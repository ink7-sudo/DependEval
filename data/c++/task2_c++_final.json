[
    {
        "files": [
            "'scop_vulkan/libraries/vulkan_renderer/public/VulkanInstance.hpp'",
            "'scop_vulkan/libraries/vulkan_renderer/private/VulkanSync.cpp'",
            "'scop_vulkan/libraries/vulkan_renderer/public/VulkanSync.hpp'"
        ],
        "content": "'scop_vulkan/libraries/vulkan_renderer/public/VulkanInstance.hpp'\n:#ifndef SCOP_VULKAN_VULKANINSTANCE_HPP\n#define SCOP_VULKAN_VULKANINSTANCE_HPP\n\n#include <string>\n#include <vector>\n\n#include <vulkan/vulkan.h>\n\nclass VulkanInstance final\n{\n  public:\n    VulkanInstance() = default;\n    ~VulkanInstance() = default;\n    VulkanInstance(VulkanInstance const &src) = delete;\n    VulkanInstance &operator=(VulkanInstance const &rhs) = delete;\n    VulkanInstance(VulkanInstance &&src) = delete;\n    VulkanInstance &operator=(VulkanInstance &&rhs) = delete;\n\n    static VkInstance createInstance(\n      std::string const &app_name,\n      std::string const &engine_name,\n      uint32_t app_version,\n      uint32_t engine_version,\n      std::vector<char const *> &&required_extensions);\n    void init(VkSurfaceKHR windowSurface);\n    void clear();\n\n    VkInstance instance{};\n    VkSurfaceKHR surface{};\n    VkDebugUtilsMessengerEXT debugMessenger{};\n    VkPhysicalDevice physicalDevice{};\n    VkDevice device{};\n    char deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]{};\n    VkQueue graphicQueue{};\n    uint32_t graphicQueueIndex{};\n    VkQueue presentQueue{};\n    uint32_t presentQueueIndex{};\n    VkCommandPool modelCommandPool{};\n\n  private:\n    inline void _setup_vk_debug_msg();\n    inline void _select_physical_device();\n    inline void _create_present_and_graphic_queue();\n\n\n    static inline bool _check_validation_layer_support();\n};\n\n#endif\n\n'scop_vulkan/libraries/vulkan_renderer/private/VulkanSync.cpp'\n:#include \"VulkanSync.hpp\"\n\n#include <stdexcept>\n\nvoid\nVulkanSync::init(VulkanInstance const &vkInstance, uint32_t nbFramebufferImgs)\n{\n    _device = vkInstance.device;\n    imageAvailableSem.resize(MAX_FRAME_INFLIGHT);\n    modelRenderFinishedSem.resize(MAX_FRAME_INFLIGHT);\n    uiRenderFinishedSem.resize(MAX_FRAME_INFLIGHT);\n    inflightFence.resize(MAX_FRAME_INFLIGHT);\n    imgsInflightFence.resize(nbFramebufferImgs, VK_NULL_HANDLE);\n\n    VkSemaphoreCreateInfo sem_info{};\n    sem_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;\n\n    VkFenceCreateInfo fence_info{};\n    fence_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;\n    fence_info.flags = VK_FENCE_CREATE_SIGNALED_BIT;\n\n    for (size_t i = 0; i < MAX_FRAME_INFLIGHT; ++i) {\n        if (vkCreateSemaphore(\n              _device, &sem_info, nullptr, &imageAvailableSem[i]) !=\n              VK_SUCCESS ||\n            vkCreateSemaphore(\n              _device, &sem_info, nullptr, &modelRenderFinishedSem[i]) !=\n              VK_SUCCESS ||\n            vkCreateSemaphore(\n              _device, &sem_info, nullptr, &uiRenderFinishedSem[i]) !=\n              VK_SUCCESS ||\n            vkCreateFence(_device, &fence_info, nullptr, &inflightFence[i]) !=\n              VK_SUCCESS) {\n            throw std::runtime_error(\"VulkanSync: failed to create semaphores\");\n        }\n    }\n}\n\nvoid\nVulkanSync::resize(uint32_t nbFramebufferImgs)\n{\n    imgsInflightFence.resize(nbFramebufferImgs, VK_NULL_HANDLE);\n}\n\nvoid\nVulkanSync::clear()\n{\n    for (size_t i = 0; i < MAX_FRAME_INFLIGHT; ++i) {\n        vkDestroySemaphore(_device, imageAvailableSem[i], nullptr);\n        vkDestroySemaphore(_device, modelRenderFinishedSem[i], nullptr);\n        vkDestroySemaphore(_device, uiRenderFinishedSem[i], nullptr);\n        vkDestroyFence(_device, inflightFence[i], nullptr);\n    }\n}\n'scop_vulkan/libraries/vulkan_renderer/public/VulkanSync.hpp'\n:#ifndef SCOP_VULKAN_VULKANSYNC_HPP\n#define SCOP_VULKAN_VULKANSYNC_HPP\n\n#include <vector>\n\n#include <vulkan/vulkan.h>\n\n#include \"VulkanInstance.hpp\"\n#include <VulkanSwapChain.hpp>\n\nclass VulkanSync\n{\n  public:\n    VulkanSync() = default;\n    ~VulkanSync() = default;\n    VulkanSync(VulkanSync const &src) = delete;\n    VulkanSync &operator=(VulkanSync const &rhs) = delete;\n    VulkanSync(VulkanSync &&src) = delete;\n    VulkanSync &operator=(VulkanSync &&rhs) = delete;\n\n    void init(VulkanInstance const &vkInstance, uint32_t nbFramebufferImgs);\n    void resize(uint32_t nbFramebufferImgs);\n    void clear();\n\n    static constexpr size_t const MAX_FRAME_INFLIGHT = 2;\n\n    size_t currentFrame{};\n    std::vector<VkSemaphore> imageAvailableSem;\n    std::vector<VkSemaphore> modelRenderFinishedSem;\n    std::vector<VkSemaphore> uiRenderFinishedSem;\n    std::vector<VkFence> inflightFence;\n    std::vector<VkFence> imgsInflightFence;\n\n  private:\n    VkDevice _device{};\n};\n\n#endif\n",
        "gt": [
            "'scop_vulkan/libraries/vulkan_renderer/public/VulkanInstance.hpp'",
            "'scop_vulkan/libraries/vulkan_renderer/public/VulkanSync.hpp'",
            "'scop_vulkan/libraries/vulkan_renderer/private/VulkanSync.cpp'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/SymbolVersionAuxRequirement.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/SymbolVersionAux.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF.hpp'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'\n:\n#ifndef LIEF_TO_JSON_H\n#define LIEF_TO_JSON_H\n\n#include \"LIEF/config.h\"\n\n#ifdef LIEF_JSON_SUPPORT\n\n\n#ifdef LIEF_ELF_SUPPORT\n#include \"LIEF/ELF/json.hpp\"\n#endif\n\n#ifdef LIEF_PE_SUPPORT\n#include \"LIEF/PE/json.hpp\"\n#endif\n\n#include \"LIEF/Abstract/json.hpp\"\n\n#include \"LIEF/Abstract.hpp\"\n#include \"LIEF/ELF.hpp\"\n#include \"LIEF/PE.hpp\"\n\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/SymbolVersionAuxRequirement.hpp'\n:\n#ifndef LIEF_ELF_SYMBOL_VERSION_AUX_REQUIREMENT_H\n#define LIEF_ELF_SYMBOL_VERSION_AUX_REQUIREMENT_H\n\n#include <string>\n#include <ostream>\n\n#include \"LIEF/visibility.h\"\n#include \"LIEF/iterators.hpp\"\n\n#include \"LIEF/ELF/SymbolVersionAux.hpp\"\n\nnamespace LIEF {\nnamespace ELF {\nnamespace details {\nstruct Elf64_Vernaux;\nstruct Elf32_Vernaux;\n}\n\nclass LIEF_API SymbolVersionAuxRequirement : public SymbolVersionAux {\n  public:\n  using SymbolVersionAux::name;\n\n  SymbolVersionAuxRequirement(const details::Elf64_Vernaux& header);\n  SymbolVersionAuxRequirement(const details::Elf32_Vernaux& header);\n  SymbolVersionAuxRequirement();\n\n  SymbolVersionAuxRequirement& operator=(const SymbolVersionAuxRequirement&);\n  SymbolVersionAuxRequirement(const SymbolVersionAuxRequirement&);\n\n  virtual ~SymbolVersionAuxRequirement();\n\n\n  uint32_t hash() const;\n\n\n  uint16_t flags() const;\n\n\n\n\n\n  uint16_t other() const;\n\n  void hash(uint32_t hash);\n  void flags(uint16_t flags);\n  void other(uint16_t other);\n\n  void accept(Visitor& visitor) const override;\n\n  bool operator==(const SymbolVersionAuxRequirement& rhs) const;\n  bool operator!=(const SymbolVersionAuxRequirement& rhs) const;\n\n  LIEF_API friend std::ostream& operator<<(std::ostream& os, const SymbolVersionAuxRequirement& symAux);\n\n  private:\n  uint32_t hash_ = 0;\n  uint16_t flags_ = 0;\n  uint16_t other_ = 0;\n};\n}\n}\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/SymbolVersionAux.hpp'\n:\n#ifndef LIEF_ELF_SYMBOL_VERSION_AUX_H\n#define LIEF_ELF_SYMBOL_VERSION_AUX_H\n\n#include <string>\n#include <ostream>\n\n#include \"LIEF/Object.hpp\"\n#include \"LIEF/visibility.h\"\n\nnamespace LIEF {\nnamespace ELF {\nclass Parser;\n\n\nclass LIEF_API SymbolVersionAux : public Object {\n  friend class Parser;\n  public:\n  SymbolVersionAux(std::string name);\n  SymbolVersionAux();\n  virtual ~SymbolVersionAux();\n\n  SymbolVersionAux& operator=(const SymbolVersionAux&);\n  SymbolVersionAux(const SymbolVersionAux&);\n\n\n  const std::string& name() const;\n\n  void name(const std::string& name);\n\n  void accept(Visitor& visitor) const override;\n\n  bool operator==(const SymbolVersionAux& rhs) const;\n  bool operator!=(const SymbolVersionAux& rhs) const;\n\n  LIEF_API friend std::ostream& operator<<(std::ostream& os, const SymbolVersionAux& symAux);\n\n  protected:\n  std::string name_;\n};\n\n}\n}\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF.hpp'\n:\n#ifndef LIEF_ELF_H\n#define LIEF_ELF_H\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_ELF_SUPPORT)\n#include \"LIEF/ELF/hash.hpp\"\n#include \"LIEF/ELF/utils.hpp\"\n#include \"LIEF/ELF/enums.hpp\"\n\n#include \"LIEF/ELF/Parser.hpp\"\n#include \"LIEF/ELF/Header.hpp\"\n#include \"LIEF/ELF/Section.hpp\"\n#include \"LIEF/ELF/Binary.hpp\"\n#include \"LIEF/ELF/Segment.hpp\"\n#include \"LIEF/ELF/Builder.hpp\"\n#include \"LIEF/ELF/EnumToString.hpp\"\n#include \"LIEF/ELF/Relocation.hpp\"\n#include \"LIEF/ELF/DynamicEntryArray.hpp\"\n#include \"LIEF/ELF/DynamicEntryFlags.hpp\"\n#include \"LIEF/ELF/DynamicEntry.hpp\"\n#include \"LIEF/ELF/DynamicEntryLibrary.hpp\"\n#include \"LIEF/ELF/DynamicEntryRpath.hpp\"\n#include \"LIEF/ELF/DynamicEntryRunPath.hpp\"\n#include \"LIEF/ELF/DynamicSharedObject.hpp\"\n#include \"LIEF/ELF/GnuHash.hpp\"\n#include \"LIEF/ELF/Note.hpp\"\n#include \"LIEF/ELF/RelocationSizes.hpp\"\n#include \"LIEF/ELF/Symbol.hpp\"\n#include \"LIEF/ELF/SymbolVersion.hpp\"\n#include \"LIEF/ELF/SymbolVersionAux.hpp\"\n#include \"LIEF/ELF/SymbolVersionAuxRequirement.hpp\"\n#include \"LIEF/ELF/SymbolVersionDefinition.hpp\"\n#include \"LIEF/ELF/SymbolVersionRequirement.hpp\"\n#include \"LIEF/ELF/SysvHash.hpp\"\n\n#include \"LIEF/ELF/NoteDetails/AndroidNote.hpp\"\n#include \"LIEF/ELF/NoteDetails/NoteAbi.hpp\"\n#include \"LIEF/ELF/NoteDetails/Core.hpp\"\n#include \"LIEF/ELF/NoteDetails.hpp\"\n#endif\n\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/SymbolVersionAux.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/SymbolVersionAuxRequirement.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'"
        ]
    },
    {
        "files": [
            "'webpp/sdk/wsdk/cmds/command_options.hpp'",
            "'webpp/webpp/std/span.hpp'",
            "'webpp/sdk/wsdk/cmds/command.hpp'",
            "'webpp/sdk/wpp/main.cpp'"
        ],
        "content": "'webpp/sdk/wsdk/cmds/command_options.hpp'\n:\n\n#ifndef WEBPP_COMMAND_OPTIONS_HPP\n#define WEBPP_COMMAND_OPTIONS_HPP\n\n#include <webpp/logs/dynamic_logger.hpp>\n#include <webpp/std/memory.hpp>\n#include <webpp/std/span.hpp>\n#include <webpp/strings/string_tokenizer.hpp>\n\nnamespace webpp::sdk {\n\n    struct global_options {\n        enum verbosity {\n            normal,\n            moderate,\n            debug\n        } verbose = normal;\n    };\n\n    using row_view = stl::span<stl::pair<stl::string_view, stl::string_view> const>;\n\n    struct output_port {\n        output_port()                                       = default;\n        output_port(output_port const&) noexcept            = default;\n        output_port(output_port&&) noexcept                 = default;\n        output_port& operator=(output_port const&) noexcept = default;\n        output_port& operator=(output_port&&) noexcept      = default;\n\n        virtual ~output_port() = default;\n\n        virtual void notify(stl::string_view)                    = 0;\n        virtual void send_table(stl::string_view name, row_view) = 0;\n\n        template <istl::StringViewifiable StrT>\n        output_port& operator<<(StrT&& str) {\n            notify(istl::string_viewify(stl::forward<StrT>(str)));\n            return *this;\n        }\n    };\n\n    struct stdout_output_port final : output_port {\n        void notify(stl::string_view name) override;\n        void send_table(stl::string_view name, row_view rows) override;\n    };\n\n    static constexpr charset WHITESPACES{' ', '\\t', '\\n', '\\r'};\n\n    struct command_options {\n        using tokenizer_type = string_tokenizer<>;\n\n        explicit command_options(\n          stl::string_view const       command,\n          stl::shared_ptr<output_port> inp_out    = stl::make_shared<stdout_output_port>(),\n          dynamic_logger               inp_logger = {})\n          : m_tokenizer{command},\n            m_output{stl::move(inp_out)},\n            m_logger{stl::move(inp_logger)} {}\n\n        command_options(command_options&&) noexcept            = default;\n        command_options(command_options const&)                = delete;\n        command_options& operator=(command_options const&)     = delete;\n        command_options& operator=(command_options&&) noexcept = default;\n        ~command_options()                                     = default;\n\n        [[nodiscard]] global_options& options() noexcept {\n            return m_options;\n        }\n\n        [[nodiscard]] tokenizer_type& tokenizer() noexcept {\n            return m_tokenizer;\n        }\n\n        output_port& output() const noexcept {\n            return *m_output;\n        }\n\n        [[nodiscard]] dynamic_logger logger() const noexcept {\n            return m_logger;\n        }\n\n      private:\n        global_options               m_options;\n        tokenizer_type               m_tokenizer;\n        stl::shared_ptr<output_port> m_output;\n        webpp::dynamic_logger        m_logger;\n    };\n\n}\n\n#endif\n\n'webpp/webpp/std/span.hpp'\n:#ifndef WEBPP_STD_SPAN_HPP\n#define WEBPP_STD_SPAN_HPP\n\n\n#include \"./std.hpp\"\n\n#include <span>\n\nnamespace webpp::istl {\n\n    template <typename>\n    struct is_span {\n        static constexpr bool value = false;\n    };\n\n    template <template <typename, stl::size_t> typename SpanT, typename T, stl::size_t Extent>\n    struct is_span<SpanT<T, Extent>> {\n        static constexpr bool value = true;\n    };\n\n    template <typename T>\n    concept is_span_v = is_span<T>::value;\n\n    template <typename T>\n    concept Span = is_span_v<T>;\n\n\n\n}\n\n#endif\n\n'webpp/sdk/wsdk/cmds/command.hpp'\n:#ifndef WEBPP_SDK_CMDS_CMD\n#define WEBPP_SDK_CMDS_CMD\n\n#include \"command_options.hpp\"\n\n#include <webpp/logs/dynamic_logger.hpp>\n#include <webpp/std/string_view.hpp>\n#include <webpp/std/vector.hpp>\n\nnamespace webpp::sdk {\n\n    enum struct command_status {\n\n        success,\n        empty_command,\n\n\n        unknown_error,\n        invalid_command\n    };\n\n\n    stl::string_view to_string(command_status status) noexcept;\n    int              to_exit_status(command_status) noexcept;\n\n    struct command {\n        command()                                   = default;\n        command(command const&)                     = delete;\n        command(command&&) noexcept                 = default;\n        command& operator=(command const&) noexcept = delete;\n        command& operator=(command&&) noexcept      = default;\n        virtual ~command()                          = default;\n\n\n        [[nodiscard]] virtual stl::string_view name() const noexcept = 0;\n\n\n        [[nodiscard]] virtual stl::string_view desc() const noexcept = 0;\n\n\n        virtual command_status start(command_options) = 0;\n    };\n\n\n    struct command_manager {\n        command_manager(stl::shared_ptr<output_port> inp_output = stl::make_shared<stdout_output_port>(),\n                        dynamic_logger               logger     = {});\n        command_manager(command_manager&&) noexcept            = default;\n        command_manager(command_manager const&)                = delete;\n        command_manager& operator=(command_manager&&) noexcept = default;\n        command_manager& operator=(command_manager const&)     = delete;\n        ~command_manager()                                     = default;\n\n\n        command_status run_command(int argc, char const** argv);\n\n\n        command_status run_command(stl::string_view);\n\n      private:\n        stl::shared_ptr<output_port> output;\n        dynamic_logger               logger;\n    };\n\n}\n\n\n#endif\n\n'webpp/sdk/wpp/main.cpp'\n:#include <webpp/logs/dynamic_logger.hpp>\n#include <webpp/std/utility.hpp>\n#include <wsdk/cmds/command.hpp>\n\ninline constexpr auto log_cat = \"main\";\n\nauto main(int argc, char const** argv) -> int {\n    using namespace webpp::sdk;\n\n    webpp::dynamic_logger const               logger;\n    webpp::stl::shared_ptr<output_port> const output = webpp::stl::make_shared<stdout_output_port>();\n    try {\n        command_manager manager{output, logger};\n        auto const      cmd_res = manager.run_command(argc, argv);\n        logger.info(log_cat, to_string(cmd_res));\n        return to_exit_status(cmd_res);\n    } catch (std::exception const& ex) {\n        logger.critical(log_cat, \"This exception has propagated to the top.\", ex);\n        return EXIT_FAILURE;\n    } catch (...) {\n        logger.critical(log_cat, \"This unknown error has propagated to the top.\");\n        return EXIT_FAILURE;\n    }\n}\n",
        "gt": [
            "'webpp/webpp/std/span.hpp'",
            "'webpp/sdk/wsdk/cmds/command_options.hpp'",
            "'webpp/sdk/wsdk/cmds/command.hpp'",
            "'webpp/sdk/wpp/main.cpp'"
        ]
    },
    {
        "files": [
            "'Birch/birch/src/type/EmptyType.hpp'",
            "'Birch/birch/src/common/ReturnTyped.cpp'",
            "'Birch/birch/src/common/ReturnTyped.hpp'"
        ],
        "content": "'Birch/birch/src/type/EmptyType.hpp'\n:\n#pragma once\n\n#include \"src/type/Type.hpp\"\n\nnamespace birch {\n\nclass EmptyType: public Type {\npublic:\n\n  EmptyType(Location* loc = nullptr);\n\n  virtual void accept(Visitor* visitor) const;\n\n  virtual bool isEmpty() const;\n};\n}\n\n'Birch/birch/src/common/ReturnTyped.cpp'\n:\n#include \"src/common/ReturnTyped.hpp\"\n\nbirch::ReturnTyped::ReturnTyped(Type* returnType) :\n    returnType(returnType) {\n\n}\n\n'Birch/birch/src/common/ReturnTyped.hpp'\n:\n#pragma once\n\n#include \"src/type/Type.hpp\"\n#include \"src/type/EmptyType.hpp\"\n\nnamespace birch {\n\nclass ReturnTyped {\npublic:\n\n  ReturnTyped(Type* returnType);\n\n\n  Type* returnType;\n};\n}\n",
        "gt": [
            "'Birch/birch/src/type/EmptyType.hpp'",
            "'Birch/birch/src/common/ReturnTyped.hpp'",
            "'Birch/birch/src/common/ReturnTyped.cpp'"
        ]
    },
    {
        "files": [
            "'sigviewer/src/commands/open_file_command.cpp'",
            "'sigviewer/src/file_handling_impl/gdf/gdf_file_signal_reader.h'",
            "'sigviewer/src/file_handling_impl/gdf/gdf_data_block.h'",
            "'sigviewer/src/file_handling/file_signal_reader_factory.h'"
        ],
        "content": "'sigviewer/src/commands/open_file_command.cpp'\n:\n\n\n\n\n#include \"open_file_command.h\"\n\n#include \"file_handling/file_signal_reader_factory.h\"\n#include \"file_handling_impl/channel_manager_impl.h\"\n#include \"file_handling_impl/event_manager_impl.h\"\n\n#include <QDir>\n\nnamespace sigviewer\n{\n\n\nQString OpenFileCommand::execute ()\n{\n    QString file_path = QDir::toNativeSeparators (filename_and_path_);\n    FileSignalReader* file_signal_reader (FileSignalReaderFactory::getInstance()->getHandler (file_path));\n    if (file_signal_reader == 0)\n        return QObject::tr(\"Can't open file %1\").arg(file_path);\n\n    ChannelManager* channel_manager (new ChannelManagerImpl (file_signal_reader));\n    QSharedPointer<EventManager> event_manager (new EventManagerImpl (*file_signal_reader));\n    QSharedPointer<FileContext> file_context (new FileContext (file_path, event_manager,\n                                                 channel_manager, file_signal_reader->getBasicHeader()));\n    application_context_->addFileContext (file_context);\n    return \"\";\n}\n\n}\n\n'sigviewer/src/file_handling_impl/gdf/gdf_file_signal_reader.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef GDF_FILE_SIGNAL_READER_H\n#define GDF_FILE_SIGNAL_READER_H\n\n#include \"file_handling/file_signal_reader.h\"\n#include \"gdf_basic_header.h\"\n#include \"gdf_signal_cache.h\"\n#include \"gdf_data_block.h\"\n#include \"../down_sampling_thread.h\"\n\n#include \"GDF/Reader.h\"\n\n#include <QObject>\n\nnamespace SigViewer_\n{\n\n\nclass GDFFileSignalReader : public QObject, public FileSignalReader\n{\n    Q_OBJECT\npublic:\n\n    GDFFileSignalReader ();\n\n\n    virtual ~GDFFileSignalReader();\n\n\n    QPair<FileSignalReader*, QString> createInstance (QString const& file_path);\n\n\n    virtual QSharedPointer<DataBlock const> getSignalData (ChannelID channel_id,\n                                                           unsigned start_sample,\n                                                           unsigned length) const;\n\n\n    virtual QList<QSharedPointer<SignalEvent const> > getEvents () const;\n\n\n    virtual QSharedPointer<BasicHeader> getBasicHeader ();\n\n\n    virtual QSharedPointer<BasicHeader const> getBasicHeader () const {return header_;}\n\nprivate:\n\n    QString open (QString const& file_path);\n\n    Q_DISABLE_COPY(GDFFileSignalReader)\n\n\n    gdf::Reader* reader_;\n    mutable DownSamplingThread* downsampling_thread_;\n\n    QSharedPointer<GDFSignalCache> cache_;\n    QSharedPointer<GDFBasicHeader> header_;\n    mutable QMap<ChannelID, QSharedPointer<GDFDataBlock> > channel_map_;\n    mutable QList<QSharedPointer<SignalEvent const> > events_;\n};\n\n}\n\n#endif\n\n'sigviewer/src/file_handling_impl/gdf/gdf_data_block.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef GDF_DATA_BLOCK_H\n#define GDF_DATA_BLOCK_H\n\n#include \"base/data_block.h\"\n#include \"gdf_signal_cache.h\"\n\n#include \"GDF/Reader.h\"\n\n#include <QVector>\n#include <QSharedPointer>\n\nnamespace SigViewer_\n{\n\n\nclass GDFDataBlock : public DataBlock\n{\npublic:\n\n    GDFDataBlock (QSharedPointer<GDFSignalCache> cache, ChannelID channel, unsigned length, float32 sample_rate);\n\n\n    virtual ~GDFDataBlock ();\n\n\n    virtual QSharedPointer<DataBlock> createSubBlock (uint32 start, uint32 length) const;\n\n\n    virtual float32 const& operator[] (uint32 index) const;\n\n\n    virtual float32 getMin () const;\n\n\n    virtual float32 getMax () const;\n\n\n    void addDownSampledVersion (QSharedPointer<DataBlock> data, unsigned downsampling_factor);\n\n\n    std::pair<QSharedPointer<DataBlock>, unsigned> getNearbyDownsampledBlock (unsigned downsampling_factor) const;\n\nprivate:\n\n    GDFDataBlock (GDFDataBlock const& src, unsigned start_sample, unsigned length);\n\n\n    Q_DISABLE_COPY (GDFDataBlock);\n\n\n    ChannelID channel_;\n    unsigned start_sample_;\n    mutable float32 current_min_;\n    mutable float32 current_max_;\n    mutable float32 current_value_;\n\n    QMap<unsigned, QSharedPointer<DataBlock> > downsampled_map_;\n\n    mutable QSharedPointer<GDFSignalCache> cache_;\n};\n\n}\n\n#endif\n\n'sigviewer/src/file_handling/file_signal_reader_factory.h'\n:\n\n\n\n\n\n\n#ifndef FILE_SIGNAL_READER_FACTORY_H\n#define FILE_SIGNAL_READER_FACTORY_H\n\n#include \"file_handler_factory.h\"\n#include \"file_signal_reader.h\"\n\n#include <QString>\n#include <map>\n#include <memory>\n\nnamespace sigviewer\n{\n\n\n\nclass FileSignalReaderFactory : public FileHandlerFactory<FileSignalReader>\n{\npublic:\n    static FileSignalReaderFactory* getInstance ();\n};\n\n}\n#endif\n",
        "gt": [
            "'sigviewer/src/file_handling_impl/gdf/gdf_data_block.h'",
            "'sigviewer/src/file_handling_impl/gdf/gdf_file_signal_reader.h'",
            "'sigviewer/src/file_handling/file_signal_reader_factory.h'",
            "'sigviewer/src/commands/open_file_command.cpp'"
        ]
    },
    {
        "files": [
            "'porla/src/methods/plugins/pluginsuninstall.cpp'",
            "'porla/src/methods/plugins/pluginsuninstall.hpp'",
            "'porla/src/methods/plugins/pluginsuninstall_reqres.hpp'"
        ],
        "content": "'porla/src/methods/plugins/pluginsuninstall.cpp'\n:#include \"pluginsuninstall.hpp\"\n\n#include <boost/log/trivial.hpp>\n#include <git2.h>\n\n#include \"../../lua/plugin.hpp\"\n#include \"../../lua/pluginengine.hpp\"\n\nusing porla::Lua::PluginEngine;\nusing porla::Lua::PluginInstallOptions;\n\nusing porla::Methods::PluginsUninstall;\nusing porla::Methods::PluginsUninstallReq;\nusing porla::Methods::PluginsUninstallRes;\n\nPluginsUninstall::PluginsUninstall(PluginEngine& plugin_engine)\n    : m_plugin_engine(plugin_engine)\n{\n}\n\nvoid PluginsUninstall::Invoke(const PluginsUninstallReq& req, WriteCb<PluginsUninstallRes> cb)\n{\n    auto plugin = m_plugin_engine.Plugins().find(req.name);\n\n    if (plugin == m_plugin_engine.Plugins().end())\n    {\n        return cb.Error(-1, \"Plugin not found\");\n    }\n\n    const auto plugin_path = plugin->second.path;\n    const auto is_repository = git_repository_open_ext(\n        nullptr,\n        plugin_path.c_str(),\n        GIT_REPOSITORY_OPEN_NO_SEARCH,\n        nullptr) == GIT_OK;\n\n    std::error_code ec;\n    m_plugin_engine.Uninstall(req.name, ec);\n\n    if (ec)\n    {\n        return cb.Error(-1, \"Failed to uninstall plugin\");\n    }\n\n    if (is_repository)\n    {\n        BOOST_LOG_TRIVIAL(info) << \"Plugin was a Git repository - removing plugin dir\";\n        fs::remove_all(plugin_path, ec);\n\n        if (ec)\n        {\n            BOOST_LOG_TRIVIAL(error) << \"Failed to remove plugin directory: \" << ec.message();\n            return cb.Error(-2, \"Plugin was uninstalled, but plugin directory could not be removed\");\n        }\n    }\n\n    cb.Ok({});\n}\n\n'porla/src/methods/plugins/pluginsuninstall.hpp'\n:#pragma once\n\n#include \"../method.hpp\"\n#include \"pluginsuninstall_reqres.hpp\"\n\nnamespace porla::Lua\n{\n    class PluginEngine;\n}\n\nnamespace porla::Methods\n{\n    class PluginsUninstall : public Method<PluginsUninstallReq, PluginsUninstallRes>\n    {\n    public:\n        explicit PluginsUninstall(porla::Lua::PluginEngine& plugin_engine);\n\n    protected:\n        void Invoke(const PluginsUninstallReq& req, WriteCb<PluginsUninstallRes> cb) override;\n\n    private:\n        porla::Lua::PluginEngine& m_plugin_engine;\n    };\n}\n\n'porla/src/methods/plugins/pluginsuninstall_reqres.hpp'\n:#pragma once\n\n#include <map>\n#include <string>\n\nnamespace porla::Methods\n{\n    struct PluginsUninstallReq\n    {\n        std::string name;\n    };\n\n    struct PluginsUninstallRes\n    {\n    };\n}\n",
        "gt": [
            "'porla/src/methods/plugins/pluginsuninstall_reqres.hpp'",
            "'porla/src/methods/plugins/pluginsuninstall.hpp'",
            "'porla/src/methods/plugins/pluginsuninstall.cpp'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO/Relocation.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/Abstract/Relocation.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO.hpp'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO/Relocation.hpp'\n:\n#ifndef LIEF_MACHO_RELOCATION_COMMAND_H\n#define LIEF_MACHO_RELOCATION_COMMAND_H\n#include <string>\n#include <vector>\n#include <ostream>\n#include <array>\n\n#include \"LIEF/Abstract/Relocation.hpp\"\n\n#include \"LIEF/visibility.h\"\n#include \"LIEF/types.hpp\"\n#include \"LIEF/Object.hpp\"\n\n#include \"LIEF/MachO/enums.hpp\"\n\nnamespace LIEF {\nnamespace MachO {\n\nclass BinaryParser;\n\n\n\n\n\n\n\nclass LIEF_API Relocation : public LIEF::Relocation {\n\n  friend class BinaryParser;\n\n  public:\n  using LIEF::Relocation::address;\n  using LIEF::Relocation::size;\n\n  Relocation();\n  Relocation(uint64_t address, uint8_t type);\n\n  Relocation& operator=(const Relocation& other);\n  Relocation(const Relocation& other);\n  void swap(Relocation& other);\n\n  ~Relocation() override;\n\n  virtual Relocation* clone() const = 0;\n\n\n\n\n\n\n  virtual bool is_pc_relative() const = 0;\n\n\n\n\n\n\n\n\n\n\n\n  virtual uint8_t type() const;\n\n\n  CPU_TYPES architecture() const;\n\n\n  virtual RELOCATION_ORIGINS origin() const = 0;\n\n\n  bool has_symbol() const;\n\n\n\n  Symbol* symbol();\n  const Symbol* symbol() const;\n\n\n  bool has_section() const;\n\n\n\n  Section* section();\n  const Section* section() const;\n\n\n  bool has_segment() const;\n\n\n\n  SegmentCommand* segment();\n  const SegmentCommand* segment() const;\n\n  virtual void pc_relative(bool val) = 0;\n  virtual void type(uint8_t type);\n\n  bool operator==(const Relocation& rhs) const;\n  bool operator!=(const Relocation& rhs) const;\n\n  void accept(Visitor& visitor) const override;\n\n  virtual std::ostream& print(std::ostream& os) const;\n\n  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Relocation& relocation);\n\n  protected:\n  Symbol*         symbol_ = nullptr;\n  uint8_t         type_ = 0;\n  CPU_TYPES       architecture_ = CPU_TYPES::CPU_TYPE_ANY;\n  Section*        section_ = nullptr;\n  SegmentCommand* segment_ = nullptr;\n};\n\n}\n}\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'\n:\n#ifndef LIEF_MAIN_HEADER_H\n#define LIEF_MAIN_HEADER_H\n#include <LIEF/config.h>\n\n#include <LIEF/Abstract.hpp>\n\n#include <LIEF/OAT.hpp>\n#include <LIEF/VDEX.hpp>\n#include <LIEF/ART.hpp>\n#include <LIEF/DEX.hpp>\n#include <LIEF/ELF.hpp>\n#include <LIEF/PE.hpp>\n#include <LIEF/MachO.hpp>\n#include <LIEF/DWARF.hpp>\n#include <LIEF/logging.hpp>\n#include <LIEF/platforms.hpp>\n\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/Abstract/Relocation.hpp'\n:\n#ifndef LIEF_ABSTRACT_RELOCATION_H\n#define LIEF_ABSTRACT_RELOCATION_H\n\n#include \"LIEF/types.hpp\"\n#include \"LIEF/Object.hpp\"\n#include \"LIEF/visibility.h\"\n\nnamespace LIEF {\n\nclass LIEF_API Relocation : public Object {\n\n  public:\n  Relocation();\n\n\n  Relocation(uint64_t address, uint8_t size);\n\n  virtual ~Relocation();\n\n  Relocation& operator=(const Relocation&);\n  Relocation(const Relocation&);\n  void swap(Relocation& other);\n\n\n  virtual uint64_t address() const;\n\n\n  virtual size_t size() const;\n\n  virtual void address(uint64_t address);\n  virtual void size(size_t size);\n\n\n  void accept(Visitor& visitor) const override;\n\n  bool operator==(const Relocation& rhs) const;\n  bool operator!=(const Relocation& rhs) const;\n\n\n  virtual bool operator<(const Relocation& rhs) const;\n\n\n  virtual bool operator<=(const Relocation& rhs) const;\n\n\n  virtual bool operator>(const Relocation& rhs) const;\n\n\n  virtual bool operator>=(const Relocation& rhs) const;\n\n  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Relocation& entry);\n\n  protected:\n  uint64_t address_ = 0;\n  uint8_t  size_ = 0;\n};\n\n\n}\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO.hpp'\n:\n#ifndef LIEF_MACHO_H\n#define LIEF_MACHO_H\n\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_MACHO_SUPPORT)\n\n#include \"LIEF/MachO/Binary.hpp\"\n#include \"LIEF/MachO/BinaryParser.hpp\"\n#include \"LIEF/MachO/BindingInfo.hpp\"\n#include \"LIEF/MachO/BuildVersion.hpp\"\n#include \"LIEF/MachO/Builder.hpp\"\n#include \"LIEF/MachO/ChainedBindingInfo.hpp\"\n#include \"LIEF/MachO/CodeSignature.hpp\"\n#include \"LIEF/MachO/CodeSignatureDir.hpp\"\n#include \"LIEF/MachO/DataCodeEntry.hpp\"\n#include \"LIEF/MachO/DataInCode.hpp\"\n#include \"LIEF/MachO/DyldBindingInfo.hpp\"\n#include \"LIEF/MachO/DyldChainedFixups.hpp\"\n#include \"LIEF/MachO/DyldEnvironment.hpp\"\n#include \"LIEF/MachO/DyldExportsTrie.hpp\"\n#include \"LIEF/MachO/DyldInfo.hpp\"\n#include \"LIEF/MachO/DylibCommand.hpp\"\n#include \"LIEF/MachO/DylinkerCommand.hpp\"\n#include \"LIEF/MachO/DynamicSymbolCommand.hpp\"\n#include \"LIEF/MachO/EncryptionInfo.hpp\"\n#include \"LIEF/MachO/EnumToString.hpp\"\n#include \"LIEF/MachO/ExportInfo.hpp\"\n#include \"LIEF/MachO/FatBinary.hpp\"\n#include \"LIEF/MachO/FilesetCommand.hpp\"\n#include \"LIEF/MachO/FunctionStarts.hpp\"\n#include \"LIEF/MachO/Header.hpp\"\n#include \"LIEF/MachO/LinkEdit.hpp\"\n#include \"LIEF/MachO/LinkerOptHint.hpp\"\n#include \"LIEF/MachO/LoadCommand.hpp\"\n#include \"LIEF/MachO/MainCommand.hpp\"\n#include \"LIEF/MachO/Parser.hpp\"\n#include \"LIEF/MachO/ParserConfig.hpp\"\n#include \"LIEF/MachO/RPathCommand.hpp\"\n#include \"LIEF/MachO/Relocation.hpp\"\n#include \"LIEF/MachO/RelocationDyld.hpp\"\n#include \"LIEF/MachO/RelocationFixup.hpp\"\n#include \"LIEF/MachO/RelocationObject.hpp\"\n#include \"LIEF/MachO/Section.hpp\"\n#include \"LIEF/MachO/SegmentCommand.hpp\"\n#include \"LIEF/MachO/SegmentSplitInfo.hpp\"\n#include \"LIEF/MachO/SourceVersion.hpp\"\n#include \"LIEF/MachO/SubFramework.hpp\"\n#include \"LIEF/MachO/Symbol.hpp\"\n#include \"LIEF/MachO/SymbolCommand.hpp\"\n#include \"LIEF/MachO/ThreadCommand.hpp\"\n#include \"LIEF/MachO/TwoLevelHints.hpp\"\n#include \"LIEF/MachO/UUIDCommand.hpp\"\n#include \"LIEF/MachO/VersionMin.hpp\"\n#include \"LIEF/MachO/enums.hpp\"\n#include \"LIEF/MachO/hash.hpp\"\n#include \"LIEF/MachO/json.hpp\"\n#include \"LIEF/MachO/type_traits.hpp\"\n#include \"LIEF/MachO/utils.hpp\"\n\n#endif\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/Abstract/Relocation.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO/Relocation.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'"
        ]
    },
    {
        "files": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/util/copy.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test_external/gsl/check_gsl.cpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/external/gsl/gsl_wrapper.hpp'"
        ],
        "content": "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/util/copy.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_UTIL_COPY_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_UTIL_COPY_HPP_INCLUDED\n\n\n#include <boost/range/algorithm/copy.hpp>\n\n#include <boost/utility/enable_if.hpp>\n\n#include <boost/numeric/odeint/util/detail/is_range.hpp>\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\nnamespace detail {\n\n    template< class Container1 , class Container2 >\n    void do_copying( const Container1 &from , Container2 &to , boost::mpl::true_ )\n    {\n        boost::range::copy( from , boost::begin( to ) );\n    }\n\n    template< class Container1 , class Container2 >\n    void do_copying( const Container1 &from , Container2 &to , boost::mpl::false_ )\n    {\n        to = from;\n    }\n\n}\n\n\n\ntemplate< class Container1, class Container2 , class Enabler = void >\nstruct copy_impl\n{\n    static void copy( const Container1 &from , Container2 &to )\n    {\n        typedef typename boost::numeric::odeint::detail::is_range< Container1 >::type is_range_type;\n        detail::do_copying( from , to , is_range_type() );\n    }\n};\n\ntemplate< class Container1 , class Container2 >\nvoid copy( const Container1 &from , Container2 &to )\n{\n    copy_impl< Container1 , Container2 >::copy( from , to );\n}\n\n\n}\n}\n}\n\n\n#endif\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test_external/gsl/check_gsl.cpp'\n:\n\n#define BOOST_TEST_MODULE odeint_gsl\n\n#include <gsl/gsl_vector.h>\n#include <boost/numeric/odeint/stepper/euler.hpp>\n#include <boost/numeric/odeint/external/gsl/gsl_wrapper.hpp>\n\n#include <boost/test/unit_test.hpp>\n\nusing namespace boost::unit_test;\nusing namespace boost::numeric::odeint;\n\ntypedef gsl_vector *state_type;\n\nconst double sigma = 10.0;\nconst double R = 28.0;\nconst double b = 8.0 / 3.0;\n\nvoid lorenz( const state_type x , state_type dxdt , double t )\n{\n    gsl_vector_set( dxdt , 0 , sigma * ( gsl_vector_get(x , 1 ) - gsl_vector_get( x , 0 ) ) );\n    gsl_vector_set( dxdt , 1 , R * gsl_vector_get( x , 0 ) - gsl_vector_get( x , 1 ) - gsl_vector_get( x , 0 ) * gsl_vector_get( x , 2) );\n    gsl_vector_set( dxdt , 2 , gsl_vector_get( x , 0 ) * gsl_vector_get( x , 1 ) - b * gsl_vector_get( x , 2) );\n}\n\nBOOST_AUTO_TEST_CASE( gsl )\n{\n    euler< state_type > euler;\n\n    state_type x = gsl_vector_alloc( 3 );\n    gsl_vector_set( x , 0 , 1.0);\n    gsl_vector_set( x , 1 , 1.0);\n    gsl_vector_set( x , 2 , 2.0);\n\n    euler.do_step( lorenz , x , 0.0 , 0.1 );\n\n\n\n    gsl_vector_free( x );\n\n}\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/external/gsl/gsl_wrapper.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_GSL_GSL_WRAPPER_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_GSL_GSL_WRAPPER_HPP_INCLUDED\n\n#include <new>\n\n#include <gsl/gsl_vector.h>\n\n#include <boost/type_traits/integral_constant.hpp>\n#include <boost/range.hpp>\n#include <boost/iterator/iterator_facade.hpp>\n\n\n#include <boost/numeric/odeint/util/state_wrapper.hpp>\n#include <boost/numeric/odeint/util/is_resizeable.hpp>\n#include <boost/numeric/odeint/util/copy.hpp>\n\nclass const_gsl_vector_iterator;\n\n\nclass gsl_vector_iterator : public boost::iterator_facade< gsl_vector_iterator , double , boost::random_access_traversal_tag >\n{\npublic :\n\n    gsl_vector_iterator( void ): m_p(0) , m_stride( 0 ) { }\n    explicit gsl_vector_iterator( gsl_vector *p ) : m_p( p->data ) , m_stride( p->stride ) { }\n    friend gsl_vector_iterator end_iterator( gsl_vector * );\n\nprivate :\n\n    friend class boost::iterator_core_access;\n    friend class const_gsl_vector_iterator;\n\n    void increment( void ) { m_p += m_stride; }\n    void decrement( void ) { m_p -= m_stride; }\n    void advance( ptrdiff_t n ) { m_p += n*m_stride; }\n    bool equal( const gsl_vector_iterator &other ) const { return this->m_p == other.m_p; }\n    bool equal( const const_gsl_vector_iterator &other ) const;\n    double& dereference( void ) const { return *m_p; }\n\n    double *m_p;\n    size_t m_stride;\n};\n\n\n\n\nclass const_gsl_vector_iterator : public boost::iterator_facade< const_gsl_vector_iterator , const double , boost::random_access_traversal_tag >\n{\npublic :\n\n    const_gsl_vector_iterator( void ): m_p(0) , m_stride( 0 ) { }\n    explicit const_gsl_vector_iterator( const gsl_vector *p ) : m_p( p->data ) , m_stride( p->stride ) { }\n    const_gsl_vector_iterator( const gsl_vector_iterator &p ) : m_p( p.m_p ) , m_stride( p.m_stride ) { }\n\nprivate :\n\n    friend class boost::iterator_core_access;\n    friend class gsl_vector_iterator;\n    friend const_gsl_vector_iterator end_iterator( const gsl_vector * );\n\n    void increment( void ) { m_p += m_stride; }\n    void decrement( void ) { m_p -= m_stride; }\n    void advance( ptrdiff_t n ) { m_p += n*m_stride; }\n    bool equal( const const_gsl_vector_iterator &other ) const { return this->m_p == other.m_p; }\n    bool equal( const gsl_vector_iterator &other ) const { return this->m_p == other.m_p; }\n    const double& dereference( void ) const { return *m_p; }\n\n    const double *m_p;\n    size_t m_stride;\n};\n\n\nbool gsl_vector_iterator::equal( const const_gsl_vector_iterator &other ) const { return this->m_p == other.m_p; }\n\n\ngsl_vector_iterator end_iterator( gsl_vector *x )\n{\n    gsl_vector_iterator iter( x );\n    iter.m_p += iter.m_stride * x->size;\n    return iter;\n}\n\nconst_gsl_vector_iterator end_iterator( const gsl_vector *x )\n{\n    const_gsl_vector_iterator iter( x );\n    iter.m_p += iter.m_stride * x->size;\n    return iter;\n}\n\n\n\n\nnamespace boost\n{\ntemplate<>\nstruct range_mutable_iterator< gsl_vector* >\n{\n    typedef gsl_vector_iterator type;\n};\n\ntemplate<>\nstruct range_const_iterator< gsl_vector* >\n{\n    typedef const_gsl_vector_iterator type;\n};\n}\n\n\n\n\n\ninline gsl_vector_iterator range_begin( gsl_vector *x )\n{\n    return gsl_vector_iterator( x );\n}\n\n\ninline const_gsl_vector_iterator range_begin( const gsl_vector *x )\n{\n    return const_gsl_vector_iterator( x );\n}\n\n\ninline gsl_vector_iterator range_end( gsl_vector *x )\n{\n    return end_iterator( x );\n}\n\n\ninline const_gsl_vector_iterator range_end( const gsl_vector *x )\n{\n    return end_iterator( x );\n}\n\n\n\n\n\n\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\n\ntemplate<>\nstruct is_resizeable< gsl_vector* >\n{\n\n    typedef boost::true_type type;\n    const static bool value = type::value;\n};\n\ntemplate <>\nstruct same_size_impl< gsl_vector* , gsl_vector* >\n{\n    static bool same_size( const gsl_vector* x , const gsl_vector* y )\n    {\n        return x->size == y->size;\n    }\n};\n\ntemplate <>\nstruct resize_impl< gsl_vector* , gsl_vector* >\n{\n    static void resize( gsl_vector* x , const gsl_vector* y )\n    {\n        gsl_vector_free( x );\n        x = gsl_vector_alloc( y->size );\n    }\n};\n\ntemplate<>\nstruct state_wrapper< gsl_vector* >\n{\n    typedef double value_type;\n    typedef gsl_vector* state_type;\n    typedef state_wrapper< gsl_vector* > state_wrapper_type;\n\n    state_type m_v;\n\n    state_wrapper( )\n    {\n        m_v = gsl_vector_alloc( 1 );\n    }\n\n    state_wrapper( const state_wrapper_type &x )\n    {\n        resize( m_v , x.m_v );\n        gsl_vector_memcpy( m_v , x.m_v );\n    }\n\n\n    ~state_wrapper()\n    {\n        gsl_vector_free( m_v );\n    }\n\n};\n\n}\n}\n}\n\n\n\n\n#endif\n",
        "gt": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/util/copy.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/external/gsl/gsl_wrapper.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test_external/gsl/check_gsl.cpp'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/EnumToString.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/VDEX.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/Type.hpp'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/EnumToString.hpp'\n:\n#ifndef LIEF_DEX_ENUM_TO_STRING_H\n#define LIEF_DEX_ENUM_TO_STRING_H\n#include \"LIEF/visibility.h\"\n#include \"LIEF/DEX/enums.hpp\"\n#include \"LIEF/DEX/MapItem.hpp\"\n#include \"LIEF/DEX/Type.hpp\"\n\nnamespace LIEF {\nnamespace DEX {\n\nLIEF_API const char* to_string(MapItem::TYPES e);\nLIEF_API const char* to_string(ACCESS_FLAGS e);\nLIEF_API const char* to_string(Type::TYPES e);\nLIEF_API const char* to_string(Type::PRIMITIVES e);\n\n}\n}\n\n#endif\n\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'\n:\n#ifndef LIEF_DEX_H\n#define LIEF_DEX_H\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_DEX_SUPPORT)\n#include \"LIEF/DEX/Parser.hpp\"\n#include \"LIEF/DEX/utils.hpp\"\n#include \"LIEF/DEX/File.hpp\"\n#include \"LIEF/DEX/Class.hpp\"\n#include \"LIEF/DEX/Prototype.hpp\"\n#include \"LIEF/DEX/Header.hpp\"\n#include \"LIEF/DEX/Method.hpp\"\n#include \"LIEF/DEX/Field.hpp\"\n#include \"LIEF/DEX/EnumToString.hpp\"\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'\n:\n#ifndef LIEF_MAIN_HEADER_H\n#define LIEF_MAIN_HEADER_H\n#include <LIEF/config.h>\n\n#include <LIEF/Abstract.hpp>\n\n#include <LIEF/OAT.hpp>\n#include <LIEF/VDEX.hpp>\n#include <LIEF/ART.hpp>\n#include <LIEF/DEX.hpp>\n#include <LIEF/ELF.hpp>\n#include <LIEF/PE.hpp>\n#include <LIEF/MachO.hpp>\n#include <LIEF/DWARF.hpp>\n#include <LIEF/logging.hpp>\n#include <LIEF/platforms.hpp>\n\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/VDEX.hpp'\n:\n#ifndef LIEF_VDEX_H\n#define LIEF_VDEX_H\n\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_VDEX_SUPPORT)\n#if !defined(LIEF_DEX_SUPPORT)\n#error \"The VDEX module can't be used without the DEX support\"\n#endif\n#include \"LIEF/DEX.hpp\"\n#include \"LIEF/VDEX/Parser.hpp\"\n#include \"LIEF/VDEX/utils.hpp\"\n#include \"LIEF/VDEX/File.hpp\"\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/Type.hpp'\n:\n#ifndef LIEF_DEX_TYPE_H\n#define LIEF_DEX_TYPE_H\n\n#include <vector>\n#include <string>\n#include <ostream>\n\n#include \"LIEF/visibility.h\"\n#include \"LIEF/Object.hpp\"\n\nnamespace LIEF {\nnamespace DEX {\nclass Parser;\nclass Class;\n\n\n\nclass LIEF_API Type : public Object {\n  friend class Parser;\n\n  public:\n  enum class TYPES {\n    UNKNOWN   = 0,\n    PRIMITIVE = 1,\n    CLASS     = 2,\n    ARRAY     = 3,\n  };\n\n  enum class PRIMITIVES {\n    VOID_T  = 0x01,\n    BOOLEAN = 0x02,\n    BYTE    = 0x03,\n    SHORT   = 0x04,\n    CHAR    = 0x05,\n    INT     = 0x06,\n    LONG    = 0x07,\n    FLOAT   = 0x08,\n    DOUBLE  = 0x09,\n  };\n\n  using array_t = std::vector<Type>;\n\n  public:\n  static std::string pretty_name(PRIMITIVES p);\n\n  public:\n  Type();\n  Type(const std::string& mangled);\n  Type(const Type& other);\n\n\n  TYPES type() const;\n\n  const Class& cls() const;\n  const array_t& array() const;\n  const PRIMITIVES& primitive() const;\n\n\n\n  Class& cls();\n\n\n\n  array_t& array();\n\n\n\n  PRIMITIVES& primitive();\n\n\n\n  size_t dim() const;\n\n\n  const Type& underlying_array_type() const;\n  Type& underlying_array_type();\n\n  void accept(Visitor& visitor) const override;\n\n  bool operator==(const Type& rhs) const;\n  bool operator!=(const Type& rhs) const;\n\n  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Type& type);\n\n  virtual ~Type();\n\n  private:\n  void parse(const std::string& type);\n\n  TYPES type_{TYPES::UNKNOWN};\n  union {\n    Class* cls_{nullptr};\n    array_t* array_;\n    PRIMITIVES* basic_;\n  };\n};\n\n}\n}\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/Type.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/EnumToString.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/VDEX.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'"
        ]
    },
    {
        "files": [
            "'jeayeson/include/jeayeson/jeayeson.hpp'",
            "'jeayeson/test/include/parser/number.hpp'",
            "'jeayeson/test/src/parser/main.cpp'"
        ],
        "content": "'jeayeson/include/jeayeson/jeayeson.hpp'\n:value.hpp\n'jeayeson/test/include/parser/number.hpp'\n:\n\n#include <jeayeson/jeayeson.hpp>\n#include <jest/jest.hpp>\n\nnamespace jeayeson\n{\n  struct number_test{};\n  using number_group = jest::group<number_test>;\n  static number_group const number_obj{ \"number\" };\n}\n\nnamespace jest\n{\n  template <> template <>\n  void jeayeson::number_group::test<0>()\n  {\n    json_map const map{ R\"raw({\"foo\":42, \"bar\":-193847, \"zero\": 0})raw\" };\n    expect_equal(map.get<json_int>(\"foo\"), 42);\n    expect_equal(map.get<json_int>(\"bar\"), -193847);\n    expect_equal(map.get<json_int>(\"zero\"), 0);\n\n    json_array const arr{ json_data{ R\"raw([42, -193847, 0])raw\" } };\n    expect_equal(arr.get<json_int>(0), 42);\n    expect_equal(arr.get<json_int>(1), -193847);\n    expect_equal(arr.get<json_int>(2), 0);\n  }\n\n  template <> template <>\n  void jeayeson::number_group::test<1>()\n  {\n    json_map const map{ R\"raw({\"foo\":42.42, \"bar\":-193847.07, \"zero\":-0.0})raw\" };\n    expect_almost_equal(map.get<json_float>(\"foo\"), 42.42);\n    expect_almost_equal(map.get<json_float>(\"bar\"), -193847.07);\n    expect_almost_equal(map.get<json_float>(\"zero\"), 0.0);\n\n    json_array const arr{ json_data{ R\"raw([42.42, -193847.07, -0.0])raw\" } };\n    expect_almost_equal(arr.get<json_float>(0), 42.42);\n    expect_almost_equal(arr.get<json_float>(1), -193847.07);\n    expect_almost_equal(arr.get<json_float>(2), 0.0);\n  }\n\n  template <> template <>\n  void jeayeson::number_group::test<2>()\n  {\n    json_map const map\n    { R\"raw({\"foo\":1.1e10, \"bar\":7.07e+15, \"zero\":2.123e-3})raw\" };\n    expect_almost_equal(map.get<json_float>(\"foo\"), 1.1e10);\n    expect_almost_equal(map.get<json_float>(\"bar\"), 7.07e+15);\n    expect_almost_equal(map.get<json_float>(\"zero\"), 2.123e-3);\n\n    json_array const arr\n    { json_data{ R\"raw([1.1e10, 7.07e+15, 2.123e-3])raw\" } };\n    expect_almost_equal(arr.get<json_float>(0), 1.1e10);\n    expect_almost_equal(arr.get<json_float>(1), 7.07e+15);\n    expect_almost_equal(arr.get<json_float>(2), 2.123e-3);\n  }\n\n  template <> template <>\n  void jeayeson::number_group::test<3>()\n  {\n    json_map const map\n    { R\"raw({\"foo\":1.1E10, \"bar\":7.07E+15, \"zero\":2.123E-3})raw\" };\n    expect_almost_equal(map.get<json_float>(\"foo\"), 1.1E10);\n    expect_almost_equal(map.get<json_float>(\"bar\"), 7.07E+15);\n    expect_almost_equal(map.get<json_float>(\"zero\"), 2.123E-3);\n\n    json_array const arr\n    { json_data{ R\"raw([1.1E10, 7.07E+15, 2.123E-3])raw\" } };\n    expect_almost_equal(arr.get<json_float>(0), 1.1E10);\n    expect_almost_equal(arr.get<json_float>(1), 7.07E+15);\n    expect_almost_equal(arr.get<json_float>(2), 2.123E-3);\n  }\n}\n\n'jeayeson/test/src/parser/main.cpp'\n:\n\n#include <jeayeson/jeayeson.hpp>\n#include <jest/jest.hpp>\n\n#include \"parser/escape.hpp\"\n#include \"parser/number.hpp\"\n#include \"parser/utf.hpp\"\n\nint main()\n{\n  jest::worker const j{};\n  return j();\n}\n",
        "gt": [
            "'jeayeson/include/jeayeson/jeayeson.hpp'",
            "'jeayeson/test/include/parser/number.hpp'",
            "'jeayeson/test/src/parser/main.cpp'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/NoteDetails/core/CorePrStatus.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/NoteDetails/Core.hpp'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/NoteDetails/core/CorePrStatus.hpp'\n:\n#ifndef LIEF_ELF_CORE_PRSTATUS_H\n#define LIEF_ELF_CORE_PRSTATUS_H\n\n#include <vector>\n#include <ostream>\n#include <map>\n#include <utility>\n\n#include \"LIEF/Object.hpp\"\n#include \"LIEF/visibility.h\"\n\n#include \"LIEF/ELF/NoteDetails.hpp\"\n\nnamespace LIEF {\nnamespace ELF {\n\nclass Parser;\nclass Builder;\nclass Binary;\n\n\nclass LIEF_API CorePrStatus : public NoteDetails {\n\n  public:\n  using NoteDetails::NoteDetails;\n  struct siginfo_t {\n    int32_t si_signo;\n    int32_t si_code;\n    int32_t si_errno;\n  };\n\n  struct timeval_t {\n    uint64_t sec;\n    uint64_t usec;\n  };\n\n\n  enum class REGISTERS  {\n    UNKNOWN,\n\n\n\n    X86_START,\n      X86_EBX, X86_ECX, X86_EDX, X86_ESI, X86_EDI, X86_EBP, X86_EAX,\n      X86_DS, X86_ES, X86_FS, X86_GS, X86__, X86_EIP, X86_CS, X86_EFLAGS, X86_ESP, X86_SS,\n    X86_END,\n\n\n\n    X86_64_START,\n      X86_64_R15, X86_64_R14, X86_64_R13, X86_64_R12, X86_64_RBP, X86_64_RBX, X86_64_R11, X86_64_R10,\n      X86_64_R9, X86_64_R8, X86_64_RAX, X86_64_RCX, X86_64_RDX, X86_64_RSI, X86_64_RDI, X86_64__,\n      X86_64_RIP, X86_64_CS, X86_64_EFLAGS, X86_64_RSP, X86_64_SS,\n    X86_64_END,\n\n\n\n    ARM_START,\n      ARM_R0, ARM_R1, ARM_R2,  ARM_R3,  ARM_R4,  ARM_R5,  ARM_R6,  ARM_R7,\n      ARM_R8, ARM_R9, ARM_R10, ARM_R11, ARM_R12, ARM_R13, ARM_R14, ARM_R15,\n      ARM_CPSR,\n    ARM_END,\n\n\n\n    AARCH64_START,\n      AARCH64_X0,  AARCH64_X1,  AARCH64_X2,  AARCH64_X3,  AARCH64_X4,  AARCH64_X5,  AARCH64_X6,  AARCH64_X7,\n      AARCH64_X8,  AARCH64_X9,  AARCH64_X10, AARCH64_X11, AARCH64_X12, AARCH64_X13, AARCH64_X14, AARCH64_X15,\n      AARCH64_X16, AARCH64_X17, AARCH64_X18, AARCH64_X19, AARCH64_X20, AARCH64_X21, AARCH64_X22, AARCH64_X23,\n      AARCH64_X24, AARCH64_X25, AARCH64_X26, AARCH64_X27, AARCH64_X28, AARCH64_X29, AARCH64_X30, AARCH64_X31,\n      AARCH64_PC, AARCH64__,\n    AARCH64_END,\n  };\n  using reg_context_t = std::map<REGISTERS, uint64_t>;\n\n  public:\n  static CorePrStatus make(Note& note);\n\n  CorePrStatus* clone() const override;\n\n\n  const siginfo_t& siginfo() const;\n\n\n  uint16_t current_sig() const;\n\n\n  uint64_t sigpend() const;\n\n\n  uint64_t sighold() const;\n\n\n  int32_t pid() const;\n\n\n  int32_t ppid() const;\n\n\n  int32_t pgrp() const;\n\n\n  int32_t sid() const;\n\n\n  timeval_t utime() const;\n\n\n  timeval_t stime() const;\n\n\n  timeval_t cutime() const;\n\n\n  timeval_t cstime() const;\n\n\n  const reg_context_t& reg_context() const;\n\n\n  uint64_t pc() const;\n\n\n  uint64_t sp() const;\n\n\n\n\n  uint64_t get(REGISTERS reg, bool* error = nullptr) const;\n\n\n  bool has(REGISTERS reg) const;\n\n  void siginfo(const siginfo_t& siginfo);\n  void current_sig(uint16_t current_sig);\n\n  void sigpend(uint64_t sigpend);\n  void sighold(uint64_t sighold);\n\n  void pid(int32_t pid);\n  void ppid(int32_t ppid);\n  void pgrp(int32_t pgrp);\n  void sid(int32_t sid);\n\n  void utime(timeval_t utime);\n  void stime(timeval_t stime);\n  void cutime(timeval_t cutime);\n  void cstime(timeval_t cstime);\n\n  void reg_context(const reg_context_t& ctx);\n\n  bool set(REGISTERS reg, uint64_t value);\n\n  bool operator==(const CorePrStatus& rhs) const;\n  bool operator!=(const CorePrStatus& rhs) const;\n\n  uint64_t& operator[](REGISTERS reg);\n\n  void dump(std::ostream& os) const override;\n  static std::ostream& dump(std::ostream& os, const timeval_t& time);\n  static std::ostream& dump(std::ostream& os, const siginfo_t& siginfo);\n  static std::ostream& dump(std::ostream& os, const reg_context_t& ctx);\n\n  void accept(Visitor& visitor) const override;\n\n  virtual ~CorePrStatus();\n\n  LIEF_API friend std::ostream& operator<<(std::ostream& os, const CorePrStatus& note);\n\n  protected:\n  template <typename ELF_T>\n  LIEF_LOCAL void parse_();\n\n  template <typename ELF_T>\n  LIEF_LOCAL void build_();\n\n  void parse() override;\n  void build() override;\n\n  private:\n  CorePrStatus(Note& note);\n\n  std::pair<size_t, size_t> reg_enum_range() const;\n\n  siginfo_t siginfo_;\n  uint16_t  cursig_;\n\n  uint64_t sigpend_;\n  uint64_t sighold_;\n\n  int32_t pid_;\n  int32_t ppid_;\n  int32_t pgrp_;\n  int32_t sid_;\n\n  timeval_t utime_;\n  timeval_t stime_;\n  timeval_t cutime_;\n  timeval_t cstime_;\n\n  reg_context_t ctx_;\n};\n\n\nLIEF_API const char* to_string(CorePrStatus::REGISTERS e);\n\n}\n}\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'\n:\n#ifndef LIEF_TO_JSON_H\n#define LIEF_TO_JSON_H\n\n#include \"LIEF/config.h\"\n\n#ifdef LIEF_JSON_SUPPORT\n\n\n#ifdef LIEF_ELF_SUPPORT\n#include \"LIEF/ELF/json.hpp\"\n#endif\n\n#ifdef LIEF_PE_SUPPORT\n#include \"LIEF/PE/json.hpp\"\n#endif\n\n#include \"LIEF/Abstract/json.hpp\"\n\n#include \"LIEF/Abstract.hpp\"\n#include \"LIEF/ELF.hpp\"\n#include \"LIEF/PE.hpp\"\n\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF.hpp'\n:\n#ifndef LIEF_ELF_H\n#define LIEF_ELF_H\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_ELF_SUPPORT)\n#include \"LIEF/ELF/hash.hpp\"\n#include \"LIEF/ELF/utils.hpp\"\n#include \"LIEF/ELF/enums.hpp\"\n\n#include \"LIEF/ELF/Parser.hpp\"\n#include \"LIEF/ELF/Header.hpp\"\n#include \"LIEF/ELF/Section.hpp\"\n#include \"LIEF/ELF/Binary.hpp\"\n#include \"LIEF/ELF/Segment.hpp\"\n#include \"LIEF/ELF/Builder.hpp\"\n#include \"LIEF/ELF/EnumToString.hpp\"\n#include \"LIEF/ELF/Relocation.hpp\"\n#include \"LIEF/ELF/DynamicEntryArray.hpp\"\n#include \"LIEF/ELF/DynamicEntryFlags.hpp\"\n#include \"LIEF/ELF/DynamicEntry.hpp\"\n#include \"LIEF/ELF/DynamicEntryLibrary.hpp\"\n#include \"LIEF/ELF/DynamicEntryRpath.hpp\"\n#include \"LIEF/ELF/DynamicEntryRunPath.hpp\"\n#include \"LIEF/ELF/DynamicSharedObject.hpp\"\n#include \"LIEF/ELF/GnuHash.hpp\"\n#include \"LIEF/ELF/Note.hpp\"\n#include \"LIEF/ELF/RelocationSizes.hpp\"\n#include \"LIEF/ELF/Symbol.hpp\"\n#include \"LIEF/ELF/SymbolVersion.hpp\"\n#include \"LIEF/ELF/SymbolVersionAux.hpp\"\n#include \"LIEF/ELF/SymbolVersionAuxRequirement.hpp\"\n#include \"LIEF/ELF/SymbolVersionDefinition.hpp\"\n#include \"LIEF/ELF/SymbolVersionRequirement.hpp\"\n#include \"LIEF/ELF/SysvHash.hpp\"\n\n#include \"LIEF/ELF/NoteDetails/AndroidNote.hpp\"\n#include \"LIEF/ELF/NoteDetails/NoteAbi.hpp\"\n#include \"LIEF/ELF/NoteDetails/Core.hpp\"\n#include \"LIEF/ELF/NoteDetails.hpp\"\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/NoteDetails/Core.hpp'\n:\n#ifndef LIEF_ELF_NOTE_DETAILS_CORE_H\n#define LIEF_ELF_NOTE_DETAILS_CORE_H\n\n#include \"LIEF/ELF/NoteDetails/core/CorePrPsInfo.hpp\"\n#include \"LIEF/ELF/NoteDetails/core/CorePrStatus.hpp\"\n#include \"LIEF/ELF/NoteDetails/core/CoreAuxv.hpp\"\n#include \"LIEF/ELF/NoteDetails/core/CoreSigInfo.hpp\"\n#include \"LIEF/ELF/NoteDetails/core/CoreFile.hpp\"\n\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/NoteDetails/core/CorePrStatus.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/NoteDetails/Core.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'"
        ]
    },
    {
        "files": [
            "'library/toptree/base.cpp'",
            "'library/formalpowerseries/inv.cpp'",
            "'library/formalpowerseries/mod.cpp'"
        ],
        "content": "'library/toptree/base.cpp'\n:#ifndef call_from_test\n#include <bits/stdc++.h>\nusing namespace std;\n#endif\n\nstruct Vertex{\n  void* handle;\n  Vertex():handle(nullptr){}\n};\nstruct Cluster{\n  Cluster(){}\n  void toggle(){}\n  static Cluster compress(Cluster x,Vertex *v,Cluster y){}\n  static Cluster rake(Cluster x,Cluster y){}\n};\n\n#ifndef call_from_test\n\nsigned main(){\n  return 0;\n}\n#endif\n\n'library/formalpowerseries/inv.cpp'\n:#ifndef call_from_test\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#include \"../combinatorics/enumeration.cpp\"\n#include \"base.cpp\"\n#undef call_from_test\n\n#endif\n\ntemplate<typename M>\nvector<M> FormalPowerSeries<M>::inv(Poly as,int deg){\n  assert(as[0]!=M(0));\n  Poly rs({M(1)/as[0]});\n  for(int i=1;i<deg;i<<=1)\n    rs=pre(sub(add(rs,rs),mul(mul(rs,rs),pre(as,i<<1))),i<<1);\n  return rs;\n}\n\n\n#ifndef call_from_test\n\nsigned main(){\n  return 0;\n}\n#endif\n\n'library/formalpowerseries/mod.cpp'\n:#ifndef call_from_test\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#include \"../combinatorics/enumeration.cpp\"\n#include \"base.cpp\"\n#include \"inv.cpp\"\n#include \"div.cpp\"\n#undef call_from_test\n\n#endif\n\ntemplate<typename M>\nvector<M> FormalPowerSeries<M>::mod(Poly as,Poly bs){\n  if(is_zero(as)) return Poly({0});\n  shrink(as);shrink(bs);\n  as=sub(as,mul(div(as,bs),bs));\n  if(is_zero(as)) return Poly({0});\n  shrink(as);\n  return as;\n}\n\n#ifndef call_from_test\n\nsigned main(){\n  return 0;\n}\n#endif\n",
        "gt": [
            "'library/toptree/base.cpp'",
            "'library/formalpowerseries/inv.cpp'",
            "'library/formalpowerseries/mod.cpp'"
        ]
    },
    {
        "files": [
            "'LittleEngineVk/engine/include/le/input/key_axis.hpp'",
            "'LittleEngineVk/engine/include/le/core/time.hpp'",
            "'LittleEngineVk/engine/src/input/range.cpp'",
            "'LittleEngineVk/engine/include/le/input/range.hpp'"
        ],
        "content": "'LittleEngineVk/engine/include/le/input/key_axis.hpp'\n:#pragma once\n#include <le/core/time.hpp>\n#include <le/input/state.hpp>\n\nnamespace le::input {\nstruct KeyAxis {\n\tstatic constexpr Duration lerp_rate_v{0.2s};\n\n\tint lo{};\n\tint hi{};\n\tDuration lerp_rate{lerp_rate_v};\n\n\tfloat value{};\n\n\t[[nodiscard]] auto tick(State const& state, Duration dt) -> float;\n};\n}\n\n'LittleEngineVk/engine/include/le/core/time.hpp'\n:#pragma once\n#include <chrono>\n\nusing namespace std::chrono_literals;\n\nnamespace le {\nusing Clock = std::chrono::steady_clock;\n\ntemplate <typename PeriodT = std::ratio<1, 1>>\nusing FDuration = std::chrono::duration<float, PeriodT>;\n\nusing Duration = FDuration<>;\n\n\n\n\nstruct DeltaTime {\n\n\n\n\tClock::time_point start{Clock::now()};\n\n\n\n\tDuration value{};\n\n\n\n\n\n\tauto operator()() -> Duration {\n\t\tauto const now = Clock::now();\n\t\tvalue = now - start;\n\t\tstart = now;\n\t\treturn value;\n\t}\n};\n}\n\n'LittleEngineVk/engine/src/input/range.cpp'\n:#include <le/input/range.hpp>\n\nnamespace le::input {\nauto Range::operator()(State const& state, Duration const dt) -> float {\n\tauto ret = float{};\n\tfor (auto& axis : key_axes) { ret += axis.tick(state, dt); }\n\tif (!gamepad_axes.empty()) {\n\t\tauto const id = gamepad_index.value_or(state.last_engaged_gamepad_index);\n\t\tauto const& gamepad = state.gamepads.at(id);\n\t\tfor (auto const axis : gamepad_axes) { ret += gamepad.axes.at(static_cast<std::size_t>(axis)); }\n\t}\n\treturn ret;\n}\n}\n\n'LittleEngineVk/engine/include/le/input/range.hpp'\n:#pragma once\n#include <le/input/key_axis.hpp>\n#include <optional>\n#include <vector>\n\nnamespace le::input {\nstruct Range {\n\tstd::vector<KeyAxis> key_axes{};\n\tstd::vector<int> gamepad_axes{};\n\tstd::optional<std::size_t> gamepad_index{};\n\n\t[[nodiscard]] auto operator()(State const& state, Duration dt) -> float;\n};\n}\n",
        "gt": [
            "'LittleEngineVk/engine/include/le/core/time.hpp'",
            "'LittleEngineVk/engine/include/le/input/key_axis.hpp'",
            "'LittleEngineVk/engine/include/le/input/range.hpp'",
            "'LittleEngineVk/engine/src/input/range.cpp'"
        ]
    },
    {
        "files": [
            "'oshu/include/core/geometry.h'",
            "'oshu/include/ui/metadata.h'",
            "'oshu/include/video/texture.h'",
            "'oshu/include/ui/shell.h'"
        ],
        "content": "'oshu/include/core/geometry.h'\n:\n\n#pragma once\n\n#include <complex>\n\nnamespace oshu {\n\n\n\n\nusing point = std::complex<double>;\n\n\nusing vector = std::complex<double>;\n\n\nusing size = std::complex<double>;\n\n\ndouble ratio(oshu::size size);\n\n\n\n}\n\n'oshu/include/ui/metadata.h'\n:\n\n#pragma once\n\n#include \"video/texture.h\"\n\nnamespace oshu {\n\nstruct beatmap;\nstruct display;\nstruct metadata;\n\n\n\n\nstruct metadata_frame {\n\n\toshu::display *display = nullptr;\n\n\toshu::beatmap *beatmap = nullptr;\n\n\tdouble *clock = nullptr;\n\n\toshu::texture ascii;\n\n\toshu::texture unicode;\n\n\toshu::texture stars;\n};\n\n\nint create_metadata_frame(oshu::display *display, oshu::beatmap *beatmap, double *clock, oshu::metadata_frame *frame);\n\n\nvoid show_metadata_frame(oshu::metadata_frame *frame, double opacity);\n\n\nvoid destroy_metadata_frame(oshu::metadata_frame *frame);\n\n\n\n}\n\n'oshu/include/video/texture.h'\n:\n\n#pragma once\n\n#include \"core/geometry.h\"\n\nstruct SDL_Texture;\n\nnamespace oshu {\n\nstruct display;\n\n\n\n\nstruct texture {\n\n\toshu::size size = 0;\n\n\toshu::point origin = 0;\n\n\tstruct SDL_Texture *texture = nullptr;\n};\n\n\nint load_texture(oshu::display *display, const char *filename, oshu::texture *texture);\n\n\nvoid destroy_texture(oshu::texture *texture);\n\n\nvoid draw_texture(oshu::display *display, oshu::texture *texture, oshu::point p);\n\n\nvoid draw_scaled_texture(oshu::display *display, oshu::texture *texture, oshu::point p, double ratio);\n\n\n\n}\n\n'oshu/include/ui/shell.h'\n:\n\n#pragma once\n\n#include \"ui/audio.h\"\n#include \"ui/background.h\"\n#include \"ui/metadata.h\"\n#include \"ui/score.h\"\n\n#include <memory>\n\nnamespace oshu {\n\nclass game_base;\nstruct game_screen;\nstruct widget;\n\n\n\n\nstruct shell {\n\n\tshell(oshu::display&, oshu::game_base&);\n\t~shell();\n\n\toshu::display &display;\n\toshu::game_base &game;\n\n\tstd::unique_ptr<widget> game_view;\n\toshu::game_screen *screen;\n\toshu::background background {};\n\toshu::metadata_frame metadata {};\n\toshu::score_frame score {};\n\toshu::audio_progress_bar audio_progress_bar {};\n\n\tvoid open();\n\n\tvoid close();\nprivate:\n\n\tbool stop = false;\n};\n\n\n\n}\n",
        "gt": [
            "'oshu/include/core/geometry.h'",
            "'oshu/include/video/texture.h'",
            "'oshu/include/ui/metadata.h'",
            "'oshu/include/ui/shell.h'"
        ]
    },
    {
        "files": [
            "'DomesdayDuplicator/Linux-Application/DomesdayDuplicator/usbdevice.h'",
            "'DomesdayDuplicator/Linux-Application/DomesdayDuplicator/usbcapture.h'",
            "'DomesdayDuplicator/Linux-Application/DomesdayDuplicator/mainwindow.h'"
        ],
        "content": "'DomesdayDuplicator/Linux-Application/DomesdayDuplicator/usbdevice.h'\n:\n\n#ifndef USBDEVICE_H\n#define USBDEVICE_H\n\n#include <QObject>\n#include <QDebug>\n#include <QThread>\n#include <QWaitCondition>\n\n#include <libusb.h>\n#include \"usbcapture.h\"\n\nclass UsbDevice : public QThread\n{\n    Q_OBJECT\npublic:\n    explicit UsbDevice(QObject *parent = nullptr, quint16 vid = 0x1D50, quint16 pid = 0x603B);\n    ~UsbDevice() override;\n\n    void stop();\n\n    bool scanForDevice();\n    void sendConfigurationCommand(bool testMode);\n\n    void startCapture(QString filename, bool isCaptureFormat10Bit, bool isCaptureFormat10BitDecimated, bool isTestMode);\n    void stopCapture();\n    qint32 getNumberOfTransfers();\n    qint32 getNumberOfDiskBuffersWritten();\n    QString getLastError();\n\nsignals:\n    void deviceAttached();\n    void deviceDetached();\n    void transferFailed();\n\npublic slots:\n\nprotected slots:\n    void run() override;\n\nprotected:\n    libusb_context *libUsbContext;\n    libusb_device_handle *usbDeviceHandle;\n    bool threadAbort;\n\nprivate slots:\n    void transferFailedSignalHandler();\n\nprivate:\n    quint16 deviceVid;\n    quint16 devicePid;\n\n    UsbCapture *usbCapture;\n    QString lastError;\n\n    bool open();\n    void close();\n    bool sendVendorSpecificCommand(quint8 command, quint16 value);\n    bool searchForAttachedDevice();\n};\n\n#endif\n\n'DomesdayDuplicator/Linux-Application/DomesdayDuplicator/usbcapture.h'\n:\n\n#ifndef USBCAPTURE_H\n#define USBCAPTURE_H\n\n#include <QObject>\n#include <QThread>\n#include <QFile>\n#include <QVector>\n#include <QDebug>\n#include <QtConcurrent/QtConcurrent>\n\n#include <libusb.h>\n\nclass UsbCapture : public QThread\n{\n    Q_OBJECT\npublic:\n    explicit UsbCapture(QObject *parent = nullptr, libusb_context *libUsbContextParam = nullptr,\n                        libusb_device_handle *usbDeviceHandleParam = nullptr, QString filenameParam = nullptr,\n                        bool isCaptureFormat10BitParam = true, bool isCaptureFormat10BitDecimatedParam = false,\n                        bool isTestData = false);\n    ~UsbCapture() override;\n\n    void startTransfer();\n    void stopTransfer();\n    qint32 getNumberOfTransfers();\n    qint32 getNumberOfDiskBuffersWritten();\n    QString getLastError();\n    static bool getOkToRename();\n    static void getAmplitudeBuffer(const unsigned char **buffer, qint32 *numBytes);\n\nsignals:\n    void transferFailed();\n\npublic slots:\n\nprotected slots:\n    void run() override;\n    void runDiskBuffers();\n\nprotected:\n    libusb_context *libUsbContext;\n    libusb_device_handle *usbDeviceHandle;\n    QString filename;\n    bool isCaptureFormat10Bit;\n    bool isCaptureFormat10BitDecimated;\n    bool isTestData;\n\nprivate:\n    qint32 numberOfDiskBuffersWritten;\n\n    enum {\n        SEQUENCE_SYNC,\n        SEQUENCE_RUNNING,\n        SEQUENCE_DISABLED,\n        SEQUENCE_FAILED,\n    } sequenceState;\n    quint32 savedSequenceCounter;\n    void checkBufferSequence(qint32 diskBufferNumber);\n\n    qint32 savedTestDataValue;\n    qint32 testDataMax;\n    void writeBufferToDisk(QFile *outputFile, qint32 diskBufferNumber);\n    void writeConversionBuffer(QFile *outputFile, qint32 numBytes);\n\n    void allocateDiskBuffers();\n    void freeDiskBuffers();\n};\n\n#endif\n\n'DomesdayDuplicator/Linux-Application/DomesdayDuplicator/mainwindow.h'\n:\n\n#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n\n#include <QMainWindow>\n#include <QLabel>\n#include <QDate>\n#include <QTimer>\n#include <QMessageBox>\n\n#include \"aboutdialog.h\"\n#include \"configurationdialog.h\"\n#include \"configuration.h\"\n#include \"usbdevice.h\"\n#include \"playercommunication.h\"\n#include \"playercontrol.h\"\n#include \"playerremotedialog.h\"\n#include \"automaticcapturedialog.h\"\n#include \"advancednamingdialog.h\"\n#include \"amplitudemeasurement.h\"\n\nnamespace Ui {\nclass MainWindow;\n}\n\nclass MainWindow : public QMainWindow\n{\n    Q_OBJECT\n\npublic:\n    explicit MainWindow(QWidget *parent = nullptr);\n    ~MainWindow();\n\nprivate slots:\n    void deviceAttachedSignalHandler();\n    void deviceDetachedSignalHandler();\n    void configurationChangedSignalHandler();\n    void remoteControlCommandSignalHandler(PlayerRemoteDialog::RemoteButtons button);\n    void remoteControlSearchSignalHandler(qint32 position, PlayerRemoteDialog::PositionMode positionMode);\n    void startAutomaticCaptureDialogSignalHandler(AutomaticCaptureDialog::CaptureType captureType,\n                                                              qint32 startAddress, qint32 endAddress,\n                                                              AutomaticCaptureDialog::DiscType discTypeParam);\n    void stopAutomaticCaptureDialogSignalHandler();\n    void updateAutomaticCaptureStatus();\n    void automaticCaptureCompleteSignalHandler(bool success);\n\n    void playerConnectedSignalHandler();\n    void playerDisconnectedSignalHandler();\n\n    void startCaptureSignalHandler();\n    void stopCaptureSignalHandler();\n\n    void updateCaptureStatistics();\n    void updatePlayerControlInformation();\n    void transferFailedSignalHandler();\n    void updateCaptureDuration();\n    void updateStorageInformation();\n    void updateAmplitudeLabel();\n\n    void on_actionExit_triggered();\n    void on_actionTest_mode_toggled(bool arg1);\n    void on_actionAbout_triggered();\n    void on_actionPreferences_triggered();\n    void on_capturePushButton_clicked();\n    void on_actionPlayer_remote_triggered();\n    void on_actionAutomatic_capture_triggered();\n    void on_limitDurationCheckBox_stateChanged(int arg1);\n    void on_actionAdvanced_naming_triggered();\n\nprivate:\n    Configuration *configuration;\n    UsbDevice *usbDevice;\n    QLabel *usbStatusLabel;\n    QStorageInfo *storageInfo;\n\n    Ui::MainWindow *ui;\n    AboutDialog *aboutDialog;\n    AutomaticCaptureDialog *automaticCaptureDialog;\n    ConfigurationDialog *configurationDialog;\n    PlayerRemoteDialog *playerRemoteDialog;\n    PlayerControl *playerControl;\n    AdvancedNamingDialog *advancedNamingDialog;\n    AmplitudeMeasurement *amplitudeMeasurement;\n\n    bool isCaptureRunning;\n    QTimer *captureStatusUpdateTimer;\n    QTimer *playerControlTimer;\n    QTimer *automaticCaptureTimer;\n    QTimer *captureDurationTimer;\n    QTime captureElapsedTime;\n    QTimer *storageInfoTimer;\n    QTimer *amplitudeTimer;\n\n    bool isPlayerConnected;\n\n\n    PlayerCommunication::DisplayState remoteDisplayState;\n    PlayerCommunication::AudioState remoteAudioState;\n    qint32 remoteSpeed;\n    PlayerCommunication::ChapterFrameMode remoteChapterFrameMode;\n\n    void updateGuiForCaptureStart();\n    void updateGuiForCaptureStop();\n    void startPlayerControl();\n    void updatePlayerRemoteDialog();\n    void updateAmplitudeUI();\n\nsignals:\n    void plotAmplitude();\n    void bufferAmplitude();\n};\n\n#endif\n",
        "gt": [
            "'DomesdayDuplicator/Linux-Application/DomesdayDuplicator/usbcapture.h'",
            "'DomesdayDuplicator/Linux-Application/DomesdayDuplicator/usbdevice.h'",
            "'DomesdayDuplicator/Linux-Application/DomesdayDuplicator/mainwindow.h'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/SysvHash.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/Object.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/SysvHash.hpp'\n:\n#ifndef LIEF_ELF_SYSV_HASH_H\n#define LIEF_ELF_SYSV_HASH_H\n\n#include <vector>\n#include <ostream>\n\n#include \"LIEF/Object.hpp\"\n#include \"LIEF/visibility.h\"\n\nnamespace LIEF {\nnamespace ELF {\n\nclass Parser;\nclass Builder;\nclass Binary;\n\n\n\n\n\n\n\nclass LIEF_API SysvHash : public Object {\n\n  friend class Parser;\n  friend class Builder;\n  friend class Binary;\n\n  public:\n  SysvHash();\n  SysvHash& operator=(const SysvHash& copy);\n  SysvHash(const SysvHash& copy);\n\n  SysvHash& operator=(SysvHash&&);\n  SysvHash(SysvHash&&);\n  ~SysvHash() override;\n\n\n  uint32_t nbucket() const;\n\n\n  uint32_t nchain() const;\n\n\n  const std::vector<uint32_t>& buckets() const;\n\n\n  const std::vector<uint32_t>& chains() const;\n\n  inline void nchain(uint32_t nb) {\n    chains_.resize(nb);\n  }\n\n  bool operator==(const SysvHash& rhs) const;\n  bool operator!=(const SysvHash& rhs) const;\n\n  void accept(Visitor& visitor) const override;\n\n  LIEF_API friend std::ostream& operator<<(std::ostream& os, const SysvHash& sysvhash);\n\n  private:\n  std::vector<uint32_t> buckets_;\n  std::vector<uint32_t> chains_;\n\n};\n\n\n}\n}\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/Object.hpp'\n:\n#ifndef LIEF_VISITABLE_H\n#define LIEF_VISITABLE_H\n#include <type_traits>\n#include \"LIEF/visibility.h\"\n\nnamespace LIEF {\n\nclass Visitor;\n\nclass LIEF_API Object {\n\n  template<class T>\n  using add_pointer_t = typename std::add_pointer<T>::type;\n\n  template<class T>\n  using decay_t = typename std::decay<T>::type;\n\n  template<class T>\n  using add_const_t = typename std::add_const<T>::type;\n\n  public:\n  template<class T>\n  using output_t = add_pointer_t<decay_t<T>>;\n\n  template<class T>\n  using output_const_t = add_pointer_t<add_const_t<decay_t<T>>>;\n\n  public:\n  Object();\n  Object(const Object& other);\n  Object& operator=(const Object& other);\n\n  template<class T>\n  LIEF_LOCAL output_t<T> as();\n\n  template<class T>\n  LIEF_LOCAL output_const_t<T> as() const;\n\n  virtual ~Object();\n  virtual void accept(Visitor& visitor) const = 0;\n};\n}\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF.hpp'\n:\n#ifndef LIEF_ELF_H\n#define LIEF_ELF_H\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_ELF_SUPPORT)\n#include \"LIEF/ELF/hash.hpp\"\n#include \"LIEF/ELF/utils.hpp\"\n#include \"LIEF/ELF/enums.hpp\"\n\n#include \"LIEF/ELF/Parser.hpp\"\n#include \"LIEF/ELF/Header.hpp\"\n#include \"LIEF/ELF/Section.hpp\"\n#include \"LIEF/ELF/Binary.hpp\"\n#include \"LIEF/ELF/Segment.hpp\"\n#include \"LIEF/ELF/Builder.hpp\"\n#include \"LIEF/ELF/EnumToString.hpp\"\n#include \"LIEF/ELF/Relocation.hpp\"\n#include \"LIEF/ELF/DynamicEntryArray.hpp\"\n#include \"LIEF/ELF/DynamicEntryFlags.hpp\"\n#include \"LIEF/ELF/DynamicEntry.hpp\"\n#include \"LIEF/ELF/DynamicEntryLibrary.hpp\"\n#include \"LIEF/ELF/DynamicEntryRpath.hpp\"\n#include \"LIEF/ELF/DynamicEntryRunPath.hpp\"\n#include \"LIEF/ELF/DynamicSharedObject.hpp\"\n#include \"LIEF/ELF/GnuHash.hpp\"\n#include \"LIEF/ELF/Note.hpp\"\n#include \"LIEF/ELF/RelocationSizes.hpp\"\n#include \"LIEF/ELF/Symbol.hpp\"\n#include \"LIEF/ELF/SymbolVersion.hpp\"\n#include \"LIEF/ELF/SymbolVersionAux.hpp\"\n#include \"LIEF/ELF/SymbolVersionAuxRequirement.hpp\"\n#include \"LIEF/ELF/SymbolVersionDefinition.hpp\"\n#include \"LIEF/ELF/SymbolVersionRequirement.hpp\"\n#include \"LIEF/ELF/SysvHash.hpp\"\n\n#include \"LIEF/ELF/NoteDetails/AndroidNote.hpp\"\n#include \"LIEF/ELF/NoteDetails/NoteAbi.hpp\"\n#include \"LIEF/ELF/NoteDetails/Core.hpp\"\n#include \"LIEF/ELF/NoteDetails.hpp\"\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'\n:\n#ifndef LIEF_MAIN_HEADER_H\n#define LIEF_MAIN_HEADER_H\n#include <LIEF/config.h>\n\n#include <LIEF/Abstract.hpp>\n\n#include <LIEF/OAT.hpp>\n#include <LIEF/VDEX.hpp>\n#include <LIEF/ART.hpp>\n#include <LIEF/DEX.hpp>\n#include <LIEF/ELF.hpp>\n#include <LIEF/PE.hpp>\n#include <LIEF/MachO.hpp>\n#include <LIEF/DWARF.hpp>\n#include <LIEF/logging.hpp>\n#include <LIEF/platforms.hpp>\n\n\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/Object.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF/SysvHash.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/ELF.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'"
        ]
    },
    {
        "files": [
            "'LittleEngineVk/scene/include/le/scene/scene_renderer.hpp'",
            "'LittleEngineVk/scene/src/imcpp/scene_graph.cpp'",
            "'LittleEngineVk/scene/include/le/scene/scene_manager.hpp'",
            "'LittleEngineVk/engine/include/le/graphics/render_frame.hpp'"
        ],
        "content": "'LittleEngineVk/scene/include/le/scene/scene_renderer.hpp'\n:#pragma once\n#include <le/graphics/render_frame.hpp>\n#include <le/scene/scene.hpp>\n\nnamespace le {\nclass SceneRenderer {\n  public:\n\tSceneRenderer(SceneRenderer const&) = delete;\n\tSceneRenderer(SceneRenderer&&) = delete;\n\tauto operator=(SceneRenderer const&) -> SceneRenderer& = delete;\n\tauto operator=(SceneRenderer&&) -> SceneRenderer& = delete;\n\n\tvirtual ~SceneRenderer() = default;\n\n\texplicit SceneRenderer();\n\n\tauto render(Scene const& scene) -> graphics::RenderFrame;\n\n  protected:\n\tgraphics::StaticPrimitive m_skybox_cube{};\n\tgraphics::SkyboxMaterial m_skybox_mat{};\n\tgraphics::PipelineState m_skybox_pipeline{};\n\tstd::vector<graphics::RenderObject> m_scene_objects{};\n\tstd::vector<graphics::RenderObject> m_ui_objects{};\n};\n}\n\n'LittleEngineVk/scene/src/imcpp/scene_graph.cpp'\n:#include <imgui.h>\n#include <le/core/fixed_string.hpp>\n#include <le/imcpp/reflector.hpp>\n#include <le/scene/imcpp/scene_graph.hpp>\n#include <le/scene/scene.hpp>\n#include <le/scene/scene_manager.hpp>\n\nnamespace le::imcpp {\nauto SceneGraph::check_stale() -> bool {\n\tbool ret = false;\n\tif (m_scene != m_prev) {\n\t\tm_prev = m_scene;\n\t\tm_scene_inspector.target = {};\n\t\tret = true;\n\t}\n\tif (auto const* id = std::get_if<EntityId>(&m_scene_inspector.target.payload); id != nullptr && !m_scene->has_entity(*id)) {\n\t\tm_scene_inspector.target = {};\n\t\tret = true;\n\t}\n\treturn ret;\n}\n\nauto SceneGraph::draw_to(NotClosed<Window> w, Scene& scene) -> SceneInspector::Target {\n\tm_scene = &scene;\n\tcheck_stale();\n\n\tif (ImGui::SliderFloat(\"Inspector Width\", &m_scene_inspector.width_pct, 0.1f, 0.5f, \"%.3f\")) {\n\t\tm_scene_inspector.width_pct = std::clamp(m_scene_inspector.width_pct, 0.1f, 0.5f);\n\t}\n\n\tImGui::DragFloat(\"Draw colliders\", &scene.collision.draw_line_width);\n\n\tImGui::Separator();\n\tif (ImGui::Button(\"Spawn\")) { Popup::open(\"scene_graph.spawn_entity\"); }\n\n\tImGui::Separator();\n\tstandalone_node(\"camera\", SceneInspector::Type::eCamera);\n\tstandalone_node(\"lights\", SceneInspector::Type::eLights);\n\tdraw_scene_tree(w);\n\thandle_popups();\n\n\tm_scene_inspector.display(scene);\n\n\treturn m_scene_inspector.target;\n}\n\nvoid SceneGraph::standalone_node(char const* label, SceneInspector::Type type) {\n\tauto flags = int{};\n\tflags |= ImGuiTreeNodeFlags_SpanFullWidth;\n\tif (auto* held_type = std::get_if<SceneInspector::Type>(&m_scene_inspector.target.payload); held_type != nullptr && *held_type == type) {\n\t\tflags |= ImGuiTreeNodeFlags_Selected;\n\t}\n\tif (imcpp::TreeNode::leaf(label, flags)) { m_scene_inspector.target.payload = type; }\n\tif (ImGui::IsItemClicked(ImGuiMouseButton_Right)) {\n\t\tm_right_clicked_target.payload = type;\n\t\tPopup::open(\"scene_graph.right_click\");\n\t}\n}\n\nauto SceneGraph::walk_node(Node& node) -> bool {\n\tauto node_locator = m_scene->make_node_locator();\n\tauto flags = int{};\n\tflags |= (ImGuiTreeNodeFlags_SpanFullWidth | ImGuiTreeNodeFlags_OpenOnArrow);\n\tif (node.entity_id && m_scene_inspector.target == node.entity_id) { flags |= ImGuiTreeNodeFlags_Selected; }\n\tif (node.children().empty()) { flags |= ImGuiTreeNodeFlags_Leaf; }\n\tauto tn = imcpp::TreeNode{node.name.c_str(), flags};\n\tif (node.entity_id) {\n\t\tauto target = SceneInspector::Target{.payload = *node.entity_id};\n\t\tif (ImGui::IsItemClicked()) { m_scene_inspector.target = target; }\n\t\tif (ImGui::IsItemClicked(ImGuiMouseButton_Right)) {\n\t\t\tm_right_clicked = true;\n\t\t\tm_right_clicked_target = target;\n\t\t}\n\t}\n\tif (tn) {\n\t\tfor (auto const& id : node.children()) {\n\t\t\tif (!walk_node(node_locator.get(id))) { return false; }\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid SceneGraph::draw_scene_tree(imcpp::OpenWindow) {\n\tauto node_locator = m_scene->make_node_locator();\n\tfor (auto const& node : node_locator.roots()) {\n\t\tif (!walk_node(node_locator.get(node))) { return; }\n\t}\n\n\tif (m_right_clicked) {\n\t\tPopup::open(\"scene_graph.right_click\");\n\t\tm_right_clicked = {};\n\t}\n}\n\nvoid SceneGraph::handle_popups() {\n\tif (auto popup = Popup{\"scene_graph.spawn_entity\"}) {\n\t\tImGui::Text(\"Spawn Entity\");\n\t\tm_entity_name(\"Name\");\n\t\tif (!m_entity_name.empty() && ImGui::Button(\"Spawn\")) {\n\t\t\tm_scene->spawn(std::string{m_entity_name.view()});\n\t\t\tm_entity_name = {};\n\t\t\tPopup::close_current();\n\t\t}\n\t}\n\n\tif (auto popup = Popup{\"scene_graph.right_click\"}) {\n\t\tauto const* entity_id = std::get_if<EntityId>(&m_right_clicked_target.payload);\n\t\tif (entity_id != nullptr && !m_scene->has_entity(*entity_id)) {\n\t\t\tm_right_clicked_target = {};\n\t\t\treturn Popup::close_current();\n\t\t}\n\t\tif (ImGui::Selectable(\"Inspect\")) {\n\t\t\tm_scene_inspector.target = m_right_clicked_target;\n\t\t\tm_right_clicked_target = {};\n\t\t\tPopup::close_current();\n\t\t}\n\t\tif (entity_id != nullptr && ImGui::Selectable(\"Destroy\")) {\n\t\t\tm_scene->get_entity(*entity_id).set_destroyed();\n\t\t\tm_right_clicked_target = {};\n\t\t\tPopup::close_current();\n\t\t}\n\t}\n}\n}\n\n'LittleEngineVk/scene/include/le/scene/scene_manager.hpp'\n:#pragma once\n#include <le/scene/scene_renderer.hpp>\n#include <le/scene/scene_switcher.hpp>\n\nnamespace le {\nclass SceneManager {\n  public:\n\tauto tick(Duration dt) -> void;\n\tauto render() const -> void;\n\n\t[[nodiscard]] auto get_active_scene() const -> Scene& { return m_switcher.get_active_scene(); }\n\n\tauto set_renderer(std::unique_ptr<SceneRenderer> renderer) -> void;\n\n  private:\n\tSceneSwitcher m_switcher{};\n\tstd::unique_ptr<SceneRenderer> m_renderer{std::make_unique<SceneRenderer>()};\n};\n}\n\n'LittleEngineVk/engine/include/le/graphics/render_frame.hpp'\n:#pragma once\n#include <le/graphics/camera.hpp>\n#include <le/graphics/lights.hpp>\n#include <le/graphics/render_object.hpp>\n#include <span>\n\nnamespace le::graphics {\nstruct RenderFrame {\n\tNotNull<Lights const*> lights;\n\tNotNull<Camera const*> camera;\n\tstd::span<RenderObject const> scene{};\n\tstd::span<RenderObject const> ui{};\n};\n}\n",
        "gt": [
            "'LittleEngineVk/engine/include/le/graphics/render_frame.hpp'",
            "'LittleEngineVk/scene/include/le/scene/scene_renderer.hpp'",
            "'LittleEngineVk/scene/include/le/scene/scene_manager.hpp'",
            "'LittleEngineVk/scene/src/imcpp/scene_graph.cpp'"
        ]
    },
    {
        "files": [
            "'gmmloc/gmmloc/node/gmmloc_node.cpp'",
            "'gmmloc/gmmloc/include/gmmloc/gmmloc.h'",
            "'gmmloc/gmmloc/include/gmmloc/visualization/gmm_visualizer.h'",
            "'gmmloc/gmmloc/include/gmmloc/visualization/visualizer.h'"
        ],
        "content": "'gmmloc/gmmloc/node/gmmloc_node.cpp'\n:#include <ros/ros.h>\n\n#include \"gmmloc/gmmloc.h\"\n\nusing namespace std;\n\nint main(int argc, char **argv) {\n  google::InitGoogleLogging(argv[0]);\n  google::ParseCommandLineFlags(&argc, &argv, false);\n\n  ros::init(argc, argv, \"gmmloc\");\n\n  ros::NodeHandle nh(\"~\");\n\n  gmmloc::GMMLoc system(nh);\n\n  system.spin();\n\n\n  system.stop();\n\n  return 0;\n}\n\n'gmmloc/gmmloc/include/gmmloc/gmmloc.h'\n:#pragma once\n\n#include <string>\n#include <thread>\n\n#include <opencv2/core/core.hpp>\n\n#include \"modules/localization.h\"\n#include \"modules/tracking.h\"\n\n#include \"visualization/visualizer.h\"\n\n#include \"gmm/gaussian_mixture.h\"\n\n#include \"utils/dataloader.h\"\n#include \"utils/cv_utils.h\"\n\n#include \"cv/orb_extractor.h\"\n\nnamespace gmmloc {\n\nclass GMMLoc {\npublic:\n  explicit GMMLoc(ros::NodeHandle &nh);\n\n  ~GMMLoc();\n\n  void spin();\n\n  Frame *processFrame(DataFrame::Ptr data);\n\n  bool needNewKeyFrame(const TrackStat &stat);\n\n  KeyFrame *processNewKeyFrame(Frame *frame);\n\n  KeyFrame *processKeyFrame(Frame *frame, bool is_first = false);\n\n  void createMapPointsFromStereo(Frame *frame, KeyFrame *kf_ptr,\n                                 bool check_depth = true);\n\n  void associateMapElements(KeyFrame *kf);\n\n  static StrOptStat optimizePoint(const Eigen::Vector3d &pt3d,\n                                  const Feature &kp, const SE3Quat &Tcw,\n                                  GaussianComponent::ConstPtr comp,\n                                  const double proj_z);\n\n  GaussianComponent::ConstPtr checkMapAssociation(Vector3d &pt3d, KeyFrame *kf,\n                                                  size_t idx);\n\n  void initialize();\n\n  void stop();\n\n  ros::NodeHandle nh_;\n\n  bool initialized_ = false;\n\n  cv::Mat im_left_, im_right_;\n\n  Frame *curr_frame_ = nullptr, *last_frame_ = nullptr;\n  KeyFrame *curr_keyframe_;\n\n  Map *map_ = nullptr;\n\n  Rectify *recter_ = nullptr;\n\n\n  ORBextractor *extractor_left_ = nullptr, *extractor_right_ = nullptr;\n  Tracking *tracker_ = nullptr;\n\n  Localization *localizer_ = nullptr;\n\n  ViewerGMMLoc *viewer_ = nullptr;\n\n  PinholeCamera *camera_;\n\n\n  GMM::Ptr gmm_model_ = nullptr;\n\n\n  Dataloader *loader_;\n\n  std::unique_ptr<std::thread> thread_loc_ = nullptr;\n  std::unique_ptr<std::thread> thread_viewer_ = nullptr;\n\n  atomic_bool pause_;\n\n  eigen_aligned_std_vector<Quaterniond> rot_gt_;\n  eigen_aligned_std_vector<Vector3d> trans_gt_;\n};\n\n}\n\n'gmmloc/gmmloc/include/gmmloc/visualization/gmm_visualizer.h'\n:#pragma once\n\n#include <ros/ros.h>\n#include <visualization_msgs/MarkerArray.h>\n\n#include \"../gmm/gaussian_mixture.h\"\n\nnamespace gmmloc {\n\nclass GMMVisualizer {\n\npublic:\n  using Ptr = std::unique_ptr<GMMVisualizer>;\n\n  using ConstPtr = std::unique_ptr<const GMMVisualizer>;\n\n\n  explicit GMMVisualizer(GMM::ConstPtr model,\n                         const std::string topic_name = \"gmm_model\",\n                         const std::string frame_id = \"map\",\n                         const double cov_factor = 3);\n\n  ~GMMVisualizer() = default;\n\n  void republish(GMM::ConstPtr model);\n\n  void republish(GMM::ConstPtr model, const std::vector<int>& indices);\n\npublic:\n  std::string frame_id_;\n  ros::Publisher pub_;\n\n  visualization_msgs::MarkerArrayPtr msg_;\n\n  double cov_factor_;\n};\n\n}\n\n'gmmloc/gmmloc/include/gmmloc/visualization/visualizer.h'\n:#pragma once\n\n#include <mutex>\n\n#include \"../types/map.h\"\n\n#include \"campose_visualizer.h\"\n#include \"gmm_visualizer.h\"\n\n#include <nav_msgs/Path.h>\n#include <sensor_msgs/PointCloud2.h>\n\n#include <opencv2/core.hpp>\n\nnamespace gmmloc {\n\nclass TrajectoryViewer {\npublic:\n  using Ptr = std::unique_ptr<TrajectoryViewer>;\n\n  using ConstPtr = std::unique_ptr<const TrajectoryViewer>;\n\npublic:\n  TrajectoryViewer() = delete;\n\n  TrajectoryViewer(const std::string &name, ros::NodeHandle &nh);\n\n  ~TrajectoryViewer() = default;\n\n  void visualize(int start = 0, int end = -1);\n\n\n  static geometry_msgs::PoseStamped pose2msg(const SE3Quat &pose);\n\n  std::string name_;\n  ros::Publisher pub_;\n  nav_msgs::Path::Ptr msg_ = nullptr;\n\n  std::vector<SE3QuatConstPtr> traj_;\n};\n\nclass ViewerGMMLoc {\nprotected:\n  std::atomic_bool stop_, finished_;\n\npublic:\n\n\npublic:\n  ViewerGMMLoc(GMM::Ptr map, ros::NodeHandle &nh);\n\n  ros::NodeHandle nh_;\n\n  bool stop() {\n    stop_ = true;\n    return stop_;\n  }\n\n  bool isFinished() { return finished_; }\n\n  void spin();\n\n  void switchKey(char key);\n\n  void drawKeyFrames();\n\n  void drawMapPoints();\n\n  void setMap(Map *pMap) { map_ = pMap; }\n\n  void broadcastTF();\n\n  void setTransform(const Quaterniond &rot, const Vector3d &trans,\n                    const std::string &name = \"camera\");\n\n  void setTrajectory(const eigen_aligned_std_vector<Quaterniond> &rot,\n                     const eigen_aligned_std_vector<Vector3d> &trans,\n                     const std::string &name = \"camera\");\n\n  void publishTrajectories();\n\n  void setImage(const cv::Mat &img);\n\nprivate:\n  CameraPoseVisualizer::Ptr pose_viz_ = nullptr;\n  Map *map_ = nullptr;\n\n  ros::Publisher kf_pub_;\n  ros::Publisher mp_pub_;\n\n  sensor_msgs::PointCloud2::Ptr mappoints_ = nullptr;\n\n  std::mutex mutex_pose_, mutex_gt_;\n\n  std::unordered_map<std::string, TrajectoryViewer::Ptr> traj_records_;\n\n  std::unordered_map<std::string, SE3QuatConstPtr> tf_records_;\n\n  GMMVisualizer::Ptr gmm_visualizer_ = nullptr;\n\n  std::mutex mutex_img_;\n  cv::Mat image_;\n};\n\n}\n",
        "gt": [
            "'gmmloc/gmmloc/include/gmmloc/visualization/gmm_visualizer.h'",
            "'gmmloc/gmmloc/include/gmmloc/visualization/visualizer.h'",
            "'gmmloc/gmmloc/include/gmmloc/gmmloc.h'",
            "'gmmloc/gmmloc/node/gmmloc_node.cpp'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/LoadConfigurations/LoadConfigurationV8.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/LoadConfigurations.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE.hpp'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/LoadConfigurations/LoadConfigurationV8.hpp'\n:\n#ifndef LIEF_PE_LOAD_CONFIGURATION_V8_H\n#define LIEF_PE_LOAD_CONFIGURATION_V8_H\n#include <ostream>\n\n#include \"LIEF/visibility.h\"\n\n#include \"LIEF/PE/enums.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV7.hpp\"\n\nnamespace LIEF {\nnamespace PE {\n\nnamespace details {\ntemplate<class T>\nstruct load_configuration_v8;\n}\n\nclass LIEF_API LoadConfigurationV8 : public LoadConfigurationV7 {\n  public:\n\n  static constexpr WIN_VERSION VERSION = WIN_VERSION::WIN10_0_18362;\n  LoadConfigurationV8();\n\n  template<class T>\n  LIEF_LOCAL LoadConfigurationV8(const details::load_configuration_v8<T>& header);\n\n  LoadConfigurationV8& operator=(const LoadConfigurationV8&);\n  LoadConfigurationV8(const LoadConfigurationV8&);\n\n  WIN_VERSION version() const override {\n    return LoadConfigurationV8::VERSION;\n  }\n\n  uint64_t volatile_metadata_pointer() const {\n    return volatile_metadata_pointer_;\n  }\n\n  void volatile_metadata_pointer(uint64_t value) {\n    volatile_metadata_pointer_ = value;\n  }\n\n  ~LoadConfigurationV8() override;\n\n  void accept(Visitor& visitor) const override;\n\n  bool operator==(const LoadConfigurationV8& rhs) const;\n  bool operator!=(const LoadConfigurationV8& rhs) const;\n\n  std::ostream& print(std::ostream& os) const override;\n\n  protected:\n  uint64_t volatile_metadata_pointer_ = 0;\n};\n}\n}\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/LoadConfigurations.hpp'\n:\n#ifndef LIEF_PE_LOAD_CONFIGURATIONS_H\n#define LIEF_PE_LOAD_CONFIGURATIONS_H\n\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV11.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV10.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV9.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV8.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV7.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV6.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV5.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV4.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV3.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV2.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV1.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfigurationV0.hpp\"\n#include \"LIEF/PE/LoadConfigurations/LoadConfiguration.hpp\"\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'\n:\n#ifndef LIEF_TO_JSON_H\n#define LIEF_TO_JSON_H\n\n#include \"LIEF/config.h\"\n\n#ifdef LIEF_JSON_SUPPORT\n\n\n#ifdef LIEF_ELF_SUPPORT\n#include \"LIEF/ELF/json.hpp\"\n#endif\n\n#ifdef LIEF_PE_SUPPORT\n#include \"LIEF/PE/json.hpp\"\n#endif\n\n#include \"LIEF/Abstract/json.hpp\"\n\n#include \"LIEF/Abstract.hpp\"\n#include \"LIEF/ELF.hpp\"\n#include \"LIEF/PE.hpp\"\n\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE.hpp'\n:\n#ifndef LIEF_PE_H\n#define LIEF_PE_H\n\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_PE_SUPPORT)\n\n#include \"LIEF/PE/Parser.hpp\"\n#include \"LIEF/PE/Section.hpp\"\n#include \"LIEF/PE/TLS.hpp\"\n#include \"LIEF/PE/Export.hpp\"\n#include \"LIEF/PE/ExportEntry.hpp\"\n#include \"LIEF/PE/Import.hpp\"\n#include \"LIEF/PE/ImportEntry.hpp\"\n#include \"LIEF/PE/DelayImport.hpp\"\n#include \"LIEF/PE/DelayImportEntry.hpp\"\n#include \"LIEF/PE/Pogo.hpp\"\n#include \"LIEF/PE/PogoEntry.hpp\"\n#include \"LIEF/PE/DataDirectory.hpp\"\n#include \"LIEF/PE/ResourcesManager.hpp\"\n#include \"LIEF/PE/ResourceData.hpp\"\n#include \"LIEF/PE/ResourceNode.hpp\"\n#include \"LIEF/PE/ResourceDirectory.hpp\"\n#include \"LIEF/PE/resources/LangCodeItem.hpp\"\n#include \"LIEF/PE/resources/ResourceAccelerator.hpp\"\n#include \"LIEF/PE/resources/ResourceDialog.hpp\"\n#include \"LIEF/PE/resources/ResourceDialogItem.hpp\"\n#include \"LIEF/PE/resources/ResourceFixedFileInfo.hpp\"\n#include \"LIEF/PE/resources/ResourceIcon.hpp\"\n#include \"LIEF/PE/resources/ResourceStringFileInfo.hpp\"\n#include \"LIEF/PE/resources/ResourceStringTable.hpp\"\n#include \"LIEF/PE/resources/ResourceVarFileInfo.hpp\"\n#include \"LIEF/PE/resources/ResourceVersion.hpp\"\n#include \"LIEF/PE/RichEntry.hpp\"\n#include \"LIEF/PE/RichHeader.hpp\"\n#include \"LIEF/PE/Symbol.hpp\"\n#include \"LIEF/PE/Relocation.hpp\"\n#include \"LIEF/PE/RelocationEntry.hpp\"\n#include \"LIEF/PE/Symbol.hpp\"\n#include \"LIEF/PE/Builder.hpp\"\n#include \"LIEF/PE/Binary.hpp\"\n#include \"LIEF/PE/Debug.hpp\"\n#include \"LIEF/PE/DosHeader.hpp\"\n#include \"LIEF/PE/Header.hpp\"\n#include \"LIEF/PE/OptionalHeader.hpp\"\n#include \"LIEF/PE/CodeView.hpp\"\n#include \"LIEF/PE/CodeViewPDB.hpp\"\n#include \"LIEF/PE/LoadConfigurations.hpp\"\n#include \"LIEF/PE/AuxiliarySymbol.hpp\"\n#include \"LIEF/PE/CodeIntegrity.hpp\"\n\n#include \"LIEF/PE/signature/attributes.hpp\"\n#include \"LIEF/PE/signature/Attribute.hpp\"\n#include \"LIEF/PE/signature/ContentInfo.hpp\"\n#include \"LIEF/PE/signature/OIDToString.hpp\"\n#include \"LIEF/PE/signature/Signature.hpp\"\n#include \"LIEF/PE/signature/SignerInfo.hpp\"\n#include \"LIEF/PE/signature/types.hpp\"\n#include \"LIEF/PE/signature/x509.hpp\"\n\n#include \"LIEF/PE/hash.hpp\"\n#include \"LIEF/PE/enums.hpp\"\n#include \"LIEF/PE/EnumToString.hpp\"\n#include \"LIEF/PE/utils.hpp\"\n\n#endif\n\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/LoadConfigurations/LoadConfigurationV8.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/LoadConfigurations.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/enums.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/EnumToString.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'\n:\n#ifndef LIEF_MAIN_HEADER_H\n#define LIEF_MAIN_HEADER_H\n#include <LIEF/config.h>\n\n#include <LIEF/Abstract.hpp>\n\n#include <LIEF/OAT.hpp>\n#include <LIEF/VDEX.hpp>\n#include <LIEF/ART.hpp>\n#include <LIEF/DEX.hpp>\n#include <LIEF/ELF.hpp>\n#include <LIEF/PE.hpp>\n#include <LIEF/MachO.hpp>\n#include <LIEF/DWARF.hpp>\n#include <LIEF/logging.hpp>\n#include <LIEF/platforms.hpp>\n\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/enums.hpp'\n:\n#ifndef LIEF_DEX_ENUMS_H\n#define LIEF_DEX_ENUMS_H\n\nnamespace LIEF {\nnamespace DEX {\n\nenum ACCESS_FLAGS {\n  ACC_UNKNOWN               = 0x0,\n  ACC_PUBLIC                = 0x1,\n  ACC_PRIVATE               = 0x2,\n  ACC_PROTECTED             = 0x4,\n  ACC_STATIC                = 0x8,\n  ACC_FINAL                 = 0x10,\n  ACC_SYNCHRONIZED          = 0x20,\n  ACC_VOLATILE              = 0x40,\n  ACC_BRIDGE                = 0x40,\n  ACC_TRANSIENT             = 0x80,\n  ACC_VARARGS               = 0x80,\n  ACC_NATIVE                = 0x100,\n  ACC_INTERFACE             = 0x200,\n  ACC_ABSTRACT              = 0x400,\n  ACC_STRICT                = 0x800,\n  ACC_SYNTHETIC             = 0x1000,\n  ACC_ANNOTATION            = 0x2000,\n  ACC_ENUM                  = 0x4000,\n  ACC_CONSTRUCTOR           = 0x10000,\n  ACC_DECLARED_SYNCHRONIZED = 0x20000\n};\n\n\nenum METHOD_TYPES {\n  METHOD_UNKNOWN      = 0x00,\n  METHOD_VIRTUAL      = 0x01,\n  METHOD_DIRECT       = 0x02,\n\n  METHOD_EXTERN       = 0x03,\n  METHOD_CTOR         = 0x04,\n  METHOD_STATIC       = 0x05,\n  METHOD_STATIC_CTOR  = 0x06,\n};\n\nstatic const ACCESS_FLAGS access_flags_list[] = {\n  ACCESS_FLAGS::ACC_UNKNOWN,\n  ACCESS_FLAGS::ACC_PUBLIC,\n  ACCESS_FLAGS::ACC_PRIVATE,\n  ACCESS_FLAGS::ACC_PROTECTED,\n  ACCESS_FLAGS::ACC_STATIC,\n  ACCESS_FLAGS::ACC_FINAL,\n  ACCESS_FLAGS::ACC_SYNCHRONIZED,\n  ACCESS_FLAGS::ACC_VOLATILE,\n  ACCESS_FLAGS::ACC_BRIDGE,\n  ACCESS_FLAGS::ACC_TRANSIENT,\n  ACCESS_FLAGS::ACC_VARARGS,\n  ACCESS_FLAGS::ACC_NATIVE,\n  ACCESS_FLAGS::ACC_INTERFACE,\n  ACCESS_FLAGS::ACC_ABSTRACT,\n  ACCESS_FLAGS::ACC_STRICT,\n  ACCESS_FLAGS::ACC_SYNTHETIC,\n  ACCESS_FLAGS::ACC_ANNOTATION,\n  ACCESS_FLAGS::ACC_ENUM,\n  ACCESS_FLAGS::ACC_CONSTRUCTOR,\n  ACCESS_FLAGS::ACC_DECLARED_SYNCHRONIZED,\n};\n\n}\n}\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/EnumToString.hpp'\n:\n#ifndef LIEF_DEX_ENUM_TO_STRING_H\n#define LIEF_DEX_ENUM_TO_STRING_H\n#include \"LIEF/visibility.h\"\n#include \"LIEF/DEX/enums.hpp\"\n#include \"LIEF/DEX/MapItem.hpp\"\n#include \"LIEF/DEX/Type.hpp\"\n\nnamespace LIEF {\nnamespace DEX {\n\nLIEF_API const char* to_string(MapItem::TYPES e);\nLIEF_API const char* to_string(ACCESS_FLAGS e);\nLIEF_API const char* to_string(Type::TYPES e);\nLIEF_API const char* to_string(Type::PRIMITIVES e);\n\n}\n}\n\n#endif\n\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'\n:\n#ifndef LIEF_DEX_H\n#define LIEF_DEX_H\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_DEX_SUPPORT)\n#include \"LIEF/DEX/Parser.hpp\"\n#include \"LIEF/DEX/utils.hpp\"\n#include \"LIEF/DEX/File.hpp\"\n#include \"LIEF/DEX/Class.hpp\"\n#include \"LIEF/DEX/Prototype.hpp\"\n#include \"LIEF/DEX/Header.hpp\"\n#include \"LIEF/DEX/Method.hpp\"\n#include \"LIEF/DEX/Field.hpp\"\n#include \"LIEF/DEX/EnumToString.hpp\"\n#endif\n\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/enums.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/EnumToString.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'"
        ]
    },
    {
        "files": [
            "'webpp/sdk/wsdk/cmds/command.hpp'",
            "'webpp/sdk/wpp/main.cpp'",
            "'webpp/webpp/std/vector.hpp'"
        ],
        "content": "'webpp/sdk/wsdk/cmds/command.hpp'\n:#ifndef WEBPP_SDK_CMDS_CMD\n#define WEBPP_SDK_CMDS_CMD\n\n#include \"command_options.hpp\"\n\n#include <webpp/logs/dynamic_logger.hpp>\n#include <webpp/std/string_view.hpp>\n#include <webpp/std/vector.hpp>\n\nnamespace webpp::sdk {\n\n    enum struct command_status {\n\n        success,\n        empty_command,\n\n\n        unknown_error,\n        invalid_command\n    };\n\n\n    stl::string_view to_string(command_status status) noexcept;\n    int              to_exit_status(command_status) noexcept;\n\n    struct command {\n        command()                                   = default;\n        command(command const&)                     = delete;\n        command(command&&) noexcept                 = default;\n        command& operator=(command const&) noexcept = delete;\n        command& operator=(command&&) noexcept      = default;\n        virtual ~command()                          = default;\n\n\n        [[nodiscard]] virtual stl::string_view name() const noexcept = 0;\n\n\n        [[nodiscard]] virtual stl::string_view desc() const noexcept = 0;\n\n\n        virtual command_status start(command_options) = 0;\n    };\n\n\n    struct command_manager {\n        command_manager(stl::shared_ptr<output_port> inp_output = stl::make_shared<stdout_output_port>(),\n                        dynamic_logger               logger     = {});\n        command_manager(command_manager&&) noexcept            = default;\n        command_manager(command_manager const&)                = delete;\n        command_manager& operator=(command_manager&&) noexcept = default;\n        command_manager& operator=(command_manager const&)     = delete;\n        ~command_manager()                                     = default;\n\n\n        command_status run_command(int argc, char const** argv);\n\n\n        command_status run_command(stl::string_view);\n\n      private:\n        stl::shared_ptr<output_port> output;\n        dynamic_logger               logger;\n    };\n\n}\n\n\n#endif\n\n'webpp/sdk/wpp/main.cpp'\n:#include <webpp/logs/dynamic_logger.hpp>\n#include <webpp/std/utility.hpp>\n#include <wsdk/cmds/command.hpp>\n\ninline constexpr auto log_cat = \"main\";\n\nauto main(int argc, char const** argv) -> int {\n    using namespace webpp::sdk;\n\n    webpp::dynamic_logger const               logger;\n    webpp::stl::shared_ptr<output_port> const output = webpp::stl::make_shared<stdout_output_port>();\n    try {\n        command_manager manager{output, logger};\n        auto const      cmd_res = manager.run_command(argc, argv);\n        logger.info(log_cat, to_string(cmd_res));\n        return to_exit_status(cmd_res);\n    } catch (std::exception const& ex) {\n        logger.critical(log_cat, \"This exception has propagated to the top.\", ex);\n        return EXIT_FAILURE;\n    } catch (...) {\n        logger.critical(log_cat, \"This unknown error has propagated to the top.\");\n        return EXIT_FAILURE;\n    }\n}\n\n'webpp/webpp/std/vector.hpp'\n:\n\n#ifndef WEBPP_VECTOR_H\n#define WEBPP_VECTOR_H\n\n#include \"../traits/default_traits.hpp\"\n#include \"std.hpp\"\n\n#include <vector>\n\n\nnamespace webpp::istl {\n\n    template <typename T,\n              Traits TraitsType  = default_traits,\n              typename Allocator = traits::allocator_type_of<TraitsType, T>>\n    using vector = stl::vector<T, Allocator>;\n\n}\n\n#endif\n",
        "gt": [
            "'webpp/webpp/std/vector.hpp'",
            "'webpp/sdk/wsdk/cmds/command.hpp'",
            "'webpp/sdk/wpp/main.cpp'"
        ]
    },
    {
        "files": [
            "'pyeos/externals/thrift/src/thrift/windows/TWinsockSingleton.h'",
            "'pyeos/externals/thrift/src/thrift/windows/config.h'",
            "'pyeos/externals/thrift/src/thrift/thrift-config.h'",
            "'pyeos/externals/thrift/src/thrift/concurrency/BoostMonitor.cpp'"
        ],
        "content": "'pyeos/externals/thrift/src/thrift/windows/TWinsockSingleton.h'\n:\n\n#ifndef _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_\n#define _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_ 1\n\n#if defined(_MSC_VER) && (_MSC_VER > 1200)\n#pragma once\n#endif\n\n#ifndef _WIN32\n#error This is a MSVC header only.\n#endif\n\n#include <thrift/thrift-config.h>\n\n\n#include <boost/noncopyable.hpp>\n\n#if USE_BOOST_THREAD\n#include <boost/thread/once.hpp>\n#elif USE_STD_THREAD\n#include <mutex>\n#else\n#error For windows you must choose USE_BOOST_THREAD or USE_STD_THREAD\n#endif\n\n#include <thrift/stdcxx.h>\n\nnamespace apache {\nnamespace thrift {\nnamespace transport {\n\n\nclass TWinsockSingleton : private boost::noncopyable {\n\npublic:\n  typedef stdcxx::shared_ptr<TWinsockSingleton> instance_ptr;\n\nprivate:\n  TWinsockSingleton(void);\n\npublic:\n  ~TWinsockSingleton(void);\n\npublic:\n  static void create(void);\n\nprivate:\n  static void init(void);\n\nprivate:\n  static instance_ptr instance_ptr_;\n#if USE_BOOST_THREAD\n  static boost::once_flag flags_;\n#elif USE_STD_THREAD\n  static std::once_flag flags_;\n#else\n#error Need a non-Boost non-C++11 way to track single initialization here.\n#endif\n};\n}\n}\n}\n\n#endif\n\n'pyeos/externals/thrift/src/thrift/windows/config.h'\n:\n\n#ifndef _THRIFT_WINDOWS_CONFIG_H_\n#define _THRIFT_WINDOWS_CONFIG_H_ 1\n\n#if defined(_MSC_VER) && (_MSC_VER > 1200)\n#pragma once\n#endif\n\n#ifndef _WIN32\n#error \"This is a Windows header only\"\n#endif\n\n\n#if (_MSC_VER >= 1700) || defined(__MINGW32__)\n#define USE_STD_THREAD 1\n#else\n\n#define USE_BOOST_THREAD 1\n#endif\n\n\n#define HAVE_INTTYPES_H 1\n\n\n#if (_MSC_VER >= 1600) || defined(__MINGW32__)\n#define HAVE_STDINT_H 1\n#endif\n\n#ifndef TARGET_WIN_XP\n#define TARGET_WIN_XP 1\n#endif\n\n#if TARGET_WIN_XP\n#ifndef WINVER\n#define WINVER 0x0501\n#endif\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x0501\n#endif\n#endif\n\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x0601\n#endif\n\n#if defined(_M_IX86) || defined(_M_X64)\n#define ARITHMETIC_RIGHT_SHIFT 1\n#define SIGNED_RIGHT_SHIFT_IS 1\n#endif\n\n#ifndef __MINGW32__\n#pragma warning(disable : 4996)\n#endif\n\n#define HAVE_GETTIMEOFDAY 1\n#define HAVE_SYS_STAT_H 1\n\n\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#else\n#include <boost/cstdint.hpp>\n\ntypedef boost::int64_t int64_t;\ntypedef boost::uint64_t uint64_t;\ntypedef boost::int32_t int32_t;\ntypedef boost::uint32_t uint32_t;\ntypedef boost::int16_t int16_t;\ntypedef boost::uint16_t uint16_t;\ntypedef boost::int8_t int8_t;\ntypedef boost::uint8_t uint8_t;\n#endif\n\n#include <thrift/transport/PlatformSocket.h>\n#include <thrift/windows/GetTimeOfDay.h>\n#include <thrift/windows/Operators.h>\n#include <thrift/windows/TWinsockSingleton.h>\n#include <thrift/windows/WinFcntl.h>\n#include <thrift/windows/SocketPair.h>\n\n\n#include <Winsock2.h>\n#include <ws2tcpip.h>\n#ifndef __MINGW32__\n  #ifdef _WIN32_WCE\n  #pragma comment(lib, \"Ws2.lib\")\n  #else\n  #pragma comment(lib, \"Ws2_32.lib\")\n  #pragma comment(lib, \"advapi32.lib\")\n  #pragma comment(lib, \"Shlwapi.lib\")\n  #endif\n#endif\n\n#endif\n\n'pyeos/externals/thrift/src/thrift/thrift-config.h'\n:\n\n#ifdef _WIN32\n#include <thrift/windows/config.h>\n#else\n#include <thrift/config.h>\n#endif\n\n'pyeos/externals/thrift/src/thrift/concurrency/BoostMonitor.cpp'\n:\n\n#include <thrift/thrift-config.h>\n\n#include <thrift/concurrency/Monitor.h>\n#include <thrift/concurrency/Exception.h>\n#include <thrift/concurrency/Util.h>\n#include <thrift/transport/PlatformSocket.h>\n#include <thrift/stdcxx.h>\n\n#include <assert.h>\n#include <boost/thread.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n\nnamespace apache {\nnamespace thrift {\nnamespace concurrency {\n\n\nclass Monitor::Impl : public boost::condition_variable_any {\n\npublic:\n  Impl() : ownedMutex_(new Mutex()), mutex_(NULL) { init(ownedMutex_.get()); }\n\n  Impl(Mutex* mutex) : mutex_(NULL) { init(mutex); }\n\n  Impl(Monitor* monitor) : mutex_(NULL) { init(&(monitor->mutex())); }\n\n  Mutex& mutex() { return *mutex_; }\n  void lock() { mutex().lock(); }\n  void unlock() { mutex().unlock(); }\n\n\n  void wait(int64_t timeout_ms) {\n    int result = waitForTimeRelative(timeout_ms);\n    if (result == THRIFT_ETIMEDOUT) {\n      throw TimedOutException();\n    } else if (result != 0) {\n      throw TException(\"Monitor::wait() failed\");\n    }\n  }\n\n\n  int waitForTimeRelative(int64_t timeout_ms) {\n    if (timeout_ms == 0LL) {\n      return waitForever();\n    }\n\n    assert(mutex_);\n    boost::timed_mutex* mutexImpl\n        = reinterpret_cast<boost::timed_mutex*>(mutex_->getUnderlyingImpl());\n    assert(mutexImpl);\n\n    boost::timed_mutex::scoped_lock lock(*mutexImpl, boost::adopt_lock);\n    int res\n        = timed_wait(lock, boost::get_system_time() + boost::posix_time::milliseconds(timeout_ms))\n              ? 0\n              : THRIFT_ETIMEDOUT;\n    lock.release();\n    return res;\n  }\n\n\n  int waitForTime(const THRIFT_TIMESPEC* abstime) {\n    struct timeval temp;\n    temp.tv_sec = static_cast<long>(abstime->tv_sec);\n    temp.tv_usec = static_cast<long>(abstime->tv_nsec) / 1000;\n    return waitForTime(&temp);\n  }\n\n\n  int waitForTime(const struct timeval* abstime) {\n    assert(mutex_);\n    boost::timed_mutex* mutexImpl = static_cast<boost::timed_mutex*>(mutex_->getUnderlyingImpl());\n    assert(mutexImpl);\n\n    struct timeval currenttime;\n    Util::toTimeval(currenttime, Util::currentTime());\n\n    long tv_sec = static_cast<long>(abstime->tv_sec - currenttime.tv_sec);\n    long tv_usec = static_cast<long>(abstime->tv_usec - currenttime.tv_usec);\n    if (tv_sec < 0)\n      tv_sec = 0;\n    if (tv_usec < 0)\n      tv_usec = 0;\n\n    boost::timed_mutex::scoped_lock lock(*mutexImpl, boost::adopt_lock);\n    int res = timed_wait(lock,\n                         boost::get_system_time() + boost::posix_time::seconds(tv_sec)\n                         + boost::posix_time::microseconds(tv_usec))\n                  ? 0\n                  : THRIFT_ETIMEDOUT;\n    lock.release();\n    return res;\n  }\n\n\n  int waitForever() {\n    assert(mutex_);\n    boost::timed_mutex* mutexImpl\n        = reinterpret_cast<boost::timed_mutex*>(mutex_->getUnderlyingImpl());\n    assert(mutexImpl);\n\n    boost::timed_mutex::scoped_lock lock(*mutexImpl, boost::adopt_lock);\n    ((boost::condition_variable_any*)this)->wait(lock);\n    lock.release();\n    return 0;\n  }\n\n  void notify() { notify_one(); }\n\n  void notifyAll() { notify_all(); }\n\nprivate:\n  void init(Mutex* mutex) { mutex_ = mutex; }\n\n  stdcxx::scoped_ptr<Mutex> ownedMutex_;\n  Mutex* mutex_;\n};\n\nMonitor::Monitor() : impl_(new Monitor::Impl()) {\n}\nMonitor::Monitor(Mutex* mutex) : impl_(new Monitor::Impl(mutex)) {\n}\nMonitor::Monitor(Monitor* monitor) : impl_(new Monitor::Impl(monitor)) {\n}\n\nMonitor::~Monitor() {\n  delete impl_;\n}\n\nMutex& Monitor::mutex() const {\n  return const_cast<Monitor::Impl*>(impl_)->mutex();\n}\n\nvoid Monitor::lock() const {\n  const_cast<Monitor::Impl*>(impl_)->lock();\n}\n\nvoid Monitor::unlock() const {\n  const_cast<Monitor::Impl*>(impl_)->unlock();\n}\n\nvoid Monitor::wait(int64_t timeout) const {\n  const_cast<Monitor::Impl*>(impl_)->wait(timeout);\n}\n\nint Monitor::waitForTime(const THRIFT_TIMESPEC* abstime) const {\n  return const_cast<Monitor::Impl*>(impl_)->waitForTime(abstime);\n}\n\nint Monitor::waitForTime(const timeval* abstime) const {\n  return const_cast<Monitor::Impl*>(impl_)->waitForTime(abstime);\n}\n\nint Monitor::waitForTimeRelative(int64_t timeout_ms) const {\n  return const_cast<Monitor::Impl*>(impl_)->waitForTimeRelative(timeout_ms);\n}\n\nint Monitor::waitForever() const {\n  return const_cast<Monitor::Impl*>(impl_)->waitForever();\n}\n\nvoid Monitor::notify() const {\n  const_cast<Monitor::Impl*>(impl_)->notify();\n}\n\nvoid Monitor::notifyAll() const {\n  const_cast<Monitor::Impl*>(impl_)->notifyAll();\n}\n}\n}\n}\n",
        "gt": [
            "'pyeos/externals/thrift/src/thrift/windows/TWinsockSingleton.h'",
            "'pyeos/externals/thrift/src/thrift/windows/config.h'",
            "'pyeos/externals/thrift/src/thrift/thrift-config.h'",
            "'pyeos/externals/thrift/src/thrift/concurrency/BoostMonitor.cpp'"
        ]
    },
    {
        "files": [
            "'godot-roguelite/src/main.cpp'",
            "'godot-roguelite/src/main.hpp'",
            "'godot-roguelite/src/entity/controller/player_controller.hpp'",
            "'godot-roguelite/src/entity/level.hpp'"
        ],
        "content": "'godot-roguelite/src/main.cpp'\n:#include \"core/assert.hpp\"\n#include \"main.hpp\"\n#include \"util/conversions.hpp\"\n#include \"util/engine.hpp\"\n#include \"util/input.hpp\"\n\nnamespace rl\n{\n    Main::Main()\n    {\n        resource::preload::packed_scene<Level> level{ path::scene::Level1 };\n        resource::preload::packed_scene<MainDialog> dialog{ path::ui::MainDialog };\n\n        m_active_level = level.instantiate();\n        runtime_assert(m_active_level != nullptr);\n        m_main_dialog = dialog.instantiate();\n        runtime_assert(m_main_dialog != nullptr);\n\n        if (m_main_dialog != nullptr)\n        {\n            m_canvas_layer = gdcast<godot::CanvasLayer>(\n                m_main_dialog->find_child(name::dialog::canvas_layer, true, false));\n\n            runtime_assert(m_canvas_layer != nullptr);\n            if (m_active_level != nullptr && m_canvas_layer != nullptr)\n                m_canvas_layer->add_child(m_active_level);\n\n            if (m_main_dialog != nullptr)\n                this->add_child(m_main_dialog);\n        }\n    }\n\n    void Main::_ready()\n    {\n        this->apply_default_settings();\n    }\n\n    void Main::_physics_process(double delta)\n    {\n        if (engine::editor_active())\n            return;\n\n        m_signal_timer += delta;\n        if (m_signal_timer > 1.0)\n        {\n            this->emit_signal(event::signal_example, delta);\n            m_signal_timer -= 1.0;\n        }\n    }\n\n    void Main::apply_default_settings()\n    {\n        engine::set_fps(60);\n        input::use_accumulated_inputs(false);\n\n        if (not engine::editor_active())\n            engine::root_window()->set_size({ 1920, 1080 });\n    }\n}\n\n'godot-roguelite/src/main.hpp'\n:#pragma once\n\n#include <godot_cpp/classes/canvas_layer.hpp>\n#include <godot_cpp/classes/node.hpp>\n\n#include \"entity/level.hpp\"\n#include \"ui/main_dialog.hpp\"\n\nnamespace rl\n{\n    class Main : public godot::Node\n    {\n        GDCLASS(Main, godot::Node);\n\n    public:\n        Main();\n        ~Main() = default;\n\n        void _ready() override;\n        void _physics_process(double delta) override;\n\n    protected:\n        void apply_default_settings();\n\n        static void _bind_methods()\n        {\n            signal_binding<Main, event::signal_example>::add<double>();\n        }\n\n    private:\n        double m_signal_timer{ 0.0 };\n        godot::CanvasLayer* m_canvas_layer{ nullptr };\n        MainDialog* m_main_dialog{ nullptr };\n        Level* m_active_level{ nullptr };\n    };\n}\n\n'godot-roguelite/src/entity/controller/player_controller.hpp'\n:#pragma once\n\n#include \"entity/controller/character_controller.hpp\"\n\nnamespace rl\n{\n    class PlayerController : public CharacterController\n    {\n        GDCLASS(PlayerController, CharacterController);\n\n    public:\n        PlayerController() = default;\n        ~PlayerController() = default;\n\n        void process_action_input(godot::Input* const input, double delta_time) override;\n        void process_movement_input(godot::Input* const input, double delta_time) override;\n        void process_rotation_input(godot::Input* const input, double delta_time) override;\n        InputMode get_input_mode(godot::Input* const input);\n\n    protected:\n        static void _bind_methods()\n        {\n        }\n    };\n}\n\n'godot-roguelite/src/entity/level.hpp'\n:#pragma once\n\n#include <atomic>\n#include <vector>\n\n#include <godot_cpp/classes/node2d.hpp>\n#include <godot_cpp/classes/sprite2d.hpp>\n\n#include \"core/constants.hpp\"\n#include \"entity/character/player.hpp\"\n#include \"entity/controller/player_controller.hpp\"\n#include \"entity/projectile/projectile_spawner.hpp\"\n#include \"util/bind.hpp\"\n#include \"util/scene.hpp\"\n\nnamespace godot\n{\n    class RigidBody2D;\n}\n\nnamespace rl\n{\n    class Player;\n\n    class Level : public godot::Node2D\n    {\n        GDCLASS(Level, godot::Node2D);\n\n    public:\n        Level();\n        ~Level() = default;\n\n        virtual void _ready() override;\n        void _draw() override;\n        void _process(double delta_time) override;\n\n        void activate(bool active = true);\n        bool active() const;\n\n    protected:\n        static void _bind_methods();\n\n        [[signal_slot]] void on_physics_box_entered(godot::Node* node) const;\n        [[signal_slot]] void on_physics_box_exited(godot::Node* node) const;\n        [[signal_slot]] void on_player_spawn_projectile(godot::Node* obj);\n        [[signal_slot]] void on_character_position_changed(const godot::Object* const obj,\n                                                           godot::Vector2 location) const;\n\n    private:\n        std::atomic<bool> m_active{ false };\n        godot::Node* m_background{ nullptr };\n        ProjectileSpawner* m_projectile_spawner{ memnew(rl::ProjectileSpawner) };\n        Player* m_player{ nullptr };\n        godot::RigidBody2D* m_physics_box{ nullptr };\n    };\n}\n",
        "gt": [
            "'godot-roguelite/src/entity/controller/player_controller.hpp'",
            "'godot-roguelite/src/entity/level.hpp'",
            "'godot-roguelite/src/main.hpp'",
            "'godot-roguelite/src/main.cpp'"
        ]
    },
    {
        "files": [
            "'slslam/src/parameter.h'",
            "'slslam/src/main.cpp'",
            "'slslam/src/slam.h'"
        ],
        "content": "'slslam/src/parameter.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef PARAMETER_H_\n#define PARAMETER_H_\n\nnamespace {\n\n  const int max_feat_num = 5;\n  const int max_trials = 1000;\n\n#ifdef IT3F\n  const string img_dir = \"../data/it3f/left_rect\";\n  const string obs_dir = \"../data/it3f/line_tracking_result\";\n#endif\n\n#ifdef OLYMPIC4F\n  const string img_dir = \"../data/olympic4f/left_rect\";\n  const string obs_dir = \"../data/olympic4f/line_tracking_result\";\n#endif\n\n#ifdef MYUNGDONG\n  const string img_dir = \"../data/myung-dong/left_rect\";\n  const string obs_dir = \"../data/myung-dong/line_tracking_result\";\n#endif\n\n  const int image_width = 640;\n  const int image_height = 480;\n\n  const double baseline = 0.12;\n  const double focal_length = 406.05;\n  const double cx1 = 327.783;\n  const double cy1 = 237.172;\n\n  const double fx1 = focal_length;\n  const double fy1 = focal_length;\n  const double prob_free_outliers = 0.999;\n\n  const double inverse_depth = 0.1;\n  const double error_thr = 5 / focal_length;\n\n\n  const double kf_rot_thr = 15 * 3.141592654 / 180;\n  const double kf_tr_thr = 0.75;\n  const double line_vn_angle_thr = 3 * 3.141592654 / 180;\n  const double extension_length = 5.0;\n}\n\n#endif\n\n'slslam/src/main.cpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"slam.h\"\n\nDEFINE_int32(ba_window_size, 10, \"Local Bundle Adjustment moving window size\");\nDEFINE_int32(max_num_iter, 10, \"Maximum number of iteration in BA\");\nDEFINE_int32(delay, 5, \"Time delay in [ms] for OpenCV visualization\");\nDEFINE_int32(stopfrm, 99999, \"Stop frame number\");\nDEFINE_int32(rseed, 4, \"Random Seed\");\nDEFINE_bool(robust, true, \"Use robust function\");\n\nint main(int argc, char *argv[])\n{\n  google::ParseCommandLineFlags(&argc, &argv, true);\n\n  if ( system( \"rm *.txt\" ) );\n  if ( system( \"rm output/tracking\n",
        "gt": [
            "'slslam/src/parameter.h'",
            "'slslam/src/slam.h'",
            "'slslam/src/main.cpp'"
        ]
    },
    {
        "files": [
            "'LearnVulkan/third_party/gli/gli/gli.hpp'",
            "'LearnVulkan/third_party/gli/gli/save.hpp'",
            "'LearnVulkan/third_party/gli/gli/save_dds.hpp'"
        ],
        "content": "'LearnVulkan/third_party/gli/gli/gli.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n#define GLI_VERSION\t\t\t\t\t83\n#define GLI_VERSION_MAJOR\t\t\t0\n#define GLI_VERSION_MINOR\t\t\t8\n#define GLI_VERSION_PATCH\t\t\t3\n#define GLI_VERSION_REVISION\t\t0\n\n\nnamespace gli\n{\n\n}\n\n#include \"format.hpp\"\n#include \"target.hpp\"\n#include \"levels.hpp\"\n\n#include \"image.hpp\"\n#include \"texture.hpp\"\n#include \"texture1d.hpp\"\n#include \"texture1d_array.hpp\"\n#include \"texture2d.hpp\"\n#include \"texture2d_array.hpp\"\n#include \"texture3d.hpp\"\n#include \"texture_cube.hpp\"\n#include \"texture_cube_array.hpp\"\n\n#include \"sampler1d.hpp\"\n#include \"sampler1d_array.hpp\"\n#include \"sampler2d.hpp\"\n#include \"sampler2d_array.hpp\"\n#include \"sampler3d.hpp\"\n#include \"sampler_cube.hpp\"\n#include \"sampler_cube_array.hpp\"\n\n#include \"duplicate.hpp\"\n#include \"convert.hpp\"\n#include \"view.hpp\"\n#include \"comparison.hpp\"\n\n#include \"reduce.hpp\"\n#include \"transform.hpp\"\n\n#include \"load.hpp\"\n#include \"save.hpp\"\n\n#include \"gl.hpp\"\n#include \"dx.hpp\"\n\n#include \"./core/flip.hpp\"\n\n'LearnVulkan/third_party/gli/gli/save.hpp'\n:\n\n\n#pragma once\n\n#include \"save_dds.hpp\"\n#include \"save_ktx.hpp\"\n\nnamespace gli\n{\n\n\n\n\n\n\n\tbool save(texture const & Texture, char const * Path);\n\n\n\n\n\n\n\n\tbool save(texture const & Texture, std::string const & Path);\n}\n\n#include \"./core/save.inl\"\n\n'LearnVulkan/third_party/gli/gli/save_dds.hpp'\n:\n\n\n#pragma once\n\n#include \"texture.hpp\"\n\nnamespace gli\n{\n\n\n\n\n\n\n\tbool save_dds(texture const & Texture, char const* Path);\n\n\n\n\n\n\n\n\tbool save_dds(texture const & Texture, std::string const & Path);\n\n\n\n\n\n\n\tbool save_dds(texture const & Texture, std::vector<char> & Memory);\n}\n\n#include \"./core/save_dds.inl\"\n",
        "gt": [
            "'LearnVulkan/third_party/gli/gli/save_dds.hpp'",
            "'LearnVulkan/third_party/gli/gli/save.hpp'",
            "'LearnVulkan/third_party/gli/gli/gli.hpp'"
        ]
    },
    {
        "files": [
            "'egoboo/egolib/library/src/egolib/integrations/events.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/InventorySlot.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/InventorySlot.cpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/Component.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/InputListener.hpp'"
        ],
        "content": "'egoboo/egolib/library/src/egolib/integrations/events.hpp'\n:#pragma once\n\n#include \"idlib/game_engine.hpp\"\n\nnamespace Ego::Events {\n\nusing MouseButtonClickedEvent = idlib::events::mouse_button_clicked_event;\nusing MouseButtonPressedEvent = idlib::events::mouse_button_pressed_event;\nusing MouseButtonReleasedEvent = idlib::events::mouse_button_released_event;\n\nusing KeyboardKeyTypedEvent = idlib::events::keyboard_key_typed_event;\nusing KeyboardKeyPressedEvent = idlib::events::keyboard_key_pressed_event;\nusing KeyboardKeyReleasedEvent = idlib::events::keyboard_key_released_event;\n\nusing MousePointerEnteredEvent = idlib::events::mouse_pointer_entered_event;\nusing MousePointerExitedEvent = idlib::events::mouse_pointer_exited_event;\nusing MousePointerMovedEvent = idlib::events::mouse_pointer_moved_event;\n\nusing MouseWheelTurnedEvent = idlib::events::mouse_wheel_turned_event;\n\n}\n\n'egoboo/egolib/library/src/egolib/game/GUI/InventorySlot.hpp'\n:#pragma once\n\n#include \"egolib/game/GUI/Component.hpp\"\n#include \"egolib/game/Inventory.hpp\"\n\n\nnamespace Ego { class Player; }\n\nnamespace Ego {\nnamespace GUI {\n\nclass InventorySlot : public Component {\npublic:\n    InventorySlot(const Inventory &inventory, const size_t slotNumber, const std::shared_ptr<Player>& player);\n\n    virtual void draw(Ego::GUI::DrawingContext& drawingContext) override;\n\n    bool notifyMousePointerMoved(const Events::MousePointerMovedEvent& e) override;\n    bool notifyMouseButtonPressed(const Events::MouseButtonPressedEvent& e) override;\n\nprivate:\n    const Inventory& _inventory;\n    size_t _slotNumber;\n    std::shared_ptr<Player> _player;\n};\n\n}\n}\n\n\n'egoboo/egolib/library/src/egolib/game/GUI/InventorySlot.cpp'\n:#include \"InventorySlot.hpp\"\n#include \"egolib/Entities/_Include.hpp\"\n#include \"egolib/Graphics/ModelDescriptor.hpp\"\n#include \"egolib/game/game.h\"\n#include \"egolib/game/Logic/Player.hpp\"\n\nnamespace Ego {\nnamespace GUI {\n\nInventorySlot::InventorySlot(const Inventory &inventory, const size_t slotNumber, const std::shared_ptr<Player>& player) :\n    _inventory(inventory),\n    _slotNumber(slotNumber),\n    _player(player) {\n\n}\n\nvoid InventorySlot::draw(DrawingContext& drawingContext) {\n    std::shared_ptr<Object> item = _inventory.getItem(_slotNumber);\n\n\n    std::shared_ptr<const Texture> icon_ref;\n\n\n    if (item) {\n        icon_ref = item->getIcon();\n    } else {\n        icon_ref = TextureManager::get().getTexture(\"mp_data/nullicon\");\n    }\n\n    bool selected = false;\n    if (_player) {\n        selected = _player->getSelectedInventorySlot() == _slotNumber;\n    }\n\n\n    draw_game_icon(icon_ref, getDerivedPosition().x(), getDerivedPosition().y(), selected ? COLOR_WHITE : NOSPARKLE, update_wld, getWidth());\n\n\n    if (item) {\n        if (0 != item->ammomax && item->ammoknown) {\n            if (!item->getProfile()->isStackable() || item->getAmmo() > 1) {\n\n                _gameEngine->getUIManager()->getFont(UIManager::FONT_GAME)->drawTextBox(std::to_string(item->getAmmo()), getDerivedPosition().x(), getDerivedPosition().y(), getWidth(), getHeight(), 0);\n            }\n        }\n    }\n}\n\nbool InventorySlot::notifyMousePointerMoved(const Events::MousePointerMovedEvent& e) {\n    bool mouseOver = contains(e.get_position());\n\n    if (mouseOver) {\n        if (_player) {\n            _player->setSelectedInventorySlot(_slotNumber);\n        }\n        return true;\n    }\n\n    return false;\n}\n\n\nbool InventorySlot::notifyMouseButtonPressed(const Events::MouseButtonPressedEvent& e) {\n    if (!_player || !contains(e.get_position())) {\n        return false;\n    }\n\n    if (e.get_button() != SDL_BUTTON_LEFT && e.get_button() != SDL_BUTTON_RIGHT) {\n        return false;\n    }\n\n    const std::shared_ptr<Object> &pchr = _player->getObject();\n    if (pchr->isAlive() && pchr->inst.canBeInterrupted() && 0 == pchr->reload_timer) {\n\n        Inventory::swap_item(pchr->getObjRef(), _slotNumber, e.get_button() == SDL_BUTTON_LEFT ? SLOT_LEFT : SLOT_RIGHT, false);\n\n\n        pchr->inst.playAction(ACTION_MG, false);\n        pchr->reload_timer = Inventory::PACKDELAY;\n        return true;\n    }\n\n    return false;\n}\n\n}\n}\n'egoboo/egolib/library/src/egolib/game/GUI/Component.hpp'\n:#pragma once\n\n#include \"egolib/game/GUI/DrawingContext.hpp\"\n#include \"egolib/game/Core/GameEngine.hpp\"\n#include \"egolib/game/GUI/UIManager.hpp\"\n#include \"egolib/game/GUI/InputListener.hpp\"\n#include \"egolib/game/graphic.h\"\n\nnamespace Ego {\nnamespace GUI {\n\n\nclass Container;\n\nclass Component : public InputListener, public std::enable_shared_from_this<Component>, private idlib::non_copyable {\npublic:\n    Component();\n\n\n    virtual void draw(DrawingContext& drawingContext) = 0;\n\n\n\n    virtual bool isEnabled() const;\n\n\n    virtual void setEnabled(const bool enabled);\n\n\n\n    virtual bool isVisible() const;\n\n\n    void setVisible(const bool visible);\n\n\n\n    Rectangle2f getDerivedBounds() const;\n\n\n    const Rectangle2f& getBounds() const;\n\n\n    virtual void setSize(const Vector2f& size);\n\n\n    virtual void setPosition(const Point2f& position);\n\n    Point2f getPosition() const;\n    Vector2f getSize() const;\n    float getX() const;\n    float getY() const;\n    float getWidth() const;\n    float getHeight() const;\n\n    void setCenterPosition(const Point2f& position, const bool onlyHorizontal = false);\n    virtual void setWidth(float width);\n    virtual void setHeight(float height);\n\n    virtual void setX(float x);\n    virtual void setY(float y);\n\n\n\n    bool contains(const Point2f& point) const;\n\n\n\n    void setParent(Container *parent);\n\n\n\n    Container *getParent() const;\n\n\n\n    Point2f getDerivedPosition() const;\n\n\n    operator std::shared_ptr<Component>() { return shared_from_this(); }\n\n    void destroy();\n    bool isDestroyed() const;\n\n\n    void bringToFront();\n\nprivate:\n    bool _destroyed;\n    Rectangle2f _bounds;\n    bool _enabled;\n    bool _visible;\n    Container *_parent;\n};\n\n}\n}\n\n'egoboo/egolib/library/src/egolib/game/GUI/InputListener.hpp'\n:#pragma once\n\n#include \"egolib/integrations/events.hpp\"\n\nnamespace Ego {\nnamespace GUI {\n\n\nclass InputListener {\npublic:\n    virtual ~InputListener();\n\npublic:\n\n    virtual bool notifyMousePointerMoved(const Events::MousePointerMovedEvent& e);\n\npublic:\n\n    virtual bool notifyMouseWheelTurned(const Events::MouseWheelTurnedEvent& e);\n\npublic:\n\n    virtual bool notifyMouseButtonPressed(const Events::MouseButtonPressedEvent& e);\n\n\n    virtual bool notifyMouseButtonReleased(const Events::MouseButtonReleasedEvent& e);\n\n\n    virtual bool notifyMouseButtonClicked(const Events::MouseButtonClickedEvent& e);\n\npublic:\n\n    virtual bool notifyKeyboardKeyPressed(const Events::KeyboardKeyPressedEvent& e);\n\n\n    virtual bool notifyKeyboardKeyReleased(const Events::KeyboardKeyReleasedEvent& e);\n\n\n    virtual bool notifyKeyboardKeyTyped(const Events::KeyboardKeyTypedEvent& e);\n\n};\n\n}\n}\n",
        "gt": [
            "'egoboo/egolib/library/src/egolib/integrations/events.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/InputListener.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/Component.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/InventorySlot.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/InventorySlot.cpp'"
        ]
    },
    {
        "files": [
            "'nymea/libnymea-core/hardwaremanagerimplementation.cpp'",
            "'nymea/libnymea-core/hardware/modbus/modbusrtuhardwareresourceimplementation.h'",
            "'nymea/libnymea/hardware/modbus/modbusrtuhardwareresource.h'"
        ],
        "content": "'nymea/libnymea-core/hardwaremanagerimplementation.cpp'\n:\n\n#include \"loggingcategories.h\"\n\n#include \"platform/platform.h\"\n\n#include \"platform/platformzeroconfcontroller.h\"\n\n#include \"hardwaremanagerimplementation.h\"\n#include \"hardware/plugintimermanagerimplementation.h\"\n#include \"hardware/network/upnp/upnpdiscoveryimplementation.h\"\n#include \"hardware/network/networkaccessmanagerimpl.h\"\n#include \"hardware/radio433/radio433brennenstuhl.h\"\n#include \"hardware/bluetoothlowenergy/bluetoothlowenergymanagerimplementation.h\"\n#include \"hardware/network/mqtt/mqttproviderimplementation.h\"\n#include \"hardware/i2c/i2cmanagerimplementation.h\"\n#include \"hardware/zigbee/zigbeehardwareresourceimplementation.h\"\n#include \"hardware/zwave/zwavehardwareresourceimplementation.h\"\n\n#include \"hardware/modbus/modbusrtumanager.h\"\n#include \"hardware/modbus/modbusrtuhardwareresourceimplementation.h\"\n#include \"hardware/network/networkdevicediscoveryimpl.h\"\n\nnamespace nymeaserver {\n\nHardwareManagerImplementation::HardwareManagerImplementation(Platform *platform, MqttBroker *mqttBroker, ZigbeeManager *zigbeeManager, ZWaveManager *zwaveManager, ModbusRtuManager *modbusRtuManager, QObject *parent) :\n    HardwareManager(parent),\n    m_platform(platform)\n{\n\n\n    m_networkAccessManager = new QNetworkAccessManager(this);\n\n\n    m_pluginTimerManager = new PluginTimerManagerImplementation(this);\n\n\n    m_radio433 = new Radio433Brennenstuhl(this);\n\n\n    m_networkManager = new NetworkAccessManagerImpl(m_networkAccessManager, this);\n\n\n    m_upnpDiscovery = new UpnpDiscoveryImplementation(m_networkAccessManager, this);\n\n\n    m_bluetoothLowEnergyManager = new BluetoothLowEnergyManagerImplementation(m_pluginTimerManager->registerTimer(10), this);\n\n    m_i2cManager = new I2CManagerImplementation(this);\n\n    m_zigbeeResource = new ZigbeeHardwareResourceImplementation(zigbeeManager, this);\n\n    m_zwaveResource = new ZWaveHardwareResourceImplementation(zwaveManager, this);\n\n    m_modbusRtuResource = new ModbusRtuHardwareResourceImplementation(modbusRtuManager, this);\n\n    m_networkDeviceDiscovery = new NetworkDeviceDiscoveryImpl(this);\n\n\n    setResourceEnabled(m_pluginTimerManager, true);\n    setResourceEnabled(m_radio433, true);\n\n    if (m_networkManager->available())\n        setResourceEnabled(m_networkManager, true);\n\n    if (m_upnpDiscovery->available())\n        setResourceEnabled(m_upnpDiscovery, true);\n\n    if (m_platform->zeroConfController()->available())\n        setResourceEnabled(m_platform->zeroConfController(), true);\n\n    if (m_bluetoothLowEnergyManager->available())\n        setResourceEnabled(m_bluetoothLowEnergyManager, true);\n\n    m_mqttProvider = new MqttProviderImplementation(mqttBroker, this);\n    qCDebug(dcHardware()) << \"Hardware manager initialized successfully\";\n}\n\nHardwareManagerImplementation::~HardwareManagerImplementation()\n{\n\n}\n\nRadio433 *HardwareManagerImplementation::radio433()\n{\n    return m_radio433;\n}\n\nPluginTimerManager *HardwareManagerImplementation::pluginTimerManager()\n{\n    return m_pluginTimerManager;\n}\n\nNetworkAccessManager *HardwareManagerImplementation::networkManager()\n{\n    return m_networkManager;\n}\n\nUpnpDiscovery *HardwareManagerImplementation::upnpDiscovery()\n{\n    return m_upnpDiscovery;\n}\n\nPlatformZeroConfController *HardwareManagerImplementation::zeroConfController()\n{\n    return m_platform->zeroConfController();\n}\n\nBluetoothLowEnergyManager *HardwareManagerImplementation::bluetoothLowEnergyManager()\n{\n    return m_bluetoothLowEnergyManager;\n}\n\nMqttProvider *HardwareManagerImplementation::mqttProvider()\n{\n    return m_mqttProvider;\n}\n\nI2CManager *HardwareManagerImplementation::i2cManager()\n{\n    return m_i2cManager;\n}\n\nZigbeeHardwareResource *HardwareManagerImplementation::zigbeeResource()\n{\n    return m_zigbeeResource;\n}\n\nZWaveHardwareResource *HardwareManagerImplementation::zwaveResource()\n{\n    return m_zwaveResource;\n}\n\nModbusRtuHardwareResource *HardwareManagerImplementation::modbusRtuResource()\n{\n    return m_modbusRtuResource;\n}\n\nNetworkDeviceDiscovery *HardwareManagerImplementation::networkDeviceDiscovery()\n{\n    return m_networkDeviceDiscovery;\n}\n\nvoid HardwareManagerImplementation::thingsLoaded()\n{\n    m_zigbeeResource->thingsLoaded();\n    m_zwaveResource->thingsLoaded();\n}\n\n}\n\n'nymea/libnymea-core/hardware/modbus/modbusrtuhardwareresourceimplementation.h'\n:\n\n#ifndef MODBUSRTUHARDWARERESOURCEIMPLEMENTATION_H\n#define MODBUSRTUHARDWARERESOURCEIMPLEMENTATION_H\n\n#include <QObject>\n\n#include \"hardware/modbus/modbusrtumanager.h\"\n#include \"hardware/modbus/modbusrtumaster.h\"\n#include \"hardware/modbus/modbusrtuhardwareresource.h\"\n\nnamespace nymeaserver {\n\nclass ModbusRtuHardwareResourceImplementation : public ModbusRtuHardwareResource\n{\n    Q_OBJECT\npublic:\n    explicit ModbusRtuHardwareResourceImplementation(ModbusRtuManager *modbusRtuManager, QObject *parent = nullptr);\n    ~ModbusRtuHardwareResourceImplementation() override = default;\n\n    QList<ModbusRtuMaster *> modbusRtuMasters() const override;\n    bool hasModbusRtuMaster(const QUuid &modbusUuid) const override;\n    ModbusRtuMaster *getModbusRtuMaster(const QUuid &modbusUuid) const override;\n\n    bool available() const override;\n    bool enabled() const override;\n\npublic slots:\n    bool enable();\n    bool disable();\n\nprotected:\n    void setEnabled(bool enabled) override;\n\nprivate:\n    ModbusRtuManager *m_modbusRtuManager = nullptr;\n    bool m_available = false;\n    bool m_enabled = false;\n\n};\n\n}\n\n#endif\n\n'nymea/libnymea/hardware/modbus/modbusrtuhardwareresource.h'\n:\n\n#ifndef MODBUSRTUHARDWARERESOURCE_H\n#define MODBUSRTUHARDWARERESOURCE_H\n\n#include <QList>\n#include <QObject>\n\n#include \"hardwareresource.h\"\n#include \"modbusrtumaster.h\"\n\nclass ModbusRtuHardwareResource : public HardwareResource\n{\n    Q_OBJECT\npublic:\n    virtual QList<ModbusRtuMaster *> modbusRtuMasters() const = 0;\n    virtual bool hasModbusRtuMaster(const QUuid &modbusUuid) const = 0;\n    virtual ModbusRtuMaster *getModbusRtuMaster(const QUuid &modbusUuid) const = 0;\n\nprotected:\n    explicit ModbusRtuHardwareResource(QObject *parent = nullptr);\n    virtual ~ModbusRtuHardwareResource() = default;\n\nsignals:\n    void modbusRtuMasterAdded(const QUuid &modbusUuid);\n    void modbusRtuMasterRemoved(const QUuid &modbusUuid);\n    void modbusRtuMasterChanged(const QUuid &modbusUuid);\n\n};\n\n#endif\n",
        "gt": [
            "'nymea/libnymea/hardware/modbus/modbusrtuhardwareresource.h'",
            "'nymea/libnymea-core/hardware/modbus/modbusrtuhardwareresourceimplementation.h'",
            "'nymea/libnymea-core/hardwaremanagerimplementation.cpp'"
        ]
    },
    {
        "files": [
            "'jarkViewer/jarkViewer/include/opencv2/face/facerec.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/face.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/face/facemark.hpp'"
        ],
        "content": "'jarkViewer/jarkViewer/include/opencv2/face/facerec.hpp'\n:\n\n\n\n\n\n\n#ifndef __OPENCV_FACEREC_HPP__\n#define __OPENCV_FACEREC_HPP__\n\n#include \"opencv2/face.hpp\"\n#include \"opencv2/core.hpp\"\n\nnamespace cv { namespace face {\n\n\n\n\n\nclass CV_EXPORTS_W BasicFaceRecognizer : public FaceRecognizer\n{\npublic:\n\n    CV_WRAP int getNumComponents() const;\n\n    CV_WRAP void setNumComponents(int val);\n\n    CV_WRAP double getThreshold() const CV_OVERRIDE;\n\n    CV_WRAP void setThreshold(double val) CV_OVERRIDE;\n    CV_WRAP std::vector<cv::Mat> getProjections() const;\n    CV_WRAP cv::Mat getLabels() const;\n    CV_WRAP cv::Mat getEigenValues() const;\n    CV_WRAP cv::Mat getEigenVectors() const;\n    CV_WRAP cv::Mat getMean() const;\n\n    virtual void read(const FileNode& fn) CV_OVERRIDE;\n    virtual void write(FileStorage& fs) const CV_OVERRIDE;\n    virtual bool empty() const CV_OVERRIDE;\n\n    using FaceRecognizer::read;\n    using FaceRecognizer::write;\n\nprotected:\n    int _num_components;\n    double _threshold;\n    std::vector<Mat> _projections;\n    Mat _labels;\n    Mat _eigenvectors;\n    Mat _eigenvalues;\n    Mat _mean;\n};\n\nclass CV_EXPORTS_W EigenFaceRecognizer : public BasicFaceRecognizer\n{\npublic:\n\n    CV_WRAP static Ptr<EigenFaceRecognizer> create(int num_components = 0, double threshold = DBL_MAX);\n};\n\nclass CV_EXPORTS_W FisherFaceRecognizer : public BasicFaceRecognizer\n{\npublic:\n\n    CV_WRAP static Ptr<FisherFaceRecognizer> create(int num_components = 0, double threshold = DBL_MAX);\n};\n\n\nclass CV_EXPORTS_W LBPHFaceRecognizer : public FaceRecognizer\n{\npublic:\n\n    CV_WRAP virtual int getGridX() const = 0;\n\n    CV_WRAP virtual void setGridX(int val) = 0;\n\n    CV_WRAP virtual int getGridY() const = 0;\n\n    CV_WRAP virtual void setGridY(int val) = 0;\n\n    CV_WRAP virtual int getRadius() const = 0;\n\n    CV_WRAP virtual void setRadius(int val) = 0;\n\n    CV_WRAP virtual int getNeighbors() const = 0;\n\n    CV_WRAP virtual void setNeighbors(int val) = 0;\n\n    CV_WRAP virtual double getThreshold() const CV_OVERRIDE = 0;\n\n    CV_WRAP virtual void setThreshold(double val) CV_OVERRIDE = 0;\n    CV_WRAP virtual std::vector<cv::Mat> getHistograms() const = 0;\n    CV_WRAP virtual cv::Mat getLabels() const = 0;\n\n\n    CV_WRAP static Ptr<LBPHFaceRecognizer> create(int radius=1, int neighbors=8, int grid_x=8, int grid_y=8, double threshold = DBL_MAX);\n};\n\n\n\n}}\n\n#endif\n\n'jarkViewer/jarkViewer/include/opencv2/face.hpp'\n:\n\n#ifndef __OPENCV_FACE_HPP__\n#define __OPENCV_FACE_HPP__\n\n\n\n#include \"opencv2/core.hpp\"\n#include \"face/predict_collector.hpp\"\n#include <map>\n\nnamespace cv { namespace face {\n\n\n\n\n\nclass CV_EXPORTS_W FaceRecognizer : public Algorithm\n{\npublic:\n\n    CV_WRAP virtual void train(InputArrayOfArrays src, InputArray labels) = 0;\n\n\n    CV_WRAP virtual void update(InputArrayOfArrays src, InputArray labels);\n\n\n    CV_WRAP_AS(predict_label) int predict(InputArray src) const;\n\n\n\n    CV_WRAP void predict(InputArray src, CV_OUT int &label, CV_OUT double &confidence) const;\n\n\n\n    CV_WRAP_AS(predict_collect) virtual void predict(InputArray src, Ptr<PredictCollector> collector) const = 0;\n\n\n    CV_WRAP virtual void write(const String& filename) const;\n\n\n    CV_WRAP virtual void read(const String& filename);\n\n\n    virtual void write(FileStorage& fs) const CV_OVERRIDE = 0;\n\n\n    virtual void read(const FileNode& fn) CV_OVERRIDE = 0;\n\n\n    virtual bool empty() const CV_OVERRIDE = 0;\n\n\n    CV_WRAP virtual void setLabelInfo(int label, const String& strInfo);\n\n\n    CV_WRAP virtual String getLabelInfo(int label) const;\n\n\n    CV_WRAP virtual std::vector<int> getLabelsByString(const String& str) const;\n\n    virtual double getThreshold() const = 0;\n\n    virtual void setThreshold(double val) = 0;\nprotected:\n\n    std::map<int, String> _labelsInfo;\n};\n\n\n\n}}\n\n#include \"opencv2/face/facerec.hpp\"\n#include \"opencv2/face/facemark.hpp\"\n#include \"opencv2/face/facemark_train.hpp\"\n#include \"opencv2/face/facemarkLBF.hpp\"\n#include \"opencv2/face/facemarkAAM.hpp\"\n#include \"opencv2/face/face_alignment.hpp\"\n#include \"opencv2/face/mace.hpp\"\n\n#endif\n\n'jarkViewer/jarkViewer/include/opencv2/face/facemark.hpp'\n:\n\n\n\n\n\n#ifndef __OPENCV_FACELANDMARK_HPP__\n#define __OPENCV_FACELANDMARK_HPP__\n\n#include \"opencv2/core.hpp\"\n#include <vector>\n\n\nnamespace cv {\nnamespace face {\n\n\n\n\n\nclass CV_EXPORTS_W Facemark : public virtual Algorithm\n{\npublic:\n\n\n    CV_WRAP virtual void loadModel( String model ) = 0;\n\n\n\n    CV_WRAP virtual bool fit( InputArray image,\n                              InputArray faces,\n                              OutputArrayOfArrays landmarks) = 0;\n};\n\n\n\nCV_EXPORTS_W Ptr<Facemark> createFacemarkAAM();\n\n\nCV_EXPORTS_W Ptr<Facemark> createFacemarkLBF();\n\n\nCV_EXPORTS_W Ptr<Facemark> createFacemarkKazemi();\n\n\n\n}\n}\n\n#endif\n",
        "gt": [
            "'jarkViewer/jarkViewer/include/opencv2/face/facemark.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/face.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/face/facerec.hpp'"
        ]
    },
    {
        "files": [
            "'libadblockplus/src/DefaultPlatform.h'",
            "'libadblockplus/include/AdblockPlus/IExecutor.h'",
            "'libadblockplus/src/DefaultPlatform.cpp'"
        ],
        "content": "'libadblockplus/src/DefaultPlatform.h'\n:\n\n#pragma once\n\n#include <AdblockPlus/IExecutor.h>\n#include <AdblockPlus/PlatformFactory.h>\n\nnamespace AdblockPlus\n{\n  class DefaultPlatform : public Platform\n  {\n  public:\n    DefaultPlatform(PlatformFactory::CreationParameters&& creationParameters);\n    ~DefaultPlatform() override;\n\n    JsEngine& GetJsEngine();\n\n    void SetUp(const AppInfo& appInfo = AppInfo(),\n               std::unique_ptr<IV8IsolateProvider> isolate = nullptr) override;\n\n    void CreateFilterEngineAsync(\n        const FilterEngineFactory::CreationParameters& parameters =\n            FilterEngineFactory::CreationParameters(),\n        const OnFilterEngineCreatedCallback& onCreated = OnFilterEngineCreatedCallback()) override;\n\n    IFilterEngine& GetFilterEngine() override;\n    ITimer& GetTimer() const override;\n    IFileSystem& GetFileSystem() const override;\n    IWebRequest& GetWebRequest() const override;\n    LogSystem& GetLogSystem() const override;\n    IResourceReader& GetResourceReader() const override;\n\n  private:\n    std::unique_ptr<JsEngine> jsEngine;\n\n  protected:\n    LogSystemPtr logSystem;\n    TimerPtr timer;\n    FileSystemPtr fileSystem;\n    WebRequestPtr webRequest;\n    std::unique_ptr<IResourceReader> resourceReader;\n\n  private:\n    std::unique_ptr<IExecutor> executor;\n\n    std::mutex modulesMutex_;\n    std::shared_future<std::unique_ptr<IFilterEngine>> filterEngine_;\n    std::set<std::string> evaluatedJsSources_;\n    std::mutex evaluatedJsSourcesMutex_;\n\n    std::function<void(const std::string&)> GetEvaluateCallback();\n  };\n}\n\n'libadblockplus/include/AdblockPlus/IExecutor.h'\n:\n\n#pragma once\n\n#include <functional>\n\nnamespace AdblockPlus\n{\n  class IExecutor\n  {\n  public:\n    virtual ~IExecutor() = default;\n\n\n    virtual void Dispatch(const std::function<void()>& task) = 0;\n\n\n    virtual void Stop() = 0;\n  };\n}\n\n'libadblockplus/src/DefaultPlatform.cpp'\n:\n\n#include <cassert>\n\n#include \"DefaultPlatform.h\"\n#include \"JsEngine.h\"\n\nusing namespace AdblockPlus;\n\nextern std::string jsSources[];\n\nnamespace\n{\n  template<typename T>\n  void ValidatePlatformCreationParameter(const std::unique_ptr<T>& param, const char* paramName)\n  {\n    if (!param)\n      throw std::logic_error(paramName + std::string(\" must not be nullptr\"));\n  }\n}\n\nDefaultPlatform::DefaultPlatform(PlatformFactory::CreationParameters&& creationParameters)\n{\n#define ASSIGN_PLATFORM_PARAM(param)                                                               \\\n  ValidatePlatformCreationParameter(param = std::move(creationParameters.param), #param)\n\n  ASSIGN_PLATFORM_PARAM(logSystem);\n  ASSIGN_PLATFORM_PARAM(timer);\n  ASSIGN_PLATFORM_PARAM(fileSystem);\n  ASSIGN_PLATFORM_PARAM(webRequest);\n  ASSIGN_PLATFORM_PARAM(resourceReader);\n  ASSIGN_PLATFORM_PARAM(executor);\n\n#undef ASSIGN_PLATFORM_PARAM\n}\n\nDefaultPlatform::~DefaultPlatform()\n{\n  executor->Stop();\n}\n\nJsEngine& DefaultPlatform::GetJsEngine()\n{\n  SetUp();\n  return *jsEngine;\n}\n\nvoid DefaultPlatform::SetUp(const AppInfo& appInfo, std::unique_ptr<IV8IsolateProvider> isolate)\n{\n  std::lock_guard<std::mutex> lock(modulesMutex_);\n  if (jsEngine)\n    return;\n  JsEngine::Interfaces interfaces{*timer, *fileSystem, *webRequest, *logSystem, *resourceReader};\n  jsEngine = JsEngine::New(appInfo, interfaces, std::move(isolate));\n}\n\nvoid DefaultPlatform::CreateFilterEngineAsync(\n    const FilterEngineFactory::CreationParameters& parameters,\n    const Platform::OnFilterEngineCreatedCallback& onCreated)\n{\n  std::shared_ptr<std::promise<std::unique_ptr<IFilterEngine>>> filterEnginePromise;\n  {\n    std::lock_guard<std::mutex> lock(modulesMutex_);\n    if (filterEngine_.valid())\n      return;\n    filterEnginePromise = std::make_shared<std::promise<std::unique_ptr<IFilterEngine>>>();\n    filterEngine_ = filterEnginePromise->get_future();\n  }\n\n  GetJsEngine();\n  FilterEngineFactory::CreateAsync(\n      *jsEngine,\n      GetEvaluateCallback(),\n      [onCreated, filterEnginePromise](std::unique_ptr<IFilterEngine> filterEngine) {\n        const auto& filterEngineRef = *filterEngine;\n        filterEnginePromise->set_value(std::move(filterEngine));\n        if (onCreated)\n          onCreated(filterEngineRef);\n      },\n      parameters);\n}\n\nIFilterEngine& DefaultPlatform::GetFilterEngine()\n{\n  CreateFilterEngineAsync();\n  return *filterEngine_.get().get();\n}\n\nITimer& DefaultPlatform::GetTimer() const\n{\n  return *timer;\n}\n\nIFileSystem& DefaultPlatform::GetFileSystem() const\n{\n  return *fileSystem;\n}\n\nIWebRequest& DefaultPlatform::GetWebRequest() const\n{\n  return *webRequest;\n}\n\nLogSystem& DefaultPlatform::GetLogSystem() const\n{\n  return *logSystem;\n}\n\nIResourceReader& DefaultPlatform::GetResourceReader() const\n{\n  return *resourceReader;\n}\n\nstd::function<void(const std::string&)> DefaultPlatform::GetEvaluateCallback()\n{\n\n  return [this](const std::string& filename) {\n    std::lock_guard<std::mutex> lock(evaluatedJsSourcesMutex_);\n    if (evaluatedJsSources_.find(filename) != evaluatedJsSources_.end())\n      return;\n\n    for (int i = 0; !jsSources[i].empty(); i += 2)\n      if (jsSources[i] == filename)\n      {\n        jsEngine->Evaluate(jsSources[i + 1], jsSources[i]);\n        evaluatedJsSources_.insert(filename);\n        return;\n      }\n\n    assert(false && \"Invalid argument: unknown JavaScript file\");\n  };\n}\n",
        "gt": [
            "'libadblockplus/include/AdblockPlus/IExecutor.h'",
            "'libadblockplus/src/DefaultPlatform.h'",
            "'libadblockplus/src/DefaultPlatform.cpp'"
        ]
    },
    {
        "files": [
            "'query-pdb/client-drv/client-drv/khttp.cpp'",
            "'query-pdb/client-drv/client-drv/berkeley.h'",
            "'query-pdb/client-drv/client-drv/khttp.h'"
        ],
        "content": "'query-pdb/client-drv/client-drv/khttp.cpp'\n:#include <memory>\n#include \"khttp.h\"\n\nclass socket_guard {\npublic:\n    explicit socket_guard(int fd) : fd_(fd) {}\n\n    int get() const {\n        return fd_;\n    }\n\n    ~socket_guard() {\n        if (fd_ != -1) {\n            closesocket(fd_);\n        }\n    }\n\nprivate:\n    int fd_;\n};\n\nstruct addrinfo_deleter {\n    void operator()(addrinfo *p) {\n        freeaddrinfo(p);\n    }\n};\n\nusing addrinfo_guard = std::unique_ptr<addrinfo, addrinfo_deleter>;\n\nkhttp::ks_initializer khttp::ksinit_;\n\nkhttp::khttp(const std::string &server)\n        : url_parser_(server),\n          header_config_({\"Windows WSK Client\"}) {\n\n    if (!ksinit_.valid()) {\n        KdPrint((\"Failed to initialize ksocket\\n\"));\n    }\n\n    if (!url_parser_.isValid()) {\n        KdPrint((\"Failed to parse url: %s\\n\", server.c_str()));\n    } else {\n        KdPrint((\"host: %s, port: %s\\n\",\n                url_parser_.hostname().c_str(),\n                url_parser_.port().c_str()));\n    }\n}\n\nhttpparser::Response khttp::get(const std::string &path) {\n    return http_impl(\"GET\", path, \"\");\n}\n\nhttpparser::Response khttp::post(const std::string &path, const std::string &content) {\n    return http_impl(\"POST\", path, content);\n}\n\nhttpparser::Response khttp::put(const std::string &path, const std::string &content) {\n    return http_impl(\"PUT\", path, content);\n}\n\nhttpparser::Response khttp::del(const std::string &path) {\n    return http_impl(\"DELETE\", path, \"\");\n}\n\nstd::string khttp::build_request(\n        const std::string &method,\n        const std::string &path,\n        const std::string &content\n) {\n    std::string s;\n    s += method + \" \" + path + \" HTTP/1.1\\r\\n\";\n    s += \"Host: \" + url_parser_.hostname() + \"\\r\\n\";\n    s += \"User-Agent: \" + header_config_.user_agent + \"\\r\\n\";\n    s += \"Accept: */*\\r\\n\";\n    s += \"Connection: close\\r\\n\";\n    s += \"Content-Length: \" + std::to_string(content.length()) + \"\\r\\n\";\n    s += \"\\r\\n\";\n    s += content;\n    return s;\n}\n\nhttpparser::Response khttp::http_impl(\n        const std::string &method,\n        const std::string &path,\n        const std::string &content\n) {\n\n    if (!ksinit_.valid() ||\n        !url_parser_.isValid() ||\n        url_parser_.scheme() != \"http\" ||\n        url_parser_.hostname().empty() ||\n        method.empty() ||\n        path.empty()) {\n        return {};\n    }\n\n    struct addrinfo hints = {};\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n\n    std::string port = url_parser_.port().empty() ? \"80\" : url_parser_.port();\n\n    addrinfo *addr_raw = nullptr;\n    addrinfo_guard addr;\n    if (getaddrinfo(\n            url_parser_.hostname().c_str(),\n            port.c_str(),\n            &hints,\n            &addr_raw\n    ) < 0) {\n        addr.reset(addr_raw);\n        KdPrint((\"Failed to get address info: %s\\n\", url_parser_.hostname().c_str()));\n        return {};\n    }\n    addr.reset(addr_raw);\n    KdPrint((\"Got address info: %s\\n\", url_parser_.hostname().c_str()));\n\n    socket_guard sockfd(socket(AF_INET, SOCK_STREAM, IPPROTO_TCP));\n    if (sockfd.get() < 0) {\n        KdPrint((\"Failed to create socket\\n\"));\n        return {};\n    }\n    KdPrint((\"Created socket: %d\\n\", sockfd.get()));\n\n    if (connect(sockfd.get(), addr->ai_addr, addr->ai_addrlen) < 0) {\n        KdPrint((\"Failed to connect to server: %s\\n\", url_parser_.hostname().c_str()));\n        return {};\n    }\n    KdPrint((\"Connected to server: %s\\n\", url_parser_.hostname().c_str()));\n\n    std::string request = build_request(method, path, content);\n    KdPrint((\"Request: \\n%s\\n\", request.c_str()));\n\n    while (true) {\n        int sent = send(sockfd.get(), request.c_str(), request.length(), 0);\n        if (sent < 0) {\n            KdPrint((\"Failed to send request\\n\"));\n            return {};\n        }\n        if (static_cast<size_t>(sent) == request.length()) {\n            break;\n        }\n        request = request.substr(sent);\n    }\n    KdPrint((\"Sent request\\n\"));\n\n    httpparser::HttpResponseParser parser;\n    httpparser::HttpResponseParser::ParseResult parse_result =\n        httpparser::HttpResponseParser::ParsingError;\n    httpparser::Response response;\n\n    while (true) {\n        char buf[512];\n        int received = recv(sockfd.get(), buf, sizeof(buf), 0);\n        if (received < 0) {\n            KdPrint((\"Failed to receive response\\n\"));\n            return {};\n        }\n        if (received == 0) {\n            break;\n        }\n        parse_result = parser.parse(response, buf, buf + received);\n    }\n    KdPrint((\"Received response\\n\"));\n\n    if (parse_result != httpparser::HttpResponseParser::ParsingCompleted) {\n        KdPrint((\"Failed to parse response\\n\"));\n        return {};\n    }\n    KdPrint((\"Parsed response\\n\"));\n\n    return response;\n}\n\n'query-pdb/client-drv/client-drv/berkeley.h'\n:#pragma once\n#include <ntddk.h>\n#include <wsk.h>\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef int       socklen_t;\ntypedef intptr_t  ssize_t;\n\nuint32_t htonl(uint32_t hostlong);\nuint16_t htons(uint16_t hostshort);\nuint32_t ntohl(uint32_t netlong);\nuint16_t ntohs(uint16_t netshort);\n\nint getaddrinfo(const char* node, const char* service, const struct addrinfo* hints, struct addrinfo** res);\nvoid freeaddrinfo(struct addrinfo *res);\n\nint socket_connection(int domain, int type, int protocol);\nint socket_listen(int domain, int type, int protocol);\nint socket_datagram(int domain, int type, int protocol);\nint connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);\nint listen(int sockfd, int backlog);\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\nint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\nint send(int sockfd, const void* buf, size_t len, int flags);\nint sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);\nint recv(int sockfd, void* buf, size_t len, int flags);\nint recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\nint closesocket(int sockfd);\n\n#define socket  socket_connection\n\n#ifdef __cplusplus\n}\n#endif\n\n'query-pdb/client-drv/client-drv/khttp.h'\n:#ifndef QPDB_DRIVER_KHTTP_H\n#define QPDB_DRIVER_KHTTP_H\n\n#include <string>\n#include <memory>\n#include \"berkeley.h\"\n#include \"ksocket.h\"\n#include \"urlparser.h\"\n#include \"httpresponseparser.h\"\n\nclass khttp {\npublic:\n    explicit khttp(const std::string &server);\n\n    httpparser::Response get(const std::string &path);\n\n    httpparser::Response post(const std::string &path, const std::string &content);\n\n    httpparser::Response put(const std::string &path, const std::string &content);\n\n    httpparser::Response del(const std::string &path);\n\nprivate:\n    class ks_initializer {\n    public:\n        ks_initializer() : valid_(NT_SUCCESS(KsInitialize())) {}\n\n        ~ks_initializer() { if (valid_) KsDestroy(); }\n\n        bool valid() const { return valid_; }\n\n    private:\n        bool valid_;\n    };\n\n    struct header_config {\n        std::string user_agent;\n    };\n\n    static ks_initializer ksinit_;\n    httpparser::UrlParser url_parser_;\n    header_config header_config_;\n\n    std::string build_request(\n            const std::string &method,\n            const std::string &path,\n            const std::string &content\n    );\n\n    httpparser::Response http_impl(\n            const std::string &method,\n            const std::string &path,\n            const std::string &content\n    );\n\n};\n\n#endif\n",
        "gt": [
            "'query-pdb/client-drv/client-drv/berkeley.h'",
            "'query-pdb/client-drv/client-drv/khttp.h'",
            "'query-pdb/client-drv/client-drv/khttp.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackServer/Application/ApplicationIf.h'",
            "'OpcUaStack/src/OpcUaStackServer/Application/ApplicationServiceIf.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSetApplication/GetNamespaceInfo.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSetApplication/GetNamespaceInfo.cpp'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackServer/Application/ApplicationIf.h'\n:\n\n#ifndef __OpcUaStackServer_ApplicationIf_h__\n#define __OpcUaStackServer_ApplicationIf_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/Config.h\"\n#include \"OpcUaStackCore/Certificate/ApplicationCertificate.h\"\n#include \"OpcUaStackCore/Certificate/CryptoManager.h\"\n#include \"OpcUaStackServer/Application/ApplicationServiceIf.h\"\n#include \"OpcUaStackServer/Application/ApplicationInfo.h\"\n\nnamespace OpcUaStackServer\n{\n\n\tclass DLLEXPORT ApplicationData\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<ApplicationData> SPtr;\n\n\t\tApplicationData(void);\n\t\t~ApplicationData(void);\n\n\t\tvoid applicationServiceIf(ApplicationServiceIf* applicationServiceIf);\n\t\tApplicationServiceIf& applicationServiceIf(void);\n\t\tvoid config(Config* config);\n\t\tConfig* config(void);\n\t\tvoid applicationInfo(ApplicationInfo* applicationInfo);\n\t\tApplicationInfo* applicationInfo(void);\n\t\tvoid applicationCertificate(const ApplicationCertificate::SPtr& applicationCertificate);\n\t\tApplicationCertificate::SPtr& applicationCertificate(void);\n\t\tvoid cryptoManager(const CryptoManager::SPtr& cryptoManager);\n\t\tCryptoManager::SPtr& cryptoManager(void);\n\n\t  private:\n\t\tApplicationServiceIf* applicationServiceIf_;\n\t\tConfig* config_;\n\t\tApplicationInfo* applicationInfo_;\n\t\tApplicationCertificate::SPtr applicationCertificate_;\n\t\tCryptoManager::SPtr cryptoManager_;\n\t};\n\n\n\tclass DLLEXPORT ApplicationIf\n\t{\n\t  public:\n\t\tApplicationIf(void);\n\t\tvirtual ~ApplicationIf(void);\n\n\t\tvirtual bool startup(void) = 0;\n\t\tvirtual bool shutdown(void) = 0;\n\t\tvirtual void receive(ServiceTransaction::SPtr serviceTransaction);\n\t\tvirtual std::string version(void);\n\n\t\tvoid service(ApplicationServiceIf* applicationServiceIf);\n\t\tApplicationServiceIf& service(void);\n\t\tvoid config(Config* config);\n\t\tConfig* config(void);\n\t\tvoid applicationInfo(ApplicationInfo* applicationInfo);\n\t\tApplicationInfo* applicationInfo(void);\n\t\tvoid applicationCertificate(ApplicationCertificate::SPtr& applicationCertificate);\n\t\tApplicationCertificate::SPtr& applicationCertificate(void);\n\t\tvoid cryptoManager(CryptoManager::SPtr cryptoManager);\n\t\tCryptoManager::SPtr& cryptoManager(void);\n\t\tvoid applicationData(ApplicationData::SPtr& applicationData);\n\t\tApplicationData::SPtr& applicationData(void);\n\n\t  private:\n\t\tApplicationData::SPtr applicationData_;\n\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackServer/Application/ApplicationServiceIf.h'\n:\n\n#ifndef __OpcUaStackServer_ApplicationServiceIf_h__\n#define __OpcUaStackServer_ApplicationServiceIf_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/Callback.h\"\n#include \"OpcUaStackCore/ServiceSet/ServiceTransaction.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackServer\n{\n\n\tclass DLLEXPORT ApplicationServiceIf\n\t{\n\t  public:\n\t\tApplicationServiceIf(void) {}\n\t\tvirtual ~ApplicationServiceIf(void) {}\n\n\t\tvirtual void send(ServiceTransaction::SPtr serviceTransaction) = 0;\n\t\tvirtual void sendSync(ServiceTransaction::SPtr serviceTransaction) = 0;\n\t\tvirtual void reload(void) {}\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackServer/ServiceSetApplication/GetNamespaceInfo.h'\n:\n\n#ifndef __OpcUaStackServer_GetNamespaceInfo_h__\n#define __OpcUaStackServer_GetNamespaceInfo_h__\n\n#include <vector>\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackServer/Application/ApplicationIf.h\"\n#include \"OpcUaStackCore/ServiceSetApplication/ApplicationServiceTransaction.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackServer\n{\n\n\tclass DLLEXPORT GetNamespaceInfo\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<GetNamespaceInfo> SPtr;\n\n\t\tGetNamespaceInfo(void);\n\t\tvirtual ~GetNamespaceInfo(void);\n\n\t\tbool query(ApplicationServiceIf* applicationServiceIf);\n\t\tOpcUaStatusCode resultCode(void);\n\n\t\tint32_t getNamespaceIndex(const std::string& namespaceUri);\n\n\t  private:\n\t\tOpcUaStatusCode resultCode_;\n\t\tNamespaceInfoResponse::Index2NamespaceMap index2NamespaceMap_;\n\t\tNamespaceInfoResponse::Namespace2IndexMap namespace2IndexMap_;\n\t};\n\n}\n#endif\n\n'OpcUaStack/src/OpcUaStackServer/ServiceSetApplication/GetNamespaceInfo.cpp'\n:\n\n#include \"OpcUaStackServer/ServiceSetApplication/GetNamespaceInfo.h\"\n\nnamespace OpcUaStackServer\n{\n\n\tGetNamespaceInfo::GetNamespaceInfo(void)\n\t: resultCode_(Success)\n\t, index2NamespaceMap_()\n\t, namespace2IndexMap_()\n\t{\n\t}\n\n\tGetNamespaceInfo::~GetNamespaceInfo(void)\n\t{\n\t}\n\n\tbool\n\tGetNamespaceInfo::query(ApplicationServiceIf* applicationServiceIf)\n\t{\n\n\t\tauto trx = constructSPtr<ServiceTransactionNamespaceInfo>();\n\n\n\t\tapplicationServiceIf->sendSync(trx);\n\t\tresultCode_ = trx->statusCode();\n\t  \tif (resultCode_ != Success) return false;\n\n\n\t\tindex2NamespaceMap_ = trx->response()->index2NamespaceMap();\n\t\tnamespace2IndexMap_= trx->response()->namespace2IndexMap();\n\n\t\treturn true;\n\t}\n\n\tOpcUaStatusCode\n\tGetNamespaceInfo::resultCode(void)\n\t{\n\t\treturn resultCode_;\n\t}\n\n\tint32_t\n\tGetNamespaceInfo::getNamespaceIndex(const std::string& namespaceUri)\n\t{\n\t\tauto it = namespace2IndexMap_.find(namespaceUri);\n\t\tif (it == namespace2IndexMap_.end()) return -1;\n\t\treturn (int32_t)it->second;\n\t}\n\n}\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackServer/Application/ApplicationServiceIf.h'",
            "'OpcUaStack/src/OpcUaStackServer/Application/ApplicationIf.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSetApplication/GetNamespaceInfo.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSetApplication/GetNamespaceInfo.cpp'"
        ]
    },
    {
        "files": [
            "'elaphureLink/thirdparty/asio/include/asio/detail/resolver_service_base.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/resolve_op.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/resolver_service.hpp'"
        ],
        "content": "'elaphureLink/thirdparty/asio/include/asio/detail/resolver_service_base.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_DETAIL_RESOLVER_SERVICE_BASE_HPP\n#define ASIO_DETAIL_RESOLVER_SERVICE_BASE_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include \"asio/error.hpp\"\n#include \"asio/execution_context.hpp\"\n#include \"asio/detail/mutex.hpp\"\n#include \"asio/detail/noncopyable.hpp\"\n#include \"asio/detail/resolve_op.hpp\"\n#include \"asio/detail/socket_ops.hpp\"\n#include \"asio/detail/socket_types.hpp\"\n#include \"asio/detail/scoped_ptr.hpp\"\n#include \"asio/detail/thread.hpp\"\n\n#if defined(ASIO_HAS_IOCP)\n# include \"asio/detail/win_iocp_io_context.hpp\"\n#else\n# include \"asio/detail/scheduler.hpp\"\n#endif\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace detail {\n\nclass resolver_service_base\n{\npublic:\n\n\n  typedef socket_ops::shared_cancel_token_type implementation_type;\n\n\n  ASIO_DECL resolver_service_base(execution_context& context);\n\n\n  ASIO_DECL ~resolver_service_base();\n\n\n  ASIO_DECL void base_shutdown();\n\n\n  ASIO_DECL void base_notify_fork(\n      execution_context::fork_event fork_ev);\n\n\n  ASIO_DECL void construct(implementation_type& impl);\n\n\n  ASIO_DECL void destroy(implementation_type&);\n\n\n  ASIO_DECL void move_construct(implementation_type& impl,\n      implementation_type& other_impl);\n\n\n  ASIO_DECL void move_assign(implementation_type& impl,\n      resolver_service_base& other_service,\n      implementation_type& other_impl);\n\n\n  void converting_move_construct(implementation_type& impl,\n      resolver_service_base&, implementation_type& other_impl)\n  {\n    move_construct(impl, other_impl);\n  }\n\n\n  void converting_move_assign(implementation_type& impl,\n      resolver_service_base& other_service,\n      implementation_type& other_impl)\n  {\n    move_assign(impl, other_service, other_impl);\n  }\n\n\n  ASIO_DECL void cancel(implementation_type& impl);\n\nprotected:\n\n  ASIO_DECL void start_resolve_op(resolve_op* op);\n\n#if !defined(ASIO_WINDOWS_RUNTIME)\n\n  class auto_addrinfo\n    : private asio::detail::noncopyable\n  {\n  public:\n    explicit auto_addrinfo(asio::detail::addrinfo_type* ai)\n      : ai_(ai)\n    {\n    }\n\n    ~auto_addrinfo()\n    {\n      if (ai_)\n        socket_ops::freeaddrinfo(ai_);\n    }\n\n    operator asio::detail::addrinfo_type*()\n    {\n      return ai_;\n    }\n\n  private:\n    asio::detail::addrinfo_type* ai_;\n  };\n#endif\n\n\n  class work_scheduler_runner;\n\n\n  ASIO_DECL void start_work_thread();\n\n\n#if defined(ASIO_HAS_IOCP)\n  typedef class win_iocp_io_context scheduler_impl;\n#else\n  typedef class scheduler scheduler_impl;\n#endif\n  scheduler_impl& scheduler_;\n\nprivate:\n\n  asio::detail::mutex mutex_;\n\n\n  asio::detail::scoped_ptr<scheduler_impl> work_scheduler_;\n\n\n  asio::detail::scoped_ptr<asio::detail::thread> work_thread_;\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#if defined(ASIO_HEADER_ONLY)\n# include \"asio/detail/impl/resolver_service_base.ipp\"\n#endif\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/detail/resolve_op.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_DETAIL_RESOLVE_OP_HPP\n#define ASIO_DETAIL_RESOLVE_OP_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include \"asio/error.hpp\"\n#include \"asio/detail/operation.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace detail {\n\nclass resolve_op : public operation\n{\npublic:\n\n  asio::error_code ec_;\n\nprotected:\n  resolve_op(func_type complete_func)\n    : operation(complete_func)\n  {\n  }\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/detail/resolver_service.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_DETAIL_RESOLVER_SERVICE_HPP\n#define ASIO_DETAIL_RESOLVER_SERVICE_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n\n#if !defined(ASIO_WINDOWS_RUNTIME)\n\n#include \"asio/ip/basic_resolver_query.hpp\"\n#include \"asio/ip/basic_resolver_results.hpp\"\n#include \"asio/detail/concurrency_hint.hpp\"\n#include \"asio/detail/memory.hpp\"\n#include \"asio/detail/resolve_endpoint_op.hpp\"\n#include \"asio/detail/resolve_query_op.hpp\"\n#include \"asio/detail/resolver_service_base.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace detail {\n\ntemplate <typename Protocol>\nclass resolver_service :\n  public execution_context_service_base<resolver_service<Protocol> >,\n  public resolver_service_base\n{\npublic:\n\n\n  typedef socket_ops::shared_cancel_token_type implementation_type;\n\n\n  typedef typename Protocol::endpoint endpoint_type;\n\n\n  typedef asio::ip::basic_resolver_query<Protocol> query_type;\n\n\n  typedef asio::ip::basic_resolver_results<Protocol> results_type;\n\n\n  resolver_service(execution_context& context)\n    : execution_context_service_base<resolver_service<Protocol> >(context),\n      resolver_service_base(context)\n  {\n  }\n\n\n  void shutdown()\n  {\n    this->base_shutdown();\n  }\n\n\n  void notify_fork(execution_context::fork_event fork_ev)\n  {\n    this->base_notify_fork(fork_ev);\n  }\n\n\n  results_type resolve(implementation_type&, const query_type& qry,\n      asio::error_code& ec)\n  {\n    asio::detail::addrinfo_type* address_info = 0;\n\n    socket_ops::getaddrinfo(qry.host_name().c_str(),\n        qry.service_name().c_str(), qry.hints(), &address_info, ec);\n    auto_addrinfo auto_address_info(address_info);\n\n    return ec ? results_type() : results_type::create(\n        address_info, qry.host_name(), qry.service_name());\n  }\n\n\n  template <typename Handler, typename IoExecutor>\n  void async_resolve(implementation_type& impl, const query_type& qry,\n      Handler& handler, const IoExecutor& io_ex)\n  {\n\n    typedef resolve_query_op<Protocol, Handler, IoExecutor> op;\n    typename op::ptr p = { asio::detail::addressof(handler),\n      op::ptr::allocate(handler), 0 };\n    p.p = new (p.v) op(impl, qry, scheduler_, handler, io_ex);\n\n    ASIO_HANDLER_CREATION((scheduler_.context(),\n          *p.p, \"resolver\", &impl, 0, \"async_resolve\"));\n\n    start_resolve_op(p.p);\n    p.v = p.p = 0;\n  }\n\n\n  results_type resolve(implementation_type&,\n      const endpoint_type& endpoint, asio::error_code& ec)\n  {\n    char host_name[NI_MAXHOST];\n    char service_name[NI_MAXSERV];\n    socket_ops::sync_getnameinfo(endpoint.data(), endpoint.size(),\n        host_name, NI_MAXHOST, service_name, NI_MAXSERV,\n        endpoint.protocol().type(), ec);\n\n    return ec ? results_type() : results_type::create(\n        endpoint, host_name, service_name);\n  }\n\n\n  template <typename Handler, typename IoExecutor>\n  void async_resolve(implementation_type& impl, const endpoint_type& endpoint,\n      Handler& handler, const IoExecutor& io_ex)\n  {\n\n    typedef resolve_endpoint_op<Protocol, Handler, IoExecutor> op;\n    typename op::ptr p = { asio::detail::addressof(handler),\n      op::ptr::allocate(handler), 0 };\n    p.p = new (p.v) op(impl, endpoint, scheduler_, handler, io_ex);\n\n    ASIO_HANDLER_CREATION((scheduler_.context(),\n          *p.p, \"resolver\", &impl, 0, \"async_resolve\"));\n\n    start_resolve_op(p.p);\n    p.v = p.p = 0;\n  }\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n\n#endif\n",
        "gt": [
            "'elaphureLink/thirdparty/asio/include/asio/detail/resolve_op.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/resolver_service_base.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/resolver_service.hpp'"
        ]
    },
    {
        "files": [
            "'zephyr/tests/core_tests/chaingen001.cpp'",
            "'zephyr/tests/core_tests/chain_switch_1.h'",
            "'zephyr/tests/core_tests/chaingen_tests_list.h'"
        ],
        "content": "'zephyr/tests/core_tests/chaingen001.cpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <vector>\n#include <iostream>\n\n#include \"include_base_utils.h\"\n\n#include \"console_handler.h\"\n\n#include \"cryptonote_basic/cryptonote_basic.h\"\n#include \"cryptonote_basic/cryptonote_format_utils.h\"\n\n#include \"chaingen.h\"\n#include \"chaingen_tests_list.h\"\n\nusing namespace std;\n\nusing namespace epee;\nusing namespace cryptonote;\n\n\n\n\none_block::one_block()\n{\n  REGISTER_CALLBACK(\"verify_1\", one_block::verify_1);\n}\n\nbool one_block::generate(std::vector<test_event_entry> &events)\n{\n    uint64_t ts_start = 1338224400;\n\n    MAKE_GENESIS_BLOCK(events, blk_0, alice, ts_start);\n    MAKE_ACCOUNT(events, alice);\n    DO_CALLBACK(events, \"verify_1\");\n\n    return true;\n}\n\nbool one_block::verify_1(cryptonote::core& c, size_t ev_index, const std::vector<test_event_entry> &events)\n{\n    DEFINE_TESTS_ERROR_CONTEXT(\"one_block::verify_1\");\n\n    alice = boost::get<cryptonote::account_base>(events[1]);\n\n\n\n\n\n\n\n\n    std::vector<cryptonote::block> blocks;\n    std::list<crypto::public_key> outs;\n    bool r = c.get_blocks(0, 100, blocks);\n\n    CHECK_TEST_CONDITION(r);\n    CHECK_TEST_CONDITION(blocks.size() == 1);\n\n    CHECK_TEST_CONDITION(c.get_blockchain_total_transactions() == 1);\n    CHECK_TEST_CONDITION(blocks.back() == boost::get<cryptonote::block>(events[0]));\n\n    return true;\n}\n\n\n\n\n\ngen_simple_chain_001::gen_simple_chain_001()\n{\n  REGISTER_CALLBACK(\"verify_callback_1\", gen_simple_chain_001::verify_callback_1);\n  REGISTER_CALLBACK(\"verify_callback_2\", gen_simple_chain_001::verify_callback_2);\n}\n\nbool gen_simple_chain_001::generate(std::vector<test_event_entry> &events)\n{\n    uint64_t ts_start = 1338224400;\n\n    GENERATE_ACCOUNT(miner);\n    GENERATE_ACCOUNT(alice);\n\n    MAKE_GENESIS_BLOCK(events, blk_0, miner, ts_start);\n    MAKE_NEXT_BLOCK(events, blk_1, blk_0, miner);\n    MAKE_NEXT_BLOCK(events, blk_1_side, blk_0, miner);\n    MAKE_NEXT_BLOCK(events, blk_2, blk_1, miner);\n\n\n    std::vector<cryptonote::block> chain;\n    map_hash2tx_t mtx;\n    find_block_chain(events, chain, mtx, get_block_hash(boost::get<cryptonote::block>(events[3])));\n    std::cout << \"BALANCE = \" << get_balance(miner, chain, mtx) << std::endl;\n\n    REWIND_BLOCKS(events, blk_2r, blk_2, miner);\n    MAKE_TX_LIST_START(events, txlist_0, miner, alice, MK_COINS(1), blk_2r);\n    MAKE_TX_LIST(events, txlist_0, miner, alice, MK_COINS(2), blk_2r);\n    MAKE_TX_LIST(events, txlist_0, miner, alice, MK_COINS(4), blk_2r);\n    MAKE_NEXT_BLOCK_TX_LIST(events, blk_3, blk_2r, miner, txlist_0);\n    REWIND_BLOCKS(events, blk_3r, blk_3, miner);\n    MAKE_TX(events, tx_1, miner, alice, MK_COINS(50), blk_3r);\n    MAKE_NEXT_BLOCK_TX1(events, blk_4, blk_3r, miner, tx_1);\n    REWIND_BLOCKS(events, blk_4r, blk_4, miner);\n    MAKE_TX(events, tx_2, miner, alice, MK_COINS(50), blk_4r);\n    MAKE_NEXT_BLOCK_TX1(events, blk_5, blk_4r, miner, tx_2);\n    REWIND_BLOCKS(events, blk_5r, blk_5, miner);\n    MAKE_TX(events, tx_3, miner, alice, MK_COINS(50), blk_5r);\n    MAKE_NEXT_BLOCK_TX1(events, blk_6, blk_5r, miner, tx_3);\n\n    DO_CALLBACK(events, \"verify_callback_1\");\n\n\n\n\n\n\n\n    return true;\n}\n\nbool gen_simple_chain_001::verify_callback_1(cryptonote::core& c, size_t ev_index, const std::vector<test_event_entry> &events)\n{\n  return true;\n}\n\nbool gen_simple_chain_001::verify_callback_2(cryptonote::core& c, size_t ev_index, const std::vector<test_event_entry> &events)\n{\n  return true;\n}\n\n'zephyr/tests/core_tests/chain_switch_1.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n#include \"chaingen.h\"\n\n\n\n\nclass gen_chain_switch_1 : public test_chain_unit_base\n{\npublic:\n  gen_chain_switch_1();\n\n  bool generate(std::vector<test_event_entry>& events) const;\n\n  bool check_split_not_switched(cryptonote::core& c, size_t ev_index, const std::vector<test_event_entry>& events);\n  bool check_split_switched(cryptonote::core& c, size_t ev_index, const std::vector<test_event_entry>& events);\n\nprivate:\n  std::vector<cryptonote::block> m_chain_1;\n\n  cryptonote::account_base m_recipient_account_1;\n  cryptonote::account_base m_recipient_account_2;\n  cryptonote::account_base m_recipient_account_3;\n  cryptonote::account_base m_recipient_account_4;\n\n  std::vector<cryptonote::transaction> m_tx_pool;\n};\n\n'zephyr/tests/core_tests/chaingen_tests_list.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n#include \"chaingen.h\"\n#include \"block_reward.h\"\n#include \"block_validation.h\"\n#include \"chain_split_1.h\"\n#include \"chain_switch_1.h\"\n#include \"double_spend.h\"\n#include \"integer_overflow.h\"\n#include \"ring_signature_1.h\"\n#include \"tx_validation.h\"\n#include \"v2_tests.h\"\n#include \"rct.h\"\n#include \"multisig.h\"\n#include \"bulletproofs.h\"\n#include \"bulletproof_plus.h\"\n#include \"rct2.h\"\n\n\n\nclass gen_simple_chain_001: public test_chain_unit_base\n{\npublic:\n  gen_simple_chain_001();\n  bool generate(std::vector<test_event_entry> &events);\n  bool verify_callback_1(cryptonote::core& c, size_t ev_index, const std::vector<test_event_entry> &events);\n  bool verify_callback_2(cryptonote::core& c, size_t ev_index, const std::vector<test_event_entry> &events);\n};\n\nclass one_block: public test_chain_unit_base\n{\n  cryptonote::account_base alice;\npublic:\n  one_block();\n  bool generate(std::vector<test_event_entry> &events);\n  bool verify_1(cryptonote::core& c, size_t ev_index, const std::vector<test_event_entry> &events);\n};\n",
        "gt": [
            "'zephyr/tests/core_tests/chain_switch_1.h'",
            "'zephyr/tests/core_tests/chaingen_tests_list.h'",
            "'zephyr/tests/core_tests/chaingen001.cpp'"
        ]
    },
    {
        "files": [
            "'jarkViewer/jarkViewer/include/opencv2/quality/qualitybase.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/quality.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/quality/qualityssim.hpp'"
        ],
        "content": "'jarkViewer/jarkViewer/include/opencv2/quality/qualitybase.hpp'\n:\n\n\n\n#ifndef OPENCV_QUALITYBASE_HPP\n#define OPENCV_QUALITYBASE_HPP\n\n#include <opencv2/core.hpp>\n\n\n\nnamespace cv\n{\nnamespace quality\n{\n\n\n\n\n\nclass CV_EXPORTS_W QualityBase\n    : public virtual Algorithm\n{\npublic:\n\n\n    virtual ~QualityBase() = default;\n\n\n    virtual CV_WRAP cv::Scalar compute( InputArray img ) = 0;\n\n\n    virtual CV_WRAP void getQualityMap(OutputArray dst) const\n    {\n        if (!dst.needed() || _qualityMap.empty() )\n            return;\n        dst.assign(_qualityMap);\n    }\n\n\n    CV_WRAP void clear() CV_OVERRIDE { _qualityMap = _mat_type(); Algorithm::clear(); }\n\n\n    CV_WRAP bool empty() const CV_OVERRIDE { return _qualityMap.empty(); }\n\nprotected:\n\n\n    using _mat_type = cv::UMat;\n\n\n    _mat_type _qualityMap;\n\n};\n\n}\n}\n#endif\n'jarkViewer/jarkViewer/include/opencv2/quality.hpp'\n:\n\n\n\n#ifndef OPENCV_QUALITY_HPP\n#define OPENCV_QUALITY_HPP\n\n#include \"quality/qualitybase.hpp\"\n#include \"quality/qualitymse.hpp\"\n#include \"quality/qualitypsnr.hpp\"\n#include \"quality/qualityssim.hpp\"\n#include \"quality/qualitygmsd.hpp\"\n#include \"quality/qualitybrisque.hpp\"\n\n#endif\n'jarkViewer/jarkViewer/include/opencv2/quality/qualityssim.hpp'\n:\n\n\n\n#ifndef OPENCV_QUALITY_QUALITYSSIM_HPP\n#define OPENCV_QUALITY_QUALITYSSIM_HPP\n\n#include \"qualitybase.hpp\"\n\nnamespace cv\n{\nnamespace quality\n{\n\n\nclass CV_EXPORTS_W QualitySSIM\n    : public QualityBase {\npublic:\n\n\n    CV_WRAP cv::Scalar compute( InputArray cmp ) CV_OVERRIDE;\n\n\n    CV_WRAP bool empty() const CV_OVERRIDE { return _refImgData.empty() && QualityBase::empty(); }\n\n\n    CV_WRAP void clear() CV_OVERRIDE { _refImgData = _mat_data(); QualityBase::clear(); }\n\n\n    CV_WRAP static Ptr<QualitySSIM> create( InputArray ref );\n\n\n    CV_WRAP static cv::Scalar compute( InputArray ref, InputArray cmp, OutputArray qualityMap );\n\nprotected:\n\n\n    struct _mat_data\n    {\n\n        using mat_type = QualityBase::_mat_type;\n\n        mat_type\n            I\n            , I_2\n            , mu\n            , mu_2\n            , sigma_2\n            ;\n\n\n        _mat_data() = default;\n\n\n        _mat_data(const mat_type&);\n\n\n        _mat_data(InputArray);\n\n\n        bool empty() const { return I.empty() && I_2.empty() && mu.empty() && mu_2.empty() && sigma_2.empty(); }\n\n\n        static std::pair<cv::Scalar, mat_type> compute(const _mat_data& lhs, const _mat_data& rhs);\n\n    };\n\n\n    _mat_data _refImgData;\n\n\n    QualitySSIM( _mat_data refImgData )\n        : _refImgData( std::move(refImgData) )\n    {}\n\n};\n}\n}\n#endif",
        "gt": [
            "'jarkViewer/jarkViewer/include/opencv2/quality/qualitybase.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/quality/qualityssim.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/quality.hpp'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/signature/attributes/GenericType.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/signature/attributes.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/errors.hpp'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/signature/attributes/GenericType.hpp'\n:\n#ifndef LIEF_PE_ATTRIBUTES_GENERIC_TYPE_H\n#define LIEF_PE_ATTRIBUTES_GENERIC_TYPE_H\n#include <memory>\n#include <vector>\n\n#include \"LIEF/visibility.h\"\n#include \"LIEF/errors.hpp\"\n#include \"LIEF/PE/signature/Attribute.hpp\"\n#include \"LIEF/PE/signature/types.hpp\"\n\n\nnamespace LIEF {\nclass VectorStream;\nnamespace PE {\n\nclass Parser;\nclass SignatureParser;\n\n\nclass LIEF_API GenericType : public Attribute {\n\n  friend class Parser;\n  friend class SignatureParser;\n\n  public:\n  GenericType();\n  GenericType(oid_t oid, std::vector<uint8_t> raw);\n  GenericType(const GenericType&);\n  GenericType& operator=(const GenericType&);\n\n  std::unique_ptr<Attribute> clone() const override;\n\n\n  inline const oid_t& oid() const {\n    return oid_;\n  }\n\n\n  inline const std::vector<uint8_t>& raw_content() const {\n    return raw_;\n  }\n\n\n  std::string print() const override;\n\n  void accept(Visitor& visitor) const override;\n\n  virtual ~GenericType();\n\n  private:\n  oid_t oid_;\n  std::vector<uint8_t> raw_;\n};\n\n}\n}\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE.hpp'\n:\n#ifndef LIEF_PE_H\n#define LIEF_PE_H\n\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_PE_SUPPORT)\n\n#include \"LIEF/PE/Parser.hpp\"\n#include \"LIEF/PE/Section.hpp\"\n#include \"LIEF/PE/TLS.hpp\"\n#include \"LIEF/PE/Export.hpp\"\n#include \"LIEF/PE/ExportEntry.hpp\"\n#include \"LIEF/PE/Import.hpp\"\n#include \"LIEF/PE/ImportEntry.hpp\"\n#include \"LIEF/PE/DelayImport.hpp\"\n#include \"LIEF/PE/DelayImportEntry.hpp\"\n#include \"LIEF/PE/Pogo.hpp\"\n#include \"LIEF/PE/PogoEntry.hpp\"\n#include \"LIEF/PE/DataDirectory.hpp\"\n#include \"LIEF/PE/ResourcesManager.hpp\"\n#include \"LIEF/PE/ResourceData.hpp\"\n#include \"LIEF/PE/ResourceNode.hpp\"\n#include \"LIEF/PE/ResourceDirectory.hpp\"\n#include \"LIEF/PE/resources/LangCodeItem.hpp\"\n#include \"LIEF/PE/resources/ResourceAccelerator.hpp\"\n#include \"LIEF/PE/resources/ResourceDialog.hpp\"\n#include \"LIEF/PE/resources/ResourceDialogItem.hpp\"\n#include \"LIEF/PE/resources/ResourceFixedFileInfo.hpp\"\n#include \"LIEF/PE/resources/ResourceIcon.hpp\"\n#include \"LIEF/PE/resources/ResourceStringFileInfo.hpp\"\n#include \"LIEF/PE/resources/ResourceStringTable.hpp\"\n#include \"LIEF/PE/resources/ResourceVarFileInfo.hpp\"\n#include \"LIEF/PE/resources/ResourceVersion.hpp\"\n#include \"LIEF/PE/RichEntry.hpp\"\n#include \"LIEF/PE/RichHeader.hpp\"\n#include \"LIEF/PE/Symbol.hpp\"\n#include \"LIEF/PE/Relocation.hpp\"\n#include \"LIEF/PE/RelocationEntry.hpp\"\n#include \"LIEF/PE/Symbol.hpp\"\n#include \"LIEF/PE/Builder.hpp\"\n#include \"LIEF/PE/Binary.hpp\"\n#include \"LIEF/PE/Debug.hpp\"\n#include \"LIEF/PE/DosHeader.hpp\"\n#include \"LIEF/PE/Header.hpp\"\n#include \"LIEF/PE/OptionalHeader.hpp\"\n#include \"LIEF/PE/CodeView.hpp\"\n#include \"LIEF/PE/CodeViewPDB.hpp\"\n#include \"LIEF/PE/LoadConfigurations.hpp\"\n#include \"LIEF/PE/AuxiliarySymbol.hpp\"\n#include \"LIEF/PE/CodeIntegrity.hpp\"\n\n#include \"LIEF/PE/signature/attributes.hpp\"\n#include \"LIEF/PE/signature/Attribute.hpp\"\n#include \"LIEF/PE/signature/ContentInfo.hpp\"\n#include \"LIEF/PE/signature/OIDToString.hpp\"\n#include \"LIEF/PE/signature/Signature.hpp\"\n#include \"LIEF/PE/signature/SignerInfo.hpp\"\n#include \"LIEF/PE/signature/types.hpp\"\n#include \"LIEF/PE/signature/x509.hpp\"\n\n#include \"LIEF/PE/hash.hpp\"\n#include \"LIEF/PE/enums.hpp\"\n#include \"LIEF/PE/EnumToString.hpp\"\n#include \"LIEF/PE/utils.hpp\"\n\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'\n:\n#ifndef LIEF_TO_JSON_H\n#define LIEF_TO_JSON_H\n\n#include \"LIEF/config.h\"\n\n#ifdef LIEF_JSON_SUPPORT\n\n\n#ifdef LIEF_ELF_SUPPORT\n#include \"LIEF/ELF/json.hpp\"\n#endif\n\n#ifdef LIEF_PE_SUPPORT\n#include \"LIEF/PE/json.hpp\"\n#endif\n\n#include \"LIEF/Abstract/json.hpp\"\n\n#include \"LIEF/Abstract.hpp\"\n#include \"LIEF/ELF.hpp\"\n#include \"LIEF/PE.hpp\"\n\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/signature/attributes.hpp'\n:\n#ifndef LIEF_PE_SIGNATURE_ATTRIBUTES_H\n#define LIEF_PE_SIGNATURE_ATTRIBUTES_H\n#include \"LIEF/PE/signature/attributes/ContentType.hpp\"\n#include \"LIEF/PE/signature/attributes/GenericType.hpp\"\n#include \"LIEF/PE/signature/attributes/MsCounterSign.hpp\"\n#include \"LIEF/PE/signature/attributes/MsSpcNestedSignature.hpp\"\n#include \"LIEF/PE/signature/attributes/MsSpcStatementType.hpp\"\n#include \"LIEF/PE/signature/attributes/PKCS9AtSequenceNumber.hpp\"\n#include \"LIEF/PE/signature/attributes/PKCS9CounterSignature.hpp\"\n#include \"LIEF/PE/signature/attributes/PKCS9MessageDigest.hpp\"\n#include \"LIEF/PE/signature/attributes/PKCS9SigningTime.hpp\"\n#include \"LIEF/PE/signature/attributes/SpcSpOpusInfo.hpp\"\n#endif\n\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/errors.hpp'\n:\n#ifndef LIEF_ERROR_H\n#define LIEF_ERROR_H\n#include <system_error>\n#include <LIEF/third-party/leaf.hpp>\n\n\nenum class lief_errors {\n  read_error = 1,\n  not_found,\n  not_implemented,\n  not_supported,\n\n  corrupted,\n  conversion_error,\n\n  read_out_of_bound,\n  asn1_bad_tag,\n  file_error,\n\n  file_format_error,\n  parsing_error,\n  build_error,\n\n  data_too_large,\n\n};\n\nconst std::error_category& error_category();\nstd::error_code make_error_code(lief_errors e);\n\nnamespace std {\n  template<>\n  struct is_error_code_enum<lief_errors>: std::true_type\n  {};\n}\n\nconst std::error_category& lief_error_category();\n\n\ninline std::error_code make_error_code(lief_errors e) {\n  return std::error_code(int(e), lief_error_category());\n}\n\n\nnamespace LIEF {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntemplate<typename T>\nusing result = boost::leaf::result<T>;\n\n\ntemplate<typename T>\nusing error_result_t = typename result<T>::error_resul;\n\n\nusing error_t = boost::leaf::error_id;\n\n\nerror_t return_error(lief_errors);\n\n\ntemplate<class T>\nstd::error_code get_error(result<T>& err) {\n  return make_error_code(lief_errors(boost::leaf::error_id(err.error()).value()));\n}\n\n\ntemplate<class T>\nlief_errors as_lief_err(result<T>& err) {\n  return lief_errors(boost::leaf::error_id(err.error()).value());\n}\n\n\nstruct ok_t {};\n\n\ninline ok_t ok() {\n  return ok_t{};\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nusing ok_error_t = result<ok_t>;\n\n}\n\n\n\n\n\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/errors.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/signature/attributes/GenericType.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/signature/attributes.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/to_json.hpp'"
        ]
    },
    {
        "files": [
            "'LittleEngineVk/engine/src/resources/material_asset.cpp'",
            "'LittleEngineVk/engine/include/le/resources/asset.hpp'",
            "'LittleEngineVk/engine/include/le/resources/material_asset.hpp'"
        ],
        "content": "'LittleEngineVk/engine/src/resources/material_asset.cpp'\n:#include <le/resources/bin_data.hpp>\n#include <le/resources/material_asset.hpp>\n#include <le/resources/resources.hpp>\n#include <le/resources/texture_asset.hpp>\n#include <le/vfs/file_reader.hpp>\n\nnamespace le {\nnamespace {\ntemplate <glm::length_t Len, typename T>\nauto to_glm_vec(glm::vec<Len, T>& out, dj::Json const& array) -> void {\n\tif (!array.is_array()) { return; }\n\tout[0] = array[0].as<T>();\n\tif constexpr (Len > 1) { out[1] = array[1].as<T>(out[1]); }\n\tif constexpr (Len > 2) { out[2] = array[2].as<T>(out[2]); }\n\tif constexpr (Len > 3) { out[3] = array[3].as<T>(out[3]); }\n}\n\nconstexpr auto to_alpha_mode(std::string_view const in, graphics::AlphaMode const fallback) -> graphics::AlphaMode {\n\tif (in == \"blend\") { return graphics::AlphaMode::eBlend; }\n\tif (in == \"mask\") { return graphics::AlphaMode::eMask; }\n\tif (in == \"opaque\") { return graphics::AlphaMode::eOpaque; }\n\treturn fallback;\n}\n\ntemplate <std::derived_from<graphics::UnlitMaterial> T = graphics::UnlitMaterial>\n[[nodiscard]] auto make_unlit(dj::Json const& json) -> std::unique_ptr<T> {\n\tauto ret = std::make_unique<T>();\n\n\tif (auto const& base_colour = json[\"base_colour\"]) {\n\t\tif (auto* texture_asset = Resources::self().load<TextureAsset>(base_colour.as_string())) { ret->texture = &texture_asset->texture; }\n\t}\n\n\treturn ret;\n}\n\ntemplate <std::derived_from<graphics::LitMaterial> T = graphics::LitMaterial>\n[[nodiscard]] auto make_lit(dj::Json const& json) -> std::unique_ptr<T> {\n\tauto ret = std::make_unique<T>();\n\n\tif (auto const& base_colour = json[\"base_colour\"]) {\n\t\tif (auto* texture_asset = Resources::self().load<TextureAsset>(base_colour.as_string())) { ret->base_colour = &texture_asset->texture; }\n\t}\n\tif (auto const& metallic_roughness = json[\"metallic_roughness\"]) {\n\t\tif (auto* texture_asset = Resources::self().load<TextureAsset>(metallic_roughness.as_string())) { ret->metallic_roughness = &texture_asset->texture; }\n\t}\n\tif (auto const& emissive = json[\"emissive\"]) {\n\t\tif (auto* texture_asset = Resources::self().load<TextureAsset>(emissive.as_string())) { ret->emissive = &texture_asset->texture; }\n\t}\n\n\tif (auto const& in_albedo = json[\"albedo\"]) {\n\t\tauto albedo = ret->albedo.to_vec4();\n\t\tto_glm_vec(albedo, in_albedo);\n\t\tret->albedo = graphics::Rgba::from(albedo);\n\t}\n\tif (auto const& in_emissive_factor = json[\"emissive_factor\"]) { to_glm_vec(ret->emissive_factor, in_emissive_factor); }\n\n\tret->metallic = json[\"metallic\"].as<float>(ret->metallic);\n\tret->roughness = json[\"roughness\"].as<float>(ret->roughness);\n\tret->alpha_cutoff = json[\"alpha_cutoff\"].as<float>(ret->alpha_cutoff);\n\tret->alpha_mode = to_alpha_mode(json[\"alpha_mode\"].as_string(), ret->alpha_mode);\n\n\treturn ret;\n}\n}\n\nauto MaterialAsset::try_load(Uri const& uri) -> bool {\n\tauto const json = read_json(uri);\n\tif (!json) { return false; }\n\n\tauto const material_type = json[\"material_type\"].as_string();\n\tif (material_type == graphics::LitMaterial::material_type_v) {\n\t\tmaterial = make_lit(json);\n\t\treturn true;\n\t}\n\n\tif (material_type == graphics::SkinnedMaterial::material_type_v) {\n\t\tmaterial = make_lit<graphics::SkinnedMaterial>(json);\n\t\treturn true;\n\t}\n\n\tif (material_type == graphics::SkyboxMaterial::material_type_v) {\n\t\tmaterial = make_unlit<graphics::SkyboxMaterial>(json);\n\t\treturn true;\n\t}\n\n\tmaterial = make_unlit(json);\n\treturn true;\n}\n}\n\n'LittleEngineVk/engine/include/le/resources/asset.hpp'\n:#pragma once\n#include <djson/json.hpp>\n#include <le/core/named_type.hpp>\n#include <le/vfs/uri.hpp>\n#include <cstdint>\n#include <vector>\n\nnamespace le {\nclass Asset : public NamedType {\n  public:\n\t[[nodiscard]] auto type_name() const -> std::string_view override { return \"Asset\"; }\n\t[[nodiscard]] virtual auto try_load(Uri const& uri) -> bool = 0;\n\n\t[[nodiscard]] static auto get_asset_type(dj::Json const& json) -> std::string_view { return json[\"asset_type\"].as_string(); }\n\t[[nodiscard]] static auto get_asset_type(Uri const& uri) -> std::string_view;\n\n  protected:\n\t[[nodiscard]] auto read_bytes(Uri const& uri) const -> std::vector<std::byte>;\n\t[[nodiscard]] auto read_string(Uri const& uri) const -> std::string;\n\t[[nodiscard]] auto read_json(Uri const& uri) const -> dj::Json;\n};\n}\n\n'LittleEngineVk/engine/include/le/resources/material_asset.hpp'\n:#pragma once\n#include <le/graphics/material.hpp>\n#include <le/resources/asset.hpp>\n\nnamespace le {\nclass MaterialAsset : public Asset {\n  public:\n\tstatic constexpr std::string_view type_name_v{\"MaterialAsset\"};\n\n\t[[nodiscard]] auto type_name() const -> std::string_view final { return type_name_v; }\n\t[[nodiscard]] auto try_load(Uri const& uri) -> bool final;\n\n\tstd::unique_ptr<graphics::Material> material{};\n};\n}\n",
        "gt": [
            "'LittleEngineVk/engine/include/le/resources/asset.hpp'",
            "'LittleEngineVk/engine/include/le/resources/material_asset.hpp'",
            "'LittleEngineVk/engine/src/resources/material_asset.cpp'"
        ]
    },
    {
        "files": [
            "'sigviewer/src/tests/tests_dialog.cpp'",
            "'sigviewer/src/tests/tests_factory.h'",
            "'sigviewer/src/tests/gui_tests.h'"
        ],
        "content": "'sigviewer/src/tests/tests_dialog.cpp'\n:\n\n\n\n\n#include \"tests_dialog.h\"\n#include \"tests_factory.h\"\n#include \"gui_impl/commands/open_file_gui_command.h\"\n\nnamespace sigviewer\n{\n\nusing namespace Tests_;\n\n\nTestsDialog::TestsDialog ()\n{\n    ui_.setupUi (this);\n    ui_.progressBar->setValue (0);\n}\n\n\nvoid TestsDialog::runTests ()\n{\n    QList<QSharedPointer<Test> > tests = TestsFactory_::allTests ();\n    ui_.progressBar->setMaximum (tests.size ());\n    ui_.progressBar->setValue (0);\n\n    unsigned fails = 0;\n\n    foreach (QSharedPointer<Test> test, tests)\n    {\n        QColor color;\n        QString test_name = test->getName();\n        test->init();\n        QString result = test->run();\n        test->cleanup();\n        if (result.size())\n        {\n            test_name += tr(\" failed: \") + result;\n            color = QColor (255, 0, 0, 50);\n            fails++;\n        }\n        else\n        {\n            test_name += tr(\": passed %1 verifications\").arg(test->passed());\n            color = QColor (0, 255, 0, 50);\n        }\n        ui_.listWidget->addItem (test_name);\n        ui_.listWidget->item (ui_.listWidget->count() - 1)->setBackgroundColor (color);\n        ui_.progressBar->setValue(ui_.progressBar->value()+1);\n    }\n    if (fails)\n        ui_.listWidget->addItem(tr(\"%1 tests failed!\").arg(fails));\n    else\n        ui_.listWidget->addItem(tr(\"All tests passed!\"));\n}\n\n\nvoid TestsDialog::on_start_button__clicked ()\n{\n    runTests();\n}\n\n\nvoid TestsDialog::on_open_dummy__clicked ()\n{\n    OpenFileGuiCommand::openFile (\"blub.sinusdummy\");\n    close();\n}\n\n\n}\n\n'sigviewer/src/tests/tests_factory.h'\n:\n\n\n\n\n#ifndef TESTS_FACTORY_H\n#define TESTS_FACTORY_H\n\n#include \"test.h\"\n#include \"event_manager_tests.h\"\n#include \"data_block_tests.h\"\n#include \"editing_commands_tests.h\"\n#include \"gui_tests.h\"\n#include \"color_manager_tests.h\"\n#include \"file_handling_tests.h\"\n#include \"event_table_widget_tests.h\"\n\n#include <QSharedPointer>\n#include <QList>\n\nnamespace sigviewer\n{\n\nnamespace TestsFactory_\n{\n\n\nQList<QSharedPointer<Tests_::Test> > allTests ()\n{\n    QList<QSharedPointer<Tests_::Test> > tests;\n    tests.append (QSharedPointer<Tests_::Test>(new Tests_::DataBlockTests));\n    tests.append (QSharedPointer<Tests_::Test>(new Tests_::ColorManagerTests));\n    tests.append (QSharedPointer<Tests_::Test>(new Tests_::EventManagerTests));\n    tests.append (QSharedPointer<Tests_::Test>(new Tests_::EditingCommandsTests));\n    tests.append (QSharedPointer<Tests_::Test>(new Tests_::GuiTests));\n    tests.append (QSharedPointer<Tests_::Test>(new Tests_::FileHandlingTests));\n    tests.append (QSharedPointer<Tests_::Test>(new Tests_::EventTableWidgetTests));\n\n    return tests;\n}\n\n}\n\n}\n\n#endif\n\n'sigviewer/src/tests/gui_tests.h'\n:\n\n\n\n\n#ifndef GUI_TESTS_H\n#define GUI_TESTS_H\n\n#include \"test.h\"\n\nnamespace sigviewer\n{\nnamespace Tests_\n{\n\nclass GuiTests : public Test\n{\npublic:\n    GuiTests() : Test (tr(\"GUI Tests\")) {}\n    virtual void init ();\n    virtual QString run ();\n    virtual void cleanup ();\nprivate:\n    QString testZooming ();\n    QString testEventEditing ();\n    QString testEnablednessNoOpenFile ();\n\n    bool animations_triggered_;\n};\n\n}\n\n}\n\n#endif\n",
        "gt": [
            "'sigviewer/src/tests/gui_tests.h'",
            "'sigviewer/src/tests/tests_factory.h'",
            "'sigviewer/src/tests/tests_dialog.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/MethodServiceConfig.h'",
            "'OpcUaStack/src/OpcUaStackCore/Utility/IOThread.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ServiceConfigBase.h'",
            "'OpcUaStack/tst/OpcUaStackClient/ServiceSet/ServiceSetManagerAsyncReal_t.cpp'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ServiceSetManager.h'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackClient/ServiceSet/MethodServiceConfig.h'\n:\n#ifndef __OpcUaStackClient_MethodServiceConfig_h__\n#define __OpcUaStackClient_MethodServiceConfig_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Utility/IOThread.h\"\n#include \"OpcUaStackClient/ServiceSet/MethodService.h\"\n#include \"OpcUaStackClient/ServiceSet/ServiceConfigBase.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackClient\n{\n\n\tclass DLLEXPORT MethodServiceConfig\n\t: public ServiceConfigBase\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<MethodServiceConfig> SPtr;\n\n\t\tMethodServiceConfig(void);\n\t\tvirtual ~MethodServiceConfig(void);\n\n\t\tMethodServiceIf* methodServiceIf_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/Utility/IOThread.h'\n:#ifndef __OpcUaStackCore_IOThread_h__\n#define __OpcUaStackCore_IOThread_h__\n\n#include <boost/shared_ptr.hpp>\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/IOService.h\"\n#include \"OpcUaStackCore/Utility/SlotTimer.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT IOThread\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<IOThread> SPtr;\n\t\ttypedef std::map<std::string, IOThread::SPtr> Map;\n\n\t\tIOThread(void);\n\t\t~IOThread(void);\n\n\t\tvoid ioService(const IOService::SPtr& ioService);\n\t\tIOService::SPtr& ioService(void);\n\t\tvoid slotTimer(const SlotTimer::SPtr& slotTimer);\n\t\tSlotTimer::SPtr& slotTimer(void);\n\t\tvoid numberThreads(uint32_t numberThreads);\n\n\t\tbool startup(void);\n\t\tbool shutdown(void);\n\n\t\ttemplate<typename HANDLER>\n\t\t    void run(HANDLER handler)\n\t\t\t{\n\t\t\t\tioService_->run(handler);\n\t\t\t}\n\n\t  private:\n\t\tvoid createIOService(void);\n\t\tvoid deleteIOService(void);\n\t\tvoid createSlotTimer(void);\n\t\tvoid deleteSlotTimer(void);\n\n\t\tuint32_t numberThreads_;\n\t\tIOService::SPtr ioService_;\n\t\tSlotTimer::SPtr slotTimer_;\n\t\tbool ioServiceCreateFlag_;\n\t\tbool slotTimerCreateFlag_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackClient/ServiceSet/ServiceConfigBase.h'\n:\n#ifndef __OpcUaStackClient_ServiceConfigBase_h__\n#define __OpcUaStackClient_ServiceConfigBase_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Utility/IOThread.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackClient\n{\n\n\tclass DLLEXPORT ServiceConfigBase\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<ServiceConfigBase> SPtr;\n\n\t\tServiceConfigBase(const std::string& ioThreadName);\n\t\tvirtual ~ServiceConfigBase(void);\n\n\t    void ioThreadName(const std::string& ioThreadName);\n\t    std::string ioThreadName(void);\n\n\t   private:\n\t\tstd::string ioThreadName_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/tst/OpcUaStackClient/ServiceSet/ServiceSetManagerAsyncReal_t.cpp'\n:#include \"unittest.h\"\n#include \"OpcUaStackClient/ServiceSet/ServiceSetManager.h\"\n\nusing namespace OpcUaStackClient;\n\n#ifdef REAL_SERVER\n\nBOOST_AUTO_TEST_SUITE(ServiceSetManagerAsyncReal_)\n\nBOOST_AUTO_TEST_CASE(ServiceSetManagerAsyncReal_)\n{\n\tstd::cout << \"ServiceSetManagerAsyncReal_t\" << std::endl;\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n\n#endif\n\n'OpcUaStack/src/OpcUaStackClient/ServiceSet/ServiceSetManager.h'\n:\n#ifndef __OpcUaStackClient_ServiceSetManager_h__\n#define __OpcUaStackClient_ServiceSetManager_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Utility/IOThread.h\"\n#include \"OpcUaStackClient/ServiceSet/SessionService.h\"\n#include \"OpcUaStackClient/ServiceSet/SessionServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/DiscoveryService.h\"\n#include \"OpcUaStackClient/ServiceSet/DiscoveryServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/AttributeService.h\"\n#include \"OpcUaStackClient/ServiceSet/AttributeServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/SubscriptionService.h\"\n#include \"OpcUaStackClient/ServiceSet/SubscriptionServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/MonitoredItemService.h\"\n#include \"OpcUaStackClient/ServiceSet/MonitoredItemServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/MethodService.h\"\n#include \"OpcUaStackClient/ServiceSet/MethodServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/ViewService.h\"\n#include \"OpcUaStackClient/ServiceSet/ViewServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/QueryService.h\"\n#include \"OpcUaStackClient/ServiceSet/QueryServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/NodeManagementService.h\"\n#include \"OpcUaStackClient/ServiceSet/NodeManagementServiceConfig.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackClient\n{\n\n\tclass DLLEXPORT ServiceSetManager\n\t{\n\t  public:\n\t\tServiceSetManager(void);\n\t\t~ServiceSetManager(void);\n\n\t\tvoid start(void) {}\n\t\tvoid stop(void) {}\n\n\t\tvoid registerIOThread(const std::string ioThreadName, IOThread::SPtr ioThread);\n\t\tvoid deregisterIOThread(const std::string ioThreadName);\n\n\n\t\tSessionService::SPtr sessionService(\n\t\t\tSessionServiceConfig& sessionServiceConfig\n\t\t);\n\t\tvoid updateEndpointUrl(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tconst std::string& endpointUrl\n\t\t);\n\n\n\t\tDiscoveryService::SPtr discoveryService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tDiscoveryService::SPtr discoveryService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tDiscoveryServiceConfig& discoveryServiceConfig\n\t\t);\n\n\n\t\tAttributeService::SPtr attributeService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tAttributeService::SPtr attributeService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tAttributeServiceConfig& attributeServiceConfig\n\t\t);\n\n\n\t\tSubscriptionService::SPtr subscriptionService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tSubscriptionService::SPtr subscriptionService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tSubscriptionServiceConfig& subscriptionServiceConfig\n\t\t);\n\n\n\t\tMonitoredItemService::SPtr monitoredItemService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tMonitoredItemService::SPtr monitoredItemService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tMonitoredItemServiceConfig& monitoredItemServiceConfig\n\t\t);\n\n\n\t\tMethodService::SPtr methodService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tMethodService::SPtr methodService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tMethodServiceConfig& methodServiceConfig\n\t\t);\n\n\n\t\tViewService::SPtr viewService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tViewService::SPtr viewService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tViewServiceConfig& viewServiceConfig\n\t\t);\n\n\n\t\tQueryService::SPtr queryService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tQueryService::SPtr queryService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tQueryServiceConfig& queryServiceConfig\n\t\t);\n\n\n\t\tNodeManagementService::SPtr nodeManagementService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tNodeManagementService::SPtr nodeManagementService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tNodeManagementServiceConfig& nodeManagementServiceConfig\n\t\t);\n\n\t  private:\n\t\tIOThread::SPtr getIOThread(const std::string ioThreadName);\n\t\tvoid createIOThread(const std::string ioThreadName);\n\t\tvoid destroyIOThread(const std::string ioThreadName);\n\n\t\tIOThread::Map ioThreadMap_;\n\t};\n\n}\n\n#endif\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/Utility/IOThread.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ServiceConfigBase.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/MethodServiceConfig.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ServiceSetManager.h'",
            "'OpcUaStack/tst/OpcUaStackClient/ServiceSet/ServiceSetManagerAsyncReal_t.cpp'"
        ]
    },
    {
        "files": [
            "'Tempest/Engine/thirdparty/openal-soft/core/front_stablizer.h'",
            "'Tempest/Engine/thirdparty/openal-soft/core/bformatdec.h'",
            "'Tempest/Engine/thirdparty/openal-soft/core/device.cpp'"
        ],
        "content": "'Tempest/Engine/thirdparty/openal-soft/core/front_stablizer.h'\n:#ifndef CORE_FRONT_STABLIZER_H\n#define CORE_FRONT_STABLIZER_H\n\n#include <array>\n#include <memory>\n\n#include \"almalloc.h\"\n#include \"bufferline.h\"\n#include \"filters/splitter.h\"\n#include \"flexarray.h\"\n\n\nstruct FrontStablizer {\n    FrontStablizer(size_t numchans) : ChannelFilters{numchans} { }\n\n    alignas(16) std::array<float,BufferLineSize> MidDirect{};\n    alignas(16) std::array<float,BufferLineSize> Side{};\n    alignas(16) std::array<float,BufferLineSize> Temp{};\n\n    BandSplitter MidFilter;\n    alignas(16) FloatBufferLine MidLF{};\n    alignas(16) FloatBufferLine MidHF{};\n\n    al::FlexArray<BandSplitter,16> ChannelFilters;\n\n    static std::unique_ptr<FrontStablizer> Create(size_t numchans)\n    { return std::unique_ptr<FrontStablizer>{new(FamCount(numchans)) FrontStablizer{numchans}}; }\n\n    DEF_FAM_NEWDEL(FrontStablizer, ChannelFilters)\n};\n\n#endif\n\n'Tempest/Engine/thirdparty/openal-soft/core/bformatdec.h'\n:#ifndef CORE_BFORMATDEC_H\n#define CORE_BFORMATDEC_H\n\n#include <array>\n#include <cstddef>\n#include <memory>\n#include <variant>\n#include <vector>\n\n#include \"alspan.h\"\n#include \"ambidefs.h\"\n#include \"bufferline.h\"\n#include \"devformat.h\"\n#include \"filters/splitter.h\"\n#include \"front_stablizer.h\"\n#include \"opthelpers.h\"\n\n\nusing ChannelDec = std::array<float,MaxAmbiChannels>;\n\nclass SIMDALIGN BFormatDec {\n    static constexpr size_t sHFBand{0};\n    static constexpr size_t sLFBand{1};\n    static constexpr size_t sNumBands{2};\n\n    struct ChannelDecoderSingle {\n        std::array<float,MaxOutputChannels> mGains{};\n    };\n\n    struct ChannelDecoderDual {\n        BandSplitter mXOver;\n        std::array<std::array<float,MaxOutputChannels>,sNumBands> mGains{};\n    };\n\n    alignas(16) std::array<FloatBufferLine,2> mSamples{};\n\n    const std::unique_ptr<FrontStablizer> mStablizer;\n\n    std::variant<std::vector<ChannelDecoderSingle>,std::vector<ChannelDecoderDual>> mChannelDec;\n\npublic:\n    BFormatDec(const size_t inchans, const al::span<const ChannelDec> coeffs,\n        const al::span<const ChannelDec> coeffslf, const float xover_f0norm,\n        std::unique_ptr<FrontStablizer> stablizer);\n\n    [[nodiscard]] auto hasStablizer() const noexcept -> bool { return mStablizer != nullptr; }\n\n\n    void process(const al::span<FloatBufferLine> OutBuffer,\n        const al::span<const FloatBufferLine> InSamples, const size_t SamplesToDo);\n\n\n    void processStablize(const al::span<FloatBufferLine> OutBuffer,\n        const al::span<const FloatBufferLine> InSamples, const size_t lidx, const size_t ridx,\n        const size_t cidx, const size_t SamplesToDo);\n\n    static std::unique_ptr<BFormatDec> Create(const size_t inchans,\n        const al::span<const ChannelDec> coeffs, const al::span<const ChannelDec> coeffslf,\n        const float xover_f0norm, std::unique_ptr<FrontStablizer> stablizer);\n};\n\n#endif\n\n'Tempest/Engine/thirdparty/openal-soft/core/device.cpp'\n:\n#include \"config.h\"\n\n#include \"bformatdec.h\"\n#include \"bs2b.h\"\n#include \"device.h\"\n#include \"front_stablizer.h\"\n#include \"hrtf.h\"\n#include \"mastering.h\"\n\n\nstatic_assert(std::atomic<std::chrono::nanoseconds>::is_always_lock_free);\n\n\nDeviceBase::DeviceBase(DeviceType type)\n    : Type{type}, mContexts{al::FlexArray<ContextBase*>::Create(0)}\n{\n}\n\nDeviceBase::~DeviceBase() = default;\n",
        "gt": [
            "'Tempest/Engine/thirdparty/openal-soft/core/front_stablizer.h'",
            "'Tempest/Engine/thirdparty/openal-soft/core/bformatdec.h'",
            "'Tempest/Engine/thirdparty/openal-soft/core/device.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackCore/ComplexDataTypes/ComplexDataType.h'",
            "'OpcUaStack/src/OpcUaStackCore/ComplexDataTypes/ComplexDataCodeGenerator.h'",
            "'OpcUaStack/tst/OpcUaStackCore/ComplexDataTypes/ComplexDataCodeGenerator_t.cpp'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackCore/ComplexDataTypes/ComplexDataType.h'\n:\n\n#ifndef __OpcUaStackCore_ComplexDataType_h__\n#define __OpcUaStackCore_ComplexDataType_h__\n\n#include <boost/shared_ptr.hpp>\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaNodeId.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaType.h\"\n\n#include <vector>\n#include <map>\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT ComplexDataTypeItem\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<ComplexDataTypeItem> SPtr;\n\t\ttypedef std::vector<ComplexDataTypeItem::SPtr> Vec;\n\n\t\tComplexDataTypeItem(void);\n\t\tComplexDataTypeItem(const std::string& itemName, OpcUaBuildInType itemType);\n\t\tvirtual ~ComplexDataTypeItem(void);\n\n\t\tComplexDataTypeItem::SPtr make(const std::string& itemName, OpcUaBuildInType itemType);\n\t\tvoid itemName(const std::string& itemName);\n\t\tstd::string& itemName(void);\n\t\tvoid itemType(OpcUaBuildInType itemType);\n\t\tOpcUaBuildInType itemType(void);\n\t\tvoid mandatory(bool mandatory);\n\t\tbool mandatory(void);\n\t\tvoid defaultValue(const std::string& defaultValue);\n\t\tstd::string& defaultValue(void);\n\n\t  private:\n\t\tstd::string itemName_;\n\t\tOpcUaBuildInType itemType_;\n\t\tbool mandatory_;\n\t\tstd::string defaultValue_;\n\t};\n\n\n\tclass DLLEXPORT ComplexDataType\n\t{\n\t  public:\n\t\ttypedef std::map<std::string, uint32_t> NameIndexMap;\n\t\ttypedef boost::shared_ptr<ComplexDataType> SPtr;\n\t\ttypedef std::map<std::string, ComplexDataType::SPtr> Map;\n\n\t\tComplexDataType(void);\n\t\tComplexDataType(const std::string& name, ComplexDataTypeItem::Vec& complexDataTypeItemVec);\n\t\tvirtual ~ComplexDataType(void);\n\n\t\tvoid complexDataTypeItemVec(ComplexDataTypeItem::Vec& complexDataTypeItemVec);\n\t\tvoid addComplexDataTypeItem(ComplexDataTypeItem::SPtr& complexDataTypeItem);\n\t\tbool addSuperTypeItemVec(ComplexDataTypeItem::Vec& superTypeItemVec);\n\t\tComplexDataTypeItem::Vec& complexDataTypeItemVec(void);\n\t\tComplexDataTypeItem::SPtr complexDataTypeItem(const std::string& name);\n\t\tComplexDataTypeItem::SPtr complexDataTypeItem(uint32_t index);\n\n\t\tvoid binaryTypeId(const OpcUaNodeId& binaryTypeId);\n\t\tOpcUaNodeId& binaryTypeId(void);\n\t\tvoid xmlTypeId(OpcUaNodeId& xmlTypeId);\n\t\tOpcUaNodeId& xmlTypeId(void);\n\n\t\tvoid name(const std::string& name);\n\t\tstd::string& name(void);\n\t\tvoid projectNamespace(const std::string& projectNamespace);\n\t\tstd::string& projectNamespace(void);\n\t\tvoid projectFolder(const std::string& projectFolder);\n\t\tstd::string& projectFolder(void);\n\t\tvoid supertype(const std::string& supertype);\n\t\tstd::string& supertype(void);\n\t\tint32_t name2Index(const std::string& name);\n\t\tstd::string index2Name(uint32_t index);\n\t\tuint32_t size(void);\n\n\t  private:\n\t\tstd::string name_;\n\t\tstd::string supertype_;\n\t\tstd::string projectNamespace_;\n\t\tstd::string projectFolder_;\n\t\tNameIndexMap nameIndexMap_;\n\t\tOpcUaNodeId binaryTypeId_;\n\t\tOpcUaNodeId xmlTypeId_;\n\t\tComplexDataTypeItem::Vec complexDataTypeItemVec_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/ComplexDataTypes/ComplexDataCodeGenerator.h'\n:\n\n#ifndef __OpcUaStackCore_ComplexDataCodeGenerator_h__\n#define __OpcUaStackCore_ComplexDataCodeGenerator_h__\n\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/regex.hpp>\n#include <iostream>\n#include <sstream>\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/Log.h\"\n#include \"OpcUaStackCore/ComplexDataTypes/ComplexDataType.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT ComplexDataCodeGenerator\n\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<ComplexDataCodeGenerator> SPtr;\n\n\t\tComplexDataCodeGenerator(void);\n\t\tvirtual ~ComplexDataCodeGenerator(void);\n\n\t    void classTemplateFileHeader(const std::string& classTemplateFileHeader);\n\t    void classTemplateFileSource(const std::string& classTemplateFileSource);\n\n\t    bool generate(ComplexDataType& complexDataType);\n\t    bool generate(ComplexDataType& complexDataType, ComplexDataType& complexDataTypeSuperType);\n\t    std::string& contentHeader(void);\n\t    std::string& contentSource(void);\n\n\t  private:\n\t    bool generateHeader(ComplexDataType& complexDataType);\n\t    bool generateSource(ComplexDataType& complexDataType);\n\t    bool readClassTemplateFileHeader(void);\n\t    bool readClassTemplateFileSource(void);\n\t    bool substSuperType(std::string& content);\n\t    bool substProjectNamespace(std::string& content);\n\t    bool substClassName(std::string& content, const std::string& className);\n\t    bool substProjectFolder(std::string& content);\n\t    bool substValues(std::string& content);\n\t    bool substValuesInit(std::string& content);\n\t    bool substValuesEncode(std::string& content);\n\t    bool substValuesDecode(std::string& content);\n\t    bool substValuesOut(std::string& content);\n\t    bool substValuesCopyTo(std::string& content);\n\t    bool substValuesEqual(std::string& content);\n\t    bool substTypeIds(std::string& content);\n\n\t    std::string contentHeader_;\n\t    std::string contentSource_;\n\t\tstd::string classTemplateFileHeader_;\n\t\tstd::string classTemplateFileSource_;\n\t\tstd::string superType_;\n\t\tstd::string projectNamespace_;\n\t\tstd::string projectFolder_;\n\t\tstd::string projectNamespaceSuperType_;\n\t\tstd::string projectFolderSuperType_;\n\t\tstd::string values_;\n\t\tstd::string valuesInit_;\n\t\tstd::string valuesEncode_;\n\t\tstd::string valuesDecode_;\n\t\tstd::string valuesOut_;\n\t\tstd::string valuesCopyTo_;\n\t\tstd::string valuesEqual_;\n\t\tstd::string binaryTypeId_;\n\t\tstd::string xmlTypeId_;\n\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/tst/OpcUaStackCore/ComplexDataTypes/ComplexDataCodeGenerator_t.cpp'\n:#include \"unittest.h\"\n#include \"OpcUaStackCore/ComplexDataTypes/ComplexDataTypeParser.h\"\n#include \"OpcUaStackCore/ComplexDataTypes/ComplexDataCodeGenerator.h\"\n\nusing namespace OpcUaStackCore;\n\nBOOST_AUTO_TEST_SUITE(ComplexDataCodeGenerator_t)\n\nBOOST_AUTO_TEST_CASE(ComplexDataCodeGenerator_CodeGenerator)\n{\n\n\tComplexDataTypeParser parser;\n\tparser.mergeSuperType(false);\n\tBOOST_REQUIRE(parser.parse(\"../tst/data/OpcUaComplexDataTypes.xml\") == true);\n\n\n\tComplexDataType::SPtr type;\n\ttype = parser.complexDataType(\"MyComplexType1\");\n\tBOOST_REQUIRE(type.get() != nullptr);\n\n\n\tComplexDataCodeGenerator generator;\n\tgenerator.classTemplateFileHeader(\"../tst/data/OpcUaComplexDataType.h.tmpl\");\n\tgenerator.classTemplateFileSource(\"../tst/data/OpcUaComplexDataType.cpp.tmpl\");\n\tBOOST_REQUIRE(generator.generate(*type) == true);\n\n\tstd::cout << \"============================\" << std::endl;\n\tstd::cout << generator.contentHeader() << std::endl;\n\tstd::cout << \"============================\" << std::endl;\n\tstd::cout << generator.contentSource() << std::endl;\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/ComplexDataTypes/ComplexDataType.h'",
            "'OpcUaStack/src/OpcUaStackCore/ComplexDataTypes/ComplexDataCodeGenerator.h'",
            "'OpcUaStack/tst/OpcUaStackCore/ComplexDataTypes/ComplexDataCodeGenerator_t.cpp'"
        ]
    },
    {
        "files": [
            "'knowrob/src/queries/NegationStage.cpp'",
            "'knowrob/include/knowrob/reasoner/ReasonerManager.h'",
            "'knowrob/include/knowrob/queries/NegationStage.h'"
        ],
        "content": "'knowrob/src/queries/NegationStage.cpp'\n:\n\n#include <utility>\n\n#include \"knowrob/queries/NegationStage.h\"\n#include \"knowrob/KnowledgeBase.h\"\n#include \"knowrob/formulas/ModalFormula.h\"\n#include \"knowrob/storage/StorageInterface.h\"\n#include \"knowrob/semweb/RDFIndicator.h\"\n\nusing namespace knowrob;\n\nNegationStage::NegationStage(const std::shared_ptr<KnowledgeBase> &kb, QueryContextPtr ctx)\n\t\t: TokenBroadcaster(),\n\t\t  kb_(kb),\n\t\t  ctx_(std::move(ctx)) {}\n\nvoid NegationStage::pushToBroadcast(const TokenPtr &tok) {\n\tif (tok->tokenType() == TokenType::ANSWER_TOKEN) {\n\t\tauto answer = std::static_pointer_cast<const Answer>(tok);\n\t\tif (answer->isPositive()) {\n\t\t\tif (!succeeds(std::static_pointer_cast<const AnswerYes>(answer))) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tTokenBroadcaster::pushToBroadcast(tok);\n}\n\nPredicateNegationStage::PredicateNegationStage(const std::shared_ptr<KnowledgeBase> &kb,\n\t\t\t\t\t\t\t\t\t\t\t   const QueryContextPtr &ctx,\n\t\t\t\t\t\t\t\t\t\t\t   const std::vector<FirstOrderLiteralPtr> &negatedLiterals)\n\t\t: NegationStage(kb, ctx),\n\t\t  negatedLiterals_(negatedLiterals) {}\n\nbool PredicateNegationStage::succeeds(const AnswerYesPtr &answer) {\n\n\n\n\n\tstd::vector<TokenBufferPtr> results;\n\n\tauto kg = kb_->getBackendForQuery();\n\n\tfor (auto &pat: negatedLiterals_) {\n\t\tauto pat1 = applyBindings(pat, *answer->substitution());\n\t\tauto indicator = RDFIndicator(pat1->predicate());\n\n\n\t\tauto instance = std::make_shared<FirstOrderLiteral>(\n\t\t\t\tpat1->predicate(), pat1->isNegated());\n\n\n\n\t\tinstance->setIsNegated(false);\n\n\n\t\tif (indicator.arity <= 2) {\n\t\t\tauto rdfLiteral = std::make_shared<TriplePattern>(\n\t\t\t\t\tinstance->predicate(), instance->isNegated());\n\t\t\trdfLiteral->setTripleFrame(ctx_->selector);\n\t\t\tresults.push_back(kb_->edb()->getAnswerCursor(\n\t\t\t\t\tkg, std::make_shared<GraphPathQuery>(rdfLiteral, ctx_)));\n\t\t}\n\n\n\n\t\tif (indicator.functor) {\n\t\t\tauto l_reasoner = kb_->reasonerManager()->findDefiningReasoner(\n\t\t\t\t\tPredicateIndicator(*indicator.functor, indicator.arity));\n\t\t\tfor (auto &r: l_reasoner) {\n\t\t\t\tresults.push_back(ReasonerManager::evaluateQuery(r.first, {instance}, ctx_));\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (auto &result: results) {\n\t\tauto resultQueue = result->createQueue();\n\t\tauto firstResult = resultQueue->pop_front();\n\t\tif (firstResult->tokenType() == TokenType::ANSWER_TOKEN) {\n\t\t\tif (std::static_pointer_cast<const Answer>(firstResult)->isPositive()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nModalNegationStage::ModalNegationStage(const std::shared_ptr<KnowledgeBase> &kb,\n\t\t\t\t\t\t\t\t\t   const QueryContextPtr &ctx,\n\t\t\t\t\t\t\t\t\t   const std::vector<std::shared_ptr<ModalFormula>> &negatedModals)\n\t\t: NegationStage(kb, ctx),\n\t\t  negatedModals_(negatedModals) {}\n\nbool ModalNegationStage::succeeds(const AnswerYesPtr &answer) {\n\n\n\n\n\tauto outputStream = std::make_shared<TokenBuffer>();\n\n\n\tfor (auto &modal: negatedModals_) {\n\t\tauto modalInstance = applyBindings(modal, *answer->substitution());\n\t\tauto modalOutput = kb_->submitQuery(modalInstance, ctx_);\n\t\tmodalOutput >> outputStream;\n\t\tmodalOutput->stopBuffering();\n\t}\n\n\n\tauto resultQueue = outputStream->createQueue();\n\tauto firstResult = resultQueue->pop_front();\n\n\treturn firstResult->indicatesEndOfEvaluation();\n}\n\n'knowrob/include/knowrob/reasoner/ReasonerManager.h'\n:\n\n#ifndef KNOWROB_REASONER_MANAGER_H_\n#define KNOWROB_REASONER_MANAGER_H_\n\n#include \"knowrob/plugins/PluginManager.h\"\n#include \"knowrob/storage/StorageManager.h\"\n#include \"knowrob/KnowledgeBase.h\"\n#include \"knowrob/reasoner/GoalDrivenReasoner.h\"\n#include \"knowrob/reasoner/DataDrivenReasoner.h\"\n\nnamespace knowrob {\n\n\tclass ReasonerManager : public PluginManager<Reasoner> {\n\tpublic:\n\n\t\tReasonerManager(KnowledgeBase *kb, const std::shared_ptr<StorageManager> &backendManager);\n\n\t\t~ReasonerManager() override;\n\n\n\t\tauto kb() const { return kb_; }\n\n\n\t\tauto backendManager() const { return backendManager_; }\n\n\n\t\tauto &goalDriven() const { return goalDriven_; }\n\n\n\t\tauto &dataDriven() const { return dataDriven_; }\n\n\n\t\tstd::vector<DefiningReasoner> findDefiningReasoner(const PredicateIndicator &indicator) const;\n\n\n\t\tstd::shared_ptr<Storage> getReasonerStorage(const std::shared_ptr<NamedReasoner> &reasoner);\n\n\n\t\tstd::shared_ptr<NamedReasoner> loadPlugin(const boost::property_tree::ptree &config) override;\n\n\n\t\tstd::shared_ptr<NamedReasoner>\n\t\taddPlugin(std::string_view reasonerID, PluginLanguage language, const std::shared_ptr<Reasoner> &reasoner) override;\n\n\n\t\tstatic TokenBufferPtr evaluateQuery(\n\t\t\t\tconst GoalDrivenReasonerPtr &reasoner,\n\t\t\t\tconst std::vector<FirstOrderLiteralPtr> &literals,\n\t\t\t\tconst QueryContextPtr &ctx);\n\n\tprivate:\n\t\tKnowledgeBase *kb_;\n\t\tstd::shared_ptr<StorageManager> backendManager_;\n\n\t\tstd::map<std::string_view, StoragePtr, std::less<>> reasonerBackends_;\n\t\tstd::map<std::string_view, DataDrivenReasonerPtr> dataDriven_;\n\t\tstd::map<std::string_view, GoalDrivenReasonerPtr> goalDriven_;\n\n\t\tvoid setReasonerStorage(const std::shared_ptr<NamedPlugin<Reasoner>> &plugin, const std::shared_ptr<Storage> &dataBackend);\n\n\t\tvoid initPlugin(const std::shared_ptr<NamedReasoner> &namedReasoner);\n\n\t\tstatic bool initializeReasoner(const std::shared_ptr<NamedReasoner> &namedReasoner, PropertyTree &config);\n\t};\n}\n\n\n\n\n#define KNOWROB_BUILTIN_REASONER(Name, Type) class Type ## _Registration{ static bool isRegistered; }; \\\n        bool Type ## _Registration::isRegistered = knowrob::PluginManager<knowrob::Reasoner>::addFactory<Type>(Name);\n\n#endif\n\n'knowrob/include/knowrob/queries/NegationStage.h'\n:\n\n#ifndef KNOWROB_NEGATION_STAGE_H\n#define KNOWROB_NEGATION_STAGE_H\n\n#include \"knowrob/semweb/TriplePattern.h\"\n#include \"knowrob/reasoner/ReasonerManager.h\"\n#include \"knowrob/KnowledgeBase.h\"\n#include \"knowrob/formulas/ModalFormula.h\"\n#include \"AnswerYes.h\"\n\nnamespace knowrob {\n\n\tclass NegationStage : public TokenBroadcaster {\n\tpublic:\n\t\tNegationStage(const std::shared_ptr<KnowledgeBase> &kb, QueryContextPtr ctx);\n\n\tprotected:\n\t\tstd::shared_ptr<KnowledgeBase> kb_;\n\t\tconst QueryContextPtr ctx_;\n\n\t\tvoid pushToBroadcast(const TokenPtr &tok) override;\n\n\t\tvirtual bool succeeds(const AnswerYesPtr &answer) = 0;\n\t};\n\n\tclass PredicateNegationStage : public NegationStage {\n\tpublic:\n\t\tPredicateNegationStage(const std::shared_ptr<KnowledgeBase> &kb,\n\t\t\t\t\t\t\t   const QueryContextPtr &ctx,\n\t\t\t\t\t\t\t   const std::vector<FirstOrderLiteralPtr> &negatedLiterals);\n\n\tprotected:\n\t\tconst std::vector<FirstOrderLiteralPtr> negatedLiterals_;\n\n\t\tbool succeeds(const AnswerYesPtr &answer) override;\n\t};\n\n\tclass ModalNegationStage : public NegationStage {\n\tpublic:\n\t\tModalNegationStage(const std::shared_ptr<KnowledgeBase> &kb,\n\t\t\t\t\t\t   const QueryContextPtr &ctx,\n\t\t\t\t\t\t   const std::vector<std::shared_ptr<ModalFormula>> &negatedModals);\n\n\tprotected:\n\t\tconst std::vector<std::shared_ptr<ModalFormula>> negatedModals_;\n\n\t\tbool succeeds(const AnswerYesPtr &answer) override;\n\t};\n\n}\n\n#endif\n",
        "gt": [
            "'knowrob/include/knowrob/reasoner/ReasonerManager.h'",
            "'knowrob/include/knowrob/queries/NegationStage.h'",
            "'knowrob/src/queries/NegationStage.cpp'"
        ]
    },
    {
        "files": [
            "'Vis/Externals/Spdlog/include/spdlog/details/backtracer-inl.h'",
            "'Vis/Externals/Spdlog/include/spdlog/details/log_msg_buffer.h'",
            "'Vis/Externals/Spdlog/include/spdlog/details/backtracer.h'"
        ],
        "content": "'Vis/Externals/Spdlog/include/spdlog/details/backtracer-inl.h'\n:\n\n\n#pragma once\n\n#ifndef SPDLOG_HEADER_ONLY\n#include <spdlog/details/backtracer.h>\n#endif\nnamespace spdlog {\nnamespace details {\nSPDLOG_INLINE backtracer::backtracer(const backtracer &other)\n{\n    std::lock_guard<std::mutex> lock(other.mutex_);\n    enabled_ = other.enabled();\n    messages_ = other.messages_;\n}\n\nSPDLOG_INLINE backtracer::backtracer(backtracer &&other) SPDLOG_NOEXCEPT\n{\n    std::lock_guard<std::mutex> lock(other.mutex_);\n    enabled_ = other.enabled();\n    messages_ = std::move(other.messages_);\n}\n\nSPDLOG_INLINE backtracer &backtracer::operator=(backtracer other)\n{\n    std::lock_guard<std::mutex> lock(mutex_);\n    enabled_ = other.enabled();\n    messages_ = std::move(other.messages_);\n    return *this;\n}\n\nSPDLOG_INLINE void backtracer::enable(size_t size)\n{\n    std::lock_guard<std::mutex> lock{mutex_};\n    enabled_.store(true, std::memory_order_relaxed);\n    messages_ = circular_q<log_msg_buffer>{size};\n}\n\nSPDLOG_INLINE void backtracer::disable()\n{\n    std::lock_guard<std::mutex> lock{mutex_};\n    enabled_.store(false, std::memory_order_relaxed);\n}\n\nSPDLOG_INLINE bool backtracer::enabled() const\n{\n    return enabled_.load(std::memory_order_relaxed);\n}\n\nSPDLOG_INLINE void backtracer::push_back(const log_msg &msg)\n{\n    std::lock_guard<std::mutex> lock{mutex_};\n    messages_.push_back(log_msg_buffer{msg});\n}\n\n\nSPDLOG_INLINE void backtracer::foreach_pop(std::function<void(const details::log_msg &)> fun)\n{\n    std::lock_guard<std::mutex> lock{mutex_};\n    while (!messages_.empty())\n    {\n        auto &front_msg = messages_.front();\n        fun(front_msg);\n        messages_.pop_front();\n    }\n}\n}\n}\n\n'Vis/Externals/Spdlog/include/spdlog/details/log_msg_buffer.h'\n:\n\n\n#pragma once\n\n#include <spdlog/details/log_msg.h>\n\nnamespace spdlog {\nnamespace details {\n\n\n\n\nclass log_msg_buffer : public log_msg\n{\n    memory_buf_t buffer;\n    void update_string_views();\n\npublic:\n    log_msg_buffer() = default;\n    explicit log_msg_buffer(const log_msg &orig_msg);\n    log_msg_buffer(const log_msg_buffer &other);\n    log_msg_buffer(log_msg_buffer &&other) SPDLOG_NOEXCEPT;\n    log_msg_buffer &operator=(const log_msg_buffer &other);\n    log_msg_buffer &operator=(log_msg_buffer &&other) SPDLOG_NOEXCEPT;\n};\n\n}\n}\n\n#ifdef SPDLOG_HEADER_ONLY\n#include \"log_msg_buffer-inl.h\"\n#endif\n\n'Vis/Externals/Spdlog/include/spdlog/details/backtracer.h'\n:\n\n\n#pragma once\n\n#include <spdlog/details/log_msg_buffer.h>\n#include <spdlog/details/circular_q.h>\n\n#include <atomic>\n#include <mutex>\n#include <functional>\n\n\n\n\nnamespace spdlog {\nnamespace details {\nclass backtracer\n{\n    mutable std::mutex mutex_;\n    std::atomic<bool> enabled_{false};\n    circular_q<log_msg_buffer> messages_;\n\npublic:\n    backtracer() = default;\n    backtracer(const backtracer &other);\n\n    backtracer(backtracer &&other) SPDLOG_NOEXCEPT;\n    backtracer &operator=(backtracer other);\n\n    void enable(size_t size);\n    void disable();\n    bool enabled() const;\n    void push_back(const log_msg &msg);\n\n\n    void foreach_pop(std::function<void(const details::log_msg &)> fun);\n};\n\n}\n}\n\n#ifdef SPDLOG_HEADER_ONLY\n#include \"backtracer-inl.h\"\n#endif",
        "gt": [
            "'Vis/Externals/Spdlog/include/spdlog/details/log_msg_buffer.h'",
            "'Vis/Externals/Spdlog/include/spdlog/details/backtracer.h'",
            "'Vis/Externals/Spdlog/include/spdlog/details/backtracer-inl.h'"
        ]
    },
    {
        "files": [
            "'deepdrive-sim/Plugins/DeepDrivePlugin/Source/DeepDrivePlugin/Private/Simulation/Traffic/BehaviorTree/Decorators/DeepDriveTBTCheckFlagDecorator.h'",
            "'deepdrive-sim/Plugins/DeepDrivePlugin/Source/DeepDrivePlugin/Private/Simulation/Traffic/BehaviorTree/Creators/DeepDriveJunctionTurnGiveWayStrictBTCreator.cpp'",
            "'deepdrive-sim/Plugins/DeepDrivePlugin/Source/DeepDrivePlugin/Private/Simulation/Traffic/BehaviorTree/DeepDriveTBTDecoratorBase.h'"
        ],
        "content": "'deepdrive-sim/Plugins/DeepDrivePlugin/Source/DeepDrivePlugin/Private/Simulation/Traffic/BehaviorTree/Decorators/DeepDriveTBTCheckFlagDecorator.h'\n:\n#pragma once\n\n#include \"Simulation/Traffic/BehaviorTree/DeepDriveTBTDecoratorBase.h\"\n#include \"Simulation/TrafficLight/DeepDriveTrafficLight.h\"\n\nclass DeepDriveTBTCheckFlagDecorator\t:\tpublic\tDeepDriveTBTDecoratorBase\n{\npublic:\n\n\tDeepDriveTBTCheckFlagDecorator(const FString &flagName, bool refValue, bool defaultValue);\n\n\tvirtual ~DeepDriveTBTCheckFlagDecorator()\t{\t}\n\n\tvirtual bool performCheck(DeepDriveTrafficBlackboard &blackboard, int32 pathPointIndex) const;\n\nprivate:\n\n\tFString\t\t\t\tm_FlagName;\n\tbool\t\t\t\tm_RefValue;\n\tbool\t\t\t\tm_DefaultValue;\n};\n\n'deepdrive-sim/Plugins/DeepDrivePlugin/Source/DeepDrivePlugin/Private/Simulation/Traffic/BehaviorTree/Creators/DeepDriveJunctionTurnGiveWayStrictBTCreator.cpp'\n:\n#include \"Simulation/Traffic/BehaviorTree/Creators/DeepDriveJunctionTurnGiveWayStrictBTCreator.h\"\n\n#include \"Private/Simulation/Traffic/Path/DeepDrivePathDefines.h\"\n\n#include \"Simulation/Traffic/BehaviorTree/DeepDriveTrafficBehaviorTree.h\"\n#include \"Simulation/Traffic/BehaviorTree/DeepDriveTrafficBehaviorTreeNode.h\"\n#include \"Simulation/Traffic/BehaviorTree/DeepDriveTrafficBlackboard.h\"\n\n#include \"Simulation/Traffic/BehaviorTree/Tasks/DeepDriveTBTStopAtLocationTask.h\"\n#include \"Simulation/Traffic/BehaviorTree/Tasks/DeepDriveTBTWaitTask.h\"\n#include \"Simulation/Traffic/BehaviorTree/Tasks/DeepDriveTBTStopTask.h\"\n#include \"Simulation/Traffic/BehaviorTree/Tasks/DeepDriveTBTCheckIsJunctionClearTask.h\"\n\n#include \"Simulation/Traffic/BehaviorTree/Decorators/DeepDriveTBTCheckFlagDecorator.h\"\n\n#include \"Simulation/Traffic/BehaviorTree/DeepDriveBehaviorTreeFactory.h\"\n\nbool DeepDriveJunctionTurnGiveWayStrictBTCreator::s_isRegistered = DeepDriveJunctionTurnGiveWayStrictBTCreator::registerCreator();\n\nbool DeepDriveJunctionTurnGiveWayStrictBTCreator::registerCreator()\n{\n\tDeepDriveBehaviorTreeFactory &factory = DeepDriveBehaviorTreeFactory::GetInstance();\n\tfactory.registerCreator(\"four_way_stop\", &DeepDriveJunctionTurnGiveWayStrictBTCreator::createBehaviorTree);\n\treturn true;\n}\n\nDeepDriveTrafficBehaviorTree* DeepDriveJunctionTurnGiveWayStrictBTCreator::createBehaviorTree()\n{\n\tDeepDriveTrafficBehaviorTree *behaviorTree = new DeepDriveTrafficBehaviorTree();\n\tif (behaviorTree)\n\t{\n\t\tDeepDriveTrafficBehaviorTreeNode *stopAtNode = behaviorTree->createNode(0);\n\t\tDeepDriveTrafficBehaviorTreeNode *waitNode = behaviorTree->createNode(0);\n\t\tDeepDriveTrafficBehaviorTreeNode *waitUntilClearNode = behaviorTree->createNode(0);\n\n\t\tbehaviorTree->getRootNode()->addDecorator( new DeepDriveTBTCheckFlagDecorator(\"IsJunctionClear\", false, false) );\n\n\t\tstopAtNode->addTask(new DeepDriveTBTStopAtLocationTask(\"StopLineLocation\", 0.6f));\n\n\t\twaitNode->addTask(new DeepDriveTBTStopTask);\n\t\twaitNode->addTask(new DeepDriveTBTWaitTask(3.0f));\n\n\t\twaitUntilClearNode->addTask(new DeepDriveTBTStopTask);\n\t\twaitUntilClearNode->addTask(new DeepDriveTBTCheckIsJunctionClearTask(\"StopLineLocation\", 1500.0f, true, \"IsJunctionClear\") );\n\t}\n\n\treturn behaviorTree;\n}\n\n'deepdrive-sim/Plugins/DeepDrivePlugin/Source/DeepDrivePlugin/Private/Simulation/Traffic/BehaviorTree/DeepDriveTBTDecoratorBase.h'\n:\n#pragma once\n\n#include \"CoreMinimal.h\"\n\nclass DeepDriveTrafficBlackboard;\nclass DeepDrivePartialPath;\n\nclass DeepDriveTBTDecoratorBase\n{\npublic:\n\n\tvirtual ~DeepDriveTBTDecoratorBase()\n\t{\n\t}\n\n\tvirtual void bind(DeepDriveTrafficBlackboard &blackboard, DeepDrivePartialPath &path)\n\t{\n\t}\n\n\tvirtual bool performCheck(DeepDriveTrafficBlackboard &blackboard, int32 pathPointIndex) const = 0;\n};\n",
        "gt": [
            "'deepdrive-sim/Plugins/DeepDrivePlugin/Source/DeepDrivePlugin/Private/Simulation/Traffic/BehaviorTree/DeepDriveTBTDecoratorBase.h'",
            "'deepdrive-sim/Plugins/DeepDrivePlugin/Source/DeepDrivePlugin/Private/Simulation/Traffic/BehaviorTree/Decorators/DeepDriveTBTCheckFlagDecorator.h'",
            "'deepdrive-sim/Plugins/DeepDrivePlugin/Source/DeepDrivePlugin/Private/Simulation/Traffic/BehaviorTree/Creators/DeepDriveJunctionTurnGiveWayStrictBTCreator.cpp'"
        ]
    },
    {
        "files": [
            "'webpp/webpp/std/vector.hpp'",
            "'webpp/sdk/wsdk/cmds/command.hpp'",
            "'webpp/sdk/wpp/main.cpp'",
            "'webpp/webpp/std/std.hpp'"
        ],
        "content": "'webpp/webpp/std/vector.hpp'\n:\n\n#ifndef WEBPP_VECTOR_H\n#define WEBPP_VECTOR_H\n\n#include \"../traits/default_traits.hpp\"\n#include \"std.hpp\"\n\n#include <vector>\n\n\nnamespace webpp::istl {\n\n    template <typename T,\n              Traits TraitsType  = default_traits,\n              typename Allocator = traits::allocator_type_of<TraitsType, T>>\n    using vector = stl::vector<T, Allocator>;\n\n}\n\n#endif\n\n'webpp/sdk/wsdk/cmds/command.hpp'\n:#ifndef WEBPP_SDK_CMDS_CMD\n#define WEBPP_SDK_CMDS_CMD\n\n#include \"command_options.hpp\"\n\n#include <webpp/logs/dynamic_logger.hpp>\n#include <webpp/std/string_view.hpp>\n#include <webpp/std/vector.hpp>\n\nnamespace webpp::sdk {\n\n    enum struct command_status {\n\n        success,\n        empty_command,\n\n\n        unknown_error,\n        invalid_command\n    };\n\n\n    stl::string_view to_string(command_status status) noexcept;\n    int              to_exit_status(command_status) noexcept;\n\n    struct command {\n        command()                                   = default;\n        command(command const&)                     = delete;\n        command(command&&) noexcept                 = default;\n        command& operator=(command const&) noexcept = delete;\n        command& operator=(command&&) noexcept      = default;\n        virtual ~command()                          = default;\n\n\n        [[nodiscard]] virtual stl::string_view name() const noexcept = 0;\n\n\n        [[nodiscard]] virtual stl::string_view desc() const noexcept = 0;\n\n\n        virtual command_status start(command_options) = 0;\n    };\n\n\n    struct command_manager {\n        command_manager(stl::shared_ptr<output_port> inp_output = stl::make_shared<stdout_output_port>(),\n                        dynamic_logger               logger     = {});\n        command_manager(command_manager&&) noexcept            = default;\n        command_manager(command_manager const&)                = delete;\n        command_manager& operator=(command_manager&&) noexcept = default;\n        command_manager& operator=(command_manager const&)     = delete;\n        ~command_manager()                                     = default;\n\n\n        command_status run_command(int argc, char const** argv);\n\n\n        command_status run_command(stl::string_view);\n\n      private:\n        stl::shared_ptr<output_port> output;\n        dynamic_logger               logger;\n    };\n\n}\n\n\n#endif\n\n'webpp/sdk/wpp/main.cpp'\n:#include <webpp/logs/dynamic_logger.hpp>\n#include <webpp/std/utility.hpp>\n#include <wsdk/cmds/command.hpp>\n\ninline constexpr auto log_cat = \"main\";\n\nauto main(int argc, char const** argv) -> int {\n    using namespace webpp::sdk;\n\n    webpp::dynamic_logger const               logger;\n    webpp::stl::shared_ptr<output_port> const output = webpp::stl::make_shared<stdout_output_port>();\n    try {\n        command_manager manager{output, logger};\n        auto const      cmd_res = manager.run_command(argc, argv);\n        logger.info(log_cat, to_string(cmd_res));\n        return to_exit_status(cmd_res);\n    } catch (std::exception const& ex) {\n        logger.critical(log_cat, \"This exception has propagated to the top.\", ex);\n        return EXIT_FAILURE;\n    } catch (...) {\n        logger.critical(log_cat, \"This unknown error has propagated to the top.\");\n        return EXIT_FAILURE;\n    }\n}\n\n'webpp/webpp/std/std.hpp'\n:\n\n#ifndef WEBPP_STD_STD_H\n#define WEBPP_STD_STD_H\n\n#define STLLIB_STANDARD         0\n#define STLLIB_EXPERIMENTAL     1\n#define STLLIB_BOOST            2\n#define STLLIB_NETWORKING_ERROR \"We don't even have access to networking TS.\"\n#define BOOST_ASIO_NO_DEPRECATED\n\n#if __has_include(<version>)\n#    include <version>\n#endif\n\nnamespace webpp::stl {\n    using namespace ::std;\n}\n\n#endif\n",
        "gt": [
            "'webpp/webpp/std/std.hpp'",
            "'webpp/webpp/std/vector.hpp'",
            "'webpp/sdk/wsdk/cmds/command.hpp'",
            "'webpp/sdk/wpp/main.cpp'"
        ]
    },
    {
        "files": [
            "'egoboo/egolib/library/src/egolib/game/GUI/MessageLog.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/DrawingContext.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/Component.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/MessageLog.cpp'"
        ],
        "content": "'egoboo/egolib/library/src/egolib/game/GUI/MessageLog.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n#include \"egolib/game/GUI/Component.hpp\"\n\nnamespace Ego {\nnamespace GUI {\n\nclass MessageLog : public Component {\npublic:\n    MessageLog();\n\n    virtual void draw(DrawingContext& drawingContext) override;\n\n    void addMessage(const std::string &message);\n\nprivate:\n    static constexpr uint32_t MESSAGE_DURATION_MS = 3000;\n    static constexpr uint32_t MESSAGE_FADE_TIME_MS = 700;\n\n    struct Message {\n    public:\n        Message(const std::string& setText, uint32_t ticks) :\n            text(setText),\n            lifeTime(ticks) {\n\n        }\n\n        std::string text;\n        uint32_t lifeTime;\n    };\n\n    std::list<Message> _messages;\n};\n\n}\n}\n\n'egoboo/egolib/library/src/egolib/game/GUI/DrawingContext.hpp'\n:#pragma once\n\nnamespace Ego {\nnamespace GUI {\n\nstruct DrawingContext {\n    DrawingContext();\n    DrawingContext(bool useDerived);\n    ~DrawingContext();\n    bool useDerived;\n};\n\n}\n}\n\n'egoboo/egolib/library/src/egolib/game/GUI/Component.hpp'\n:#pragma once\n\n#include \"egolib/game/GUI/DrawingContext.hpp\"\n#include \"egolib/game/Core/GameEngine.hpp\"\n#include \"egolib/game/GUI/UIManager.hpp\"\n#include \"egolib/game/GUI/InputListener.hpp\"\n#include \"egolib/game/graphic.h\"\n\nnamespace Ego {\nnamespace GUI {\n\n\nclass Container;\n\nclass Component : public InputListener, public std::enable_shared_from_this<Component>, private idlib::non_copyable {\npublic:\n    Component();\n\n\n    virtual void draw(DrawingContext& drawingContext) = 0;\n\n\n\n    virtual bool isEnabled() const;\n\n\n    virtual void setEnabled(const bool enabled);\n\n\n\n    virtual bool isVisible() const;\n\n\n    void setVisible(const bool visible);\n\n\n\n    Rectangle2f getDerivedBounds() const;\n\n\n    const Rectangle2f& getBounds() const;\n\n\n    virtual void setSize(const Vector2f& size);\n\n\n    virtual void setPosition(const Point2f& position);\n\n    Point2f getPosition() const;\n    Vector2f getSize() const;\n    float getX() const;\n    float getY() const;\n    float getWidth() const;\n    float getHeight() const;\n\n    void setCenterPosition(const Point2f& position, const bool onlyHorizontal = false);\n    virtual void setWidth(float width);\n    virtual void setHeight(float height);\n\n    virtual void setX(float x);\n    virtual void setY(float y);\n\n\n\n    bool contains(const Point2f& point) const;\n\n\n\n    void setParent(Container *parent);\n\n\n\n    Container *getParent() const;\n\n\n\n    Point2f getDerivedPosition() const;\n\n\n    operator std::shared_ptr<Component>() { return shared_from_this(); }\n\n    void destroy();\n    bool isDestroyed() const;\n\n\n    void bringToFront();\n\nprivate:\n    bool _destroyed;\n    Rectangle2f _bounds;\n    bool _enabled;\n    bool _visible;\n    Container *_parent;\n};\n\n}\n}\n\n'egoboo/egolib/library/src/egolib/game/GUI/MessageLog.cpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"egolib/game/GUI/MessageLog.hpp\"\n#include \"egolib/font_bmp.h\"\n\nnamespace Ego {\nnamespace GUI {\n\nMessageLog::MessageLog() :\n    _messages() {}\n\nvoid MessageLog::draw(DrawingContext& drawingContext) {\n    float yOffset = getY();\n\n\n    _messages.remove_if([this, &yOffset](Message& message) {\n        const int millisRemaining = static_cast<int64_t>(message.lifeTime) - Core::System::get().getSystemService().getTicks();\n        if (millisRemaining <= 0) return true;\n        yOffset = _gameEngine->getUIManager()->drawBitmapFontString(Vector2f(getX(), yOffset), message.text, 0, millisRemaining > MESSAGE_FADE_TIME_MS ? 1.0f : millisRemaining / static_cast<float>(MESSAGE_FADE_TIME_MS));\n        return Core::System::get().getSystemService().getTicks() > message.lifeTime;\n    });\n}\n\nvoid MessageLog::addMessage(const std::string &message) {\n\n    _messages.emplace_back(message, Core::System::get().getSystemService().getTicks() + egoboo_config_t::get().hud_messageDuration.getValue() * 10);\n\n\n    while (_messages.size() > egoboo_config_t::get().hud_simultaneousMessages_max.getValue()) {\n        _messages.pop_front();\n    }\n}\n\n}\n}\n",
        "gt": [
            "'egoboo/egolib/library/src/egolib/game/GUI/DrawingContext.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/Component.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/MessageLog.hpp'",
            "'egoboo/egolib/library/src/egolib/game/GUI/MessageLog.cpp'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/VDEX.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/Method.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/CodeInfo.hpp'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'\n:\n#ifndef LIEF_MAIN_HEADER_H\n#define LIEF_MAIN_HEADER_H\n#include <LIEF/config.h>\n\n#include <LIEF/Abstract.hpp>\n\n#include <LIEF/OAT.hpp>\n#include <LIEF/VDEX.hpp>\n#include <LIEF/ART.hpp>\n#include <LIEF/DEX.hpp>\n#include <LIEF/ELF.hpp>\n#include <LIEF/PE.hpp>\n#include <LIEF/MachO.hpp>\n#include <LIEF/DWARF.hpp>\n#include <LIEF/logging.hpp>\n#include <LIEF/platforms.hpp>\n\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'\n:\n#ifndef LIEF_DEX_H\n#define LIEF_DEX_H\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_DEX_SUPPORT)\n#include \"LIEF/DEX/Parser.hpp\"\n#include \"LIEF/DEX/utils.hpp\"\n#include \"LIEF/DEX/File.hpp\"\n#include \"LIEF/DEX/Class.hpp\"\n#include \"LIEF/DEX/Prototype.hpp\"\n#include \"LIEF/DEX/Header.hpp\"\n#include \"LIEF/DEX/Method.hpp\"\n#include \"LIEF/DEX/Field.hpp\"\n#include \"LIEF/DEX/EnumToString.hpp\"\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/VDEX.hpp'\n:\n#ifndef LIEF_VDEX_H\n#define LIEF_VDEX_H\n\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_VDEX_SUPPORT)\n#if !defined(LIEF_DEX_SUPPORT)\n#error \"The VDEX module can't be used without the DEX support\"\n#endif\n#include \"LIEF/DEX.hpp\"\n#include \"LIEF/VDEX/Parser.hpp\"\n#include \"LIEF/VDEX/utils.hpp\"\n#include \"LIEF/VDEX/File.hpp\"\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/Method.hpp'\n:\n#ifndef LIEF_DEX_METHOD_H\n#define LIEF_DEX_METHOD_H\n\n#include <climits>\n#include <vector>\n\n#include \"LIEF/visibility.h\"\n#include \"LIEF/Object.hpp\"\n\n#include \"LIEF/DEX/enums.hpp\"\n#include \"LIEF/DEX/CodeInfo.hpp\"\n#include \"LIEF/DEX/deopt.hpp\"\n\nnamespace LIEF {\nnamespace DEX {\nclass Parser;\nclass Class;\nclass Prototype;\n\n\nclass LIEF_API Method : public Object {\n  friend class Parser;\n  public:\n  using access_flags_list_t = std::vector<ACCESS_FLAGS>;\n\n  public:\n  using bytecode_t = std::vector<uint8_t>;\n  Method();\n  Method(std::string name, Class* parent = nullptr);\n\n  Method(const Method&);\n  Method& operator=(const Method&);\n\n\n  const std::string& name() const;\n\n\n  bool has_class() const;\n\n\n\n  const Class* cls() const;\n  Class* cls();\n\n\n  uint64_t code_offset() const;\n\n\n  const bytecode_t& bytecode() const;\n\n\n  size_t index() const;\n\n\n\n  bool is_virtual() const;\n\n\n  const Prototype* prototype() const;\n  Prototype* prototype();\n\n  void insert_dex2dex_info(uint32_t pc, uint32_t index);\n\n  void accept(Visitor& visitor) const override;\n\n  const dex2dex_method_info_t& dex2dex_info() const;\n\n\n  bool has(ACCESS_FLAGS f) const;\n\n\n  access_flags_list_t access_flags() const;\n\n  bool operator==(const Method& rhs) const;\n  bool operator!=(const Method& rhs) const;\n\n  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Method& mtd);\n\n  virtual ~Method();\n\n  private:\n  void set_virtual(bool v);\n\n  private:\n  std::string name_;\n  Class* parent_ = nullptr;\n  Prototype* prototype_ = nullptr;\n  uint32_t access_flags_ = ACCESS_FLAGS::ACC_UNKNOWN;\n  uint32_t original_index_ = UINT_MAX;\n  bool is_virtual_ = false;\n\n  uint64_t code_offset_ = 0;\n  std::vector<uint8_t> bytecode_;\n\n  CodeInfo code_info_;\n\n  dex2dex_method_info_t dex2dex_info_;\n\n};\n\n}\n}\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/CodeInfo.hpp'\n:\n#ifndef LIEF_DEX_CODE_INFO_H\n#define LIEF_DEX_CODE_INFO_H\n\n#include <cstdint>\n#include <ostream>\n\n#include \"LIEF/visibility.h\"\n#include \"LIEF/Object.hpp\"\n\nnamespace LIEF {\nnamespace DEX {\nnamespace details {\nstruct code_item;\n}\n\nclass Parser;\n\nclass LIEF_API CodeInfo : public Object {\n  friend class Parser;\n\n  public:\n  CodeInfo();\n  CodeInfo(const details::code_item& codeitem);\n\n  CodeInfo(const CodeInfo&);\n  CodeInfo& operator=(const CodeInfo&);\n\n  void accept(Visitor& visitor) const override;\n\n  bool operator==(const CodeInfo& rhs) const;\n  bool operator!=(const CodeInfo& rhs) const;\n\n  virtual ~CodeInfo();\n\n  LIEF_API friend std::ostream& operator<<(std::ostream& os, const CodeInfo& cinfo);\n\n  private:\n  uint16_t nb_registers_ = 0;\n  uint16_t args_input_sizes_ = 0;\n  uint16_t output_sizes_ = 0;\n\n};\n\n}\n}\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/CodeInfo.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/Method.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/VDEX.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/MonitoredItemServiceConfig.cpp'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/MonitoredItemServiceConfig.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/MonitoredItemService.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/MonitoredItemServiceTransaction.h'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackClient/ServiceSet/MonitoredItemServiceConfig.cpp'\n:\n\n\n#include \"OpcUaStackCore/Base/Log.h\"\n#include \"OpcUaStackClient/ServiceSet/MonitoredItemServiceConfig.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackClient\n{\n\n\n\n\n\n\n\n\n\tMonitoredItemServiceConfig::MonitoredItemServiceConfig(void)\n\t: ServiceConfigBase(\"MonitoredItem\")\n\t, monitoredItemServiceIf_(nullptr)\n\t{\n\t}\n\n\tMonitoredItemServiceConfig::~MonitoredItemServiceConfig(void)\n\t{\n\t}\n\n}\n\n\n'OpcUaStack/src/OpcUaStackClient/ServiceSet/MonitoredItemServiceConfig.h'\n:\n#ifndef __OpcUaStackClient_MonitoredItemServiceConfig_h__\n#define __OpcUaStackClient_MonitoredItemServiceConfig_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Utility/IOThread.h\"\n#include \"OpcUaStackClient/ServiceSet/MonitoredItemService.h\"\n#include \"OpcUaStackClient/ServiceSet/ServiceConfigBase.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackClient\n{\n\n\tclass DLLEXPORT MonitoredItemServiceConfig\n\t: public ServiceConfigBase\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<MonitoredItemServiceConfig> SPtr;\n\n\t\tMonitoredItemServiceConfig(void);\n\t\tvirtual ~MonitoredItemServiceConfig(void);\n\n\t\tMonitoredItemServiceIf* monitoredItemServiceIf_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackClient/ServiceSet/MonitoredItemService.h'\n:\n\n#ifndef __OpcUaStackClient_MonitoredItemService_h__\n#define __OpcUaStackClient_MonitoredItemService_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Component/Component.h\"\n#include \"OpcUaStackCore/ServiceSet/MonitoredItemServiceTransaction.h\"\n#include \"OpcUaStackClient/ServiceSet/MonitoredItemServiceIf.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackClient\n{\n\tclass DLLEXPORT MonitoredItemService\n\t: public Component\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<MonitoredItemService> SPtr;\n\n\t\tMonitoredItemService(IOThread* ioThread);\n\t\t~MonitoredItemService(void);\n\n\t\tvoid setConfiguration(\n\t\t\tComponent* componentSession,\n\t\t\tMonitoredItemServiceIf* monitoredItemServiceIf\n\t\t);\n\t\tvoid componentSession(Component* componentSession);\n\t\tvoid monitoredItemServiceIf(MonitoredItemServiceIf* monitoredItemServiceIf);\n\n\t\tvoid syncSend(ServiceTransactionCreateMonitoredItems::SPtr serviceTransactionCreateMonitoredItems);\n\t\tvoid asyncSend(ServiceTransactionCreateMonitoredItems::SPtr serviceTransactionCreateMonitoredItems);\n\t\tvoid syncSend(ServiceTransactionDeleteMonitoredItems::SPtr serviceTransactionDeleteMonitoredItems);\n\t\tvoid asyncSend(ServiceTransactionDeleteMonitoredItems::SPtr serviceTransactionDeleteMonitoredItems);\n\t\tvoid syncSend(ServiceTransactionModifyMonitoredItems::SPtr serviceTransactionModifyMonitoredItems);\n\t\tvoid asyncSend(ServiceTransactionModifyMonitoredItems::SPtr serviceTransactionModifyMonitoredItems);\n\t\tvoid syncSend(ServiceTransactionSetMonitoringMode::SPtr serviceTransactionSetMonitoringMode);\n\t\tvoid asyncSend(ServiceTransactionSetMonitoringMode::SPtr serviceTransactionSetMonitoringMode);\n\t\tvoid syncSend(ServiceTransactionSetTriggering::SPtr serviceTransactionSetTriggering);\n\t\tvoid asyncSend(ServiceTransactionSetTriggering::SPtr serviceTransactionSetTriggering);\n\n\n\t\tvoid receive(Message::SPtr message);\n\n\n\t  private:\n\t\tComponent* componentSession_;\n\n\t\tMonitoredItemServiceIf* monitoredItemServiceIf_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/MonitoredItemServiceTransaction.h'\n:\n\n#ifndef __OpcUaStackCore_MonitoredItemServiceTransaction_h__\n#define __OpcUaStackCore_MonitoredItemServiceTransaction_h__\n\n#include \"OpcUaStackCore/BuildInTypes/OpcUaIdentifier.h\"\n#include \"OpcUaStackCore/ServiceSet/ServiceTransactionTemplate.h\"\n#include \"OpcUaStackCore/ServiceSet/CreateMonitoredItemsRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/CreateMonitoredItemsResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/DeleteMonitoredItemsRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/DeleteMonitoredItemsResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/ModifyMonitoredItemsRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/ModifyMonitoredItemsResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/SetMonitoringModeRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/SetMonitoringModeResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/SetTriggeringRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/SetTriggeringResponse.h\"\n\n\nnamespace OpcUaStackCore\n{\n\n\ttypedef ServiceTransactionTemplate<\n\t\tCreateMonitoredItemsRequest,\n\t\tCreateMonitoredItemsResponse,\n\t\tOpcUaId_CreateMonitoredItemsRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_CreateMonitoredItemsResponse_Encoding_DefaultBinary\n\t> ServiceTransactionCreateMonitoredItems;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tDeleteMonitoredItemsRequest,\n\t\tDeleteMonitoredItemsResponse,\n\t\tOpcUaId_DeleteMonitoredItemsRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_DeleteMonitoredItemsResponse_Encoding_DefaultBinary\n\t> ServiceTransactionDeleteMonitoredItems;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tModifyMonitoredItemsRequest,\n\t\tModifyMonitoredItemsResponse,\n\t\tOpcUaId_ModifyMonitoredItemsRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_ModifyMonitoredItemsResponse_Encoding_DefaultBinary\n\t> ServiceTransactionModifyMonitoredItems;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tSetMonitoringModeRequest,\n\t\tSetMonitoringModeResponse,\n\t\tOpcUaId_SetMonitoringModeRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_SetMonitoringModeResponse_Encoding_DefaultBinary\n\t> ServiceTransactionSetMonitoringMode;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tSetTriggeringRequest,\n\t\tSetTriggeringResponse,\n\t\tOpcUaId_SetTriggeringRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_SetTriggeringResponse_Encoding_DefaultBinary\n\t> ServiceTransactionSetTriggering;\n\n}\n\n#endif\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/MonitoredItemServiceTransaction.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/MonitoredItemService.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/MonitoredItemServiceConfig.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/MonitoredItemServiceConfig.cpp'"
        ]
    },
    {
        "files": [
            "'knowrob/include/knowrob/reasoner/swrl/SWRLReasoner.h'",
            "'knowrob/include/knowrob/reasoner/GoalDrivenReasoner.h'",
            "'knowrob/src/reasoner/Computable.cpp'",
            "'knowrob/include/knowrob/reasoner/Computable.h'"
        ],
        "content": "'knowrob/include/knowrob/reasoner/swrl/SWRLReasoner.h'\n:\n\n#ifndef KNOWROB_SWRL_REASONER_H\n#define KNOWROB_SWRL_REASONER_H\n\n\n#include <knowrob/reasoner/prolog/PrologReasoner.h>\n\nnamespace knowrob {\n\n\tclass SWRLReasoner : public PrologReasoner {\n\tpublic:\n\t\tstatic const std::string SWRL_FORMAT;\n\n\t\tSWRLReasoner();\n\n\t\tbool loadSWRLFile(const DataSourcePtr &dataFile);\n\n\n\t\tvoid unload() override;\n\n\tprotected:\n\n\t\tbool initializeDefaultPackages() override;\n\t};\n\n}\n\n#endif\n\n'knowrob/include/knowrob/reasoner/GoalDrivenReasoner.h'\n:\n\n#ifndef KNOWROB_GOAL_DRIVEN_REASONER_H\n#define KNOWROB_GOAL_DRIVEN_REASONER_H\n\n#include \"Reasoner.h\"\n#include \"Goal.h\"\n#include \"knowrob/formulas/PredicateIndicator.h\"\n\nnamespace knowrob {\n\n\tenum class GoalDrivenReasonerFeature {\n\n\t\tSupportsSimpleConjunctions = 0x01,\n\n\t\tSupportsExtensionalGrounding = 0x02,\n\t};\n\n\n\tclass GoalDrivenReasoner : public Reasoner {\n\tpublic:\n\t\tGoalDrivenReasoner() : Reasoner(), features_(0) {}\n\n\n\t\tbool hasFeature(GoalDrivenReasonerFeature feature) const;\n\n\n\t\tvoid enableFeature(GoalDrivenReasonerFeature feature);\n\n\n\t\tbool isRelationDefined(const PredicateIndicator &indicator);\n\n\n\t\tbool isClassDefined(const std::string_view &iri);\n\n\n\t\tvoid defineRelation(const PredicateIndicator &indicator);\n\n\n\t\tvoid defineRelation(const IRIAtomPtr &iri);\n\n\n\t\tvoid undefineRelation(const PredicateIndicator &indicator);\n\n\n\t\tvoid defineClass(const IRIAtomPtr &iri);\n\n\n\t\tvoid undefineClass(const IRIAtomPtr &iri);\n\n\n\t\tconst auto &definedRelations() const { return definedRelations_; }\n\n\n\t\tconst auto &definedClasses() const { return definedClasses_; }\n\n\n\t\tvirtual bool evaluate(GoalPtr query) = 0;\n\n\tprotected:\n\t\tstd::set<PredicateIndicator> definedRelations_;\n\t\tstd::set<PredicateIndicator> definedClasses_;\n\t\tint features_;\n\t};\n\n\n\tclass ReasonerRunner : public ThreadPool::Runner {\n\tpublic:\n\t\tstd::shared_ptr<GoalDrivenReasoner> reasoner;\n\t\tstd::shared_ptr<Goal> query;\n\n\t\tReasonerRunner() = default;\n\n\n\t\tvoid run() override;\n\n\tprivate:\n\t\tvoid run_();\n\t};\n\n\tusing GoalDrivenReasonerPtr = std::shared_ptr<GoalDrivenReasoner>;\n\tusing DefiningReasoner = std::pair<GoalDrivenReasonerPtr,AtomPtr>;\n}\n\n#endif\n\n'knowrob/src/reasoner/Computable.cpp'\n:\n\n#include <knowrob/reasoner/Computable.h>\n\nusing namespace knowrob;\n\nComputable::Computable(const FirstOrderLiteral &literal, const std::vector<DefiningReasoner> &reasonerList)\n: FirstOrderLiteral(literal), reasonerList_(reasonerList) {}\n\nComputable::Computable(const PredicatePtr &predicate, bool isNegative,\n\t\t\t\t\t   const std::vector<DefiningReasoner> &reasonerList)\n: FirstOrderLiteral(predicate, isNegative), reasonerList_(reasonerList) {}\n\nnamespace knowrob {\n\tComputablePtr applyBindings(const ComputablePtr &lit, const Bindings &bindings) {\n\t\tauto predicate = std::static_pointer_cast<Predicate>(applyBindings(lit->predicate(), bindings));\n\t\tif (predicate != lit->predicate()) {\n\t\t\treturn std::make_shared<Computable>(predicate, lit->isNegated(), lit->reasonerList());\n\t\t}\n\t\telse {\n\t\t\treturn lit;\n\t\t}\n\t}\n}\n\n'knowrob/include/knowrob/reasoner/Computable.h'\n:\n\n#ifndef KNOWROB_COMPUTABLE_H\n#define KNOWROB_COMPUTABLE_H\n\n#include \"knowrob/formulas/FirstOrderLiteral.h\"\n#include \"GoalDrivenReasoner.h\"\n\nnamespace knowrob {\n\n\tclass Computable : public FirstOrderLiteral {\n\tpublic:\n\n\t\tComputable(const FirstOrderLiteral &literal,\n\t\t\t\t   const std::vector<DefiningReasoner> &reasonerList);\n\n\n\t\tComputable(const PredicatePtr &predicate, bool isNegative,\n\t\t\t\t   const std::vector<DefiningReasoner> &reasonerList);\n\n\n\t\tconst auto &reasonerList() const { return reasonerList_; }\n\n\tprotected:\n\t\tstd::vector<DefiningReasoner> reasonerList_;\n\t};\n\n\tusing ComputablePtr = std::shared_ptr<Computable>;\n\n\n\tComputablePtr applyBindings(const ComputablePtr &lit, const Bindings &bindings);\n\n}\n\n#endif\n",
        "gt": [
            "'knowrob/include/knowrob/reasoner/swrl/SWRLReasoner.h'",
            "'knowrob/include/knowrob/reasoner/GoalDrivenReasoner.h'",
            "'knowrob/include/knowrob/reasoner/Computable.h'",
            "'knowrob/src/reasoner/Computable.cpp'"
        ]
    },
    {
        "files": [
            "'Tempest/Engine/gapi/metal/mtsamplercache.cpp'",
            "'Tempest/Engine/gapi/metal/mtsamplercache.h'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLCommandQueue.hpp'"
        ],
        "content": "'Tempest/Engine/gapi/metal/mtsamplercache.cpp'\n:#if defined(TEMPEST_BUILD_METAL)\n\n#include \"mtsamplercache.h\"\n\n#include \"mtdevice.h\"\n\nusing namespace Tempest;\nusing namespace Tempest::Detail;\n\nnamespace Tempest {\nnamespace Detail  {\n\nstatic MTL::SamplerAddressMode nativeFormat(ClampMode m) {\n  switch(m) {\n    case ClampMode::ClampToBorder:  return MTL::SamplerAddressModeClampToBorderColor;\n    case ClampMode::ClampToEdge:    return MTL::SamplerAddressModeClampToEdge;\n    case ClampMode::MirroredRepeat: return MTL::SamplerAddressModeMirrorRepeat;\n    case ClampMode::Repeat:         return MTL::SamplerAddressModeRepeat;\n    case ClampMode::Count:          return MTL::SamplerAddressModeRepeat;\n    }\n  return MTL::SamplerAddressModeRepeat;\n  }\n\nstatic MTL::SamplerMinMagFilter nativeFormat(Tempest::Filter f) {\n  switch(f) {\n    case Filter::Nearest: return MTL::SamplerMinMagFilterNearest;\n    case Filter::Linear:  return MTL::SamplerMinMagFilterLinear;\n    case Filter::Count:   return MTL::SamplerMinMagFilterLinear;\n    }\n  return MTL::SamplerMinMagFilterLinear;\n  }\n}\n}\n\nMtSamplerCache::MtSamplerCache(MTL::Device& dev)\n  :dev(dev) {\n  def = mkSampler(Sampler(),false);\n  if(def==nullptr)\n    throw std::system_error(Tempest::GraphicsErrc::NoDevice);\n  }\n\nMtSamplerCache::~MtSamplerCache() {\n  }\n\nMTL::SamplerState& MtSamplerCache::get(Tempest::Sampler src, bool argBuffers) {\n  src.mapping = ComponentMapping();\n  static const Tempest::Sampler defSrc;\n  if(src==defSrc)\n    return *def;\n\n  std::lock_guard<std::mutex> guard(sync);\n  for(auto& i:values)\n    if(i.src==src && i.argBuffers==argBuffers)\n      return *i.val;\n  values.emplace_back(Entry());\n  auto& b = values.back();\n  b.src        = src;\n  b.argBuffers = argBuffers;\n  b.val        = mkSampler(src,argBuffers);\n  if(b.val==nullptr)\n    throw std::system_error(Tempest::GraphicsErrc::OutOfHostMemory);\n  return *b.val;\n  }\n\nNsPtr<MTL::SamplerState> MtSamplerCache::mkSampler(const Tempest::Sampler& src, bool argBuffers) {\n  auto desc = NsPtr<MTL::SamplerDescriptor>::init();\n  desc->setRAddressMode(nativeFormat(src.uClamp));\n  desc->setSAddressMode(nativeFormat(src.vClamp));\n  desc->setTAddressMode(nativeFormat(src.wClamp));\n\n  desc->setMinFilter(nativeFormat(src.minFilter));\n  desc->setMagFilter(nativeFormat(src.magFilter));\n  if(src.mipFilter==Filter::Nearest)\n    desc->setMipFilter(MTL::SamplerMipFilterNearest); else\n    desc->setMipFilter(MTL::SamplerMipFilterLinear);\n  desc->setMaxAnisotropy(src.anisotropic ? 16 : 1);\n  desc->setBorderColor(MTL::SamplerBorderColorOpaqueWhite);\n  desc->setLodAverage(false);\n  desc->setSupportArgumentBuffers(argBuffers);\n\n  return NsPtr<MTL::SamplerState>(dev.newSamplerState(desc.get()));\n  }\n\n#endif\n\n'Tempest/Engine/gapi/metal/mtsamplercache.h'\n:#pragma once\n\n#include <Tempest/AbstractGraphicsApi>\n#include <Metal/Metal.hpp>\n#include <mutex>\n\n#include \"nsptr.h\"\n\nnamespace Tempest {\nnamespace Detail {\n\nclass MtDevice;\n\nclass MtSamplerCache {\n  public:\n    MtSamplerCache(MTL::Device& dev);\n    ~MtSamplerCache();\n\n    MTL::SamplerState& get(Sampler src, bool argBuffers=false);\n\n  private:\n    NsPtr<MTL::SamplerState> mkSampler(const Sampler& src, bool argBuffers);\n\n    struct Entry {\n      Sampler                  src;\n      bool                     argBuffers = false;\n      NsPtr<MTL::SamplerState> val;\n      };\n\n    MTL::Device&             dev;\n    NsPtr<MTL::SamplerState> def;\n\n    std::mutex               sync;\n    std::vector<Entry>       values;\n  };\n\n}\n}\n\n'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n\n\n#include \"MTLAccelerationStructure.hpp\"\n#include \"MTLAccelerationStructureCommandEncoder.hpp\"\n#include \"MTLAccelerationStructureTypes.hpp\"\n#include \"MTLArgument.hpp\"\n#include \"MTLArgumentEncoder.hpp\"\n#include \"MTLBinaryArchive.hpp\"\n#include \"MTLBlitCommandEncoder.hpp\"\n#include \"MTLBlitPass.hpp\"\n#include \"MTLBuffer.hpp\"\n#include \"MTLCaptureManager.hpp\"\n#include \"MTLCaptureScope.hpp\"\n#include \"MTLCommandBuffer.hpp\"\n#include \"MTLCommandEncoder.hpp\"\n#include \"MTLCommandQueue.hpp\"\n#include \"MTLComputeCommandEncoder.hpp\"\n#include \"MTLComputePass.hpp\"\n#include \"MTLComputePipeline.hpp\"\n#include \"MTLCounters.hpp\"\n#include \"MTLDefines.hpp\"\n#include \"MTLDepthStencil.hpp\"\n#include \"MTLDevice.hpp\"\n#include \"MTLDrawable.hpp\"\n#include \"MTLDynamicLibrary.hpp\"\n#include \"MTLEvent.hpp\"\n#include \"MTLFence.hpp\"\n#include \"MTLFunctionConstantValues.hpp\"\n#include \"MTLFunctionDescriptor.hpp\"\n#include \"MTLFunctionHandle.hpp\"\n#include \"MTLFunctionLog.hpp\"\n#include \"MTLFunctionStitching.hpp\"\n#include \"MTLHeaderBridge.hpp\"\n#include \"MTLHeap.hpp\"\n#include \"MTLIndirectCommandBuffer.hpp\"\n#include \"MTLIndirectCommandEncoder.hpp\"\n#include \"MTLIntersectionFunctionTable.hpp\"\n#include \"MTLIOCommandBuffer.hpp\"\n#include \"MTLIOCommandQueue.hpp\"\n#include \"MTLIOCompressor.hpp\"\n#include \"MTLLibrary.hpp\"\n#include \"MTLLinkedFunctions.hpp\"\n#include \"MTLParallelRenderCommandEncoder.hpp\"\n#include \"MTLPipeline.hpp\"\n#include \"MTLPixelFormat.hpp\"\n#include \"MTLPrivate.hpp\"\n#include \"MTLRasterizationRate.hpp\"\n#include \"MTLRenderCommandEncoder.hpp\"\n#include \"MTLRenderPass.hpp\"\n#include \"MTLRenderPipeline.hpp\"\n#include \"MTLResource.hpp\"\n#include \"MTLResourceStateCommandEncoder.hpp\"\n#include \"MTLResourceStatePass.hpp\"\n#include \"MTLSampler.hpp\"\n#include \"MTLStageInputOutputDescriptor.hpp\"\n#include \"MTLTexture.hpp\"\n#include \"MTLTypes.hpp\"\n#include \"MTLVertexDescriptor.hpp\"\n#include \"MTLVisibleFunctionTable.hpp\"\n#include \"MTLVersion.hpp\"\n\n\n\n'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLCommandQueue.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n#include \"MTLDefines.hpp\"\n#include \"MTLHeaderBridge.hpp\"\n#include \"MTLPrivate.hpp\"\n\n#include <Foundation/Foundation.hpp>\n\nnamespace MTL\n{\nclass CommandQueue : public NS::Referencing<CommandQueue>\n{\npublic:\n    NS::String*          label() const;\n    void                 setLabel(const NS::String* label);\n\n    class Device*        device() const;\n\n    class CommandBuffer* commandBuffer();\n\n    class CommandBuffer* commandBuffer(const class CommandBufferDescriptor* descriptor);\n\n    class CommandBuffer* commandBufferWithUnretainedReferences();\n\n    void                 insertDebugCaptureBoundary();\n};\n\n}\n\n\n_MTL_INLINE NS::String* MTL::CommandQueue::label() const\n{\n    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));\n}\n\n_MTL_INLINE void MTL::CommandQueue::setLabel(const NS::String* label)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);\n}\n\n\n_MTL_INLINE MTL::Device* MTL::CommandQueue::device() const\n{\n    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));\n}\n\n\n_MTL_INLINE MTL::CommandBuffer* MTL::CommandQueue::commandBuffer()\n{\n    return Object::sendMessage<MTL::CommandBuffer*>(this, _MTL_PRIVATE_SEL(commandBuffer));\n}\n\n\n_MTL_INLINE MTL::CommandBuffer* MTL::CommandQueue::commandBuffer(const MTL::CommandBufferDescriptor* descriptor)\n{\n    return Object::sendMessage<MTL::CommandBuffer*>(this, _MTL_PRIVATE_SEL(commandBufferWithDescriptor_), descriptor);\n}\n\n\n_MTL_INLINE MTL::CommandBuffer* MTL::CommandQueue::commandBufferWithUnretainedReferences()\n{\n    return Object::sendMessage<MTL::CommandBuffer*>(this, _MTL_PRIVATE_SEL(commandBufferWithUnretainedReferences));\n}\n\n\n_MTL_INLINE void MTL::CommandQueue::insertDebugCaptureBoundary()\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(insertDebugCaptureBoundary));\n}\n",
        "gt": [
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLCommandQueue.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'",
            "'Tempest/Engine/gapi/metal/mtsamplercache.h'",
            "'Tempest/Engine/gapi/metal/mtsamplercache.cpp'"
        ]
    },
    {
        "files": [
            "'LearnVulkan/Android/app/src/main/cpp/examples/02_StaticCube/StaticCube.h'",
            "'LearnVulkan/third_party/glm/glm/glm.hpp'",
            "'LearnVulkan/third_party/glm/glm/gtx/fast_exponential.hpp'",
            "'LearnVulkan/source/engines/ThirdPersonEngine.h'",
            "'LearnVulkan/source/template/object/camera/ThirdPersonCamera.h'"
        ],
        "content": "'LearnVulkan/Android/app/src/main/cpp/examples/02_StaticCube/StaticCube.h'\n:\n\n\n\n#ifndef LEARNVULKAN_STATICCUBE_H\n#define LEARNVULKAN_STATICCUBE_H\n\n#include \"ThirdPersonEngine.h\"\n\nBEGIN_NAMESPACE(VulkanEngine)\n\nclass VulkanCube;\n\nclass VulkanVertFragShader;\n\nclass UniformCamera;\n\nclass StaticCube : public ThirdPersonEngine {\npublic:\n    StaticCube() = default;\n\n    virtual ~StaticCube();\n\n    void prepareMyObjects() override;\n\n    void buildMyObjects(VkCommandBuffer &cmd) override;\n\n    void render() override;\n\n    void setDescriptorSet();\n\n    void createPipelines();\n\n    void createCube();\n\nprotected:\n    std::shared_ptr<VulkanCube> m_cube = nullptr;\n    std::shared_ptr<VulkanVertFragShader> m_cubeShader = nullptr;\n    std::shared_ptr<UniformCamera> m_cubeUniform = nullptr;\n};\n\nEND_NAMESPACE(VulkanEngine)\n\n#endif\n\n'LearnVulkan/third_party/glm/glm/glm.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"detail/_fixes.hpp\"\n\n#include \"detail/setup.hpp\"\n\n#pragma once\n\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <limits>\n#include <cassert>\n#include \"fwd.hpp\"\n\n#include \"vec2.hpp\"\n#include \"vec3.hpp\"\n#include \"vec4.hpp\"\n#include \"mat2x2.hpp\"\n#include \"mat2x3.hpp\"\n#include \"mat2x4.hpp\"\n#include \"mat3x2.hpp\"\n#include \"mat3x3.hpp\"\n#include \"mat3x4.hpp\"\n#include \"mat4x2.hpp\"\n#include \"mat4x3.hpp\"\n#include \"mat4x4.hpp\"\n\n#include \"trigonometric.hpp\"\n#include \"exponential.hpp\"\n#include \"common.hpp\"\n#include \"packing.hpp\"\n#include \"geometric.hpp\"\n#include \"matrix.hpp\"\n#include \"vector_relational.hpp\"\n#include \"integer.hpp\"\n\n'LearnVulkan/third_party/glm/glm/gtx/fast_exponential.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n\n#include \"../glm.hpp\"\n\n#if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n#\tifndef GLM_ENABLE_EXPERIMENTAL\n#\t\tpragma message(\"GLM: GLM_GTX_fast_exponential is an experimental extension and may change in the future. Use #define GLM_ENABLE_EXPERIMENTAL before including it, if you really want to use it.\")\n#\telse\n#\t\tpragma message(\"GLM: GLM_GTX_fast_exponential extension included\")\n#\tendif\n#endif\n\nnamespace glm\n{\n\n\n\n\n\n\ttemplate<typename genType>\n\tGLM_FUNC_DECL genType fastPow(genType x, genType y);\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, T, Q> fastPow(vec<L, T, Q> const& x, vec<L, T, Q> const& y);\n\n\n\n\ttemplate<typename genTypeT, typename genTypeU>\n\tGLM_FUNC_DECL genTypeT fastPow(genTypeT x, genTypeU y);\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, T, Q> fastPow(vec<L, T, Q> const& x);\n\n\n\n\ttemplate<typename T>\n\tGLM_FUNC_DECL T fastExp(T x);\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, T, Q> fastExp(vec<L, T, Q> const& x);\n\n\n\n\ttemplate<typename T>\n\tGLM_FUNC_DECL T fastLog(T x);\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, T, Q> fastLog(vec<L, T, Q> const& x);\n\n\n\n\ttemplate<typename T>\n\tGLM_FUNC_DECL T fastExp2(T x);\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, T, Q> fastExp2(vec<L, T, Q> const& x);\n\n\n\n\ttemplate<typename T>\n\tGLM_FUNC_DECL T fastLog2(T x);\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, T, Q> fastLog2(vec<L, T, Q> const& x);\n\n\n}\n\n#include \"fast_exponential.inl\"\n\n'LearnVulkan/source/engines/ThirdPersonEngine.h'\n:\n\n\n\n#ifndef LEARNVULKAN_THIRDPERSONENGINE_H\n#define LEARNVULKAN_THIRDPERSONENGINE_H\n\n#include \"VulkanBaseEngine.h\"\n#include \"ThirdPersonCamera.h\"\n\nBEGIN_NAMESPACE(VulkanEngine)\n\nclass VULKANENGINE_EXPORT_API ThirdPersonEngine : public VulkanBaseEngine , public ThirdPersonCamera {\npublic:\n    ThirdPersonEngine() = default;\n    virtual ~ThirdPersonEngine() {}\n\n    void updateCamera();\n};\n\nEND_NAMESPACE(VulkanEngine)\n\n#endif\n\n'LearnVulkan/source/template/object/camera/ThirdPersonCamera.h'\n:\n\n\n\n#ifndef LEARNVULKAN_THIRDPERSONCAMERA_H\n#define LEARNVULKAN_THIRDPERSONCAMERA_H\n\n#include <glm/glm.hpp>\n#include \"base_template.h\"\n\nclass VULKANENGINE_EXPORT_API ThirdPersonCamera {\npublic:\n    ThirdPersonCamera()=default;\n    ~ThirdPersonCamera()=default;\n\n    void setZoom(float zoom) { m_zoom = zoom; }\n\n    glm::vec3 m_rotation = glm::vec3();\n    glm::vec3 m_cameraPos = glm::vec3();\n    const float m_baseZoom = -2.f;\n    float m_zoom = m_baseZoom;\n};\n\n\n#endif\n",
        "gt": [
            "'LearnVulkan/third_party/glm/glm/gtx/fast_exponential.hpp'",
            "'LearnVulkan/third_party/glm/glm/glm.hpp'",
            "'LearnVulkan/source/template/object/camera/ThirdPersonCamera.h'",
            "'LearnVulkan/source/engines/ThirdPersonEngine.h'",
            "'LearnVulkan/Android/app/src/main/cpp/examples/02_StaticCube/StaticCube.h'"
        ]
    },
    {
        "files": [
            "'elaphureLink/thirdparty/asio/include/asio/detail/future.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/ts/executor.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/ts/net.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/use_future.hpp'"
        ],
        "content": "'elaphureLink/thirdparty/asio/include/asio/detail/future.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_DETAIL_FUTURE_HPP\n#define ASIO_DETAIL_FUTURE_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#if defined(ASIO_HAS_STD_FUTURE)\n# include <future>\n\n\n\n# if defined(__GNUC__) && !defined(ASIO_HAS_CLANG_LIBCXX)\n#  if defined(_GLIBCXX_HAS_GTHREADS)\n#   define ASIO_HAS_STD_FUTURE_CLASS 1\n#  endif\n# else\n#  define ASIO_HAS_STD_FUTURE_CLASS 1\n# endif\n#endif\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/ts/executor.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_TS_EXECUTOR_HPP\n#define ASIO_TS_EXECUTOR_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/async_result.hpp\"\n#include \"asio/associated_allocator.hpp\"\n#include \"asio/execution_context.hpp\"\n#include \"asio/is_executor.hpp\"\n#include \"asio/associated_executor.hpp\"\n#include \"asio/bind_executor.hpp\"\n#include \"asio/executor_work_guard.hpp\"\n#include \"asio/system_executor.hpp\"\n#include \"asio/executor.hpp\"\n#include \"asio/any_io_executor.hpp\"\n#include \"asio/dispatch.hpp\"\n#include \"asio/post.hpp\"\n#include \"asio/defer.hpp\"\n#include \"asio/strand.hpp\"\n#include \"asio/packaged_task.hpp\"\n#include \"asio/use_future.hpp\"\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/ts/net.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_TS_NET_HPP\n#define ASIO_TS_NET_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/ts/netfwd.hpp\"\n#include \"asio/ts/executor.hpp\"\n#include \"asio/ts/io_context.hpp\"\n#include \"asio/ts/timer.hpp\"\n#include \"asio/ts/buffer.hpp\"\n#include \"asio/ts/socket.hpp\"\n#include \"asio/ts/internet.hpp\"\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/use_future.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_USE_FUTURE_HPP\n#define ASIO_USE_FUTURE_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include \"asio/detail/future.hpp\"\n\n#if defined(ASIO_HAS_STD_FUTURE_CLASS) \\\n  || defined(GENERATING_DOCUMENTATION)\n\n#include <memory>\n#include \"asio/detail/type_traits.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace detail {\n\ntemplate <typename Function, typename Allocator>\nclass packaged_token;\n\ntemplate <typename Function, typename Allocator, typename Result>\nclass packaged_handler;\n\n}\n\n\n\n\ntemplate <typename Allocator = std::allocator<void> >\nclass use_future_t\n{\npublic:\n\n\n  typedef Allocator allocator_type;\n\n\n  ASIO_CONSTEXPR use_future_t()\n  {\n  }\n\n\n  explicit use_future_t(const Allocator& allocator)\n    : allocator_(allocator)\n  {\n  }\n\n#if !defined(ASIO_NO_DEPRECATED)\n\n  template <typename OtherAllocator>\n  use_future_t<OtherAllocator> operator[](const OtherAllocator& allocator) const\n  {\n    return use_future_t<OtherAllocator>(allocator);\n  }\n#endif\n\n\n  template <typename OtherAllocator>\n  use_future_t<OtherAllocator> rebind(const OtherAllocator& allocator) const\n  {\n    return use_future_t<OtherAllocator>(allocator);\n  }\n\n\n  allocator_type get_allocator() const\n  {\n    return allocator_;\n  }\n\n\n\n  template <typename Function>\n#if defined(GENERATING_DOCUMENTATION)\n  unspecified\n#else\n  detail::packaged_token<typename decay<Function>::type, Allocator>\n#endif\n  operator()(ASIO_MOVE_ARG(Function) f) const;\n\nprivate:\n\n\n  struct std_allocator_void\n  {\n    ASIO_CONSTEXPR std_allocator_void()\n    {\n    }\n\n    operator std::allocator<void>() const\n    {\n      return std::allocator<void>();\n    }\n  };\n\n  typename conditional<\n    is_same<std::allocator<void>, Allocator>::value,\n    std_allocator_void, Allocator>::type allocator_;\n};\n\n\n\n\n#if defined(ASIO_HAS_CONSTEXPR) || defined(GENERATING_DOCUMENTATION)\nconstexpr use_future_t<> use_future;\n#elif defined(ASIO_MSVC)\n__declspec(selectany) use_future_t<> use_future;\n#endif\n\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#include \"asio/impl/use_future.hpp\"\n\n#endif\n\n\n#endif\n",
        "gt": [
            "'elaphureLink/thirdparty/asio/include/asio/detail/future.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/use_future.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/ts/executor.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/ts/net.hpp'"
        ]
    },
    {
        "files": [
            "'query-pdb/thirdparty/raw_pdb/src/Foundation/PDB_Move.h'",
            "'query-pdb/thirdparty/raw_pdb/src/PDB_ModuleInfoStream.cpp'",
            "'query-pdb/thirdparty/raw_pdb/src/PDB_PCH.h'"
        ],
        "content": "'query-pdb/thirdparty/raw_pdb/src/Foundation/PDB_Move.h'\n:\n\n\n#pragma once\n\n#include \"PDB_DisableWarningsPush.h\"\n#include <type_traits>\n#include \"PDB_DisableWarningsPop.h\"\n\n\n\n\n#define PDB_MOVE(...)\t\tstatic_cast<std::remove_reference<decltype(__VA_ARGS__)>::type&&>(__VA_ARGS__)\n\n'query-pdb/thirdparty/raw_pdb/src/PDB_ModuleInfoStream.cpp'\n:\n\n\n#include \"PDB_PCH.h\"\n#include \"PDB_ModuleInfoStream.h\"\n#include \"Foundation/PDB_Memory.h\"\n#include \"Foundation/PDB_DisableWarningsPush.h\"\n#include <cstring>\n#include \"Foundation/PDB_DisableWarningsPop.h\"\n\n\nnamespace\n{\n\tstatic constexpr const char* LinkerSymbolName(\"* Linker *\");\n\n\n\n\n\tPDB_NO_DISCARD static inline size_t EstimateModuleCount(size_t streamSize) PDB_NO_EXCEPT\n\t{\n\n\n\t\treturn streamSize / sizeof(PDB::DBI::ModuleInfo);\n\t}\n}\n\n\n\n\nPDB::ModuleInfoStream::Module::Module(void) PDB_NO_EXCEPT\n\t: m_info(nullptr)\n\t, m_name(nullptr)\n\t, m_nameLength(0u)\n\t, m_objectName(nullptr)\n\t, m_objectNameLength(0u)\n{\n}\n\n\n\n\nPDB::ModuleInfoStream::Module::Module(const DBI::ModuleInfo* info, const char* name, size_t nameLength, const char* objectName, size_t objectNameLength) PDB_NO_EXCEPT\n\t: m_info(info)\n\t, m_name(name)\n\t, m_nameLength(nameLength)\n\t, m_objectName(objectName)\n\t, m_objectNameLength(objectNameLength)\n{\n}\n\n\n\n\nPDB_NO_DISCARD bool PDB::ModuleInfoStream::Module::HasSymbolStream(void) const PDB_NO_EXCEPT\n{\n\tconst uint16_t streamIndex = m_info->moduleSymbolStreamIndex;\n\n\n\n\treturn (streamIndex != 0xFFFFu);\n}\n\n\n\n\nPDB_NO_DISCARD bool PDB::ModuleInfoStream::Module::HasLineStream(void) const PDB_NO_EXCEPT\n{\n\treturn (m_info->c13Size > 0);\n}\n\n\n\nPDB_NO_DISCARD PDB::ModuleSymbolStream PDB::ModuleInfoStream::Module::CreateSymbolStream(const RawFile& file) const PDB_NO_EXCEPT\n{\n\tPDB_ASSERT(HasSymbolStream(), \"Module symbol stream index is invalid.\");\n\n\treturn ModuleSymbolStream(file, m_info->moduleSymbolStreamIndex, m_info->symbolSize);\n}\n\nPDB_NO_DISCARD PDB::ModuleLineStream PDB::ModuleInfoStream::Module::CreateLineStream(const RawFile& file) const PDB_NO_EXCEPT\n{\n\tPDB_ASSERT(HasLineStream(), \"Module line stream is not present.\");\n\n\treturn ModuleLineStream(file, m_info->moduleSymbolStreamIndex, m_info->symbolSize + m_info->c11Size + m_info->c13Size, m_info->symbolSize + m_info->c11Size);\n}\n\n\n\nPDB::ModuleInfoStream::ModuleInfoStream(void) PDB_NO_EXCEPT\n\t: m_stream()\n\t, m_modules(nullptr)\n\t, m_moduleCount(0u)\n{\n}\n\n\n\n\nPDB::ModuleInfoStream::ModuleInfoStream(ModuleInfoStream&& other) PDB_NO_EXCEPT\n\t: m_stream(PDB_MOVE(other.m_stream))\n\t, m_modules(PDB_MOVE(other.m_modules))\n\t, m_moduleCount(PDB_MOVE(other.m_moduleCount))\n{\n\tother.m_modules = nullptr;\n\tother.m_moduleCount = 0u;\n}\n\n\n\n\nPDB::ModuleInfoStream& PDB::ModuleInfoStream::operator=(ModuleInfoStream&& other) PDB_NO_EXCEPT\n{\n\tif (this != &other)\n\t{\n\t\tPDB_DELETE_ARRAY(m_modules);\n\n\t\tm_stream = PDB_MOVE(other.m_stream);\n\t\tm_modules = PDB_MOVE(other.m_modules);\n\t\tm_moduleCount = PDB_MOVE(other.m_moduleCount);\n\n\t\tother.m_modules = nullptr;\n\t\tother.m_moduleCount = 0u;\n\t}\n\n\treturn *this;\n}\n\n\n\n\nPDB::ModuleInfoStream::ModuleInfoStream(const DirectMSFStream& directStream, uint32_t size, uint32_t offset) PDB_NO_EXCEPT\n\t: m_stream(directStream, size, offset)\n\t, m_modules(nullptr)\n\t, m_moduleCount(0u)\n{\n\tm_modules = PDB_NEW_ARRAY(Module, EstimateModuleCount(size));\n\n\tsize_t streamOffset = 0u;\n\twhile (streamOffset < size)\n\t{\n\t\tconst DBI::ModuleInfo* moduleInfo = m_stream.GetDataAtOffset<const DBI::ModuleInfo>(streamOffset);\n\t\tstreamOffset += sizeof(DBI::ModuleInfo);\n\n\t\tconst char* name = m_stream.GetDataAtOffset<const char>(streamOffset);\n\t\tconst size_t nameLength = std::strlen(name);\n\t\tstreamOffset += nameLength + 1u;\n\n\t\tconst char* objectName = m_stream.GetDataAtOffset<const char>(streamOffset);\n\t\tconst size_t objectNameLength = std::strlen(objectName);\n\t\tstreamOffset += objectNameLength + 1u;\n\n\n\t\tstreamOffset = BitUtil::RoundUpToMultiple<size_t>(streamOffset, 4ul);\n\n\t\tm_modules[m_moduleCount] = Module(moduleInfo, name, nameLength, objectName, objectNameLength);\n\t\t++m_moduleCount;\n\t}\n}\n\n\n\n\nPDB::ModuleInfoStream::~ModuleInfoStream(void) PDB_NO_EXCEPT\n{\n\tPDB_DELETE_ARRAY(m_modules);\n}\n\n\n\n\nPDB_NO_DISCARD const PDB::ModuleInfoStream::Module* PDB::ModuleInfoStream::FindLinkerModule(void) const PDB_NO_EXCEPT\n{\n\tconst size_t count = m_moduleCount;\n\tfor (size_t i = 0u; i < count; ++i)\n\t{\n\n\t\tconst Module& module = m_modules[count - i - 1u];\n\n\n\t\tif (std::strcmp(module.GetName().Decay(), LinkerSymbolName) == 0)\n\t\t{\n\t\t\treturn &module;\n\t\t}\n\t}\n\n\treturn nullptr;\n}\n\n'query-pdb/thirdparty/raw_pdb/src/PDB_PCH.h'\n:\n\n\n#pragma once\n\n\n#include \"Foundation/PDB_Platform.h\"\n#include \"Foundation/PDB_Macros.h\"\n#include \"Foundation/PDB_Warnings.h\"\n\n\n#include \"Foundation/PDB_DisableWarningsPush.h\"\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <type_traits>\n#include \"Foundation/PDB_DisableWarningsPop.h\"\n\n\n#include \"Foundation/PDB_Log.h\"\n#include \"Foundation/PDB_Assert.h\"\n#include \"Foundation/PDB_Move.h\"\n#include \"Foundation/PDB_Forward.h\"\n#include \"Foundation/PDB_Memory.h\"\n#include \"Foundation/PDB_ArrayView.h\"\n#include \"Foundation/PDB_BitUtil.h\"\n#include \"Foundation/PDB_BitOperators.h\"\n#include \"Foundation/PDB_PointerUtil.h\"\n",
        "gt": [
            "'query-pdb/thirdparty/raw_pdb/src/Foundation/PDB_Move.h'",
            "'query-pdb/thirdparty/raw_pdb/src/PDB_PCH.h'",
            "'query-pdb/thirdparty/raw_pdb/src/PDB_ModuleInfoStream.cpp'"
        ]
    },
    {
        "files": [
            "'pyeos/externals/thrift/src/thrift/windows/OverlappedSubmissionThread.h'",
            "'pyeos/externals/thrift/src/thrift/transport/TPipeServer.cpp'",
            "'pyeos/externals/thrift/src/thrift/windows/Sync.h'"
        ],
        "content": "'pyeos/externals/thrift/src/thrift/windows/OverlappedSubmissionThread.h'\n:\n\n#ifndef _THRIFT_WINDOWS_OverlappedSubmissionThread_H_\n#define _THRIFT_WINDOWS_OverlappedSubmissionThread_H_ 1\n\n#ifndef _WIN32\n#error \"OverlappedSubmissionThread.h is only usable on Windows\"\n#endif\n\n#include <thrift/windows/Sync.h>\n#include <boost/noncopyable.hpp>\n#include <Windows.h>\n\n\n\nnamespace apache {\nnamespace thrift {\nnamespace transport {\n\nstruct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) TOverlappedWorkItem : public SLIST_ENTRY {\n  TOverlappedWorkItem();\n\n  enum action_t {\n    UNKNOWN = 3000,\n    CONNECT,\n    READ,\n    CANCELIO,\n    STOP,\n  };\n\n  TAutoResetEvent doneSubmittingEvent;\n  action_t action;\n  HANDLE h;\n  uint8_t* buffer;\n  uint32_t buffer_len;\n  OVERLAPPED overlap;\n\n  DWORD last_error;\n  BOOL success;\n\n  void reset(uint8_t* buf, uint32_t len, HANDLE event);\n  uint32_t overlappedResults(bool signal_failure = true);\n  bool process();\n};\n\nclass TOverlappedSubmissionThread : boost::noncopyable {\npublic:\n  void addWorkItem(TOverlappedWorkItem* item);\n\n\npublic:\n  static TOverlappedSubmissionThread* acquire_instance();\n  static void release_instance();\n\nprivate:\n  static TCriticalSection instanceGuard_;\n  static TOverlappedSubmissionThread* instance_;\n  static uint32_t instanceRefCount_;\n\n\nprivate:\n  TOverlappedSubmissionThread();\n  ~TOverlappedSubmissionThread();\n  void run();\n  static unsigned __stdcall thread_proc(void* addr);\n\nprivate:\n  DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) SLIST_HEADER workList_;\n  TOverlappedWorkItem stopItem_;\n  TAutoResetEvent workAvailableEvent_;\n  HANDLE thread_;\n};\n\nclass TAutoOverlapThread : boost::noncopyable {\nprivate:\n  TOverlappedSubmissionThread* p;\n\npublic:\n  TAutoOverlapThread() : p(TOverlappedSubmissionThread::acquire_instance()) {}\n  ~TAutoOverlapThread() { TOverlappedSubmissionThread::release_instance(); }\n  TOverlappedSubmissionThread* operator->() { return p; }\n};\n}\n}\n}\n\n#endif\n\n'pyeos/externals/thrift/src/thrift/transport/TPipeServer.cpp'\n:\n\n#include <thrift/thrift-config.h>\n#include <cstring>\n\n#include <thrift/transport/TPipe.h>\n#include <thrift/transport/TPipeServer.h>\n#include <thrift/stdcxx.h>\n#include <boost/noncopyable.hpp>\n\n#ifdef _WIN32\n#include <thrift/windows/OverlappedSubmissionThread.h>\n#include <AccCtrl.h>\n#include <Aclapi.h>\n#endif\n\nnamespace apache {\nnamespace thrift {\nnamespace transport {\n\n#ifdef _WIN32\n\nusing stdcxx::shared_ptr;\n\nclass TPipeServerImpl : boost::noncopyable {\npublic:\n  TPipeServerImpl() {}\n  virtual ~TPipeServerImpl() {}\n  virtual void interrupt() = 0;\n  virtual stdcxx::shared_ptr<TTransport> acceptImpl() = 0;\n\n  virtual HANDLE getPipeHandle() = 0;\n  virtual HANDLE getWrtPipeHandle() = 0;\n  virtual HANDLE getClientRdPipeHandle() = 0;\n  virtual HANDLE getClientWrtPipeHandle() = 0;\n  virtual HANDLE getNativeWaitHandle() { return NULL; }\n};\n\nclass TAnonPipeServer : public TPipeServerImpl {\npublic:\n  TAnonPipeServer() {\n\n\n\n    if (!createAnonPipe()) {\n      GlobalOutput.perror(\"TPipeServer Create(Anon)Pipe failed, GLE=\", GetLastError());\n      throw TTransportException(TTransportException::NOT_OPEN,\n                                \" TPipeServer Create(Anon)Pipe failed\");\n    }\n  }\n\n  virtual ~TAnonPipeServer() {\n    PipeR_.reset();\n    PipeW_.reset();\n    ClientAnonRead_.reset();\n    ClientAnonWrite_.reset();\n  }\n\n  virtual void interrupt() {}\n\n  virtual stdcxx::shared_ptr<TTransport> acceptImpl();\n\n  virtual HANDLE getPipeHandle() { return PipeR_.h; }\n  virtual HANDLE getWrtPipeHandle() { return PipeW_.h; }\n  virtual HANDLE getClientRdPipeHandle() { return ClientAnonRead_.h; }\n  virtual HANDLE getClientWrtPipeHandle() { return ClientAnonWrite_.h; }\n\nprivate:\n  bool createAnonPipe();\n\n  TAutoHandle PipeR_;\n  TAutoHandle PipeW_;\n\n\n\n  TAutoHandle ClientAnonRead_;\n  TAutoHandle ClientAnonWrite_;\n};\n\nclass TNamedPipeServer : public TPipeServerImpl {\npublic:\n  TNamedPipeServer(const std::string& pipename, uint32_t bufsize, uint32_t maxconnections)\n    : stopping_(false), pipename_(pipename), bufsize_(bufsize), maxconns_(maxconnections)\n  {\n    connectOverlap_.action = TOverlappedWorkItem::CONNECT;\n    cancelOverlap_.action = TOverlappedWorkItem::CANCELIO;\n    TAutoCrit lock(pipe_protect_);\n    initiateNamedConnect(lock);\n  }\n  virtual ~TNamedPipeServer() {}\n\n  virtual void interrupt() {\n    TAutoCrit lock(pipe_protect_);\n    cached_client_.reset();\n    if (Pipe_.h != INVALID_HANDLE_VALUE) {\n      stopping_ = true;\n      cancelOverlap_.h = Pipe_.h;\n\n      thread_->addWorkItem(&cancelOverlap_);\n    }\n  }\n\n  virtual stdcxx::shared_ptr<TTransport> acceptImpl();\n\n  virtual HANDLE getPipeHandle() { return Pipe_.h; }\n  virtual HANDLE getWrtPipeHandle() { return INVALID_HANDLE_VALUE; }\n  virtual HANDLE getClientRdPipeHandle() { return INVALID_HANDLE_VALUE; }\n  virtual HANDLE getClientWrtPipeHandle() { return INVALID_HANDLE_VALUE; }\n  virtual HANDLE getNativeWaitHandle() { return listen_event_.h; }\n\nprivate:\n  bool createNamedPipe(const TAutoCrit &lockProof);\n  void initiateNamedConnect(const TAutoCrit &lockProof);\n\n  TAutoOverlapThread thread_;\n  TOverlappedWorkItem connectOverlap_;\n  TOverlappedWorkItem cancelOverlap_;\n\n  bool stopping_;\n  std::string pipename_;\n  uint32_t bufsize_;\n  uint32_t maxconns_;\n  TManualResetEvent listen_event_;\n\n  TCriticalSection pipe_protect_;\n\n  stdcxx::shared_ptr<TPipe> cached_client_;\n  TAutoHandle Pipe_;\n};\n\nHANDLE TPipeServer::getNativeWaitHandle() {\n  if (impl_)\n    return impl_->getNativeWaitHandle();\n  return NULL;\n}\n\n\nTPipeServer::TPipeServer(const std::string& pipename, uint32_t bufsize)\n  : bufsize_(bufsize), isAnonymous_(false) {\n  setMaxConnections(TPIPE_SERVER_MAX_CONNS_DEFAULT);\n  setPipename(pipename);\n}\n\nTPipeServer::TPipeServer(const std::string& pipename, uint32_t bufsize, uint32_t maxconnections)\n  : bufsize_(bufsize), isAnonymous_(false) {\n  setMaxConnections(maxconnections);\n  setPipename(pipename);\n}\n\nTPipeServer::TPipeServer(const std::string& pipename) : bufsize_(1024), isAnonymous_(false) {\n  setMaxConnections(TPIPE_SERVER_MAX_CONNS_DEFAULT);\n  setPipename(pipename);\n}\n\nTPipeServer::TPipeServer(int bufsize) : bufsize_(bufsize), isAnonymous_(true) {\n  setMaxConnections(1);\n  impl_.reset(new TAnonPipeServer);\n}\n\nTPipeServer::TPipeServer() : bufsize_(1024), isAnonymous_(true) {\n  setMaxConnections(1);\n  impl_.reset(new TAnonPipeServer);\n}\n\n\nTPipeServer::~TPipeServer() {}\n\n\n\n\nvoid TPipeServer::listen() {\n  if (isAnonymous_)\n    return;\n  impl_.reset(new TNamedPipeServer(pipename_, bufsize_, maxconns_));\n}\n\nshared_ptr<TTransport> TPipeServer::acceptImpl() {\n  return impl_->acceptImpl();\n}\n\nshared_ptr<TTransport> TAnonPipeServer::acceptImpl() {\n\n  byte buf;\n  DWORD br;\n  int fSuccess = ReadFile(PipeR_.h,\n                          &buf,\n                          0,\n                          &br,\n                          NULL);\n\n  if (!fSuccess && GetLastError() != ERROR_MORE_DATA) {\n    GlobalOutput.perror(\"TPipeServer unable to initiate pipe comms, GLE=\", GetLastError());\n    throw TTransportException(TTransportException::NOT_OPEN,\n                              \" TPipeServer unable to initiate pipe comms\");\n  }\n  shared_ptr<TPipe> client(new TPipe(PipeR_.h, PipeW_.h));\n  return client;\n}\n\nvoid TNamedPipeServer::initiateNamedConnect(const TAutoCrit &lockProof) {\n  if (stopping_)\n    return;\n  if (!createNamedPipe(lockProof)) {\n    GlobalOutput.perror(\"TPipeServer CreateNamedPipe failed, GLE=\", GetLastError());\n    throw TTransportException(TTransportException::NOT_OPEN, \" TPipeServer CreateNamedPipe failed\");\n  }\n\n\n  ResetEvent(listen_event_.h);\n  connectOverlap_.reset(NULL, 0, listen_event_.h);\n  connectOverlap_.h = Pipe_.h;\n  thread_->addWorkItem(&connectOverlap_);\n\n\n\n\n  if (connectOverlap_.success) {\n    GlobalOutput.printf(\"Client connected.\");\n    cached_client_.reset(new TPipe(Pipe_));\n\n    SetEvent(listen_event_.h);\n    return;\n  }\n\n  DWORD dwErr = connectOverlap_.last_error;\n  switch (dwErr) {\n  case ERROR_PIPE_CONNECTED:\n    GlobalOutput.printf(\"Client connected.\");\n    cached_client_.reset(new TPipe(Pipe_));\n\n    SetEvent(listen_event_.h);\n    return;\n  case ERROR_IO_PENDING:\n    return;\n  default:\n    GlobalOutput.perror(\"TPipeServer ConnectNamedPipe failed, GLE=\", dwErr);\n    throw TTransportException(TTransportException::NOT_OPEN,\n                              \" TPipeServer ConnectNamedPipe failed\");\n  }\n}\n\nshared_ptr<TTransport> TNamedPipeServer::acceptImpl() {\n  {\n    TAutoCrit lock(pipe_protect_);\n    if (cached_client_.get() != NULL) {\n      shared_ptr<TPipe> client;\n\n      client.swap(cached_client_);\n\n\n      initiateNamedConnect(lock);\n      return client;\n    }\n  }\n\n  if (Pipe_.h == INVALID_HANDLE_VALUE) {\n    throw TTransportException(TTransportException::NOT_OPEN,\n                              \"TNamedPipeServer: someone called accept on a closed pipe server\");\n  }\n\n  DWORD dwDummy = 0;\n\n\n\n\n\n\n\n\n\n  if (GetOverlappedResult(Pipe_.h, &connectOverlap_.overlap, &dwDummy, TRUE)) {\n    TAutoCrit lock(pipe_protect_);\n    GlobalOutput.printf(\"Client connected.\");\n    shared_ptr<TPipe> client(new TPipe(Pipe_));\n\n    initiateNamedConnect(lock);\n    return client;\n  }\n\n  DWORD gle = GetLastError();\n  GlobalOutput.perror(\"TPipeServer ConnectNamedPipe GLE=\", gle);\n  if(gle == ERROR_OPERATION_ABORTED) {\n    TAutoCrit lock(pipe_protect_);\n    throw TTransportException(TTransportException::INTERRUPTED, \"TPipeServer: server interupted\");\n  }\n  throw TTransportException(TTransportException::NOT_OPEN, \"TPipeServer: client connection failed\");\n}\n\nvoid TPipeServer::interrupt() {\n  if (impl_)\n    impl_->interrupt();\n}\n\nvoid TPipeServer::close() {\n  impl_.reset();\n}\n\nbool TNamedPipeServer::createNamedPipe(const TAutoCrit & ) {\n\n\n\n  SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;\n  PSID everyone_sid = NULL;\n  AllocateAndInitializeSid(\n      &SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &everyone_sid);\n\n  EXPLICIT_ACCESS ea;\n  ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));\n  ea.grfAccessPermissions = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;\n  ea.grfAccessMode = SET_ACCESS;\n  ea.grfInheritance = NO_INHERITANCE;\n  ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;\n  ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;\n  ea.Trustee.ptstrName = static_cast<LPTSTR>(everyone_sid);\n\n  PACL acl = NULL;\n  SetEntriesInAcl(1, &ea, NULL, &acl);\n\n  PSECURITY_DESCRIPTOR sd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);\n  InitializeSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION);\n  SetSecurityDescriptorDacl(sd, TRUE, acl, FALSE);\n\n  SECURITY_ATTRIBUTES sa;\n  sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n  sa.lpSecurityDescriptor = sd;\n  sa.bInheritHandle = FALSE;\n\n\n  TAutoHandle hPipe(CreateNamedPipeA(pipename_.c_str(),\n                                     PIPE_ACCESS_DUPLEX |\n                                     FILE_FLAG_OVERLAPPED,\n                                     PIPE_TYPE_BYTE |\n                                     PIPE_READMODE_BYTE,\n                                     maxconns_,\n                                     bufsize_,\n                                     bufsize_,\n                                     0,\n                                     &sa));\n\n  DWORD lastError = GetLastError();\n  LocalFree(sd);\n  LocalFree(acl);\n  FreeSid(everyone_sid);\n\n  if (hPipe.h == INVALID_HANDLE_VALUE) {\n    Pipe_.reset();\n    GlobalOutput.perror(\"TPipeServer::TCreateNamedPipe() GLE=\", lastError);\n    throw TTransportException(TTransportException::NOT_OPEN,\n                              \"TCreateNamedPipe() failed\",\n                lastError);\n    return false;\n  }\n\n  Pipe_.reset(hPipe.release());\n  return true;\n}\n\nbool TAnonPipeServer::createAnonPipe() {\n  SECURITY_ATTRIBUTES sa;\n  SECURITY_DESCRIPTOR sd;\n\n  InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);\n  SetSecurityDescriptorDacl(&sd, true, NULL, false);\n  sa.lpSecurityDescriptor = &sd;\n  sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n  sa.bInheritHandle = true;\n\n  HANDLE ClientAnonReadH, PipeW_H, ClientAnonWriteH, Pipe_H;\n  if (!CreatePipe(&ClientAnonReadH, &PipeW_H, &sa, 0))\n  {\n    GlobalOutput.perror(\"TPipeServer CreatePipe (anon) failed, GLE=\", GetLastError());\n    return false;\n  }\n  if (!CreatePipe(&Pipe_H, &ClientAnonWriteH, &sa, 0))\n  {\n    GlobalOutput.perror(\"TPipeServer CreatePipe (anon) failed, GLE=\", GetLastError());\n    CloseHandle(ClientAnonReadH);\n    CloseHandle(PipeW_H);\n    return false;\n  }\n\n  ClientAnonRead_.reset(ClientAnonReadH);\n  ClientAnonWrite_.reset(ClientAnonWriteH);\n  PipeR_.reset(Pipe_H);\n  PipeW_.reset(PipeW_H);\n\n  return true;\n}\n\n\n\n\nstd::string TPipeServer::getPipename() {\n  return pipename_;\n}\n\nvoid TPipeServer::setPipename(const std::string& pipename) {\n  if (pipename.find(\"\\\\\\\\\") == std::string::npos)\n    pipename_ = \"\\\\\\\\.\\\\pipe\\\\\" + pipename;\n  else\n    pipename_ = pipename;\n}\n\nint TPipeServer::getBufferSize() {\n  return bufsize_;\n}\nvoid TPipeServer::setBufferSize(int bufsize) {\n  bufsize_ = bufsize;\n}\n\nHANDLE TPipeServer::getPipeHandle() {\n  return impl_ ? impl_->getPipeHandle() : INVALID_HANDLE_VALUE;\n}\nHANDLE TPipeServer::getWrtPipeHandle() {\n  return impl_ ? impl_->getWrtPipeHandle() : INVALID_HANDLE_VALUE;\n}\nHANDLE TPipeServer::getClientRdPipeHandle() {\n  return impl_ ? impl_->getClientRdPipeHandle() : INVALID_HANDLE_VALUE;\n}\nHANDLE TPipeServer::getClientWrtPipeHandle() {\n  return impl_ ? impl_->getClientWrtPipeHandle() : INVALID_HANDLE_VALUE;\n}\n\nbool TPipeServer::getAnonymous() {\n  return isAnonymous_;\n}\nvoid TPipeServer::setAnonymous(bool anon) {\n  isAnonymous_ = anon;\n}\n\nvoid TPipeServer::setMaxConnections(uint32_t maxconnections) {\n  if (maxconnections == 0)\n    maxconns_ = 1;\n  else if (maxconnections > PIPE_UNLIMITED_INSTANCES)\n    maxconns_ = PIPE_UNLIMITED_INSTANCES;\n  else\n    maxconns_ = maxconnections;\n}\n\n#endif\n}\n}\n}\n\n'pyeos/externals/thrift/src/thrift/windows/Sync.h'\n:\n\n#ifndef _THRIFT_WINDOWS_Sync_H_\n#define _THRIFT_WINDOWS_Sync_H_ 1\n\n#ifndef _WIN32\n#error \"windows/Sync.h is only usable on Windows\"\n#endif\n\n#include <thrift/concurrency/Exception.h>\n#include <boost/noncopyable.hpp>\n#include <Windows.h>\n\n\n\nnamespace apache {\nnamespace thrift {\n\nstruct TCriticalSection : boost::noncopyable {\n  CRITICAL_SECTION cs;\n  TCriticalSection() { InitializeCriticalSection(&cs); }\n  ~TCriticalSection() { DeleteCriticalSection(&cs); }\n};\n\nclass TAutoCrit : boost::noncopyable {\nprivate:\n  CRITICAL_SECTION* cs_;\n\npublic:\n  explicit TAutoCrit(TCriticalSection& cs) : cs_(&cs.cs) { EnterCriticalSection(cs_); }\n  ~TAutoCrit() { LeaveCriticalSection(cs_); }\n};\n\nstruct TAutoResetEvent : boost::noncopyable {\n  HANDLE h;\n\n  TAutoResetEvent() {\n    h = CreateEvent(NULL, FALSE, FALSE, NULL);\n    if (h == NULL) {\n      GlobalOutput.perror(\"TAutoResetEvent unable to create event, GLE=\", GetLastError());\n      throw apache::thrift::concurrency::SystemResourceException(\"CreateEvent failed\");\n    }\n  }\n  ~TAutoResetEvent() { CloseHandle(h); }\n};\n\nstruct TManualResetEvent : boost::noncopyable {\n  HANDLE h;\n\n  TManualResetEvent() {\n    h = CreateEvent(NULL, TRUE, FALSE, NULL);\n    if (h == NULL) {\n      GlobalOutput.perror(\"TManualResetEvent unable to create event, GLE=\", GetLastError());\n      throw apache::thrift::concurrency::SystemResourceException(\"CreateEvent failed\");\n    }\n  }\n  ~TManualResetEvent() { CloseHandle(h); }\n};\n\nstruct TAutoHandle : boost::noncopyable {\n  HANDLE h;\n  explicit TAutoHandle(HANDLE h_ = INVALID_HANDLE_VALUE) : h(h_) {}\n  ~TAutoHandle() {\n    if (h != INVALID_HANDLE_VALUE)\n      CloseHandle(h);\n  }\n\n  HANDLE release() {\n    HANDLE retval = h;\n    h = INVALID_HANDLE_VALUE;\n    return retval;\n  }\n  void reset(HANDLE h_ = INVALID_HANDLE_VALUE) {\n    if (h_ == h)\n      return;\n    if (h != INVALID_HANDLE_VALUE)\n      CloseHandle(h);\n    h = h_;\n  }\n};\n}\n}\n\n#endif\n",
        "gt": [
            "'pyeos/externals/thrift/src/thrift/windows/Sync.h'",
            "'pyeos/externals/thrift/src/thrift/windows/OverlappedSubmissionThread.h'",
            "'pyeos/externals/thrift/src/thrift/transport/TPipeServer.cpp'"
        ]
    },
    {
        "files": [
            "'occt-import-js/occt-import-js/src/importer-xcaf.cpp'",
            "'occt-import-js/occt-import-js/src/importer-xcaf.hpp'",
            "'occt-import-js/occt-import-js/src/importer.hpp'"
        ],
        "content": "'occt-import-js/occt-import-js/src/importer-xcaf.cpp'\n:#include \"importer-xcaf.hpp\"\n#include \"importer-utils.hpp\"\n\n#include <TopExp_Explorer.hxx>\n#include <TopoDS.hxx>\n#include <TopoDS_Face.hxx>\n#include <TDF_ChildIterator.hxx>\n#include <TDocStd_Document.hxx>\n#include <TDataStd_Name.hxx>\n#include <Quantity_Color.hxx>\n#include <BRep_Tool.hxx>\n#include <XCAFDoc_DocumentTool.hxx>\n\nstatic std::string GetLabelNameNoRef (const TDF_Label& label)\n{\n    Handle (TDataStd_Name) nameAttribute = new TDataStd_Name ();\n    if (!label.FindAttribute (nameAttribute->GetID (), nameAttribute)) {\n        return std::string ();\n    }\n\n    Standard_Integer utf8NameLength = nameAttribute->Get ().LengthOfCString ();\n    char* nameBuf = new char[utf8NameLength + 1];\n    nameAttribute->Get ().ToUTF8CString (nameBuf);\n    std::string name (nameBuf, utf8NameLength);\n    delete[] nameBuf;\n    return name;\n}\n\nstatic std::string GetLabelName (const TDF_Label& label, const Handle (XCAFDoc_ShapeTool)& shapeTool)\n{\n    if (XCAFDoc_ShapeTool::IsReference (label)) {\n        TDF_Label referredShapeLabel;\n        shapeTool->GetReferredShape (label, referredShapeLabel);\n        return GetLabelName (referredShapeLabel, shapeTool);\n    }\n    return GetLabelNameNoRef (label);\n}\n\nstatic std::string GetShapeName (const TopoDS_Shape& shape, const Handle (XCAFDoc_ShapeTool)& shapeTool)\n{\n    TDF_Label shapeLabel;\n    if (!shapeTool->Search (shape, shapeLabel)) {\n        return std::string ();\n    }\n    return GetLabelName (shapeLabel, shapeTool);\n}\n\nstatic bool GetLabelColorNoRef (const TDF_Label& label, const Handle (XCAFDoc_ColorTool)& colorTool, Color& color)\n{\n    static const std::vector<XCAFDoc_ColorType> colorTypes = {\n        XCAFDoc_ColorSurf,\n        XCAFDoc_ColorCurv,\n        XCAFDoc_ColorGen\n    };\n\n    Quantity_Color qColor;\n    for (XCAFDoc_ColorType colorType : colorTypes) {\n        if (colorTool->GetColor (label, colorType, qColor)) {\n            color = Color (qColor.Red (), qColor.Green (), qColor.Blue ());\n            return true;\n        }\n    }\n\n    return false;\n}\n\nstatic bool GetLabelColor (const TDF_Label& label, const Handle (XCAFDoc_ShapeTool)& shapeTool, const Handle (XCAFDoc_ColorTool)& colorTool, Color& color)\n{\n    if (GetLabelColorNoRef (label, colorTool, color)) {\n        return true;\n    }\n\n    if (XCAFDoc_ShapeTool::IsReference (label)) {\n        TDF_Label referredShape;\n        shapeTool->GetReferredShape (label, referredShape);\n        return GetLabelColor (referredShape, shapeTool, colorTool, color);\n    }\n\n    return false;\n}\n\nstatic bool GetShapeColor (const TopoDS_Shape& shape, const Handle (XCAFDoc_ShapeTool)& shapeTool, const Handle (XCAFDoc_ColorTool)& colorTool, Color& color)\n{\n    TDF_Label shapeLabel;\n    if (!shapeTool->Search (shape, shapeLabel)) {\n        return false;\n    }\n    return GetLabelColor (shapeLabel, shapeTool, colorTool, color);\n}\n\nstatic bool IsFreeShape (const TDF_Label& label, const Handle (XCAFDoc_ShapeTool)& shapeTool)\n{\n    TopoDS_Shape tmpShape;\n    return shapeTool->GetShape (label, tmpShape) && shapeTool->IsFree (label);\n}\n\nclass XcafFace : public OcctFace\n{\npublic:\n    XcafFace (const TopoDS_Face& face, const Handle (XCAFDoc_ShapeTool)& shapeTool, const Handle (XCAFDoc_ColorTool)& colorTool) :\n        OcctFace (face),\n        shapeTool (shapeTool),\n        colorTool (colorTool)\n    {\n\n    }\n\n    virtual bool GetColor (Color& color) const override\n    {\n        return GetShapeColor ((const TopoDS_Shape&) face, shapeTool, colorTool, color);\n    }\n\nprivate:\n    const Handle (XCAFDoc_ShapeTool)& shapeTool;\n    const Handle (XCAFDoc_ColorTool)& colorTool;\n};\n\nclass XcafShapeMesh : public Mesh\n{\npublic:\n    XcafShapeMesh (const TopoDS_Shape& shape, const Handle (XCAFDoc_ShapeTool)& shapeTool, const Handle (XCAFDoc_ColorTool)& colorTool) :\n        Mesh (),\n        shape (shape),\n        shapeTool (shapeTool),\n        colorTool (colorTool)\n    {\n\n    }\n\n    virtual std::string GetName () const override\n    {\n        return GetShapeName (shape, shapeTool);\n    }\n\n    virtual bool GetColor (Color& color) const override\n    {\n        return GetShapeColor (shape, shapeTool, colorTool, color);\n    }\n\n    virtual void EnumerateFaces (const std::function<void (const Face& face)>& onFace) const override\n    {\n        for (TopExp_Explorer ex (shape, TopAbs_FACE); ex.More (); ex.Next ()) {\n            const TopoDS_Face& face = TopoDS::Face (ex.Current ());\n            XcafFace outputFace (face, shapeTool, colorTool);\n            onFace (outputFace);\n        }\n    }\n\nprivate:\n    const TopoDS_Shape& shape;\n    const Handle (XCAFDoc_ShapeTool)& shapeTool;\n    const Handle (XCAFDoc_ColorTool)& colorTool;\n};\n\nclass XcafStandaloneFacesMesh : public Mesh\n{\npublic:\n    XcafStandaloneFacesMesh (const TopoDS_Shape& shape, const Handle (XCAFDoc_ShapeTool)& shapeTool, const Handle (XCAFDoc_ColorTool)& colorTool) :\n        Mesh (),\n        shape (shape),\n        shapeTool (shapeTool),\n        colorTool (colorTool)\n    {\n\n    }\n\n    bool HasFaces () const\n    {\n        TopExp_Explorer ex (shape, TopAbs_FACE, TopAbs_SHELL);\n        return ex.More ();\n    }\n\n    virtual std::string GetName () const override\n    {\n        return std::string ();\n    }\n\n    virtual bool GetColor (Color&) const override\n    {\n        return false;\n    }\n\n    virtual void EnumerateFaces (const std::function<void (const Face& face)>& onFace) const override\n    {\n        for (TopExp_Explorer ex (shape, TopAbs_FACE, TopAbs_SHELL); ex.More (); ex.Next ()) {\n            const TopoDS_Face& face = TopoDS::Face (ex.Current ());\n            XcafFace outputFace (face, shapeTool, colorTool);\n            onFace (outputFace);\n        }\n    }\n\nprivate:\n    const TopoDS_Shape& shape;\n    const Handle (XCAFDoc_ShapeTool)& shapeTool;\n    const Handle (XCAFDoc_ColorTool)& colorTool;\n};\n\nclass XcafNode : public Node\n{\npublic:\n    XcafNode (const TDF_Label& label, const Handle (XCAFDoc_ShapeTool)& shapeTool, const Handle (XCAFDoc_ColorTool)& colorTool) :\n        label (label),\n        shapeTool (shapeTool),\n        colorTool (colorTool)\n    {\n\n    }\n\n    virtual std::string GetName () const override\n    {\n        return GetLabelName (label, shapeTool);\n    }\n\n    virtual std::vector<NodePtr> GetChildren () const override\n    {\n        if (IsMeshNode ()) {\n            return {};\n        }\n\n        std::vector<NodePtr> children;\n        for (TDF_ChildIterator it (label); it.More (); it.Next ()) {\n            TDF_Label childLabel = it.Value ();\n            if (IsFreeShape (childLabel, shapeTool)) {\n                children.push_back (std::make_shared<const XcafNode> (\n                    childLabel, shapeTool, colorTool\n                    ));\n            }\n        }\n        return children;\n    }\n\n    virtual bool IsMeshNode () const override\n    {\n\n        if (!label.HasChild ()) {\n            return true;\n        }\n\n\n        bool hasSubShapeChild = false;\n        for (TDF_ChildIterator it (label); it.More (); it.Next ()) {\n            TDF_Label childLabel = it.Value ();\n            if (shapeTool->IsSubShape (childLabel)) {\n                hasSubShapeChild = true;\n                break;\n            }\n        }\n        if (hasSubShapeChild) {\n            return true;\n        }\n\n\n        bool hasFreeShapeChild = false;\n        for (TDF_ChildIterator it (label); it.More (); it.Next ()) {\n            TDF_Label childLabel = it.Value ();\n            if (IsFreeShape (childLabel, shapeTool)) {\n                hasFreeShapeChild = true;\n                break;\n            }\n        }\n        if (!hasFreeShapeChild) {\n            return true;\n        }\n\n        return false;\n    }\n\n    virtual void EnumerateMeshes (const std::function<void (const Mesh&)>& onMesh) const override\n    {\n        if (!IsMeshNode ()) {\n            return;\n        }\n\n        TopoDS_Shape shape = shapeTool->GetShape (label);\n        EnumerateShapeMeshes (shape, onMesh);\n    }\n\nprivate:\n    void EnumerateShapeMeshes (const TopoDS_Shape& shape, const std::function<void (const Mesh&)>& onMesh) const\n    {\n\n        for (TopExp_Explorer ex (shape, TopAbs_SOLID); ex.More (); ex.Next ()) {\n            const TopoDS_Shape& currentShape = ex.Current ();\n            XcafShapeMesh outputShapeMesh (currentShape, shapeTool, colorTool);\n            onMesh (outputShapeMesh);\n        }\n\n\n        for (TopExp_Explorer ex (shape, TopAbs_SHELL, TopAbs_SOLID); ex.More (); ex.Next ()) {\n            const TopoDS_Shape& currentShape = ex.Current ();\n            XcafShapeMesh outputShapeMesh (currentShape, shapeTool, colorTool);\n            onMesh (outputShapeMesh);\n        }\n\n\n        XcafStandaloneFacesMesh standaloneFacesMesh (shape, shapeTool, colorTool);\n        if (standaloneFacesMesh.HasFaces ()) {\n            onMesh (standaloneFacesMesh);\n        }\n    }\n\n    TDF_Label label;\n    const Handle (XCAFDoc_ShapeTool)& shapeTool;\n    const Handle (XCAFDoc_ColorTool)& colorTool;\n};\n\nclass XcafRootNode : public Node\n{\npublic:\n    XcafRootNode (const Handle (XCAFDoc_ShapeTool)& shapeTool, const Handle (XCAFDoc_ColorTool)& colorTool, const ImportParams& params) :\n        shapeTool (shapeTool),\n        colorTool (colorTool),\n        params (params)\n    {\n\n    }\n\n    virtual std::string GetName () const override\n    {\n        return std::string ();\n    }\n\n    virtual std::vector<NodePtr> GetChildren () const override\n    {\n        TDF_Label mainLabel = shapeTool->Label ();\n\n        std::vector<NodePtr> children;\n        for (TDF_ChildIterator it (mainLabel); it.More (); it.Next ()) {\n            TDF_Label childLabel = it.Value ();\n            if (IsFreeShape (childLabel, shapeTool)) {\n                TopoDS_Shape shape = shapeTool->GetShape (childLabel);\n                if (!TriangulateShape (shape, params)) {\n                    continue;\n                }\n                children.push_back (std::make_shared<const XcafNode> (\n                    childLabel, shapeTool, colorTool\n                    ));\n            }\n        }\n\n        return children;\n    }\n\n    virtual bool IsMeshNode () const override\n    {\n        return false;\n    }\n\n    virtual void EnumerateMeshes (const std::function<void (const Mesh&)>&) const override\n    {\n\n    }\n\nprivate:\n    const Handle (XCAFDoc_ShapeTool)& shapeTool;\n    const Handle (XCAFDoc_ColorTool)& colorTool;\n    const ImportParams& params;\n};\n\nImporterXcaf::ImporterXcaf () :\n    Importer (),\n    document (nullptr),\n    shapeTool (nullptr),\n    colorTool (nullptr),\n    rootNode (nullptr)\n{\n\n}\n\nImporter::Result ImporterXcaf::LoadFile (const std::vector<std::uint8_t>& fileContent, const ImportParams& params)\n{\n    document = new TDocStd_Document (\"XmlXCAF\");\n\n    UnitsMethods_LengthUnit lengthUnit = LinearUnitToLengthUnit (params.linearUnit);\n    XCAFDoc_DocumentTool::SetLengthUnit (document, 1.0, lengthUnit);\n\n    if (!TransferToDocument (fileContent)) {\n        return Importer::Result::ImportFailed;\n    }\n\n    TDF_Label mainLabel = document->Main ();\n    shapeTool = XCAFDoc_DocumentTool::ShapeTool (mainLabel);\n    colorTool = XCAFDoc_DocumentTool::ColorTool (mainLabel);\n\n    TDF_LabelSequence labels;\n    shapeTool->GetFreeShapes (labels);\n    if (labels.IsEmpty ()) {\n        return Importer::Result::ImportFailed;\n    }\n\n    rootNode = std::make_shared<const XcafRootNode> (shapeTool, colorTool, params);\n    return Importer::Result::Success;\n}\n\nNodePtr ImporterXcaf::GetRootNode () const\n{\n    return rootNode;\n}\n\n'occt-import-js/occt-import-js/src/importer-xcaf.hpp'\n:#pragma once\n\n#include \"importer.hpp\"\n\n#include <TDocStd_Document.hxx>\n#include <XCAFDoc_ColorTool.hxx>\n#include <XCAFDoc_ShapeTool.hxx>\n\nclass ImporterXcaf : public Importer\n{\npublic:\n    ImporterXcaf ();\n\n    virtual Result LoadFile (const std::vector<std::uint8_t>& fileContent, const ImportParams& params) override;\n    virtual NodePtr GetRootNode () const override;\n\nprotected:\n    virtual bool TransferToDocument (const std::vector<std::uint8_t>& fileContent) = 0;\n\n    Handle (TDocStd_Document) document;\n    Handle (XCAFDoc_ShapeTool) shapeTool;\n    Handle (XCAFDoc_ColorTool) colorTool;\n    NodePtr rootNode;\n};\n\n'occt-import-js/occt-import-js/src/importer.hpp'\n:#pragma once\n\n#include <string>\n#include <vector>\n#include <memory>\n#include <functional>\n\nclass Node;\nclass Importer;\nusing NodePtr = std::shared_ptr<const Node>;\nusing ImporterPtr = std::shared_ptr<Importer>;\n\nclass Color\n{\npublic:\n    Color ();\n    Color (double r, double g, double b);\n\n    double r;\n    double g;\n    double b;\n};\n\nclass Face\n{\npublic:\n    Face ();\n    virtual ~Face ();\n\n    virtual bool HasNormals () const = 0;\n    virtual bool GetColor (Color& color) const = 0;\n\n    virtual void EnumerateVertices (const std::function<void (double, double, double)>& onVertex) const = 0;\n    virtual void EnumerateNormals (const std::function<void (double, double, double)>& onNormal) const = 0;\n    virtual void EnumerateTriangles (const std::function<void (int, int, int)>& onTriangle) const = 0;\n};\n\nclass Mesh\n{\npublic:\n    Mesh ();\n    virtual ~Mesh ();\n\n    virtual std::string GetName () const = 0;\n    virtual bool GetColor (Color& color) const = 0;\n    virtual void EnumerateFaces (const std::function<void (const Face& face)>& onFace) const = 0;\n};\n\nclass Node\n{\npublic:\n    Node ();\n    virtual ~Node ();\n\n    virtual std::string GetName () const = 0;\n    virtual std::vector<NodePtr> GetChildren () const = 0;\n\n    virtual bool IsMeshNode () const = 0;\n    virtual void EnumerateMeshes (const std::function<void (const Mesh&)>& onMesh) const = 0;\n};\n\nclass ImportParams\n{\npublic:\n    enum class LinearUnit\n    {\n        Millimeter,\n        Centimeter,\n        Meter,\n        Inch,\n        Foot\n    };\n\n    enum class LinearDeflectionType\n    {\n        BoundingBoxRatio,\n        AbsoluteValue\n    };\n\n    ImportParams ();\n\n    LinearUnit linearUnit;\n    LinearDeflectionType linearDeflectionType;\n    double linearDeflection;\n    double angularDeflection;\n};\n\nclass Importer\n{\npublic:\n    enum class Result\n    {\n        Success = 0,\n        FileNotFound = 1,\n        ImportFailed = 2\n    };\n\n    Importer ();\n    virtual ~Importer ();\n\n    Result LoadFile (const std::string& filePath, const ImportParams& params);\n\n    virtual Result LoadFile (const std::vector<std::uint8_t>& fileContent, const ImportParams& params) = 0;\n    virtual NodePtr GetRootNode () const = 0;\n};\n",
        "gt": [
            "'occt-import-js/occt-import-js/src/importer.hpp'",
            "'occt-import-js/occt-import-js/src/importer-xcaf.hpp'",
            "'occt-import-js/occt-import-js/src/importer-xcaf.cpp'"
        ]
    },
    {
        "files": [
            "'nymea/libnymea-core/scriptengine/scriptthings.cpp'",
            "'nymea/libnymea-core/scriptengine/scriptthings.h'",
            "'nymea/libnymea/integrations/thingmanager.h'",
            "'nymea/libnymea/types/browseraction.h'"
        ],
        "content": "'nymea/libnymea-core/scriptengine/scriptthings.cpp'\n:\n\n#include \"scriptthings.h\"\n#include \"scriptthing.h\"\n\n#include <qqml.h>\n#include <QQmlEngine>\n\n#include <QLoggingCategory>\nQ_DECLARE_LOGGING_CATEGORY(dcScriptEngine)\n\nnamespace nymeaserver {\nnamespace scriptengine {\n\nScriptThings::ScriptThings(QObject *parent)\n    : QSortFilterProxyModel{parent}\n{\n\n}\n\nvoid ScriptThings::classBegin()\n{\n    m_thingManager = reinterpret_cast<ThingManager*>(qmlEngine(this)->property(\"thingManager\").toULongLong());\n    m_model = new ThingsModel(m_thingManager, this);\n    setSourceModel(m_model);\n\n    connect(m_thingManager, &ThingManager::thingAdded, this, [this](Thing *newThing){\n        emit thingAdded(newThing->id().toString());\n        emit countChanged();\n    });\n    connect(m_thingManager, &ThingManager::thingRemoved, this, [this](const ThingId &thingId){\n        emit thingRemoved(thingId.toString());\n        emit countChanged();\n    });\n}\n\nvoid ScriptThings::componentComplete()\n{\n\n}\n\nQString ScriptThings::filterInterface() const\n{\n    return m_filterInterface;\n}\n\nvoid ScriptThings::setFilterInterface(const QString &filterInterface)\n{\n    if (m_filterInterface != filterInterface) {\n        m_filterInterface = filterInterface;\n        emit filterInterfaceChanged();\n        invalidateFilter();\n    }\n}\n\nScriptThing *ScriptThings::get(int index) const\n{\n    Thing *thing = m_model->get(mapToSource(this->index(index, 0)).row());\n    if (!thing) {\n        return nullptr;\n    }\n    ScriptThing *scriptThing = new ScriptThing(m_thingManager);\n    QQmlEngine::setObjectOwnership(scriptThing, QQmlEngine::JavaScriptOwnership);\n    scriptThing->setThingId(thing->id().toString());\n    return scriptThing;\n\n}\n\nScriptThing *ScriptThings::getThing(const QUuid &thingId) const\n{\n    Thing *thing = m_model->getThing(thingId);\n    if (!thing) {\n        return nullptr;\n    }\n    ScriptThing *scriptThing = new ScriptThing(m_thingManager);\n    QQmlEngine::setObjectOwnership(scriptThing, QQmlEngine::JavaScriptOwnership);\n    scriptThing->setThingId(thing->id().toString());\n    return scriptThing;\n}\n\nbool ScriptThings::filterAcceptsRow(int sourceRow, const QModelIndex &sourceParent) const\n{\n    Q_UNUSED(sourceParent)\n    Thing *thing = m_model->get(sourceRow);\n    if (!m_filterInterface.isEmpty() && !thing->thingClass().interfaces().contains(m_filterInterface)) {\n        return false;\n    }\n\n    return true;\n}\n\nThingsModel::ThingsModel(ThingManager *thingManager, QObject *parent):\n    QAbstractListModel(parent),\n    m_thingManager(thingManager)\n{\n}\n\nint ThingsModel::rowCount(const QModelIndex &parent) const\n{\n    Q_UNUSED(parent)\n    return m_thingManager->configuredThings().count();\n}\n\nQVariant ThingsModel::data(const QModelIndex &index, int role) const\n{\n    switch (role) {\n    case RoleId:\n        return m_thingManager->configuredThings().at(index.row())->id();\n    case RoleName:\n        return m_thingManager->configuredThings().at(index.row())->name();\n    }\n    return QVariant();\n}\n\nQHash<int, QByteArray> ThingsModel::roleNames() const\n{\n    return {\n        {RoleId, \"thingId\"},\n        {RoleName, \"thingName\"}\n    };\n}\n\nThing *ThingsModel::get(int index) const\n{\n    return m_thingManager->configuredThings().at(index);\n}\n\nThing *ThingsModel::getThing(const QUuid &thingId) const\n{\n    return m_thingManager->findConfiguredThing(thingId);\n}\n\n}\n}\n\n'nymea/libnymea-core/scriptengine/scriptthings.h'\n:\n\n#ifndef SCRIPTTHINGS_H\n#define SCRIPTTHINGS_H\n\n#include \"integrations/thingmanager.h\"\n\n#include <QObject>\n#include <QAbstractListModel>\n#include <QSortFilterProxyModel>\n#include <QQmlParserStatus>\n\n\nnamespace nymeaserver {\nnamespace scriptengine {\n\nclass ScriptThing;\nclass ThingsModel;\n\n\nclass ScriptThings : public QSortFilterProxyModel, public QQmlParserStatus\n{\n    Q_OBJECT\n    Q_PROPERTY(int count READ rowCount NOTIFY countChanged)\n    Q_PROPERTY(QString filterInterface READ filterInterface WRITE setFilterInterface NOTIFY filterInterfaceChanged)\n\npublic:\n    explicit ScriptThings(QObject *parent = nullptr);\n    void classBegin() override;\n    void componentComplete() override;\n\n    QString filterInterface() const;\n    void setFilterInterface(const QString &filterInterface);\n\n    Q_INVOKABLE nymeaserver::scriptengine::ScriptThing *get(int index) const;\n    Q_INVOKABLE nymeaserver::scriptengine::ScriptThing *getThing(const QUuid &thingId) const;\n\nsignals:\n    void countChanged();\n    void filterInterfaceChanged();\n    void thingAdded(const QString &thingId);\n    void thingRemoved(const QString &thingId);\n\nprotected:\n    bool filterAcceptsRow(int sourceRow, const QModelIndex &sourceParent) const override;\n\nprivate:\n    ThingManager *m_thingManager = nullptr;\n    ThingsModel *m_model = nullptr;\n\n    QString m_filterInterface;\n};\n\nclass ThingsModel: public QAbstractListModel\n{\n    Q_OBJECT\n\npublic:\n    enum Roles {\n        RoleId,\n        RoleName\n    };\n    ThingsModel(ThingManager *thingManager, QObject *parent = nullptr);\n\n    int rowCount(const QModelIndex &parent = QModelIndex()) const override;\n    QVariant data(const QModelIndex &index, int role) const override;\n    QHash<int, QByteArray> roleNames() const override;\n\n    Thing *get(int index) const;\n    Thing *getThing(const QUuid &thingId) const;\n\nsignals:\n    void countChanged();\n\nprivate:\n    ThingManager *m_thingManager = nullptr;\n\n};\n\n}\n}\n#endif\n\n'nymea/libnymea/integrations/thingmanager.h'\n:\n\n#ifndef THINGMANAGER_H\n#define THINGMANAGER_H\n\n#include <QObject>\n\n#include \"thing.h\"\n#include \"integrationplugin.h\"\n#include \"ioconnection.h\"\n#include \"types/interface.h\"\n#include \"types/vendor.h\"\n#include \"types/browseritem.h\"\n#include \"types/browseraction.h\"\n#include \"types/browseritemaction.h\"\n\nclass ThingManager : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit ThingManager(QObject *parent = nullptr);\n    virtual ~ThingManager() = default;\n\n    virtual IntegrationPlugins plugins() const = 0;\n    virtual IntegrationPlugin* plugin(const PluginId &pluginId) const = 0;\n    virtual Thing::ThingError setPluginConfig(const PluginId &pluginId, const ParamList &pluginConfig) = 0;\n\n    virtual Vendors supportedVendors() const = 0;\n    virtual Interfaces supportedInterfaces() const = 0;\n    virtual ThingClasses supportedThings(const VendorId &vendorId = VendorId()) const = 0;\n\n    virtual ThingClass findThingClass(const ThingClassId &thingClassId) const = 0;\n\n    virtual Things configuredThings() const = 0;\n    virtual Thing* findConfiguredThing(const ThingId &id) const = 0;\n    virtual Things findConfiguredThings(const ThingClassId &thingClassId) const = 0;\n    virtual Things findConfiguredThings(const QString &interface) const = 0;\n    virtual Things findChilds(const ThingId &id) const = 0;\n\n    virtual ThingDiscoveryInfo* discoverThings(const ThingClassId &thingClassId, const ParamList &params) = 0;\n\n    virtual ThingSetupInfo* addConfiguredThing(const ThingClassId &thingClassId, const ParamList &params, const QString &name = QString()) = 0;\n    virtual ThingSetupInfo* addConfiguredThing(const ThingDescriptorId &thingDescriptorId, const ParamList &params = ParamList(), const QString &name = QString()) = 0;\n\n    virtual ThingSetupInfo* reconfigureThing(const ThingId &thingId, const ParamList &params, const QString &name = QString()) = 0;\n    virtual ThingSetupInfo* reconfigureThing(const ThingDescriptorId &thingDescriptorId, const ParamList &params = ParamList(), const QString &name = QString()) = 0;\n\n    virtual ThingPairingInfo* pairThing(const ThingClassId &thingClassId, const ParamList &params, const QString &name = QString()) = 0;\n    virtual ThingPairingInfo* pairThing(const ThingDescriptorId &thingDescriptorId, const ParamList &params = ParamList(), const QString &name = QString()) = 0;\n    virtual ThingPairingInfo* pairThing(const ThingId &thingId, const ParamList &params, const QString &name = QString()) = 0;\n    virtual ThingPairingInfo* confirmPairing(const PairingTransactionId &pairingTransactionId, const QString &username = QString(), const QString &secret = QString()) = 0;\n\n    virtual Thing::ThingError editThing(const ThingId &thingId, const QString &name) = 0;\n    virtual Thing::ThingError setThingSettings(const ThingId &thingId, const ParamList &settings) = 0;\n\n    virtual Thing::ThingError setStateLogging(const ThingId &thingId, const StateTypeId &stateTypeId, bool enabled) = 0;\n    virtual Thing::ThingError setEventLogging(const ThingId &thingId, const EventTypeId &eventTypeId, bool enabled) = 0;\n    virtual Thing::ThingError setActionLogging(const ThingId &thingId, const ActionTypeId &actionTypeId, bool enabled) = 0;\n    virtual Thing::ThingError setStateFilter(const ThingId &thingId, const StateTypeId &stateTypeId, Types::StateValueFilter filter) = 0;\n\n    virtual Thing::ThingError removeConfiguredThing(const ThingId &thingId) = 0;\n\n    virtual ThingActionInfo* executeAction(const Action &action) = 0;\n\n    virtual BrowseResult* browseThing(const ThingId &thingId, const QString &itemId, const QLocale &locale) = 0;\n    virtual BrowserItemResult* browserItemDetails(const ThingId &thingId, const QString &itemId, const QLocale &locale) = 0;\n    virtual BrowserActionInfo* executeBrowserItem(const BrowserAction &browserAction) = 0;\n    virtual BrowserItemActionInfo* executeBrowserItemAction(const BrowserItemAction &browserItemAction) = 0;\n\n    virtual IOConnections ioConnections(const ThingId &thingId = ThingId()) const = 0;\n    IOConnectionResult connectIO(const ThingId &inputThing, const StateTypeId &inputState, const ThingId &outputThing, const StateTypeId &outputState, bool inverted = false);\n    virtual Thing::ThingError disconnectIO(const IOConnectionId &ioConnectionId) = 0;\n\n    virtual QString translate(const PluginId &pluginId, const QString &string, const QLocale &locale) = 0;\n    virtual ParamType translateParamType(const PluginId &pluginId, const ParamType &paramType, const QLocale &locale) = 0;\n    virtual StateType translateStateType(const PluginId &pluginId, const StateType &stateType, const QLocale &locale) = 0;\n    virtual EventType translateEventType(const PluginId &pluginId, const EventType &eventType, const QLocale &locale) = 0;\n    virtual ActionType translateActionType(const PluginId &pluginId, const ActionType &actionType, const QLocale &locale) = 0;\n    virtual ThingClass translateThingClass(const ThingClass &thingClass, const QLocale &locale) = 0;\n    virtual Vendor translateVendor(const Vendor &vendor, const QLocale &locale) = 0;\n\nprotected:\n    virtual IOConnectionResult connectIO(const IOConnection &connection) = 0;\n\nsignals:\n    void loaded();\n    void pluginConfigChanged(const PluginId &id, const ParamList &config);\n    void eventTriggered(const Event &event);\n    void thingStateChanged(Thing *thing, const StateTypeId &stateTypeId, const QVariant &value, const QVariant &minValue, const QVariant &maxValue, const QVariantList &possibleValues);\n    void thingRemoved(const ThingId &thingId);\n    void thingAdded(Thing *thing);\n    void thingChanged(Thing *thing);\n    void thingSettingChanged(const ThingId &thingId, const ParamTypeId &settingParamTypeId, const QVariant &value);\n    void ioConnectionAdded(const IOConnection &ioConnection);\n    void ioConnectionRemoved(const IOConnectionId &ioConnectionId);\n    void actionExecuted(const Action &action, Thing::ThingError status);\n};\n\n#endif\n\n'nymea/libnymea/types/browseraction.h'\n:\n\n#ifndef BROWSERACTION_H\n#define BROWSERACTION_H\n\n#include \"typeutils.h\"\n\nclass BrowserAction\n{\npublic:\n    explicit BrowserAction(const ThingId &thingId = ThingId(), const QString &itemId = QString());\n    BrowserAction(const BrowserAction &other);\n\n    bool isValid() const;\n\n    ThingId thingId() const;\n    QString itemId() const;\n\n    void operator=(const BrowserAction &other);\nprivate:\n    ThingId m_thingId;\n    QString m_itemId;\n};\n\n#endif\n",
        "gt": [
            "'nymea/libnymea/types/browseraction.h'",
            "'nymea/libnymea/integrations/thingmanager.h'",
            "'nymea/libnymea-core/scriptengine/scriptthings.h'",
            "'nymea/libnymea-core/scriptengine/scriptthings.cpp'"
        ]
    },
    {
        "files": [
            "'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/DeliveryNotifyMgr.h'",
            "'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/NetworkMgr.h'",
            "'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/TransmissionData.h'",
            "'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/RealTimeSrvWorld.cpp'",
            "'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/InFlightPacket.h'"
        ],
        "content": "'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/DeliveryNotifyMgr.h'\n:\n\n#pragma once\n#include <deque>\n#include \"BitStream.h\"\n#include \"InFlightPacket.h\"\n#include \"RealTimeSrvHelper.h\"\n#include \"AckBitField.h\"\n\nclass DeliveryNotifyMgr\n{\npublic:\n\n\n\tDeliveryNotifyMgr( bool inShouldSendAcks, bool inShouldProcessAcks );\n\t~DeliveryNotifyMgr();\n\n\tvoid\t\t\t\t\t\tReset();\n\tinline\tInFlightPacket*\t\tWriteState( OutputBitStream& inOutputStream );\n\tinline bool\t\t\t\t\tReadAndProcessState( InputBitStream& inInputStream );\n\n\tuint32_t\t\t\tGetDroppedPacketCount()\t\tconst { return mDroppedPacketCount; }\n\tuint32_t\t\t\tGetDeliveredPacketCount()\tconst { return mDeliveredPacketCount; }\n\tuint32_t\t\t\tGetDispatchedPacketCount()\tconst { return mDispatchedPacketCount; }\n\n\tconst std::deque< InFlightPacket >&\tGetInFlightPackets()\tconst { return mInFlightPackets; }\n\nprivate:\n\n\tInFlightPacket*\t\tWriteSequenceNumber( OutputBitStream& inOutputStream );\n\n\tbool ProcessSequenceNumber( InputBitStream& inInputStream );\n\n\tPacketSN\tmNextOutgoingSequenceNumber;\n\tPacketSN\tmNextExpectedSequenceNumber;\n\n\tstd::deque< InFlightPacket >\tmInFlightPackets;\n\n\tbool\t\t\t\t\tmShouldSendAcks;\n\tbool\t\t\t\t\tmShouldProcessAcks;\n\n\tuint32_t\t\tmDeliveredPacketCount;\n\tuint32_t\t\tmDroppedPacketCount;\n\tuint32_t\t\tmDispatchedPacketCount;\n\nprotected:\n\tAckBitField*\t\t\tmAckBitField;\n\n};\n\n\ninline InFlightPacket* DeliveryNotifyMgr::WriteState( OutputBitStream& inOutputStream )\n{\n\tInFlightPacket* toRet = WriteSequenceNumber( inOutputStream );\n\tif ( mShouldSendAcks )\n\t{\n\t\tmAckBitField->Write( inOutputStream );\n\t}\n\treturn toRet;\n}\n\ninline bool DeliveryNotifyMgr::ReadAndProcessState( InputBitStream& inInputStream )\n{\n\tbool toRet = ProcessSequenceNumber( inInputStream );\n\n\n\n\n\treturn toRet;\n}\n'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/NetworkMgr.h'\n:\n\n#pragma once\n\n#include <memory>\n#include <queue>\n#include <list>\n#include <unordered_map>\n#include \"Networking.h\"\n#include \"BitStream.h\"\n#include \"ReplicationMgr.h\"\n#include \"RealTimeSrvEntity.h\"\n#include \"DeliveryNotifyMgr.h\"\n#include \"WeightedTimedMovingAverage.h\"\n#include \"kcpsess/kcpsess.h\"\n\n\ntypedef std::unordered_map< int, RealTimeSrvEntityPtr > IntToGameObjectMap;\n\n\nclass NetworkMgr\n{\n\tenum NetworkClientState\n\t{\n\t\tNCS_Uninitialized,\n\t\tNCS_Resetting,\n\t\tNCS_Reseted,\n\t\tNCS_SayingHello,\n\t\tNCS_Welcomed\n\t};\npublic:\n\tstatic const uint32_t\tkHelloCC\t= 'HELO';\n\tstatic const uint32_t\tkWelcomeCC\t= 'WLCM';\n\tstatic const uint32_t\tkResetCC\t= 'RSET';\n\tstatic const uint32_t\tkResetedCC\t= 'RSTD';\n\tstatic const uint32_t\tkStateCC\t= 'STAT';\n\tstatic const uint32_t\tkInputCC\t= 'INPT';\n\n\tstatic const int\t\tkMaxPacketsPerFrameCount = 10;\n\n\tstatic float kTimeBufferStatePackets;\n\tstatic double kTimeBetweenStatePackets;\n\npublic:\n\tstatic std::unique_ptr<NetworkMgr>\tsInstance;\n\n\tstatic void StaticInit( const FString& inIP, int inPort );\n\n\tvoid\tUpdate();\n\n\tvoid\tSendPacket( const OutputBitStream& inOutputStream );\n\n\tvoid\tProcessIncomingPackets();\n\n\tvoid\tProcessPacket( InputBitStream& inInputStream );\n\n\tvoid\tSendOutgoingPackets();\n\n\tconst\tWeightedTimedMovingAverage&\t\tGetAvgRoundTripTime()\tconst { return mAvgRoundTripTime; }\n\tfloat\t\t\t\t\t\t\t\t\tGetRoundTripTime()\t\tconst { return mAvgRoundTripTime.GetValue(); }\n\n\tvoid\tSetDropPacketChance( float inChance ) { mDropPacketChance = inChance; }\n\tvoid\tSetSimulatedLatency( float inLatency ) { mSimulatedLatency = inLatency; }\n\tint\t\tGetPlayerId() const\t{ return mPlayerId; }\n\n\tRealTimeSrvEntityPtr\tGetGameObject( int inNetworkId ) const;\n\tvoid\tAddToNetworkIdToGameObjectMap( RealTimeSrvEntityPtr inGameObject );\n\tvoid\tRemoveFromNetworkIdToGameObjectMap( RealTimeSrvEntityPtr inGameObject );\n\n\tReplicationMgr GetReplicationManagerClient() { return mReplicationManagerClient; }\n\n\tvoid\tUpdateLastPacketFromSrvTime();\n\tfloat\tGetLastPacketFromClientTime()\tconst { return mLastPacketFromSrvTime; }\n\tvoid\tCheckForDisconnects();\n\tvoid\tResetForNewGame();\n\n\n\n\n\n\n\nprotected:\n\n\tIntToGameObjectMap\t\tmNetworkIdToGameObjectMap;\nprivate:\n\n\tNetworkMgr();\n\n\tvoid Init(\n\t\tconst FString& inYourChosenSocketName,\n\t\tconst FString& inIP,\n\t\tconst int32 inPort );\n\n\tvoid\tHandleResetPacket();\n\tvoid\tHandleWelcomePacket( InputBitStream& inInputStream );\n\n\tvoid\tUpdateBytesSentLastFrame();\n\n\n\tvoid\tRecombineSlicesToChunk( InputBitStream& inInputStream );\n\n\tvoid\tReadIncomingPacketsIntoQueue();\n\tvoid\tProcessQueuedPackets();\n\tvoid\tHandleStatePacket( InputBitStream& inInputStream );\n\tvoid\tReadLastMoveProcessedOnServerTimestamp( InputBitStream& inInputStream );\n\n\tvoid\tUpdateSendingInputPacket();\n\tvoid    SendInputPacket();\n\n\tvoid    UpdateSayingHello();\n\tvoid    SendHelloPacket();\n\n\tvoid DoSendPkt(const void* data, int len);\n\tkcpsess::KcpSession::InputData DoRecvPkt();\n\nprivate:\n\n\tDeliveryNotifyMgr\t\t\tmDeliveryNotificationManager;\n\tReplicationMgr\t\t\t\tmReplicationManagerClient;\n\n\n\tTSharedPtr<FInternetAddr>\tmRemoteAddr;\n\tFSocket*\t\t\t\t\tmSocket;\n\n\tNetworkClientState\t\t\tmState;\n\n\tfloat\t\t\t\t\t\tmTimeOfLastHello;\n\tfloat\t\t\t\t\t\tmTimeOfLastInputPacket;\n\n\tint\t\t\t\t\t\t\tmPlayerId;\n\tint\t\t\t\t\t\t\tmResetedPlayerId;\n\tfloat\t\t\t\t\t\tmLastMoveProcessedByServerTimestamp;\n\tfloat\t\t\t\t\t\tmLastRoundTripTime;\n\n\tfloat\t\t\t\t\t\tmDropPacketChance;\n\tfloat\t\t\t\t\t\tmSimulatedLatency;\n\n\tWeightedTimedMovingAverage\tmAvgRoundTripTime;\n\n\tfloat\t\t\t\t\t\tmLastCheckDCTime;\n\tfloat\t\t\t\t\t\tmLastPacketFromSrvTime;\n\n\tbool\t\t\t\t\t\tmIsReceivingSlicePacket;\n\tuint8_t\t\t\t\t\t\tmNextExpectedSlicedPacketIndex;\n\n\tInputBitStream\t\t\t\tmChunkInputStream;\n\tChunkPacketID\t\t\t\tmChunkPacketID;\n\nprivate:\n\tclass ReceivedPacket\n\t{\n\tpublic:\n\t\tReceivedPacket( float inReceivedTime, InputBitStream& inInputMemoryBitStream\n\n\t\t) :\n\t\t    mReceivedTime( inReceivedTime ),\n\n\t\t\tmPacketBuffer( inInputMemoryBitStream )\n\t\t{\n\t\t}\n\n\n\t\tfloat\t\t\t\t\tGetReceivedTime()\tconst { return mReceivedTime; }\n\t\tInputBitStream&\tGetPacketBuffer()   { return mPacketBuffer; }\n\n\tprivate:\n\n\t\tfloat\t\t\t\t\tmReceivedTime;\n\t\tInputBitStream\tmPacketBuffer;\n\n\n\t};\n\n\tstd::queue< ReceivedPacket, std::list< ReceivedPacket > >\tmPacketQueue;\n\n\n\tkcpsess::KcpSession::InputData kcpsessInputData_;\n\tstd::unique_ptr<kcpsess::KcpSession> kcpSession_;\n\tstatic const size_t kPacketBufSize = 1500;\n\tchar packetBuf_[kPacketBufSize];\n};\n\n'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/TransmissionData.h'\n:\n\n#pragma once\n#include <memory>\n\nclass DeliveryNotifyMgr;\n\nclass TransmissionData\n{\npublic:\n\tvirtual void HandleDeliveryFailure( DeliveryNotifyMgr* inDeliveryNotificationManager ) const = 0;\n\tvirtual void HandleDeliverySuccess( DeliveryNotifyMgr* inDeliveryNotificationManager ) const = 0;\n};\ntypedef std::shared_ptr< TransmissionData > TransmissionDataPtr;\n'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/RealTimeSrvWorld.cpp'\n:\n\n\n#include \"RealTimeSrvWorld.h\"\n#include \"NetworkMgr.h\"\n#include \"RealTimeSrvHelper.h\"\n\n\n\n\nstd::unique_ptr< RealTimeSrvWorld >\tRealTimeSrvWorld::sInstance;\n\nvoid RealTimeSrvWorld::StaticInit()\n{\n\tsInstance.reset( new RealTimeSrvWorld() );\n}\n\nRealTimeSrvWorld::RealTimeSrvWorld()\n{\n}\n\n\nvoid RealTimeSrvWorld::AddGameObject( RealTimeSrvEntityPtr inGameObject )\n{\n\tmGameObjects.push_back( inGameObject );\n\tinGameObject->SetIndexInWorld( mGameObjects.size() - 1 );\n}\n\nvoid RealTimeSrvWorld::ResetRealTimeSrvWorld()\n{\n\tfor ( int i = 0, c = mGameObjects.size(); i < c; ++i )\n\t{\n\t\tRealTimeSrvEntityPtr go = mGameObjects[i];\n\n\t\tRemoveGameObject( go );\n\t\tgo->HandleDying();\n\t\t--i;\n\t\t--c;\n\t}\n}\n\nvoid RealTimeSrvWorld::RemoveGameObject( RealTimeSrvEntityPtr inGameObject )\n{\n\tint index = inGameObject->GetIndexInWorld();\n\n\tint lastIndex = mGameObjects.size() - 1;\n\tif ( index != lastIndex )\n\t{\n\t\tmGameObjects[index] = mGameObjects[lastIndex];\n\t\tmGameObjects[index]->SetIndexInWorld( index );\n\t}\n\n\tinGameObject->SetIndexInWorld( -1 );\n\n\tmGameObjects.pop_back();\n}\n\n\nvoid RealTimeSrvWorld::Update()\n{\n\n\tfor ( int i = 0, c = mGameObjects.size(); i < c; ++i )\n\t{\n\t\tRealTimeSrvEntityPtr go = mGameObjects[i];\n\n\t\tif ( !go->DoesWantToDie() )\n\t\t{\n\t\t\tgo->Update();\n\t\t}\n\n\t\tif ( go->DoesWantToDie() )\n\t\t{\n\t\t\tRemoveGameObject( go );\n\t\t\tgo->HandleDying();\n\t\t\t--i;\n\t\t\t--c;\n\t\t}\n\t}\n}\n'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/InFlightPacket.h'\n:\n\n#pragma once\n#include <unordered_map>\n#include \"TransmissionData.h\"\n#include \"RealTimeSrvHelper.h\"\n\n\nclass DeliveryNotifyMgr;\n\nclass InFlightPacket\n{\npublic:\n\n\tInFlightPacket( PacketSN inSequenceNumber );\n\n\tPacketSN GetSequenceNumber() const { return mSequenceNumber; }\n\tfloat\t\t\t\t GetTimeDispatched() const { return mTimeDispatched; }\n\n\tvoid \t\t\t\t SetTransmissionData( int inKey, TransmissionDataPtr\tinTransmissionData )\n\t{\n\t\tmTransmissionDataMap[inKey] = inTransmissionData;\n\t}\n\tconst TransmissionDataPtr GetTransmissionData( int inKey ) const\n\t{\n\t\tauto it = mTransmissionDataMap.find( inKey );\n\t\treturn ( it != mTransmissionDataMap.end() ) ? it->second : nullptr;\n\t}\n\n\tvoid\t\t\tHandleDeliveryFailure( DeliveryNotifyMgr* inDeliveryNotificationManager ) const;\n\tvoid\t\t\tHandleDeliverySuccess( DeliveryNotifyMgr* inDeliveryNotificationManager ) const;\n\nprivate:\n\tPacketSN\tmSequenceNumber;\n\tfloat\t\t\tmTimeDispatched;\n\n\tstd::unordered_map< int, TransmissionDataPtr >\tmTransmissionDataMap;\n};",
        "gt": [
            "'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/TransmissionData.h'",
            "'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/InFlightPacket.h'",
            "'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/DeliveryNotifyMgr.h'",
            "'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/NetworkMgr.h'",
            "'realtime-server-ue4-demo/Source/UE4ClientDemo/RealTimeSrv/RealTimeSrvWorld.cpp'"
        ]
    },
    {
        "files": [
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/ext/ExtWire.cpp'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/ext/ExtWire.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/std/list.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/Buffer.h'"
        ],
        "content": "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/ext/ExtWire.cpp'\n:#include \"ExtWire.h\"\n\n#include \"protocol/Buffer.h\"\n\nnamespace rd\n{\nExtWire::ExtWire()\n{\n\tconnected.advise(Lifetime::Eternal(), [this](bool b) {\n\t\tif (b)\n\t\t{\n\t\t\t{\n\t\t\t\tstd::lock_guard<decltype(lock)> guard(lock);\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif (sendQ.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tauto it = std::move(sendQ.front());\n\t\t\t\t\tsendQ.pop();\n\t\t\t\t\trealWire->send(\n\t\t\t\t\t\tit.first, [payload = std::move(it.second)](Buffer& buffer) { buffer.write_byte_array_raw(payload); });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\nvoid ExtWire::advise(Lifetime lifetime, RdReactiveBase const* entity) const\n{\n\trealWire->advise(lifetime, entity);\n}\n\nvoid ExtWire::send(RdId const& id, std::function<void(Buffer& buffer)> writer) const\n{\n\t{\n\t\tstd::lock_guard<decltype(lock)> guard(lock);\n\t\tif (!sendQ.empty() || !connected.get())\n\t\t{\n\t\t\tBuffer buffer;\n\t\t\twriter(buffer);\n\t\t\tsendQ.emplace(id, buffer.getRealArray());\n\t\t\treturn;\n\t\t}\n\t}\n\trealWire->send(id, std::move(writer));\n}\n}\n\n'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/ext/ExtWire.h'\n:#ifndef RD_CPP_EXTWIRE_H\n#define RD_CPP_EXTWIRE_H\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable:4251)\n#endif\n\n#include \"base/IWire.h\"\n#include \"protocol/RdId.h\"\n#include \"protocol/Buffer.h\"\n\n#include <queue>\n#include <mutex>\n#include <functional>\n\n#include <rd_framework_export.h>\n\nnamespace rd\n{\nclass RD_FRAMEWORK_API ExtWire final : public IWire\n{\n\tmutable std::mutex lock;\n\n\tmutable std::queue<std::pair<RdId, Buffer::ByteArray> > sendQ;\n\npublic:\n\tExtWire();\n\n\tmutable IWire const* realWire = nullptr;\n\n\tvoid advise(Lifetime lifetime, RdReactiveBase const* entity) const override;\n\n\tvoid send(RdId const& id, std::function<void(Buffer& buffer)> writer) const override;\n};\n}\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\n#endif\n\n'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/std/list.h'\n:#ifndef RD_CPP_LIST_H\n#define RD_CPP_LIST_H\n\n#include <vector>\n#include <cstdint>\n\nnamespace rd\n{\ntemplate <typename T>\nint32_t size(T const& value) = delete;\n\n\n#if __cplusplus < 201703L\n\ntemplate <typename T, typename A>\nint32_t size(std::vector<T, A> const& value)\n{\n\treturn static_cast<int32_t>(value.size());\n}\n#else\ntemplate <typename T, typename A>\nint32_t size(std::vector<T, A> const& value)\n{\n\treturn std::size(value);\n}\n#endif\n\ntemplate <typename T, typename A>\nvoid resize(std::vector<T, A>& value, int32_t size)\n{\n\tvalue.resize(size);\n}\n}\n\n#endif\n\n'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/Buffer.h'\n:#ifndef RD_CPP_UNSAFEBUFFER_H\n#define RD_CPP_UNSAFEBUFFER_H\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable:4251)\n#endif\n\n#include \"types/DateTime.h\"\n#include \"util/core_util.h\"\n#include \"types/wrapper.h\"\n#include \"std/allocator.h\"\n#include \"std/list.h\"\n\n#include <vector>\n#include <type_traits>\n#include <functional>\n#include <memory>\n\n#include <rd_framework_export.h>\n\nnamespace rd\n{\n\nclass RD_FRAMEWORK_API Buffer final\n{\npublic:\n\tfriend class PkgInputStream;\n\n\tusing word_t = uint8_t;\n\n\tusing Allocator = std::allocator<word_t>;\n\n\tusing ByteArray = std::vector<word_t, Allocator>;\n\nprivate:\n\ttemplate <int>\n\tfriend std::wstring read_wstring_spec(Buffer&);\n\n\ttemplate <int>\n\tfriend void write_wstring_spec(Buffer&, wstring_view);\n\n\tByteArray data_;\n\n\tsize_t offset = 0;\n\n\n\tvoid read(word_t* dst, size_t size);\n\n\n\tvoid write(const word_t* src, size_t size);\n\n\tsize_t size() const;\n\npublic:\n\n\n\tBuffer();\n\n\texplicit Buffer(size_t initial_size);\n\n\texplicit Buffer(ByteArray array, size_t offset = 0);\n\n\tBuffer(Buffer const&) = delete;\n\n\tBuffer& operator=(Buffer const&) = delete;\n\n\tBuffer(Buffer&&) noexcept = default;\n\n\tBuffer& operator=(Buffer&&) noexcept = default;\n\n\n\n\tsize_t get_position() const;\n\n\tvoid set_position(size_t value);\n\n\tvoid require_available(size_t size);\n\n\tvoid check_available(size_t moreSize) const;\n\n\tvoid rewind();\n\n\ttemplate <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value, T>>\n\tT read_integral()\n\t{\n\t\tT result;\n\t\tread(reinterpret_cast<word_t*>(&result), sizeof(T));\n\t\treturn result;\n\t}\n\n\ttemplate <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value>>\n\tvoid write_integral(T const& value)\n\t{\n\t\twrite(reinterpret_cast<word_t const*>(&value), sizeof(T));\n\t}\n\n\ttemplate <typename T, typename = typename std::enable_if_t<std::is_floating_point<T>::value, T>>\n\tT read_floating_point()\n\t{\n\t\tT result;\n\t\tread(reinterpret_cast<word_t*>(&result), sizeof(T));\n\t\treturn result;\n\t}\n\n\ttemplate <typename T, typename = typename std::enable_if_t<std::is_floating_point<T>::value>>\n\tvoid write_floating_point(T const& value)\n\t{\n\t\twrite(reinterpret_cast<word_t const*>(&value), sizeof(T));\n\t}\n\n\ttemplate <template <class, class> class C, typename T, typename A = allocator<T>,\n\t\ttypename = typename std::enable_if_t<util::is_pod_v<T>>>\n\tC<T, A> read_array()\n\t{\n\t\tint32_t len = read_integral<int32_t>();\n\t\tRD_ASSERT_MSG(len >= 0, \"read null array(length = \" + std::to_string(len) + \")\");\n\t\tC<T, A> result;\n\t\tusing rd::resize;\n\t\tresize(result, len);\n\t\tif (len > 0)\n\t\t{\n\t\t\tread(reinterpret_cast<word_t*>(&result[0]), sizeof(T) * len);\n\t\t}\n\t\treturn result;\n\t}\n\n\ttemplate <template <class, class> class C, typename T, typename A = allocator<value_or_wrapper<T>>>\n\tC<value_or_wrapper<T>, A> read_array(std::function<value_or_wrapper<T>()> reader)\n\t{\n\t\tint32_t len = read_integral<int32_t>();\n\t\tC<value_or_wrapper<T>, A> result;\n\t\tusing rd::resize;\n\t\tresize(result, len);\n\t\tfor (int32_t i = 0; i < len; ++i)\n\t\t{\n\t\t\tresult[i] = std::move(reader());\n\t\t}\n\t\treturn result;\n\t}\n\n\ttemplate <template <class, class> class C, typename T, typename A = allocator<T>,\n\t\ttypename = typename std::enable_if_t<util::is_pod_v<T>>>\n\tvoid write_array(C<T, A> const& container)\n\t{\n\t\tusing rd::size;\n\t\tconst int32_t& len = rd::size(container);\n\t\twrite_integral<int32_t>(static_cast<int32_t>(len));\n\t\tif (len > 0)\n\t\t{\n\t\t\twrite(reinterpret_cast<word_t const*>(&container[0]), sizeof(T) * len);\n\t\t}\n\t}\n\n\ttemplate <template <class, class> class C, typename T, typename A = allocator<T>,\n\t\ttypename = typename std::enable_if_t<!rd::util::in_heap_v<T>>>\n\tvoid write_array(C<T, A> const& container, std::function<void(T const&)> writer)\n\t{\n\t\tusing rd::size;\n\t\twrite_integral<int32_t>(size(container));\n\t\tfor (auto const& e : container)\n\t\t{\n\t\t\twriter(e);\n\t\t}\n\t}\n\n\ttemplate <template <class, class> class C, typename T, typename A = allocator<Wrapper<T>>>\n\tvoid write_array(C<Wrapper<T>, A> const& container, std::function<void(T const&)> writer)\n\t{\n\t\tusing rd::size;\n\t\twrite_integral<int32_t>(size(container));\n\t\tfor (auto const& e : container)\n\t\t{\n\t\t\twriter(*e);\n\t\t}\n\t}\n\n\tvoid read_byte_array(ByteArray& array);\n\n\tvoid read_byte_array_raw(ByteArray& array);\n\n\tvoid write_byte_array_raw(ByteArray const& array);\n\n\n\n\n\n\tbool read_bool();\n\n\tvoid write_bool(bool value);\n\n\twchar_t read_char();\n\n\tvoid write_char(wchar_t value);\n\n\tvoid write_char16_string(const uint16_t* data, size_t len);\n\n\tuint16_t * read_char16_string();\n\n\tstd::wstring read_wstring();\n\n\tvoid write_wstring(std::wstring const& value);\n\n\tvoid write_wstring(wstring_view value);\n\n\tvoid write_wstring(Wrapper<std::wstring> const& value);\n\n\tDateTime read_date_time();\n\n\tvoid write_date_time(DateTime const& date_time);\n\n\ttemplate <typename T, typename = typename std::enable_if_t<util::is_enum_v<T>>>\n\tT read_enum()\n\t{\n\t\tint32_t x = read_integral<int32_t>();\n\t\treturn static_cast<T>(x);\n\t}\n\n\ttemplate <typename T, typename = typename std::enable_if_t<util::is_enum_v<T>>>\n\tvoid write_enum(T const& x)\n\t{\n\t\twrite_integral<int32_t>(static_cast<int32_t>(x));\n\t}\n\n\ttemplate <typename T, typename = typename std::enable_if_t<util::is_enum_v<T>>>\n\tT read_enum_set()\n\t{\n\t\tint32_t x = read_integral<int32_t>();\n\t\treturn static_cast<T>(x);\n\t}\n\n\ttemplate <typename T, typename = typename std::enable_if_t<util::is_enum_v<T>>>\n\tvoid write_enum_set(T const& x)\n\t{\n\t\twrite_integral<int32_t>(static_cast<int32_t>(x));\n\t}\n\n\ttemplate <typename T, typename F, typename = typename std::enable_if_t<util::is_same_v<typename util::result_of_t<F()>, T>>>\n\topt_or_wrapper<T> read_nullable(F&& reader)\n\t{\n\t\tbool nullable = !read_bool();\n\t\tif (nullable)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\t\treturn {reader()};\n\t}\n\n\ttemplate <typename T, typename F,\n\t\ttypename = typename std::enable_if_t<util::is_same_v<typename util::result_of_t<F()>, Wrapper<T>>>>\n\tWrapper<T> read_nullable(F&& reader)\n\t{\n\t\tbool nullable = !read_bool();\n\t\tif (nullable)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\t\treturn reader();\n\t}\n\n\ttemplate <typename T>\n\ttypename std::enable_if_t<!std::is_abstract<T>::value> write_nullable(\n\t\toptional<T> const& value, std::function<void(T const&)> writer)\n\t{\n\t\tif (!value)\n\t\t{\n\t\t\twrite_bool(false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twrite_bool(true);\n\t\t\twriter(*value);\n\t\t}\n\t}\n\n\ttemplate <typename T, typename F>\n\ttypename std::enable_if_t<!util::is_invocable_v<F, Wrapper<T>>> write_nullable(Wrapper<T> const& value, F&& writer)\n\t{\n\t\tif (!value)\n\t\t{\n\t\t\twrite_bool(false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twrite_bool(true);\n\t\t\twriter(*value);\n\t\t}\n\t}\n\n\ttemplate <typename T, typename F>\n\ttypename std::enable_if_t<util::is_invocable_v<F, Wrapper<T>>> write_nullable(Wrapper<T> const& value, F&& writer)\n\t{\n\t\tif (!value)\n\t\t{\n\t\t\twrite_bool(false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twrite_bool(true);\n\t\t\twriter(value);\n\t\t}\n\t}\n\n\tByteArray getArray() const&;\n\n\tByteArray getArray() &&;\n\n\tByteArray getRealArray() const&;\n\n\tByteArray getRealArray() &&;\n\n\tword_t const* data() const;\n\n\tword_t* data();\n\n\tword_t const* current_pointer() const;\n\n\tword_t* current_pointer();\n\n\tByteArray& get_data();\n};\n}\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\n#endif\n",
        "gt": [
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/std/list.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/Buffer.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/ext/ExtWire.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/ext/ExtWire.cpp'"
        ]
    },
    {
        "files": [
            "'knowrob/include/knowrob/queries/QueryContext.h'",
            "'knowrob/include/knowrob/semweb/GraphQueryExpansion.h'",
            "'knowrob/include/knowrob/storage/Transaction.h'",
            "'knowrob/src/storage/Transaction.cpp'",
            "'knowrob/include/knowrob/storage/QueryableStorage.h'"
        ],
        "content": "'knowrob/include/knowrob/queries/QueryContext.h'\n:\n\n#ifndef KNOWROB_QUERY_CONTEXT_H\n#define KNOWROB_QUERY_CONTEXT_H\n\n#include <utility>\n\n#include \"knowrob/formulas/ModalOperator.h\"\n#include \"knowrob/semweb/GraphSelector.h\"\n#include \"knowrob/queries/QueryFlag.h\"\n\nnamespace knowrob {\n\n\tstruct QueryContext {\n\t\texplicit QueryContext(int queryFlags = QUERY_FLAG_ALL_SOLUTIONS)\n\t\t\t\t: queryFlags(queryFlags), modalIteration(ModalIteration::emptyIteration()) {}\n\n\t\tQueryContext(const QueryContext &other, const ModalOperatorPtr &modalOperator)\n\t\t\t\t: queryFlags(other.queryFlags), modalIteration(other.modalIteration + modalOperator) {\n\t\t}\n\n\n\t\tint queryFlags;\n\n\t\tModalIteration modalIteration;\n\n\t\tGraphSelector selector;\n\t};\n\n\tusing QueryContextPtr = std::shared_ptr<const QueryContext>;\n};\n\n#endif\n\n'knowrob/include/knowrob/semweb/GraphQueryExpansion.h'\n:\n\n#ifndef KNOWROB_GRAPH_QUERY_EXPANSION_H\n#define KNOWROB_GRAPH_QUERY_EXPANSION_H\n\n#include \"knowrob/queries/QueryContext.h\"\n#include \"knowrob/semweb/GraphPathQuery.h\"\n#include \"knowrob/semweb/GraphQuery.h\"\n\nnamespace knowrob {\n\tstruct GraphQueryExpansion {\n\t\tGraphQueryExpansion() : counter(0), with_reassignment(false) {}\n\n\t\tGraphQueryPtr expanded;\n\t\tstd::vector<VariablePtr> o_vars;\n\t\tstd::vector<VariablePtr> u_vars;\n\t\tVariablePtr accumulated_begin;\n\t\tVariablePtr accumulated_end;\n\t\tQueryContextPtr query_ctx;\n\t\tuint32_t counter;\n\t\tbool with_reassignment;\n\t};\n\n\tusing GraphQueryExpansionPtr = std::shared_ptr<GraphQueryExpansion>;\n}\n\n#endif\n\n'knowrob/include/knowrob/storage/Transaction.h'\n:\n\n#ifndef KNOWROB_TRANSACTION_H\n#define KNOWROB_TRANSACTION_H\n\n#include \"memory\"\n#include \"knowrob/ThreadPool.h\"\n#include \"knowrob/storage/Storage.h\"\n#include \"knowrob/semweb/TripleContainer.h\"\n#include \"QueryableStorage.h\"\n#include \"knowrob/storage/ReificationContainer.h\"\n\nnamespace knowrob::transaction {\n\n\tclass Transaction {\n\tpublic:\n\t\tTransaction(const std::shared_ptr<QueryableStorage> &queryable,\n\t\t\t\t\tconst std::shared_ptr<Vocabulary> &vocabulary,\n\t\t\t\t\tbool isRemoval)\n\t\t\t\t: vocabulary_(vocabulary),\n\t\t\t\t  queryable_(queryable),\n\t\t\t\t  isRemoval_(isRemoval) {}\n\n\t\tvirtual ~Transaction() = default;\n\n\n\t\tvoid addBackend(const std::shared_ptr<NamedBackend> &backend) { backends_.push_back(backend); }\n\n\n\t\tbool commit(const Triple &triple);\n\n\n\t\tbool commit(const Triple &triple, const IRIAtomPtr &reifiedName);\n\n\n\t\tbool commit(const TripleContainerPtr &triples);\n\n\n\t\tbool commit(const TripleContainerPtr &triples, const ReifiedNames &reifiedNames);\n\n\tprotected:\n\t\tstd::shared_ptr<Vocabulary> vocabulary_;\n\t\tstd::shared_ptr<QueryableStorage> queryable_;\n\t\tstd::vector<std::shared_ptr<NamedBackend>> backends_;\n\t\tbool isRemoval_;\n\n\t\tbool commitProtected(const TripleContainerPtr &triple, const StoragePtr &backend);\n\n\t\tvirtual bool doCommit(const Triple &triple, const StoragePtr &backend) = 0;\n\n\t\tvirtual bool doCommit(const TripleContainerPtr &triples, const StoragePtr &backend) = 0;\n\n\t\tvirtual void updateVocabulary(const Triple &triple) = 0;\n\n\t\tstatic std::shared_ptr<ThreadPool::Runner> createTripleWorker(\n\t\t\t\tconst TripleContainerPtr &triples,\n\t\t\t\tconst std::function<void(const TriplePtr &)> &fn);\n\n\t\tIRIAtomPtr queryReifiedName(const Triple &triple);\n\t};\n\n\n\tclass Insert : public Transaction {\n\tpublic:\n\t\tInsert(const std::shared_ptr<QueryableStorage> &queryable, const std::shared_ptr<Vocabulary> &vocabulary)\n\t\t\t\t: Transaction(queryable, vocabulary, false) {}\n\n\tprotected:\n\t\tbool doCommit(const Triple &triple, const StoragePtr &backend) override;\n\n\t\tbool doCommit(const TripleContainerPtr &triples, const StoragePtr &backend) override;\n\n\t\tvoid updateVocabulary(const Triple &triple) override;\n\t};\n\n\n\tclass Remove : public Transaction {\n\tpublic:\n\t\tRemove(const std::shared_ptr<QueryableStorage> &queryable, const std::shared_ptr<Vocabulary> &vocabulary)\n\t\t\t\t: Transaction(queryable, vocabulary, true) {}\n\n\tprotected:\n\t\tbool doCommit(const Triple &triple, const StoragePtr &backend) override;\n\n\t\tbool doCommit(const TripleContainerPtr &triples, const StoragePtr &backend) override;\n\n\t\tvoid updateVocabulary(const Triple &triple) override;\n\t};\n}\n\n#endif\n\n'knowrob/src/storage/Transaction.cpp'\n:\n\n#include \"knowrob/storage/Transaction.h\"\n#include \"knowrob/storage/ReifiedTriple.h\"\n#include \"knowrob/storage/ReificationContainer.h\"\n#include \"knowrob/semweb/rdfs.h\"\n#include \"knowrob/semweb/owl.h\"\n#include \"knowrob/semweb/rdf.h\"\n#include \"knowrob/storage/ReifiedQuery.h\"\n#include \"knowrob/knowrob.h\"\n#include \"knowrob/integration/python/gil.h\"\n\nusing namespace knowrob;\nusing namespace knowrob::transaction;\n\nstatic void setReificationVariable(\n\t\tconst std::shared_ptr<GraphTerm> &t,\n\t\tconst VariablePtr &variable) {\n\tswitch (t->termType()) {\n\t\tcase knowrob::GraphTermType::Pattern: {\n\t\t\tauto &pattern = std::static_pointer_cast<GraphPattern>(t)->value();\n\t\t\tpattern->setSubjectTerm(variable);\n\t\t\tbreak;\n\t\t}\n\t\tcase knowrob::GraphTermType::Union:\n\t\tcase knowrob::GraphTermType::Sequence: {\n\t\t\tauto connective = std::static_pointer_cast<GraphConnective>(t);\n\t\t\tfor (auto &term: connective->terms()) {\n\t\t\t\tsetReificationVariable(term, variable);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase knowrob::GraphTermType::Builtin:\n\t\t\tbreak;\n\t};\n}\n\nIRIAtomPtr Transaction::queryReifiedName(const Triple &triple) {\n\tstatic auto v_reification = std::make_shared<Variable>(\"reification\");\n\tauto pat = std::make_shared<TriplePattern>(triple);\n\tauto query = std::make_shared<GraphPathQuery>(pat);\n\tauto reified = std::make_shared<ReifiedQuery>(query, vocabulary_);\n\tsetReificationVariable(reified->term(), v_reification);\n\n\tIRIAtomPtr reifiedName;\n\tqueryable_->query(reified, [&](const BindingsPtr &bindings) {\n\t\tauto t_reifiedName = bindings->get(v_reification->name());\n\t\tif (t_reifiedName && t_reifiedName->isIRI()) {\n\t\t\treifiedName = IRIAtom::Tabled(std::static_pointer_cast<IRIAtom>(t_reifiedName)->stringForm());\n\t\t}\n\t});\n\treturn reifiedName;\n}\n\nbool Transaction::commit(const Triple &triple) {\n\tstatic auto v_reification = std::make_shared<Variable>(\"reification\");\n\tif (isRemoval_ && ReifiedTriple::isReifiable(triple)) {\n\t\treturn commit(triple, queryReifiedName(triple));\n\t} else {\n\t\treturn commit(triple, nullptr);\n\t}\n}\n\nbool Transaction::commit(const Triple &triple, const IRIAtomPtr &reifiedName) {\n\tReifiedTriplePtr reification;\n\tbool success = true;\n\n\n\n\tupdateVocabulary(triple);\n\n\tfor (auto &definedBackend: backends_) {\n\t\tauto &backend = definedBackend->value();\n\t\tif (!backend->supports(StorageFeature::TripleContext) && ReifiedTriple::isReifiable(triple)) {\n\t\t\tif (!reification) reification = std::make_shared<ReifiedTriple>(triple, vocabulary_, reifiedName);\n\t\t\tfor (auto &reified: *reification) {\n\t\t\t\tsuccess = success && doCommit(*reified.ptr, backend);\n\t\t\t}\n\t\t} else {\n\t\t\tsuccess = doCommit(triple, backend);\n\t\t}\n\t\tif (!success) break;\n\t}\n\treturn success;\n}\n\nbool Transaction::commit(const TripleContainerPtr &triples) {\n\tstatic auto v_reification = std::make_shared<Variable>(\"reification\");\n\tif (isRemoval_ && !queryable_->supports(StorageFeature::TripleContext)) {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\tauto estimatedSize = GlobalSettings::batchSize();\n\t\tReifiedNames reifiedNames = std::make_shared<std::vector<IRIAtomPtr>>();\n\t\treifiedNames->reserve(estimatedSize);\n\t\tfor (auto &triple: *triples) {\n\t\t\tif (ReifiedTriple::isReifiable(*triple)) {\n\t\t\t\treifiedNames->push_back(queryReifiedName(*triple));\n\t\t\t} else {\n\t\t\t\treifiedNames->push_back(nullptr);\n\t\t\t}\n\t\t}\n\n\t\tif (reifiedNames->size() < estimatedSize) {\n\t\t\treifiedNames->resize(reifiedNames->size());\n\t\t}\n\t\treturn commit(triples, reifiedNames);\n\t} else {\n\t\treturn commit(triples, {});\n\t}\n}\n\nbool Transaction::commit(const TripleContainerPtr &triples, const ReifiedNames &reifiedNames) {\n\tTripleContainerPtr reified;\n\tstd::vector<std::shared_ptr<ThreadPool::Runner>> transactions;\n\tbool success = true;\n\n\n\n\tfor (auto &triple: *triples) {\n\t\tupdateVocabulary(*triple);\n\t}\n\n\tfor (auto &definedBackend: backends_) {\n\t\tauto &backend = definedBackend->value();\n\t\tconst TripleContainerPtr *backendTriples;\n\t\tif (!backend->supports(StorageFeature::TripleContext)) {\n\t\t\tif (!reified) reified = std::make_shared<ReificationContainer>(triples, vocabulary_, reifiedNames);\n\t\t\tbackendTriples = &reified;\n\t\t} else {\n\t\t\tbackendTriples = &triples;\n\t\t}\n\t\tauto worker = std::make_shared<ThreadPool::LambdaRunner>(\n\t\t\t\t[&](const std::function<bool()> &) { success = success && commitProtected(*backendTriples, backend); });\n\t\ttransactions.push_back(worker);\n\n\t\tDefaultThreadPool()->pushWork(worker,\n\t\t\t\t\t\t\t\t\t  [&definedBackend](const std::exception &exc) {\n\t\t\t\t\t\t\t\t\t\t  KB_ERROR(\"transaction failed for backend '{}': {}\", definedBackend->name(),\n\t\t\t\t\t\t\t\t\t\t\t\t   exc.what());\n\t\t\t\t\t\t\t\t\t  });\n\t}\n\n\tfor (auto &transaction: transactions) transaction->join();\n\n\treturn success;\n}\n\nbool Transaction::commitProtected(const TripleContainerPtr &triples, const StoragePtr &backend) {\n\tif (backend->storageLanguage() == PluginLanguage::PYTHON) {\n\t\tpy::gil_lock lock;\n\t\treturn doCommit(triples, backend);\n\t} else {\n\t\treturn doCommit(triples, backend);\n\t}\n}\n\nstd::shared_ptr<ThreadPool::Runner> Transaction::createTripleWorker(\n\t\tconst TripleContainerPtr &triples,\n\t\tconst std::function<void(const TriplePtr &)> &fn) {\n\tauto perTripleWorker =\n\t\t\tstd::make_shared<ThreadPool::LambdaRunner>([fn, triples](const ThreadPool::LambdaRunner::StopChecker &) {\n\t\t\t\tstd::for_each(triples->begin(), triples->end(), fn);\n\t\t\t});\n\tDefaultThreadPool()->pushWork(perTripleWorker,\n\t\t\t\t\t\t\t\t  [](const std::exception &exc) {\n\t\t\t\t\t\t\t\t\t  KB_ERROR(\"failed to perform per triple work: {}\", exc.what());\n\t\t\t\t\t\t\t\t  });\n\treturn perTripleWorker;\n}\n\nbool Insert::doCommit(const Triple &triple, const StoragePtr &backend) {\n\treturn backend->insertOne(triple);\n}\n\nbool Remove::doCommit(const Triple &triple, const StoragePtr &backend) {\n\treturn backend->removeOne(triple);\n}\n\nbool Insert::doCommit(const TripleContainerPtr &triples, const knowrob::StoragePtr &backend) {\n\treturn backend->insertAll(triples);\n}\n\nbool Remove::doCommit(const TripleContainerPtr &triples, const knowrob::StoragePtr &backend) {\n\treturn backend->removeAll(triples);\n}\n\nvoid Insert::updateVocabulary(const Triple &triple) {\n\n\tif (isSubClassOfIRI(triple.predicate())) {\n\t\tauto sub = vocabulary_->defineClass(triple.subject());\n\t\tauto sup = vocabulary_->defineClass(triple.valueAsString());\n\t\tsub->addDirectParent(sup, triple.graph());\n\t\tvocabulary_->increaseFrequency(rdfs::subClassOf->stringForm());\n\t} else if (isSubPropertyOfIRI(triple.predicate())) {\n\t\tauto sub = vocabulary_->defineProperty(triple.subject());\n\t\tauto sup = vocabulary_->defineProperty(triple.valueAsString());\n\t\tsub->addDirectParent(sup, triple.graph());\n\t\tvocabulary_->increaseFrequency(rdfs::subPropertyOf->stringForm());\n\t} else if (isTypeIRI(triple.predicate())) {\n\t\tvocabulary_->addResourceType(triple.subject(), triple.valueAsString());\n\n\t\tstatic std::set<std::string_view> skippedTypes = {\n\t\t\t\towl::Class->stringForm(),\n\t\t\t\towl::Restriction->stringForm(),\n\t\t\t\towl::NamedIndividual->stringForm(),\n\t\t\t\towl::AnnotationProperty->stringForm(),\n\t\t\t\towl::ObjectProperty->stringForm(),\n\t\t\t\towl::DatatypeProperty->stringForm(),\n\t\t\t\trdfs::Class->stringForm(),\n\t\t\t\trdf::Property->stringForm()\n\t\t};\n\t\tif (vocabulary_->isDefinedClass(triple.valueAsString()) &&\n\t\t\t!skippedTypes.count(triple.valueAsString())) {\n\t\t\tvocabulary_->increaseFrequency(triple.valueAsString());\n\t\t}\n\t\tvocabulary_->increaseFrequency(rdf::type->stringForm());\n\t} else if (isInverseOfIRI(triple.predicate())) {\n\t\tauto p = vocabulary_->defineProperty(triple.subject());\n\t\tauto q = vocabulary_->defineProperty(triple.valueAsString());\n\t\tp->setInverse(q);\n\t\tq->setInverse(p);\n\t\tvocabulary_->increaseFrequency(owl::inverseOf->stringForm());\n\t} else if (owl::imports->stringForm() == triple.predicate()) {\n\t\tauto resolvedImport = URI::resolve(triple.valueAsString());\n\t\tauto importedGraph = DataSource::getNameFromURI(resolvedImport);\n\t\tif (triple.graph()) {\n\t\t\tvocabulary_->importHierarchy()->addDirectImport(triple.graph().value(), importedGraph);\n\t\t} else {\n\t\t\tKB_WARN(\"import statement without graph\");\n\t\t}\n\t} else if (vocabulary_->isObjectProperty(triple.predicate()) ||\n\t\t\t   vocabulary_->isDatatypeProperty(triple.predicate())) {\n\n\t\tvocabulary_->increaseFrequency(triple.predicate());\n\t}\n}\n\nvoid Remove::updateVocabulary(const Triple &triple) {\n\n\tif (isSubClassOfIRI(triple.predicate())) {\n\t\tauto sub = vocabulary_->defineClass(triple.subject());\n\t\tauto sup = vocabulary_->defineClass(triple.valueAsString());\n\t\tsub->removeDirectParent(sup, triple.graph());\n\t} else if (isSubPropertyOfIRI(triple.predicate())) {\n\t\tauto sub = vocabulary_->defineProperty(triple.subject());\n\t\tauto sup = vocabulary_->defineProperty(triple.valueAsString());\n\t\tsub->removeDirectParent(sup, triple.graph());\n\t}\n}\n\n'knowrob/include/knowrob/storage/QueryableStorage.h'\n:\n\n#ifndef KNOWROB_QUERYABLE_STORAGE_H\n#define KNOWROB_QUERYABLE_STORAGE_H\n\n#include \"knowrob/queries/TokenBuffer.h\"\n#include \"Storage.h\"\n#include \"knowrob/queries/Answer.h\"\n#include \"knowrob/semweb/GraphPathQuery.h\"\n#include \"knowrob/queries/AnswerYes.h\"\n#include \"knowrob/queries/AnswerNo.h\"\n#include \"knowrob/semweb/GraphConnective.h\"\n#include \"knowrob/semweb/GraphQueryExpansion.h\"\n#include \"VersionedOrigin.h\"\n\nnamespace knowrob {\n\tusing ResourceCounter = std::function<void(std::string_view, uint64_t)>;\n\n\n\tclass QueryableStorage : public Storage {\n\tpublic:\n\t\tstatic AtomPtr versionProperty;\n\n\t\texplicit QueryableStorage(StorageFeatures features = StorageFeature::NothingSpecial);\n\n\t\t~QueryableStorage() override = default;\n\n\n\t\tvirtual bool isPersistent() const = 0;\n\n\n\t\tvirtual void foreach(const TripleVisitor &visitor) const;\n\n\n\t\tvirtual void batch(const TripleHandler &callback) const = 0;\n\n\n\t\tvirtual void batchOrigin(std::string_view origin, const TripleHandler &callback) = 0;\n\n\n\t\tvirtual bool contains(const Triple &triple);\n\n\n\t\tvirtual void match(const TriplePattern &query, const TripleVisitor &visitor);\n\n\n\t\tvirtual void query(const GraphQueryPtr &query, const BindingsHandler &callback) = 0;\n\n\n\t\tvirtual void count(const ResourceCounter &callback) const = 0;\n\n\n\t\tstd::vector<VersionedOriginPtr> getOrigins();\n\n\n\t\tstd::optional<std::string> getVersionOfOrigin(std::string_view origin);\n\n\n\t\tvoid setVersionOfOrigin(std::string_view origin, std::string_view version);\n\n\n\t\tvoid dropSessionOrigins();\n\n\n\t\tGraphQueryExpansionPtr expand(const GraphQueryPtr &q);\n\n\n\t\tstatic std::shared_ptr<AnswerYes> yes(const GraphPathQueryPtr &original,\n\t\t\t\t\t\t\t\t\t\t\t  const GraphQueryExpansionPtr &expansion,\n\t\t\t\t\t\t\t\t\t\t\t  const BindingsPtr &bindings);\n\n\n\t\tstatic std::shared_ptr<AnswerNo> no(const GraphPathQueryPtr &q);\n\t};\n\n\tusing QueryableBackendPtr = std::shared_ptr<QueryableStorage>;\n}\n\n#endif\n",
        "gt": [
            "'knowrob/include/knowrob/queries/QueryContext.h'",
            "'knowrob/include/knowrob/semweb/GraphQueryExpansion.h'",
            "'knowrob/include/knowrob/storage/QueryableStorage.h'",
            "'knowrob/include/knowrob/storage/Transaction.h'",
            "'knowrob/src/storage/Transaction.cpp'"
        ]
    },
    {
        "files": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/runge_kutta_cash_karp54.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/numeric/symplectic.cpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/util/resizer.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint.hpp'"
        ],
        "content": "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/runge_kutta_cash_karp54.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_STEPPER_RUNGE_KUTTA_CASH_KARP54_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_STEPPER_RUNGE_KUTTA_CASH_KARP54_HPP_INCLUDED\n\n#include <boost/fusion/container/vector.hpp>\n#include <boost/fusion/container/generation/make_vector.hpp>\n\n#include <boost/numeric/odeint/stepper/explicit_error_generic_rk.hpp>\n#include <boost/numeric/odeint/algebra/range_algebra.hpp>\n#include <boost/numeric/odeint/algebra/default_operations.hpp>\n\n#include <boost/numeric/odeint/util/state_wrapper.hpp>\n#include <boost/numeric/odeint/util/is_resizeable.hpp>\n#include <boost/numeric/odeint/util/resizer.hpp>\n\n#include <boost/array.hpp>\n\n\n\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\n\n#ifndef DOXYGEN_SKIP\ntemplate< class Value = double >\nstruct rk54_ck_coefficients_a1 : boost::array< Value , 1 >\n{\n    rk54_ck_coefficients_a1( void )\n    {\n        (*this)[0] = static_cast< Value >( 1 )/static_cast< Value >( 5 );\n    }\n};\n\ntemplate< class Value = double >\nstruct rk54_ck_coefficients_a2 : boost::array< Value , 2 >\n{\n    rk54_ck_coefficients_a2( void )\n    {\n        (*this)[0] = static_cast<Value>( 3 )/static_cast<Value>( 40 );\n        (*this)[1] = static_cast<Value>( 9 )/static_cast<Value>( 40 );\n    }\n};\n\n\ntemplate< class Value = double >\nstruct rk54_ck_coefficients_a3 : boost::array< Value , 3 >\n{\n    rk54_ck_coefficients_a3( void )\n    {\n        (*this)[0] = static_cast<Value>( 3 )/static_cast<Value>( 10 );\n        (*this)[1] = static_cast<Value>( -9 )/static_cast<Value>( 10 );\n        (*this)[2] = static_cast<Value>( 6 )/static_cast<Value>( 5 );\n    }\n};\n\ntemplate< class Value = double >\nstruct rk54_ck_coefficients_a4 : boost::array< Value , 4 >\n{\n    rk54_ck_coefficients_a4( void )\n    {\n        (*this)[0] = static_cast<Value>( -11 )/static_cast<Value>( 54 );\n        (*this)[1] = static_cast<Value>( 5 )/static_cast<Value>( 2 );\n        (*this)[2] = static_cast<Value>( -70 )/static_cast<Value>( 27 );\n        (*this)[3] = static_cast<Value>( 35 )/static_cast<Value>( 27 );\n    }\n};\n\ntemplate< class Value = double >\nstruct rk54_ck_coefficients_a5 : boost::array< Value , 5 >\n{\n    rk54_ck_coefficients_a5( void )\n    {\n        (*this)[0] = static_cast<Value>( 1631 )/static_cast<Value>( 55296 );\n        (*this)[1] = static_cast<Value>( 175 )/static_cast<Value>( 512 );\n        (*this)[2] = static_cast<Value>( 575 )/static_cast<Value>( 13824 );\n        (*this)[3] = static_cast<Value>( 44275 )/static_cast<Value>( 110592 );\n        (*this)[4] = static_cast<Value>( 253 )/static_cast<Value>( 4096 );\n    }\n};\n\ntemplate< class Value = double >\nstruct rk54_ck_coefficients_b : boost::array< Value , 6 >\n{\n    rk54_ck_coefficients_b( void )\n    {\n        (*this)[0] = static_cast<Value>( 37 )/static_cast<Value>( 378 );\n        (*this)[1] = static_cast<Value>( 0 );\n        (*this)[2] = static_cast<Value>( 250 )/static_cast<Value>( 621 );\n        (*this)[3] = static_cast<Value>( 125 )/static_cast<Value>( 594 );\n        (*this)[4] = static_cast<Value>( 0 );\n        (*this)[5] = static_cast<Value>( 512 )/static_cast<Value>( 1771 );\n    }\n};\n\ntemplate< class Value = double >\nstruct rk54_ck_coefficients_db : boost::array< Value , 6 >\n{\n    rk54_ck_coefficients_db( void )\n    {\n        (*this)[0] = static_cast<Value>( 37 )/static_cast<Value>( 378 ) - static_cast<Value>( 2825 )/static_cast<Value>( 27648 );\n        (*this)[1] = static_cast<Value>( 0 );\n        (*this)[2] = static_cast<Value>( 250 )/static_cast<Value>( 621 ) - static_cast<Value>( 18575 )/static_cast<Value>( 48384 );\n        (*this)[3] = static_cast<Value>( 125 )/static_cast<Value>( 594 ) - static_cast<Value>( 13525 )/static_cast<Value>( 55296 );\n        (*this)[4] = static_cast<Value>( -277 )/static_cast<Value>( 14336 );\n        (*this)[5] = static_cast<Value>( 512 )/static_cast<Value>( 1771 ) - static_cast<Value>( 1 )/static_cast<Value>( 4 );\n    }\n};\n\n\ntemplate< class Value = double >\nstruct rk54_ck_coefficients_c : boost::array< Value , 6 >\n{\n    rk54_ck_coefficients_c( void )\n    {\n        (*this)[0] = static_cast<Value>(0);\n        (*this)[1] = static_cast<Value>( 1 )/static_cast<Value>( 5 );\n        (*this)[2] = static_cast<Value>( 3 )/static_cast<Value>( 10 );\n        (*this)[3] = static_cast<Value>( 3 )/static_cast<Value>( 5 );\n        (*this)[4] = static_cast<Value>( 1 );\n        (*this)[5] = static_cast<Value>( 7 )/static_cast<Value>( 8 );\n    }\n};\n#endif\n\n\ntemplate<\n    class State ,\n    class Value = double ,\n    class Deriv = State ,\n    class Time = Value ,\n    class Algebra = range_algebra ,\n    class Operations = default_operations ,\n    class Resizer = initially_resizer\n    >\n#ifndef DOXYGEN_SKIP\nclass runge_kutta_cash_karp54 : public explicit_error_generic_rk< 6 , 5 , 5 , 4 ,\n        State , Value , Deriv , Time , Algebra , Operations , Resizer >\n#else\nclass runge_kutta_cash_karp54 : public explicit_error_generic_rk\n#endif\n{\n\npublic:\n#ifndef DOXYGEN_SKIP\n    typedef explicit_error_generic_rk< 6 , 5 , 5 , 4 , State , Value , Deriv , Time ,\n                               Algebra , Operations , Resizer > stepper_base_type;\n#endif\n    typedef typename stepper_base_type::state_type state_type;\n    typedef typename stepper_base_type::value_type value_type;\n    typedef typename stepper_base_type::deriv_type deriv_type;\n    typedef typename stepper_base_type::time_type time_type;\n    typedef typename stepper_base_type::algebra_type algebra_type;\n    typedef typename stepper_base_type::operations_type operations_type;\n    typedef typename stepper_base_type::resizer_type resizer_typ;\n\n    #ifndef DOXYGEN_SKIP\n    typedef typename stepper_base_type::stepper_type stepper_type;\n    typedef typename stepper_base_type::wrapped_state_type wrapped_state_type;\n    typedef typename stepper_base_type::wrapped_deriv_type wrapped_deriv_type;\n    #endif\n\n\n    runge_kutta_cash_karp54( const algebra_type &algebra = algebra_type() ) : stepper_base_type(\n        boost::fusion::make_vector( rk54_ck_coefficients_a1<Value>() ,\n                                 rk54_ck_coefficients_a2<Value>() ,\n                                 rk54_ck_coefficients_a3<Value>() ,\n                                 rk54_ck_coefficients_a4<Value>() ,\n                                 rk54_ck_coefficients_a5<Value>() ) ,\n            rk54_ck_coefficients_b<Value>() , rk54_ck_coefficients_db<Value>() , rk54_ck_coefficients_c<Value>() ,\n            algebra )\n    { }\n};\n\n\n\n\n\n\n\n\n}\n}\n}\n\n#endif\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/numeric/symplectic.cpp'\n:\n\n\n#include <boost/config.hpp>\n#ifdef BOOST_MSVC\n    #pragma warning(disable:4996)\n#endif\n\n#define BOOST_TEST_MODULE numeric_symplectic\n\n#include <iostream>\n#include <cmath>\n\n#include <boost/array.hpp>\n\n#include <boost/test/unit_test.hpp>\n\n#include <boost/mpl/vector.hpp>\n\n#include <boost/numeric/odeint.hpp>\n\nusing namespace boost::unit_test;\nusing namespace boost::numeric::odeint;\nnamespace mpl = boost::mpl;\n\ntypedef double value_type;\n\ntypedef boost::array< double ,1 > state_type;\n\n\nstruct osc\n{\n    void operator()( const state_type &q , state_type &dpdt ) const\n    {\n        dpdt[0] = -q[0];\n    }\n};\n\nBOOST_AUTO_TEST_SUITE( numeric_symplectic_test )\n\n\n\ntemplate< class Stepper >\nstruct perform_symplectic_test\n{\n    void operator()( void )\n    {\n\n        Stepper stepper;\n        const int o = stepper.order()+1;\n\n        const state_type q0 = {{ 0.0 }};\n        const state_type p0 = {{ 1.0 }};\n        state_type q1,p1;\n        std::pair< state_type , state_type >x1( q1 , p1 );\n        const double t = 0.0;\n\n        double dt = 0.5;\n        stepper.do_step( osc() , std::make_pair( q0 , p0 ) , t , x1 , dt );\n        const double f = 2.0 * std::abs( sin(dt) - x1.first[0] ) / std::pow( dt , o );\n\n        std::cout << o << \" , \" << f << std::endl;\n\n\n        while( f*std::pow( dt , o ) > 1E-16 )\n        {\n            stepper.do_step( osc() , std::make_pair( q0 , p0 ) , t , x1 , dt );\n            std::cout << \"Testing dt=\" << dt << std::endl;\n            BOOST_CHECK_SMALL( std::abs( sin(dt) - x1.first[0] ) , f*std::pow( dt , o ) );\n            dt *= 0.5;\n        }\n    }\n};\n\n\ntypedef mpl::vector<\n    symplectic_euler< state_type > ,\n    symplectic_rkn_sb3a_mclachlan< state_type >\n    > symplectic_steppers;\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( symplectic_test , Stepper, symplectic_steppers )\n{\n    perform_symplectic_test< Stepper > tester;\n    tester();\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/util/resizer.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_UTIL_RESIZER_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_UTIL_RESIZER_HPP_INCLUDED\n\n\n#include <boost/numeric/odeint/util/is_resizeable.hpp>\n#include <boost/numeric/odeint/util/same_size.hpp>\n#include <boost/numeric/odeint/util/resize.hpp>\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\ntemplate< class ResizeWrappedState , class State >\nbool adjust_size_by_resizeability( ResizeWrappedState &x , const State &y , boost::true_type )\n{\n    if ( !same_size( x.m_v , y ) )\n    {\n        resize( x.m_v , y );\n        return true;\n    }\n    else\n        return false;\n}\n\ntemplate< class ResizeWrappedState , class State >\nbool adjust_size_by_resizeability( ResizeWrappedState &  , const State &  , boost::false_type )\n{\n    return false;\n}\n\nstruct always_resizer\n{\n    template< class State , class ResizeFunction >\n    bool adjust_size( const State &x , ResizeFunction f )\n    {\n        return f( x );\n    }\n};\n\n\nstruct initially_resizer\n{\n\n    bool m_initialized;\n\n    initially_resizer() : m_initialized( false )\n    { }\n\n    template< class State , class ResizeFunction >\n    bool adjust_size( const State &x , ResizeFunction f )\n    {\n        if( !m_initialized )\n        {\n            m_initialized = true;\n            return f( x );\n        } else\n            return false;\n    }\n};\n\n\nstruct never_resizer\n{\n    template< class State , class ResizeFunction >\n    bool adjust_size( const State &x , ResizeFunction f )\n    {\n        return false;\n    }\n};\n\n\n}\n}\n}\n\n#endif\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_HPP_INCLUDED\n\n#include <boost/numeric/odeint/version.hpp>\n#include <boost/numeric/odeint/config.hpp>\n\n\n#include <boost/numeric/odeint/util/ublas_wrapper.hpp>\n\n#include <boost/numeric/odeint/stepper/euler.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta4_classic.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta4.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta_cash_karp54.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta_cash_karp54_classic.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta_dopri5.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta_fehlberg78.hpp>\n\n#include <boost/numeric/odeint/stepper/controlled_runge_kutta.hpp>\n\n#include <boost/numeric/odeint/stepper/dense_output_runge_kutta.hpp>\n\n#include <boost/numeric/odeint/stepper/bulirsch_stoer.hpp>\n\n#ifndef __CUDACC__\n\n#include <boost/numeric/odeint/stepper/bulirsch_stoer_dense_out.hpp>\n#endif\n\n#include <boost/numeric/odeint/stepper/symplectic_euler.hpp>\n#include <boost/numeric/odeint/stepper/symplectic_rkn_sb3a_mclachlan.hpp>\n\n#include <boost/numeric/odeint/stepper/adams_bashforth_moulton.hpp>\n\n#include <boost/numeric/odeint/stepper/implicit_euler.hpp>\n#include <boost/numeric/odeint/stepper/rosenbrock4.hpp>\n#include <boost/numeric/odeint/stepper/rosenbrock4_controller.hpp>\n#include <boost/numeric/odeint/stepper/rosenbrock4_dense_output.hpp>\n\n\n\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n\n#include <boost/numeric/odeint/integrate/integrate.hpp>\n#include <boost/numeric/odeint/integrate/integrate_adaptive.hpp>\n#include <boost/numeric/odeint/integrate/integrate_const.hpp>\n#include <boost/numeric/odeint/integrate/integrate_n_steps.hpp>\n#include <boost/numeric/odeint/integrate/integrate_times.hpp>\n\n#include <boost/numeric/odeint/integrate/observer_collection.hpp>\n\n#include <boost/numeric/odeint/stepper/generation.hpp>\n\n\n#endif\n",
        "gt": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/util/resizer.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/runge_kutta_cash_karp54.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/numeric/symplectic.cpp'"
        ]
    },
    {
        "files": [
            "'LittleEngineVk/scene/src/imcpp/scene_graph.cpp'",
            "'LittleEngineVk/scene/include/le/scene/imcpp/scene_graph.hpp'",
            "'LittleEngineVk/engine/include/le/imcpp/common.hpp'",
            "'LittleEngineVk/scene/include/le/scene/imcpp/scene_inspector.hpp'"
        ],
        "content": "'LittleEngineVk/scene/src/imcpp/scene_graph.cpp'\n:#include <imgui.h>\n#include <le/core/fixed_string.hpp>\n#include <le/imcpp/reflector.hpp>\n#include <le/scene/imcpp/scene_graph.hpp>\n#include <le/scene/scene.hpp>\n#include <le/scene/scene_manager.hpp>\n\nnamespace le::imcpp {\nauto SceneGraph::check_stale() -> bool {\n\tbool ret = false;\n\tif (m_scene != m_prev) {\n\t\tm_prev = m_scene;\n\t\tm_scene_inspector.target = {};\n\t\tret = true;\n\t}\n\tif (auto const* id = std::get_if<EntityId>(&m_scene_inspector.target.payload); id != nullptr && !m_scene->has_entity(*id)) {\n\t\tm_scene_inspector.target = {};\n\t\tret = true;\n\t}\n\treturn ret;\n}\n\nauto SceneGraph::draw_to(NotClosed<Window> w, Scene& scene) -> SceneInspector::Target {\n\tm_scene = &scene;\n\tcheck_stale();\n\n\tif (ImGui::SliderFloat(\"Inspector Width\", &m_scene_inspector.width_pct, 0.1f, 0.5f, \"%.3f\")) {\n\t\tm_scene_inspector.width_pct = std::clamp(m_scene_inspector.width_pct, 0.1f, 0.5f);\n\t}\n\n\tImGui::DragFloat(\"Draw colliders\", &scene.collision.draw_line_width);\n\n\tImGui::Separator();\n\tif (ImGui::Button(\"Spawn\")) { Popup::open(\"scene_graph.spawn_entity\"); }\n\n\tImGui::Separator();\n\tstandalone_node(\"camera\", SceneInspector::Type::eCamera);\n\tstandalone_node(\"lights\", SceneInspector::Type::eLights);\n\tdraw_scene_tree(w);\n\thandle_popups();\n\n\tm_scene_inspector.display(scene);\n\n\treturn m_scene_inspector.target;\n}\n\nvoid SceneGraph::standalone_node(char const* label, SceneInspector::Type type) {\n\tauto flags = int{};\n\tflags |= ImGuiTreeNodeFlags_SpanFullWidth;\n\tif (auto* held_type = std::get_if<SceneInspector::Type>(&m_scene_inspector.target.payload); held_type != nullptr && *held_type == type) {\n\t\tflags |= ImGuiTreeNodeFlags_Selected;\n\t}\n\tif (imcpp::TreeNode::leaf(label, flags)) { m_scene_inspector.target.payload = type; }\n\tif (ImGui::IsItemClicked(ImGuiMouseButton_Right)) {\n\t\tm_right_clicked_target.payload = type;\n\t\tPopup::open(\"scene_graph.right_click\");\n\t}\n}\n\nauto SceneGraph::walk_node(Node& node) -> bool {\n\tauto node_locator = m_scene->make_node_locator();\n\tauto flags = int{};\n\tflags |= (ImGuiTreeNodeFlags_SpanFullWidth | ImGuiTreeNodeFlags_OpenOnArrow);\n\tif (node.entity_id && m_scene_inspector.target == node.entity_id) { flags |= ImGuiTreeNodeFlags_Selected; }\n\tif (node.children().empty()) { flags |= ImGuiTreeNodeFlags_Leaf; }\n\tauto tn = imcpp::TreeNode{node.name.c_str(), flags};\n\tif (node.entity_id) {\n\t\tauto target = SceneInspector::Target{.payload = *node.entity_id};\n\t\tif (ImGui::IsItemClicked()) { m_scene_inspector.target = target; }\n\t\tif (ImGui::IsItemClicked(ImGuiMouseButton_Right)) {\n\t\t\tm_right_clicked = true;\n\t\t\tm_right_clicked_target = target;\n\t\t}\n\t}\n\tif (tn) {\n\t\tfor (auto const& id : node.children()) {\n\t\t\tif (!walk_node(node_locator.get(id))) { return false; }\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid SceneGraph::draw_scene_tree(imcpp::OpenWindow) {\n\tauto node_locator = m_scene->make_node_locator();\n\tfor (auto const& node : node_locator.roots()) {\n\t\tif (!walk_node(node_locator.get(node))) { return; }\n\t}\n\n\tif (m_right_clicked) {\n\t\tPopup::open(\"scene_graph.right_click\");\n\t\tm_right_clicked = {};\n\t}\n}\n\nvoid SceneGraph::handle_popups() {\n\tif (auto popup = Popup{\"scene_graph.spawn_entity\"}) {\n\t\tImGui::Text(\"Spawn Entity\");\n\t\tm_entity_name(\"Name\");\n\t\tif (!m_entity_name.empty() && ImGui::Button(\"Spawn\")) {\n\t\t\tm_scene->spawn(std::string{m_entity_name.view()});\n\t\t\tm_entity_name = {};\n\t\t\tPopup::close_current();\n\t\t}\n\t}\n\n\tif (auto popup = Popup{\"scene_graph.right_click\"}) {\n\t\tauto const* entity_id = std::get_if<EntityId>(&m_right_clicked_target.payload);\n\t\tif (entity_id != nullptr && !m_scene->has_entity(*entity_id)) {\n\t\t\tm_right_clicked_target = {};\n\t\t\treturn Popup::close_current();\n\t\t}\n\t\tif (ImGui::Selectable(\"Inspect\")) {\n\t\t\tm_scene_inspector.target = m_right_clicked_target;\n\t\t\tm_right_clicked_target = {};\n\t\t\tPopup::close_current();\n\t\t}\n\t\tif (entity_id != nullptr && ImGui::Selectable(\"Destroy\")) {\n\t\t\tm_scene->get_entity(*entity_id).set_destroyed();\n\t\t\tm_right_clicked_target = {};\n\t\t\tPopup::close_current();\n\t\t}\n\t}\n}\n}\n\n'LittleEngineVk/scene/include/le/scene/imcpp/scene_graph.hpp'\n:#pragma once\n#include <le/imcpp/input_text.hpp>\n#include <le/scene/imcpp/scene_inspector.hpp>\n\nnamespace le::imcpp {\nclass SceneGraph {\n  public:\n\tauto draw_to(NotClosed<Window> w, Scene& scene) -> SceneInspector::Target;\n\n\t[[nodiscard]] auto get_scene_inspector() const -> SceneInspector const& { return m_scene_inspector; }\n\t[[nodiscard]] auto get_scene_inspector() -> SceneInspector& { return m_scene_inspector; }\n\n  private:\n\tauto check_stale() -> bool;\n\tvoid standalone_node(char const* label, SceneInspector::Type type);\n\tauto walk_node(Node& node) -> bool;\n\tvoid draw_scene_tree(NotClosed<Window> w);\n\tvoid handle_popups();\n\n\tSceneInspector m_scene_inspector{};\n\tPtr<Scene> m_scene{};\n\tvoid const* m_prev{};\n\n\tbool m_right_clicked{};\n\tSceneInspector::Target m_right_clicked_target{};\n\tInputText<> m_entity_name{};\n};\n}\n\n'LittleEngineVk/engine/include/le/imcpp/common.hpp'\n:#pragma once\n#include <glm/vec2.hpp>\n#include <le/core/ptr.hpp>\n#include <concepts>\n#include <span>\n\nnamespace le {\nclass Engine;\n}\n\nnamespace le::imcpp {\n\n\n\n\n\nauto max_size(std::span<char const* const> strings) -> glm::vec2;\n\n\n\n\n\n\nauto small_button_red(char const* label) -> bool;\n\n\n\n\n\n\n\n\n\nauto selectable(char const* label, bool selected, int flags = {}, glm::vec2 size = {}) -> bool;\n\nauto input_text(char const* label, char* buffer, std::size_t size, int flags = {}) -> bool;\n\n\n\n\nclass StyleVar {\n  public:\n\tStyleVar(StyleVar const&) = delete;\n\tStyleVar(StyleVar&&) = delete;\n\tauto operator=(StyleVar const&) -> StyleVar& = delete;\n\tauto operator=(StyleVar&&) -> StyleVar& = delete;\n\n\texplicit StyleVar(int index, glm::vec2 value) { push(index, value); }\n\texplicit StyleVar(int index, float value) { push(index, value); }\n\t~StyleVar();\n\n\tauto push(int index, glm::vec2 value) -> void;\n\tauto push(int index, float value) -> void;\n\n\texplicit operator bool() const { return true; }\n\n  private:\n\tint m_count{};\n};\n\n\n\n\nclass Openable {\n  public:\n\tOpenable(Openable const&) = delete;\n\tOpenable(Openable&&) = delete;\n\tauto operator=(Openable const&) -> Openable& = delete;\n\tauto operator=(Openable&&) -> Openable& = delete;\n\n\t~Openable() noexcept;\n\n\t[[nodiscard]] auto is_open() const -> bool { return m_open; }\n\texplicit operator bool() const { return is_open(); }\n\n  protected:\n\tusing Close = void (*)();\n\n\tOpenable() = default;\n\tOpenable(bool is_open, Close close, bool force_close = {}) : m_close(close), m_open(is_open), m_force_close(force_close) {}\n\n\tClose m_close{};\n\tbool m_open{};\n\tbool m_force_close{};\n};\n\n\n\n\ntemplate <typename T>\nstruct NotClosed {\n\tNotClosed([[maybe_unused]] T const& t) { assert(t.is_open()); }\n\n\ttemplate <std::derived_from<T> Derived>\n\tNotClosed(NotClosed<Derived> ) {}\n};\n\nclass Canvas : public Openable {\n  protected:\n\tusing Openable::Openable;\n};\n\n\n\n\nclass Window : public Canvas {\n  public:\n\tclass Menu;\n\n\texplicit Window(char const* label, bool* open_if = {}, int flags = {});\n\tWindow(NotClosed<Canvas> parent, char const* label, glm::vec2 size = {}, bool border = {}, int flags = {});\n};\n\nusing OpenWindow = NotClosed<Window>;\n\n\n\n\nclass TreeNode : public Openable {\n  public:\n\texplicit TreeNode(char const* label, int flags = {});\n\n\tstatic auto leaf(char const* label, int flags = {}) -> bool;\n};\n\n\n\n\nclass MenuBar : public Openable {\n  protected:\n\tusing Openable::Openable;\n};\n\n\n\n\nclass Menu : public Openable {\n  public:\n\texplicit Menu(NotClosed<MenuBar>, char const* label, bool enabled = true);\n};\n\n\n\n\nclass Window::Menu : public MenuBar {\n  public:\n\texplicit Menu(NotClosed<Canvas>);\n};\n\n\n\n\nclass MainMenu : public MenuBar {\n  public:\n\texplicit MainMenu();\n};\n\n\n\n\nclass Popup : public Canvas {\n  public:\n\texplicit Popup(char const* id, bool centered = {}, int flags = {}) : Popup(id, {}, {}, centered, flags) {}\n\n\tstatic void open(char const* id);\n\tstatic void close_current();\n\n  protected:\n\texplicit Popup(char const* id, bool modal, bool closeable, bool centered, int flags);\n};\n\n\n\n\nclass Modal : public Popup {\n  public:\n\texplicit Modal(char const* id, bool centered = true, bool closeable = true, int flags = {}) : Popup(id, true, closeable, centered, flags) {}\n};\n\n\n\n\nclass TabBar : public Openable {\n  public:\n\tclass Item;\n\n\texplicit TabBar(char const* label, int flags = {});\n};\n\nclass TabBar::Item : public Openable {\n  public:\n\texplicit Item(NotClosed<TabBar>, char const* label, bool* open = {}, int flags = {});\n};\n\n\n\n\nclass Combo : public Openable {\n  public:\n\texplicit Combo(char const* label, char const* preview);\n\n\n\tauto item(char const* label, bool selected, int flags = {}, glm::vec2 size = {}) const -> bool { return selectable(label, selected, flags, size); }\n};\n\nclass ListBox : public Openable {\n  public:\n\texplicit ListBox(char const* label, glm::vec2 size = {});\n};\n}\n\n'LittleEngineVk/scene/include/le/scene/imcpp/scene_inspector.hpp'\n:#pragma once\n#include <le/graphics/camera.hpp>\n#include <le/graphics/lights.hpp>\n#include <le/imcpp/common.hpp>\n#include <le/imcpp/input_text.hpp>\n#include <le/scene/entity.hpp>\n#include <le/scene/imcpp/entity_inspector.hpp>\n#include <variant>\n\nnamespace le::imcpp {\nclass SceneInspector {\n  public:\n\tenum class Type { eCamera, eLights };\n\n\tstruct Target {\n\t\tstd::variant<std::monostate, Type, Id<Entity>> payload{};\n\n\t\texplicit constexpr operator bool() const { return !std::holds_alternative<std::monostate>(payload); }\n\n\t\tconstexpr auto operator==(Id<Entity> id) const -> bool {\n\t\t\tif (auto const* eid = std::get_if<Id<Entity>>(&payload)) { return *eid == id; }\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tTarget target{};\n\tfloat width_pct{0.35f};\n\n\tauto display(Scene& scene) -> void;\n\n\t[[nodiscard]] auto get_entity_inspector() const -> EntityInspector& { return *m_entity_inspector; }\n\tauto set_entity_inspector(std::unique_ptr<EntityInspector> entity_inspector) -> void;\n\n  private:\n\tvoid draw_to(NotClosed<Window> w, Scene& scene);\n\n\tauto inspect(OpenWindow w, graphics::Camera& camera) -> void;\n\tauto inspect(OpenWindow w, graphics::Lights& lights) -> void;\n\n\tstd::unique_ptr<EntityInspector> m_entity_inspector{std::make_unique<EntityInspector>()};\n};\n}\n",
        "gt": [
            "'LittleEngineVk/engine/include/le/imcpp/common.hpp'",
            "'LittleEngineVk/scene/include/le/scene/imcpp/scene_inspector.hpp'",
            "'LittleEngineVk/scene/include/le/scene/imcpp/scene_graph.hpp'",
            "'LittleEngineVk/scene/src/imcpp/scene_graph.cpp'"
        ]
    },
    {
        "files": [
            "'LearnVulkan/Android/app/src/main/cpp/native-lib.cpp'",
            "'LearnVulkan/source/engines/ThirdPersonEngine.h'",
            "'LearnVulkan/source/base/VulkanBaseEngine.h'",
            "'LearnVulkan/examples/02_AdvancedExamples/11_AssimpModel/AssimpModelSample.h'"
        ],
        "content": "'LearnVulkan/Android/app/src/main/cpp/native-lib.cpp'\n:#include <jni.h>\n#include <string>\n\n#include \"VulkanBase.h\"\n#include \"StaticTriangle.h\"\n#include \"StaticCube.h\"\n#include \"Texture2dCube.h\"\n#include \"SkyboxCube.h\"\n#include \"PhongLighting.h\"\n#include \"InstanceDraw.h\"\n#include \"ShadowMapping.h\"\n#include \"ShadowMappingOnmi.h\"\n#include \"AssimpModelSample.h\"\n\nenum VulkanExampleNames {\n    Example_StaticTriangle = 0,\n    Example_StaticCube,\n    Example_Texture2dCube,\n    Example_SkyboxCube,\n    Example_PhongLighting,\n    Example_InstanceDraw,\n    Example_ShadowMapping,\n    Example_ShadowMappingOnmi,\n    Example_AssimpModelSample,\n};\n\nextern \"C\"\nJNIEXPORT jlong JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_createInstance(JNIEnv *env, jobject thiz,\n                                                                   jint id) {\n    if(id == Example_StaticTriangle){\n        auto *engine = new VulkanEngine::StaticTriangle();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_StaticCube){\n        auto *engine = new VulkanEngine::StaticCube();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_Texture2dCube){\n        auto *engine = new VulkanEngine::Texture2dCube();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_SkyboxCube){\n        auto *engine = new VulkanEngine::SkyboxCube();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_PhongLighting){\n        auto *engine = new VulkanEngine::PhongLighting();\n        return (jlong) engine;\n    }\n    else if(id == Example_InstanceDraw){\n        auto *engine = new VulkanEngine::InstanceDraw();\n        return (jlong) engine;\n    }\n    else if(id == Example_ShadowMapping){\n        auto *engine = new VulkanEngine::ShadowMapping();\n        return (jlong) engine;\n    }\n    else if(id == Example_ShadowMappingOnmi){\n        auto *engine = new VulkanEngine::ShadowMappingOnmi();\n        return (jlong) engine;\n    }\n    else if(id == Example_AssimpModelSample) {\n        auto *engine = new VulkanEngine::AssimpModelSample();\n        return (jlong) engine;\n    }\n    else{\n        auto *engine = new VulkanEngine::StaticTriangle();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_initVulkan(JNIEnv *env, jobject thiz,\n                                                               jlong instance) {\n\n    if (instance){\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase*>(instance);\n        engine->initVulkan();\n        engine->prepare();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_renderFrame(JNIEnv *env, jobject thiz,\n                                                                jlong instance) {\n\n    if (instance){\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase*>(instance);\n        engine->renderFrame();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setSurface(JNIEnv *env, jobject thiz,\n                                                               jlong instance, jobject surface) {\n\n    auto window = ANativeWindow_fromSurface(env, surface);\n\n    assert(window);\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = (VulkanEngine::VulkanBase *) instance;\n        LOGI(\"New Surface %ld\", window);\n        engine->setWindow(window);\n        uint32_t width = static_cast<uint32_t >(ANativeWindow_getWidth(window));\n        uint32_t height = static_cast<uint32_t >(ANativeWindow_getHeight(window));\n        engine->setWidth(width);\n        engine->setHeight(height);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setAssetManager(JNIEnv *env, jobject thiz,\n                                                                    jlong instance,\n                                                                    jobject asset_manager) {\n\n    auto asset = AAssetManager_fromJava(env, asset_manager);\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setAssetManager(asset);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setTouchPos(JNIEnv *env, jobject thiz,\n                                                                jlong instance, jfloat x,\n                                                                jfloat y) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setTouchPos(x, y);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setTouchPosSecond(JNIEnv *env, jobject thiz,\n                                                                      jlong instance, jfloat x,\n                                                                      jfloat y) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setTouchPosSecond(x, y);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setTouchMode(JNIEnv *env, jobject thiz,\n                                                                 jlong instance, jint mode) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setTouchMode(VulkanEngine::VulkanBase::TouchMode(mode));\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_resetTouch(JNIEnv *env, jobject thiz,\n                                                               jlong instance) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->resetTouch();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_deleteVulkan(JNIEnv *env, jobject thiz,\n                                                                 jlong instance, jint id) {\n\n    if (instance) {\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine*>(instance);\n        delete (engine);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_destroySurface(JNIEnv *env, jobject thiz,\n                                                                   jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->destroySurface();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_rebuildSurface(JNIEnv *env, jobject thiz,\n                                                                   jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->rebuildSurface();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_pause(JNIEnv *env, jobject thiz,\n                                                          jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->pause();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_resume(JNIEnv *env, jobject thiz,\n                                                           jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->resume();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_waitCurrentFrameComplete(JNIEnv *env,\n                                                                             jobject thiz,\n                                                                             jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->waitForCurrentFrameComplete();\n        LOGI(\"waitForCurrentFrameComplete\");\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_destroyANativeWindow(JNIEnv *env, jobject thiz,\n                                                                         jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->destroyANativeWindow();\n        LOGI(\"destroyANativeWindow\");\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_runFunction(JNIEnv *env, jobject thiz,\n                                                            jlong instance, jint i) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->runFunction(i);\n    }\n}\n'LearnVulkan/source/engines/ThirdPersonEngine.h'\n:\n\n\n\n#ifndef LEARNVULKAN_THIRDPERSONENGINE_H\n#define LEARNVULKAN_THIRDPERSONENGINE_H\n\n#include \"VulkanBaseEngine.h\"\n#include \"ThirdPersonCamera.h\"\n\nBEGIN_NAMESPACE(VulkanEngine)\n\nclass VULKANENGINE_EXPORT_API ThirdPersonEngine : public VulkanBaseEngine , public ThirdPersonCamera {\npublic:\n    ThirdPersonEngine() = default;\n    virtual ~ThirdPersonEngine() {}\n\n    void updateCamera();\n};\n\nEND_NAMESPACE(VulkanEngine)\n\n#endif\n\n'LearnVulkan/source/base/VulkanBaseEngine.h'\n:\n\n\n\n#ifndef LEARNVULKAN_VULKANBASEENGINE_H\n#define LEARNVULKAN_VULKANBASEENGINE_H\n\n#include \"VulkanBase.h\"\n\n#include \"VulkanContext.h\"\n#include \"VulkanDescriptorSet.h\"\n#include \"VulkanVertexDescriptions.h\"\n#include \"VulkanPipelines.h\"\n\n#ifdef __ANDROID__\nnamespace vks{\nclass UIOverlay;\n}\n#else\n#include \"VulkanUIOverlay.h\"\n#endif\n\nBEGIN_NAMESPACE(VulkanEngine)\n\nclass VULKANENGINE_EXPORT_API VulkanBaseEngine : public VulkanBase {\npublic:\n    VulkanBaseEngine() = default;\n\n    virtual ~VulkanBaseEngine();\n\n    virtual void initWindow();\n\n    virtual void prepare() override;\n\n    virtual void render() override;\n\n    virtual void updateOverlay() override;\n\n    virtual void drawUI(const VkCommandBuffer commandBuffer);\n\n    virtual void OnUpdateUIOverlay(vks::UIOverlay *overlay) {}\n\n    virtual void processPrepareCallback() {}\n\n    virtual void updateCommand();\n\n    void renderAsyncThread();\n\n    void renderJoin();\n\nprotected:\n    void prepareIMGUI();\n\n    void prepareDescriptorSets();\n\n    void prepareVertexDescriptions();\n\n    void prepareBasePipelines();\n\n    void prepareContext();\n\n    virtual void prepareMyObjects() {};\n\n    virtual void buildCommandBuffersBeforeMainRenderPass(VkCommandBuffer &cmd) {}\n\n    virtual void buildCommandBuffers() override;\n\n    virtual void buildCommandBuffersAfterMainRenderPass(VkCommandBuffer &cmd) {}\n\n    virtual void setViewPorts(VkCommandBuffer &cmd);\n\n    virtual void buildMyObjects(VkCommandBuffer &cmd) {};\n\n    template<class T>\n    void REGISTER_OBJECT(std::shared_ptr<T> &obj) {\n        obj = VkObject::New<T>(m_context);\n        m_objs.emplace_back(obj);\n    }\n\n    void destroyObjects() {\n        for (auto &obj : m_objs) {\n            obj = nullptr;\n        }\n    }\n\n    VkPipelineShaderStageCreateInfo\n    loadShader(const std::string &fileName, const VkShaderStageFlagBits &stage);\n\nprotected:\n    int m_maxSets = 1;\n\n    VulkanDescriptorSet *m_vulkanDescriptorSet = nullptr;\n    VulkanVertexDescriptions *m_vulkanVertexDescriptions = nullptr;\n    VulkanPipelines *m_pipelines = nullptr;\n    VulkanContext *m_context = nullptr;\n    VkPipelineLayout m_pipelineLayout = VK_NULL_HANDLE;\n\n#ifndef __ANDROID__\n    vks::UIOverlay m_UIOverlay;\n#endif\n\n    std::vector<std::shared_ptr<VkObject>> m_objs;\n\n    struct Settings {\n        bool overlay = true;\n    } m_settings;\n\n    bool m_rebuild = false;\n\n    std::thread *m_thread = nullptr;\n};\n\nEND_NAMESPACE(VulkanEngine)\n\n#endif\n\n'LearnVulkan/examples/02_AdvancedExamples/11_AssimpModel/AssimpModelSample.h'\n:\n\n\n\n#ifndef LEARNVULKAN_ASSIMPMODELSAMPLE_H\n#define LEARNVULKAN_ASSIMPMODELSAMPLE_H\n\n#include \"ThirdPersonEngine.h\"\n\nBEGIN_NAMESPACE(VulkanEngine)\n\nclass VulkanCube;\n\nclass VulkanVertFragShader;\n\nclass UniformCamera;\n\nclass VulkanTexture2D;\n\nclass VulkanTextureCubeMap;\n\nclass VulkanPlane;\n\nclass VulkanFrameBuffer;\n\nclass ShadowCamera;\n\nclass AssimpObject;\n\nclass ReflectParaBuffer;\n\nclass AssimpModelSample : public ThirdPersonEngine {\npublic:\n    AssimpModelSample() = default;\n\n    ~AssimpModelSample();\n\n    void prepareFunctions() override;\n\n    void prepareMyObjects() override;\n\n    void buildMyObjects(VkCommandBuffer &cmd) override;\n\n    void render() override;\n\n    void setDescriptorSet();\n\n    void createPipelines();\n\n    void createCube();\n\n    void createSkybox();\n\n    void createPlane();\n\n    void createShadowFrameBuffer();\n\n    void createDebugQuad();\n\n    void createReflectParaBuffer();\n\n    void buildCommandBuffersBeforeMainRenderPass(VkCommandBuffer &cmd) override;\n\n    void seeDebugQuad();\n\n    void OnUpdateUIOverlay(vks::UIOverlay *overlay) override;\n\nprotected:\n    std::shared_ptr<AssimpObject> m_assimpObject = nullptr;\n\n    std::shared_ptr<VulkanCube> m_cube = nullptr;\n    std::shared_ptr<VulkanVertFragShader> m_cubeShader = nullptr;\n    std::shared_ptr<UniformCamera> m_cubeUniform = nullptr;\n    std::shared_ptr<VulkanTexture2D> m_cubeTextureA = nullptr;\n    std::shared_ptr<VulkanTexture2D> m_cubeTextureB = nullptr;\n\n    std::shared_ptr<VulkanCube> m_sky = nullptr;\n    std::shared_ptr<VulkanVertFragShader> m_skyShader = nullptr;\n    std::shared_ptr<VulkanTextureCubeMap> m_skyTexture = nullptr;\n\n    std::shared_ptr<VulkanPlane> m_plane = nullptr;\n    std::shared_ptr<VulkanVertFragShader> m_planeShader = nullptr;\n    std::shared_ptr<VulkanTexture2D> m_planeTexture = nullptr;\n\n    std::shared_ptr<VulkanFrameBuffer> m_frameBuffer = nullptr;\n    std::shared_ptr<VulkanVertFragShader> m_shadowShader = nullptr;\n    std::shared_ptr<ShadowCamera> m_shadowCamera = nullptr;\n\n    std::shared_ptr<VulkanPlane> m_dubugPlane = nullptr;\n    std::shared_ptr<VulkanVertFragShader> m_debugShader = nullptr;\n\n    std::shared_ptr<ReflectParaBuffer> m_reflectParaBuffer = nullptr;\n\n    bool m_seeDebug = false;\n};\n\nEND_NAMESPACE(VulkanEngine)\n\n#endif\n",
        "gt": [
            "'LearnVulkan/source/base/VulkanBaseEngine.h'",
            "'LearnVulkan/source/engines/ThirdPersonEngine.h'",
            "'LearnVulkan/examples/02_AdvancedExamples/11_AssimpModel/AssimpModelSample.h'",
            "'LearnVulkan/Android/app/src/main/cpp/native-lib.cpp'"
        ]
    },
    {
        "files": [
            "'pyeos/contracts/eosiolib/print.hpp'",
            "'pyeos/contracts/eosiolib/eosio.hpp'",
            "'pyeos/contracts/eosiolib/fixed_key.hpp'",
            "'pyeos/contracts/test_api_multi_index/test_api_multi_index.cpp'"
        ],
        "content": "'pyeos/contracts/eosiolib/print.hpp'\n:\n#pragma once\n#include <eosiolib/print.h>\n#include <eosiolib/types.hpp>\n#include <eosiolib/fixed_key.hpp>\n#include <utility>\n#include <string>\n\nnamespace eosio {\n#ifdef __WASM\n   static_assert( sizeof(long) == sizeof(int), \"unexpected size difference\" );\n#endif\n\n   inline void print( const char* ptr ) {\n      prints(ptr);\n   }\n\n   inline void print( const std::string& s) {\n      prints_l( s.c_str(), s.size() );\n   }\n\n   inline void print( std::string& s) {\n      prints_l( s.c_str(), s.size() );\n   }\n\n   inline void print( const char c ) {\n      prints_l( &c, 1 );\n   }\n\n\n#ifdef __WASM\n   inline void print( int num ) {\n      printi(num);\n   }\n#endif\n\n   inline void print( int32_t num ) {\n      printi(num);\n   }\n\n\n   inline void print( int64_t num ) {\n      printi(num);\n   }\n\n\n\n#ifdef __WASM\n   inline void print( unsigned int num ) {\n      printui(num);\n   }\n#endif\n\n   inline void print( uint32_t num ) {\n      printui(num);\n   }\n\n\n   inline void print( uint64_t num ) {\n      printui(num);\n   }\n\n\n   inline void print( int128_t num ) {\n      printi128(&num);\n   }\n\n\n   inline void print( uint128_t num ) {\n      printui128(&num);\n   }\n\n\n\n   inline void print( float num ) { printsf( num ); }\n\n\n   inline void print( double num ) { printdf( num ); }\n\n\n   inline void print( long double num ) { printqf( &num ); }\n\n\n\n   template<size_t Size>\n   inline void print( const fixed_key<Size>& val ) {\n      auto arr = val.extract_as_byte_array();\n      prints(\"0x\");\n      printhex(static_cast<const void*>(arr.data()), arr.size());\n   }\n\n\n   template<size_t Size>\n   inline void print( fixed_key<Size>& val ) {\n      print(static_cast<const fixed_key<Size>&>(val));\n   }\n\n\n   inline void print( name name ) {\n      printn(name.value);\n   }\n\n\n   inline void print( bool val ) {\n      prints(val?\"true\":\"false\");\n   }\n\n\n\n   template<typename T>\n   inline void print( T&& t ) {\n      t.print();\n   }\n\n\n   inline void print_f( const char* s ) {\n      prints(s);\n   }\n\n\n\n\n\n   template <typename Arg, typename... Args>\n   inline void print_f( const char* s, Arg val, Args... rest ) {\n      while ( *s != '\\0' ) {\n         if ( *s == '%' ) {\n            print( val );\n            print_f( s+1, rest... );\n            return;\n         }\n         prints_l( s, 1 );\n         s++;\n      }\n   }\n\n\n   template<typename Arg, typename... Args>\n   void print( Arg&& a, Args&&... args ) {\n      print(std::forward<Arg>(a));\n      print(std::forward<Args>(args)...);\n   }\n\n\n   class iostream {};\n\n\n   template<typename T>\n   inline iostream& operator<<( iostream& out, const T& v ) {\n      print( v );\n      return out;\n   }\n\n   static iostream cout;\n\n\n\n\n}\n\n'pyeos/contracts/eosiolib/eosio.hpp'\n:\n#pragma once\n#include <eosiolib/types.hpp>\n#include <eosiolib/action.hpp>\n#include <eosiolib/print.hpp>\n#include <eosiolib/multi_index.hpp>\n#include <eosiolib/dispatcher.hpp>\n#include <eosiolib/contract.hpp>\n\n'pyeos/contracts/eosiolib/fixed_key.hpp'\n:\n#pragma once\n\n#include <array>\n#include <algorithm>\n#include <type_traits>\n\n#include <eosiolib/system.h>\n\nnamespace eosio {\n\n   template<size_t Size>\n   class fixed_key;\n\n   template<size_t Size>\n   bool operator==(const fixed_key<Size> &c1, const fixed_key<Size> &c2);\n\n   template<size_t Size>\n   bool operator!=(const fixed_key<Size> &c1, const fixed_key<Size> &c2);\n\n   template<size_t Size>\n   bool operator>(const fixed_key<Size> &c1, const fixed_key<Size> &c2);\n\n   template<size_t Size>\n   bool operator<(const fixed_key<Size> &c1, const fixed_key<Size> &c2);\n\n\n\n\n   template<size_t Size>\n   class fixed_key {\n      private:\n\n         template<bool...> struct bool_pack;\n         template<bool... bs>\n         using all_true = std::is_same< bool_pack<bs..., true>, bool_pack<true, bs...> >;\n\n         template<typename Word, size_t NumWords>\n         static void set_from_word_sequence(const std::array<Word, NumWords>& arr, fixed_key<Size>& key)\n         {\n            auto itr = key._data.begin();\n            word_t temp_word = 0;\n            const size_t sub_word_shift = 8 * sizeof(Word);\n            const size_t num_sub_words = sizeof(word_t) / sizeof(Word);\n            auto sub_words_left = num_sub_words;\n            for( auto&& w : arr ) {\n               if( sub_words_left > 1 ) {\n                   temp_word |= static_cast<word_t>(w);\n                   temp_word <<= sub_word_shift;\n                   --sub_words_left;\n                   continue;\n               }\n\n               eosio_assert( sub_words_left == 1, \"unexpected error in fixed_key constructor\" );\n               temp_word |= static_cast<word_t>(w);\n               sub_words_left = num_sub_words;\n\n               *itr = temp_word;\n               temp_word = 0;\n               ++itr;\n            }\n            if( sub_words_left != num_sub_words ) {\n               if( sub_words_left > 1 )\n                  temp_word <<= 8 * (sub_words_left-1);\n               *itr = temp_word;\n            }\n         }\n\n      public:\n\n         typedef uint128_t word_t;\n\n\n\n         static constexpr size_t num_words() { return (Size + sizeof(word_t) - 1) / sizeof(word_t); }\n\n\n         static constexpr size_t padded_bytes() { return num_words() * sizeof(word_t) - Size; }\n\n\n         constexpr fixed_key() : _data() {}\n\n\n         fixed_key(const std::array<word_t, num_words()>& arr)\n         {\n           std::copy(arr.begin(), arr.end(), _data.begin());\n         }\n\n\n         template<typename Word, size_t NumWords,\n                  typename Enable = typename std::enable_if<std::is_integral<Word>::value &&\n                                                             !std::is_same<Word, bool>::value &&\n                                                             sizeof(Word) < sizeof(word_t)>::type >\n         fixed_key(const std::array<Word, NumWords>& arr)\n         {\n            static_assert( sizeof(word_t) == (sizeof(word_t)/sizeof(Word)) * sizeof(Word),\n                           \"size of the backing word size is not divisible by the size of the array element\" );\n            static_assert( sizeof(Word) * NumWords <= Size, \"too many words supplied to fixed_key constructor\" );\n\n            set_from_word_sequence(arr, *this);\n         }\n\n\n         template<typename FirstWord, typename... Rest>\n         static\n         fixed_key<Size>\n         make_from_word_sequence(typename std::enable_if<std::is_integral<FirstWord>::value &&\n                                                          !std::is_same<FirstWord, bool>::value &&\n                                                          sizeof(FirstWord) <= sizeof(word_t) &&\n                                                          all_true<(std::is_same<FirstWord, Rest>::value)...>::value,\n                                                         FirstWord>::type first_word,\n                                 Rest... rest)\n         {\n            static_assert( sizeof(word_t) == (sizeof(word_t)/sizeof(FirstWord)) * sizeof(FirstWord),\n                           \"size of the backing word size is not divisible by the size of the words supplied as arguments\" );\n            static_assert( sizeof(FirstWord) * (1 + sizeof...(Rest)) <= Size, \"too many words supplied to make_from_word_sequence\" );\n\n            fixed_key<Size> key;\n            set_from_word_sequence(std::array<FirstWord, 1+sizeof...(Rest)>{{ first_word, rest... }}, key);\n            return key;\n         }\n\n\n         const auto& get_array()const { return _data; }\n\n\n         auto data() { return _data.data(); }\n\n\n         auto data()const { return _data.data(); }\n\n\n         auto size()const { return _data.size(); }\n\n\n\n         std::array<uint8_t, Size> extract_as_byte_array()const {\n            std::array<uint8_t, Size> arr;\n\n            const size_t num_sub_words = sizeof(word_t);\n\n            auto arr_itr  = arr.begin();\n            auto data_itr = _data.begin();\n\n            for( size_t counter = _data.size(); counter > 0; --counter, ++data_itr ) {\n               size_t sub_words_left = num_sub_words;\n\n               if( counter == 1 ) {\n                  sub_words_left -= padded_bytes();\n               }\n               auto temp_word = *data_itr;\n               for( ; sub_words_left > 0; --sub_words_left ) {\n                  *(arr_itr + sub_words_left - 1) = static_cast<uint8_t>(temp_word & 0xFF);\n                  temp_word >>= 8;\n               }\n               arr_itr += num_sub_words;\n            }\n\n            return arr;\n         }\n\n\n         friend bool operator== <>(const fixed_key<Size> &c1, const fixed_key<Size> &c2);\n\n         friend bool operator!= <>(const fixed_key<Size> &c1, const fixed_key<Size> &c2);\n\n         friend bool operator> <>(const fixed_key<Size> &c1, const fixed_key<Size> &c2);\n\n         friend bool operator< <>(const fixed_key<Size> &c1, const fixed_key<Size> &c2);\n\n      private:\n\n         std::array<word_t, num_words()> _data;\n    };\n\n\n   template<size_t Size>\n   bool operator==(const fixed_key<Size> &c1, const fixed_key<Size> &c2) {\n      return c1._data == c2._data;\n   }\n\n\n   template<size_t Size>\n   bool operator!=(const fixed_key<Size> &c1, const fixed_key<Size> &c2) {\n      return c1._data != c2._data;\n   }\n\n\n   template<size_t Size>\n   bool operator>(const fixed_key<Size>& c1, const fixed_key<Size>& c2) {\n      return c1._data > c2._data;\n   }\n\n\n   template<size_t Size>\n   bool operator<(const fixed_key<Size> &c1, const fixed_key<Size> &c2) {\n      return c1._data < c2._data;\n   }\n\n\n   typedef fixed_key<32> key256;\n}\n\n'pyeos/contracts/test_api_multi_index/test_api_multi_index.cpp'\n:\n#include <eosiolib/eosio.hpp>\n#include \"../test_api/test_api.hpp\"\n\n#include \"test_multi_index.cpp\"\n\nextern \"C\" {\n\n   void apply( uint64_t receiver, uint64_t code, uint64_t action ) {\n      require_auth(code);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_general);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_store_only);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_check_without_storing);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_require_find_fail);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_require_find_fail_with_msg);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_require_find_sk_fail);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_require_find_sk_fail_with_msg);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx128_general);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx128_store_only);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx128_check_without_storing);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx128_autoincrement_test);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx128_autoincrement_test_part1);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx128_autoincrement_test_part2);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx256_general);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx_double_general);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx_long_double_general);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_pk_iterator_exceed_end);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_sk_iterator_exceed_end);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_pk_iterator_exceed_begin);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_sk_iterator_exceed_begin);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_pass_pk_ref_to_other_table);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_pass_sk_ref_to_other_table);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_pass_pk_end_itr_to_iterator_to);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_pass_pk_end_itr_to_modify);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_pass_pk_end_itr_to_erase);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_pass_sk_end_itr_to_iterator_to);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_pass_sk_end_itr_to_modify);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_pass_sk_end_itr_to_erase);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_modify_primary_key);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_run_out_of_avl_pk);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_sk_cache_pk_lookup);\n      WASM_TEST_HANDLER_EX(test_multi_index, idx64_pk_cache_sk_lookup);\n\n\n      eosio_assert(false, \"Unknown Test\");\n   }\n\n}\n",
        "gt": [
            "'pyeos/contracts/eosiolib/fixed_key.hpp'",
            "'pyeos/contracts/eosiolib/print.hpp'",
            "'pyeos/contracts/eosiolib/eosio.hpp'",
            "'pyeos/contracts/test_api_multi_index/test_api_multi_index.cpp'"
        ]
    },
    {
        "files": [
            "'query-pdb/thirdparty/spdlog/tests/test_cfg.cpp'",
            "'query-pdb/thirdparty/spdlog/include/spdlog/details/periodic_worker.h'",
            "'query-pdb/thirdparty/spdlog/include/spdlog/cfg/argv.h'",
            "'query-pdb/thirdparty/spdlog/include/spdlog/details/registry.h'"
        ],
        "content": "'query-pdb/thirdparty/spdlog/tests/test_cfg.cpp'\n:\n#include \"includes.h\"\n#include \"test_sink.h\"\n\n#include <spdlog/cfg/env.h>\n#include <spdlog/cfg/argv.h>\n\nusing spdlog::cfg::load_argv_levels;\nusing spdlog::cfg::load_env_levels;\nusing spdlog::sinks::test_sink_st;\n\nTEST_CASE(\"env\", \"[cfg]\")\n{\n    spdlog::drop(\"l1\");\n    auto l1 = spdlog::create<test_sink_st>(\"l1\");\n#ifdef CATCH_PLATFORM_WINDOWS\n    _putenv_s(\"SPDLOG_LEVEL\", \"l1=warn\");\n#else\n    setenv(\"SPDLOG_LEVEL\", \"l1=warn\", 1);\n#endif\n    load_env_levels();\n    REQUIRE(l1->level() == spdlog::level::warn);\n    spdlog::set_default_logger(spdlog::create<test_sink_st>(\"cfg-default\"));\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::info);\n}\n\nTEST_CASE(\"argv1\", \"[cfg]\")\n{\n    spdlog::drop(\"l1\");\n    const char *argv[] = {\"ignore\", \"SPDLOG_LEVEL=l1=warn\"};\n    load_argv_levels(2, argv);\n    auto l1 = spdlog::create<spdlog::sinks::test_sink_st>(\"l1\");\n    REQUIRE(l1->level() == spdlog::level::warn);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::info);\n}\n\nTEST_CASE(\"argv2\", \"[cfg]\")\n{\n    spdlog::drop(\"l1\");\n    const char *argv[] = {\"ignore\", \"SPDLOG_LEVEL=l1=warn,trace\"};\n    load_argv_levels(2, argv);\n    auto l1 = spdlog::create<test_sink_st>(\"l1\");\n    REQUIRE(l1->level() == spdlog::level::warn);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::trace);\n}\n\nTEST_CASE(\"argv3\", \"[cfg]\")\n{\n    spdlog::set_level(spdlog::level::trace);\n\n    spdlog::drop(\"l1\");\n    const char *argv[] = {\"ignore\", \"SPDLOG_LEVEL=junk_name=warn\"};\n    load_argv_levels(2, argv);\n    auto l1 = spdlog::create<test_sink_st>(\"l1\");\n    REQUIRE(l1->level() == spdlog::level::trace);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::trace);\n}\n\nTEST_CASE(\"argv4\", \"[cfg]\")\n{\n    spdlog::set_level(spdlog::level::info);\n    spdlog::drop(\"l1\");\n    const char *argv[] = {\"ignore\", \"SPDLOG_LEVEL=junk\"};\n    load_argv_levels(2, argv);\n    auto l1 = spdlog::create<test_sink_st>(\"l1\");\n    REQUIRE(l1->level() == spdlog::level::info);\n}\n\nTEST_CASE(\"argv5\", \"[cfg]\")\n{\n    spdlog::set_level(spdlog::level::info);\n    spdlog::drop(\"l1\");\n    const char *argv[] = {\"ignore\", \"ignore\", \"SPDLOG_LEVEL=l1=warn,trace\"};\n    load_argv_levels(3, argv);\n    auto l1 = spdlog::create<test_sink_st>(\"l1\");\n    REQUIRE(l1->level() == spdlog::level::warn);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::trace);\n    spdlog::set_level(spdlog::level::info);\n}\n\nTEST_CASE(\"argv6\", \"[cfg]\")\n{\n    spdlog::set_level(spdlog::level::err);\n    const char *argv[] = {\"\"};\n    load_argv_levels(1, argv);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::err);\n    spdlog::set_level(spdlog::level::info);\n}\n\nTEST_CASE(\"argv7\", \"[cfg]\")\n{\n    spdlog::set_level(spdlog::level::err);\n    const char *argv[] = {\"\"};\n    load_argv_levels(0, argv);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::err);\n    spdlog::set_level(spdlog::level::info);\n}\n\nTEST_CASE(\"level-not-set-test1\", \"[cfg]\")\n{\n    spdlog::drop(\"l1\");\n    const char *argv[] = {\"ignore\", \"\"};\n    load_argv_levels(2, argv);\n    auto l1 = spdlog::create<spdlog::sinks::test_sink_st>(\"l1\");\n    l1->set_level(spdlog::level::trace);\n    REQUIRE(l1->level() == spdlog::level::trace);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::info);\n}\n\nTEST_CASE(\"level-not-set-test2\", \"[cfg]\")\n{\n    spdlog::drop(\"l1\");\n    spdlog::drop(\"l2\");\n    const char *argv[] = {\"ignore\", \"SPDLOG_LEVEL=l1=trace\"};\n\n    auto l1 = spdlog::create<spdlog::sinks::test_sink_st>(\"l1\");\n    l1->set_level(spdlog::level::warn);\n    auto l2 = spdlog::create<spdlog::sinks::test_sink_st>(\"l2\");\n    l2->set_level(spdlog::level::warn);\n\n    load_argv_levels(2, argv);\n\n    REQUIRE(l1->level() == spdlog::level::trace);\n    REQUIRE(l2->level() == spdlog::level::warn);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::info);\n}\n\nTEST_CASE(\"level-not-set-test3\", \"[cfg]\")\n{\n    spdlog::drop(\"l1\");\n    spdlog::drop(\"l2\");\n    const char *argv[] = {\"ignore\", \"SPDLOG_LEVEL=l1=trace\"};\n\n    load_argv_levels(2, argv);\n\n    auto l1 = spdlog::create<spdlog::sinks::test_sink_st>(\"l1\");\n    auto l2 = spdlog::create<spdlog::sinks::test_sink_st>(\"l2\");\n\n    REQUIRE(l1->level() == spdlog::level::trace);\n    REQUIRE(l2->level() == spdlog::level::info);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::info);\n}\n\nTEST_CASE(\"level-not-set-test4\", \"[cfg]\")\n{\n    spdlog::drop(\"l1\");\n    spdlog::drop(\"l2\");\n    const char *argv[] = {\"ignore\", \"SPDLOG_LEVEL=l1=trace,warn\"};\n\n    load_argv_levels(2, argv);\n\n    auto l1 = spdlog::create<spdlog::sinks::test_sink_st>(\"l1\");\n    auto l2 = spdlog::create<spdlog::sinks::test_sink_st>(\"l2\");\n\n    REQUIRE(l1->level() == spdlog::level::trace);\n    REQUIRE(l2->level() == spdlog::level::warn);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::warn);\n}\n\nTEST_CASE(\"level-not-set-test5\", \"[cfg]\")\n{\n    spdlog::drop(\"l1\");\n    spdlog::drop(\"l2\");\n    const char *argv[] = {\"ignore\", \"SPDLOG_LEVEL=l1=junk,warn\"};\n\n    load_argv_levels(2, argv);\n\n    auto l1 = spdlog::create<spdlog::sinks::test_sink_st>(\"l1\");\n    auto l2 = spdlog::create<spdlog::sinks::test_sink_st>(\"l2\");\n\n    REQUIRE(l1->level() == spdlog::level::warn);\n    REQUIRE(l2->level() == spdlog::level::warn);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::warn);\n}\n\nTEST_CASE(\"restore-to-default\", \"[cfg]\")\n{\n    spdlog::drop(\"l1\");\n    spdlog::drop(\"l2\");\n    const char *argv[] = {\"ignore\", \"SPDLOG_LEVEL=info\"};\n    load_argv_levels(2, argv);\n    REQUIRE(spdlog::default_logger()->level() == spdlog::level::info);\n}\n\n'query-pdb/thirdparty/spdlog/include/spdlog/details/periodic_worker.h'\n:\n\n\n#pragma once\n\n\n\n\n\n\n\n#include <chrono>\n#include <condition_variable>\n#include <functional>\n#include <mutex>\n#include <thread>\nnamespace spdlog {\nnamespace details {\n\nclass SPDLOG_API periodic_worker\n{\npublic:\n    template<typename Rep, typename Period>\n    periodic_worker(const std::function<void()> &callback_fun, std::chrono::duration<Rep, Period> interval)\n    {\n        active_ = (interval > std::chrono::duration<Rep, Period>::zero());\n        if (!active_)\n        {\n            return;\n        }\n\n        worker_thread_ = std::thread([this, callback_fun, interval]() {\n            for (;;)\n            {\n                std::unique_lock<std::mutex> lock(this->mutex_);\n                if (this->cv_.wait_for(lock, interval, [this] { return !this->active_; }))\n                {\n                    return;\n                }\n                callback_fun();\n            }\n        });\n    }\n    periodic_worker(const periodic_worker &) = delete;\n    periodic_worker &operator=(const periodic_worker &) = delete;\n\n    ~periodic_worker();\n\nprivate:\n    bool active_;\n    std::thread worker_thread_;\n    std::mutex mutex_;\n    std::condition_variable cv_;\n};\n}\n}\n\n#ifdef SPDLOG_HEADER_ONLY\n#    include \"periodic_worker-inl.h\"\n#endif\n\n'query-pdb/thirdparty/spdlog/include/spdlog/cfg/argv.h'\n:\n\n\n#pragma once\n#include <spdlog/cfg/helpers.h>\n#include <spdlog/details/registry.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nnamespace spdlog {\nnamespace cfg {\n\n\ninline void load_argv_levels(int argc, const char **argv)\n{\n    const std::string spdlog_level_prefix = \"SPDLOG_LEVEL=\";\n    for (int i = 1; i < argc; i++)\n    {\n        std::string arg = argv[i];\n        if (arg.find(spdlog_level_prefix) == 0)\n        {\n            auto levels_string = arg.substr(spdlog_level_prefix.size());\n            helpers::load_levels(levels_string);\n        }\n    }\n}\n\ninline void load_argv_levels(int argc, char **argv)\n{\n    load_argv_levels(argc, const_cast<const char **>(argv));\n}\n\n}\n}\n\n'query-pdb/thirdparty/spdlog/include/spdlog/details/registry.h'\n:\n\n\n#pragma once\n\n\n\n\n\n\n#include <spdlog/common.h>\n#include <spdlog/details/periodic_worker.h>\n\n#include <chrono>\n#include <functional>\n#include <memory>\n#include <string>\n#include <unordered_map>\n#include <mutex>\n\nnamespace spdlog {\nclass logger;\n\nnamespace details {\nclass thread_pool;\n\nclass SPDLOG_API registry\n{\npublic:\n    using log_levels = std::unordered_map<std::string, level::level_enum>;\n    registry(const registry &) = delete;\n    registry &operator=(const registry &) = delete;\n\n    void register_logger(std::shared_ptr<logger> new_logger);\n    void initialize_logger(std::shared_ptr<logger> new_logger);\n    std::shared_ptr<logger> get(const std::string &logger_name);\n    std::shared_ptr<logger> default_logger();\n\n\n\n\n\n    logger *get_default_raw();\n\n\n\n    void set_default_logger(std::shared_ptr<logger> new_default_logger);\n\n    void set_tp(std::shared_ptr<thread_pool> tp);\n\n    std::shared_ptr<thread_pool> get_tp();\n\n\n    void set_formatter(std::unique_ptr<formatter> formatter);\n\n    void enable_backtrace(size_t n_messages);\n\n    void disable_backtrace();\n\n    void set_level(level::level_enum log_level);\n\n    void flush_on(level::level_enum log_level);\n\n    template<typename Rep, typename Period>\n    void flush_every(std::chrono::duration<Rep, Period> interval)\n    {\n        std::lock_guard<std::mutex> lock(flusher_mutex_);\n        auto clbk = [this]() { this->flush_all(); };\n        periodic_flusher_ = details::make_unique<periodic_worker>(clbk, interval);\n    }\n\n    void set_error_handler(err_handler handler);\n\n    void apply_all(const std::function<void(const std::shared_ptr<logger>)> &fun);\n\n    void flush_all();\n\n    void drop(const std::string &logger_name);\n\n    void drop_all();\n\n\n    void shutdown();\n\n    std::recursive_mutex &tp_mutex();\n\n    void set_automatic_registration(bool automatic_registration);\n\n\n    void set_levels(log_levels levels, level::level_enum *global_level);\n\n    static registry &instance();\n\nprivate:\n    registry();\n    ~registry();\n\n    void throw_if_exists_(const std::string &logger_name);\n    void register_logger_(std::shared_ptr<logger> new_logger);\n    bool set_level_from_cfg_(logger *logger);\n    std::mutex logger_map_mutex_, flusher_mutex_;\n    std::recursive_mutex tp_mutex_;\n    std::unordered_map<std::string, std::shared_ptr<logger>> loggers_;\n    log_levels log_levels_;\n    std::unique_ptr<formatter> formatter_;\n    spdlog::level::level_enum global_log_level_ = level::info;\n    level::level_enum flush_level_ = level::off;\n    err_handler err_handler_;\n    std::shared_ptr<thread_pool> tp_;\n    std::unique_ptr<periodic_worker> periodic_flusher_;\n    std::shared_ptr<logger> default_logger_;\n    bool automatic_registration_ = true;\n    size_t backtrace_n_messages_ = 0;\n};\n\n}\n}\n\n#ifdef SPDLOG_HEADER_ONLY\n#    include \"registry-inl.h\"\n#endif\n",
        "gt": [
            "'query-pdb/thirdparty/spdlog/include/spdlog/details/periodic_worker.h'",
            "'query-pdb/thirdparty/spdlog/include/spdlog/details/registry.h'",
            "'query-pdb/thirdparty/spdlog/include/spdlog/cfg/argv.h'",
            "'query-pdb/thirdparty/spdlog/tests/test_cfg.cpp'"
        ]
    },
    {
        "files": [
            "'Implicit-SVSDF-Planner/src/utils/include/igl/default_num_threads.h'",
            "'Implicit-SVSDF-Planner/src/utils/include/igl/parallel_for.h'",
            "'Implicit-SVSDF-Planner/src/utils/include/igl/default_num_threads.cpp'",
            "'Implicit-SVSDF-Planner/src/utils/include/igl/histc.cpp'"
        ],
        "content": "'Implicit-SVSDF-Planner/src/utils/include/igl/default_num_threads.h'\n:\n\n\n\n\n\n\n#ifndef IGL_DEFAULT_NUM_THREADS_H\n#define IGL_DEFAULT_NUM_THREADS_H\n#include \"igl_inline.h\"\n\nnamespace igl\n{\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  IGL_INLINE unsigned int default_num_threads(unsigned int force_num_threads = 0);\n}\n\n#ifndef IGL_STATIC_LIBRARY\n#include \"default_num_threads.cpp\"\n#endif\n\n#endif\n\n'Implicit-SVSDF-Planner/src/utils/include/igl/parallel_for.h'\n:\n\n\n\n\n\n\n#ifndef IGL_PARALLEL_FOR_H\n#define IGL_PARALLEL_FOR_H\n#include \"igl_inline.h\"\n#include <functional>\n\n\n\n\nnamespace igl\n{\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  template<typename Index, typename FunctionType >\n  inline bool parallel_for(\n    const Index loop_size,\n    const FunctionType & func,\n    const size_t min_parallel=0);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  template<\n    typename Index,\n    typename PrepFunctionType,\n    typename FunctionType,\n    typename AccumFunctionType\n    >\n  inline bool parallel_for(\n    const Index loop_size,\n    const PrepFunctionType & prep_func,\n    const FunctionType & func,\n    const AccumFunctionType & accum_func,\n    const size_t min_parallel=0);\n}\n\n\n\n#include \"default_num_threads.h\"\n\n#include <cmath>\n#include <cassert>\n#include <thread>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Index, typename FunctionType >\ninline bool igl::parallel_for(\n  const Index loop_size,\n  const FunctionType & func,\n  const size_t min_parallel)\n{\n  using namespace std;\n\n  const auto & no_op = [](const size_t ){};\n\n  const auto & wrapper = [&func](Index i,size_t ){ func(i); };\n  return parallel_for(loop_size,no_op,wrapper,no_op,min_parallel);\n}\n\ntemplate<\n  typename Index,\n  typename PreFunctionType,\n  typename FunctionType,\n  typename AccumFunctionType>\ninline bool igl::parallel_for(\n  const Index loop_size,\n  const PreFunctionType & prep_func,\n  const FunctionType & func,\n  const AccumFunctionType & accum_func,\n  const size_t min_parallel)\n{\n  assert(loop_size>=0);\n  if(loop_size==0) return false;\n\n\n#ifdef IGL_PARALLEL_FOR_FORCE_SERIAL\n  const size_t nthreads = 1;\n#else\n  const size_t nthreads = igl::default_num_threads();\n#endif\n  if(loop_size<min_parallel || nthreads<=1)\n  {\n\n    prep_func(1);\n    for(Index i = 0;i<loop_size;i++) func(i,0);\n    accum_func(0);\n    return false;\n  }else\n  {\n\n    Index slice =\n      std::max(\n        (Index)std::round((loop_size+1)/static_cast<double>(nthreads)),(Index)1);\n\n\n    const auto & range = [&func](const Index k1, const Index k2, const size_t t)\n    {\n      for(Index k = k1; k < k2; k++) func(k,t);\n    };\n    prep_func(nthreads);\n\n    std::vector<std::thread> pool;\n    pool.reserve(nthreads);\n\n    Index i1 = 0;\n    Index i2 = std::min(0 + slice, loop_size);\n    {\n      size_t t = 0;\n      for (; t+1 < nthreads && i1 < loop_size; ++t)\n      {\n        pool.emplace_back(range, i1, i2, t);\n        i1 = i2;\n        i2 = std::min(i2 + slice, loop_size);\n      }\n      if (i1 < loop_size)\n      {\n        pool.emplace_back(range, i1, loop_size, t);\n      }\n    }\n\n    for (std::thread &t : pool) if (t.joinable()) t.join();\n\n    for(size_t t = 0;t<nthreads;t++)\n    {\n      accum_func(t);\n    }\n    return true;\n  }\n}\n\n\n\n\n#endif\n\n'Implicit-SVSDF-Planner/src/utils/include/igl/default_num_threads.cpp'\n:\n\n\n\n\n\n\n\n#include \"default_num_threads.h\"\n\n#include <cstdlib>\n#include <thread>\n\nIGL_INLINE unsigned int igl::default_num_threads(unsigned int user_num_threads) {\n\n  class MySingleton {\n  public:\n    static MySingleton &instance(unsigned int force_num_threads) {\n      static MySingleton instance(force_num_threads);\n      return instance;\n    }\n\n    unsigned int get_num_threads() const { return m_num_threads; }\n\n  private:\n    static const char* getenv_nowarning(const char* env_var)\n    {\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4996)\n#endif\n      return std::getenv(env_var);\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n    }\n\n    MySingleton(unsigned int force_num_threads) {\n\n      if (force_num_threads) {\n        m_num_threads = force_num_threads;\n        return;\n      }\n\n      if (const char *env_str = getenv_nowarning(\"IGL_NUM_THREADS\")) {\n        const int env_num_thread = atoi(env_str);\n        if (env_num_thread > 0) {\n          m_num_threads = static_cast<unsigned int>(env_num_thread);\n          return;\n        }\n      }\n\n      const unsigned int hw_num_threads = std::thread::hardware_concurrency();\n      if (hw_num_threads) {\n        m_num_threads = hw_num_threads;\n        return;\n      }\n\n      m_num_threads = 8u;\n    }\n\n    unsigned int m_num_threads = 0;\n  };\n\n  return MySingleton::instance(user_num_threads).get_num_threads();\n}\n\n'Implicit-SVSDF-Planner/src/utils/include/igl/histc.cpp'\n:\n\n\n\n\n\n\n#include \"histc.h\"\n#include \"parallel_for.h\"\n#include <cassert>\n#include <iostream>\n\ntemplate <typename DerivedX, typename DerivedE, typename DerivedN, typename DerivedB>\nIGL_INLINE void igl::histc(\n  const Eigen::MatrixBase<DerivedX > & X,\n  const Eigen::MatrixBase<DerivedE > & E,\n  Eigen::PlainObjectBase<DerivedN > & N,\n  Eigen::PlainObjectBase<DerivedB > & B)\n{\n  histc(X,E,B);\n  const int n = E.size();\n  const int m = X.size();\n  assert(m == B.size());\n  N.resize(n,1);\n  N.setConstant(0);\n  for(int j = 0;j<m;j++)\n  {\n    if(B(j) >= 0)\n    {\n      N(int(B(j)))++;\n    }\n  }\n}\n\ntemplate <typename DerivedX, typename DerivedE, typename DerivedB>\nIGL_INLINE void igl::histc(\n  const Eigen::MatrixBase<DerivedX > & X,\n  const Eigen::MatrixBase<DerivedE > & E,\n  Eigen::PlainObjectBase<DerivedB > & B)\n{\n  const int m = X.size();\n  using namespace std;\n  assert(\n    (E.bottomRightCorner(E.size()-1,1) -\n      E.topLeftCorner(E.size()-1,1)).maxCoeff() >= 0 &&\n    \"E should be monotonically increasing\");\n  B.resize(m,1);\n  parallel_for(m,[&](const int j)\n  {\n    const double x = X(j);\n\n    if(x < E(0) || x > E(E.size()-1))\n    {\n      B(j) = -1;\n      return;\n    }\n\n    int l = 0;\n    int h = E.size()-1;\n    int k = l;\n    while((h-l)>1)\n    {\n      assert(x >= E(l));\n      assert(x <= E(h));\n      k = (h+l)/2;\n      if(x < E(k))\n      {\n        h = k;\n      }else\n      {\n        l = k;\n      }\n    }\n    if(x == E(h))\n    {\n      k = h;\n    }else\n    {\n      k = l;\n    }\n    B(j) = k;\n  },1000);\n}\n\ntemplate <typename DerivedE>\nIGL_INLINE void igl::histc(\n    const typename DerivedE::Scalar & x,\n    const Eigen::MatrixBase<DerivedE > & E,\n    typename DerivedE::Index & b)\n{\n  Eigen::Matrix<typename DerivedE::Scalar,1,1> X;\n  X(0) = x;\n  Eigen::Matrix<typename DerivedE::Index,1,1> B;\n  hist(X,E,B);\n  b = B(0);\n}\n\n#ifdef IGL_STATIC_LIBRARY\n\ntemplate void igl::histc<Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1> >(Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> >&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> >&);\ntemplate void igl::histc<Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, 1, 1, 0, 1, 1> >(Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, 1, 1, 0, 1, 1> >&);\ntemplate void igl::histc<Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, -1, 0, -1, -1> >(Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> >&);\ntemplate void igl::histc<Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, 1, 0, -1, 1> >(Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&);\ntemplate void igl::histc<Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, -1, 0, -1, -1> >(Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> >&);\ntemplate void igl::histc<Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, 1, 0, -1, 1> >(Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::MatrixBase<Eigen::Matrix<double, -1, 1, 0, -1, 1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&);\ntemplate void igl::histc<Eigen::Matrix<float, -1, 1, 0, -1, 1>, Eigen::Matrix<float, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, -1, 0, -1, -1> >(Eigen::MatrixBase<Eigen::Matrix<float, -1, 1, 0, -1, 1> > const&, Eigen::MatrixBase<Eigen::Matrix<float, -1, 1, 0, -1, 1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> >&);\ntemplate void igl::histc<Eigen::Matrix<float, -1, 1, 0, -1, 1>, Eigen::Matrix<float, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, 1, 0, -1, 1> >(Eigen::MatrixBase<Eigen::Matrix<float, -1, 1, 0, -1, 1> > const&, Eigen::MatrixBase<Eigen::Matrix<float, -1, 1, 0, -1, 1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&);\n#if EIGEN_VERSION_AT_LEAST(3,3,0)\n#else\ntemplate void igl::histc<Eigen::CwiseNullaryOp<Eigen::internal::linspaced_op<int, true>, Eigen::Matrix<int, -1, 1, 0, -1, 1> >, Eigen::Matrix<int, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, 1, 0, -1, 1> >(Eigen::MatrixBase<Eigen::CwiseNullaryOp<Eigen::internal::linspaced_op<int, true>, Eigen::Matrix<int, -1, 1, 0, -1, 1> > > const&, Eigen::MatrixBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&);\n#endif\n\n#endif\n",
        "gt": [
            "'Implicit-SVSDF-Planner/src/utils/include/igl/default_num_threads.cpp'",
            "'Implicit-SVSDF-Planner/src/utils/include/igl/default_num_threads.h'",
            "'Implicit-SVSDF-Planner/src/utils/include/igl/parallel_for.h'",
            "'Implicit-SVSDF-Planner/src/utils/include/igl/histc.cpp'"
        ]
    },
    {
        "files": [
            "'SLIDE_SLAM/backend/sloam/include/objects/semanticObject.h'",
            "'SLIDE_SLAM/backend/sloam/include/objects/cube.h'",
            "'SLIDE_SLAM/backend/sloam/src/tests/cube_factor_test.cpp'"
        ],
        "content": "'SLIDE_SLAM/backend/sloam/include/objects/semanticObject.h'\n:\n\n#pragma once\n\n#include <definitions.h>\n\ntemplate <typename T>\nclass SemanticObject {\n public:\n\n  virtual Scalar distance(const T& model) const = 0;\n  virtual Scalar distance(const PointT& point) const = 0;\n  virtual void project(const SE3& tf) = 0;\n  T getModel() const { return model; };\n  VectorType getFeatures() const { return features; };\n  size_t id;\n  bool isValid;\n  VectorType features;\n  T model;\n};\n\ntemplate <typename T>\nvoid projectObjects(const SE3& tf, std::vector<T>& objs) {\n  for (T& o : objs) o.project(tf);\n}\n\ntemplate <typename T>\nvoid projectObjects(const SE3& tf, const std::vector<T>& objs,\n                    std::vector<T>& projected) {\n  for (T o : objs) {\n    o.project(tf);\n    projected.push_back(o);\n  }\n}\n'SLIDE_SLAM/backend/sloam/include/objects/cube.h'\n:\n\n#pragma once\n\n#include <gtsam/geometry/Point3.h>\n#include <gtsam/geometry/Pose3.h>\n#include <semanticObject.h>\n#include <utils.h>\n#include <algorithm>\n\n\nstruct CubeParameters {\n  gtsam::Pose3 pose;\n  gtsam::Point3 scale;\n  int semantic_label;\n};\n\nclass Cube : public SemanticObject<CubeParameters> {\npublic:\n  explicit Cube(const gtsam::Pose3 &pose, const gtsam::Point3 &scale,\n                const int &label = -2);\n\n  Scalar distance(const CubeParameters &model) const;\n  Scalar distance(const PointT &point) const;\n\n  void project(const SE3 &tf);\n  Cube projectAndReturn(const SE3 &tf);\n  Scalar weightedDistance(const CubeParameters &model, double dim_weight= 0.0) const;\n  Scalar IoU(const CubeParameters &model) const;\n};\n\n'SLIDE_SLAM/backend/sloam/src/tests/cube_factor_test.cpp'\n:#include <cube.h>\n#include <cubeFactor.h>\n#include <definitions.h>\n#include <graph.h>\n\n#include <serialization.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"gtest/gtest.h\"\nusing ::testing::EmptyTestEventListener;\nusing ::testing::InitGoogleTest;\nusing ::testing::Test;\nusing ::testing::TestEventListeners;\nusing ::testing::TestInfo;\nusing ::testing::TestPartResult;\nusing ::testing::UnitTest;\nusing namespace gtsam_cube;\nusing namespace gtsam;\n\nclass CubeFactorTest : public ::testing::Test {\n protected:\n  void SetUp() override {\n\n\n\n\n\n\n\n\n    v_input << 0.5, 0.8, 0.3, 100.0, 12.0, 10.5;\n    gtsam::Pose3 pose_temp = gtsam::Pose3::Expmap(v_input);\n    Cube cube_temp = Cube(pose_temp, gtsam::Point3(2.0, 3.5, 0.5));\n    landmarks.push_back(cube_temp);\n    noiseModel = noiseModel::Diagonal::Sigmas(Vector9::Ones() * 0.01);\n  }\n\n  gtsam::Vector6 v_input;\n  std::vector<Cube> landmarks;\n  boost::shared_ptr<noiseModel::Diagonal> noiseModel;\n};\n\n\nTEST_F(CubeFactorTest, Initalizes) {\n  auto c = Cube(landmarks[0].model.pose, landmarks[0].model.scale);\n  CubeMeasurement cm = CubeMeasurement(c);\n  auto cf = CubeFactor(0, 0, cm, noiseModel);\n  EXPECT_TRUE(cf.equals(cf));\n}\n\n\nTEST_F(CubeFactorTest, EvalError) {\n\n\n\n\n\n\n  gtsam::Vector6 v_input2;\n  v_input2 << 0.0, 0.0, 0.0, 100.0, 12.0, 10.5;\n  gtsam::Pose3 pose_temp2 = gtsam::Pose3::Expmap(v_input2);\n  Cube cube_temp2 = Cube(pose_temp2, gtsam::Point3(2.0, 3.5, 0.5));\n  auto c = Cube(cube_temp2.model.pose, cube_temp2.model.scale);\n\n\n  gtsam::Vector6 v_error_temp;\n  v_error_temp << 0.0, 0.0, 0.0, 5.0, 10.0, 20.0;\n  gtsam::Pose3 pose_temp = gtsam::Pose3::Expmap(v_input2 + v_error_temp);\n\n  CubeMeasurement cube_landmark = CubeMeasurement(c);\n  auto c_error = Cube(pose_temp, cube_temp2.model.scale);\n  CubeMeasurement cube_noisy = CubeMeasurement(c_error);\n  CubeFactor cube_measurement = CubeFactor(0, 0, cube_noisy, noiseModel);\n  CubeFactor cube_measurement_no_noise =\n      CubeFactor(0, 0, cube_landmark, noiseModel);\n  auto pose = gtsam::Pose3();\n  auto error = cube_measurement.evaluateError(pose, cube_landmark, boost::none,\n                                              boost::none);\n\n\n\n\n  v_error_temp << 0.3, 0.5, 1.0, 5.0, 10.0, 20.0;\n  gtsam::Pose3 pose_temp3 = gtsam::Pose3::Expmap(v_input2 + v_error_temp);\n\n  CubeMeasurement cube_landmark2 = CubeMeasurement(c);\n  auto c_error2 = Cube(pose_temp3, cube_temp2.model.scale);\n  CubeMeasurement cube_noisy2 = CubeMeasurement(c_error2);\n  CubeFactor cube_measurement2 = CubeFactor(0, 0, cube_noisy2, noiseModel);\n  CubeFactor cube_measurement_no_noise2 =\n      CubeFactor(0, 0, cube_landmark2, noiseModel);\n  auto pose2 = gtsam::Pose3();\n  auto error2 = cube_measurement2.evaluateError(pose, cube_landmark2,\n                                                boost::none, boost::none);\n\n\n\n  gtsam::Vector9 error_all;\n  error_all << error2(0), error2(1), error2(2), error(3), error(4), error(5), 0,\n      0, 0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  for (auto i = 0; i < v_error_temp.size(); ++i) {\n    std::cout << \"for index:\";\n    std::cout << i;\n    std::cout << \", calculated error is:\";\n    std::cout << (error_all[i]);\n    std::cout << \", actual error is:\";\n    std::cout << (v_error_temp[i]) << '\\n';\n  }\n\n  for (auto i = 0; i < v_error_temp.size(); ++i) {\n    EXPECT_NEAR(error_all[i], v_error_temp[i], 1e-2);\n  }\n}\n\n\nTEST_F(CubeFactorTest, EvalErrorJacobian) {\n  auto cA = Cube(landmarks[0].model.pose, landmarks[0].model.scale);\n  auto cB = Cube(landmarks[0].model.pose, landmarks[0].model.scale);\n  SE3 tf;\n  tf.translation()[1] = 0.5;\n  cB.project(tf);\n\n  cB.model.scale = gtsam::Point3(0.1, 0.1, 0.1);\n\n  CubeMeasurement cAm = CubeMeasurement(cA);\n  CubeMeasurement cBm = CubeMeasurement(cB);\n\n  auto cf = CubeFactor(0, 0, cAm, noiseModel);\n  auto pose = gtsam::Pose3();\n  gtsam::Matrix H;\n  auto error = cf.evaluateError(pose, cBm, H, boost::none);\n  auto d = H * error;\n  EXPECT_TRUE(d[1] - 0.5 < 1e-2);\n  EXPECT_TRUE(d[6] - 0.1 < 1e-2);\n  EXPECT_TRUE(d[7] - 0.1 < 1e-2);\n  EXPECT_TRUE(d[8] - 0.1 < 1e-2);\n}\n\n\nTEST_F(CubeFactorTest, RetractOrigin) {\n  gtsam::Vector9 v;\n  v << 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.1, 0.1;\n  gtsam::Vector9 v_pose;\n  v_pose = v.head(6);\n  CubeMeasurement cm = CubeMeasurement::Retract(v);\n  for (int i = 0; i < 6; i++) {\n    EXPECT_TRUE(gtsam::Pose3::Logmap(cm.pose)[i] == v_pose[i]);\n  }\n  EXPECT_TRUE(cm.scale[0] == 0.1);\n  EXPECT_TRUE(cm.scale[1] == 0.1);\n  EXPECT_TRUE(cm.scale[2] == 0.1);\n}\n\n\nTEST_F(CubeFactorTest, LocalOrigin) {\n  auto c = Cube(landmarks[0].model.pose, landmarks[0].model.scale);\n  CubeMeasurement cm = CubeMeasurement(c);\n  gtsam::Vector9 v = CubeMeasurement::LocalCoordinates(cm);\n  auto v_temp = gtsam::Pose3::Logmap(landmarks[0].model.pose);\n  EXPECT_TRUE(v.head(6) == v_temp);\n  EXPECT_TRUE(v[6] == landmarks[0].model.scale[0]);\n  EXPECT_TRUE(v[7] == landmarks[0].model.scale[1]);\n  EXPECT_TRUE(v[8] == landmarks[0].model.scale[2]);\n}\n\n\nTEST_F(CubeFactorTest, LocalCoordinates) {\n  auto cA = Cube(landmarks[0].model.pose, landmarks[0].model.scale);\n  auto cB = Cube(landmarks[0].model.pose, landmarks[0].model.scale);\n  SE3 tf;\n\n\n  cA.model.scale = cA.model.scale + gtsam::Point3(0.1, 0.1, 0.1);\n  CubeMeasurement cAm = CubeMeasurement(cA);\n  CubeMeasurement cBm = CubeMeasurement(cB);\n\n\n  gtsam::Vector9 v = cAm.localCoordinates(cBm);\n\n  EXPECT_NEAR(v[6], 0.1, 1e-2);\n  EXPECT_NEAR(v[7], 0.1, 1e-2);\n  EXPECT_NEAR(v[8], 0.1, 1e-2);\n}\n\nTEST_F(CubeFactorTest, Retract) {\n  auto cA = Cube(landmarks[0].model.pose, landmarks[0].model.scale);\n  CubeMeasurement cAm = CubeMeasurement(cA);\n  gtsam::Vector9 v;\n\n  v << 1.8, 0.2, 1.0, 30.0, 100, 2.5, 1.0, 1.0, 1.0;\n\n  CubeMeasurement cBm = cAm.retract(v);\n  gtsam::Vector6 pose_temp;\n\n\n\n  gtsam::Pose3 pose_temp_pose3 =\n      cAm.pose * gtsam::Pose3::Expmap(v.segment(0, 6));\n  pose_temp = gtsam::Pose3::Logmap(pose_temp_pose3);\n\n  for (int i = 0; i < 6; i++) {\n    EXPECT_NEAR(pose_temp[i], gtsam::Pose3::Logmap(cBm.pose)[i], 0.01);\n  }\n  std::cout << \"pose_temp:\\n\" << pose_temp << '\\n';\n  std::cout << \"cAm:\\n\" << gtsam::Pose3::Logmap(cAm.pose) << '\\n';\n  std::cout << \"cBm:\\n\" << gtsam::Pose3::Logmap(cBm.pose) << '\\n';\n\n  EXPECT_NEAR(cAm.scale[0] + 1, cBm.scale[0], 1e-2);\n  EXPECT_NEAR(cAm.scale[1] + 1, cBm.scale[1], 1e-2);\n  EXPECT_NEAR(cAm.scale[2] + 1, cBm.scale[2], 1e-2);\n}\n\nTEST_F(CubeFactorTest, FactorGraph) {\n  auto graph = SemanticFactorGraph();\n  auto poseA = gtsam::Pose3(gtsam::Rot3(), gtsam::Point3(0.0, 0.0, 0.0));\n  auto poseB = gtsam::Pose3(gtsam::Rot3(), gtsam::Point3(0.1, 0.0, 0.0));\n  auto poseC = gtsam::Pose3(gtsam::Rot3(), gtsam::Point3(-0.1, 0.0, 0.0));\n\n  graph.setPriors(poseA);\n  graph.addKeyPoseAndBetween(0, 1, poseA, poseB, 0);\n  graph.addKeyPoseAndBetween(1, 2, poseB, poseC, 0);\n\n  auto ca = Cube(landmarks[0].model.pose, landmarks[0].model.scale);\n  auto cb = Cube(landmarks[0].model.pose, landmarks[0].model.scale);\n  auto cc = Cube(landmarks[0].model.pose, landmarks[0].model.scale);\n  ca.model.scale = gtsam::Point3(0.1, 0.1, 0.1);\n  cb.model.scale = gtsam::Point3(0.15, 0.15, 0.15);\n  cc.model.scale = gtsam::Point3(0.05, 0.05, 0.05);\n\n\n  graph.addCubeFactor(0, 0, poseA, ca, false, 0);\n  graph.addCubeFactor(1, 0, poseB, cb, true, 0);\n  graph.solve();\n  graph.getCube(0).print();\n\n\n  graph.addCubeFactor(2, 0, poseC, cc, true, 0);\n  graph.solve();\n  graph.getCube(0).print();\n\n  graph.getPose(0).print();\n  graph.getPose(1).print();\n  graph.getPose(2).print();\n  EXPECT_NEAR(graph.getCube(0).scale[0], 0.1, 1e-5);\n}",
        "gt": [
            "'SLIDE_SLAM/backend/sloam/include/objects/semanticObject.h'",
            "'SLIDE_SLAM/backend/sloam/include/objects/cube.h'",
            "'SLIDE_SLAM/backend/sloam/src/tests/cube_factor_test.cpp'"
        ]
    },
    {
        "files": [
            "'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/Tracker.h'",
            "'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/ATANCamera.h'",
            "'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/SmallBlurryImage.h'",
            "'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/MapMaker.h'"
        ],
        "content": "'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/Tracker.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __TRACKER_H\n#define __TRACKER_H\n\n#include \"MapMaker.h\"\n#include \"ATANCamera.h\"\n#include \"MiniPatch.h\"\n#include \"Relocaliser.h\"\n#include \"ptam/Params.h\"\n\n#include <sstream>\n#include <vector>\n#include <list>\n\nstruct TrackerData;\nstruct Trail\n{\n  MiniPatch mPatch;\n  CVD::ImageRef irCurrentPos;\n  CVD::ImageRef irInitialPos;\n};\n\nclass Tracker\n{\npublic:\n  Tracker(CVD::ImageRef irVideoSize, const ATANCamera &c, Map &m, MapMaker &mm);\n\n\n  void TrackFrame(CVD::Image<CVD::byte> &imFrame, bool bDraw);\n  void TrackFrame(CVD::Image<CVD::byte> &imFrame, bool bDraw, const TooN::SO3<double> & imuOrientation);\n\n  inline SE3<> GetCurrentPose() { return mse3CamFromWorld;}\n\n  inline Matrix<6> GetCurrentCov() { return mmCovariances;}\n  inline KeyFrame::Ptr GetCurrentKF() { return mCurrentKF;}\n  Vector<3> CalcSBIRotation(SmallBlurryImage *SBI1, SmallBlurryImage *SBI2);\n\n\n  std::string GetMessageForUser();\n  int getTrackingQuality(){return mTrackingQuality;}\n\n  void command(const std::string & params);\n  std::list<Trail> & getTrails(){return  mlTrails;};\n  bool getTrailTrackingStarted(){return mnInitialStage == TRAIL_TRACKING_STARTED;};\n  bool getTrailTrackingComplete(){return mnInitialStage == TRAIL_TRACKING_COMPLETE;};\n  CVD::Image<TooN::Vector<2> > & ComputeGrid();\n\nprotected:\n  CVD::Image<TooN::Vector<2> > mProjVertices;\n  KeyFrame::Ptr mCurrentKF;\n\n\n  Map &mMap;\n  MapMaker &mMapMaker;\n  ATANCamera mCamera;\n  Relocaliser mRelocaliser;\n\n  CVD::ImageRef mirSize;\n\n  void Reset();\n  void RenderGrid();\n\n\n  void TrackForInitialMap();\n  enum {TRAIL_TRACKING_NOT_STARTED,\n    TRAIL_TRACKING_STARTED,\n    TRAIL_TRACKING_COMPLETE} mnInitialStage;\n    void TrailTracking_Start();\n    int  TrailTracking_Advance();\n    std::list<Trail> mlTrails;\n    KeyFrame::Ptr mFirstKF;\n    KeyFrame::Ptr mPreviousFrameKF;\n\n\n    void TrackMap();\n    void AssessTrackingQuality();\n    void ApplyMotionModel();\n    void UpdateMotionModel();\n    int SearchForPoints(std::vector<TrackerData*> &vTD,\n                        int nRange,\n                        int nFineIts);\n    Vector<6> CalcPoseUpdate(std::vector<TrackerData*> vTD,\n                             double dOverrideSigma = 0.0,\n                             bool bMarkOutliers = false);\n    SE3<> mse3CamFromWorld;\n    SE3<> mse3StartPos;\n    Vector<6> mv6CameraVelocity;\n    double mdVelocityMagnitude;\n    double mdMSDScaledVelocityMagnitude;\n    bool mbDidCoarse;\n\n    bool mbDraw;\n\n\n    SO3<> mso3CurrentImu;\n    SO3<> mso3LastImu;\n\n\n\n\n\n    Matrix<6>\tmmCovariances;\n    KeyFrame::Ptr mOldKF;\n    bool mAutoreset;\n\n\n\n    int mnFrame;\n    int mnLastKeyFrameDropped;\n    void AddNewKeyFrame();\n\n\n    int manMeasAttempted[LEVELS];\n    int manMeasFound[LEVELS];\n    enum {BAD, DODGY, GOOD} mTrackingQuality;\n    int mnLostFrames;\n\n\n    bool AttemptRecovery();\n    bool mbJustRecoveredSoUseCoarse;\n\n\n    SmallBlurryImage *mpSBILastFrame;\n    SmallBlurryImage *mpSBIThisFrame;\n    void CalcSBIRotation();\n    Vector<6> mv6SBIRot;\n    bool mbUseSBIInit;\n\n\n    bool mbUserPressedSpacebar;\n    std::ostringstream mMessageForUser;\n\n\n    void GUICommandHandler(std::string sCommand, std::string sParams);\n    static void GUICommandCallBack(void* ptr, std::string sCommand, std::string sParams);\n    struct Command {std::string sCommand; std::string sParams; };\n    std::vector<Command> mvQueuedCommands;\n\n\n};\n\n#endif\n\n\n\n\n\n\n\n'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/ATANCamera.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __ATAN_CAMERA_H\n#define __ATAN_CAMERA_H\n\n#include <TooN/TooN.h>\n#include <cmath>\nusing namespace TooN;\n#include <cvd/vector_image_ref.h>\n\n\n#include <ros/ros.h>\n#include <ros/package.h>\n\n#define NUMTRACKERCAMPARAMETERS 5\n\nclass CameraCalibrator;\nclass CalibImage;\n\n\n\n\n\n\n\n\nclass ATANCamera {\npublic:\n  ATANCamera(std::string sName);\n\n\n  void SetImageSize(Vector<2> v2ImageSize);\n  inline void SetImageSize(CVD::ImageRef irImageSize) {SetImageSize(vec(irImageSize));};\n  inline Vector<2> GetImageSize() {return mvImageSize;};\n  void RefreshParams();\n\n\n  Vector<2> Project(const Vector<2>& camframe);\n  inline Vector<2> Project(CVD::ImageRef ir) { return Project(vec(ir)); }\n  Vector<2> UnProject(const Vector<2>& imframe);\n  inline Vector<2> UnProject(CVD::ImageRef ir)  { return UnProject(vec(ir)); }\n\n  Vector<2> UFBProject(const Vector<2>& camframe);\n  Vector<2> UFBUnProject(const Vector<2>& camframe);\n  inline Vector<2> UFBLinearProject(const Vector<2>& camframe);\n  inline Vector<2> UFBLinearUnProject(const Vector<2>& fbframe);\n\n  Matrix<2,2> GetProjectionDerivs();\n\n  inline bool Invalid() {  return mbInvalid;}\n  inline double LargestRadiusInImage() {  return mdLargestRadius; }\n  inline double OnePixelDist() { return mdOnePixelDist; }\n\n\n  inline Vector<2> ImplaneTL();\n  inline Vector<2> ImplaneBR();\n\n\n  Matrix<4> MakeUFBLinearFrustumMatrix(double near, double far);\n\n\n  double PixelAspectRatio() { return mvFocal[1] / mvFocal[0];}\n\n\n\n  static const Vector<NUMTRACKERCAMPARAMETERS> mvDefaultParams;\n\n\n\n  Vector<NUMTRACKERCAMPARAMETERS> mgvvCameraParams;\n\n\nprotected:\n\n\n  Matrix<2, NUMTRACKERCAMPARAMETERS> GetCameraParameterDerivs();\n  void UpdateParams(Vector<NUMTRACKERCAMPARAMETERS> vUpdate);\n  void DisableRadialDistortion();\n\n\n  double MaxFOV_;\n\n\n  Vector<2> mvLastCam;\n  Vector<2> mvLastIm;\n  Vector<2> mvLastDistCam;\n  double mdLastR;\n  double mdLastDistR;\n  double mdLastFactor;\n  bool mbInvalid;\n\n\n  double mdLargestRadius;\n  double mdMaxR;\n  double mdOnePixelDist;\n  double md2Tan;\n  double mdOneOver2Tan;\n  double mdW;\n  double mdWinv;\n  double mdDistortionEnabled;\n  Vector<2> mvCenter;\n  Vector<2> mvFocal;\n  Vector<2> mvInvFocal;\n  Vector<2> mvImageSize;\n  Vector<2> mvUFBLinearFocal;\n  Vector<2> mvUFBLinearInvFocal;\n  Vector<2> mvUFBLinearCenter;\n  Vector<2> mvImplaneTL;\n  Vector<2> mvImplaneBR;\n\n\n  inline double rtrans_factor(double r)\n  {\n    if(r < 0.001 || mdW == 0.0)\n      return 1.0;\n    else\n      return (mdWinv* atan(r * md2Tan) / r);\n  };\n\n\n  inline double invrtrans(double r)\n  {\n    if(mdW == 0.0)\n      return r;\n   \treturn tan(r * mdW) * mdOneOver2Tan;\n  };\n\n  std::string msName;\n\n  friend class CameraCalibrator;\n  friend class CalibImage;\n};\n\n\ninline Vector<2> ATANCamera::UFBLinearProject(const Vector<2>& camframe)\n{\n  Vector<2> v2Res;\n  v2Res[0] = camframe[0] * mvUFBLinearFocal[0] + mvUFBLinearCenter[0];\n  v2Res[1] = camframe[1] * mvUFBLinearFocal[1] + mvUFBLinearCenter[1];\n  return v2Res;\n}\n\ninline Vector<2> ATANCamera::UFBLinearUnProject(const Vector<2>& fbframe)\n{\n  Vector<2> v2Res;\n  v2Res[0] = (fbframe[0] - mvUFBLinearCenter[0]) * mvUFBLinearInvFocal[0];\n  v2Res[1] = (fbframe[1] - mvUFBLinearCenter[1]) * mvUFBLinearInvFocal[1];\n  return v2Res;\n}\n\n\n#endif\n\n\n'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/SmallBlurryImage.h'\n:\n\n\n\n\n\n#ifndef __SMALLBLURRYIMAGE_H\n#define __SMALLBLURRYIMAGE_H\n#include <cvd/image.h>\n#include <cvd/byte.h>\n#include <TooN/se2.h>\n#include <TooN/se3.h>\n#include \"KeyFrame.h\"\n#include \"ATANCamera.h\"\n\nclass SmallBlurryImage\n{\npublic:\n  SmallBlurryImage();\n  SmallBlurryImage(KeyFrame& kf, double dBlur = 2.5);\n  void MakeFromKF(KeyFrame& kf, double dBlur = 2.5);\n  void MakeJacs();\n  double ZMSSD(SmallBlurryImage &other);\n  std::pair<SE2<>,double> IteratePosRelToTarget(SmallBlurryImage &other, int nIterations = 10);\n  static SE3<> SE3fromSE2(SE2<> se2, ATANCamera camera);\n\nprotected:\n  CVD::Image<CVD::byte> mimSmall;\n  CVD::Image<float> mimTemplate;\n  CVD::Image<Vector<2> > mimImageJacs;\n  bool mbMadeJacs;\n  static CVD::ImageRef mirSize;\n};\n\n\n\n#endif\n\n\n\n\n\n\n\n\n\n\n'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/MapMaker.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __MAPMAKER_H\n#define __MAPMAKER_H\n#include <cvd/image.h>\n#include <cvd/byte.h>\n#include <cvd/thread.h>\n\n#include \"Map.h\"\n#include \"KeyFrame.h\"\n#include \"ATANCamera.h\"\n#include \"SmallBlurryImage.h\"\n#include <queue>\n#include <sstream>\n#include <boost/shared_ptr.hpp>\n#include <ptam/OctomapInterface.h>\n\n\n\n\n\nstruct MapMakerData\n{\n  std::set<KeyFrame::Ptr> sMeasurementKFs;\n  std::set<KeyFrame::Ptr> sNeverRetryKFs;\n  inline int GoodMeasCount()\n  {  return sMeasurementKFs.size(); }\n};\n\n\nclass MapMaker : protected CVD::Thread\n{\npublic:\n  MapMaker(Map &m, const ATANCamera &cam, ros::NodeHandle& nh);\n  ~MapMaker();\n\n\n  bool InitFromStereo(KeyFrame::Ptr kFirst, KeyFrame::Ptr kSecond,\n                      std::vector<std::pair<CVD::ImageRef, CVD::ImageRef> > &vMatches,\n                      SE3<> &se3CameraPos);\n\n  bool InitFromStereo_OLD(KeyFrame::Ptr kFirst, KeyFrame::Ptr kSecond,\n                          std::vector<std::pair<CVD::ImageRef, CVD::ImageRef> > &vMatches,\n                          SE3<> &se3CameraPos);\n\n\n  void AddKeyFrame(KeyFrame::Ptr k);\n  void RequestReset();\n  bool ResetDone();\n  int  QueueSize() { return mvpKeyFrameQueue.size() ;}\n  bool NeedNewKeyFrame(KeyFrame::Ptr kCurrent);\n  bool IsDistanceToNearestKeyFrameExcessive(KeyFrame::Ptr kCurrent);\n\n  std::string getMessageForUser(){return mMessageForUser.str();};\n  void resetMessageForUser(){mMessageForUser.str(\"\"); };\n\n\n  void ApplyGlobalScaleToMap(double dScale);\n  void ApplyGlobalTransformationToMap(SE3<> se3NewFromOld);\n  KeyFrame::Ptr ClosestKeyFrame(KeyFrame::Ptr k);\n  std::vector<KeyFrame::Ptr> NClosestKeyFrames(KeyFrame::Ptr k, unsigned int N);\n\n\nprotected:\n\n  Map &mMap;\n  ATANCamera mCamera;\n  virtual void run();\n\n\n  OctoMapInterface octomap_interface;\n\n\n\n  SE3<> CalcPlaneAligner();\n\n\n  void AddKeyFrameFromTopOfQueue();\n  void ThinCandidates(KeyFrame::Ptr k, int nLevel);\n  bool AddSomeMapPoints(int nLevel);\n  bool AddPointEpipolar(KeyFrame::Ptr kSrc, KeyFrame::Ptr kTarget, int nLevel, int nCandidate);\n\n  Vector<3> ReprojectPoint(SE3<> se3AfromB, const Vector<2> &v2A, const Vector<2> &v2B);\n\n\n  void BundleAdjust(std::set<KeyFrame::Ptr>, std::set<KeyFrame::Ptr>, std::set<boost::shared_ptr<MapPoint> >, bool);\n  void BundleAdjustAll();\n  void BundleAdjustRecent();\n\n\n  int ReFindInSingleKeyFrame(KeyFrame::Ptr k);\n  void ReFindFromFailureQueue();\n  void ReFindNewlyMade();\n  void ReFindAll();\n  bool ReFind_Common(KeyFrame::Ptr k, boost::shared_ptr<MapPoint> p);\n  void SubPixelRefineMatches(KeyFrame::Ptr k, int nLevel);\n\n\n  void Reset();\n  void HandleBadPoints();\n  double DistToNearestKeyFrame(KeyFrame::Ptr kCurrent);\n  double KeyFrameLinearDist(KeyFrame::Ptr k1, KeyFrame::Ptr k2);\n  bool RefreshSceneDepth(KeyFrame::Ptr pKF);\n\n\n\n  void GUICommandHandler(std::string sCommand, std::string sParams);\n  static void GUICommandCallBack(void* ptr, std::string sCommand, std::string sParams);\n  struct Command {std::string sCommand; std::string sParams; };\n  std::vector<Command> mvQueuedCommands;\n\n\n\n  std::vector<KeyFrame::Ptr> mvpKeyFrameQueue;\n  std::vector<std::pair<KeyFrame::Ptr, boost::shared_ptr<MapPoint> > > mvFailureQueue;\n  std::queue<boost::shared_ptr<MapPoint> > mqNewQueue;\n\n  double mdWiggleScale;\n\n\n  double mdWiggleScaleDepthNormalized;\n\n\n  bool mbBundleConverged_Full;\n  bool mbBundleConverged_Recent;\n\n\n  bool mbResetRequested;\n  bool mbResetDone;\n  bool mbBundleAbortRequested;\n  bool mbBundleRunning;\n  bool mbBundleRunningIsRecent;\n\n\n  std::ostringstream mMessageForUser;\n};\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "gt": [
            "'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/ATANCamera.h'",
            "'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/SmallBlurryImage.h'",
            "'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/MapMaker.h'",
            "'ROS-Hydro-SLAM/ethzasl_ptam/ptam/include/ptam/Tracker.h'"
        ]
    },
    {
        "files": [
            "'pyeos/plugins/history_plugin/include/eosio/history_plugin/history_plugin.hpp'",
            "'pyeos/plugins/history_api_plugin/include/eosio/history_api_plugin/history_api_plugin.hpp'",
            "'pyeos/programs/pyeos/main.cpp'"
        ],
        "content": "'pyeos/plugins/history_plugin/include/eosio/history_plugin/history_plugin.hpp'\n:\n#pragma once\n#include <appbase/application.hpp>\n\n#include <eosio/chain_plugin/chain_plugin.hpp>\n\nnamespace fc { class variant; }\n\nnamespace eosio {\n   using chain::transaction_id_type;\n   using std::shared_ptr;\n   using namespace appbase;\n   using chain::name;\n   using fc::optional;\n   using chain::uint128_t;\n\n   typedef shared_ptr<class history_plugin_impl> history_ptr;\n   typedef shared_ptr<const class history_plugin_impl> history_const_ptr;\n\nnamespace history_apis {\n\nclass read_only {\n   history_const_ptr history;\n\n   public:\n      read_only(history_const_ptr&& history)\n         : history(history) {}\n\n\n      struct get_actions_params {\n         chain::account_name account_name;\n         optional<int32_t>   pos;\n         optional<int32_t>   offset;\n      };\n\n      struct ordered_action_result {\n         uint64_t                     global_action_seq = 0;\n         int32_t                      account_action_seq = 0;\n         uint32_t                     block_num;\n         chain::block_timestamp_type  block_time;\n         fc::variant                  action_trace;\n      };\n\n      struct get_actions_result {\n         vector<ordered_action_result> actions;\n         uint32_t                      last_irreversible_block;\n         optional<bool>                time_limit_exceeded_error;\n      };\n\n\n      virtual get_actions_result get_actions( const get_actions_params& )const;\n\n\n      struct get_transaction_params {\n         string                        id;\n         optional<uint32_t>            block_num_hint;\n      };\n\n      struct get_transaction_result {\n         transaction_id_type                   id;\n         fc::variant                           trx;\n         chain::block_timestamp_type           block_time;\n         uint32_t                              block_num = 0;\n         uint32_t                              last_irreversible_block = 0;\n         vector<fc::variant>                   traces;\n      };\n\n      virtual get_transaction_result get_transaction( const get_transaction_params& )const;\n\n\n\n\n\n\n\n      struct get_key_accounts_params {\n         chain::public_key_type     public_key;\n      };\n      struct get_key_accounts_results {\n         vector<chain::account_name> account_names;\n      };\n      virtual get_key_accounts_results get_key_accounts(const get_key_accounts_params& params) const;\n\n\n      struct get_controlled_accounts_params {\n         chain::account_name     controlling_account;\n      };\n      struct get_controlled_accounts_results {\n         vector<chain::account_name> controlled_accounts;\n      };\n      virtual get_controlled_accounts_results get_controlled_accounts(const get_controlled_accounts_params& params) const;\n};\n\n\n}\n\n\n\nclass history_plugin : public plugin<history_plugin> {\n   public:\n      APPBASE_PLUGIN_REQUIRES((chain_plugin))\n\n      history_plugin();\n      virtual ~history_plugin();\n\n      virtual void set_program_options(options_description& cli, options_description& cfg) override;\n\n      void plugin_initialize(const variables_map& options);\n      void plugin_startup();\n      void plugin_shutdown();\n\n      history_apis::read_only&  get_read_only_api()const { return *ro; }\n\n   private:\n      history_ptr my;\n      history_apis::read_only* ro;\n};\n\n}\n\nFC_REFLECT( eosio::history_apis::read_only::get_actions_params, (account_name)(pos)(offset) )\nFC_REFLECT( eosio::history_apis::read_only::get_actions_result, (actions)(last_irreversible_block)(time_limit_exceeded_error) )\nFC_REFLECT( eosio::history_apis::read_only::ordered_action_result, (global_action_seq)(account_action_seq)(block_num)(block_time)(action_trace) )\n\nFC_REFLECT( eosio::history_apis::read_only::get_transaction_params, (id)(block_num_hint) )\nFC_REFLECT( eosio::history_apis::read_only::get_transaction_result, (id)(trx)(block_time)(block_num)(last_irreversible_block)(traces) )\n\nFC_REFLECT(eosio::history_apis::read_only::get_key_accounts_params, (public_key) )\nFC_REFLECT(eosio::history_apis::read_only::get_key_accounts_results, (account_names) )\nFC_REFLECT(eosio::history_apis::read_only::get_controlled_accounts_params, (controlling_account) )\nFC_REFLECT(eosio::history_apis::read_only::get_controlled_accounts_results, (controlled_accounts) )\n\n'pyeos/plugins/history_api_plugin/include/eosio/history_api_plugin/history_api_plugin.hpp'\n:\n\n#pragma once\n#include <eosio/history_plugin/history_plugin.hpp>\n#include <eosio/chain_plugin/chain_plugin.hpp>\n#include <eosio/http_plugin/http_plugin.hpp>\n\n#include <appbase/application.hpp>\n\nnamespace eosio {\n\n   using namespace appbase;\n\n   class history_api_plugin : public plugin<history_api_plugin> {\n      public:\n        APPBASE_PLUGIN_REQUIRES((history_plugin)(chain_plugin)(http_plugin))\n\n        history_api_plugin();\n        virtual ~history_api_plugin();\n\n        virtual void set_program_options(options_description&, options_description&) override;\n\n        void plugin_initialize(const variables_map&);\n        void plugin_startup();\n        void plugin_shutdown();\n\n      private:\n   };\n\n}\n\n'pyeos/programs/pyeos/main.cpp'\n:#include <appbase/application.hpp>\n#include <fc/log/logger_config.hpp>\n#include <fc/exception/exception.hpp>\n\n#include <boost/chrono.hpp>\n#include <boost/thread/thread.hpp>\n#include <boost/exception/diagnostic_information.hpp>\n\n#include <eosio/history_plugin/history_plugin.hpp>\n#include <eosio/net_plugin/net_plugin.hpp>\n#include <eosio/http_plugin/http_plugin.hpp>\n#include <eosio/chain_plugin/chain_plugin.hpp>\n#include <eosio/producer_plugin/producer_plugin.hpp>\n#include <eosio/chain_api_plugin/chain_api_plugin.hpp>\n#include <eosio/history_api_plugin/history_api_plugin.hpp>\n\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <Python.h>\n\n#include <mutex>\n#include <condition_variable>\n\n#include <config.hpp>\n\n\n\n\nusing namespace appbase;\nusing namespace eosio;\nusing namespace eosio::chain;\n\nstatic bool init_finished = false;\nstatic bool shutdown_finished = false;\nstatic std::condition_variable cv;\nstatic std::mutex cv_m;\n\nstatic int g_argc = 0;\nstatic char** g_argv = NULL;\n\n\nvoid py_exit();\n\nextern \"C\" {\n   void init_api();\n   PyObject* PyInit_eosapi();\n   PyObject* PyInit_wallet();\n   PyObject* PyInit_net();\n\n\n   PyObject* PyInit_eoslib();\n   PyObject* PyInit_db();\n   PyObject* PyInit_rodb();\n   PyObject* PyInit_debug();\n   PyObject* PyInit_python_contract();\n   PyObject* PyInit__struct();\n   PyObject* PyInit_pyobject();\n\n   PyObject* PyInit_vm_cpython();\n   PyObject* PyInit_db();\n   PyObject* PyInit_eoslib();\n\n\n   void vm_deinit_all();\n   void vm_api_init();\n   void vm_manager_init();\n}\n\nbool is_init_finished() {\n   return init_finished;\n}\n\nvoid init_console() {\n   PyImport_AppendInittab(\"pyobject\", PyInit_pyobject);\n   PyImport_AppendInittab(\"wallet\", PyInit_wallet);\n   PyImport_AppendInittab(\"eosapi\", PyInit_eosapi);\n   PyImport_AppendInittab(\"net\", PyInit_net);\n   PyImport_AppendInittab(\"rodb\", PyInit_rodb);\n   PyImport_AppendInittab(\"debug\", PyInit_debug);\n\n   Py_InitializeEx(0);\n   PyEval_InitThreads();\n\n   PyImport_ImportModule(\"pyobject\");\n   PyImport_ImportModule(\"wallet\");\n   PyImport_ImportModule(\"eosapi\");\n   PyImport_ImportModule(\"net\");\n   PyImport_ImportModule(\"rodb\");\n   PyImport_ImportModule(\"debug\");\n\n   PyImport_ImportModule(\"vm_cpython\");\n   PyImport_ImportModule(\"db\");\n   PyImport_ImportModule(\"eoslib\");\n\n   PyRun_SimpleString(\n       \"import sys;\"\n        \"sys.path.append('../../programs/pyeos');\"\n        \"sys.path.append('../../programs/pyeos/contracts');\"\n   );\n   PyRun_SimpleString(\"import readline\");\n   PyRun_SimpleString(\"import wallet\");\n   PyRun_SimpleString(\"import eosapi;\");\n   PyRun_SimpleString(\"import debug;\");\n   PyRun_SimpleString(\"import vm_cpython;\");\n   PyRun_SimpleString(\"import db;\");\n   PyRun_SimpleString(\"import eoslib;\");\n\n   PyRun_SimpleString(\"from imp import reload;\");\n   PyRun_SimpleString(\"import initeos;initeos.preinit()\");\n}\n\nvoid start_eos() {\n   try {\n      app().startup();\n      wlog(\"+++++++++++app().startup() done!\");\n      {\n\n      }\n      cv.notify_all();\n      init_finished = true;\n      app().exec();\n   } FC_LOG_AND_DROP();\n   wlog(\"+++++++++++app exec done!!\");\n   {\n       std::lock_guard<std::mutex> lk(cv_m);\n       init_finished = true;\n       shutdown_finished = true;\n   }\n   cv.notify_all();\n}\n\nvoid cleos_init();\nvoid init_wallet();\nvoid init_producer();\nextern \"C\" void vm_manager_init_python();\nvoid cleos_set_http_url(std::string& s);\n\nint main(int argc, char** argv) {\n\n   setenv(\"PYTHONHOME\",\"../../externals/python/dist\",1);\n   setenv(\"PYTHONPATH\",\"../../externals/python/dist/lib\",1);\n   g_argc = argc;\n   g_argv = argv;\n\n   init_wallet();\n   init_producer();\n   cleos_init();\n   vm_api_init();\n\n   vm_manager_init_python();\n\n   app().set_version(eosio::nodeos::config::version);\n   app().register_plugin<history_plugin>();\n   app().register_plugin<history_api_plugin>();\n\n   app().register_plugin<chain_api_plugin>();\n   app().register_plugin<producer_plugin>();\n\n   init_console();\n\n\n   try {\n      try {\n         if(!app().initialize<chain_api_plugin, http_plugin, net_plugin, history_plugin, producer_plugin>(g_argc, g_argv)) {\n            return -1;\n         }\n      } FC_LOG_AND_RETHROW();\n   } catch (...) {\n      return -1;\n   }\n   bool readonly = app().has_option(\"read-only\");\n   if (readonly) {\n      wlog(\"+++++++++read only mode\");\n      PyRun_SimpleString(\"import initeos\");\n      PyRun_SimpleString(\"initeos.start_console()\");\n      py_exit();\n      return 0;\n   }\n\n   if (app().has_option(\"http-server-address\")) {\n      string s = app().get_option(\"http-server-address\");\n      s = \"http:\n      cleos_set_http_url(s);\n   }\n   std::unique_lock<std::mutex> lk(cv_m);\n\n   Py_BEGIN_ALLOW_THREADS\n   boost::thread t(start_eos);\n   cv.wait(lk);\n   Py_END_ALLOW_THREADS\n\n   wlog(\"running console...\");\n   if (app().interactive_mode()) {\n      try {\n         PyRun_SimpleString(\"import initeos;initeos.init_wallet()\");\n         PyRun_SimpleString(\"import initeos\");\n         PyRun_SimpleString(\"initeos.start_console()\");\n      } FC_LOG_AND_DROP();\n      wlog(\"quit app...\");\n      appbase::app().quit();\n   }\n\n   Py_BEGIN_ALLOW_THREADS\n   cv.wait(lk, [](){return shutdown_finished;});\n   Py_END_ALLOW_THREADS\n\n   wlog(\"exiting...\");\n   vm_deinit_all();\n   py_exit();\n\n   return 0;\n}\n\n\n",
        "gt": [
            "'pyeos/plugins/history_plugin/include/eosio/history_plugin/history_plugin.hpp'",
            "'pyeos/plugins/history_api_plugin/include/eosio/history_api_plugin/history_api_plugin.hpp'",
            "'pyeos/programs/pyeos/main.cpp'"
        ]
    },
    {
        "files": [
            "'SLIDE_SLAM/backend/sloam/include/objects/ellipsoid.h'",
            "'SLIDE_SLAM/backend/sloam/include/factorgraph/graphWrapper.h'",
            "'SLIDE_SLAM/backend/sloam/src/factorgraph/graphWrapper.cpp'"
        ],
        "content": "'SLIDE_SLAM/backend/sloam/include/objects/ellipsoid.h'\n:\n\n\n\n#pragma once\n\n#include <gtsam/geometry/Point3.h>\n#include <gtsam/geometry/Pose3.h>\n#include <semanticObject.h>\n#include <utils.h>\n\n#include <algorithm>\n\nstruct EllipsoidParameters {\n  gtsam::Pose3 pose;\n  gtsam::Point3 scale;\n  int semantic_label;\n};\n\nclass Ellipsoid : public SemanticObject<EllipsoidParameters> {\n public:\n  explicit Ellipsoid(const gtsam::Pose3 &pose, const gtsam::Point3 &scale,\n                     const int &label = 1);\n\n  Scalar distance(const EllipsoidParameters &model) const;\n  Scalar distance(const PointT &point) const;\n\n  void project(const SE3 &tf);\n  Ellipsoid projectAndReturn(const SE3 &tf);\n  Scalar weightedDistance(const EllipsoidParameters &model,\n                          double dim_weight = 0.0) const;\n};\n\n'SLIDE_SLAM/backend/sloam/include/factorgraph/graphWrapper.h'\n:\n\n#pragma once\n\n#include <cubeMapManager.h>\n#include <definitions.h>\n#include <graph.h>\n#include <cylinderMapManager.h>\n#include <cube.h>\n#include <cubeFactor.h>\n#include <cylinder.h>\n#include <cylinderFactor.h>\n#include <ellipsoid.h>\n#include <ellipsoidMapManager.h>\n\nclass SemanticFactorGraphWrapper : public SemanticFactorGraph {\n public:\n\n  SemanticFactorGraphWrapper(int numRobots = 1);\n\n\n  bool addLoopClosureObservation(const SE3 &relativeMotion,\n                                 const SE3 &poseEstimate,\n                                 const boost::array<double, 36> &cov,\n                                 const SE3 &loop_closure_pose,\n                                 const size_t &closure_matched_pose_idx);\n\n  bool getPoseByID(SE3 &curr_pose, const int &poseID);\n\n\n  bool addOdomBearingObservation(\n      const SE3 &relativeMotion, const SE3 &poseEstimate,\n      const boost::array<double, 36> &cov,\n      const std::vector<Point3> &bearing_factors,\n      const std::vector<double> &range_factors, const std::vector<size_t> &ids,\n      const std::vector<Point3> &landmark_body_positions,\n      const double &data_association_distance);\n\n\n  bool addSLOAMObservation(const CylinderMapManager &semanticMap,\n                           const CubeMapManager &cubeSemanticMap,\n                           const EllipsoidMapManager &ellipsoidSemanticMap,\n                           const std::vector<int> &cyl_matches,\n                           const std::vector<Cylinder> &cylinders,\n                           const std::vector<int> &cube_matches,\n                           const std::vector<Cube> &cubes,\n                           const std::vector<int> &ellipsoid_matches,\n                           const std::vector<Ellipsoid> &ellipsoids,\n                           const SE3 &relativeMotion, const SE3 &poseEstimates,\n                           const int &robotID, bool opt = true);\n\n\n  void updateFactorGraphMap(CylinderMapManager &semanticMap,\n                            CubeMapManager &cubeSemanticMap,\n                            EllipsoidMapManager &ellipsoidSemanticMap);\n  void updateCylinder(const CylinderMeasurement &measurement, Cylinder &cyl);\n  void updateCube(const CubeMeasurement &measurement, Cube &cube);\n  void updateEllipsoid(const Point3 &measurement, Ellipsoid &ellipsoid);\n  void getCurrPose(SE3 &curr_pose, const int &robotID,\n                   boost::optional<Eigen::MatrixXd &> cov = boost::none);\n  int numRobots;\n\n  std::unordered_map<size_t, size_t> robotNumPoseInGraph;\n  std::unordered_map<size_t, gtsam::Pose3> robotPrevPose;\n\n  void getAllPoses(std::vector<SE3> &optimized_poses,\n                   std::vector<size_t> &pose_inds, const int &robotID);\n  void getAllCentroidLandmarks(std::vector<SE3> &optimized_landmark_pos,\n                               std::vector<size_t> &landmark_inds);\n  void getAllCentroidLandmarks(std::vector<SE3> &optimized_landmark_pos);\n  void getAllCentroidLandmarksAndLabels(\n      std::vector<SE3> &optimized_landmark_pos,\n      std::vector<int> &landmark_labels);\n\n  size_t pose_counter_robot1_;\n  size_t pose_counter_robot2_;\n  size_t getPoseCounterById(const int &robotID) const;\n\n private:\n  size_t cyl_counter_;\n  size_t cube_counter_;\n  size_t point_landmark_counter_;\n  std::vector<size_t> pose_counter_robot_;\n  std::vector<gtsam::Pose3> robot_prev_pose_;\n};\n\n'SLIDE_SLAM/backend/sloam/src/factorgraph/graphWrapper.cpp'\n:\n\n#include <graphWrapper.h>\n\nSemanticFactorGraphWrapper::SemanticFactorGraphWrapper(int num_of_robots)\n    : numRobots(num_of_robots) {\n  cyl_counter_ = 0;\n  cube_counter_ = 0;\n  point_landmark_counter_ = 0;\n  for (int i = 0; i < numRobots; i++) {\n    pose_counter_robot_.push_back(0);\n    robot_prev_pose_.push_back(gtsam::Pose3());\n  }\n\n\n  pose_counter_robot1_ = 0;\n}\n\n\nbool SemanticFactorGraphWrapper::addLoopClosureObservation(\n    const SE3 &relativeMotionSE3, const SE3 &poseEstimateSE3,\n    const boost::array<double, 36> &cov, const SE3 &loop_closure_relative_pose,\n    const size_t &closure_matched_pose_idx) {\n\n  gtsam::Pose3 relativeMotion(relativeMotionSE3.matrix());\n  gtsam::Pose3 poseEstimate(poseEstimateSE3.matrix());\n  int robotID = 0;\n  bool optimize = false;\n\n  if (pose_counter_robot1_ == 0) {\n    ROS_ERROR_STREAM(\n        \"ERROR: First pose should not be the loop closure pose!!!!!!!!!\");\n    return false;\n  } else {\n\n\n    bool loopClosureFound = true;\n\n    addKeyPoseAndBetween(pose_counter_robot1_ - 1, pose_counter_robot1_,\n                         relativeMotion, poseEstimate, robotID, cov,\n                         loopClosureFound, loop_closure_relative_pose,\n                         closure_matched_pose_idx);\n    pose_counter_robot1_++;\n    ROS_INFO_STREAM(\"Running factor-graph optimization, pose counter is: \"\n                    << pose_counter_robot1_);\n    solve();\n    return true;\n  }\n}\n\nbool SemanticFactorGraphWrapper::addSLOAMObservation(\n    const CylinderMapManager &semanticMap, const CubeMapManager &cube_semantic_map,\n    const EllipsoidMapManager &ellipsoid_semantic_map,\n    const std::vector<int> &cyl_matches, const std::vector<Cylinder> &cylinders,\n    const std::vector<int> &cube_matches,\n    const std::vector<Cube> &scan_cubes_world,\n    const std::vector<int> &ellipse_matches,\n    const std::vector<Ellipsoid> &ellipses, const SE3 &relativeMotionSE3,\n    const SE3 &poseEstimateSE3, const int &robotID, bool opt) {\n  size_t pose_counter;\n\n  gtsam::Pose3 curr_pose(poseEstimateSE3.matrix());\n  gtsam::Pose3 relativeMotion(relativeMotionSE3.matrix());\n\n  pose_counter = pose_counter_robot_[robotID];\n\n\n\n  if (pose_counter == 0) {\n\n    setPriors(curr_pose, robotID);\n    ROS_WARN_STREAM(\n        \"EROOR: Factor graph optimization is done when adding the first \"\n        \"pose prior, this may cause problems!!!\");\n  } else {\n\n\n    addKeyPoseAndBetween(pose_counter - 1, pose_counter, relativeMotion,\n                         curr_pose, robotID);\n  }\n  const auto matchesMap = semanticMap.getMatchesMap();\n  const auto cubeMatchesMap = cube_semantic_map.getMatchesMap();\n\n\n  for (auto i = 0; i < cyl_matches.size(); i++) {\n    if (cyl_matches[i] == -1) {\n\n      addCylinderFactor(pose_counter, cyl_counter_, curr_pose, cylinders[i],\n                        false, robotID);\n      cyl_counter_++;\n    } else {\n\n      int mapIdx = matchesMap.at(cyl_matches[i]);\n\n      addCylinderFactor(pose_counter, mapIdx, curr_pose, cylinders[i], true,\n                        robotID);\n    }\n  }\n\n\n  for (auto i = 0; i < cube_matches.size(); i++) {\n    if (cube_matches[i] == -1) {\n\n      addCubeFactor(pose_counter, cube_counter_, curr_pose, scan_cubes_world[i],\n                    false, robotID);\n      cube_counter_++;\n    } else {\n\n      int mapIdx = cubeMatchesMap.at(cube_matches[i]);\n      addCubeFactor(pose_counter, mapIdx, curr_pose, scan_cubes_world[i], true,\n                    robotID);\n    }\n  }\n\n\n  const auto ellipMatchesMap = ellipsoid_semantic_map.getMatchesMap();\n\n  std::vector<Point3> bearing_factors;\n  std::vector<double> range_factors;\n\n\n\n  std::vector<Ellipsoid> ellipses_body_frame;\n  for (size_t i = 0; i < ellipses.size(); i++) {\n    Ellipsoid ellipsoid_body(ellipses[i].model.pose, ellipses[i].model.scale,\n                             ellipses[i].model.semantic_label);\n\n\n    ellipsoid_body.model.pose =\n        Pose3(curr_pose.matrix().inverse() * ellipses[i].model.pose.matrix());\n    ellipses_body_frame.push_back(ellipsoid_body);\n  }\n  for (size_t i = 0; i < ellipses_body_frame.size(); i++) {\n\n    double range_factor =\n        ellipses_body_frame[i].model.pose.translation().norm();\n\n\n    Point3 bearing_factor =\n        ellipses_body_frame[i].model.pose.translation().normalized();\n    bearing_factors.push_back(bearing_factor);\n    range_factors.push_back(range_factor);\n  }\n\n  for (auto i = 0; i < ellipse_matches.size(); i++) {\n    if (ellipse_matches[i] == -1) {\n\n      addPointLandmarkKey(point_landmark_counter_,\n                          ellipses[i].model.pose.translation());\n      addRangeBearingFactor(pose_counter, point_landmark_counter_,\n                            bearing_factors[i], range_factors[i], robotID);\n      point_landmark_labels_.push_back(ellipses[i].model.semantic_label);\n      point_landmark_counter_++;\n    } else {\n\n      int mapIdx = ellipMatchesMap.at(ellipse_matches[i]);\n      addRangeBearingFactor(pose_counter, mapIdx, bearing_factors[i],\n                            range_factors[i], robotID);\n    }\n  }\n\n\n  pose_counter++;\n  pose_counter_robot_[robotID] = pose_counter;\n\n\n\n  bool optimize = true;\n\n  if (optimize && opt) {\n\n    size_t num_factors = fgraph.size();\n    size_t num_keys = fgraph.keys().size();\n\n    solve();\n\n\n\n\n\n\n\n\n\n\n\n    return true;\n  }\n\n\n\n\n\n  return false;\n}\n\nvoid SemanticFactorGraphWrapper::updateCylinder(\n    const CylinderMeasurement &measurement, Cylinder &cyl) {\n  cyl.model.root = measurement.root;\n  cyl.model.ray = measurement.ray;\n  cyl.model.radius = measurement.radius;\n}\n\nvoid SemanticFactorGraphWrapper::updateCube(const CubeMeasurement &measurement,\n                                            Cube &cube) {\n  cube.model.scale = measurement.scale;\n  cube.model.pose = measurement.pose;\n}\n\nvoid SemanticFactorGraphWrapper::updateEllipsoid(const Point3 &measurement,\n                                                 Ellipsoid &ellipsoid) {\n\n  ellipsoid.model.pose = Pose3(Rot3(), measurement);\n}\n\n\nvoid SemanticFactorGraphWrapper::updateFactorGraphMap(\n    CylinderMapManager &semanticMap, CubeMapManager &cube_semantic_map,\n    EllipsoidMapManager &ellipsoid_semantic_map) {\n  auto &map = semanticMap.getRawMap();\n  auto &cube_map = cube_semantic_map.getRawMap();\n  auto &ellipsoid_map = ellipsoid_semantic_map.getRawMap();\n  for (auto i = 0; i < cyl_counter_; ++i) {\n    updateCylinder(getCylinder(i), map[i]);\n  }\n  for (auto i = 0; i < cube_counter_; ++i) {\n    updateCube(getCube(i), cube_map[i]);\n  }\n\n  for (auto i = 0; i < point_landmark_counter_; ++i) {\n    updateEllipsoid(getCentroidLandmark(i), ellipsoid_map[i]);\n  }\n}\n\nvoid SemanticFactorGraphWrapper::getCurrPose(\n    SE3 &curr_pose, const int &robotID,\n\n    boost::optional<Eigen::MatrixXd &> cov) {\n  size_t pose_counter;\n  pose_counter = pose_counter_robot_[robotID];\n  gtsam::Pose3 pose;\n\n  bool pose_valid = getPose(pose_counter - 1, robotID, pose);\n  curr_pose = SE3(pose.matrix());\n  if (!pose_valid) {\n    ROS_ERROR_STREAM(\n        \"getCurrPose fail to fetch pose for pose_idx : \" << pose_counter - 1);\n  }\n  if (cov) {\n    std::cout << \"graphWarpper.cpp the getPoseCovarinace is probably not \"\n                 \"implemented correctly!\"\n              << '\\n';\n    *cov = getPoseCovariance(pose_counter - 1, robotID);\n  }\n}\n\nbool SemanticFactorGraphWrapper::getPoseByID(SE3 &curr_pose,\n                                             const int &poseID) {\n  gtsam::Pose3 pose;\n  bool pose_valid = getPose(poseID, 0, pose);\n  curr_pose = SE3(pose.matrix());\n  if (!pose_valid) {\n    ROS_ERROR_STREAM(\n        \"getPoseByID fail to fetch pose for pose_idx : \" << poseID);\n    return false;\n  } else {\n    return true;\n  }\n}\n\nvoid SemanticFactorGraphWrapper::getAllPoses(std::vector<SE3> &optimized_poses,\n                                             std::vector<size_t> &pose_inds,\n                                             const int &robotID) {\n  optimized_poses.clear();\n  pose_inds.clear();\n  for (size_t i = 0; i < pose_counter_robot_[robotID]; i++) {\n    gtsam::Pose3 pose;\n    bool pose_valid = getPose(i, robotID, pose);\n    if (!pose_valid) {\n      ROS_ERROR_STREAM(\n          \"MAJOR ERROR: getAllPoses fail to fetch pose for pose_idx: \" << i);\n      ROS_ERROR(\"YOU MUST CORRECT THIS ERROR!!!\");\n    } else {\n      optimized_poses.push_back(SE3(pose.matrix()));\n      pose_inds.push_back(i);\n    }\n  }\n\n\n  if (pose_inds.size() != optimized_poses.size()) {\n    ROS_ERROR_STREAM(\n        \"ERROR: getAllPoses fail to due to pose_inds and optimized_poses \"\n        \"having \"\n        \"different sizes!!!\");\n  }\n}\n\nvoid SemanticFactorGraphWrapper::getAllCentroidLandmarks(\n    std::vector<SE3> &optimized_landmark_pos,\n    std::vector<size_t> &landmark_inds) {\n  for (auto i = 0; i < point_landmark_counter_; i++) {\n    gtsam::Point3 landmark_position = getCentroidLandmark(i);\n    if (landmark_position.x() == gtsam::Point3().x() &&\n        landmark_position.y() == gtsam::Point3().y() &&\n        landmark_position.z() == gtsam::Point3().z()) {\n\n    } else {\n      gtsam::Pose3 landmark_pose =\n          gtsam::Pose3(gtsam::Rot3(), landmark_position);\n      optimized_landmark_pos.push_back(SE3(landmark_pose.matrix()));\n      landmark_inds.push_back(i);\n    }\n  }\n}\n\nvoid SemanticFactorGraphWrapper::getAllCentroidLandmarks(\n    std::vector<SE3> &optimized_landmark_pos) {\n  for (auto i = 0; i < point_landmark_counter_; i++) {\n    gtsam::Point3 landmark_position = getCentroidLandmark(i);\n    if (landmark_position.x() == gtsam::Point3().x() &&\n        landmark_position.y() == gtsam::Point3().y() &&\n        landmark_position.z() == gtsam::Point3().z()) {\n      ROS_INFO_STREAM(\"fail to fetch landmark idx: \" << i);\n    } else {\n      gtsam::Pose3 landmark_pose =\n          gtsam::Pose3(gtsam::Rot3(), landmark_position);\n      optimized_landmark_pos.push_back(SE3(landmark_pose.matrix()));\n    }\n  }\n}\n\nvoid SemanticFactorGraphWrapper::getAllCentroidLandmarksAndLabels(\n    std::vector<SE3> &optimized_landmark_pos,\n    std::vector<int> &landmark_labels) {\n  for (auto i = 0; i < point_landmark_counter_; i++) {\n    gtsam::Point3 landmark_position = getCentroidLandmark(i);\n    if (landmark_position.x() == gtsam::Point3().x() &&\n        landmark_position.y() == gtsam::Point3().y() &&\n        landmark_position.z() == gtsam::Point3().z()) {\n\n    } else {\n      gtsam::Pose3 landmark_pose =\n          gtsam::Pose3(gtsam::Rot3(), landmark_position);\n      optimized_landmark_pos.push_back(SE3(landmark_pose.matrix()));\n      if (i < point_landmark_labels_.size()) {\n        landmark_labels.push_back(point_landmark_labels_[i]);\n      } else {\n        landmark_labels.push_back(-1);\n        ROS_ERROR_STREAM(\n            \"ERROR: point_landmark_labels_ is not the same size as \"\n            \"point_landmark_counter_, which is abnormal!!!\");\n      }\n    }\n  }\n}\n\nsize_t SemanticFactorGraphWrapper::getPoseCounterById(\n    const int &robotID) const {\n  return pose_counter_robot_[robotID];\n}",
        "gt": [
            "'SLIDE_SLAM/backend/sloam/include/objects/ellipsoid.h'",
            "'SLIDE_SLAM/backend/sloam/include/factorgraph/graphWrapper.h'",
            "'SLIDE_SLAM/backend/sloam/src/factorgraph/graphWrapper.cpp'"
        ]
    },
    {
        "files": [
            "'bcflight/flight/stabilizer/EKF.h'",
            "'bcflight/flight/stabilizer/IMU.h'",
            "'bcflight/flight/stabilizer/Stabilizer.cpp'"
        ],
        "content": "'bcflight/flight/stabilizer/EKF.h'\n:\n\n#ifndef EKF_H\n#define EKF_H\n\n#include <Matrix.h>\n\nclass EKF\n{\npublic:\n\tEKF( uint32_t n_inputs, uint32_t n_outputs );\n\t~EKF();\n\n\tvoid setInputFilter( uint32_t row, float filter );\n\tvoid setOutputFilter( uint32_t row, float filter );\n\tvoid setSelector( uint32_t input_row, uint32_t output_row, float selector );\n\n\tVector4f state( uint32_t offset ) const;\n\n\tvoid UpdateInput( uint32_t row, float input );\n\tvoid Process( float dt );\n\n\tvoid DumpInput();\n\nprotected:\n\tuint32_t mInputsCount;\n\tuint32_t mOutputsCount;\n\tMatrix mQ;\n\tMatrix mR;\n\tMatrix mC;\n\tMatrix mSigma;\n\tMatrix mInput;\n\tMatrix mState;\n};\n\n#endif\n\n'bcflight/flight/stabilizer/IMU.h'\n:\n\n#ifndef IMU_H\n#define IMU_H\n\n#include <Main.h>\n#include <Vector.h>\n#include <EKF.h>\n#include <Filter.h>\n#include \"SensorFusion.h\"\n#include <list>\n#include <functional>\n\nclass Gyroscope;\nclass Accelerometer;\nclass Magnetometer;\nclass Altimeter;\nclass GPS;\n\n#define IMU_RPY_SMOOTH_RATIO 0.02f\n\nLUA_CLASS class IMU\n{\npublic:\n\ttypedef enum {\n\t\tOff,\n\t\tCalibrating,\n\t\tCalibratingAll,\n\t\tCalibrationDone,\n\t\tRunning\n\t} State;\n\n\tLUA_EXPORT IMU();\n\tvirtual ~IMU();\n\n\tLUA_PROPERTY(\"filters.position.input\") void setPositionFilterInput( const Vector3f& v );\n\tLUA_PROPERTY(\"filters.position.output\") void setPositionFilterOutput( const Vector3f& v );\n\n\tconst Vector3f acceleration() const;\n\tconst Vector3f gyroscope() const;\n\tconst Vector3f magnetometer() const;\n\n\tconst State& state() const;\n\tconst Vector3f RPY() const;\n\tconst Vector3f dRPY() const;\n\tconst Vector3f rate() const;\n\tconst Vector3f velocity() const;\n\tconst Vector3f position() const;\n\tconst float altitude() const;\n\tconst Vector3f gpsLocation() const;\n\tconst float gpsSpeed() const;\n\tconst uint32_t gpsSatellitesSeen() const;\n\tconst uint32_t gpsSatellitesUsed() const;\n\n\tFilter<Vector3f>* ratesFilters() const { return mRatesFilter; }\n\n\tLUA_EXPORT void Recalibrate();\n\tvoid RecalibrateAll();\n\tvoid ResetRPY();\n\tvoid ResetYaw();\n\tvoid Loop( uint64_t tick, float dt );\n\n\tvoid registerConsumer( const std::function<void(uint64_t, const Vector3f&, const Vector3f&)>& f );\n\nprotected:\n\tvoid Calibrate( float dt, bool all = false );\n\tvoid UpdateSensors( uint64_t tick, bool gyro_only = false );\n\tvoid UpdateAttitude( float dt );\n\tvoid UpdateVelocity( float dt );\n\tvoid UpdatePosition( float dt );\n\tvoid UpdateGPS();\n\n\tMain* mMain;\n\tuint32_t mSensorsUpdateSlow;\n\tbool mPositionUpdate;\n#ifdef SYSTEM_NAME_Linux\n\tmutex mPositionUpdateMutex;\n#endif\n\n\tLUA_PROPERTY(\"gyroscopes\") std::list<Gyroscope*> mGyroscopes;\n\tLUA_PROPERTY(\"accelerometers\") std::list<Accelerometer*> mAccelerometers;\n\tLUA_PROPERTY(\"magnetometers\") std::list<Magnetometer*> mMagnetometers;\n\tLUA_PROPERTY(\"altimeters\") std::list<Altimeter*> mAltimeters;\n\tLUA_PROPERTY(\"gps\") std::list<GPS*> mGPSes;\n\n\tLUA_PROPERTY(\"filters.rates\") Filter<Vector3f>* mRatesFilter;\n\tLUA_PROPERTY(\"filters.accelerometer\") Filter<Vector3f>* mAccelerometerFilter;\n\n\n\tState mState;\n\tVector3f mAcceleration;\n\tVector3f mGyroscope;\n\tVector3f mMagnetometer;\n\tVector2f mGPSLocation;\n\tfloat mGPSSpeed;\n\tfloat mGPSAltitude;\n\tuint32_t mGPSSatellitesSeen;\n\tuint32_t mGPSSatellitesUsed;\n\tfloat mAltitudeOffset;\n\tfloat mProximity;\n\tVector3f mRPY;\n\tVector3f mdRPY;\n\tVector3f mRate;\n\tVector3f mAccelerationSmoothed;\n\tVector3f mRPYOffset;\n\tVector4f mAccelerometerOffset;\n\n\n\tuint32_t mCalibrationStep;\n\tuint64_t mCalibrationTimer;\n\tVector4f mRPYAccum;\n\tVector4f mdRPYAccum;\n\tVector3f mGravity;\n\n\n\n\n\tLUA_PROPERTY(\"filters.attitude\") SensorFusion<Vector3f>* mAttitude;\n\tEKF mPosition;\n\tEKF mVelocity;\n\tVector4f mLastAccelAttitude;\n\tVector3f mVirtualNorth;\n\n\tVector3f mLastAcceleration;\n\tuint32_t mAcroRPYCounter;\n\n\n\tuint32_t mGyroscopeErrorCounter;\n\n\tstd::list< std::function<void(uint64_t, const Vector3f&, const Vector3f&)> > mConsumers;\n};\n\n#endif\n\n'bcflight/flight/stabilizer/Stabilizer.cpp'\n:\n\n#include <unistd.h>\n#include <math.h>\n#include <Debug.h>\n#include <Main.h>\n#include <Board.h>\n#include <IMU.h>\n#include <Controller.h>\n#include \"Config.h\"\n#include \"Stabilizer.h\"\n\nStabilizer::Stabilizer()\n\t: mMain( Main::instance() )\n\t, mFrame( nullptr )\n\t, mMode( Rate )\n\t, mAltitudeHold( false )\n\t, mRateRollPID( PID<float>() )\n\t, mRatePitchPID( PID<float>() )\n\t, mRateYawPID( PID<float>() )\n\t, mRollHorizonPID( PID<float>() )\n\t, mPitchHorizonPID( PID<float>() )\n\t, mAltitudePID( PID<float>() )\n\t, mAltitudeControl( 0.0f )\n\t, mDerivativeFilter( nullptr )\n\t, mTPAMultiplier( 1.0f )\n\t, mTPAThreshold( 1.0f )\n\t, mAntiGravityGain( 1.0f )\n\t, mAntiGravityThreshold( 0.0f )\n\t, mAntiGravityDecay( 10.0f )\n\t, mAntigravityThrustAccum( 0.0f )\n\t, mArmed( false )\n\t, mFilteredRPYDerivative( Vector3f() )\n\t, mLockState( 0 )\n\t, mHorizonMultiplier( Vector3f( 15.0f, 15.0f, 1.0f ) )\n\t, mHorizonOffset( Vector3f() )\n\t, mHorizonMaxRate( Vector3f( 300.0f, 300.0f, 300.0f ) )\n{\n\tfDebug(this);\n\n\tmAltitudePID.setP( 0.001 );\n\tmAltitudePID.setI( 0.010 );\n\tmAltitudePID.setDeadBand( 0.05f );\n}\n\n\nStabilizer::~Stabilizer()\n{\n}\n\n\nFrame* Stabilizer::frame() const\n{\n\treturn mFrame;\n}\n\n\nvoid Stabilizer::setFrame( Frame* frame )\n{\n\tmFrame = frame;\n}\n\n\nvoid Stabilizer::setRollP( float p )\n{\n\tmRateRollPID.setP( p );\n\tBoard::SaveRegister( \"PID:Roll:P\", to_string( p ) );\n}\n\n\nvoid Stabilizer::setRollI( float i )\n{\n\tmRateRollPID.setI( i );\n\tBoard::SaveRegister( \"PID:Roll:I\", to_string( i ) );\n}\n\n\nvoid Stabilizer::setRollD( float d )\n{\n\tmRateRollPID.setD( d );\n\tBoard::SaveRegister( \"PID:Roll:D\", to_string( d ) );\n}\n\n\nVector3f Stabilizer::getRollPID() const\n{\n\treturn mRateRollPID.getPID();\n}\n\n\nvoid Stabilizer::setPitchP( float p )\n{\n\tmRatePitchPID.setP( p );\n\tBoard::SaveRegister( \"PID:Pitch:P\", to_string( p ) );\n}\n\n\nvoid Stabilizer::setPitchI( float i )\n{\n\tmRatePitchPID.setI( i );\n\tBoard::SaveRegister( \"PID:Pitch:I\", to_string( i ) );\n}\n\n\nvoid Stabilizer::setPitchD( float d )\n{\n\tmRatePitchPID.setD( d );\n\tBoard::SaveRegister( \"PID:Pitch:D\", to_string( d ) );\n}\n\n\nVector3f Stabilizer::getPitchPID() const\n{\n\treturn mRatePitchPID.getPID();\n}\n\n\nvoid Stabilizer::setYawP( float p )\n{\n\tmRateYawPID.setP( p );\n\tBoard::SaveRegister( \"PID:Yaw:P\", to_string( p ) );\n}\n\n\nvoid Stabilizer::setYawI( float i )\n{\n\tmRateYawPID.setI( i );\n\tBoard::SaveRegister( \"PID:Yaw:I\", to_string( i ) );\n}\n\n\nvoid Stabilizer::setYawD( float d )\n{\n\tmRateYawPID.setD( d );\n\tBoard::SaveRegister( \"PID:Yaw:D\", to_string( d ) );\n}\n\n\nVector3f Stabilizer::getYawPID() const\n{\n\treturn mRateYawPID.getPID();\n}\n\n\nVector3f Stabilizer::lastPIDOutput() const\n{\n\treturn Vector3f( mRateRollPID.state(), mRatePitchPID.state(), mRateYawPID.state() );\n}\n\n\nvoid Stabilizer::setHorizonOffset( const Vector3f& v )\n{\n\tmHorizonOffset = v;\n}\n\n\nVector3f Stabilizer::horizonOffset() const\n{\n\treturn mHorizonOffset;\n}\n\n\nvoid Stabilizer::setMode( uint32_t mode )\n{\n\tmMode = (Mode)mode;\n}\n\n\nuint32_t Stabilizer::mode() const\n{\n\treturn (uint32_t)mMode;\n}\n\n\nvoid Stabilizer::setAltitudeHold( bool enabled )\n{\n\tmAltitudeHold = enabled;\n}\n\n\nbool Stabilizer::altitudeHold() const\n{\n\treturn mAltitudeHold;\n}\n\n\nvoid Stabilizer::Arm()\n{\n\tmArmed = true;\n}\n\n\nvoid Stabilizer::Disarm()\n{\n\tmArmed = false;\n}\n\n\nbool Stabilizer::armed() const\n{\n\treturn mArmed;\n}\n\n\nfloat Stabilizer::thrust() const\n{\n\treturn mThrust;\n}\n\n\nconst Vector3f& Stabilizer::RPY() const\n{\n\treturn mRPY;\n}\n\n\nconst Vector3f& Stabilizer::filteredRPYDerivative() const\n{\n\treturn mFilteredRPYDerivative;\n}\n\n\nvoid Stabilizer::Reset( const float& yaw )\n{\n\tmRateRollPID.Reset();\n\tmRatePitchPID.Reset();\n\tmRateYawPID.Reset();\n\tmRollHorizonPID.Reset();\n\tmPitchHorizonPID.Reset();\n\tmRPY.x = 0.0f;\n\tmRPY.y = 0.0f;\n\tmRPY.z = 0.0f;\n\tmThrust = 0.0f;\n}\n\n\nvoid Stabilizer::setRoll( float value )\n{\n\tmRPY.x = value;\n}\n\n\nvoid Stabilizer::setPitch( float value )\n{\n\tmRPY.y = value;\n}\n\n\nvoid Stabilizer::setYaw( float value )\n{\n\tmRPY.z = value;\n}\n\n\nvoid Stabilizer::setThrust( float value )\n{\n\tmPreviousThrust = mThrust;\n\tmThrust = value;\n}\n\n\nvoid Stabilizer::Update( IMU* imu, float dt )\n{\n\tVector3f rate_control = Vector3f();\n\n\tif ( mLockState >= 1 ) {\n\t\tmLockState = 2;\n\t\treturn;\n\t}\n\n\tVector3f rates = imu->rate();\n\n\tif ( mDerivativeFilter ) {\n\t\tmFilteredRPYDerivative = mDerivativeFilter->filter( rates, dt );\n\t} else {\n\t\tmFilteredRPYDerivative = rates;\n\t}\n\n\tif ( not mArmed ) {\n\t\treturn;\n\t}\n\n\n\tif ( mFrame->airMode() == false and mThrust <= 0.15f ) {\n\t\tmFrame->Stabilize( Vector3f( 0.0f, 0.0f, 0.0f ), mThrust );\n\t\treturn;\n\t}\n\n\tVector3f rollPIDMultiplier = Vector3f( 1.0f, 1.0f, 1.0f );\n\tVector3f pitchPIDMultiplier = Vector3f( 1.0f, 1.0f, 1.0f );\n\tVector3f yawPIDMultiplier = Vector3f( 1.0f, 1.0f, 1.0f );\n\n\n\n\n\tif ( mTPAThreshold > 0.0f and mTPAThreshold < 1.0f ) {\n\t\tfloat tpa = ( ( mThrust - mTPAThreshold ) / ( 1.0f - mTPAThreshold ) ) * mTPAMultiplier;\n\t\tVector3f tpaPID = Vector3f(\n\t\t\t1.0f - 0.25f * std::max( 0.0f, std::min( 1.0f, tpa ) ),\n\t\t\t1.0f - 0.25f * std::max( 0.0f, std::min( 1.0f, tpa ) ),\n\t\t\t1.0f - std::max( 0.0f, std::min( 1.0f, tpa ) )\n\t\t);\n\t\trollPIDMultiplier = rollPIDMultiplier * tpaPID;\n\t\tpitchPIDMultiplier = pitchPIDMultiplier * tpaPID;\n\t\tyawPIDMultiplier = yawPIDMultiplier * tpaPID;\n\t}\n\n\n\tif ( mAntiGravityThreshold > 0.0f ) {\n\t\tfloat delta = std::abs( mThrust - mPreviousThrust ) / dt;\n\t\tmAntigravityThrustAccum = std::min( 1.0f, mAntigravityThrustAccum * ( 1.0f - dt * mAntiGravityDecay ) + delta * dt );\n\t\tfloat ag = 1.0f + (mAntiGravityGain - 1.0f) * std::max(0.0f, std::min( 1.0f, ( mAntigravityThrustAccum - mAntiGravityThreshold ) / (1.0f - mAntiGravityThreshold) ) );\n\t\trollPIDMultiplier.y *= ag;\n\t\tpitchPIDMultiplier.y *= ag;\n\t\tyawPIDMultiplier.y *= ag;\n\t\tif ( ag > 1.0f ) {\n\t\t\tgTrace() << \"AG: \" << ag << \" | \" << mAntigravityThrustAccum << \" | \" << delta;\n\t\t}\n\t}\n\n\tswitch ( mMode ) {\n\t\tcase Stabilize : {\n\t\t\tVector3f drone_state = imu->RPY();\n\t\t\tVector3f control_angles = mRPY;\n\t\t\tcontrol_angles.x = mHorizonMultiplier.x * min( max( control_angles.x, -1.0f ), 1.0f ) + mHorizonOffset.x;\n\t\t\tcontrol_angles.y = mHorizonMultiplier.y * min( max( control_angles.y, -1.0f ), 1.0f ) + mHorizonOffset.y;\n\n\t\t\tmRollHorizonPID.Process( control_angles.x, drone_state.x, dt );\n\t\t\tmPitchHorizonPID.Process( control_angles.y, drone_state.y, dt );\n\t\t\trate_control.x = mRollHorizonPID.state();\n\t\t\trate_control.y = mPitchHorizonPID.state();\n\t\t\trate_control.x = max( -mHorizonMaxRate.x, min( mHorizonMaxRate.x, rate_control.x ) );\n\t\t\trate_control.y = max( -mHorizonMaxRate.y, min( mHorizonMaxRate.y, rate_control.y ) );\n\t\t\trate_control.z = mRPY.z * mRateFactor;\n\t\t\tbreak;\n\t\t}\n\t\tcase ReturnToHome :\n\t\tcase Follow :\n\t\tcase Rate :\n\t\tdefault : {\n\t\t\trate_control = mRPY * mRateFactor;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfloat deltaR = rate_control.x - rates.x;\n\tfloat deltaP = rate_control.y - rates.y;\n\tfloat deltaY = rate_control.z - rates.z;\n\tfloat deltaRd = rate_control.x - mFilteredRPYDerivative.x;\n\tfloat deltaPd = rate_control.y - mFilteredRPYDerivative.y;\n\tfloat deltaYd = rate_control.z - mFilteredRPYDerivative.z;\n\tmRateRollPID.Process( deltaR, deltaR, deltaRd, dt, rollPIDMultiplier );\n\tmRatePitchPID.Process( deltaP, deltaP, deltaPd, dt, pitchPIDMultiplier );\n\tmRateYawPID.Process( deltaY, deltaY, deltaYd, dt, yawPIDMultiplier );\n\n\tfloat thrust = mThrust;\n\n\tVector3f ratePID( mRateRollPID.state(), mRatePitchPID.state(), mRateYawPID.state() );\n\n\tMain::instance()->blackbox()->Enqueue( \"Stabilizer:ratePID\", ratePID );\n\n\tif ( mFrame->Stabilize( ratePID, thrust ) == false ) {\n\t\tgDebug() << \"stab error\";\n\t\tReset( imu->RPY().z );\n\t}\n}\n\nvoid Stabilizer::MotorTest(uint32_t id) {\n\tmLockState = 1;\n\twhile ( mLockState != 2 ) {\n\t\tusleep( 1000 * 10 );\n\t}\n\n\tmFrame->MotorTest(id);\n\n\tmLockState = 0;\n}\n\nvoid Stabilizer::CalibrateESCs()\n{\n\tif ( mMain->imu()->state() != IMU::Off ) {\n\t\tmLockState = 1;\n\t\twhile ( mLockState != 2 ) {\n\t\t\tusleep( 1000 * 10 );\n\t\t}\n\t}\n\n\tmFrame->CalibrateESCs();\n\n\tmLockState = 0;\n}\n",
        "gt": [
            "'bcflight/flight/stabilizer/EKF.h'",
            "'bcflight/flight/stabilizer/IMU.h'",
            "'bcflight/flight/stabilizer/Stabilizer.cpp'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/types.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO/DyldInfo.hpp'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'\n:\n#ifndef LIEF_MAIN_HEADER_H\n#define LIEF_MAIN_HEADER_H\n#include <LIEF/config.h>\n\n#include <LIEF/Abstract.hpp>\n\n#include <LIEF/OAT.hpp>\n#include <LIEF/VDEX.hpp>\n#include <LIEF/ART.hpp>\n#include <LIEF/DEX.hpp>\n#include <LIEF/ELF.hpp>\n#include <LIEF/PE.hpp>\n#include <LIEF/MachO.hpp>\n#include <LIEF/DWARF.hpp>\n#include <LIEF/logging.hpp>\n#include <LIEF/platforms.hpp>\n\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO.hpp'\n:\n#ifndef LIEF_MACHO_H\n#define LIEF_MACHO_H\n\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_MACHO_SUPPORT)\n\n#include \"LIEF/MachO/Binary.hpp\"\n#include \"LIEF/MachO/BinaryParser.hpp\"\n#include \"LIEF/MachO/BindingInfo.hpp\"\n#include \"LIEF/MachO/BuildVersion.hpp\"\n#include \"LIEF/MachO/Builder.hpp\"\n#include \"LIEF/MachO/ChainedBindingInfo.hpp\"\n#include \"LIEF/MachO/CodeSignature.hpp\"\n#include \"LIEF/MachO/CodeSignatureDir.hpp\"\n#include \"LIEF/MachO/DataCodeEntry.hpp\"\n#include \"LIEF/MachO/DataInCode.hpp\"\n#include \"LIEF/MachO/DyldBindingInfo.hpp\"\n#include \"LIEF/MachO/DyldChainedFixups.hpp\"\n#include \"LIEF/MachO/DyldEnvironment.hpp\"\n#include \"LIEF/MachO/DyldExportsTrie.hpp\"\n#include \"LIEF/MachO/DyldInfo.hpp\"\n#include \"LIEF/MachO/DylibCommand.hpp\"\n#include \"LIEF/MachO/DylinkerCommand.hpp\"\n#include \"LIEF/MachO/DynamicSymbolCommand.hpp\"\n#include \"LIEF/MachO/EncryptionInfo.hpp\"\n#include \"LIEF/MachO/EnumToString.hpp\"\n#include \"LIEF/MachO/ExportInfo.hpp\"\n#include \"LIEF/MachO/FatBinary.hpp\"\n#include \"LIEF/MachO/FilesetCommand.hpp\"\n#include \"LIEF/MachO/FunctionStarts.hpp\"\n#include \"LIEF/MachO/Header.hpp\"\n#include \"LIEF/MachO/LinkEdit.hpp\"\n#include \"LIEF/MachO/LinkerOptHint.hpp\"\n#include \"LIEF/MachO/LoadCommand.hpp\"\n#include \"LIEF/MachO/MainCommand.hpp\"\n#include \"LIEF/MachO/Parser.hpp\"\n#include \"LIEF/MachO/ParserConfig.hpp\"\n#include \"LIEF/MachO/RPathCommand.hpp\"\n#include \"LIEF/MachO/Relocation.hpp\"\n#include \"LIEF/MachO/RelocationDyld.hpp\"\n#include \"LIEF/MachO/RelocationFixup.hpp\"\n#include \"LIEF/MachO/RelocationObject.hpp\"\n#include \"LIEF/MachO/Section.hpp\"\n#include \"LIEF/MachO/SegmentCommand.hpp\"\n#include \"LIEF/MachO/SegmentSplitInfo.hpp\"\n#include \"LIEF/MachO/SourceVersion.hpp\"\n#include \"LIEF/MachO/SubFramework.hpp\"\n#include \"LIEF/MachO/Symbol.hpp\"\n#include \"LIEF/MachO/SymbolCommand.hpp\"\n#include \"LIEF/MachO/ThreadCommand.hpp\"\n#include \"LIEF/MachO/TwoLevelHints.hpp\"\n#include \"LIEF/MachO/UUIDCommand.hpp\"\n#include \"LIEF/MachO/VersionMin.hpp\"\n#include \"LIEF/MachO/enums.hpp\"\n#include \"LIEF/MachO/hash.hpp\"\n#include \"LIEF/MachO/json.hpp\"\n#include \"LIEF/MachO/type_traits.hpp\"\n#include \"LIEF/MachO/utils.hpp\"\n\n#endif\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/types.hpp'\n:\n#ifndef LIEF_TYPES_H\n#define LIEF_TYPES_H\n#include <stdint.h>\n#include <inttypes.h>\n#include <cstddef>\n\n#if defined(_MSC_VER)\n#define ALIGNED_(x) __declspec(align(x))\n#elif defined(__GNUC__)\n#define ALIGNED_(x) __attribute__ ((__aligned__(x), __packed__))\n#endif\n\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO/DyldInfo.hpp'\n:\n#ifndef LIEF_MACHO_DYLD_INFO_COMMAND_H\n#define LIEF_MACHO_DYLD_INFO_COMMAND_H\n#include <string>\n#include <set>\n#include <vector>\n#include <ostream>\n#include <memory>\n\n#include \"LIEF/visibility.h\"\n#include \"LIEF/types.hpp\"\n#include \"LIEF/span.hpp\"\n\n#include \"LIEF/MachO/LoadCommand.hpp\"\n#include \"LIEF/MachO/type_traits.hpp\"\n#include \"LIEF/iterators.hpp\"\n\nnamespace LIEF {\nclass vector_iostream;\nclass BinaryStream;\nnamespace MachO {\n\nclass Binary;\nclass BinaryParser;\nclass Builder;\nclass DyldBindingInfo;\nclass ExportInfo;\nclass LinkEdit;\nclass RelocationDyld;\n\nnamespace details {\nstruct dyld_info_command;\n}\n\n\nclass LIEF_API DyldInfo : public LoadCommand {\n\n  friend class BinaryParser;\n  friend class Binary;\n  friend class Builder;\n  friend class LinkEdit;\n\n  public:\n\n  using info_t = std::pair<uint32_t, uint32_t>;\n\n\n  using binding_info_t = std::vector<std::unique_ptr<DyldBindingInfo>>;\n\n\n  using it_binding_info = ref_iterator<binding_info_t&, DyldBindingInfo*>;\n\n\n  using it_const_binding_info = const_ref_iterator<const binding_info_t&, DyldBindingInfo*>;\n\n\n  using export_info_t = std::vector<std::unique_ptr<ExportInfo>>;\n\n\n  using it_export_info = ref_iterator<export_info_t&, ExportInfo*>;\n\n\n  using it_const_export_info = const_ref_iterator<const export_info_t&, ExportInfo*>;\n\n\n  enum class BINDING_ENCODING_VERSION {\n    UNKNOWN = 0,\n    V1,\n    V2\n  };\n\n  DyldInfo();\n  DyldInfo(const details::dyld_info_command& dyld_info_cmd);\n\n  DyldInfo& operator=(DyldInfo other);\n  DyldInfo(const DyldInfo& copy);\n\n  void swap(DyldInfo& other);\n\n  DyldInfo* clone() const override;\n\n  virtual ~DyldInfo();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  const info_t& rebase() const;\n\n\n  span<const uint8_t> rebase_opcodes() const;\n  span<uint8_t>       rebase_opcodes();\n\n\n  void rebase_opcodes(buffer_t raw);\n\n\n\n  std::string show_rebases_opcodes() const;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  const info_t& bind() const;\n\n\n  span<const uint8_t> bind_opcodes() const;\n  span<uint8_t>       bind_opcodes();\n\n\n  void bind_opcodes(buffer_t raw);\n\n\n  std::string show_bind_opcodes() const;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  const info_t& weak_bind() const;\n\n\n  span<const uint8_t> weak_bind_opcodes() const;\n  span<uint8_t>       weak_bind_opcodes();\n\n\n  void weak_bind_opcodes(buffer_t raw);\n\n\n  std::string show_weak_bind_opcodes() const;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  const info_t& lazy_bind() const;\n\n\n  span<const uint8_t> lazy_bind_opcodes() const;\n  span<uint8_t>       lazy_bind_opcodes();\n\n\n  void lazy_bind_opcodes(buffer_t raw);\n\n\n  std::string show_lazy_bind_opcodes() const;\n\n\n  it_binding_info       bindings();\n  it_const_binding_info bindings() const;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  const info_t& export_info() const;\n\n\n  it_export_info       exports();\n  it_const_export_info exports() const;\n\n\n  span<const uint8_t> export_trie() const;\n  span<uint8_t>       export_trie();\n\n\n  void export_trie(buffer_t raw);\n\n\n  std::string show_export_trie() const;\n\n  void rebase(const info_t& info);\n  void bind(const info_t& info);\n  void weak_bind(const info_t& info);\n  void lazy_bind(const info_t& info);\n  void export_info(const info_t& info);\n\n  void set_rebase_offset(uint32_t offset);\n  void set_rebase_size(uint32_t size);\n\n  void set_bind_offset(uint32_t offset);\n  void set_bind_size(uint32_t size);\n\n  void set_weak_bind_offset(uint32_t offset);\n  void set_weak_bind_size(uint32_t size);\n\n  void set_lazy_bind_offset(uint32_t offset);\n  void set_lazy_bind_size(uint32_t size);\n\n  void set_export_offset(uint32_t offset);\n  void set_export_size(uint32_t size);\n\n  void add(std::unique_ptr<ExportInfo> info);\n\n  bool operator==(const DyldInfo& rhs) const;\n  bool operator!=(const DyldInfo& rhs) const;\n\n  void accept(Visitor& visitor) const override;\n\n  std::ostream& print(std::ostream& os) const override;\n\n  static bool classof(const LoadCommand* cmd);\n\n  private:\n  using bind_container_t = std::set<DyldBindingInfo*, std::function<bool(DyldBindingInfo*, DyldBindingInfo*)>>;\n\n  void show_bindings(std::ostream& os, span<const uint8_t> buffer, bool is_lazy = false) const;\n\n  void show_trie(std::ostream& output, std::string output_prefix, BinaryStream& stream, uint64_t start, uint64_t end, const std::string& prefix) const;\n\n  LIEF_LOCAL DyldInfo& update_standard_bindings(const bind_container_t& bindings, vector_iostream& stream);\n  LIEF_LOCAL DyldInfo& update_standard_bindings_v1(const bind_container_t& bindings, vector_iostream& stream);\n  LIEF_LOCAL DyldInfo& update_standard_bindings_v2(const bind_container_t& bindings,\n                                                   std::vector<RelocationDyld*> rebases, vector_iostream& stream);\n\n  LIEF_LOCAL DyldInfo& update_weak_bindings(const bind_container_t& bindings, vector_iostream& stream);\n  LIEF_LOCAL DyldInfo& update_lazy_bindings(const bind_container_t& bindings, vector_iostream& stream);\n\n  LIEF_LOCAL DyldInfo& update_rebase_info(vector_iostream& stream);\n  LIEF_LOCAL DyldInfo& update_binding_info(vector_iostream& stream, details::dyld_info_command& cmd);\n  LIEF_LOCAL DyldInfo& update_export_trie(vector_iostream& stream);\n\n  info_t   rebase_;\n  span<uint8_t> rebase_opcodes_;\n\n  info_t   bind_;\n  span<uint8_t> bind_opcodes_;\n\n  info_t   weak_bind_;\n  span<uint8_t> weak_bind_opcodes_;\n\n  info_t   lazy_bind_;\n  span<uint8_t> lazy_bind_opcodes_;\n\n  info_t   export_;\n  span<uint8_t> export_trie_;\n\n  export_info_t  export_info_;\n  binding_info_t binding_info_;\n\n  BINDING_ENCODING_VERSION binding_encoding_version_ = BINDING_ENCODING_VERSION::UNKNOWN;\n\n  Binary* binary_ = nullptr;\n};\n\n}\n}\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/types.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO/DyldInfo.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/MachO.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/Subscription.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/SubscriptionServiceTransaction.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/Subscription.cpp'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/ServiceTransactionTemplate.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/ServiceTransactionIf.h'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackServer/ServiceSet/Subscription.h'\n:\n\n#ifndef __OpcUaStackServer_Subscription_h__\n#define __OpcUaStackServer_Subscription_h__\n\n#include <boost/thread/mutex.hpp>\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaStatusCode.h\"\n#include \"OpcUaStackCore/Utility/SlotTimer.h\"\n#include \"OpcUaStackCore/ServiceSetApplication/ForwardGlobalSync.h\"\n#include \"OpcUaStackCore/ServiceSet/SubscriptionServiceTransaction.h\"\n#include \"OpcUaStackCore/ServiceSet/MonitoredItemServiceTransaction.h\"\n#include \"OpcUaStackServer/ServiceSet/MonitorManager.h\"\n#include \"OpcUaStackServer/ServiceSet/AcknowledgementManager.h\"\n#include \"OpcUaStackServer/InformationModel/InformationModel.h\"\n#include <map>\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackServer\n{\n\n\ttypedef std::map<uint32_t, PublishResponse::SPtr> RetransmissionQueue;\n\ttypedef enum\n\t{\n\t\tNothingTodo,\n\t\tNeedAttention,\n\t\tSendPublish,\n\t\tSendPublishKeepalive,\n\t\tSubscriptionTimeout,\n\t} PublishResult;\n\n\tclass DLLEXPORT Subscription\n\t: public Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<Subscription> SPtr;\n\n\t\tSubscription(void);\n\t\t~Subscription(void);\n\n\t\tuint32_t subscriptionId(void);\n\t\tvoid publishingInterval(double publishingInterval);\n\t\tvoid lifetimeCount(uint32_t lifetimeCount);\n\t\tvoid maxKeepAliveCount(uint32_t maxKeepAliveCount);\n\t\tvoid ioThread(IOThread* ioThread);\n\t\tvoid informationModel(InformationModel::SPtr informationModel);\n\t\tvoid forwardGlobalSync(ForwardGlobalSync::SPtr& forwardGlobalSync);\n\t\tOpcUaStatusCode receiveAcknowledgement(uint32_t acknowledgmentNumber);\n\n\t\tvoid retransmissionQueue(SubscriptionAcknowledgement::SPtr subscriptionAcknowledgement);\n\t\tvoid retransmissionQueue(PublishResponse::SPtr publishResponse);\n\n\t\tPublishResult publish(ServiceTransactionPublish::SPtr trx);\n\t\tuint32_t publishPre(void);\n\n\n\t\tOpcUaStatusCode receive(ServiceTransactionCreateMonitoredItems::SPtr trx);\n\t\tOpcUaStatusCode receive(ServiceTransactionDeleteMonitoredItems::SPtr trx);\n\t\tOpcUaStatusCode receive(ServiceTransactionModifyMonitoredItems::SPtr trx);\n\t\tOpcUaStatusCode receive(ServiceTransactionSetMonitoringMode::SPtr trx);\n\t\tOpcUaStatusCode receive(ServiceTransactionSetTriggering::SPtr trx);\n\n\t\tSlotTimerElement::SPtr slotTimerElement(void);\n\n\t  private:\n\t\tvoid createKeepalive(ServiceTransactionPublish::SPtr trx);\n\n\t\tstatic uint32_t uniqueSubscriptionId(void);\n\t\tstatic boost::mutex mutex_;\n\t\tstatic uint32_t uniqueSubscriptionId_;\n\n\t\tAcknowledgementManager acknowledgementManager_;\n\t\tuint32_t subscriptionId_;\n\t\tdouble publishingInterval_;\n\t\tuint32_t lifetimeCount_;\n\t\tuint32_t actLifetimeCount_;\n\t\tuint32_t maxKeepAliveCount_;\n\t\tuint32_t actMaxKeepAliveCount_;\n\t\tSlotTimerElement::SPtr slotTimerElement_;\n\t\tRetransmissionQueue retransmissionQueue_;\n\n\t\tIOThread* ioThread_;\n\t\tMonitorManager monitorManager_;\n\t};\n\n\ttypedef std::map<uint32_t, Subscription::SPtr> SubscriptionMap;\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/SubscriptionServiceTransaction.h'\n:\n\n#ifndef __OpcUaStackCore_SubscriptionServiceTransaction_h__\n#define __OpcUaStackCore_SubscriptionServiceTransaction_h__\n\n#include \"OpcUaStackCore/BuildInTypes/OpcUaIdentifier.h\"\n#include \"OpcUaStackCore/ServiceSet/ServiceTransactionTemplate.h\"\n#include \"OpcUaStackCore/ServiceSet/CreateSubscriptionRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/CreateSubscriptionResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/ModifySubscriptionRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/ModifySubscriptionResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/SetPublishingModeRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/SetPublishingModeResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/PublishRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/PublishResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/RepublishRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/RepublishResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/TransferSubscriptionsRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/TransferSubscriptionsResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/DeleteSubscriptionsRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/DeleteSubscriptionsResponse.h\"\n\nnamespace OpcUaStackCore\n{\n\n\ttypedef ServiceTransactionTemplate<\n\t\tCreateSubscriptionRequest,\n\t\tCreateSubscriptionResponse,\n\t\tOpcUaId_CreateSubscriptionRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_CreateSubscriptionResponse_Encoding_DefaultBinary\n\t> ServiceTransactionCreateSubscription;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tModifySubscriptionRequest,\n\t\tModifySubscriptionResponse,\n\t\tOpcUaId_ModifySubscriptionRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_ModifySubscriptionResponse_Encoding_DefaultBinary\n\t> ServiceTransactionModifySubscription;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tSetPublishingModeRequest,\n\t\tSetPublishingModeResponse,\n\t\tOpcUaId_SetPublishingModeRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_SetPublishingModeResponse_Encoding_DefaultBinary\n\t> ServiceTransactionSetPublishingMode;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tPublishRequest,\n\t\tPublishResponse,\n\t\tOpcUaId_PublishRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_PublishResponse_Encoding_DefaultBinary\n\t> ServiceTransactionPublish;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tRepublishRequest,\n\t\tRepublishResponse,\n\t\tOpcUaId_RepublishRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_RepublishResponse_Encoding_DefaultBinary\n\t> ServiceTransactionRepublish;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tTransferSubscriptionsRequest,\n\t\tTransferSubscriptionsResponse,\n\t\tOpcUaId_TransferSubscriptionsRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_TransferSubscriptionsResponse_Encoding_DefaultBinary\n\t> ServiceTransactionTransferSubscriptions;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tDeleteSubscriptionsRequest,\n\t\tDeleteSubscriptionsResponse,\n\t\tOpcUaId_DeleteSubscriptionsRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_DeleteSubscriptionsResponse_Encoding_DefaultBinary\n\t> ServiceTransactionDeleteSubscriptions;\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackServer/ServiceSet/Subscription.cpp'\n:\n\n#include \"OpcUaStackServer/ServiceSet/Subscription.h\"\n#include \"OpcUaStackCore/ServiceSet/DataChangeNotification.h\"\n\nnamespace OpcUaStackServer\n{\n\n\tuint32_t Subscription::uniqueSubscriptionId_ = 0;\n\tboost::mutex Subscription::mutex_;\n\n\tuint32_t\n\tSubscription::uniqueSubscriptionId(void)\n\t{\n\t\tboost::mutex::scoped_lock g(mutex_);\n\t\tuniqueSubscriptionId_++;\n\t\treturn uniqueSubscriptionId_;\n\t}\n\n\n\n\tSubscription::Subscription(void)\n\t: subscriptionId_(uniqueSubscriptionId())\n\t, slotTimerElement_(constructSPtr<SlotTimerElement>())\n\t, retransmissionQueue_()\n\t, monitorManager_()\n\t, acknowledgementManager_()\n\t{\n\t    monitorManager_.subscriptionId(subscriptionId_);\n\t}\n\n\tSubscription::~Subscription(void)\n\t{\n\t\tretransmissionQueue_.clear();\n\t}\n\n\tuint32_t\n\tSubscription::subscriptionId(void)\n\t{\n\t\treturn subscriptionId_;\n\t}\n\n\tvoid\n\tSubscription::publishingInterval(double publishingInterval)\n\t{\n\t\tpublishingInterval_ = publishingInterval;\n\t}\n\n\tSlotTimerElement::SPtr\n\tSubscription::slotTimerElement(void)\n\t{\n\t\treturn slotTimerElement_;\n\t}\n\n\tvoid\n\tSubscription::lifetimeCount(uint32_t lifetimeCount)\n\t{\n\t\tlifetimeCount_ = lifetimeCount;\n\t\tactLifetimeCount_ = lifetimeCount;\n\t}\n\n\tvoid\n\tSubscription::maxKeepAliveCount(uint32_t maxKeepAliveCount)\n\t{\n\t\tmaxKeepAliveCount_ = maxKeepAliveCount;\n\t\tactMaxKeepAliveCount_  = maxKeepAliveCount;\n\t}\n\n\tvoid\n\tSubscription::ioThread(IOThread* ioThread)\n\t{\n\t\tioThread_ = ioThread;\n\t\tmonitorManager_.ioThread(ioThread);\n\t}\n\n\tvoid\n\tSubscription::informationModel(InformationModel::SPtr informationModel)\n\t{\n\t\tmonitorManager_.informationModel(informationModel);\n\t}\n\n\tvoid\n\tSubscription::forwardGlobalSync(ForwardGlobalSync::SPtr& forwardGlobalSync)\n\t{\n\t\tmonitorManager_.forwardGlobalSync(forwardGlobalSync);\n\t}\n\n\tOpcUaStatusCode\n\tSubscription::receiveAcknowledgement(uint32_t acknowledgmentNumber)\n\t{\n\t\tacknowledgementManager_.deleteNotification(acknowledgmentNumber);\n\t\treturn Success;\n\t}\n\n\n\tuint32_t\n\tSubscription::publishPre(void)\n\t{\n\t\treturn 0;\n\t}\n\n\tPublishResult\n\tSubscription::publish(ServiceTransactionPublish::SPtr trx)\n\t{\n\t\tif (trx.get() == NULL) {\n\t\t\tactLifetimeCount_--;\n\n\t\t\tif (actLifetimeCount_ == 0) return SubscriptionTimeout;\n\n\t\t\tif (actMaxKeepAliveCount_ == 0) return NothingTodo;\n\n\n\t\t\tactMaxKeepAliveCount_--;\n\t\t\tif (actMaxKeepAliveCount_ == 0) return NeedAttention;\n\n\t\t\treturn NothingTodo;\n\t\t}\n\n\n\t\tactLifetimeCount_ = lifetimeCount_;\n\n\t\tExtensibleParameter::SPtr extensibleParameter;\n\t\tOpcUaStatusCode statusCode;\n\n\n\n\n\t\textensibleParameter = constructSPtr<ExtensibleParameter>();\n\t\textensibleParameter->parameterTypeId().nodeId(OpcUaId_EventNotificationList_Encoding_DefaultBinary);\n\t\tEventNotificationList::SPtr eventNotificationList = extensibleParameter->parameter<EventNotificationList>();\n\t\tstatusCode = monitorManager_.receive(eventNotificationList->events());\n\t\tif (eventNotificationList->events()->size() > 0) {\n\t\t\tactMaxKeepAliveCount_ = maxKeepAliveCount_;\n\n\t\t\tuint32_t sequencenumber = acknowledgementManager_.nextSequenceNumber();\n\t\t\tacknowledgementManager_.addNotification(sequencenumber, extensibleParameter);\n\n\t\t\tPublishResponse::SPtr publishResponse = trx->response();\n\t\t\tpublishResponse->notificationMessage()->notificationData()->set(0, extensibleParameter);\n\t\t\tpublishResponse->notificationMessage()->publishTime().dateTime(boost::posix_time::microsec_clock::local_time());\n\t\t\tpublishResponse->notificationMessage()->sequenceNumber(sequencenumber);\n\t\t\tpublishResponse->subscriptionId(subscriptionId_);\n\t\t\tpublishResponse->moreNotifications(false);\n\t\t\tacknowledgementManager_.availableSequenceNumbers(publishResponse->availableSequenceNumbers());\n\n\t\t\tif (statusCode == BadOutOfMemory) return NeedAttention;\n\t\t\treturn SendPublish;\n\t\t}\n\n\n\n\n\t\textensibleParameter = constructSPtr<ExtensibleParameter>();\n\t\textensibleParameter->parameterTypeId().nodeId(OpcUaId_DataChangeNotification_Encoding_DefaultBinary);\n\t\tDataChangeNotification::SPtr dataChangeNotification = extensibleParameter->parameter<DataChangeNotification>();\n\n\t\tstatusCode = monitorManager_.receive(dataChangeNotification->monitoredItems());\n\t\tif (dataChangeNotification->monitoredItems()->size() > 0) {\n\t\t\tactMaxKeepAliveCount_ = maxKeepAliveCount_;\n\n\t\t\tuint32_t sequencenumber = acknowledgementManager_.nextSequenceNumber();\n\t\t\tacknowledgementManager_.addNotification(sequencenumber, extensibleParameter);\n\n\t\t\tPublishResponse::SPtr publishResponse = trx->response();\n\t\t\tpublishResponse->notificationMessage()->notificationData()->set(0, extensibleParameter);\n\t\t\tpublishResponse->notificationMessage()->publishTime().dateTime(boost::posix_time::microsec_clock::local_time());\n\t\t\tpublishResponse->notificationMessage()->sequenceNumber(sequencenumber);\n\t\t\tpublishResponse->subscriptionId(subscriptionId_);\n\t\t\tpublishResponse->moreNotifications(false);\n\t\t\tacknowledgementManager_.availableSequenceNumbers(publishResponse->availableSequenceNumbers());\n\n\t\t\tif (statusCode == BadOutOfMemory) return NeedAttention;\n\t\t\treturn SendPublish;\n\t\t}\n\n\n\n\n\t\tactMaxKeepAliveCount_--;\n\t\tif (actMaxKeepAliveCount_ == 0) {\n\t\t\tactMaxKeepAliveCount_  = maxKeepAliveCount_;\n\n\t\t\tcreateKeepalive(trx);\n\t\t\treturn SendPublishKeepalive;\n\t\t}\n\n\t\treturn NothingTodo;\n\t}\n\n\tvoid\n\tSubscription::createKeepalive(ServiceTransactionPublish::SPtr trx)\n\t{\n\t\tPublishRequest::SPtr publishRequest = trx->request();\n\t\tPublishResponse::SPtr publishResponse = trx->response();\n\t\tServiceTransaction::SPtr serviceTransaction = trx;\n\n\t\tuint32_t sequencenumber = acknowledgementManager_.nextSequenceNumber(true);\n\n\t\tpublishResponse->notificationMessage()->publishTime().dateTime(boost::posix_time::microsec_clock::local_time());\n\t\tpublishResponse->notificationMessage()->sequenceNumber(sequencenumber);\n\t\tpublishResponse->subscriptionId(subscriptionId_);\n\t\tpublishResponse->moreNotifications(false);\n\t\tacknowledgementManager_.availableSequenceNumbers(publishResponse->availableSequenceNumbers());\n\t}\n\n\tvoid\n\tSubscription::retransmissionQueue(SubscriptionAcknowledgement::SPtr subscriptionAcknowledgement)\n\t{\n\t\tretransmissionQueue_.erase(subscriptionAcknowledgement->sequenceNumber());\n\t}\n\n\tvoid\n\tSubscription::retransmissionQueue(PublishResponse::SPtr publishResponse)\n\t{\n\t\tpublishResponse->availableSequenceNumbers()->resize(retransmissionQueue_.size());\n\n\t\tuint32_t idx = 0;\n\t\tRetransmissionQueue::iterator it;\n\t\tfor (it=retransmissionQueue_.begin(); it!=retransmissionQueue_.end(); it++) {\n\t\t\tpublishResponse->availableSequenceNumbers()->set(idx, it->first);\n\t\t\tidx++;\n\t\t}\n\n\t\tretransmissionQueue_.insert(std::make_pair(publishResponse->notificationMessage()->sequenceNumber(), publishResponse));\n\t}\n\n\n\tOpcUaStatusCode\n\tSubscription::receive(ServiceTransactionCreateMonitoredItems::SPtr trx)\n\t{\n\n\n\t\treturn monitorManager_.receive(trx);\n\t}\n\n\tOpcUaStatusCode\n\tSubscription::receive(ServiceTransactionDeleteMonitoredItems::SPtr trx)\n\t{\n\n\n\t\treturn monitorManager_.receive(trx);\n\t}\n\n\tOpcUaStatusCode\n\tSubscription::receive(ServiceTransactionModifyMonitoredItems::SPtr trx)\n\t{\n\t\treturn monitorManager_.receive(trx);\n\t}\n\n\tOpcUaStatusCode\n\tSubscription::receive(ServiceTransactionSetMonitoringMode::SPtr trx)\n\t{\n\t\treturn monitorManager_.receive(trx);\n\t}\n\n\tOpcUaStatusCode\n\tSubscription::receive(ServiceTransactionSetTriggering::SPtr trx)\n\t{\n\t\treturn monitorManager_.receive(trx);\n\t}\n}\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/ServiceTransactionTemplate.h'\n:\n\n#ifndef __OpcUaStackCore_ServiceTransactionTemplate_h__\n#define __OpcUaStackCore_ServiceTransactionTemplate_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/ServiceSet/ServiceTransaction.h\"\n#include \"OpcUaStackCore/ServiceSet/ServiceTransactionIf.h\"\n\nnamespace OpcUaStackCore\n{\n\n\ttemplate<typename REQTYPE, typename RESTYPE, uint32_t REQID, uint32_t RESID>\n\t  class ServiceTransactionTemplate\n\t  : public ServiceTransaction\n\t  {\n\t    public:\n\t\t  typedef boost::shared_ptr<ServiceTransactionTemplate<REQTYPE, RESTYPE, REQID, RESID> > SPtr;\n\n\t\t  static void name(const std::string& name);\n\t\t  static std::string name(void);\n\n\t\t  ServiceTransactionTemplate(void);\n\t\t  virtual ~ServiceTransactionTemplate(void);\n\n\t\t  ServiceTransaction::SPtr constructTransaction(void);\n\n\t\t  typename REQTYPE::SPtr request(void);\n\t\t  typename RESTYPE::SPtr response(void);\n\n\t\t  std::string requestName(void);\n\t\t  std::string responseName(void);\n\n\t\t  void opcUaBinaryEncodeRequest(std::ostream& os) const;\n\t\t  void opcUaBinaryEncodeResponse(std::ostream& os) const;\n\t\t  void opcUaBinaryDecodeRequest(std::istream& is);\n\t\t  void opcUaBinaryDecodeResponse(std::istream& is);\n\n\t    private:\n\t\t  ResponseHeader::SPtr responseHeader_;\n\t\t  typename REQTYPE::SPtr request_;\n\t\t  typename RESTYPE::SPtr response_;\n\n\t\t  static std::string name_;\n\t  };\n\n}\n\n#include \"OpcUaStackCore/ServiceSet/ServiceTransactionTemplate.txx\"\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/ServiceTransactionIf.h'\n:\n\n#ifndef __OpcUaStackCore_ServiceTransactionIf_h__\n#define __OpcUaStackCore_ServiceTransactionIf_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaNodeId.h\"\n#include \"OpcUaStackCore/ServiceSet/ServiceTransaction.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT ServiceTransactionIf\n\t{\n\t  public:\n\n\t\tvirtual void receive(OpcUaNodeId& typeId, ServiceTransaction::SPtr serviceTransaction) = 0;\n\t};\n\n};\n\n#endif\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/ServiceTransactionIf.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/ServiceTransactionTemplate.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/SubscriptionServiceTransaction.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/Subscription.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/Subscription.cpp'"
        ]
    },
    {
        "files": [
            "'Luz/deps/glm/mat2x2.hpp'",
            "'Luz/deps/glm/glm.hpp'",
            "'Luz/source/Graphics/Window.hpp'",
            "'Luz/source/Core/main.cpp'"
        ],
        "content": "'Luz/deps/glm/mat2x2.hpp'\n:\n\n\n#pragma once\n#include \"./ext/matrix_double2x2.hpp\"\n#include \"./ext/matrix_double2x2_precision.hpp\"\n#include \"./ext/matrix_float2x2.hpp\"\n#include \"./ext/matrix_float2x2_precision.hpp\"\n\n\n'Luz/deps/glm/glm.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"detail/_fixes.hpp\"\n\n#include \"detail/setup.hpp\"\n\n#pragma once\n\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <limits>\n#include <cassert>\n#include \"fwd.hpp\"\n\n#include \"vec2.hpp\"\n#include \"vec3.hpp\"\n#include \"vec4.hpp\"\n#include \"mat2x2.hpp\"\n#include \"mat2x3.hpp\"\n#include \"mat2x4.hpp\"\n#include \"mat3x2.hpp\"\n#include \"mat3x3.hpp\"\n#include \"mat3x4.hpp\"\n#include \"mat4x2.hpp\"\n#include \"mat4x3.hpp\"\n#include \"mat4x4.hpp\"\n\n#include \"trigonometric.hpp\"\n#include \"exponential.hpp\"\n#include \"common.hpp\"\n#include \"packing.hpp\"\n#include \"geometric.hpp\"\n#include \"matrix.hpp\"\n#include \"vector_relational.hpp\"\n#include \"integer.hpp\"\n\n'Luz/source/Graphics/Window.hpp'\n:#pragma once\n\n#include <GLFW/glfw3.h>\n#include <glm/glm.hpp>\n#include <chrono>\n\nenum class WindowMode {\n    Windowed,\n    WindowedFullScreen,\n    FullScreen\n};\nclass Window {\nprivate:\n    static inline GLFWwindow*   window             = nullptr;\n    static inline GLFWmonitor** monitors           = nullptr;\n    static inline const char*   name               = \"Luz Engine\";\n    static inline int           width              = 1280;\n    static inline int           height             = 720;\n    static inline int           posX               = 0;\n    static inline int           posY               = 30;\n    static inline int           monitorIndex       = 0;\n    static inline int           monitorCount       = 0;\n    static inline int           videoModeIndex     = 0;\n    static inline bool          framebufferResized = false;\n\n    static inline std::chrono::high_resolution_clock::time_point lastTime;\n    static inline float deltaTime = .0f;\n\n    static inline std::vector<std::string> pathsDrop;\n\n    static inline float     scroll        = .0f;\n    static inline float     deltaScroll   = .0f;\n    static inline glm::vec2 mousePos      = glm::vec2(.0f, .0f);\n    static inline glm::vec2 deltaMousePos = glm::vec2(.0f, .0f);\n\n    static inline char lastKeyState[GLFW_KEY_LAST + 1];\n    static inline WindowMode mode = WindowMode::Windowed;\n    static inline bool dirty     = true;\n    static inline bool resizable = true;\n    static inline bool decorated = true;\n    static inline bool maximized = true;\n\n    static void ScrollCallback(GLFWwindow* window, double x, double y);\n    static void FramebufferResizeCallback(GLFWwindow* window, int width, int height);\n    static void WindowMaximizeCallback(GLFWwindow* window, int maximized);\n    static void WindowChangePosCallback(GLFWwindow* window, int x, int y);\n    static void WindowDropCallback(GLFWwindow* window, int count, const char* paths[]);\n\npublic:\n    static void Create();\n    static void Update();\n    static void OnImgui();\n    static void Destroy();\n    static void ApplyChanges();\n    static void UpdateFramebufferSize();\n    static bool IsKeyPressed(uint16_t keyCode);\n\n    static inline GLFWwindow* GetGLFWwindow()                  { return window;                                 }\n    static inline bool        IsDirty()                        { return dirty;                                  }\n    static inline void        WaitEvents()                     { glfwWaitEvents();                              }\n    static inline uint32_t    GetWidth()                       { return width;                                  }\n    static inline uint32_t    GetHeight()                      { return height;                                 }\n    static inline float       GetDeltaTime()                   { return deltaTime;                              }\n    static inline bool        GetShouldClose()                 { return glfwWindowShouldClose(window);          }\n    static inline float       GetDeltaScroll()                 { return deltaScroll;                            }\n    static inline glm::vec2   GetDeltaMouse()                  { return deltaMousePos;                          }\n    static inline bool        GetFramebufferResized()          { return framebufferResized;                     }\n    static inline bool        IsKeyDown(uint16_t keyCode)      { return glfwGetKey(window, keyCode);            }\n    static inline bool        IsMouseDown(uint16_t buttonCode) { return glfwGetMouseButton(window, buttonCode); }\n    static inline void        SetMode(WindowMode newMode) { mode = newMode; dirty = true; }\n    static inline std::vector<std::string> GetAndClearPaths()  { auto paths = pathsDrop; pathsDrop.clear(); return paths; }\n};\n'Luz/source/Core/main.cpp'\n:#include \"Luzpch.hpp\"\n\n#include \"Window.hpp\"\n#include \"CameraController.hpp\"\n#include \"FileManager.hpp\"\n#include \"DeferredRenderer.hpp\"\n#include \"VulkanWrapper.h\"\n#include \"AssetManager.hpp\"\n#include \"GPUScene.hpp\"\n#include \"Editor.h\"\n#include \"DebugDraw.h\"\n#include \"LuzCommon.h\"\n\n#include <stb_image.h>\n\n#include <imgui/imgui_stdlib.h>\n#include <imgui/ImGuizmo.h>\n\n#include <GLFW/glfw3.h>\n\nclass LuzApplication {\npublic:\n    void run() {\n        Setup();\n        Create();\n        MainLoop();\n        Finish();\n    }\n\nprivate:\n    u32 frameCount = 0;\n    ImDrawData* imguiDrawData = nullptr;\n    glm::ivec2 viewportSize = { 64, 48 };\n    glm::ivec2 newViewportSize = viewportSize;\n    AssetManager assetManager;\n    GPUScene gpuScene;\n    Ref<SceneAsset> scene;\n    Ref<CameraNode> camera;\n    Editor editor;\n    CameraController cameraController;\n    bool viewportHovered = false;\n    bool fullscreen = false;\n    bool batterySaver = LUZ_BATTERY_SAVER;\n    DeferredRenderer::Output outputMode = DeferredRenderer::Output::Light;\n\n    std::chrono::high_resolution_clock::time_point lastFrameTime = {};\n    std::chrono::high_resolution_clock::time_point lastCameraTime = {};\n\n    void Setup() {\n        LUZ_PROFILE_FUNC();\n        IMGUI_CHECKVERSION();\n        assetManager.LoadProject(\"assets/default.luz\", \"assets/default.luzbin\");\n        scene = assetManager.GetInitialScene();\n        camera = assetManager.GetMainCamera(scene);\n    }\n\n    void Create() {\n        LUZ_PROFILE_FUNC();\n        Window::Create();\n        vkw::Init(Window::GetGLFWwindow(), Window::GetWidth(), Window::GetHeight());\n        DeferredRenderer::CreateImages(Window::GetWidth(), Window::GetHeight());\n        DeferredRenderer::CreateShaders();\n        gpuScene.Create();\n        DebugDraw::Create();\n        camera->extent = { viewportSize.x, viewportSize.y };\n    }\n\n    void Finish() {\n        LUZ_PROFILE_FUNC();\n        DebugDraw::Destroy();\n        gpuScene.Destroy();\n        DeferredRenderer::Destroy();\n        vkw::Destroy();\n        Window::Destroy();\n        FinishImgui();\n    }\n\n    void MainLoop() {\n        while (!Window::GetShouldClose()) {\n            LUZ_PROFILE_FRAME();\n            LUZ_PROFILE_NAMED(\"MainLoop\");\n            if (const auto paths = Window::GetAndClearPaths(); paths.size()) {\n                auto newNodes = assetManager.AddAssetsToScene(scene, paths);\n                if (newNodes.size()) {\n                    editor.Select(assetManager, newNodes);\n                }\n            }\n            gpuScene.AddAssets(assetManager);\n\n            {\n                auto currentTime = std::chrono::high_resolution_clock::now();\n                float deltaTime = std::chrono::duration_cast<std::chrono::nanoseconds>(currentTime - lastCameraTime).count() / 1000000.0f;\n                cameraController.Update(scene, camera, viewportHovered, deltaTime);\n                lastCameraTime = currentTime;\n            }\n            DrawFrame();\n            bool ctrlPressed = Window::IsKeyPressed(GLFW_KEY_LEFT_CONTROL) || Window::IsKeyDown(GLFW_KEY_LEFT_CONTROL);\n            if (ctrlPressed && Window::IsKeyPressed(GLFW_KEY_S)) {\n                assetManager.SaveProject(\"assets/default.luz\", \"assets/default.luzbin\");\n            }\n            if (Window::IsKeyPressed(GLFW_KEY_F5)) {\n                vkw::WaitIdle();\n                DeferredRenderer::CreateShaders();\n            } else if (DirtyFrameResources()) {\n                RecreateFrameResources();\n            }\n            BatterySaver();\n            Window::Update();\n        }\n        vkw::WaitIdle();\n    }\n\n    bool DirtyFrameResources() {\n        bool dirty = false;\n        dirty |= (newViewportSize != viewportSize);\n        dirty |= vkw::GetSwapChainDirty();\n        dirty |= Window::GetFramebufferResized();\n        dirty |= Window::IsDirty();\n        return dirty;\n    }\n\n    void BatterySaver() {\n        LUZ_PROFILE_NAMED(\"BatterySaver\");\n        if (!batterySaver) {\n            return;\n        }\n        float targetFrameTime = 33.333f;\n        float elapsedTime = 0.0f;\n        do {\n            auto currentTime = std::chrono::high_resolution_clock::now();\n            elapsedTime = std::chrono::duration_cast<std::chrono::microseconds>(currentTime - lastFrameTime).count() / 1000.0f;\n        } while (elapsedTime < targetFrameTime);\n\n        lastFrameTime = std::chrono::high_resolution_clock::now();\n    }\n\n    ImVec2 ToScreenSpace(glm::vec3 position) {\n        glm::vec4 cameraSpace = camera->GetProj() * camera->GetView() * glm::vec4(position, 1.0f);\n        ImVec2 screenSpace = ImVec2(cameraSpace.x / cameraSpace.w, cameraSpace.y / cameraSpace.w);\n        glm::ivec2 ext = viewportSize;\n        screenSpace.x = (screenSpace.x + 1.0f) * ext.x/2.0f;\n        screenSpace.y = (screenSpace.y + 1.0f) * ext.y/2.0f;\n        return screenSpace;\n    }\n\n    void DrawEditor() {\n        LUZ_PROFILE_FUNC();\n        LUZ_PROFILE_NAMED(\"DrawEditor\");\n\n        if (ImGui::IsKeyPressed(ImGuiKey_F11)) {\n            fullscreen = !fullscreen;\n            if (fullscreen) {\n                Window::SetMode(WindowMode::FullScreen);\n                glfwSetInputMode(Window::GetGLFWwindow(), GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n            } else {\n                Window::SetMode(WindowMode::Windowed);\n                glfwSetInputMode(Window::GetGLFWwindow(), GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n            }\n        }\n        if (ImGui::IsKeyPressed(ImGuiKey_F7)) {\n            outputMode = DeferredRenderer::Output((outputMode + 1) % DeferredRenderer::Output::Count);\n        }\n\n        editor.BeginFrame();\n\n        if (!fullscreen) {\n            viewportHovered = editor.ViewportPanel(DeferredRenderer::GetComposedImage(), newViewportSize);\n            editor.ProfilerPanel();\n            editor.AssetsPanel(assetManager);\n            editor.DemoPanel();\n            editor.ScenePanel(scene);\n            editor.InspectorPanel(assetManager, camera, gpuScene);\n            editor.DebugDrawPanel();\n        } else {\n            newViewportSize = { Window::GetWidth(), Window::GetHeight() };\n            viewportHovered = true;\n        }\n        editor.ProfilerPopup();\n\n        imguiDrawData = editor.EndFrame();\n    }\n\n    void RenderFrame() {\n        gpuScene.UpdateResources(scene, camera);\n        DebugDraw::Update();\n\n        LUZ_PROFILE_FUNC();\n\n        vkw::BeginCommandBuffer(vkw::Queue::Graphics);\n\n        gpuScene.UpdateResourcesGPU();\n        gpuScene.UpdateLineResources();\n\n        vkw::CmdBarrier();\n\n        auto totalTS = vkw::CmdBeginTimeStamp(\"Total\");\n\n        OpaqueConstants constants;\n        constants.sceneBufferIndex = gpuScene.GetSceneBuffer();\n        constants.modelBufferIndex = gpuScene.GetModelsBuffer();\n\n        auto opaqueTS = vkw::CmdBeginTimeStamp(\"OpaquePass\");\n        DeferredRenderer::BeginOpaquePass();\n\n        {\n            LUZ_PROFILE_NAMED(\"RenderModels\");\n            auto& allModels = gpuScene.GetMeshModels();\n            for (GPUModel& model : allModels) {\n                constants.modelID = model.modelRID;\n                vkw::CmdPushConstants(&constants, sizeof(constants));\n                vkw::CmdDrawMesh(model.mesh.vertexBuffer, model.mesh.indexBuffer, model.mesh.indexCount);\n            }\n        }\n\n\n\n        DeferredRenderer::EndPass();\n        vkw::CmdEndTimeStamp(opaqueTS);\n\n        auto shadowMapTS = vkw::CmdBeginTimeStamp(\"ShadowMaps\");\n        for (auto& light : scene->GetAll<LightNode>(ObjectType::LightNode)) {\n            DeferredRenderer::ShadowMapPass(light, scene, gpuScene);\n        }\n        vkw::CmdEndTimeStamp(shadowMapTS);\n\n        auto lightTS = vkw::CmdBeginTimeStamp(\"LightPass\");\n        DeferredRenderer::LightConstants lightPassConstants;\n        lightPassConstants.sceneBufferIndex = constants.sceneBufferIndex;\n        lightPassConstants.modelBufferIndex = constants.modelBufferIndex;\n        lightPassConstants.frameID = frameCount;\n        DeferredRenderer::LightPass(lightPassConstants);\n        vkw::CmdEndTimeStamp(lightTS);\n\n        auto volumetricTS = vkw::CmdBeginTimeStamp(\"VolumetricLightPass\");\n        if (gpuScene.AnyVolumetricLight()) {\n            DeferredRenderer::ScreenSpaceVolumetricLightPass(gpuScene, frameCount);\n            DeferredRenderer::ShadowMapVolumetricLightPass(gpuScene, frameCount);\n        }\n        vkw::CmdEndTimeStamp(volumetricTS);\n\n        auto taaTS = vkw::CmdBeginTimeStamp(\"TAAPass\");\n        DeferredRenderer::TAAPass(gpuScene, scene);\n        vkw::CmdEndTimeStamp(taaTS);\n\n        auto lineTS = vkw::CmdBeginTimeStamp(\"LineRenderingPass\");\n        DeferredRenderer::LineRenderingPass(gpuScene);\n        vkw::CmdEndTimeStamp(lineTS);\n\n        auto histogramTS = vkw::CmdBeginTimeStamp(\"LuminanceHistogramPass\");\n        DeferredRenderer::LuminanceHistogramPass();\n        vkw::CmdEndTimeStamp(histogramTS);\n\n        auto composeTS = vkw::CmdBeginTimeStamp(\"ComposePass\");\n        if (fullscreen) {\n            vkw::CmdBeginPresent();\n            DeferredRenderer::ComposePass(false, outputMode, scene);\n        }  else {\n            DeferredRenderer::ComposePass(true, outputMode, scene);\n            vkw::CmdBeginPresent();\n        }\n        vkw::CmdEndTimeStamp(composeTS);\n\n        auto imguiTS = vkw::CmdBeginTimeStamp(\"ImGui\");\n        vkw::CmdDrawImGui(imguiDrawData);\n        vkw::CmdEndTimeStamp(imguiTS);\n\n        vkw::CmdEndPresent();\n        vkw::CmdEndTimeStamp(totalTS);\n\n        DeferredRenderer::SwapLightHistory();\n    }\n\n    void DrawFrame() {\n        LUZ_PROFILE_FUNC();\n        DrawEditor();\n        RenderFrame();\n        if (vkw::GetSwapChainDirty()) {\n            return;\n        }\n        vkw::SubmitAndPresent();\n        frameCount = (frameCount + 1) % (1 << 15);\n    }\n\n    void RecreateFrameResources() {\n        LUZ_PROFILE_FUNC();\n\n        while (Window::GetWidth() == 0 || Window::GetHeight() == 0) {\n            Window::WaitEvents();\n        }\n        viewportSize = newViewportSize;\n        if (viewportSize.x == 0 || viewportSize.y == 0) {\n            return;\n        }\n        vkw::WaitIdle();\n        if (Window::GetFramebufferResized() || Window::IsDirty()) {\n            if (Window::IsDirty()) {\n                Window::ApplyChanges();\n            }\n            Window::UpdateFramebufferSize();\n            vkw::OnSurfaceUpdate(Window::GetWidth(), Window::GetHeight());\n        }\n        DeferredRenderer::CreateImages(viewportSize.x, viewportSize.y);\n        camera->extent = {viewportSize.x, viewportSize.y};\n    }\n\n    void FinishImgui() {\n        ImGui::DestroyContext();\n    }\n\n};\n\nbool CheckAssetsDirectory() {\n    return std::filesystem::is_directory(\"assets/\");\n}\n\nint main() {\n    Logger::Init();\n    if (!CheckAssetsDirectory()) {\n        Log::Error(\"Wrong working directory. Run from main directory (\\\"Luz/\\\")\");\n        Log::Error(\"(Linux): ./Luz/bin/Luz\");\n        Log::Error(\"(Windows): ./Luz/bin/Luz.exe\");\n        return 0;\n    }\n    LuzApplication app;\n    app.run();\n    return 0;\n}",
        "gt": [
            "'Luz/deps/glm/mat2x2.hpp'",
            "'Luz/deps/glm/glm.hpp'",
            "'Luz/source/Graphics/Window.hpp'",
            "'Luz/source/Core/main.cpp'"
        ]
    },
    {
        "files": [
            "'pyeos/externals/thrift/src/thrift/server/TServer.h'",
            "'pyeos/externals/thrift/test/processor/ServerThread.h'",
            "'pyeos/externals/thrift/test/processor/ServerThread.cpp'"
        ],
        "content": "'pyeos/externals/thrift/src/thrift/server/TServer.h'\n:\n\n#ifndef _THRIFT_SERVER_TSERVER_H_\n#define _THRIFT_SERVER_TSERVER_H_ 1\n\n#include <thrift/TProcessor.h>\n#include <thrift/transport/TServerTransport.h>\n#include <thrift/protocol/TBinaryProtocol.h>\n#include <thrift/concurrency/Thread.h>\n\n#include <thrift/stdcxx.h>\n\nnamespace apache {\nnamespace thrift {\nnamespace server {\n\nusing apache::thrift::TProcessor;\nusing apache::thrift::protocol::TBinaryProtocolFactory;\nusing apache::thrift::protocol::TProtocol;\nusing apache::thrift::protocol::TProtocolFactory;\nusing apache::thrift::transport::TServerTransport;\nusing apache::thrift::transport::TTransport;\nusing apache::thrift::transport::TTransportFactory;\n\n\nclass TServerEventHandler {\npublic:\n  virtual ~TServerEventHandler() {}\n\n\n  virtual void preServe() {}\n\n\n  virtual void* createContext(stdcxx::shared_ptr<TProtocol> input,\n                              stdcxx::shared_ptr<TProtocol> output) {\n    (void)input;\n    (void)output;\n    return NULL;\n  }\n\n\n  virtual void deleteContext(void* serverContext,\n                             stdcxx::shared_ptr<TProtocol> input,\n                             stdcxx::shared_ptr<TProtocol> output) {\n    (void)serverContext;\n    (void)input;\n    (void)output;\n  }\n\n\n  virtual void processContext(void* serverContext, stdcxx::shared_ptr<TTransport> transport) {\n    (void)serverContext;\n    (void)transport;\n  }\n\nprotected:\n\n  TServerEventHandler() {}\n};\n\n\nclass TServer : public concurrency::Runnable {\npublic:\n  virtual ~TServer() {}\n\n  virtual void serve() = 0;\n\n  virtual void stop() {}\n\n\n  virtual void run() { serve(); }\n\n  stdcxx::shared_ptr<TProcessorFactory> getProcessorFactory() { return processorFactory_; }\n\n  stdcxx::shared_ptr<TServerTransport> getServerTransport() { return serverTransport_; }\n\n  stdcxx::shared_ptr<TTransportFactory> getInputTransportFactory() { return inputTransportFactory_; }\n\n  stdcxx::shared_ptr<TTransportFactory> getOutputTransportFactory() {\n    return outputTransportFactory_;\n  }\n\n  stdcxx::shared_ptr<TProtocolFactory> getInputProtocolFactory() { return inputProtocolFactory_; }\n\n  stdcxx::shared_ptr<TProtocolFactory> getOutputProtocolFactory() { return outputProtocolFactory_; }\n\n  stdcxx::shared_ptr<TServerEventHandler> getEventHandler() { return eventHandler_; }\n\nprotected:\n  TServer(const stdcxx::shared_ptr<TProcessorFactory>& processorFactory)\n    : processorFactory_(processorFactory) {\n    setInputTransportFactory(stdcxx::shared_ptr<TTransportFactory>(new TTransportFactory()));\n    setOutputTransportFactory(stdcxx::shared_ptr<TTransportFactory>(new TTransportFactory()));\n    setInputProtocolFactory(stdcxx::shared_ptr<TProtocolFactory>(new TBinaryProtocolFactory()));\n    setOutputProtocolFactory(stdcxx::shared_ptr<TProtocolFactory>(new TBinaryProtocolFactory()));\n  }\n\n  TServer(const stdcxx::shared_ptr<TProcessor>& processor)\n    : processorFactory_(new TSingletonProcessorFactory(processor)) {\n    setInputTransportFactory(stdcxx::shared_ptr<TTransportFactory>(new TTransportFactory()));\n    setOutputTransportFactory(stdcxx::shared_ptr<TTransportFactory>(new TTransportFactory()));\n    setInputProtocolFactory(stdcxx::shared_ptr<TProtocolFactory>(new TBinaryProtocolFactory()));\n    setOutputProtocolFactory(stdcxx::shared_ptr<TProtocolFactory>(new TBinaryProtocolFactory()));\n  }\n\n  TServer(const stdcxx::shared_ptr<TProcessorFactory>& processorFactory,\n          const stdcxx::shared_ptr<TServerTransport>& serverTransport)\n    : processorFactory_(processorFactory), serverTransport_(serverTransport) {\n    setInputTransportFactory(stdcxx::shared_ptr<TTransportFactory>(new TTransportFactory()));\n    setOutputTransportFactory(stdcxx::shared_ptr<TTransportFactory>(new TTransportFactory()));\n    setInputProtocolFactory(stdcxx::shared_ptr<TProtocolFactory>(new TBinaryProtocolFactory()));\n    setOutputProtocolFactory(stdcxx::shared_ptr<TProtocolFactory>(new TBinaryProtocolFactory()));\n  }\n\n  TServer(const stdcxx::shared_ptr<TProcessor>& processor,\n          const stdcxx::shared_ptr<TServerTransport>& serverTransport)\n    : processorFactory_(new TSingletonProcessorFactory(processor)),\n      serverTransport_(serverTransport) {\n    setInputTransportFactory(stdcxx::shared_ptr<TTransportFactory>(new TTransportFactory()));\n    setOutputTransportFactory(stdcxx::shared_ptr<TTransportFactory>(new TTransportFactory()));\n    setInputProtocolFactory(stdcxx::shared_ptr<TProtocolFactory>(new TBinaryProtocolFactory()));\n    setOutputProtocolFactory(stdcxx::shared_ptr<TProtocolFactory>(new TBinaryProtocolFactory()));\n  }\n\n  TServer(const stdcxx::shared_ptr<TProcessorFactory>& processorFactory,\n          const stdcxx::shared_ptr<TServerTransport>& serverTransport,\n          const stdcxx::shared_ptr<TTransportFactory>& transportFactory,\n          const stdcxx::shared_ptr<TProtocolFactory>& protocolFactory)\n    : processorFactory_(processorFactory),\n      serverTransport_(serverTransport),\n      inputTransportFactory_(transportFactory),\n      outputTransportFactory_(transportFactory),\n      inputProtocolFactory_(protocolFactory),\n      outputProtocolFactory_(protocolFactory) {}\n\n  TServer(const stdcxx::shared_ptr<TProcessor>& processor,\n          const stdcxx::shared_ptr<TServerTransport>& serverTransport,\n          const stdcxx::shared_ptr<TTransportFactory>& transportFactory,\n          const stdcxx::shared_ptr<TProtocolFactory>& protocolFactory)\n    : processorFactory_(new TSingletonProcessorFactory(processor)),\n      serverTransport_(serverTransport),\n      inputTransportFactory_(transportFactory),\n      outputTransportFactory_(transportFactory),\n      inputProtocolFactory_(protocolFactory),\n      outputProtocolFactory_(protocolFactory) {}\n\n  TServer(const stdcxx::shared_ptr<TProcessorFactory>& processorFactory,\n          const stdcxx::shared_ptr<TServerTransport>& serverTransport,\n          const stdcxx::shared_ptr<TTransportFactory>& inputTransportFactory,\n          const stdcxx::shared_ptr<TTransportFactory>& outputTransportFactory,\n          const stdcxx::shared_ptr<TProtocolFactory>& inputProtocolFactory,\n          const stdcxx::shared_ptr<TProtocolFactory>& outputProtocolFactory)\n    : processorFactory_(processorFactory),\n      serverTransport_(serverTransport),\n      inputTransportFactory_(inputTransportFactory),\n      outputTransportFactory_(outputTransportFactory),\n      inputProtocolFactory_(inputProtocolFactory),\n      outputProtocolFactory_(outputProtocolFactory) {}\n\n  TServer(const stdcxx::shared_ptr<TProcessor>& processor,\n          const stdcxx::shared_ptr<TServerTransport>& serverTransport,\n          const stdcxx::shared_ptr<TTransportFactory>& inputTransportFactory,\n          const stdcxx::shared_ptr<TTransportFactory>& outputTransportFactory,\n          const stdcxx::shared_ptr<TProtocolFactory>& inputProtocolFactory,\n          const stdcxx::shared_ptr<TProtocolFactory>& outputProtocolFactory)\n    : processorFactory_(new TSingletonProcessorFactory(processor)),\n      serverTransport_(serverTransport),\n      inputTransportFactory_(inputTransportFactory),\n      outputTransportFactory_(outputTransportFactory),\n      inputProtocolFactory_(inputProtocolFactory),\n      outputProtocolFactory_(outputProtocolFactory) {}\n\n\n  stdcxx::shared_ptr<TProcessor> getProcessor(stdcxx::shared_ptr<TProtocol> inputProtocol,\n                                             stdcxx::shared_ptr<TProtocol> outputProtocol,\n                                             stdcxx::shared_ptr<TTransport> transport) {\n    TConnectionInfo connInfo;\n    connInfo.input = inputProtocol;\n    connInfo.output = outputProtocol;\n    connInfo.transport = transport;\n    return processorFactory_->getProcessor(connInfo);\n  }\n\n\n  stdcxx::shared_ptr<TProcessorFactory> processorFactory_;\n  stdcxx::shared_ptr<TServerTransport> serverTransport_;\n\n  stdcxx::shared_ptr<TTransportFactory> inputTransportFactory_;\n  stdcxx::shared_ptr<TTransportFactory> outputTransportFactory_;\n\n  stdcxx::shared_ptr<TProtocolFactory> inputProtocolFactory_;\n  stdcxx::shared_ptr<TProtocolFactory> outputProtocolFactory_;\n\n  stdcxx::shared_ptr<TServerEventHandler> eventHandler_;\n\npublic:\n  void setInputTransportFactory(stdcxx::shared_ptr<TTransportFactory> inputTransportFactory) {\n    inputTransportFactory_ = inputTransportFactory;\n  }\n\n  void setOutputTransportFactory(stdcxx::shared_ptr<TTransportFactory> outputTransportFactory) {\n    outputTransportFactory_ = outputTransportFactory;\n  }\n\n  void setInputProtocolFactory(stdcxx::shared_ptr<TProtocolFactory> inputProtocolFactory) {\n    inputProtocolFactory_ = inputProtocolFactory;\n  }\n\n  void setOutputProtocolFactory(stdcxx::shared_ptr<TProtocolFactory> outputProtocolFactory) {\n    outputProtocolFactory_ = outputProtocolFactory;\n  }\n\n  void setServerEventHandler(stdcxx::shared_ptr<TServerEventHandler> eventHandler) {\n    eventHandler_ = eventHandler;\n  }\n};\n\n\n#ifdef HAVE_SYS_RESOURCE_H\nint increase_max_fds(int max_fds = (1 << 24));\n#endif\n}\n}\n}\n\n#endif\n\n'pyeos/externals/thrift/test/processor/ServerThread.h'\n:\n#ifndef _THRIFT_TEST_SERVERTHREAD_H_\n#define _THRIFT_TEST_SERVERTHREAD_H_ 1\n\n#include <thrift/TProcessor.h>\n#include <thrift/protocol/TProtocol.h>\n#include <thrift/server/TServer.h>\n#include <thrift/transport/TTransport.h>\n\n#include \"EventLog.h\"\n\nnamespace apache {\nnamespace thrift {\nnamespace test {\n\n\nclass ServerState {\npublic:\n  virtual ~ServerState() {}\n\n\n  virtual stdcxx::shared_ptr<server::TServer> createServer(uint16_t port) = 0;\n\n\n  virtual stdcxx::shared_ptr<server::TServerEventHandler> getServerEventHandler() {\n    return stdcxx::shared_ptr<server::TServerEventHandler>();\n  }\n\n\n  virtual void bindSuccessful(uint16_t ) {}\n};\n\n\nclass ServerThread {\npublic:\n  ServerThread(const stdcxx::shared_ptr<ServerState>& state, bool autoStart)\n    : port_(0),\n      running_(false),\n      serving_(false),\n      error_(false),\n      serverState_(state) {\n    if (autoStart) {\n      start();\n    }\n  }\n\n  void start();\n  void stop();\n\n  uint16_t getPort() const { return port_; }\n\n  ~ServerThread() {\n    if (running_) {\n      try {\n        stop();\n      } catch (...) {\n        GlobalOutput.printf(\"error shutting down server\");\n      }\n    }\n  }\n\nprotected:\n\n\n\n\n  class Helper : public concurrency::Runnable, public server::TServerEventHandler {\n  public:\n    Helper(ServerThread* serverThread) : serverThread_(serverThread) {}\n\n    void run() { serverThread_->run(); }\n\n    void preServe() { serverThread_->preServe(); }\n\n  private:\n    ServerThread* serverThread_;\n  };\n\n  void run();\n  void preServe();\n\n  stdcxx::shared_ptr<Helper> helper_;\n\n  uint16_t port_;\n  bool running_;\n  bool serving_;\n  bool error_;\n  concurrency::Monitor serverMonitor_;\n\n  stdcxx::shared_ptr<ServerState> serverState_;\n  stdcxx::shared_ptr<server::TServer> server_;\n  stdcxx::shared_ptr<concurrency::Thread> thread_;\n};\n}\n}\n}\n\n#endif\n\n'pyeos/externals/thrift/test/processor/ServerThread.cpp'\n:\n#ifndef _THRIFT_TEST_SERVERTHREAD_TCC_\n#define _THRIFT_TEST_SERVERTHREAD_TCC_ 1\n\n#include \"ServerThread.h\"\n\n#include <thrift/concurrency/PlatformThreadFactory.h>\n#include <thrift/concurrency/ThreadManager.h>\n#include <thrift/server/TThreadPoolServer.h>\n#include <thrift/transport/TBufferTransports.h>\n#include <thrift/transport/TServerSocket.h>\n\nnamespace apache {\nnamespace thrift {\nnamespace test {\n\nvoid ServerThread::start() {\n  assert(!running_);\n  running_ = true;\n\n  helper_.reset(new Helper(this));\n\n\n  concurrency::PlatformThreadFactory threadFactory;\n  threadFactory.setDetached(false);\n  thread_ = threadFactory.newThread(helper_);\n\n  thread_->start();\n\n\n\n  concurrency::Synchronized s(serverMonitor_);\n  while (!serving_ && !error_) {\n    serverMonitor_.waitForever();\n  }\n\n  if (error_) {\n    throw transport::TTransportException(transport::TTransportException::NOT_OPEN,\n                                         \"failed to bind on server socket\");\n  }\n}\n\nvoid ServerThread::stop() {\n  if (!running_) {\n    return;\n  }\n\n\n  server_->stop();\n  running_ = false;\n\n\n\n\n\n\n\n  thread_->join();\n}\n\nvoid ServerThread::run() {\n\n  port_ = 12345;\n  unsigned int maxRetries = 10;\n  for (unsigned int n = 0; n < maxRetries; ++n) {\n\n    server_ = serverState_->createServer(port_);\n\n\n\n    server_->setServerEventHandler(helper_);\n\n    try {\n\n      server_->serve();\n    } catch (const TException&) {\n\n\n      ++port_;\n      continue;\n    }\n\n\n\n\n\n\n\n    concurrency::Synchronized s(serverMonitor_);\n    if (serving_) {\n\n\n      serving_ = false;\n      return;\n    } else {\n\n\n      ++port_;\n      continue;\n    }\n  }\n\n\n  concurrency::Synchronized s(serverMonitor_);\n  error_ = true;\n  serverMonitor_.notify();\n}\n\nvoid ServerThread::preServe() {\n\n  serverState_->bindSuccessful(port_);\n\n\n  stdcxx::shared_ptr<server::TServerEventHandler> serverEventHandler\n      = serverState_->getServerEventHandler();\n  server_->setServerEventHandler(serverEventHandler);\n\n\n  concurrency::Synchronized s(serverMonitor_);\n  serving_ = true;\n  serverMonitor_.notify();\n\n\n\n  if (serverEventHandler) {\n    serverEventHandler->preServe();\n  }\n}\n}\n}\n}\n\n#endif\n",
        "gt": [
            "'pyeos/externals/thrift/src/thrift/server/TServer.h'",
            "'pyeos/externals/thrift/test/processor/ServerThread.h'",
            "'pyeos/externals/thrift/test/processor/ServerThread.cpp'"
        ]
    },
    {
        "files": [
            "'mav_dji_ros_interface/dji_sdk_lib/include/dji_sdk_lib/DJI_Config.h'",
            "'mav_dji_ros_interface/dji_sdk_lib/include/dji_sdk_lib/DJI_Logging.h'",
            "'mav_dji_ros_interface/dji_sdk_lib/src/DJI_Logging.cpp'",
            "'mav_dji_ros_interface/dji_sdk_lib/include/dji_sdk_lib/DJI_Type.h'"
        ],
        "content": "'mav_dji_ros_interface/dji_sdk_lib/include/dji_sdk_lib/DJI_Config.h'\n:\n\n#ifndef DJI_CONFIG_H\n#define DJI_CONFIG_H\n\n#include <stdint.h>\n#define MEMORY_SIZE 256\n#define BUFFER_SIZE 256\n#define ACK_SIZE 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define API_ERROR_DATA\n#define API_STATUS_DATA\n\n\n\n\n\n\n\n#include \"DJI_Version.h\"\n\n#endif\n\n'mav_dji_ros_interface/dji_sdk_lib/include/dji_sdk_lib/DJI_Logging.h'\n:\n\n#ifndef ONBOARDSDK_DJI_LOGGING_H\n#define ONBOARDSDK_DJI_LOGGING_H\n\n#include \"DJI_API.h\"\n#include \"DJI_Type.h\"\n\n#ifdef API_TRACE_DATA\nnamespace DJI {\nnamespace onboardSDK {\n\ntypedef struct __Command {\n  uint8_t set_id;\n  uint8_t id;\n} __Command;\n\ntypedef struct __ActivationGetProtocolVersionCommand {\n  uint8_t set_id;\n  uint8_t id;\n  uint8_t val;\n} __ActivationGetProtocolVersionCommand;\n\nenum __ActivationGetProtocolVersionAckCodes {\n  AUTOPILOT_ACTIVATED = 0x0000,\n  AUTOPILOT_NOT_ACTIVATED = 0xFF01\n};\n\ntypedef struct __ActivationGetProtocolVersionAck {\n  __ActivationGetProtocolVersionAckCodes status;\n  uint32_t crc;\n  uint8_t version[32];\n} __ActivationGetProtocolVersionAck;\n\nvoid printFrame(HardDriver *hardDriver, Header *header, bool toAircraft);\n}\n}\n#endif\n#endif\n\n'mav_dji_ros_interface/dji_sdk_lib/src/DJI_Logging.cpp'\n:\n\n#include \"dji_sdk_lib/DJI_Logging.h\"\n#include \"dji_sdk_lib/DJI_API.h\"\n#include \"dji_sdk_lib/DJI_Link.h\"\n#include \"dji_sdk_lib/DJI_Type.h\"\n#ifdef API_TRACE_DATA\n#include <pthread.h>\n\nnamespace DJI {\nnamespace onboardSDK {\n\npthread_mutex_t _logging_lock = PTHREAD_MUTEX_INITIALIZER;\n\nvoid printFrame(HardDriver *serialDevice, Header *header, bool onboardToAircraft) {\n    pthread_mutex_lock(&_logging_lock);\n\n  uint32_t *crc32 = (uint32_t *)((uint8_t *)header + header->length - 4);\n\n  if (!header->isAck) {\n    __Command *command = (__Command *)((uint8_t *)header + sizeof(Header));\n\n    if (!onboardToAircraft && command->set_id == SET_BROADCAST) {\n      pthread_mutex_unlock(&_logging_lock);\n      return;\n    }\n\n        API_LOG(serialDevice, DEBUG_LOG, \"\\n\\n\");\n        if (onboardToAircraft) {\n            API_LOG(serialDevice, DEBUG_LOG, \"|---------------------Sending To Aircraft-------------------------------------------------------------|\\n\");\n        } else {\n            API_LOG(serialDevice, DEBUG_LOG, \"|---------------------Received From Aircraft-----------------------------------------------------------|\\n\");\n        }\n\n        API_LOG(serialDevice, DEBUG_LOG,\n                \"|<---------------------Header-------------------------------->|<---CMD frame data--->|<--Tail-->|\\n\");\n        API_LOG(serialDevice, DEBUG_LOG,\n                \"|SOF |LEN |VER|SESSION|ACK|RES0|PADDING|ENC|RES1|SEQ   |CRC16 |CMD SET|CMD ID|CMD VAL|  CRC32   |\\n\");\n        API_LOG(serialDevice, DEBUG_LOG,\n                \"|0x%2X|%4d|%3d|%7d|%3d|%4d|%7d|%3d|%4d|%6d|0x%04X|  0x%02X | 0x%02X |       |0x%08X|\\n\", header->sof,\n                header->length, header->version, header->sessionID, header->isAck,\n                header->reversed0, header->padding, header->enc, header->reversed1,\n                header->sequenceNumber, header->crc, command->set_id, command->id, *crc32);\n\n        if (command->set_id == SET_ACTIVATION && command->id == 0x00) {\n\n\n\n        }\n    } else {\n        API_LOG(serialDevice, DEBUG_LOG, \"\\n\\n\");\n        if (onboardToAircraft) {\n            API_LOG(serialDevice, DEBUG_LOG, \"|---------------------Sending To Aircraft-------------------------------------------------------------|\\n\");\n        } else {\n            API_LOG(serialDevice, DEBUG_LOG, \"|---------------------Received From Aircraft-----------------------------------------------------------|\\n\");\n        }\n\n        API_LOG(serialDevice, DEBUG_LOG,\n                \"|<---------------------Header-------------------------------->|<-ACK frame data->|<--Tail-->|\\n\");\n        API_LOG(serialDevice, DEBUG_LOG,\n                \"|SOF |LEN |VER|SESSION|ACK|RES0|PADDING|ENC|RES1|SEQ   |CRC16 |      ACK VAL     |  CRC32   |\\n\");\n        API_LOG(serialDevice, DEBUG_LOG,\n                \"|0x%2X|%4d|%3d|%7d|%3d|%4d|%7d|%3d|%4d|%6d|0x%04X|      ACK VAL     |0x%08X|\\n\", header->sof,\n                header->length, header->version, header->sessionID, header->isAck,\n                header->reversed0, header->padding, header->enc, header->reversed1,\n                header->sequenceNumber, header->crc, *crc32);\n    }\n    pthread_mutex_unlock(&_logging_lock);\n}\n}\n}\n#endif\n\n'mav_dji_ros_interface/dji_sdk_lib/include/dji_sdk_lib/DJI_Type.h'\n:\n\n\n\n#ifndef DJI_TYPE\n#define DJI_TYPE\n\n#include \"DJI_Config.h\"\n#include \"DJICommonType.h\"\n#include <stdio.h>\n#include <exception>\n#include <stdexcept>\n\n#define NAME(x) #x\n\n\n#ifdef __GNUC__\n#define __UNUSED __attribute__((__unused__))\n#define __DELETE(x) delete (char *) x\n#else\n#define __UNUSED\n#define __DELETE(x) delete x\n\n\n\n#ifndef STM32\n#pragma warning(disable : 4100)\n#pragma warning(disable : 4800)\n#pragma warning(disable : 4996)\n#pragma warning(disable : 4244)\n#pragma warning(disable : 4267)\n#pragma warning(disable : 4700)\n#pragma warning(disable : 4101)\n#endif\n#endif\n\n#ifdef WIN32\n#define __func__ __FUNCTION__\n#endif\n\n\n\n#define API_LOG(driver, title, fmt, ...)                                  \\\n  if ((title))                                                            \\\n  {                                                                       \\\n    int len = (sprintf(DJI::onboardSDK::buffer, \"%s %s,line %d: \" fmt,    \\\n        (title) ? (title) : \"NONE\", __func__, __LINE__, ##__VA_ARGS__));  \\\n    if ((len != -1) && (len < 1024))                                      \\\n      (driver)->displayLog();                                             \\\n    else                                                                  \\\n      (driver)->displayLog(\"ERROR: log printer inner fault\\n\");           \\\n  }\n\n#ifdef API_TRACE_DATA\n#define TRACE_LOG \"TRACE\"\n#else\n#define TRACE_LOG 0\n#endif\n\n#ifdef API_DEBUG_DATA\n#define DEBUG_LOG \"DEBUG\"\n#else\n#define DEBUG_LOG 0\n#endif\n\n#ifdef API_ERROR_DATA\n#define ERROR_LOG \"ERROR\"\n#else\n#define ERROR_LOG 0\n#endif\n\n#ifdef API_BUFFER_DATA\n#define BUFFER_LOG \"BUFFER\"\n#else\n#define BUFFER_LOG 0\n#endif\n\n#ifdef API_STATUS_DATA\n#define STATUS_LOG \"STATUS\"\n#else\n#define STATUS_LOG 0\n#endif\n\n#ifdef API_MISSION_DATA\n#define MISSION_LOG \"MISSION\"\n#else\n#define MISSION_LOG 0\n#endif\n\n#ifdef API_RTK_DEBUG\n#define RTK_LOG \"MISSION\"\n#else\n#define RTK_LOG 0\n#endif\n\n\n#ifdef ARMCC\n#pragma anon_unions\n#endif\n\nnamespace DJI\n{\nnamespace onboardSDK\n{\n\nconst size_t bufsize = 1024;\nextern char buffer[];\nextern uint8_t encrypt;\n\nconst size_t SESSION_TABLE_NUM = 32;\nconst size_t CALLBACK_LIST_NUM = 10;\n\n\nconst size_t MAX_ACK_SIZE = 107;\n\n\nclass CoreAPI;\n\n\ntypedef struct Header\n{\n  unsigned int sof : 8;\n  unsigned int length : 10;\n  unsigned int version : 6;\n  unsigned int sessionID : 5;\n  unsigned int isAck : 1;\n\n  unsigned int reversed0 : 2;\n\n  unsigned int padding : 5;\n  unsigned int enc : 3;\n\n  unsigned int reversed1 : 24;\n\n  unsigned int sequenceNumber : 16;\n  unsigned int crc : 16;\n} Header;\n\n\ntypedef void (*CallBack)(DJI::onboardSDK::CoreAPI *, Header *, UserData);\n\n\ntypedef struct CallBackHandler\n{\n  CallBack callback;\n  UserData userData;\n} CallBackHandler;\n\ntypedef struct Command\n{\n  unsigned short sessionMode : 2;\n  unsigned short encrypt : 1;\n  unsigned short retry : 13;\n  unsigned short timeout;\n  size_t length;\n  uint8_t *buf;\n  CallBack handler;\n  UserData userData;\n} Command;\n\n\ntypedef struct SDKFilter\n{\n  unsigned short reuseIndex;\n  unsigned short reuseCount;\n  unsigned short recvIndex;\n  unsigned char recvBuf[BUFFER_SIZE];\n\n  unsigned char sdkKey[32];\n  unsigned char encode;\n} SDKFilter;\n\n\ntypedef struct MMU_Tab\n{\n  unsigned int tabIndex : 8;\n  unsigned int usageFlag : 8;\n  unsigned int memSize : 16;\n  unsigned char *pmem;\n} MMU_Tab;\n\ntypedef struct CMDSession\n{\n  uint32_t sessionID : 5;\n  uint32_t usageFlag : 1;\n  uint32_t sent : 5;\n  uint32_t retry : 5;\n  uint32_t timeout : 16;\n  MMU_Tab *mmu;\n  CallBack handler;\n  UserData userData;\n  uint32_t preSeqNum;\n  time_ms preTimestamp;\n} CMDSession;\n\ntypedef struct ACKSession\n{\n  uint32_t sessionID : 5;\n  uint32_t sessionStatus : 2;\n  uint32_t res : 25;\n  MMU_Tab *mmu;\n} ACKSession;\n\ntypedef struct Ack\n{\n  uint16_t sessionID : 8;\n  uint16_t encrypt : 8;\n  uint16_t seqNum;\n  uint32_t length;\n  uint8_t *buf;\n} Ack;\n\n#pragma pack(1)\n\ntypedef uint8_t BatteryData;\n\n\ntypedef struct GimbalAngleData\n{\n  int16_t yaw;\n  int16_t roll;\n  int16_t pitch;\n  uint8_t mode;\n  uint8_t duration;\n} GimbalAngleData;\n\ntypedef struct GimbalSpeedData\n{\n  int16_t yaw;\n  int16_t roll;\n  int16_t pitch;\n  uint8_t reserved;\n} GimbalSpeedData;\n\ntypedef float float32_t;\ntypedef double float64_t;\n\n\ntypedef struct HotPointData\n{\n  uint8_t version;\n\n  float64_t latitude;\n  float64_t longitude;\n  float64_t height;\n\n  float64_t radius;\n  float32_t yawRate;\n\n  uint8_t clockwise;\n  uint8_t startPoint;\n  uint8_t yawMode;\n  uint8_t reserved[11];\n} HotPointData;\n\n\ntypedef struct WayPointInitData\n{\n  uint8_t indexNumber;\n  float32_t maxVelocity;\n  float32_t idleVelocity;\n\n  uint8_t finishAction;\n  uint8_t executiveTimes;\n  uint8_t yawMode;\n  uint8_t traceMode;\n  uint8_t RCLostAction;\n  uint8_t gimbalPitch;\n  float64_t latitude;\n  float64_t longitude;\n  float32_t altitude;\n\n  uint8_t reserved[16];\n} WayPointInitData;\n\ntypedef struct WayPointData\n{\n  uint8_t index;\n\n  float64_t latitude;\n  float64_t longitude;\n  float32_t altitude;\n  float32_t damping;\n\n  int16_t yaw;\n  int16_t gimbalPitch;\n  uint8_t turnMode;\n\n  uint8_t reserved[8];\n  uint8_t hasAction;\n  uint16_t actionTimeLimit;\n\n  uint8_t actionNumber : 4;\n  uint8_t actionRepeat : 4;\n\n  uint8_t commandList[16];\n  int16_t commandParameter[16];\n} WayPointData;\n\n\n\ntypedef uint8_t MissionACK;\ntypedef uint16_t SimpleACK;\n\ntypedef struct HotPointStartACK\n{\n  uint8_t ack;\n  float32_t maxRadius;\n} HotpointStartACK;\n\ntypedef struct WayPointInitACK\n{\n  uint8_t ack;\n  WayPointInitData data;\n} WayPointInitACK;\n\ntypedef struct WayPointDataACK\n{\n  uint8_t ack;\n  uint8_t index;\n  WayPointData data;\n} WayPointDataACK;\n\ntypedef struct WayPointVelocityACK\n{\n  uint8_t ack;\n  float32_t idleVelocity;\n} WayPointVelocityACK;\n\n\ntypedef struct HotPointReadACK\n{\n  MissionACK ack;\n  HotPointData data;\n} HotpointReadACK;\n\ntypedef struct DroneVersionACK\n{\n  unsigned char ack[MAX_ACK_SIZE];\n} DroneVersionACK;\n\ntypedef union MissionACKUnion\n{\n  uint8_t raw_ack_array[MAX_ACK_SIZE];\n  DroneVersionACK droneVersion;\n  MissionACK missionACK;\n\n  SimpleACK simpleACK;\n\n  HotPointStartACK hotpointStartACK;\n\n\n\n  HotpointReadACK hotpointReadACK;\n\n\n\n  WayPointInitACK waypointInitACK;\n\n\n\n  WayPointDataACK waypointDataACK;\n\n  WayPointVelocityACK waypointVelocityACK;\n} MissionACKUnion;\n\ntypedef struct QuaternionData\n{\n  float32_t q0;\n  float32_t q1;\n  float32_t q2;\n  float32_t q3;\n} QuaternionData;\n\n\ntypedef struct CommonData\n{\n  float32_t x;\n  float32_t y;\n  float32_t z;\n} CommonData;\n\n\n\ntypedef struct Vector3fData\n{\n  float32_t x;\n  float32_t y;\n  float32_t z;\n} Vector3fData;\n\ntypedef struct VelocityData\n{\n  float32_t x;\n  float32_t y;\n  float32_t z;\n  uint8_t health : 1;\n  uint8_t sensorID : 4;\n  uint8_t reserve : 3;\n} VelocityData;\n\ntypedef struct PositionData\n{\n  float64_t latitude;\n  float64_t longitude;\n\n\n\n  float32_t altitude;\n\n\n\n\n  float32_t height;\n\n  uint8_t health;\n} PositionData;\n\n\ntypedef struct RadioData\n{\n  int16_t roll;\n  int16_t pitch;\n  int16_t yaw;\n  int16_t throttle;\n  int16_t mode;\n  int16_t gear;\n} RadioData;\n\n\ntypedef struct RCData\n{\n  int16_t roll;\n  int16_t pitch;\n  int16_t yaw;\n  int16_t throttle;\n  int16_t mode;\n  int16_t gear;\n} RCData;\n\n\ntypedef struct MagnetData\n{\n  int16_t x;\n  int16_t y;\n  int16_t z;\n} MagnetData;\n\n\ntypedef struct MagData\n{\n  int16_t x;\n  int16_t y;\n  int16_t z;\n} MagData;\n\n\n\ntypedef struct GPSPositionData\n{\n  float64_t latitude;\n  float64_t longitude;\n\n  float64_t altitude;\n\n} GPSPositionData;\n\ntypedef struct CtrlInfoData\n{\n  uint8_t mode;\n\n  uint8_t deviceStatus : 3;\n  uint8_t flightStatus : 1;\n  uint8_t vrcStatus : 1;\n  uint8_t reserved : 3;\n} CtrlInfoData;\n\ntypedef struct TimeStampData\n{\n\n  uint32_t time;\n  uint32_t nanoTime;\n  uint8_t syncFlag;\n} TimeStampData;\n\ntypedef struct GimbalData\n{\n  float32_t roll;\n  float32_t pitch;\n  float32_t yaw;\n  uint8_t pitchLimit : 1;\n  uint8_t rollLimit : 1;\n  uint8_t yawLimit : 1;\n  uint8_t reserved : 5;\n} GimbalData;\n\ntypedef uint8_t FlightStatus;\n\ntypedef struct TaskData\n{\n  unsigned char cmdSequence;\n  unsigned char cmdData;\n} TaskData;\n\n\n\ntypedef struct RTKData\n{\n  uint32_t date;\n  uint32_t time;\n  float64_t longitude;\n  float64_t latitude;\n\n  float32_t Hmsl;\n\n  float32_t velocityNorth;\n  float32_t velocityEast;\n\n  float32_t velocityGround;\n\n  int16_t yaw;\n  uint8_t posFlag;\n  uint8_t yawFlag;\n\n} RTKData;\n\n\n\ntypedef struct GPSData\n{\n  uint32_t date;\n  uint32_t time;\n  int32_t longitude;\n  int32_t latitude;\n\n  int32_t Hmsl;\n\n  float32_t velocityNorth;\n  float32_t velocityEast;\n\n  float32_t velocityGround;\n\n} GPSData;\n\n#ifndef SDK_DEV\n\ntypedef struct BroadcastData\n{\n  unsigned short dataFlag;\n  TimeStampData timeStamp;\n  QuaternionData q;\n\n  CommonData a;\n  VelocityData v;\n\n  CommonData w;\n  PositionData pos;\n\n  MagnetData mag;\n  GPSData gps;\n  RTKData rtk;\n\n  RadioData rc;\n  GimbalData gimbal;\n  FlightStatus status;\n  BatteryData battery;\n  CtrlInfoData ctrlInfo;\n\n\n  uint8_t activation;\n} BroadcastData;\n#endif\n\ntypedef struct VirtualRCSetting\n{\n  uint8_t enable : 1;\n  uint8_t cutoff : 1;\n  uint8_t reserved : 6;\n} VirtualRCSetting;\n\ntypedef struct VirtualRCData\n{\n\n\n\n  uint32_t roll;\n  uint32_t pitch;\n  uint32_t throttle;\n  uint32_t yaw;\n  uint32_t gear;\n  uint32_t reserved;\n  uint32_t mode;\n  uint32_t Channel_07;\n  uint32_t Channel_08;\n  uint32_t Channel_09;\n  uint32_t Channel_10;\n  uint32_t Channel_11;\n  uint32_t Channel_12;\n  uint32_t Channel_13;\n  uint32_t Channel_14;\n  uint32_t Channel_15;\n} VirtualRCData;\n\ntypedef struct ActivateData\n{\n  unsigned int ID;\n  unsigned int reserved;\n  unsigned int version;\n  unsigned char iosID[32];\n  char *encKey;\n} ActivateData;\n\n\n\ntypedef struct VersionData\n{\n  unsigned short version_ack;\n  unsigned int version_crc;\n  char hw_serial_num[16];\n  char hwVersion[12];\n  DJI::onboardSDK::Version fwVersion;\n\n\n  char version_name[32];\n} VersionData;\n\n\n#pragma pack()\n#ifdef SDK_DEV\n#include \"devtype.h\"\n#endif\n}\n}\n\n#define PRO_PURE_DATA_MAX_SIZE 1007\nconst size_t MMU_TABLE_NUM = 32;\n\n\n#endif\n",
        "gt": [
            "'mav_dji_ros_interface/dji_sdk_lib/include/dji_sdk_lib/DJI_Config.h'",
            "'mav_dji_ros_interface/dji_sdk_lib/include/dji_sdk_lib/DJI_Type.h'",
            "'mav_dji_ros_interface/dji_sdk_lib/include/dji_sdk_lib/DJI_Logging.h'",
            "'mav_dji_ros_interface/dji_sdk_lib/src/DJI_Logging.cpp'"
        ]
    },
    {
        "files": [
            "'LearnVulkan/third_party/glm/glm/glm.hpp'",
            "'LearnVulkan/third_party/glm/glm/integer.hpp'",
            "'LearnVulkan/third_party/glm/glm/detail/glm.cpp'"
        ],
        "content": "'LearnVulkan/third_party/glm/glm/glm.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"detail/_fixes.hpp\"\n\n#include \"detail/setup.hpp\"\n\n#pragma once\n\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <limits>\n#include <cassert>\n#include \"fwd.hpp\"\n\n#include \"vec2.hpp\"\n#include \"vec3.hpp\"\n#include \"vec4.hpp\"\n#include \"mat2x2.hpp\"\n#include \"mat2x3.hpp\"\n#include \"mat2x4.hpp\"\n#include \"mat3x2.hpp\"\n#include \"mat3x3.hpp\"\n#include \"mat3x4.hpp\"\n#include \"mat4x2.hpp\"\n#include \"mat4x3.hpp\"\n#include \"mat4x4.hpp\"\n\n#include \"trigonometric.hpp\"\n#include \"exponential.hpp\"\n#include \"common.hpp\"\n#include \"packing.hpp\"\n#include \"geometric.hpp\"\n#include \"matrix.hpp\"\n#include \"vector_relational.hpp\"\n#include \"integer.hpp\"\n\n'LearnVulkan/third_party/glm/glm/integer.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n#include \"detail/qualifier.hpp\"\n#include \"common.hpp\"\n#include \"vector_relational.hpp\"\n\nnamespace glm\n{\n\n\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t L, qualifier Q>\n\tGLM_FUNC_DECL vec<L, uint, Q> uaddCarry(\n\t\tvec<L, uint, Q> const& x,\n\t\tvec<L, uint, Q> const& y,\n\t\tvec<L, uint, Q> & carry);\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t L, qualifier Q>\n\tGLM_FUNC_DECL vec<L, uint, Q> usubBorrow(\n\t\tvec<L, uint, Q> const& x,\n\t\tvec<L, uint, Q> const& y,\n\t\tvec<L, uint, Q> & borrow);\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t L, qualifier Q>\n\tGLM_FUNC_DECL void umulExtended(\n\t\tvec<L, uint, Q> const& x,\n\t\tvec<L, uint, Q> const& y,\n\t\tvec<L, uint, Q> & msb,\n\t\tvec<L, uint, Q> & lsb);\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t L, qualifier Q>\n\tGLM_FUNC_DECL void imulExtended(\n\t\tvec<L, int, Q> const& x,\n\t\tvec<L, int, Q> const& y,\n\t\tvec<L, int, Q> & msb,\n\t\tvec<L, int, Q> & lsb);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, T, Q> bitfieldExtract(\n\t\tvec<L, T, Q> const& Value,\n\t\tint Offset,\n\t\tint Bits);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, T, Q> bitfieldInsert(\n\t\tvec<L, T, Q> const& Base,\n\t\tvec<L, T, Q> const& Insert,\n\t\tint Offset,\n\t\tint Bits);\n\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v);\n\n\n\n\n\n\n\n\ttemplate<typename genType>\n\tGLM_FUNC_DECL int bitCount(genType v);\n\n\n\n\n\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, int, Q> bitCount(vec<L, T, Q> const& v);\n\n\n\n\n\n\n\n\n\n\ttemplate<typename genIUType>\n\tGLM_FUNC_DECL int findLSB(genIUType x);\n\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, int, Q> findLSB(vec<L, T, Q> const& v);\n\n\n\n\n\n\n\n\n\n\n\ttemplate<typename genIUType>\n\tGLM_FUNC_DECL int findMSB(genIUType x);\n\n\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t L, typename T, qualifier Q>\n\tGLM_FUNC_DECL vec<L, int, Q> findMSB(vec<L, T, Q> const& v);\n\n\n}\n\n#include \"detail/func_integer.inl\"\n\n'LearnVulkan/third_party/glm/glm/detail/glm.cpp'\n:\n\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, highp>;\ntemplate struct vec<4, int32, highp>;\ntemplate struct vec<4, int64, highp>;\ntemplate struct vec<4, float32, highp>;\ntemplate struct vec<4, float64, highp>;\n\n\ntemplate struct mat<2, 2, float32, lowp>;\ntemplate struct mat<2, 2, float64, lowp>;\n\ntemplate struct mat<2, 2, float32, mediump>;\ntemplate struct mat<2, 2, float64, mediump>;\n\ntemplate struct mat<2, 2, float32, highp>;\ntemplate struct mat<2, 2, float64, highp>;\n\n\ntemplate struct mat<2, 3, float32, lowp>;\ntemplate struct mat<2, 3, float64, lowp>;\n\ntemplate struct mat<2, 3, float32, mediump>;\ntemplate struct mat<2, 3, float64, mediump>;\n\ntemplate struct mat<2, 3, float32, highp>;\ntemplate struct mat<2, 3, float64, highp>;\n\n\ntemplate struct mat<2, 4, float32, lowp>;\ntemplate struct mat<2, 4, float64, lowp>;\n\ntemplate struct mat<2, 4, float32, mediump>;\ntemplate struct mat<2, 4, float64, mediump>;\n\ntemplate struct mat<2, 4, float32, highp>;\ntemplate struct mat<2, 4, float64, highp>;\n\n\ntemplate struct mat<3, 2, float32, lowp>;\ntemplate struct mat<3, 2, float64, lowp>;\n\ntemplate struct mat<3, 2, float32, mediump>;\ntemplate struct mat<3, 2, float64, mediump>;\n\ntemplate struct mat<3, 2, float32, highp>;\ntemplate struct mat<3, 2, float64, highp>;\n\n\ntemplate struct mat<3, 3, float32, lowp>;\ntemplate struct mat<3, 3, float64, lowp>;\n\ntemplate struct mat<3, 3, float32, mediump>;\ntemplate struct mat<3, 3, float64, mediump>;\n\ntemplate struct mat<3, 3, float32, highp>;\ntemplate struct mat<3, 3, float64, highp>;\n\n\ntemplate struct mat<3, 4, float32, lowp>;\ntemplate struct mat<3, 4, float64, lowp>;\n\ntemplate struct mat<3, 4, float32, mediump>;\ntemplate struct mat<3, 4, float64, mediump>;\n\ntemplate struct mat<3, 4, float32, highp>;\ntemplate struct mat<3, 4, float64, highp>;\n\n\ntemplate struct mat<4, 2, float32, lowp>;\ntemplate struct mat<4, 2, float64, lowp>;\n\ntemplate struct mat<4, 2, float32, mediump>;\ntemplate struct mat<4, 2, float64, mediump>;\n\ntemplate struct mat<4, 2, float32, highp>;\ntemplate struct mat<4, 2, float64, highp>;\n\n\ntemplate struct mat<4, 3, float32, lowp>;\ntemplate struct mat<4, 3, float64, lowp>;\n\ntemplate struct mat<4, 3, float32, mediump>;\ntemplate struct mat<4, 3, float64, mediump>;\n\ntemplate struct mat<4, 3, float32, highp>;\ntemplate struct mat<4, 3, float64, highp>;\n\n\ntemplate struct mat<4, 4, float32, lowp>;\ntemplate struct mat<4, 4, float64, lowp>;\n\ntemplate struct mat<4, 4, float32, mediump>;\ntemplate struct mat<4, 4, float64, mediump>;\n\ntemplate struct mat<4, 4, float32, highp>;\ntemplate struct mat<4, 4, float64, highp>;\n\n\ntemplate struct qua<float32, lowp>;\ntemplate struct qua<float64, lowp>;\n\ntemplate struct qua<float32, mediump>;\ntemplate struct qua<float64, mediump>;\n\ntemplate struct qua<float32, highp>;\ntemplate struct qua<float64, highp>;\n\n\ntemplate struct tdualquat<float32, lowp>;\ntemplate struct tdualquat<float64, lowp>;\n\ntemplate struct tdualquat<float32, mediump>;\ntemplate struct tdualquat<float64, mediump>;\n\ntemplate struct tdualquat<float32, highp>;\ntemplate struct tdualquat<float64, highp>;\n\n}\n\n",
        "gt": [
            "'LearnVulkan/third_party/glm/glm/integer.hpp'",
            "'LearnVulkan/third_party/glm/glm/glm.hpp'",
            "'LearnVulkan/third_party/glm/glm/detail/glm.cpp'"
        ]
    },
    {
        "files": [
            "'gamma/third_party/scann-1.2.1/scann/projection/projection_factory.h'",
            "'gamma/third_party/scann-1.2.1/scann/partitioning/partitioner_factory_base.h'",
            "'gamma/third_party/scann-1.2.1/scann/partitioning/partitioner_factory.h'"
        ],
        "content": "'gamma/third_party/scann-1.2.1/scann/projection/projection_factory.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SCANN_PROJECTION_PROJECTION_FACTORY_H_\n#define SCANN_PROJECTION_PROJECTION_FACTORY_H_\n\n#include <cstdint>\n\n#include \"scann/data_format/dataset.h\"\n#include \"scann/projection/chunking_projection.h\"\n#include \"scann/projection/projection_base.h\"\n#include \"scann/proto/projection.pb.h\"\n\nnamespace research_scann {\n\ntemplate <typename T>\nclass ProjectionFactoryImpl {\n public:\n  static StatusOr<unique_ptr<Projection<T>>> Create(\n      const ProjectionConfig& config, const TypedDataset<T>* dataset,\n      int32_t seed_offset);\n};\n\ntemplate <typename T>\nStatusOr<unique_ptr<Projection<T>>> ProjectionFactory(\n    const ProjectionConfig& config, const TypedDataset<T>* dataset = nullptr,\n    int32_t seed_offset = 0) {\n  return ProjectionFactoryImpl<T>::Create(config, dataset, seed_offset);\n}\n\ntemplate <typename T>\nStatusOr<unique_ptr<Projection<T>>> ProjectionFactory(\n    const ProjectionConfig& config, int32_t seed_offset) {\n  return ProjectionFactoryImpl<T>::Create(config, nullptr, seed_offset);\n}\n\ntemplate <typename T>\ninline StatusOr<unique_ptr<ChunkingProjection<T>>> ChunkingProjectionFactory(\n    const ProjectionConfig& config, const TypedDataset<T>* dataset = nullptr,\n    int32_t seed_offset = 0) {\n  unique_ptr<Projection<T>> initial_projection;\n  switch (config.projection_type()) {\n    case ProjectionConfig::CHUNK:\n    case ProjectionConfig::VARIABLE_CHUNK:\n    case ProjectionConfig::IDENTITY_CHUNK:\n      break;\n    default: {\n      TF_ASSIGN_OR_RETURN(initial_projection,\n                          ProjectionFactory<T>(config, dataset, seed_offset));\n      break;\n    }\n  }\n\n  return ChunkingProjection<T>::BuildFromConfig(config,\n                                                std::move(initial_projection));\n}\n\nSCANN_INSTANTIATE_TYPED_CLASS(extern, ProjectionFactoryImpl);\n\n}\n\n#endif\n\n'gamma/third_party/scann-1.2.1/scann/partitioning/partitioner_factory_base.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SCANN_PARTITIONING_PARTITIONER_FACTORY_BASE_H_\n#define SCANN_PARTITIONING_PARTITIONER_FACTORY_BASE_H_\n\n#include \"scann/data_format/dataset.h\"\n#include \"scann/partitioning/kmeans_tree_partitioner_utils.h\"\n#include \"scann/partitioning/partitioner_base.h\"\n#include \"scann/partitioning/projecting_decorator.h\"\n#include \"scann/projection/projection_base.h\"\n#include \"scann/projection/projection_factory.h\"\n#include \"scann/proto/partitioning.pb.h\"\n#include \"scann/utils/types.h\"\n#include \"scann/utils/util_functions.h\"\n\nnamespace research_scann {\n\ntemplate <typename T>\nStatusOr<unique_ptr<Partitioner<T>>> PartitionerFactory(\n    const TypedDataset<T>* dataset, const PartitioningConfig& config,\n    shared_ptr<ThreadPool> pool = nullptr);\n\ntemplate <typename T>\nStatusOr<unique_ptr<Partitioner<T>>> PartitionerFactoryPreSampledAndProjected(\n    const TypedDataset<T>* dataset, const PartitioningConfig& config,\n    shared_ptr<ThreadPool> training_parallelization_pool = nullptr);\n\ntemplate <typename T, typename ProjectionType = double>\nunique_ptr<Partitioner<T>> MakeProjectingDecorator(\n    shared_ptr<const Projection<T>> projection,\n    unique_ptr<Partitioner<ProjectionType>> partitioner) {\n  Partitioner<T>* result;\n  if (dynamic_cast<KMeansTreeLikePartitioner<ProjectionType>*>(\n          partitioner.get())) {\n    result = new KMeansTreeProjectingDecorator<T, ProjectionType>(\n        std::move(projection),\n        absl::WrapUnique(down_cast<KMeansTreeLikePartitioner<ProjectionType>*>(\n            partitioner.release())));\n  } else {\n    result = new GenericProjectingDecorator<T, ProjectionType>(\n        std::move(projection), std::move(partitioner));\n  }\n  return absl::WrapUnique(result);\n}\n\n#define SCANN_INSTANTIATE_PARTITIONER_FACTORY(extern_or_nothing, type)     \\\n  extern_or_nothing template StatusOr<unique_ptr<Partitioner<type>>>       \\\n  PartitionerFactory<type>(                                                \\\n      const TypedDataset<type>* dataset, const PartitioningConfig& config, \\\n      shared_ptr<ThreadPool> training_parallelization_pool);               \\\n  extern_or_nothing template StatusOr<unique_ptr<Partitioner<type>>>       \\\n  PartitionerFactoryPreSampledAndProjected<type>(                          \\\n      const TypedDataset<type>* dataset, const PartitioningConfig& config, \\\n      shared_ptr<ThreadPool> training_parallelization_pool);\n\nSCANN_INSTANTIATE_PARTITIONER_FACTORY(extern, int8_t);\nSCANN_INSTANTIATE_PARTITIONER_FACTORY(extern, uint8_t);\nSCANN_INSTANTIATE_PARTITIONER_FACTORY(extern, int16_t);\nSCANN_INSTANTIATE_PARTITIONER_FACTORY(extern, uint16_t);\nSCANN_INSTANTIATE_PARTITIONER_FACTORY(extern, int32_t);\nSCANN_INSTANTIATE_PARTITIONER_FACTORY(extern, uint32_t);\nSCANN_INSTANTIATE_PARTITIONER_FACTORY(extern, int64_t);\nSCANN_INSTANTIATE_PARTITIONER_FACTORY(extern, uint64_t);\nSCANN_INSTANTIATE_PARTITIONER_FACTORY(extern, float);\nSCANN_INSTANTIATE_PARTITIONER_FACTORY(extern, double);\n\n}\n\n#endif\n\n'gamma/third_party/scann-1.2.1/scann/partitioning/partitioner_factory.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SCANN_PARTITIONING_PARTITIONER_FACTORY_H_\n#define SCANN_PARTITIONING_PARTITIONER_FACTORY_H_\n\n#include <cstdint>\n#include <memory>\n\n#include \"scann/data_format/dataset.h\"\n#include \"scann/partitioning/partitioner.pb.h\"\n#include \"scann/partitioning/partitioner_base.h\"\n#include \"scann/partitioning/partitioner_factory_base.h\"\n#include \"scann/proto/partitioning.pb.h\"\n#include \"scann/trees/kmeans_tree/kmeans_tree.h\"\n#include \"scann/utils/types.h\"\n#include \"scann/utils/util_functions.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n\nnamespace research_scann {\n\ntemplate <typename T>\nStatusOr<unique_ptr<Partitioner<T>>> PartitionerFromSerialized(\n    const SerializedPartitioner& proto, const PartitioningConfig& config,\n    int32_t projection_seed_offset = 0);\n\ntemplate <typename T>\nStatusOr<unique_ptr<Partitioner<T>>> PartitionerFromSerialized(\n    const std::string& serialized, const PartitioningConfig& config,\n    int32_t projection_seed_offset = 0);\n\ntemplate <typename T>\nStatusOr<unique_ptr<Partitioner<T>>> PartitionerFromKMeansTree(\n    shared_ptr<const KMeansTree> kmeans_tree, const PartitioningConfig& config);\n\ntemplate <typename T>\nStatusOr<unique_ptr<Partitioner<T>>> LoadSinglePartitioner(\n    const PartitioningConfig& config, int32_t epoch,\n    int32_t projection_seed_offset = 0);\n\ntemplate <typename T>\nStatusOr<std::shared_ptr<const Partitioner<T>>> LoadSinglePartitionerWithCache(\n    const PartitioningConfig& config, int32_t epoch = 0);\n\ntemplate <typename T>\nStatusOr<std::shared_ptr<const Partitioner<T>>>\nPartitionerFromSerializedWithCache(\n    const SerializedPartitioner& serialized_partitioner,\n    const PartitioningConfig& config);\n\nStatusOr<SerializedPartitioner> ReadSerializedPartitioner(\n    const PartitioningConfig& config, int32_t epoch = 0);\n\ntemplate <typename T>\nStatusOr<unique_ptr<Partitioner<T>>> PartitionerFromSerializedImpl(\n    const SerializedPartitioner& proto, const PartitioningConfig& config);\n\ntemplate <typename T>\nStatusOr<unique_ptr<Partitioner<T>>> PartitionerFromSerialized(\n    const std::string& serialized, const PartitioningConfig& config,\n    int32_t projection_seed_offset) {\n  SerializedPartitioner proto;\n  if (!proto.ParseFromString(serialized)) {\n    return InvalidArgumentError(\n        \"Could not parse serialized Partitioner proto.\");\n  }\n  return PartitionerFromSerialized<T>(proto, config, projection_seed_offset);\n}\n\nStatusOr<std::string> CanonicalizePartitionerFilename(\n    const PartitioningConfig& config, int32_t epoch = 0);\n\ntemplate <typename T>\nStatusOr<unique_ptr<Partitioner<T>>> LoadSinglePartitioner(\n    const PartitioningConfig& config, int32_t epoch,\n    int32_t projection_seed_offset) {\n  TF_ASSIGN_OR_RETURN(SerializedPartitioner sp,\n                      ReadSerializedPartitioner(config));\n  return PartitionerFromSerialized<T>(sp, config, projection_seed_offset);\n}\n\n#define SCANN_INSTANTIATE_SERIALIZED_PARTITIONER_FACTORY(extern_or_nothing, \\\n                                                         type)              \\\n  extern_or_nothing template StatusOr<unique_ptr<Partitioner<type>>>        \\\n  PartitionerFromSerialized<type>(const SerializedPartitioner& proto,       \\\n                                  const PartitioningConfig& config,         \\\n                                  int32_t projection_seed_offset);          \\\n  extern_or_nothing template StatusOr<unique_ptr<Partitioner<type>>>        \\\n  PartitionerFromKMeansTree<type>(                                          \\\n      std::shared_ptr<const KMeansTree> kmeans_tree,                        \\\n      const PartitioningConfig& config);\n\nSCANN_INSTANTIATE_SERIALIZED_PARTITIONER_FACTORY(extern, int8_t);\nSCANN_INSTANTIATE_SERIALIZED_PARTITIONER_FACTORY(extern, uint8_t);\nSCANN_INSTANTIATE_SERIALIZED_PARTITIONER_FACTORY(extern, int16_t);\nSCANN_INSTANTIATE_SERIALIZED_PARTITIONER_FACTORY(extern, uint16_t);\nSCANN_INSTANTIATE_SERIALIZED_PARTITIONER_FACTORY(extern, int32_t);\nSCANN_INSTANTIATE_SERIALIZED_PARTITIONER_FACTORY(extern, uint32_t);\nSCANN_INSTANTIATE_SERIALIZED_PARTITIONER_FACTORY(extern, int64_t);\nSCANN_INSTANTIATE_SERIALIZED_PARTITIONER_FACTORY(extern, uint64_t);\nSCANN_INSTANTIATE_SERIALIZED_PARTITIONER_FACTORY(extern, float);\nSCANN_INSTANTIATE_SERIALIZED_PARTITIONER_FACTORY(extern, double);\n\n}\n\n#endif\n",
        "gt": [
            "'gamma/third_party/scann-1.2.1/scann/projection/projection_factory.h'",
            "'gamma/third_party/scann-1.2.1/scann/partitioning/partitioner_factory_base.h'",
            "'gamma/third_party/scann-1.2.1/scann/partitioning/partitioner_factory.h'"
        ]
    },
    {
        "files": [
            "'svaba/src/SGA/Algorithm/ClusterProcess.h'",
            "'svaba/src/SGA/Algorithm/ReadCluster.h'",
            "'svaba/src/SGA/Algorithm/ClusterProcess.cpp'",
            "'svaba/src/svaba/svabaOverlapAlgorithm.h'"
        ],
        "content": "'svaba/src/SGA/Algorithm/ClusterProcess.h'\n:\n\n\n\n\n\n\n\n#ifndef CLUSTERPROCESS_H\n#define CLUSTERPROCESS_H\n\n#include \"Util.h\"\n#include \"OverlapAlgorithm.h\"\n#include \"SequenceProcessFramework.h\"\n#include \"BitVector.h\"\n#include \"Bigraph.h\"\n#include \"SGUtil.h\"\n#include \"ReadCluster.h\"\n#include \"ClusterReader.h\"\n\nstruct ClusterParameters\n{\n    const OverlapAlgorithm* pOverlapper;\n    int minOverlap;\n    size_t maxClusterSize;\n    int maxIterations;\n    BitVector* pMarkedReads;\n    const std::set<std::string>* pLimitKmers;\n    size_t limitK;\n};\n\nstruct ClusterResult\n{\n    std::vector<ClusterNode> clusterNodes;\n};\n\n\nclass ClusterProcess\n{\n    public:\n        ClusterProcess(ClusterParameters params);\n        ~ClusterProcess();\n\n\n        ClusterResult process(const SequenceWorkItem& item);\n\n\n        ClusterResult process(const ClusterVector& inSequences);\n\n    private:\n\n        ClusterParameters m_parameters;\n};\n\n\nclass ClusterPostProcess\n{\n    public:\n        ClusterPostProcess(std::ostream* pWriter, size_t minClusterSize, BitVector* pMarkedReads);\n        ~ClusterPostProcess();\n\n        void process(const SequenceWorkItem& item, const ClusterResult& result);\n        void process(const ClusterVector& inSequences , const ClusterResult& result);\n        void process(const ClusterResult& result);\n\n    private:\n        size_t m_minClusterSize;\n        size_t m_numClusters;\n        size_t m_numTotalReads;\n        size_t m_numTotalReadsClustered;\n\n        std::ostream* m_pWriter;\n        BitVector* m_pMarkedReads;\n};\n\n#endif\n\n'svaba/src/SGA/Algorithm/ReadCluster.h'\n:\n\n\n\n\n\n\n\n\n#ifndef READCLUSTER_H\n#define READCLUSTER_H\n\n#include \"Util.h\"\n#include \"OverlapAlgorithm.h\"\n\n\nstruct ClusterNode\n{\n    std::string sequence;\n    int64_t fwdCanonicalID;\n    BWTInterval interval;\n    bool isReverseInterval;\n\n    static inline bool compare(const ClusterNode& a, const ClusterNode& b)\n    {\n        return BWTInterval::compare(a.interval, b.interval);\n    }\n\n    static inline bool equal(const ClusterNode& a, const ClusterNode& b)\n    {\n        return BWTInterval::equal(a.interval, b.interval);\n    }\n};\ntypedef std::queue<ClusterNode> ClusterNodeQueue;\ntypedef std::vector<ClusterNode> ClusterNodeVector;\ntypedef std::set<int64_t> ClusterIntervalSet;\n\n\nclass ReadCluster\n{\n    public:\n\n\n        ReadCluster(const OverlapAlgorithm* pOverlapper, int minOverlap);\n\n\n\n\n        void setLimitKmers(const std::set<std::string>* pLimitKmers, size_t limitK);\n\n\n        ClusterNode addSeed(const std::string& sequence, bool bCheckInIndex);\n\n\n\n        void run(size_t max_size, int max_iterations);\n\n\n        ClusterNodeVector getOutput() const;\n\n    private:\n\n\n        bool canExtendRead(const ClusterNode& node) const;\n\n        ClusterNodeQueue m_queue;\n        const OverlapAlgorithm* m_pOverlapper;\n        int m_minOverlap;\n\n        const std::set<std::string>* m_pLimitKmers;\n        size_t m_limitK;\n\n        ClusterNodeVector m_outCluster;\n        ClusterIntervalSet m_usedIndex;\n};\n\n#endif\n\n'svaba/src/SGA/Algorithm/ClusterProcess.cpp'\n:\n\n\n\n\n\n\n\n#include \"ClusterProcess.h\"\n#include \"SGAlgorithms.h\"\n#include \"SGVisitors.h\"\n\n\nClusterProcess::ClusterProcess(ClusterParameters params) : m_parameters(params)\n{\n\n    assert(m_parameters.pOverlapper != NULL);\n    assert(m_parameters.pMarkedReads != NULL);\n    assert(m_parameters.minOverlap >= 12);\n}\n\n\nClusterProcess::~ClusterProcess()\n{\n\n\n}\n\n\nClusterResult ClusterProcess::process(const SequenceWorkItem& item)\n{\n    ReadCluster cluster(m_parameters.pOverlapper, m_parameters.minOverlap);\n    ClusterNode node = cluster.addSeed(item.read.seq.toString(), true);\n    assert(node.interval.isValid());\n\n    for(int64_t i = node.interval.lower; i <= node.interval.upper; ++i)\n    {\n        if(m_parameters.pMarkedReads->test(i))\n        {\n            ClusterResult result;\n            return result;\n        }\n    }\n\n\n    if(m_parameters.pLimitKmers != NULL)\n        cluster.setLimitKmers(m_parameters.pLimitKmers, m_parameters.limitK);\n\n\n    cluster.run(m_parameters.maxClusterSize, 0);\n\n\n\n\n    ClusterResult result;\n    result.clusterNodes = cluster.getOutput();\n\n\n\n    int64_t lowestIndex = result.clusterNodes.front().interval.lower;\n    bool currentValue = m_parameters.pMarkedReads->test(lowestIndex);\n    bool updateSuccess = false;\n\n    if(currentValue == false)\n    {\n\n\n        updateSuccess = m_parameters.pMarkedReads->updateCAS(lowestIndex, currentValue, true);\n    }\n\n    if(updateSuccess)\n    {\n\n\n\n        std::vector<ClusterNode>::const_iterator iter = result.clusterNodes.begin();\n        for(; iter != result.clusterNodes.end(); ++iter)\n        {\n            for(int64_t i = iter->interval.lower; i <= iter->interval.upper; ++i)\n            {\n                if(i == lowestIndex)\n                    continue;\n                currentValue = m_parameters.pMarkedReads->test(i);\n                if(currentValue)\n                {\n\n                    std::cout << \"Warning: Bit \" << i << \" was unexpectedly set by a different thread\\n\";\n                }\n                else\n                {\n                    m_parameters.pMarkedReads->updateCAS(i, currentValue, true);\n                }\n            }\n        }\n    }\n    else\n    {\n\n\n        result.clusterNodes.clear();\n    }\n    return result;\n}\n\n\nClusterResult ClusterProcess::process(const ClusterVector& inSequences)\n{\n    ReadCluster cluster(m_parameters.pOverlapper, m_parameters.minOverlap);\n\n\n    for(size_t i = 0; i < inSequences.size(); ++i)\n        cluster.addSeed(inSequences[i].sequence, false);\n\n\n    if(m_parameters.pLimitKmers != NULL)\n        cluster.setLimitKmers(m_parameters.pLimitKmers, m_parameters.limitK);\n\n    cluster.run(m_parameters.maxClusterSize, m_parameters.maxIterations);\n\n    ClusterResult result;\n    result.clusterNodes = cluster.getOutput();\n    return result;\n}\n\n\nClusterPostProcess::ClusterPostProcess(std::ostream* pWriter,\n                                       size_t minClusterSize,\n                                       BitVector* pMarkedReads) : m_minClusterSize(minClusterSize),\n                                                                  m_numClusters(0),\n                                                                  m_numTotalReads(0),\n                                                                  m_numTotalReadsClustered(0),\n                                                                  m_pWriter(pWriter),\n                                                                  m_pMarkedReads(pMarkedReads)\n{\n\n}\n\n\nClusterPostProcess::~ClusterPostProcess()\n{\n    printf(\"[sga cluster] Clustered %zu reads into %zu clusters (%zu total reads input)\\n\", m_numTotalReadsClustered, m_numClusters, m_numTotalReads);\n}\n\n\nvoid ClusterPostProcess::process(const SequenceWorkItem& , const ClusterResult& result)\n{\n    process(result);\n}\n\n\nvoid ClusterPostProcess::process(const ClusterVector& , const ClusterResult& result)\n{\n    process(result);\n}\n\nvoid ClusterPostProcess::process(const ClusterResult& result)\n{\n    m_numTotalReads += 1;\n\n    if(result.clusterNodes.size() > 0)\n    {\n\n        size_t clusterSize = 0;\n        for(size_t i = 0; i < result.clusterNodes.size(); ++i)\n        {\n            if(result.clusterNodes[i].interval.isValid())\n                clusterSize += result.clusterNodes[i].interval.size();\n            else\n                clusterSize += 1;\n        }\n\n        if(clusterSize >= m_minClusterSize)\n        {\n            for(size_t i = 0; i < result.clusterNodes.size(); ++i)\n                *m_pWriter << \"cluster-\" << m_numClusters << \"\\t\" << clusterSize << \"\\t\" << result.clusterNodes[i].sequence << \"\\t\" << result.clusterNodes[i].interval << \"\\n\";\n            m_numClusters += 1;\n            m_numTotalReadsClustered += clusterSize;\n        }\n    }\n}\n\n'svaba/src/svaba/svabaOverlapAlgorithm.h'\n:\n\n\n\n\n\n\n\n\n#ifndef SVABA_OVERLAPALGORITHM_H\n#define SVABA_OVERLAPALGORITHM_H\n\n#include \"SuffixTools/BWT.h\"\n#include \"OverlapBlock.h\"\n#include \"OverlapAlgorithm.h\"\n#include \"SearchSeed.h\"\n#include \"BWTAlgorithms.h\"\n#include \"Util.h\"\n\n\n\nclass svabaOverlapAlgorithm\n{\n    public:\n\n        svabaOverlapAlgorithm(const BWT* pBWT, const BWT* pRevBWT,\n                         double er, int seedLen, int seedStride,\n                         bool irrOnly, int maxSeeds = -1) : m_pBWT(pBWT),\n                                         m_pRevBWT(pRevBWT),\n                                         m_errorRate(er),\n                                         m_seedLength(seedLen),\n                                         m_seedStride(seedStride),\n                                         m_bIrreducible(irrOnly),\n                                         m_exactModeOverlap(false),\n                                         m_exactModeIrreducible(false),\n                                         m_maxSeeds(maxSeeds) {}\n\n\n\n        OverlapResult overlapRead(const SeqRecord& read, int minOverlap, OverlapBlockList* pOutList) const;\n\n\n        OverlapResult overlapReadExact(const SeqRecord& read, int minOverlap, OverlapBlockList* pOBOut) const;\n\n\n        OverlapResult alignReadDuplicate(const SeqRecord& read, OverlapBlockList* pOBOut) const;\n\n\n        OverlapResult overlapReadInexact(const SeqRecord& read, int minOverlap, OverlapBlockList* pOBOut) const;\n\n\n        void writeResultASQG(std::ostream& writer, const SeqRecord& read, const OverlapResult& result) const;\n\n\n        void writeOverlapBlocks(std::ostream& writer, size_t readIdx, bool isSubstring, const OverlapBlockList* pList) const;\n        void writeOverlapBlocks(std::stringstream& writer, size_t readIdx, bool isSubstring, const OverlapBlockList* pList) const;\n\n\n        void buildForwardHistory(OverlapBlockList* pList) const;\n\n\n        void setExactModeOverlap(bool b) { m_exactModeOverlap = b; }\n        void setExactModeIrreducible(bool b) { m_exactModeIrreducible = b; }\n\n\n        const BWT* getBWT() const { return m_pBWT; }\n        const BWT* getRBWT() const { return m_pRevBWT; }\n\n    private:\n\n\n\n        void findOverlapBlocksExact(const std::string& w, const BWT* pBWT, const BWT* pRevBWT,\n                                    const AlignFlags& af, const int minOverlap, OverlapBlockList* pOBTemp,\n                                    OverlapBlockList* pOBFinal, OverlapResult& result) const;\n\n\n        bool findOverlapBlocksInexact(const std::string& w, const BWT* pBWT, const BWT* pRevBWT,\n                                      const AlignFlags& af, const int minOverlap, OverlapBlockList* pOBList,\n                                      OverlapBlockList* pOBFinal, OverlapResult& result) const;\n\n\n        inline bool extendSeedExactRight(SearchSeed& seed, const std::string& w, const BWT* pBWT, const BWT* pRevBWT) const;\n        inline bool extendSeedExactLeft(SearchSeed& seed, const std::string& w, const BWT* pBWT, const BWT* pRevBWT) const;\n\n        inline void branchSeedRight(const SearchSeed& seed, const std::string& w, const BWT* pBWT, const BWT* pRevBWT, SearchSeedQueue* pQueue) const;\n        inline void branchSeedLeft(const SearchSeed& seed, const std::string& w, const BWT* pBWT, const BWT* pRevBWT, SearchSeedQueue* pQueue) const;\n\n\n        inline void extendSeedInexactRight(SearchSeed& seed, const std::string& w, const BWT* pBWT, const BWT* pRevBWT,\n                                           SearchSeedVector* pOutVector) const;\n\n\n        inline void extendSeedInexactLeft(SearchSeed& seed, const std::string& w, const BWT* pBWT, const BWT* pRevBWT,\n                                          SearchSeedVector* pOutVector) const;\n\n\n\n        inline void calculateSeedParameters(const std::string& w, const int minOverlap, int& seed_length, int& seed_stride) const;\n\n\n        inline int createSearchSeeds(const std::string& w, const BWT* pBWT,\n                                     const BWT* pRevBWT, int seed_length, int seed_stride,\n                                     SearchSeedVector* pOutVector) const;\n\n\n        inline void extendSeedsExactRightQueue(const std::string& w, const BWT* pBWT, const BWT* pRevBWT,\n                                                 ExtendDirection dir, const SearchSeedVector* pInVector,\n                                                 SearchSeedQueue* pOutQueue) const;\n\n\n        inline void extendSeedsExactRight(const std::string& w, const BWT* pBWT, const BWT* pRevBWT,\n                                                 ExtendDirection dir, const SearchSeedVector* pInVector,\n                                                 SearchSeedVector* pOutVector) const;\n\n\n        void terminateContainedBlocks(OverlapBlockList& containedBlocks) const;\n\n\n\n\n\n        void computeIrreducibleBlocks(const BWT* pBWT, const BWT* pRevBWT,\n                                      OverlapBlockList* pOBList, OverlapBlockList* pOBFinal) const;\n\n\n        void _processIrreducibleBlocksExact(const BWT* pBWT, const BWT* pRevBWT,\n                                            OverlapBlockList& obList, OverlapBlockList* pOBFinal) const;\n\n\n        void _processIrreducibleBlocksExactIterative(const BWT* pBWT,\n                                                     const BWT* pRevBWT,\n                                                     OverlapBlockList& inList,\n                                                     OverlapBlockList* pOBFinal) const;\n\n        void _processIrreducibleBlocksInexact(const BWT* pBWT, const BWT* pRevBWT,\n                                              OverlapBlockList& obList, OverlapBlockList* pOBFinal) const;\n\n\n        void updateOverlapBlockRangesRight(const BWT* pBWT, const BWT* pRevBWT,\n                                           OverlapBlockList& obList, char b) const;\n\n\n        void extendActiveBlocksRight(const BWT* pBWT, const BWT* pRevBWT,\n                                     OverlapBlockList& activeList,\n                                     OverlapBlockList& terminalList,\n                                     OverlapBlockList& containedList) const;\n\n        double calculateBlockErrorRate(const OverlapBlock& terminalBlock, const OverlapBlock& otherBlock) const;\n        bool isBlockSubstring(OverlapBlock& terminalBlock, const OverlapBlockList& blockList, double maxER) const;\n\n\n        const BWT* m_pBWT;\n        const BWT* m_pRevBWT;\n        double m_errorRate;\n        int m_seedLength;\n        int m_seedStride;\n        bool m_bIrreducible;\n        bool m_exactModeOverlap;\n        bool m_exactModeIrreducible;\n\n\n        int m_maxSeeds;\n};\n\n#endif\n",
        "gt": [
            "'svaba/src/svaba/svabaOverlapAlgorithm.h'",
            "'svaba/src/SGA/Algorithm/ReadCluster.h'",
            "'svaba/src/SGA/Algorithm/ClusterProcess.h'",
            "'svaba/src/SGA/Algorithm/ClusterProcess.cpp'"
        ]
    },
    {
        "files": [
            "'gmmloc/gmmloc/include/gmmloc/common/eigen_types.h'",
            "'gmmloc/gmmloc/src/visualization/visualizer.cpp'",
            "'gmmloc/gmmloc/include/gmmloc/common/common.h'"
        ],
        "content": "'gmmloc/gmmloc/include/gmmloc/common/eigen_types.h'\n:#pragma once\n\n#include <Eigen/Dense>\n\nnamespace gmmloc {\nusing scalar_t = double;\n\n\ntemplate <typename Scalar> using Vector0 = Eigen::Matrix<Scalar, 0, 1>;\n\n\ntemplate <typename Scalar> using Vector1 = Eigen::Matrix<Scalar, 1, 1>;\nusing Vector1d = Eigen::Matrix<double, 1, 1>;\nusing Vector1f = Eigen::Matrix<float, 1, 1>;\nusing Vector1i = Eigen::Matrix<int, 1, 1>;\nusing Vector1s = Eigen::Matrix<scalar_t, 1, 1>;\n\n\ntemplate <typename Scalar> using Vector2 = Eigen::Matrix<Scalar, 2, 1>;\n\nusing Eigen::Vector2d;\nusing Eigen::Vector2f;\nusing Eigen::Vector2i;\nusing Vector2s = Eigen::Matrix<scalar_t, 2, 1>;\n\n\ntemplate <typename Scalar> using Vector3 = Eigen::Matrix<Scalar, 3, 1>;\nusing Eigen::Vector3d;\nusing Eigen::Vector3f;\nusing Eigen::Vector3i;\nusing Vector3s = Eigen::Matrix<scalar_t, 3, 1>;\n\n\ntemplate <typename Scalar> using Vector4 = Eigen::Matrix<Scalar, 4, 1>;\nusing Eigen::Vector4d;\nusing Eigen::Vector4f;\nusing Eigen::Vector4i;\nusing Vector4s = Eigen::Matrix<scalar_t, 4, 1>;\n\n\ntemplate <typename Scalar> using Vector5 = Eigen::Matrix<Scalar, 5, 1>;\nusing Vector5d = Eigen::Matrix<double, 5, 1>;\nusing Vector5f = Eigen::Matrix<float, 5, 1>;\nusing Vector5i = Eigen::Matrix<int, 5, 1>;\nusing Vector5s = Eigen::Matrix<scalar_t, 5, 1>;\n\n\ntemplate <typename Scalar> using Vector6 = Eigen::Matrix<Scalar, 6, 1>;\nusing Vector6d = Eigen::Matrix<double, 6, 1>;\nusing Vector6f = Eigen::Matrix<float, 6, 1>;\nusing Vector6i = Eigen::Matrix<int, 6, 1>;\nusing Vector6s = Eigen::Matrix<scalar_t, 6, 1>;\n\n\ntemplate <typename Scalar, int Rows>\nusing Vector = Eigen::Matrix<Scalar, Rows, 1>;\n\n\ntemplate <typename Scalar>\nusing VectorX = Eigen::Matrix<Scalar, Eigen::Dynamic, 1>;\n\n\n\ntemplate <typename Scalar>\nusing VectorUpTo6 = Eigen::Matrix<Scalar, Eigen::Dynamic, 1, 0, 6, 1>;\n\n\ntemplate <typename Scalar> using RowVector2 = Eigen::Matrix<Scalar, 1, 2>;\nusing Eigen::RowVector2d;\nusing Eigen::RowVector2f;\nusing Eigen::RowVector2i;\nusing RowVector2s = Eigen::Matrix<scalar_t, 1, 2>;\n\n\ntemplate <typename Scalar> using RowVector3 = Eigen::Matrix<Scalar, 1, 3>;\nusing Eigen::RowVector3d;\nusing Eigen::RowVector3f;\nusing Eigen::RowVector3i;\nusing RowVector3s = Eigen::Matrix<scalar_t, 1, 3>;\n\n\ntemplate <typename Scalar> using RowVector4 = Eigen::Matrix<Scalar, 1, 4>;\nusing Eigen::RowVector4d;\nusing Eigen::RowVector4f;\nusing Eigen::RowVector4i;\nusing RowVector4s = Eigen::Matrix<scalar_t, 1, 4>;\n\n\ntemplate <typename Scalar> using RowVector6 = Eigen::Matrix<Scalar, 1, 6>;\nusing RowVector6d = Eigen::Matrix<double, 1, 6>;\nusing RowVector6f = Eigen::Matrix<float, 1, 6>;\nusing RowVector6i = Eigen::Matrix<int, 1, 6>;\nusing RowVector6s = Eigen::Matrix<scalar_t, 1, 6>;\n\n\ntemplate <typename Scalar, int Cols>\nusing RowVector = Eigen::Matrix<Scalar, 1, Cols>;\n\n\ntemplate <typename Scalar>\nusing RowVectorX = Eigen::Matrix<Scalar, 1, Eigen::Dynamic>;\n\n\ntemplate <typename Scalar> using Matrix2 = Eigen::Matrix<Scalar, 2, 2>;\nusing Eigen::Matrix2d;\nusing Eigen::Matrix2f;\nusing Eigen::Matrix2i;\nusing Matrix2s = Eigen::Matrix<scalar_t, 2, 2>;\n\n\ntemplate <typename Scalar> using Matrix3 = Eigen::Matrix<Scalar, 3, 3>;\nusing Eigen::Matrix3d;\nusing Eigen::Matrix3f;\nusing Eigen::Matrix3i;\nusing Matrix3s = Eigen::Matrix<scalar_t, 3, 3>;\n\n\ntemplate <typename Scalar> using Matrix4 = Eigen::Matrix<Scalar, 4, 4>;\nusing Eigen::Matrix4d;\nusing Eigen::Matrix4f;\nusing Eigen::Matrix4i;\nusing Matrix4s = Eigen::Matrix<scalar_t, 4, 4>;\n\n\ntemplate <typename Scalar> using Matrix6 = Eigen::Matrix<Scalar, 6, 6>;\nusing Matrix6d = Eigen::Matrix<double, 6, 6>;\nusing Matrix6f = Eigen::Matrix<float, 6, 6>;\nusing Matrix6i = Eigen::Matrix<int, 6, 6>;\nusing Matrix6s = Eigen::Matrix<scalar_t, 6, 6>;\n\n\ntemplate <typename Scalar>\nusing Matrix2X = Eigen::Matrix<Scalar, 2, Eigen::Dynamic>;\n\n\ntemplate <typename Scalar>\nusing Matrix3X = Eigen::Matrix<Scalar, 3, Eigen::Dynamic>;\n\n\ntemplate <typename Scalar>\nusing Matrix4X = Eigen::Matrix<Scalar, 4, Eigen::Dynamic>;\n\n\ntemplate <typename Scalar>\nusing Matrix6X = Eigen::Matrix<Scalar, 6, Eigen::Dynamic>;\n\n\ntemplate <typename Scalar>\nusing MatrixX = Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>;\n\n\n\n\ntemplate <typename Scalar>\nusing MatrixUpTo6 =\n    Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, 0, 6, 6>;\n\n\ntemplate <typename Scalar> using Quaternion = Eigen::Quaternion<Scalar>;\nusing Eigen::Quaterniond;\nusing Eigen::Quaternionf;\nusing Quaternions = Eigen::Quaternion<scalar_t>;\n\n\ntemplate <typename Scalar> using AngleAxis = Eigen::AngleAxis<Scalar>;\nusing Eigen::AngleAxisd;\nusing Eigen::AngleAxisf;\nusing AngleAxiss = Eigen::AngleAxis<scalar_t>;\n\n\ntemplate <typename Scalar>\nusing Isometry3 = Eigen::Transform<Scalar, 3, Eigen::Isometry>;\nusing Eigen::Isometry3d;\nusing Eigen::Isometry3f;\nusing Isometry3s = Eigen::Transform<scalar_t, 3, Eigen::Isometry>;\n\n\ntemplate <typename Scalar> using Translation3 = Eigen::Translation<Scalar, 3>;\n\n}\n\n'gmmloc/gmmloc/src/visualization/visualizer.cpp'\n:#include \"gmmloc/visualization/visualizer.h\"\n\n#include <thread>\n\n#include \"gmmloc/common/common.h\"\n\n#include \"gmmloc/global.h\"\n\n#include <sensor_msgs/point_cloud2_iterator.h>\n\n#include <tf2/LinearMath/Quaternion.h>\n#include <tf2_ros/transform_broadcaster.h>\n\nnamespace gmmloc {\n\nusing namespace std;\n\nTrajectoryViewer::TrajectoryViewer(const std::string &name,\n                                   ros::NodeHandle &nh) {\n  name_ = name;\n  pub_ = nh.advertise<nav_msgs::Path>(name, 1);\n\n  msg_ = nav_msgs::Path::Ptr(new nav_msgs::Path);\n\n\n  msg_->header.frame_id = \"map\";\n  msg_->header.seq = 0;\n}\n\ngeometry_msgs::PoseStamped TrajectoryViewer::pose2msg(const SE3Quat &pose) {\n\n  geometry_msgs::PoseStamped msg;\n  const auto &q = pose.rotation();\n  const auto &v = pose.translation();\n  msg.pose.orientation.w = q.w();\n  msg.pose.orientation.x = q.x();\n  msg.pose.orientation.y = q.y();\n  msg.pose.orientation.z = q.z();\n\n  msg.pose.position.x = v.x();\n  msg.pose.position.y = v.y();\n  msg.pose.position.z = v.z();\n\n  return msg;\n}\n\nvoid TrajectoryViewer::visualize(int start, int end) {\n  msg_->header.seq++;\n  msg_->header.stamp = ros::Time::now();\n\n  msg_->poses.clear();\n\n  int start_ = start;\n  int end_ = end < 0 ? traj_.size() : end;\n\n  for (int i = start_; i < end_; i++) {\n    auto msg_pose = pose2msg(*traj_[i]);\n    msg_pose.header = msg_->header;\n    msg_->poses.push_back(msg_pose);\n  }\n\n  pub_.publish(msg_);\n}\n\nViewerGMMLoc::ViewerGMMLoc(GMM::Ptr map, ros::NodeHandle &nh)\n    : stop_(false), finished_(true), nh_(nh) {\n\n  gmm_visualizer_ = GMMVisualizer::Ptr(new GMMVisualizer(map));\n\n\n  pose_viz_ = CameraPoseVisualizer::Ptr(new CameraPoseVisualizer(\n      38.0f / 255.0f, 188.0 / 255.0f, 213.0f / 255.0f, 1.0f));\n  pose_viz_->setScale(0.1);\n  pose_viz_->setLineWidth(0.01);\n\n  kf_pub_ = nh.advertise<visualization_msgs::MarkerArray>(\"keyframes\", 1);\n  mp_pub_ = nh.advertise<sensor_msgs::PointCloud2>(\"mappoints\", 1);\n\n  mappoints_ = sensor_msgs::PointCloud2::Ptr(new sensor_msgs::PointCloud2);\n  auto pcm = sensor_msgs::PointCloud2Modifier(*mappoints_);\n  pcm.setPointCloud2FieldsByString(2, \"xyz\", \"rgb\");\n\n  image_ = cv::Mat(camera::height, camera::width, CV_8UC1, cv::Scalar::all(0));\n}\n\nvoid ViewerGMMLoc::publishTrajectories() {\n  const int pub_length = 200;\n\n  int start = 0, end = 0;\n\n  std::unique_lock<mutex> lock(mutex_pose_);\n  if (traj_records_.count(\"camera\")) {\n    end = traj_records_[\"camera\"]->traj_.size();\n    start = (pub_length >= end) ? 0 : end - pub_length;\n  }\n\n  for (const auto &record : traj_records_) {\n\n    record.second->visualize(start, end);\n  }\n}\n\nvoid ViewerGMMLoc::setImage(const cv::Mat &img) {\n  unique_lock<mutex> lock(mutex_img_);\n  img.copyTo(image_);\n}\n\nvoid ViewerGMMLoc::setTransform(const Quaterniond &rot, const Vector3d &trans,\n                                const std::string &name) {\n\n  std::unique_lock<mutex> lock(mutex_pose_);\n  auto pose = SE3QuatConstPtr(new SE3Quat(rot, trans));\n\n  tf_records_[name] = pose;\n\n\n\n  if (name == \"camera\") {\n    if (!traj_records_.count(\"camera\")) {\n      traj_records_[\"camera\"] =\n          TrajectoryViewer::Ptr(new TrajectoryViewer(\"camera\", nh_));\n    }\n\n    auto &ptr = traj_records_[\"camera\"];\n\n    ptr->traj_.push_back(pose);\n  }\n}\n\nvoid ViewerGMMLoc::setTrajectory(\n    const eigen_aligned_std_vector<Quaterniond> &rot,\n    const eigen_aligned_std_vector<Vector3d> &trans, const std::string &name) {\n  std::unique_lock<mutex> lock(mutex_pose_);\n  CHECK_EQ(rot.size(), trans.size());\n\n\n  {\n    if (!traj_records_.count(name)) {\n      traj_records_[name] =\n          TrajectoryViewer::Ptr(new TrajectoryViewer(name, nh_));\n    }\n\n    auto &ptr = traj_records_[name];\n    for (size_t i = 0; i < rot.size(); i++) {\n      ptr->traj_.push_back(SE3QuatConstPtr(new SE3Quat(rot[i], trans[i])));\n    }\n  }\n}\n\nvoid ViewerGMMLoc::spin() {\n  finished_ = false;\n\n  cv::namedWindow(\"image\");\n\n  bool bFollow = true;\n  bool bLocalizationMode = false;\n\n  ros::Rate rate(30);\n\n  CHECK_NOTNULL(map_);\n  CHECK_NOTNULL(pose_viz_);\n\n  std_msgs::Header kf_header;\n  kf_header.frame_id = \"map\";\n\n  while (!stop_) {\n\n    kf_header.seq++;\n    kf_header.stamp = ros::Time::now();\n\n    mappoints_->header = kf_header;\n\n    pose_viz_->reset();\n\n    drawKeyFrames();\n\n    drawMapPoints();\n\n    mp_pub_.publish(mappoints_);\n\n    publishTrajectories();\n\n    broadcastTF();\n\n    pose_viz_->publish(kf_pub_, kf_header);\n\n    cv::Mat img;\n    {\n      unique_lock<mutex> lock(mutex_img_);\n      if (image_.channels() == 1) {\n        cv::cvtColor(image_, img, CV_GRAY2BGR);\n      } else {\n        image_.copyTo(img);\n      }\n    }\n    cv::imshow(\"image\", img);\n    switchKey(cv::waitKey(1));\n\n    rate.sleep();\n  }\n\n  finished_ = true;\n}\n\nvoid ViewerGMMLoc::switchKey(char key) {\n  switch (key) {\n  case ' ':\n    global::pause = !global::pause;\n    break;\n  case 's':\n    global::pause = true;\n    global::step = true;\n    break;\n  case 'q':\n    global::stop = true;\n    break;\n\n  default:\n    break;\n  }\n}\n\nvoid ViewerGMMLoc::drawKeyFrames() {\n  const vector<KeyFrame *> vpKFs = map_->getAllKeyFrames();\n\n  for (size_t i = 0; i < vpKFs.size(); i++) {\n    KeyFrame *kf_ptr = vpKFs[i];\n    auto Twc = kf_ptr->getTwc();\n\n    pose_viz_->addKFPose(Twc.translation(), Twc.rotation());\n  }\n\n  for (size_t i = 0; i < vpKFs.size(); i++) {\n    const vector<KeyFrame *> vCovKFs = vpKFs[i]->getCovisiblesByWeight(100);\n\n    const auto &Twc = vpKFs[i]->getTwc();\n    if (!vCovKFs.empty()) {\n      for (vector<KeyFrame *>::const_iterator vit = vCovKFs.begin(),\n                                              vend = vCovKFs.end();\n           vit != vend; vit++) {\n        if ((*vit)->idx_ < vpKFs[i]->idx_)\n          continue;\n        const auto &Twcj = vpKFs[i]->getTwc();\n        pose_viz_->addEdge(Twc.translation(), Twcj.translation());\n      }\n    }\n  }\n}\n\nvoid ViewerGMMLoc::drawMapPoints() {\n  const vector<MapPoint *> &vpMPs = map_->getAllMapPoints();\n\n  size_t map_size = 0;\n  for (auto &&mp : vpMPs) {\n    if (mp->not_valid_)\n      continue;\n\n    map_size++;\n  }\n\n  auto pcm = sensor_msgs::PointCloud2Modifier(*mappoints_);\n  pcm.resize(map_size);\n\n\n  sensor_msgs::PointCloud2Iterator<float> out_x(*mappoints_, \"x\");\n  sensor_msgs::PointCloud2Iterator<float> out_y(*mappoints_, \"y\");\n  sensor_msgs::PointCloud2Iterator<float> out_z(*mappoints_, \"z\");\n  sensor_msgs::PointCloud2Iterator<uint8_t> out_r(*mappoints_, \"r\");\n  sensor_msgs::PointCloud2Iterator<uint8_t> out_g(*mappoints_, \"g\");\n  sensor_msgs::PointCloud2Iterator<uint8_t> out_b(*mappoints_, \"b\");\n\n  for (auto &&mp : vpMPs) {\n    if (mp->not_valid_)\n      continue;\n    Vector3d pos = mp->getPosition();\n\n    *out_x = pos(0);\n    *out_y = pos(1);\n    *out_z = pos(2);\n\n    if (mp->type_ == MapPoint::FromDepthGMM) {\n      *out_r = 198, *out_g = 39, *out_b = 40;\n    } else if (mp->type_ == MapPoint::FromDepth) {\n      *out_r = 31, *out_g = 119, *out_b = 180;\n    } else if (mp->type_ == MapPoint::FromTriMonoGMM) {\n      *out_r = 198, *out_g = 39, *out_b = 40;\n    } else if (mp->type_ == MapPoint::FromTriMono) {\n      *out_r = 31, *out_g = 119, *out_b = 180;\n    } else if (mp->type_ == MapPoint::FromTriStereoGMM) {\n      *out_r = 198, *out_g = 39, *out_b = 40;\n    } else if (mp->type_ == MapPoint::FromTriStereo) {\n      *out_r = 31, *out_g = 119, *out_b = 180;\n    }\n\n    ++out_x, ++out_y, ++out_z;\n    ++out_r, ++out_g, ++out_b;\n  }\n}\n\nvoid ViewerGMMLoc::broadcastTF() {\n\n  static tf2_ros::TransformBroadcaster br;\n\n  unique_lock<std::mutex> lock(mutex_pose_);\n  for (auto &&info : tf_records_) {\n    geometry_msgs::TransformStamped transformStamped;\n\n    transformStamped.header.stamp = ros::Time::now();\n    transformStamped.header.frame_id = \"map\";\n    transformStamped.child_frame_id = info.first;\n\n    Vector3d t_w_c = info.second->translation();\n    Quaterniond rot_w_c = info.second->rotation();\n    transformStamped.transform.translation.x = t_w_c.x();\n    transformStamped.transform.translation.y = t_w_c.y();\n    transformStamped.transform.translation.z = t_w_c.z();\n\n    transformStamped.transform.rotation.x = rot_w_c.x();\n    transformStamped.transform.rotation.y = rot_w_c.y();\n    transformStamped.transform.rotation.z = rot_w_c.z();\n    transformStamped.transform.rotation.w = rot_w_c.w();\n    br.sendTransform(transformStamped);\n  }\n}\n\n}\n\n'gmmloc/gmmloc/include/gmmloc/common/common.h'\n:#pragma once\n\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <memory>\n#include <thread>\n#include <mutex>\n#include <shared_mutex>\n\n#include <chrono>\n#include <algorithm>\n#include <numeric>\n\n#include <cstdint>\n\n#include <opencv2/opencv.hpp>\n\n#include <Eigen/Dense>\n\n#include <gflags/gflags.h>\n#include <glog/logging.h>\n\n#include \"eigen_stl_types.h\"\n#include \"eigen_types.h\"\n\n#include <g2o/types/slam3d/se3quat.h>\n\nnamespace gmmloc {\n\nusing g2o::SE3Quat;\n\nusing SE3QuatPtr = std::shared_ptr<SE3Quat>;\n\nusing SE3QuatConstPtr = std::shared_ptr<const SE3Quat>;\n}",
        "gt": [
            "'gmmloc/gmmloc/include/gmmloc/common/eigen_types.h'",
            "'gmmloc/gmmloc/include/gmmloc/common/common.h'",
            "'gmmloc/gmmloc/src/visualization/visualizer.cpp'"
        ]
    },
    {
        "files": [
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/ViewableSet.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/impl/RdSet.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/SignalCookie.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/rd_core_export.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/SignalX.h'"
        ],
        "content": "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/ViewableSet.h'\n:#ifndef RD_CPP_CORE_VIEWABLESET_H\n#define RD_CPP_CORE_VIEWABLESET_H\n\n#include \"base/IViewableSet.h\"\n#include \"reactive/base/SignalX.h\"\n\n#include <std/allocator.h>\n#include <util/core_util.h>\n\nnamespace rd\n{\n\ntemplate <typename T, typename A = allocator<T>>\nclass ViewableSet : public IViewableSet<T, A>\n{\npublic:\n\tusing Event = typename IViewableSet<T>::Event;\n\n\tusing IViewableSet<T, A>::advise;\n\nprivate:\n\tusing WT = typename IViewableSet<T, A>::WT;\n\tusing WA = typename std::allocator_traits<A>::template rebind_alloc<Wrapper<T>>;\n\n\tSignal<Event> change;\n\tusing data_t = ordered_set<Wrapper<T>, wrapper::TransparentHash<T>, wrapper::TransparentKeyEqual<T>, WA>;\n\tmutable data_t set;\n\npublic:\n\n\n\tViewableSet() = default;\n\n\tViewableSet(ViewableSet&&) = default;\n\n\tViewableSet& operator=(ViewableSet&&) = default;\n\n\tvirtual ~ViewableSet() = default;\n\n\n\npublic:\n\tclass iterator\n\t{\n\t\tfriend class ViewableSet<T>;\n\n\t\ttypename data_t::iterator it_;\n\n\t\texplicit iterator(const typename data_t::iterator& it) : it_(it)\n\t\t{\n\t\t}\n\n\tpublic:\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\t\tusing value_type = T;\n\t\tusing difference_type = std::ptrdiff_t;\n\t\tusing pointer = T const*;\n\t\tusing reference = T const&;\n\n\t\titerator(const iterator& other) = default;\n\n\t\titerator(iterator&& other) noexcept = default;\n\n\t\titerator& operator=(const iterator& other) = default;\n\n\t\titerator& operator=(iterator&& other) noexcept = default;\n\n\t\titerator& operator++()\n\t\t{\n\t\t\t++it_;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator++(int)\n\t\t{\n\t\t\tauto it = *this;\n\t\t\t++*this;\n\t\t\treturn it;\n\t\t}\n\n\t\titerator& operator--()\n\t\t{\n\t\t\t--it_;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator--(int)\n\t\t{\n\t\t\tauto it = *this;\n\t\t\t--*this;\n\t\t\treturn it;\n\t\t}\n\n\t\titerator& operator+=(difference_type delta)\n\t\t{\n\t\t\tit_ += delta;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator& operator-=(difference_type delta)\n\t\t{\n\t\t\tit_ -= delta;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator+(difference_type delta) const\n\t\t{\n\t\t\tauto it = *this;\n\t\t\treturn it += delta;\n\t\t}\n\n\t\titerator operator-(difference_type delta) const\n\t\t{\n\t\t\tauto it = *this;\n\t\t\treturn it -= delta;\n\t\t}\n\n\t\tdifference_type operator-(iterator const& other) const\n\t\t{\n\t\t\treturn it_ - other.it_;\n\t\t}\n\n\t\tbool operator<(iterator const& other) const noexcept\n\t\t{\n\t\t\treturn this->it_ < other.it_;\n\t\t}\n\n\t\tbool operator>(iterator const& other) const noexcept\n\t\t{\n\t\t\treturn this->it_ > other.it_;\n\t\t}\n\n\t\tbool operator==(iterator const& other) const noexcept\n\t\t{\n\t\t\treturn this->it_ == other.it_;\n\t\t}\n\n\t\tbool operator!=(iterator const& other) const noexcept\n\t\t{\n\t\t\treturn !(*this == other);\n\t\t}\n\n\t\tbool operator<=(iterator const& other) const noexcept\n\t\t{\n\t\t\treturn (this->it_ < other.it_) || (*this == other);\n\t\t}\n\n\t\tbool operator>=(iterator const& other) const noexcept\n\t\t{\n\t\t\treturn (this->it_ > other.it_) || (*this == other);\n\t\t}\n\n\t\treference operator*() const noexcept\n\t\t{\n\t\t\treturn **it_;\n\t\t}\n\n\t\tpointer operator->() const noexcept\n\t\t{\n\t\t\treturn (*it_).get();\n\t\t}\n\t};\n\n\tusing reverse_iterator = std::reverse_iterator<iterator>;\n\n\titerator begin() const\n\t{\n\t\treturn iterator(set.begin());\n\t}\n\n\titerator end() const\n\t{\n\t\treturn iterator(set.end());\n\t}\n\n\treverse_iterator rbegin() const\n\t{\n\t\treturn reverse_iterator(end());\n\t}\n\n\treverse_iterator rend() const\n\t{\n\t\treturn reverse_iterator(begin());\n\t}\n\n\n\n\tbool add(WT element) const override\n\t{\n\n\t\tauto const& it = set.emplace(std::move(element));\n\t\tif (!it.second)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tchange.fire(Event(AddRemove::ADD, &(wrapper::get<T>(*it.first))));\n\t\treturn true;\n\t}\n\n\tbool addAll(std::vector<WT> elements) const override\n\t{\n\t\tfor (auto&& element : elements)\n\t\t{\n\t\t\tViewableSet::add(std::move(element));\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid clear() const override\n\t{\n\t\tstd::vector<Event> changes;\n\t\tfor (auto const& element : set)\n\t\t{\n\t\t\tchanges.push_back(Event(AddRemove::REMOVE, &(*element)));\n\t\t}\n\t\tfor (auto const& e : changes)\n\t\t{\n\t\t\tchange.fire(e);\n\t\t}\n\t\tset.clear();\n\t}\n\n\tbool remove(T const& element) const override\n\t{\n\t\tif (!ViewableSet::contains(element))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tauto it = set.find(element);\n\t\tchange.fire(Event(AddRemove::REMOVE, &(wrapper::get<T>(*it))));\n\t\tset.erase(it);\n\t\treturn true;\n\t}\n\n\tvoid advise(Lifetime lifetime, std::function<void(Event const&)> handler) const override\n\t{\n\t\tfor (auto const& x : set)\n\t\t{\n\t\t\thandler(Event(AddRemove::ADD, &(*x)));\n\t\t}\n\t\tchange.advise(lifetime, handler);\n\t}\n\n\tsize_t size() const override\n\t{\n\t\treturn set.size();\n\t}\n\n\tbool contains(T const& element) const override\n\t{\n\t\treturn set.count(element) > 0;\n\t}\n\n\tbool empty() const override\n\t{\n\t\treturn set.empty();\n\t}\n\n\ttemplate <typename... Args>\n\tbool emplace_add(Args&&... args) const\n\t{\n\t\treturn add(WT{std::forward<Args>(args)...});\n\t}\n};\n}\n\nstatic_assert(std::is_move_constructible<rd::ViewableSet<int>>::value, \"Is move constructible from ViewableSet<int>\");\n\n#endif\n\n'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/impl/RdSet.h'\n:#ifndef RD_CPP_RDSET_H\n#define RD_CPP_RDSET_H\n\n#include \"reactive/ViewableSet.h\"\n#include \"base/RdReactiveBase.h\"\n#include \"serialization/Polymorphic.h\"\n#include \"std/allocator.h\"\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable : 4250)\n#endif\n\nnamespace rd\n{\n\ntemplate <typename T, typename S = Polymorphic<T>, typename A = allocator<T>>\nclass RdSet final : public RdReactiveBase, public ViewableSet<T, A>, public ISerializable\n{\nprivate:\n\tusing WT = typename IViewableSet<T>::WT;\n\nprotected:\n\tusing set = ViewableSet<T>;\n\npublic:\n\tusing Event = typename IViewableSet<T>::Event;\n\n\tusing value_type = T;\n\n\n\n\tRdSet() = default;\n\n\tRdSet(RdSet&&) = default;\n\n\tRdSet& operator=(RdSet&&) = default;\n\n\tvirtual ~RdSet() = default;\n\n\n\n\tstatic RdSet<T, S> read(SerializationCtx& , Buffer& buffer)\n\t{\n\t\tRdSet<T, S> result;\n\t\tRdId id = RdId::read(buffer);\n\t\twithId(result, std::move(id));\n\t\treturn result;\n\t}\n\n\tvoid write(SerializationCtx& , Buffer& buffer) const override\n\t{\n\t\trdid.write(buffer);\n\t}\n\n\tbool optimize_nested = false;\n\n\tvoid init(Lifetime lifetime) const override\n\t{\n\t\tRdBindableBase::init(lifetime);\n\n\t\tlocal_change([this, lifetime] {\n\t\t\tadvise(lifetime, [this](AddRemove kind, T const& v) {\n\t\t\t\tif (!is_local_change)\n\t\t\t\t\treturn;\n\n\t\t\t\tget_wire()->send(rdid, [this, kind, &v](Buffer& buffer) {\n\t\t\t\t\tbuffer.write_enum<AddRemove>(kind);\n\t\t\t\t\tS::write(this->get_serialization_context(), buffer, v);\n\n\t\t\t\t\tspdlog::get(\"logSend\")->trace(\"SENDset {} {}:: {}:: {}\", to_string(location), to_string(rdid), to_string(kind), to_string(v));\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tget_wire()->advise(lifetime, this);\n\t}\n\n\tvoid on_wire_received(Buffer buffer) const override\n\t{\n\t\tAddRemove kind = buffer.read_enum<AddRemove>();\n\t\tauto value = S::read(this->get_serialization_context(), buffer);\n\n\t\tswitch (kind)\n\t\t{\n\t\t\tcase AddRemove::ADD:\n\t\t\t{\n\t\t\t\tset::add(std::move(value));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase AddRemove::REMOVE:\n\t\t\t{\n\t\t\t\tset::remove(wrapper::get<T>(value));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool add(WT value) const override\n\t{\n\t\treturn local_change([this, value = std::move(value)]() mutable { return set::add(std::move(value)); });\n\t}\n\n\tvoid clear() const override\n\t{\n\t\treturn local_change([&] { return set::clear(); });\n\t}\n\n\tbool remove(T const& value) const override\n\t{\n\t\treturn local_change([&] { return set::remove(value); });\n\t}\n\n\tsize_t size() const override\n\t{\n\t\treturn local_change([&] { return set::size(); });\n\t}\n\n\tbool contains(T const& value) const override\n\t{\n\t\treturn local_change([&] { return set::contains(value); });\n\t}\n\n\tbool empty() const override\n\t{\n\t\treturn local_change([&] { return set::empty(); });\n\t}\n\n\tvoid advise(Lifetime lifetime, std::function<void(Event const&)> handler) const override\n\t{\n\t\tif (is_bound())\n\t\t{\n\t\t\tassert_threading();\n\t\t}\n\t\tset::advise(lifetime, std::move(handler));\n\t}\n\n\tbool addAll(std::vector<WT> elements) const override\n\t{\n\t\treturn local_change([this, elements = std::move(elements)]() mutable { return set::addAll(elements); });\n\t}\n\n\tfriend std::string to_string(RdSet const& value)\n\t{\n\t\tstd::string res = \"[\";\n\t\tfor (auto const& p : value)\n\t\t{\n\t\t\tres += to_string(p) + \",\";\n\t\t}\n\t\treturn res + \"]\";\n\t}\n\n\tusing IViewableSet<T>::advise;\n};\n}\n\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\nstatic_assert(std::is_move_constructible<rd::RdSet<int>>::value, \"Is move constructible RdSet<int>\");\n\n#endif\n\n'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/SignalCookie.h'\n:#ifndef RD_CPP_SIGNALCOOKIE_H\n#define RD_CPP_SIGNALCOOKIE_H\n\n#include <cstdint>\n#include <rd_core_export.h>\n\nextern \"C\" void RD_CORE_API rd_signal_cookie_inc();\nextern \"C\" void RD_CORE_API rd_signal_cookie_dec();\nextern \"C\" int32_t RD_CORE_API rd_signal_cookie_get();\n\n#endif\n\n'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/rd_core_export.h'\n:\n#ifndef RD_CORE_API_H\n#define RD_CORE_API_H\n\n#if defined(_WIN32)\n#ifdef RD_CORE_STATIC_DEFINE\n#  define RD_CORE_API\n#  define RD_CORE_NO_EXPORT\n#else\n#  ifndef RD_CORE_API\n#    ifdef rd_core_cpp_EXPORTS\n\n#      define RD_CORE_API __declspec(dllexport)\n#    else\n\n#      define RD_CORE_API __declspec(dllimport)\n#    endif\n#  endif\n\n#  ifndef RD_CORE_NO_EXPORT\n#    define RD_CORE_NO_EXPORT\n#  endif\n#endif\n\n#ifndef RD_CORE_DEPRECATED\n#  define RD_CORE_DEPRECATED __declspec(deprecated)\n#endif\n\n#ifndef RD_CORE_DEPRECATED_EXPORT\n#  define RD_CORE_DEPRECATED_EXPORT RD_CORE_API RD_CORE_DEPRECATED\n#endif\n\n#ifndef RD_CORE_DEPRECATED_NO_EXPORT\n#  define RD_CORE_DEPRECATED_NO_EXPORT RD_CORE_NO_EXPORT RD_CORE_DEPRECATED\n#endif\n\n#if 0\n#  ifndef RD_CORE_NO_DEPRECATED\n#    define RD_CORE_NO_DEPRECATED\n#  endif\n#endif\n#endif\n\n#if defined(unix) || defined(__unix__) || defined(__unix) || defined(__APPLE__)\n#ifdef RD_CORE_STATIC_DEFINE\n#  define RD_CORE_API\n#  define RD_CORE_NO_EXPORT\n#else\n#  ifndef RD_CORE_API\n#    ifdef rd_core_cpp_EXPORTS\n\n#      define RD_CORE_API __attribute__((visibility(\"default\")))\n#    else\n\n#      define RD_CORE_API __attribute__((visibility(\"default\")))\n#    endif\n#  endif\n\n#  ifndef RD_CORE_NO_EXPORT\n#    define RD_CORE_NO_EXPORT __attribute__((visibility(\"hidden\")))\n#  endif\n#endif\n\n#ifndef RD_CORE_DEPRECATED\n#  define RD_CORE_DEPRECATED __attribute__ ((__deprecated__))\n#endif\n\n#ifndef RD_CORE_DEPRECATED_EXPORT\n#  define RD_CORE_DEPRECATED_EXPORT RD_CORE_API RD_CORE_DEPRECATED\n#endif\n\n#ifndef RD_CORE_DEPRECATED_NO_EXPORT\n#  define RD_CORE_DEPRECATED_NO_EXPORT RD_CORE_NO_EXPORT RD_CORE_DEPRECATED\n#endif\n\n#if 0\n#  ifndef RD_CORE_NO_DEPRECATED\n#    define RD_CORE_NO_DEPRECATED\n#  endif\n#endif\n#endif\n\n#endif\n\n'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/SignalX.h'\n:#ifndef RD_CPP_CORE_SIGNAL_H\n#define RD_CPP_CORE_SIGNAL_H\n\n#include \"interfaces.h\"\n#include \"SignalCookie.h\"\n\n#include <lifetime/Lifetime.h>\n#include <util/core_util.h>\n\n#include <utility>\n#include <functional>\n#include <atomic>\n\nnamespace rd\n{\n\ntemplate <typename T>\nclass Signal final : public ISignal<T>\n{\nprivate:\n\tusing WT = typename ISignal<T>::WT;\n\n\tclass Event\n\t{\n\tprivate:\n\t\tstd::function<void(T const&)> action;\n\t\tLifetime lifetime;\n\n\tpublic:\n\n\t\tEvent() = delete;\n\n\t\ttemplate <typename F>\n\t\tEvent(F&& action, Lifetime lifetime) : action(std::forward<F>(action)), lifetime(lifetime)\n\t\t{\n\t\t}\n\n\t\tEvent(Event&&) = default;\n\n\n\t\tbool is_alive() const\n\t\t{\n\t\t\treturn !lifetime->is_terminated();\n\t\t}\n\n\t\tvoid execute_if_alive(T const& value) const\n\t\t{\n\t\t\tif (is_alive())\n\t\t\t{\n\t\t\t\taction(value);\n\t\t\t}\n\t\t}\n\t};\n\n\tusing counter_t = int32_t;\n\tusing listeners_t = std::map<counter_t, Event>;\n\n\tmutable counter_t advise_id = 0;\n\tmutable listeners_t listeners, priority_listeners;\n\n\tstatic void cleanup(listeners_t& queue)\n\t{\n\t\tutil::erase_if(queue, [](Event const& e) -> bool { return !e.is_alive(); });\n\t}\n\n\tvoid fire_impl(T const& value, listeners_t& queue) const\n\t{\n\t\tfor (auto const& p : queue)\n\t\t{\n\t\t\tauto const& event = p.second;\n\t\t\tevent.execute_if_alive(value);\n\t\t}\n\t\tcleanup(queue);\n\t}\n\n\ttemplate <typename F>\n\tvoid advise0(const Lifetime& lifetime, F&& handler, listeners_t& queue) const\n\t{\n\t\tif (lifetime->is_terminated())\n\t\t\treturn;\n\t\tcounter_t id = advise_id ;\n\t\tqueue.emplace(id, Event(std::forward<F>(handler), lifetime));\n\t\t++advise_id;\n\t}\n\npublic:\n\n\n\tSignal() = default;\n\n\tSignal(Signal const& other) = delete;\n\n\tSignal& operator=(Signal const& other) = delete;\n\n\tSignal(Signal&&) = default;\n\n\tSignal& operator=(Signal&&) = default;\n\n\tvirtual ~Signal() = default;\n\n\n\n\tusing ISignal<T>::fire;\n\n\tvoid fire(T const& value) const override\n\t{\n\t\tfire_impl(value, priority_listeners);\n\t\tfire_impl(value, listeners);\n\t}\n\n\tusing ISignal<T>::advise;\n\n\tvoid advise(Lifetime lifetime, std::function<void(T const&)> handler) const override\n\t{\n\t\tadvise0(lifetime, std::move(handler), isPriorityAdvise() ? priority_listeners : listeners);\n\t}\n\n\tstatic bool isPriorityAdvise()\n\t{\n\t\treturn rd_signal_cookie_get() > 0;\n\t}\n};\n\ntemplate <typename F>\nvoid priorityAdviseSection(F&& block)\n{\n\trd_signal_cookie_inc();\n\tblock();\n\trd_signal_cookie_dec();\n}\n}\n\nstatic_assert(std::is_move_constructible<rd::Signal<int>>::value, \"Is not move constructible from Signal<int>\");\nstatic_assert(std::is_move_constructible<rd::Signal<rd::Void>>::value, \"Is not move constructible from Signal<Void>\");\n\n#endif\n",
        "gt": [
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/rd_core_export.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/SignalCookie.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/SignalX.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/ViewableSet.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/impl/RdSet.h'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/instructions.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/File.hpp'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'\n:\n#ifndef LIEF_MAIN_HEADER_H\n#define LIEF_MAIN_HEADER_H\n#include <LIEF/config.h>\n\n#include <LIEF/Abstract.hpp>\n\n#include <LIEF/OAT.hpp>\n#include <LIEF/VDEX.hpp>\n#include <LIEF/ART.hpp>\n#include <LIEF/DEX.hpp>\n#include <LIEF/ELF.hpp>\n#include <LIEF/PE.hpp>\n#include <LIEF/MachO.hpp>\n#include <LIEF/DWARF.hpp>\n#include <LIEF/logging.hpp>\n#include <LIEF/platforms.hpp>\n\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'\n:\n#ifndef LIEF_DEX_H\n#define LIEF_DEX_H\n#include \"LIEF/config.h\"\n\n#if defined(LIEF_DEX_SUPPORT)\n#include \"LIEF/DEX/Parser.hpp\"\n#include \"LIEF/DEX/utils.hpp\"\n#include \"LIEF/DEX/File.hpp\"\n#include \"LIEF/DEX/Class.hpp\"\n#include \"LIEF/DEX/Prototype.hpp\"\n#include \"LIEF/DEX/Header.hpp\"\n#include \"LIEF/DEX/Method.hpp\"\n#include \"LIEF/DEX/Field.hpp\"\n#include \"LIEF/DEX/EnumToString.hpp\"\n#endif\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/instructions.hpp'\n:\n#ifndef LIEF_DEX_INSTRUCTIONS_H\n#define LIEF_DEX_INSTRUCTIONS_H\n#include \"LIEF/visibility.h\"\n#include \"LIEF/types.hpp\"\n#include <cstddef>\n\nnamespace LIEF {\nnamespace DEX {\n\nenum SWITCH_ARRAY_IDENT : uint16_t {\n  IDENT_PACKED_SWITCH = 0x0100,\n  IDENT_SPARSE_SWITCH = 0x0200,\n  IDENT_FILL_ARRAY    = 0x0300,\n};\n\n\nenum OPCODES : uint8_t {\n  OP_NOP                    = 0x00,\n  OP_MOVE                   = 0x01,\n  OP_MOVE_FROM_16           = 0x02,\n  OP_MOVE_16                = 0x03,\n  OP_MOVE_WIDE              = 0x04,\n  OP_MOVE_WIDE_FROM_16      = 0x05,\n  OP_MOVE_WIDE_16           = 0x06,\n  OP_MOVE_OBJECT            = 0x07,\n  OP_MOVE_OBJECT_FROM_16    = 0x08,\n  OP_MOVE_OBJECT_16         = 0x09,\n  OP_MOVE_RESULT            = 0x0a,\n  OP_MOVE_RESULT_WIDE       = 0x0b,\n  OP_MOVE_RESULT_OBJECT     = 0x0c,\n  OP_MOVE_EXCEPTION         = 0x0d,\n  OP_RETURN_VOID            = 0x0e,\n  OP_RETURN                 = 0x0f,\n  OP_RETURN_WIDE            = 0x10,\n  OP_RETURN_OBJECT          = 0x11,\n  OP_CONST_4                = 0x12,\n  OP_CONST_16               = 0x13,\n  OP_CONST                  = 0x14,\n  OP_CONST_HIGH_16          = 0x15,\n  OP_CONST_WIDE_16          = 0x16,\n  OP_CONST_WIDE_32          = 0x17,\n  OP_CONST_WIDE             = 0x18,\n  OP_CONST_WIDE_HIGH_16     = 0x19,\n  OP_CONST_STRING           = 0x1a,\n  OP_CONST_STRING_JUMBO     = 0x1b,\n  OP_CONST_CLASS            = 0x1c,\n  OP_MONITOR_ENTER          = 0x1d,\n  OP_MONITOR_EXIT           = 0x1e,\n  OP_CHECK_CAST             = 0x1f,\n  OP_INSTANCE_OF            = 0x20,\n  OP_ARRAY_LENGTH           = 0x21,\n  OP_NEW_INSTANCE           = 0x22,\n  OP_NEW_ARRAY              = 0x23,\n  OP_FILLED_NEW_ARRAY       = 0x24,\n  OP_FILLED_NEW_ARRAY_RANGE = 0x25,\n  OP_FILL_ARRAY_DATA        = 0x26,\n  OP_THROW                  = 0x27,\n  OP_GOTO                   = 0x28,\n  OP_GOTO_16                = 0x29,\n  OP_GOTO_32                = 0x2a,\n  OP_PACKED_SWITCH          = 0x2b,\n  OP_SPARSE_SWITCH          = 0x2c,\n  OP_CMPL_FLOAT             = 0x2d,\n  OP_CMPG_FLOAT             = 0x2e,\n  OP_CMPL_DOUBLE            = 0x2f,\n  OP_CMPG_DOUBLE            = 0x30,\n  OP_CMP_LONG               = 0x31,\n  OP_IF_EQ                  = 0x32,\n  OP_IF_NE                  = 0x33,\n  OP_IF_LT                  = 0x34,\n  OP_IF_GE                  = 0x35,\n  OP_IF_GT                  = 0x36,\n  OP_IF_LE                  = 0x37,\n  OP_IF_EQZ                 = 0x38,\n  OP_IF_NEZ                 = 0x39,\n  OP_IF_LTZ                 = 0x3a,\n  OP_IF_GEZ                 = 0x3b,\n  OP_IF_GTZ                 = 0x3c,\n  OP_IF_LEZ                 = 0x3d,\n  OP_AGET                   = 0x44,\n  OP_AGET_WIDE              = 0x45,\n  OP_AGET_OBJECT            = 0x46,\n  OP_AGET_BOOLEAN           = 0x47,\n  OP_AGET_BYTE              = 0x48,\n  OP_AGET_CHAR              = 0x49,\n  OP_AGET_SHORT             = 0x4a,\n  OP_APUT                   = 0x4b,\n  OP_APUT_WIDE              = 0x4c,\n  OP_APUT_OBJECT            = 0x4d,\n  OP_APUT_BOOLEAN           = 0x4e,\n  OP_APUT_BYTE              = 0x4f,\n  OP_APUT_CHAR              = 0x50,\n  OP_APUT_SHORT             = 0x51,\n  OP_IGET                   = 0x52,\n  OP_IGET_WIDE              = 0x53,\n  OP_IGET_OBJECT            = 0x54,\n  OP_IGET_BOOLEAN           = 0x55,\n  OP_IGET_BYTE              = 0x56,\n  OP_IGET_CHAR              = 0x57,\n  OP_IGET_SHORT             = 0x58,\n  OP_IPUT                   = 0x59,\n  OP_IPUT_WIDE              = 0x5a,\n  OP_IPUT_OBJECT            = 0x5b,\n  OP_IPUT_BOOLEAN           = 0x5c,\n  OP_IPUT_BYTE              = 0x5d,\n  OP_IPUT_CHAR              = 0x5e,\n  OP_IPUT_SHORT             = 0x5f,\n  OP_SGET                   = 0x60,\n  OP_SGET_WIDE              = 0x61,\n  OP_SGET_OBJECT            = 0x62,\n  OP_SGET_BOOLEAN           = 0x63,\n  OP_SGET_BYTE              = 0x64,\n  OP_SGET_CHAR              = 0x65,\n  OP_SGET_SHORT             = 0x66,\n  OP_SPUT                   = 0x67,\n  OP_SPUT_WIDE              = 0x68,\n  OP_SPUT_OBJECT            = 0x69,\n  OP_SPUT_BOOLEAN           = 0x6a,\n  OP_SPUT_BYTE              = 0x6b,\n  OP_SPUT_CHAR              = 0x6c,\n  OP_SPUT_SHORT             = 0x6d,\n  OP_INVOKE_VIRTUAL         = 0x6e,\n  OP_INVOKE_SUPER           = 0x6f,\n  OP_INVOKE_DIRECT          = 0x70,\n  OP_INVOKE_STATIC          = 0x71,\n  OP_INVOKE_INTERFACE       = 0x72,\n  OP_RETURN_VOID_NO_BARRIER = 0x73,\n  OP_INVOKE_VIRTUAL_RANGE   = 0x74,\n  OP_INVOKE_SUPER_RANGE     = 0x75,\n  OP_INVOKE_DIRECT_RANGE    = 0x76,\n  OP_INVOKE_STATIC_RANGE    = 0x77,\n  OP_INVOKE_INTERFACE_RANGE = 0x78,\n  OP_NEG_INT                = 0x7b,\n  OP_NOT_INT                = 0x7c,\n  OP_NEG_LONG               = 0x7d,\n  OP_NOT_LONG               = 0x7e,\n  OP_NEG_FLOAT              = 0x7f,\n  OP_NEG_DOUBLE             = 0x80,\n  OP_INT_TO_LONG            = 0x81,\n  OP_INT_TO_FLOAT           = 0x82,\n  OP_INT_TO_DOUBLE          = 0x83,\n  OP_LONG_TO_INT            = 0x84,\n  OP_LONG_TO_FLOAT          = 0x85,\n  OP_LONG_TO_DOUBLE         = 0x86,\n  OP_FLOAT_TO_INT           = 0x87,\n  OP_FLOAT_TO_LONG          = 0x88,\n  OP_FLOAT_TO_DOUBLE        = 0x89,\n  OP_DOUBLE_TO_INT          = 0x8a,\n  OP_DOUBLE_TO_LONG         = 0x8b,\n  OP_DOUBLE_TO_FLOAT        = 0x8c,\n  OP_INT_TO_BYTE            = 0x8d,\n  OP_INT_TO_CHAR            = 0x8e,\n  OP_INT_TO_SHORT           = 0x8f,\n  OP_ADD_INT                = 0x90,\n  OP_SUB_INT                = 0x91,\n  OP_MUL_INT                = 0x92,\n  OP_DIV_INT                = 0x93,\n  OP_REM_INT                = 0x94,\n  OP_AND_INT                = 0x95,\n  OP_OR_INT                 = 0x96,\n  OP_XOR_INT                = 0x97,\n  OP_SHL_INT                = 0x98,\n  OP_SHR_INT                = 0x99,\n  OP_USHR_INT               = 0x9a,\n  OP_ADD_LONG               = 0x9b,\n  OP_SUB_LONG               = 0x9c,\n  OP_MUL_LONG               = 0x9d,\n  OP_DIV_LONG               = 0x9e,\n  OP_REM_LONG               = 0x9f,\n  OP_AND_LONG               = 0xa0,\n  OP_OR_LONG                = 0xa1,\n  OP_XOR_LONG               = 0xa2,\n  OP_SHL_LONG               = 0xa3,\n  OP_SHR_LONG               = 0xa4,\n  OP_USHR_LONG              = 0xa5,\n  OP_ADD_FLOAT              = 0xa6,\n  OP_SUB_FLOAT              = 0xa7,\n  OP_MUL_FLOAT              = 0xa8,\n  OP_DIV_FLOAT              = 0xa9,\n  OP_REM_FLOAT              = 0xaa,\n  OP_ADD_DOUBLE             = 0xab,\n  OP_SUB_DOUBLE             = 0xac,\n  OP_MUL_DOUBLE             = 0xad,\n  OP_DIV_DOUBLE             = 0xae,\n  OP_REM_DOUBLE             = 0xaf,\n  OP_ADD_INT_2_ADDR         = 0xb0,\n  OP_SUB_INT_2_ADDR         = 0xb1,\n  OP_MUL_INT_2_ADDR         = 0xb2,\n  OP_DIV_INT_2_ADDR         = 0xb3,\n  OP_REM_INT_2_ADDR         = 0xb4,\n  OP_AND_INT_2_ADDR         = 0xb5,\n  OP_OR_INT_2_ADDR          = 0xb6,\n  OP_XOR_INT_2_ADDR         = 0xb7,\n  OP_SHL_INT_2_ADDR         = 0xb8,\n  OP_SHR_INT_2_ADDR         = 0xb9,\n  OP_USHR_INT_2_ADDR        = 0xba,\n  OP_ADD_LONG_2_ADDR        = 0xbb,\n  OP_SUB_LONG_2_ADDR        = 0xbc,\n  OP_MUL_LONG_2_ADDR        = 0xbd,\n  OP_DIV_LONG_2_ADDR        = 0xbe,\n  OP_REM_LONG_2_ADDR        = 0xbf,\n  OP_AND_LONG_2_ADDR        = 0xc0,\n  OP_OR_LONG_2_ADDR         = 0xc1,\n  OP_XOR_LONG_2_ADDR        = 0xc2,\n  OP_SHL_LONG_2_ADDR        = 0xc3,\n  OP_SHR_LONG_2_ADDR        = 0xc4,\n  OP_USHR_LONG_2_ADDR       = 0xc5,\n  OP_ADD_FLOAT_2_ADDR       = 0xc6,\n  OP_SUB_FLOAT_2_ADDR       = 0xc7,\n  OP_MUL_FLOAT_2_ADDR       = 0xc8,\n  OP_DIV_FLOAT_2_ADDR       = 0xc9,\n  OP_REM_FLOAT_2_ADDR       = 0xca,\n  OP_ADD_DOUBLE_2_ADDR      = 0xcb,\n  OP_SUB_DOUBLE_2_ADDR      = 0xcc,\n  OP_MUL_DOUBLE_2_ADDR      = 0xcd,\n  OP_DIV_DOUBLE_2_ADDR      = 0xce,\n  OP_REM_DOUBLE_2_ADDR      = 0xcf,\n  OP_ADD_INT_LIT_16         = 0xd0,\n  OP_RSUB_INT               = 0xd1,\n  OP_MUL_INT_LIT_16         = 0xd2,\n  OP_DIV_INT_LIT_16         = 0xd3,\n  OP_REM_INT_LIT_16         = 0xd4,\n  OP_AND_INT_LIT_16         = 0xd5,\n  OP_OR_INT_LIT_16          = 0xd6,\n  OP_XOR_INT_LIT_16         = 0xd7,\n  OP_ADD_INT_LIT_8          = 0xd8,\n  OP_RSUB_INT_LIT_8         = 0xd9,\n  OP_MUL_INT_LIT_8          = 0xda,\n  OP_DIV_INT_LIT_8          = 0xdb,\n  OP_REM_INT_LIT_8          = 0xdc,\n  OP_AND_INT_LIT_8          = 0xdd,\n  OP_OR_INT_LIT_8           = 0xde,\n  OP_XOR_INT_LIT_8          = 0xdf,\n  OP_SHL_INT_LIT_8          = 0xe0,\n  OP_SHR_INT_LIT_8          = 0xe1,\n  OP_USHR_INT_LIT_8         = 0xe2,\n\n\n  OP_IGET_QUICK                  = 0xe3,\n  OP_IGET_WIDE_QUICK             = 0xe4,\n  OP_IGET_OBJECT_QUICK           = 0xe5,\n  OP_IPUT_QUICK                  = 0xe6,\n  OP_IPUT_WIDE_QUICK             = 0xe7,\n  OP_IPUT_OBJECT_QUICK           = 0xe8,\n  OP_INVOKE_VIRTUAL_QUICK        = 0xe9,\n  OP_INVOKE_VIRTUAL_RANGE_QUICK  = 0xea,\n  OP_IPUT_BOOLEAN_QUICK          = 0xeb,\n  OP_IPUT_BYTE_QUICK             = 0xec,\n  OP_IPUT_CHAR_QUICK             = 0xed,\n  OP_IPUT_SHORT_QUICK            = 0xee,\n  OP_IGET_BOOLEAN_QUICK          = 0xef,\n  OP_IGET_BYTE_QUICK             = 0xf0,\n  OP_IGET_CHAR_QUICK             = 0xf1,\n  OP_IGET_SHORT_QUICK            = 0xf2,\n\n\n  OP_INVOKE_POLYMORPHIC       = 0xfa,\n  OP_INVOKE_POLYMORPHIC_RANGE = 0xfb,\n  OP_INVOKE_CUSTOM            = 0xfc,\n  OP_INVOKE_CUSTOM_RANGE      = 0xfd,\n\n\n  OP_CONST_METHOD_HANDLE      = 0xfe,\n  OP_CONST_METHOD_TYPE        = 0xff,\n};\n\nenum INST_FORMATS : uint8_t {\n  F_00x = 0,\n  F_10x,\n  F_12x,\n  F_11n,\n  F_11x,\n  F_10t,\n  F_20t,\n  F_20bc,\n  F_22x,\n  F_21t,\n  F_21s,\n  F_21h,\n  F_21c,\n  F_23x,\n  F_22b,\n  F_22t,\n  F_22s,\n  F_22c,\n  F_22cs,\n  F_30t,\n  F_32x,\n  F_31i,\n  F_31t,\n  F_31c,\n  F_35c,\n  F_35ms,\n  F_35mi,\n  F_3rc,\n  F_3rms,\n  F_3rmi,\n  F_51l,\n\n\n  F_45cc,\n  F_4rcc,\n};\n\nstruct packed_switch {\n  uint16_t ident;\n  uint16_t size;\n  uint32_t first_key;\n\n};\n\n\nstruct sparse_switch {\n  uint16_t ident;\n  uint16_t size;\n\n};\n\nstruct fill_array_data {\n  uint16_t ident;\n  uint16_t element_width;\n  uint32_t size;\n\n};\n\n\n\nLIEF_API INST_FORMATS inst_format_from_opcode(OPCODES op);\n\nLIEF_API size_t inst_size_from_format(INST_FORMATS fmt);\nLIEF_API size_t inst_size_from_opcode(OPCODES op);\n\nLIEF_API bool is_switch_array(const uint8_t* ptr, const uint8_t* end);\n\nLIEF_API size_t switch_array_size(const uint8_t* ptr, const uint8_t* end);\n\n}\n}\n\n#endif\n\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/File.hpp'\n:\n#ifndef LIEF_DEX_FILE_H\n#define LIEF_DEX_FILE_H\n#include <memory>\n\n#include \"LIEF/visibility.h\"\n#include \"LIEF/Object.hpp\"\n\n#include \"LIEF/DEX/Header.hpp\"\n#include \"LIEF/DEX/MapList.hpp\"\n#include \"LIEF/DEX/instructions.hpp\"\n#include \"LIEF/DEX/deopt.hpp\"\n#include \"LIEF/DEX/types.hpp\"\n\nnamespace LIEF {\nnamespace DEX {\nclass Parser;\nclass Class;\nclass Method;\nclass Type;\nclass Prototype;\nclass Field;\n\n\nclass LIEF_API File : public Object {\n  friend class Parser;\n\n  public:\n  using classes_t = std::unordered_map<std::string, Class*>;\n  using classes_list_t = std::vector<std::unique_ptr<Class>>;\n  using it_classes = ref_iterator<classes_list_t&, Class*>;\n  using it_const_classes = const_ref_iterator<const classes_list_t&, const Class*>;\n\n  using methods_t = std::vector<std::unique_ptr<Method>>;\n  using it_methods = ref_iterator<methods_t&, Method*>;\n  using it_const_methods = const_ref_iterator<const methods_t&, const Method*>;\n\n  using strings_t           = std::vector<std::unique_ptr<std::string>>;\n  using it_strings          = ref_iterator<strings_t&, std::string*>;\n  using it_const_strings    = const_ref_iterator<const strings_t&, const std::string*>;\n\n  using types_t             = std::vector<std::unique_ptr<Type>>;\n  using it_types            = ref_iterator<types_t&, Type*>;\n  using it_const_types      = const_ref_iterator<const types_t&, const Type*>;\n\n  using prototypes_t        = std::vector<std::unique_ptr<Prototype>>;\n  using it_prototypes       = ref_iterator<prototypes_t&, Prototype*>;\n  using it_const_prototypes = const_ref_iterator<const prototypes_t&, const Prototype*>;\n\n  using fields_t            = std::vector<std::unique_ptr<Field>>;\n  using it_fields           = ref_iterator<fields_t&, Field*>;\n  using it_const_fields     = const_ref_iterator<const fields_t&, const Field*>;\n\n  public:\n  File& operator=(const File& copy) = delete;\n  File(const File& copy)            = delete;\n\n\n  dex_version_t version() const;\n\n\n  const std::string& name() const;\n\n  void name(const std::string& name);\n\n\n  const std::string& location() const;\n  void location(const std::string& location);\n\n\n  const Header& header() const;\n  Header& header();\n\n\n  it_const_classes classes() const;\n  it_classes classes();\n\n\n  bool has_class(const std::string& class_name) const;\n\n\n  const Class* get_class(const std::string& class_name) const;\n\n  Class* get_class(const std::string& class_name);\n\n\n  const Class* get_class(size_t index) const;\n\n  Class* get_class(size_t index);\n\n\n  dex2dex_info_t dex2dex_info() const;\n\n\n  std::string dex2dex_json_info() const;\n\n\n  it_const_methods methods() const;\n  it_methods methods();\n\n\n  it_const_fields fields() const;\n  it_fields fields();\n\n\n  it_const_strings strings() const;\n  it_strings strings();\n\n\n  it_const_types types() const;\n  it_types types();\n\n\n  it_prototypes prototypes();\n  it_const_prototypes prototypes() const;\n\n\n  const MapList& map() const;\n  MapList& map();\n\n\n  std::string save(const std::string& path = \"\", bool deoptimize = true) const;\n\n  std::vector<uint8_t> raw(bool deoptimize = true) const;\n\n  void accept(Visitor& visitor) const override;\n\n  bool operator==(const File& rhs) const;\n  bool operator!=(const File& rhs) const;\n\n  ~File() override;\n\n  LIEF_API friend std::ostream& operator<<(std::ostream& os, const File& file);\n\n  private:\n  File();\n\n  void add_class(std::unique_ptr<Class> cls);\n\n  static void deoptimize_nop(uint8_t* inst_ptr, uint32_t value);\n  static void deoptimize_return(uint8_t* inst_ptr, uint32_t value);\n  static void deoptimize_invoke_virtual(uint8_t* inst_ptr, uint32_t value, OPCODES new_inst);\n  static void deoptimize_instance_field_access(uint8_t* inst_ptr, uint32_t value, OPCODES new_inst);\n\n  std::string name_;\n  std::string location_;\n\n  Header       header_;\n  classes_t    classes_;\n  methods_t    methods_;\n  fields_t     fields_;\n  strings_t    strings_;\n  types_t      types_;\n  prototypes_t prototypes_;\n  MapList      map_;\n\n  classes_list_t class_list_;\n  std::vector<uint8_t> original_data_;\n};\n\n}\n}\n\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/instructions.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX/File.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/DEX.hpp'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.hpp'"
        ]
    },
    {
        "files": [
            "'knowrob/include/knowrob/plugins/PluginFactory.h'",
            "'knowrob/include/knowrob/semweb/SPARQLService.h'",
            "'knowrob/include/knowrob/storage/Storage.h'",
            "'knowrob/include/knowrob/storage/redland/RedlandModel.h'",
            "'knowrob/src/DataSource.cpp'"
        ],
        "content": "'knowrob/include/knowrob/plugins/PluginFactory.h'\n:\n\n#ifndef KNOWROB_PLUGIN_FACTORY_H_\n#define KNOWROB_PLUGIN_FACTORY_H_\n\n#include <string>\n#include <memory>\n#include \"NamedPlugin.h\"\n\nnamespace knowrob {\n\n\ttemplate<class T>\n\tclass PluginFactory {\n\tpublic:\n\t\tvirtual ~PluginFactory() = default;\n\n\n\t\tvirtual std::shared_ptr<NamedPlugin<T>> create(std::string_view pluginID) = 0;\n\n\n\t\tvirtual std::string_view name() const = 0;\n\t};\n}\n\n#endif\n\n'knowrob/include/knowrob/semweb/SPARQLService.h'\n:\n\n#ifndef KNOWROB_SPARQL_SERVICE_H\n#define KNOWROB_SPARQL_SERVICE_H\n\n#include <redland.h>\n#include \"knowrob/semweb/TripleFormat.h\"\n#include \"knowrob/semweb/TripleContainer.h\"\n#include \"OntologySource.h\"\n#include \"knowrob/storage/redland/RedlandModel.h\"\n\nnamespace knowrob {\n\n\tclass SPARQLService : public OntologySource {\n\tpublic:\n\n\t\tSPARQLService(const URI &uri, semweb::TripleFormat format);\n\n\n\t\tSPARQLService(const URI &uri, std::string_view format);\n\n\n\t\tbool load(const TripleHandler &callback) override;\n\n\tprotected:\n\t\tRedlandModel model_;\n\t};\n\n}\n\n#endif\n\n'knowrob/include/knowrob/storage/Storage.h'\n:\n\n#ifndef KNOWROB_STORAGE_H\n#define KNOWROB_STORAGE_H\n\n#include <boost/property_tree/ptree.hpp>\n#include \"knowrob/semweb/TriplePattern.h\"\n#include \"knowrob/semweb/Triple.h\"\n#include \"knowrob/semweb/TripleContainer.h\"\n#include \"knowrob/semweb/Vocabulary.h\"\n#include \"knowrob/PropertyTree.h\"\n#include \"knowrob/ThreadPool.h\"\n#include \"knowrob/DataSourceHandler.h\"\n#include \"knowrob/plugins/PluginFactory.h\"\n#include \"knowrob/plugins/TypedPluginFactory.h\"\n\nnamespace knowrob {\n\n\tenum class StorageFeature : std::uint8_t {\n\n\t\tNothingSpecial = 1ul << 0,\n\n\t\tReAssignment = 1ul << 2,\n\n\n\n\t\tTripleContext = 1ul << 3\n\t};\n\tusing StorageFeatures = StorageFeature;\n\n\n\tStorageFeature operator|(StorageFeature a, StorageFeature b);\n\n\n\tbool operator&(StorageFeature a, StorageFeature b);\n\n\n\tclass Storage : public DataSourceHandler {\n\tpublic:\n\t\texplicit Storage(StorageFeatures features = StorageFeature::NothingSpecial) : features_(features), storageLanguage_(PluginLanguage::CPP) {}\n\n\t\tvirtual ~Storage() = default;\n\n\n\t\tPluginLanguage storageLanguage() const { return storageLanguage_; }\n\n\n\t\tconst auto &vocabulary() const { return vocabulary_; }\n\n\n\t\tvoid setVocabulary(std::shared_ptr<Vocabulary> vocabulary) { vocabulary_ = std::move(vocabulary); }\n\n\n\t\tbool supports(StorageFeature feature) const { return features_ & feature; }\n\n\n\t\tvirtual bool insertOne(const Triple &triple) = 0;\n\n\n\t\tvirtual bool insertAll(const TripleContainerPtr &triples) = 0;\n\n\n\t\tvirtual bool removeOne(const Triple &triple) = 0;\n\n\n\t\tvirtual bool removeAll(const TripleContainerPtr &triples) = 0;\n\n\n\t\tvirtual bool removeAllWithOrigin(std::string_view origin) = 0;\n\n\n\t\tvirtual bool initializeBackend(const PropertyTree &config) = 0;\n\n\t\tstd::optional<std::string> getVersionOfOrigin(std::string_view origin) const {\n\t\t\tauto it = originVersions_.find(origin.data());\n\t\t\tif (it != originVersions_.end()) {\n\t\t\t\treturn it->second;\n\t\t\t}\n\t\t\treturn std::nullopt;\n\t\t}\n\n\t\tvoid setVersionOfOrigin(std::string_view origin, std::optional<std::string_view> version) {\n\t\t\tif (version) {\n\t\t\t\toriginVersions_[origin.data()] = version.value().data();\n\t\t\t} else {\n\t\t\t\toriginVersions_.erase(origin.data());\n\t\t\t}\n\t\t}\n\n\tprotected:\n\t\tstd::map<std::string, std::string> originVersions_;\n\t\tstd::shared_ptr<Vocabulary> vocabulary_;\n\t\tStorageFeatures features_;\n\t\tPluginLanguage storageLanguage_;\n\n\t\tvoid enableFeature(StorageFeature feature) { features_ = features_ | feature; }\n\n\t\tvoid setStorageLanguage(PluginLanguage storageLanguage) { storageLanguage_ = storageLanguage; }\n\n\t\tfriend class StorageManager;\n\t};\n\n\tusing StoragePtr = std::shared_ptr<Storage>;\n\tusing BackendFactory = PluginFactory<Storage>;\n\tusing NamedBackend = NamedPlugin<Storage>;\n\n}\n\n\n#define KNOWROB_STORAGE_PLUGIN(classType, pluginName) extern \"C\" { \\\n        std::shared_ptr<knowrob::DataBackend> knowrob_createPlugin(const std::string &pluginID) \\\n            { return std::make_shared<classType>(); } \\\n        const char* knowrob_getPluginName() { return pluginName; } }\n\n#endif\n\n'knowrob/include/knowrob/storage/redland/RedlandModel.h'\n:\n\n#ifndef KNOWROB_REDLAND_MODEL_H\n#define KNOWROB_REDLAND_MODEL_H\n\n#include <redland.h>\n#include \"knowrob/semweb/TripleContainer.h\"\n#include \"knowrob/URI.h\"\n#include \"knowrob/semweb/TripleFormat.h\"\n#include \"knowrob/storage/Storage.h\"\n#include \"knowrob/semweb/SPARQLQuery.h\"\n#include \"RedlandURI.h\"\n#include \"knowrob/storage/SPARQLBackend.h\"\n\nnamespace knowrob {\n\n\tenum class RedlandStorageType {\n\n\t\tMEMORY,\n\n\t\tHASHES,\n\n\t\tMYSQL,\n\n\t\tPOSTGRESQL,\n\n\t\tSQLITE\n\t};\n\n\tenum class RedlandHashType {\n\n\t\tMEMORY,\n\n\t\tBDB\n\t};\n\n\n\tclass RedlandModel : public SPARQLBackend {\n\tpublic:\n\t\tstatic constexpr std::string_view QUERY_LANGUAGE_SPARQL = \"sparql\";\n\n\t\tRedlandModel();\n\n\t\t~RedlandModel() override;\n\n\n\t\tvoid setStorageType(RedlandStorageType storageType);\n\n\n\t\tvoid setStorageHashType(RedlandHashType hashType);\n\n\n\t\tvoid setHost(std::string_view host);\n\n\n\t\tvoid setDatabase(std::string_view database);\n\n\n\t\tvoid setUser(std::string_view user);\n\n\n\t\tvoid setPassword(std::string_view password);\n\n\n\t\tvoid setStorageDirectory(std::string_view dir = \".\");\n\n\n\t\tvoid setHashesStorage(RedlandHashType hashType, std::string_view dir = \".\");\n\n\n\t\tvoid setMemoryStorage();\n\n\n\t\tvoid setRaptorWorld(librdf_world *world);\n\n\n\t\tvoid setOrigin(std::string_view origin) { origin_ = origin; }\n\n\n\t\tauto storageType() const { return storageType_; }\n\n\n\t\tbool isInitialized() const;\n\n\n\t\tbool initializeBackend();\n\n\n\t\tbool initializeBackend(const PropertyTree &config) override;\n\n\n\t\tbool load(const URI &uri, semweb::TripleFormat tripleFormat);\n\n\n\t\tbool sparql(std::string_view queryString, const BindingsHandler &callback) const override;\n\n\n\t\tbool insertOne(const Triple &triple) override;\n\n\n\t\tbool insertAll(const TripleContainerPtr &triples) override;\n\n\n\t\tbool removeOne(const Triple &triple) override;\n\n\n\t\tbool removeAll(const TripleContainerPtr &triples) override;\n\n\n\t\tbool removeAllWithOrigin(std::string_view origin) override;\n\n\n\t\tbool isPersistent() const override;\n\n\n\t\tbool contains(const Triple &triple) override;\n\n\n\t\tvoid batch(const TripleHandler &callback) const override;\n\n\n\t\tvoid batchOrigin(std::string_view origin, const TripleHandler &callback) override;\n\n\n\t\tvoid match(const TriplePattern &query, const TripleVisitor &visitor) override;\n\n\tprotected:\n\t\tlibrdf_world *ownedWorld_;\n\t\tlibrdf_world *world_;\n\t\tlibrdf_model *model_;\n\t\tlibrdf_storage *storage_;\n\n\n\n\t\tRedlandURI xsdURIs_[static_cast<int>(XSDType::LAST)];\n\n\t\tRedlandURI &xsdURI(XSDType xsdType);\n\n\t\tstd::map<std::string, librdf_node *, std::less<>> contextNodes_;\n\n\t\tstd::string storageName_;\n\n\t\tstd::optional<std::string> origin_;\n\t\tstd::optional<std::string> host_;\n\t\tstd::optional<std::string> port_;\n\t\tstd::optional<std::string> database_;\n\t\tstd::optional<std::string> user_;\n\t\tstd::optional<std::string> password_;\n\t\tstd::optional<std::string> storageDir_;\n\t\tstd::optional<RedlandHashType> hashType_;\n\t\tRedlandStorageType storageType_;\n\t\tstd::string storageOptions_;\n\n\t\tstd::string getStorageOptions() const;\n\n\t\tvoid knowrobToRaptor(const Triple &triple, raptor_statement *raptorTriple);\n\n\t\tvoid knowrobToRaptor(const TriplePattern &pat, raptor_statement *raptorTriple);\n\n\t\traptor_term *knowrobToRaptor(const TermPtr &term);\n\n\t\tlibrdf_node *getContextNode(std::string_view origin);\n\n\t\tlibrdf_node *getContextNode(const Triple &triple);\n\n\tprivate:\n\t\tvoid finalize();\n\t};\n\n}\n\n#endif\n\n'knowrob/src/DataSource.cpp'\n:\n\n#include <utility>\n#include <filesystem>\n#include <boost/spirit/include/qi.hpp>\n#include <boost/spirit/include/phoenix_operator.hpp>\n#include \"knowrob/integration/python/utils.h\"\n#include \"knowrob/DataSource.h\"\n#include \"knowrob/semweb/OntologyLanguage.h\"\n#include \"knowrob/semweb/OntologyFile.h\"\n#include \"knowrob/semweb/SPARQLService.h\"\n#include \"knowrob/semweb/GraphSelector.h\"\n\n#define DATA_SOURCE_SETTING_FORMAT \"format\"\n#define DATA_SOURCE_SETTING_LANG \"language\"\n#define DATA_SOURCE_SETTING_TYPE \"type\"\n#define DATA_SOURCE_SETTING_FRAME \"frame\"\n\n#define DATA_SOURCE_TYPE_SPARQL \"sparql\"\n#define DATA_SOURCE_TYPE_ONTOLOGY \"ontology\"\n\nusing namespace knowrob;\nnamespace fs = std::filesystem;\nnamespace qi = boost::spirit::qi;\nnamespace ascii = boost::spirit::ascii;\n\nDataSource::DataSource(URI uri, std::string_view format, DataSourceType dataSourceType)\n\t\t: dataSourceType_(dataSourceType),\n\t\t  format_(format),\n\t\t  uri_(std::move(uri)) {\n}\n\nstd::string DataSource::getNameFromURI(const std::string &uriString) {\n\treturn fs::path(uriString).stem();\n}\n\ntemplate<typename TP>\nstd::time_t to_time_t(TP tp) {\n\n\tusing namespace std::chrono;\n\tauto sctp = time_point_cast<system_clock::duration>(tp - TP::clock::now() + system_clock::now());\n\treturn system_clock::to_time_t(sctp);\n}\n\nstd::string DataSource::getVersionFromURI(const std::string &uriString) {\n\tfs::path p(uriString);\n\n\n\n\tif (exists(p)) {\n\t\tstd::ostringstream oss;\n\t\tauto stamp = last_write_time(p);\n\t\tauto tt = to_time_t(stamp);\n\t\tauto tm = *std::localtime(&tt);\n\t\toss << std::put_time(&tm, \"%c\");\n\t\treturn oss.str();\n\t}\n\n\n\tauto versionString = p.parent_path().filename();\n\tif (isVersionString(versionString)) {\n\t\treturn versionString;\n\t}\n\n\n\n\t{\n\t\tstd::ostringstream oss;\n\t\tauto t = std::time(nullptr);\n\t\tauto tm = *std::localtime(&t);\n\t\toss << std::put_time(&tm, \"%d-%m-%Y\");\n\t\treturn oss.str();\n\t}\n}\n\nbool DataSource::isVersionString(const std::string &versionString) {\n\n\tqi::rule<std::string::const_iterator> numbers = (\n\t\t\t(+qi::digit >> '.' >> +qi::digit >> '.' >> +qi::digit) |\n\t\t\t(+qi::digit >> '.' >> +qi::digit));\n\n\tauto first = versionString.begin();\n\tauto last = versionString.end();\n\tbool r = qi::phrase_parse(first,\n\t\t\t\t\t\t\t  last,\n\t\t\t\t\t\t\t  (('v' >> numbers) | numbers),\n\t\t\t\t\t\t\t  ascii::space);\n\n\treturn (first == last && r);\n}\n\nstatic bool isOntologySourceType(\n\t\tconst std::string &format,\n\t\tconst boost::optional<std::string> &language,\n\t\tconst boost::optional<std::string> &type) {\n\tif (type && (type.value() == DATA_SOURCE_TYPE_ONTOLOGY || type.value() == DATA_SOURCE_TYPE_SPARQL)) return true;\n\tif (language && semweb::isOntologyLanguageString(language.value())) return true;\n\tif (semweb::isTripleFormatString(format)) return true;\n\treturn false;\n}\n\nDataSourcePtr DataSource::create(const VocabularyPtr &vocabulary, const boost::property_tree::ptree &config) {\n\tstatic const std::string formatDefault = {};\n\n\n\tURI dataSourceURI(config);\n\tauto dataSourceFormat = config.get(DATA_SOURCE_SETTING_FORMAT, formatDefault);\n\tauto o_dataSourceLanguage = config.get_optional<std::string>(DATA_SOURCE_SETTING_LANG);\n\tauto o_type = config.get_optional<std::string>(DATA_SOURCE_SETTING_TYPE);\n\tauto isOntology = isOntologySourceType(dataSourceFormat, o_dataSourceLanguage, o_type);\n\n\tauto o_tripleFrame = config.get_child_optional(DATA_SOURCE_SETTING_FRAME);\n\tstd::shared_ptr<GraphSelector> tripleFrame;\n\tif (o_tripleFrame) {\n\t\ttripleFrame = std::make_shared<GraphSelector>();\n\t\ttripleFrame->set(*o_tripleFrame);\n\t}\n\n\tif (isOntology && o_type && o_type.value() == DATA_SOURCE_TYPE_SPARQL) {\n\t\tauto sparqlService = std::make_shared<SPARQLService>(dataSourceURI, dataSourceFormat);\n\t\tif (tripleFrame) {\n\t\t\tsparqlService->setFrame(tripleFrame);\n\t\t}\n\t\treturn sparqlService;\n\t} else if (isOntology) {\n\t\tauto ontoFile = std::make_shared<OntologyFile>(vocabulary, dataSourceURI, dataSourceFormat);\n\t\tif (o_dataSourceLanguage.has_value()) {\n\t\t\tontoFile->setOntologyLanguage(semweb::ontologyLanguageFromString(o_dataSourceLanguage.value()));\n\t\t}\n\t\tif (tripleFrame) {\n\t\t\tontoFile->setFrame(tripleFrame);\n\t\t}\n\t\treturn ontoFile;\n\t} else {\n\t\treturn std::make_shared<DataSource>(dataSourceURI, dataSourceFormat, DataSourceType::UNSPECIFIED);\n\t}\n}\n\nnamespace knowrob::py {\n\ttemplate<>\n\tvoid createType<DataSource>() {\n\t\tusing namespace boost::python;\n\t\tclass_<DataSource, std::shared_ptr<DataSource>>\n\t\t\t\t(\"DataSource\", no_init)\n\t\t\t\t.def(\"format\", &DataSource::format, return_value_policy<copy_const_reference>())\n\t\t\t\t.def(\"uri\", &DataSource::uri, return_value_policy<copy_const_reference>())\n\t\t\t\t.def(\"path\", &DataSource::path, return_value_policy<copy_const_reference>())\n\t\t\t\t.def(\"version\", &DataSource::version)\n\t\t\t\t.def(\"name\", &DataSource::name)\n\t\t\t\t.def(\"dataSourceType\", &DataSource::dataSourceType)\n\t\t\t\t.def(\"isVersionString\", &DataSource::isVersionString)\n\t\t\t\t.staticmethod(\"isVersionString\")\n\t\t\t\t.def(\"getNameFromURI\", &DataSource::getNameFromURI)\n\t\t\t\t.staticmethod(\"getNameFromURI\")\n\t\t\t\t.def(\"getVersionFromURI\", &DataSource::getVersionFromURI)\n\t\t\t\t.staticmethod(\"getVersionFromURI\")\n\t\t\t\t.def(\"create\", &DataSource::create)\n\t\t\t\t.staticmethod(\"create\");\n\t}\n}\n",
        "gt": [
            "'knowrob/include/knowrob/plugins/PluginFactory.h'",
            "'knowrob/include/knowrob/storage/Storage.h'",
            "'knowrob/include/knowrob/storage/redland/RedlandModel.h'",
            "'knowrob/include/knowrob/semweb/SPARQLService.h'",
            "'knowrob/src/DataSource.cpp'"
        ]
    },
    {
        "files": [
            "'gmmloc/gmmloc/include/gmmloc/types/keyframe.h'",
            "'gmmloc/gmmloc/include/gmmloc/types/map.h'",
            "'gmmloc/orb_dbow2/include/orb_dbow2/dbow2/BowVector.h'",
            "'gmmloc/gmmloc/src/modules/tracking.cpp'"
        ],
        "content": "'gmmloc/gmmloc/include/gmmloc/types/keyframe.h'\n:#pragma once\n\n#include <mutex>\n#include <set>\n\n#include \"orb_dbow2/dbow2/BowVector.h\"\n#include \"orb_dbow2/dbow2/FeatureVector.h\"\n\n#include \"frame.h\"\n#include \"mappoint.h\"\n\n#include \"../gmm/gaussian_mixture.h\"\n\nnamespace gmmloc {\n\nclass MapPoint;\nclass Frame;\nclass Map;\n\nstruct ErrorResult {\n  bool is_projection_valid = true;\n\n  bool is_stereo = false;\n\n  double err = 0.0;\n};\n\nclass KeyFrame {\n  friend class Map;\n\npublic:\n\n\n  KeyFrame(Frame &F);\n\n  void updateConnections();\n\n  void addConnection(KeyFrame *kf_ptr, const int &weight);\n\n  void removeConnection(KeyFrame *kf_ptr);\n\n  std::vector<KeyFrame *> getVectorCovisibleKeyFrames();\n  std::vector<KeyFrame *> getBestCovisibilityKeyFrames(const int &N);\n  std::vector<KeyFrame *> getCovisiblesByWeight(const int &w);\n\n  void updateBestCovisibles();\n  KeyFrame *getBestCovisibilityKeyFrame();\n\n  void addObservation(MapPoint *mappt, const size_t &idx);\n\n  void removeObservation(const size_t &idx);\n\n  void removeObservation(MapPoint *mappt);\n\n  void replaceObservation(const size_t &idx, MapPoint *mappt);\n\n  std::vector<MapPoint *> getMapPoints();\n\n  int countMapPoints(const int &minum_obs_);\n\n  MapPoint *getMapPoint(const size_t &idx);\n\n  bool project3(const Vector3d &pt, Vector2d *uv);\n\n  bool project3(const Vector3d &pt, Vector3d *uvr);\n\n  bool unproject3(size_t idx, Vector3d *pt3d);\n\n  ErrorResult projectionError(const Vector3d &pt, size_t idx);\n\n  std::vector<size_t> getFeaturesInArea(const float &x, const float &y,\n                                        const float &r) const;\n\npublic:\n  static long unsigned int next_idx_;\n  long unsigned int idx_;\n  const long unsigned int frame_idx_;\n\n  const double timestamp_;\n\n  std::atomic_bool not_valid_;\n\n  PinholeCamera *camera_ = nullptr;\n\n\n  long unsigned int ba_local_kf_ = 0;\n  long unsigned int fixed_kf_idx_ba = 0;\n\n  const float mbf, mb;\n\n  const size_t num_feats_;\n\n  const std::vector<Feature> features_;\n\n  DBoW2::BowVector bow_vec_;\n  DBoW2::FeatureVector feat_vec_;\n\npublic:\n  const SE3Quat getTcw();\n\n  const SE3Quat getTwc();\n\n  void setTcw(const SE3Quat &T_c_w);\n\n  void setTwc(const SE3Quat &T_w_c);\n\nprotected:\n  SE3QuatPtr T_c_w_, T_w_c_;\n\n  std::vector<MapPoint *> mappoints_;\n\n  std::vector<std::vector<std::vector<size_t>>> grid_;\n\n  std::unordered_map<KeyFrame *, int> map_frame_weights_;\n  std::vector<KeyFrame *> ordered_keyframes_;\n  std::vector<int> ordered_weights_;\n\n  KeyFrame *best_cov_kf_ = nullptr;\n\n  std::shared_mutex mutex_pose_;\n  std::mutex mutex_connections_;\n  std::mutex mutex_attr_;\n\npublic:\n  std::vector<GaussianComponents2d> comps_;\n};\n\n}\n\n'gmmloc/gmmloc/include/gmmloc/types/map.h'\n:#pragma once\n\n#include <mutex>\n#include <set>\n\n#include \"frame.h\"\n\n#include \"keyframe.h\"\n#include \"mappoint.h\"\n\n#include \"../gmm/gaussian_mixture.h\"\n\nnamespace gmmloc {\n\nclass MapPoint;\nclass KeyFrame;\nclass Frame;\n\n\nstruct FrameInfo {\n\n\n  double timestamp;\n\n  KeyFrame *ref = nullptr;\n\n  SE3QuatPtr Trc;\n};\n\nstruct StrOptStat {\n  EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n  bool res = false;\n  double chi2_proj, chi2_str;\n  Vector3d pt_est;\n};\n\nenum StrOptResult {\n\n};\n\nclass Map {\npublic:\n\n\n  Map() = default;\n\n  void addKeyFrame(KeyFrame *kf_ptr);\n\n  void addObservation(MapPoint *mappt);\n\n  void insertMapPoint(MapPoint *mappt);\n\n  void insertKeyFrame(KeyFrame *kf);\n\n  void removeMapPoint(MapPoint *mappt);\n\n  void removeKeyFrame(KeyFrame *kf);\n\n  void updateLastFrame(Frame *last_frame);\n\n  void updateFrameInfo(Frame *curr_frame);\n\n  void replaceMapPoint(MapPoint *mp_src, MapPoint *mp_tgt);\n\n  void setGMMMap(GMM::Ptr model) { gmm_map_ = model; }\n\n\n  std::vector<KeyFrame *> getAllKeyFrames();\n  std::vector<MapPoint *> getAllMapPoints();\n\n  long unsigned int countMapPoints();\n  long unsigned countKeyFrames();\n\n  void clear();\n\n  void summarize();\n\n  void setTrajectory(const eigen_aligned_std_vector<Quaterniond> &rot,\n                     const eigen_aligned_std_vector<Vector3d> &trans);\n\nprotected:\n  std::set<MapPoint *> mappoints_;\n  std::set<KeyFrame *> keyframes_;\n\n  std::mutex mutex_info_;\n\n  std::vector<FrameInfo *> frame_info_;\n  std::vector<SE3QuatConstPtr> gt_traj_;\n\n  long unsigned int max_kf_idx_ = 0;\n\n  std::mutex mutex_map_;\n\n  GMM::Ptr gmm_map_ = nullptr;\n};\n\n}\n\n'gmmloc/orb_dbow2/include/orb_dbow2/dbow2/BowVector.h'\n:\n\n#ifndef __D_T_BOW_VECTOR__\n#define __D_T_BOW_VECTOR__\n\n#include <iostream>\n#include <map>\n#include <vector>\n\n#include \"../dutils/config.h\"\n\nnamespace DBoW2 {\n\n\ntypedef unsigned int WordId;\n\n\ntypedef double WordValue;\n\n\ntypedef unsigned int NodeId;\n\n\nEXPORT typedef enum LNorm\n{\n  L1,\n  L2\n} LNorm;\n\n\nEXPORT typedef enum WeightingType\n{\n  TF_IDF,\n  TF,\n  IDF,\n  BINARY\n} WeightingType;\n\n\nEXPORT typedef enum ScoringType\n{\n  L1_NORM,\n  L2_NORM,\n  CHI_SQUARE,\n  KL,\n  BHATTACHARYYA,\n  DOT_PRODUCT,\n} ScoringType;\n\n\n\nclass EXPORT BowVector:\n\tpublic std::map<WordId, WordValue>\n{\npublic:\n\n\n\tBowVector(void);\n\n\n\t~BowVector(void);\n\n\n\tvoid addWeight(WordId id, WordValue v);\n\n\n\tvoid addIfNotExist(WordId id, WordValue v);\n\n\n\tvoid normalize(LNorm norm_type);\n\n\n\tfriend std::ostream& operator<<(std::ostream &out, const BowVector &v);\n\n\n\tvoid saveM(const std::string &filename, size_t W) const;\n};\n\n}\n\n#endif\n\n'gmmloc/gmmloc/src/modules/tracking.cpp'\n:#include \"gmmloc/modules/tracking.h\"\n\n#include <opencv2/core/core.hpp>\n#include <opencv2/features2d/features2d.hpp>\n\n#include <cmath>\n#include <iostream>\n#include <mutex>\n\n#include <unordered_set>\n\n#include \"gmmloc/config.h\"\n#include \"gmmloc/global.h\"\n\n#include \"gmmloc/types/map.h\"\n\n#include \"gmmloc/cv/orb_matcher.h\"\n\n#include \"gmmloc/utils/timing.h\"\n\nnamespace gmmloc {\n\nusing namespace std;\n\nTracking::Tracking() {}\n\nvoid Tracking::initialize(Frame *init_frame) {\n\n  last_frame_ = init_frame;\n\n  ref_keyframe_ = init_frame->ref_keyframe_;\n  local_keyframes_.push_back(ref_keyframe_);\n}\n\nTrackStat Tracking::track(Frame *frame) {\n  CHECK_NOTNULL(last_frame_);\n\n  curr_frame_ = frame;\n\n  LOG(INFO) << last_frame_->num_feats_;\n\n  updateLastFrame();\n\n  if (!last_frame_->is_keyframe_) {\n    createTemporalPoints();\n  }\n\n\n  stat_.res = true;\n  {\n    int num_matches = trackWithMotionModel();\n\n    if (num_matches < 10) {\n      stat_.num_match_inliers = 10;\n      stat_.res = false;\n\n      LOG(ERROR) << \"tracking failure..\";\n    }\n  }\n\n\n  if (!stat_.res) {\n    int num_matches = trackKeyFrame();\n\n    if (num_matches < 10) {\n      stat_.num_match_inliers = 10;\n      stat_.res = false;\n\n      LOG(ERROR) << \"tracking failure..\";\n      return stat_;\n    }\n  }\n\n  curr_frame_->ref_keyframe_ = ref_keyframe_;\n  {\n\n    updateLocalMap();\n\n    searchLocalPoints();\n\n    int num_matches = trackLocalMap();\n    stat_.num_match_inliers = num_matches;\n  }\n\n\n  {\n\n    int num_map = 0;\n    int num_total = 0;\n    for (size_t i = 0; i < curr_frame_->num_feats_; i++) {\n      if (curr_frame_->features_[i].depth > 0 &&\n          curr_frame_->features_[i].depth < frame::th_depth) {\n        num_total++;\n        if (curr_frame_->mappoints_[i]) {\n          if (curr_frame_->mappoints_[i]->countObservations() > 0) {\n            num_map++;\n          }\n        }\n      }\n    }\n\n    stat_.ratio_map = (float)num_map / (float)(std::max(1, num_total));\n  }\n\n  clearTemporalPoints();\n\n  for (size_t i = 0; i < curr_frame_->num_feats_; i++) {\n    if (curr_frame_->mappoints_[i] && curr_frame_->is_outlier_[i]) {\n      curr_frame_->mappoints_[i] = nullptr;\n    }\n  }\n\n  last_frame_ = curr_frame_;\n  LOG(INFO) << last_frame_ << endl;\n\n  return stat_;\n}\n\nvoid Tracking::updateLocalMap() {\n  LOG(INFO) << \"update local map\";\n\n\n  {\n    unordered_set<KeyFrame *> set_local_kfs;\n    unordered_map<KeyFrame *, int> kf_counter;\n\n    for (size_t i = 0; i < curr_frame_->num_feats_; i++) {\n      if (curr_frame_->mappoints_[i]) {\n        MapPoint *mappt = curr_frame_->mappoints_[i];\n        if (!mappt->not_valid_) {\n          const unordered_map<KeyFrame *, size_t> observations =\n              mappt->getObservations();\n          for (unordered_map<KeyFrame *, size_t>::const_iterator\n                   it = observations.begin(),\n                   itend = observations.end();\n               it != itend; it++)\n            kf_counter[it->first]++;\n        } else {\n          curr_frame_->mappoints_[i] = nullptr;\n        }\n      }\n    }\n\n    if (kf_counter.empty())\n      return;\n\n    int max = 0;\n    KeyFrame *kf_max = nullptr;\n\n    local_keyframes_.clear();\n\n    for (auto &&it : kf_counter) {\n      KeyFrame *kf_ptr = it.first;\n\n      if (kf_ptr->not_valid_)\n        continue;\n\n      if (it.second > max) {\n        max = it.second;\n        kf_max = kf_ptr;\n      }\n\n      set_local_kfs.emplace(it.first);\n    }\n\n    for (auto &&kf_ptr : set_local_kfs) {\n      if (set_local_kfs.size() > 80)\n        break;\n\n      const vector<KeyFrame *> neigh_kfs =\n          kf_ptr->getBestCovisibilityKeyFrames(10);\n      for (auto &&neigh_kf : neigh_kfs) {\n        if (!neigh_kf->not_valid_) {\n          if (set_local_kfs.count(neigh_kf)) {\n            set_local_kfs.emplace(neigh_kf);\n            break;\n          }\n        }\n      }\n    }\n\n    if (kf_max) {\n      ref_keyframe_ = kf_max;\n      curr_frame_->ref_keyframe_ = ref_keyframe_;\n    }\n\n    local_keyframes_.assign(set_local_kfs.begin(), set_local_kfs.end());\n  }\n\n\n  {\n\n    unordered_set<MapPoint *> set_local_mps;\n    for (auto &&kf_ptr : local_keyframes_) {\n\n      const vector<MapPoint *> mappts = kf_ptr->getMapPoints();\n\n      for (auto &&mappt : mappts) {\n        if (mappt && !mappt->not_valid_ && !set_local_mps.count(mappt)) {\n          set_local_mps.emplace(mappt);\n        }\n      }\n    }\n\n    local_mappoints_.clear();\n    local_mappoints_.assign(set_local_mps.begin(), set_local_mps.end());\n  }\n}\n\nvoid Tracking::searchLocalPoints() {\n  LOG(INFO) << \"search local poinst\";\n\n  for (vector<MapPoint *>::iterator vit = curr_frame_->mappoints_.begin(),\n                                    vend = curr_frame_->mappoints_.end();\n       vit != vend; vit++) {\n    MapPoint *mappt = *vit;\n    if (mappt) {\n      if (mappt->not_valid_) {\n        *vit = nullptr;\n      } else {\n        mappt->num_visible_++;\n        mappt->last_visible_idx_ = curr_frame_->idx_;\n        mappt->is_in_view_ = false;\n      }\n    }\n  }\n\n  int num_to_match = 0;\n\n  Vector3d t_w_c = curr_frame_->T_w_c_->translation();\n\n\n  mappoints_proj_stat.resize(local_mappoints_.size());\n  for (size_t i = 0; i < local_mappoints_.size(); i++) {\n    auto &&mappt = local_mappoints_[i];\n    auto &proj_stat = mappoints_proj_stat[i];\n\n    if (mappt->last_visible_idx_ == curr_frame_->idx_)\n      continue;\n    if (mappt->not_valid_)\n      continue;\n\n    Vector3d uvr;\n    mappt->is_in_view_ = false;\n    if (!curr_frame_->project3(mappt->getPosition(), &uvr)) {\n      continue;\n    }\n\n    if (mappt->checkScaleAndVisible(t_w_c, proj_stat)) {\n      mappt->is_in_view_ = true;\n      proj_stat.uvr = uvr;\n\n      mappt->num_visible_++;\n      num_to_match++;\n    }\n  }\n\n  if (num_to_match > 0) {\n    ORBmatcher matcher(0.8);\n    int th = 3;\n    if (curr_frame_->idx_ < 2)\n      th = 5;\n\n    matcher.searchByProjection(*curr_frame_, local_mappoints_,\n                               mappoints_proj_stat, th);\n  }\n}\n\nint Tracking::trackLocalMap() {\n\n  LOG(INFO) << \"track local map\";\n\n\n  optimizeCurrentPose();\n\n  int num_match_inliers = 0;\n\n\n  for (size_t i = 0; i < curr_frame_->num_feats_; i++) {\n    if (curr_frame_->mappoints_[i]) {\n\n      if (!curr_frame_->is_outlier_[i]) {\n        curr_frame_->mappoints_[i]->num_found_++;\n\n        if (curr_frame_->mappoints_[i]->countObservations() > 0) {\n          num_match_inliers++;\n        }\n      } else {\n        curr_frame_->mappoints_[i] = nullptr;\n      }\n    }\n  }\n\n  return num_match_inliers;\n}\n\nint Tracking::trackKeyFrame() {\n  ORBVocabulary::transform(curr_frame_);\n\n  ORBmatcher matcher(0.7, true);\n  vector<MapPoint *> mappts;\n\n  int nmatches = matcher.searchByBoW(ref_keyframe_, *curr_frame_, mappts);\n\n  if (nmatches < 15) {\n    LOG(ERROR) << \"not enough match\";\n  }\n\n  curr_frame_->mappoints_ = mappts;\n  curr_frame_->setTcw(last_frame_->getTcw());\n\n  optimizeCurrentPose();\n\n\n  int num_matches_map = 0;\n  for (size_t i = 0; i < curr_frame_->num_feats_; i++) {\n    if (curr_frame_->mappoints_[i]) {\n      if (curr_frame_->is_outlier_[i]) {\n        MapPoint *mappt = curr_frame_->mappoints_[i];\n\n        curr_frame_->mappoints_[i] = nullptr;\n        curr_frame_->is_outlier_[i] = false;\n        mappt->is_in_view_ = false;\n        mappt->last_visible_idx_ = curr_frame_->idx_;\n        nmatches--;\n      } else if (curr_frame_->mappoints_[i]->countObservations() > 0)\n        num_matches_map++;\n    }\n  }\n\n  return num_matches_map;\n}\n\nint Tracking::trackWithMotionModel() {\n  LOG(INFO) << \"track with motion model\";\n  ORBmatcher matcher(0.9, true);\n\n  const int th = 7;\n  int nmatches =\n      matcher.searchByProjection(*curr_frame_, *last_frame_, th, false);\n\n  LOG(INFO) << \"search done. #matches: \" << nmatches;\n\n\n  if (nmatches < 20) {\n    fill(curr_frame_->mappoints_.begin(), curr_frame_->mappoints_.end(),\n         nullptr);\n    nmatches = matcher.searchByProjection(*curr_frame_, *last_frame_, 2 * th,\n                                          false);\n  }\n\n  if (nmatches < 20)\n    return false;\n\n\n  optimizeCurrentPose();\n\n  LOG(INFO) << \"opt done.\";\n  int num_matches_map = 0;\n  for (size_t i = 0; i < curr_frame_->num_feats_; i++) {\n    if (curr_frame_->mappoints_[i]) {\n      if (curr_frame_->is_outlier_[i]) {\n        MapPoint *mappt = curr_frame_->mappoints_[i];\n\n        curr_frame_->mappoints_[i] = nullptr;\n        curr_frame_->is_outlier_[i] = false;\n        mappt->is_in_view_ = false;\n        mappt->last_visible_idx_ = curr_frame_->idx_;\n        nmatches--;\n      } else if (curr_frame_->mappoints_[i]->countObservations() > 0)\n        num_matches_map++;\n    }\n  }\n\n  LOG(INFO) << \"motion model num matches: \" << num_matches_map;\n  return num_matches_map;\n}\n\nvoid Tracking::clearTemporalPoints() {\n\n  for (size_t i = 0; i < curr_frame_->num_feats_; i++) {\n    MapPoint *mappt = curr_frame_->mappoints_[i];\n    if (mappt)\n      if (mappt->countObservations() < 1) {\n        curr_frame_->is_outlier_[i] = false;\n        curr_frame_->mappoints_[i] = nullptr;\n      }\n  }\n\n  for (MapPoint *mp : temp_pts_) {\n    delete mp;\n  }\n\n  temp_pts_.clear();\n}\n\nvoid Tracking::updateLastFrame() {\n  for (size_t i = 0; i < last_frame_->num_feats_; i++) {\n    MapPoint *mp = last_frame_->mappoints_[i];\n\n    if (mp) {\n      MapPoint *rep = mp->getReplaced();\n      if (rep) {\n        last_frame_->mappoints_[i] = rep;\n      }\n    }\n  }\n}\n\n\nvoid Tracking::createTemporalPoints() {\n  LOG(INFO) << \"create temproal points\";\n\n  if (last_frame_->is_keyframe_) {\n    return;\n  }\n\n  vector<pair<float, int>> depth_indices;\n\n  for (size_t i = 0; i < last_frame_->num_feats_; i++) {\n    float z = last_frame_->features_[i].depth;\n    if (z > 0) {\n      depth_indices.push_back(make_pair(z, i));\n    }\n  }\n\n  if (depth_indices.empty())\n    return;\n\n  std::sort(depth_indices.begin(), depth_indices.end());\n\n  int num_pts = 0;\n  for (size_t j = 0; j < depth_indices.size(); j++) {\n    int i = depth_indices[j].second;\n\n    bool create_new = false;\n\n    MapPoint *mappt = last_frame_->mappoints_[i];\n    if (!mappt)\n      create_new = true;\n    else if (mappt->countObservations() < 1) {\n      create_new = true;\n    }\n\n    if (create_new) {\n      const auto &feat = last_frame_->features_[i];\n      if (feat.depth > 0.0f) {\n        Vector3d pt3d, ptc;\n        last_frame_->camera_->unproject3(feat.uv, feat.depth, &ptc);\n        pt3d = last_frame_->getTwc().map(ptc);\n        MapPoint *new_mappt = new MapPoint(pt3d, last_frame_, i);\n\n        last_frame_->mappoints_[i] = new_mappt;\n\n        temp_pts_.push_back(new_mappt);\n      }\n      num_pts++;\n    } else {\n      num_pts++;\n    }\n\n    if (depth_indices[j].first > frame::th_depth && num_pts > 100)\n      break;\n  }\n}\n\n}\n",
        "gt": [
            "'gmmloc/orb_dbow2/include/orb_dbow2/dbow2/BowVector.h'",
            "'gmmloc/gmmloc/include/gmmloc/types/keyframe.h'",
            "'gmmloc/gmmloc/include/gmmloc/types/map.h'",
            "'gmmloc/gmmloc/src/modules/tracking.cpp'"
        ]
    },
    {
        "files": [
            "'query-pdb/thirdparty/spdlog/include/spdlog/details/file_helper.h'",
            "'query-pdb/thirdparty/spdlog/bench/async_bench.cpp'",
            "'query-pdb/thirdparty/spdlog/include/spdlog/sinks/basic_file_sink.h'"
        ],
        "content": "'query-pdb/thirdparty/spdlog/include/spdlog/details/file_helper.h'\n:\n\n\n#pragma once\n\n#include <spdlog/common.h>\n#include <tuple>\n\nnamespace spdlog {\nnamespace details {\n\n\n\n\n\nclass SPDLOG_API file_helper\n{\npublic:\n    file_helper() = default;\n    explicit file_helper(const file_event_handlers &event_handlers);\n\n    file_helper(const file_helper &) = delete;\n    file_helper &operator=(const file_helper &) = delete;\n    ~file_helper();\n\n    void open(const filename_t &fname, bool truncate = false);\n    void reopen(bool truncate);\n    void flush();\n    void sync();\n    void close();\n    void write(const memory_buf_t &buf);\n    size_t size() const;\n    const filename_t &filename() const;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    static std::tuple<filename_t, filename_t> split_by_extension(const filename_t &fname);\n\nprivate:\n    const int open_tries_ = 5;\n    const unsigned int open_interval_ = 10;\n    std::FILE *fd_{nullptr};\n    filename_t filename_;\n    file_event_handlers event_handlers_;\n};\n}\n}\n\n#ifdef SPDLOG_HEADER_ONLY\n#    include \"file_helper-inl.h\"\n#endif\n\n'query-pdb/thirdparty/spdlog/bench/async_bench.cpp'\n:\n\n\n\n\n\n\n\n#include \"spdlog/spdlog.h\"\n#include \"spdlog/async.h\"\n#include \"spdlog/sinks/basic_file_sink.h\"\n\n#if defined(SPDLOG_USE_STD_FORMAT)\n#    include <format>\n#elif defined(SPDLOG_FMT_EXTERNAL)\n#    include <fmt/format.h>\n#else\n#    include \"spdlog/fmt/bundled/format.h\"\n#endif\n\n#include \"utils.h\"\n#include <atomic>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <thread>\n\nusing namespace std;\nusing namespace std::chrono;\nusing namespace spdlog;\nusing namespace spdlog::sinks;\nusing namespace utils;\n\nvoid bench_mt(int howmany, std::shared_ptr<spdlog::logger> log, int thread_count);\n\n#ifdef _MSC_VER\n#    pragma warning(push)\n#    pragma warning(disable : 4996)\n#endif\n\nint count_lines(const char *filename)\n{\n    int counter = 0;\n    auto *infile = fopen(filename, \"r\");\n    int ch;\n    while (EOF != (ch = getc(infile)))\n    {\n        if ('\\n' == ch)\n            counter++;\n    }\n    fclose(infile);\n\n    return counter;\n}\n\nvoid verify_file(const char *filename, int expected_count)\n{\n    spdlog::info(\"Verifying {} to contain {} line..\", filename, expected_count);\n    auto count = count_lines(filename);\n    if (count != expected_count)\n    {\n        spdlog::error(\"Test failed. {} has {} lines instead of {}\", filename, count, expected_count);\n        exit(1);\n    }\n    spdlog::info(\"Line count OK ({})\\n\", count);\n}\n\n#ifdef _MSC_VER\n#    pragma warning(pop)\n#endif\n\nint main(int argc, char *argv[])\n{\n\n    int howmany = 1000000;\n    int queue_size = std::min(howmany + 2, 8192);\n    int threads = 10;\n    int iters = 3;\n\n    try\n    {\n        spdlog::set_pattern(\"[%^%l%$] %v\");\n        if (argc == 1)\n        {\n            spdlog::info(\"Usage: {} <message_count> <threads> <q_size> <iterations>\", argv[0]);\n            return 0;\n        }\n\n        if (argc > 1)\n            howmany = atoi(argv[1]);\n        if (argc > 2)\n            threads = atoi(argv[2]);\n        if (argc > 3)\n        {\n            queue_size = atoi(argv[3]);\n            if (queue_size > 500000)\n            {\n                spdlog::error(\"Max queue size allowed: 500,000\");\n                exit(1);\n            }\n        }\n\n        if (argc > 4)\n            iters = atoi(argv[4]);\n\n        auto slot_size = sizeof(spdlog::details::async_msg);\n        spdlog::info(\"-------------------------------------------------\");\n        spdlog::info(\"Messages     : {:L}\", howmany);\n        spdlog::info(\"Threads      : {:L}\", threads);\n        spdlog::info(\"Queue        : {:L} slots\", queue_size);\n        spdlog::info(\"Queue memory : {:L} x {:L} = {:L} KB \", queue_size, slot_size, (queue_size * slot_size) / 1024);\n        spdlog::info(\"Total iters  : {:L}\", iters);\n        spdlog::info(\"-------------------------------------------------\");\n\n        const char *filename = \"logs/basic_async.log\";\n        spdlog::info(\"\");\n        spdlog::info(\"*********************************\");\n        spdlog::info(\"Queue Overflow Policy: block\");\n        spdlog::info(\"*********************************\");\n        for (int i = 0; i < iters; i++)\n        {\n            auto tp = std::make_shared<details::thread_pool>(queue_size, 1);\n            auto file_sink = std::make_shared<spdlog::sinks::basic_file_sink_mt>(filename, true);\n            auto logger = std::make_shared<async_logger>(\"async_logger\", std::move(file_sink), std::move(tp), async_overflow_policy::block);\n            bench_mt(howmany, std::move(logger), threads);\n\n        }\n\n        spdlog::info(\"\");\n        spdlog::info(\"*********************************\");\n        spdlog::info(\"Queue Overflow Policy: overrun\");\n        spdlog::info(\"*********************************\");\n\n        filename = \"logs/basic_async-overrun.log\";\n        for (int i = 0; i < iters; i++)\n        {\n            auto tp = std::make_shared<details::thread_pool>(queue_size, 1);\n            auto file_sink = std::make_shared<spdlog::sinks::basic_file_sink_mt>(filename, true);\n            auto logger =\n                std::make_shared<async_logger>(\"async_logger\", std::move(file_sink), std::move(tp), async_overflow_policy::overrun_oldest);\n            bench_mt(howmany, std::move(logger), threads);\n        }\n        spdlog::shutdown();\n    }\n    catch (std::exception &ex)\n    {\n        std::cerr << \"Error: \" << ex.what() << std::endl;\n        perror(\"Last error\");\n        return 1;\n    }\n    return 0;\n}\n\nvoid thread_fun(std::shared_ptr<spdlog::logger> logger, int howmany)\n{\n    for (int i = 0; i < howmany; i++)\n    {\n        logger->info(\"Hello logger: msg number {}\", i);\n    }\n}\n\nvoid bench_mt(int howmany, std::shared_ptr<spdlog::logger> logger, int thread_count)\n{\n    using std::chrono::high_resolution_clock;\n    vector<std::thread> threads;\n    auto start = high_resolution_clock::now();\n\n    int msgs_per_thread = howmany / thread_count;\n    int msgs_per_thread_mod = howmany % thread_count;\n    for (int t = 0; t < thread_count; ++t)\n    {\n        if (t == 0 && msgs_per_thread_mod)\n            threads.push_back(std::thread(thread_fun, logger, msgs_per_thread + msgs_per_thread_mod));\n        else\n            threads.push_back(std::thread(thread_fun, logger, msgs_per_thread));\n    }\n\n    for (auto &t : threads)\n    {\n        t.join();\n    };\n\n    auto delta = high_resolution_clock::now() - start;\n    auto delta_d = duration_cast<duration<double>>(delta).count();\n    spdlog::info(\"Elapsed: {} secs\\t {:L}/sec\", delta_d, int(howmany / delta_d));\n}\n\n'query-pdb/thirdparty/spdlog/include/spdlog/sinks/basic_file_sink.h'\n:\n\n\n#pragma once\n\n#include <spdlog/details/file_helper.h>\n#include <spdlog/details/null_mutex.h>\n#include <spdlog/sinks/base_sink.h>\n#include <spdlog/details/synchronous_factory.h>\n\n#include <mutex>\n#include <string>\n\nnamespace spdlog {\nnamespace sinks {\n\ntemplate<typename Mutex>\nclass basic_file_sink final : public base_sink<Mutex>\n{\npublic:\n    explicit basic_file_sink(const filename_t &filename, bool truncate = false, const file_event_handlers &event_handlers = {});\n    const filename_t &filename() const;\n\nprotected:\n    void sink_it_(const details::log_msg &msg) override;\n    void flush_() override;\n\nprivate:\n    details::file_helper file_helper_;\n};\n\nusing basic_file_sink_mt = basic_file_sink<std::mutex>;\nusing basic_file_sink_st = basic_file_sink<details::null_mutex>;\n\n}\n\n\n\n\ntemplate<typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> basic_logger_mt(\n    const std::string &logger_name, const filename_t &filename, bool truncate = false, const file_event_handlers &event_handlers = {})\n{\n    return Factory::template create<sinks::basic_file_sink_mt>(logger_name, filename, truncate, event_handlers);\n}\n\ntemplate<typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> basic_logger_st(\n    const std::string &logger_name, const filename_t &filename, bool truncate = false, const file_event_handlers &event_handlers = {})\n{\n    return Factory::template create<sinks::basic_file_sink_st>(logger_name, filename, truncate, event_handlers);\n}\n\n}\n\n#ifdef SPDLOG_HEADER_ONLY\n#    include \"basic_file_sink-inl.h\"\n#endif\n",
        "gt": [
            "'query-pdb/thirdparty/spdlog/include/spdlog/details/file_helper.h'",
            "'query-pdb/thirdparty/spdlog/include/spdlog/sinks/basic_file_sink.h'",
            "'query-pdb/thirdparty/spdlog/bench/async_bench.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/EndpointDescription.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/DiscoveryService.cpp'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/UserTokenPolicy.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/GetEndpointsResponse.h'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackCore/ServiceSet/EndpointDescription.h'\n:\n\n#ifndef __OpcUaStackCore_EndpointDescription_h__\n#define __OpcUaStackCore_EndpointDescription_h__\n\n#include <stdint.h>\n#include <map>\n#include <vector>\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaBaseEnums.h\"\n#include \"OpcUaStackCore/SecureChannel/ApplicationInstanceCertificate.h\"\n#include \"OpcUaStackCore/ServiceSet/ApplicationDescription.h\"\n#include \"OpcUaStackCore/ServiceSet/UserTokenPolicy.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT EndpointDescription\n\t: public  Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<EndpointDescription> SPtr;\n\t\ttypedef std::multimap<std::string, EndpointDescription::SPtr> Multimap;\n\t\ttypedef std::vector<EndpointDescription::SPtr> Vec;\n\n\t\tEndpointDescription(void);\n\t\tEndpointDescription(const EndpointDescription& endpointDescription);\n\t\tvirtual ~EndpointDescription(void);\n\n\t\tvoid endpointUrl(const std::string& endpointUrl);\n\t\tstd::string endpointUrl(void) const;\n\t\tvoid applicationDescription(const ApplicationDescription::SPtr applicationDescription);\n\t\tApplicationDescription::SPtr applicationDescription(void) const;\n\t\tvoid serverCertificate(const OpcUaByte* buf, OpcUaInt32 bufLen);\n\t\tvoid serverCertificate(OpcUaByte** buf, OpcUaInt32* bufLen) const;\n\t\tvoid messageSecurityMode(const SecurityMode securityMode);\n\t\tSecurityMode messageSecurityMode(void) const;\n\t\tvoid securityPolicyUri(const std::string& securityPolicyUri);\n\t\tstd::string securityPolicyUri(void) const;\n\t\tvoid securityPolicy(const SecurityPolicy securityPolicy);\n\t\tSecurityPolicy securityPolicy(void) const;\n\t\tvoid userIdentityTokens(const UserTokenPolicyArray::SPtr userIdentityTokens);\n\t\tUserTokenPolicyArray::SPtr userIdentityTokens(void) const;\n\t\tvoid transportProfileUri(const std::string& transportProfileUri);\n\t\tstd::string transportProfileUri(void) const;\n\t\tvoid securityLevel(const OpcUaByte securityLevel);\n\t\tOpcUaByte securityLevel(void) const;\n\n\t\tbool needSecurity(void);\n\n\t\tvoid opcUaBinaryEncode(std::ostream& os) const;\n\t\tvoid opcUaBinaryDecode(std::istream& is);\n\t\tvoid out(std::ostream& os);\n\n\t  private:\n\t\tOpcUaString endpointUrl_;\n\t\tApplicationDescription::SPtr applicationDescription_;\n\t\tOpcUaByteString serverCertificate_;\n\t\tSecurityMode messageSecurityMode_;\n\t\tOpcUaString securityPolicyUri_;\n\t\tUserTokenPolicyArray::SPtr userIdentityTokens_;\n\t\tOpcUaString transportProfileUri_;\n\t\tOpcUaByte securityLevel_;\n\t};\n\n\n\tclass EndpointDescriptionArray\n\t: public OpcUaArray<EndpointDescription::SPtr, SPtrTypeCoder<EndpointDescription> >\n\t, public Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<EndpointDescriptionArray> SPtr;\n\t};\n\n\n\tclass DLLEXPORT EndpointDescriptionSet\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<EndpointDescriptionSet> SPtr;\n\n\t\tEndpointDescriptionSet(void);\n\t\t~EndpointDescriptionSet(void);\n\n\t\tvoid addEndpoint(const std::string& endpointUrl, EndpointDescription::SPtr& endpointDescription);\n\t\tvoid getEndpoints(const std::string& endpointUrl, EndpointDescriptionArray::SPtr& endpointDescriptionArray);\n\t\tvoid getEndpoints(EndpointDescriptionArray::SPtr& endpointDescriptionArray);\n\t\tvoid getEndpointUrls(std::vector<std::string>& endpointUrls);\n\n\t  private:\n\t\tEndpointDescription::Multimap endpointDescriptionMap_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackServer/ServiceSet/DiscoveryService.cpp'\n:\n\n#include \"OpcUaStackCore/BuildInTypes/OpcUaIdentifier.h\"\n#include \"OpcUaStackCore/Base/Log.h\"\n#include \"OpcUaStackCore/SecureChannel/RequestHeader.h\"\n#include \"OpcUaStackCore/SecureChannel/ResponseHeader.h\"\n#include \"OpcUaStackCore/ServiceSet/DiscoveryServiceTransaction.h\"\n#include \"OpcUaStackCore/ServiceSet/GetEndpointsRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/GetEndpointsResponse.h\"\n#include \"OpcUaStackCore/Application/ApplicationRegisterServerContext.h\"\n#include \"OpcUaStackCore/Application/ApplicationFindServerContext.h\"\n#include \"OpcUaStackServer/ServiceSet/DiscoveryService.h\"\n\n\nnamespace OpcUaStackServer\n{\n\n\tDiscoveryService::DiscoveryService(void)\n\t: discoveryIf_(nullptr)\n\t, applicationCertificate_(nullptr)\n\t, endpointDescriptionArray_()\n\t{\n\t}\n\n\tDiscoveryService::~DiscoveryService(void)\n\t{\n\t}\n\n\tvoid\n\tDiscoveryService::discoveryIf(DiscoveryIf* discoveryIf)\n\t{\n\t\tdiscoveryIf_ = discoveryIf;\n\t}\n\n\tvoid\n\tDiscoveryService::endpointDescriptionSet(EndpointDescriptionSet::SPtr& endpointDescriptionSet)\n\t{\n\t\tLog(Debug, \"endpointDescriptionSet\");\n\n\t\tassert(endpointDescriptionSet.get() != nullptr);\n\n\t\tendpointDescriptionArray_ = constructSPtr<EndpointDescriptionArray>();\n\t\tendpointDescriptionSet->getEndpoints(endpointDescriptionArray_);\n\t}\n\n\tvoid\n\tDiscoveryService::applicationCertificate(ApplicationCertificate::SPtr& applicationCertificate)\n\t{\n\t\tLog(Debug, \"applicationCertificate\");\n\n\t\tassert(applicationCertificate.get() != nullptr);\n\n\t\tapplicationCertificate_ = applicationCertificate;\n\n\t\tif (!applicationCertificate_->enable()) {\n\t\t\treturn;\n\t\t}\n\n\t\tCertificate::SPtr& certificate = applicationCertificate->certificate();\n\t\tuint32_t certLen;\n\t\tif (!certificate->toDERBufLen(&certLen)) {\n\t\t\treturn;\n\t\t}\n\t\tchar* certBuf = new char[certLen];\n\t\tif (!certificate->toDERBuf(certBuf, &certLen)) {\n\t\t\tdelete [] certBuf;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (uint32_t idx = 0; idx < endpointDescriptionArray_->size(); idx++) {\n\t\t\tEndpointDescription::SPtr endpointDescription;\n\t\t\tendpointDescriptionArray_->get(idx, endpointDescription);\n\n\t\t\tif (!endpointDescription->needSecurity()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tendpointDescription->serverCertificate((const unsigned char*)certBuf, certLen);\n\t\t}\n\n\t\tdelete [] certBuf;\n\t}\n\n\tvoid\n\tDiscoveryService::getEndpointRequest(\n\t\tRequestHeader::SPtr requestHeader,\n\t\tSecureChannelTransaction::SPtr secureChannelTransaction\n\t)\n\t{\n\t\tassert(requestHeader.get() != nullptr);\n\t\tassert(secureChannelTransaction.get() != nullptr);\n\t\tassert(endpointDescriptionArray_.get() != nullptr);\n\n\t\tLog(Debug, \"receive get endpoint request request\")\n\t\t    .parameter(\"AvailableNumberEndpoints\", endpointDescriptionArray_->size());\n\n\t\tsecureChannelTransaction->responseTypeNodeId_ = OpcUaId_GetEndpointsResponse_Encoding_DefaultBinary;\n\n\t\tstd::iostream is(&secureChannelTransaction->is_);\n\t\tGetEndpointsRequest getEndpointsRequest;\n\n\t\tgetEndpointsRequest.opcUaBinaryDecode(is);\n\n\n\n\t\tstd::iostream os(&secureChannelTransaction->os_);\n\n\t\tResponseHeader responseHeader;\n\t\tGetEndpointsResponse getEndpointsResponse;\n\n\t\tresponseHeader.requestHandle(requestHeader->requestHandle());\n\t\tresponseHeader.serviceResult(Success);\n\t\tgetEndpointsResponse.endpoints(endpointDescriptionArray_);\n\n\t\tresponseHeader.opcUaBinaryEncode(os);\n\t\tgetEndpointsResponse.opcUaBinaryEncode(os);\n\n\t\tif (discoveryIf_ != nullptr) {\n\t\t\tResponseHeader::SPtr responseHeader = getEndpointsResponse.responseHeader();\n\t\t\tdiscoveryIf_->discoveryResponseMessage(responseHeader, secureChannelTransaction);\n\t\t}\n\t}\n\n\tvoid\n\tDiscoveryService::registerServerRequest(\n\t\tRequestHeader::SPtr requestHeader,\n\t\tSecureChannelTransaction::SPtr secureChannelTransaction\n\t)\n\t{\n\t\tLog(Debug, \"receive register server request request\");\n\t\tsecureChannelTransaction->responseTypeNodeId_ = OpcUaId_RegisterServerResponse_Encoding_DefaultBinary;\n\n\t\tstd::iostream is(&secureChannelTransaction->is_);\n\t\tRegisterServerRequest registerServerRequest;\n\n\t\tregisterServerRequest.opcUaBinaryDecode(is);\n\n\n\n\t\tstd::iostream os(&secureChannelTransaction->os_);\n\n\t\tResponseHeader responseHeader;\n\t\tRegisterServerResponse registerServerResponse;\n\n\t\tresponseHeader.requestHandle(requestHeader->requestHandle());\n\n\n\t\tApplicationRegisterServerContext ctx;\n\t\tctx.statusCode_ = BadNotSupported;\n\t\tif (forwardGlobalSync()->registerServerService().isCallback()) {\n\n\n\t\t\tctx.applicationContext_ = forwardGlobalSync()->registerServerService().applicationContext();\n\t\t\tregisterServerRequest.server().copyTo(ctx.server_);\n\t\t\tforwardGlobalSync()->registerServerService().callback()(&ctx);\n\t\t}\n\t\tresponseHeader.serviceResult(ctx.statusCode_);\n\n\t\tresponseHeader.opcUaBinaryEncode(os);\n\t\tregisterServerResponse.opcUaBinaryEncode(os);\n\n\t\tif (discoveryIf_ != nullptr) {\n\t\t\tResponseHeader::SPtr responseHeader = registerServerResponse.responseHeader();\n\t\t\tdiscoveryIf_->discoveryResponseMessage(responseHeader, secureChannelTransaction);\n\t\t}\n\t}\n\n\tvoid\n\tDiscoveryService::findServersRequest(\n\t\tRequestHeader::SPtr requestHeader,\n\t\tSecureChannelTransaction::SPtr secureChannelTransaction\n\t)\n\t{\n\t\tLog(Debug, \"receive find servers request request\");\n\t\tsecureChannelTransaction->responseTypeNodeId_ = OpcUaId_FindServersResponse_Encoding_DefaultBinary;\n\n\t\tstd::iostream is(&secureChannelTransaction->is_);\n\t\tFindServersRequest findServersRequest;\n\n\t\tfindServersRequest.opcUaBinaryDecode(is);\n\n\n\n\t\tstd::iostream os(&secureChannelTransaction->os_);\n\n\t\tResponseHeader responseHeader;\n\t\tFindServersResponse findServersResponse;\n\n\t\tresponseHeader.requestHandle(requestHeader->requestHandle());\n\n\n\t\tApplicationFindServerContext ctx;\n\t\tctx.statusCode_ = BadNotSupported;\n\t\tif (forwardGlobalSync()->findServersService().isCallback()) {\n\n\n\t\t\tctx.applicationContext_ = forwardGlobalSync()->findServersService().applicationContext();\n\t\t\tfindServersRequest.endpointUrl().copyTo(ctx.endpointUrl_);\n\t\t\tctx.localeIdArraySPtr_ = findServersRequest.localeIds();\n\t\t\tctx.serverUriArraySPtr_ = findServersRequest.serverUris();\n\t\t\tforwardGlobalSync()->findServersService().callback()(&ctx);\n\t\t}\n\n\t\tresponseHeader.serviceResult(ctx.statusCode_);\n\t\tif (ctx.statusCode_ == Success) {\n\t\t\tfindServersResponse.servers(ctx.servers_);\n\t\t}\n\n\t\tresponseHeader.opcUaBinaryEncode(os);\n\t\tfindServersResponse.opcUaBinaryEncode(os);\n\n\t\tif (discoveryIf_ != nullptr) {\n\t\t\tResponseHeader::SPtr responseHeader = findServersResponse.responseHeader();\n\t\t\tdiscoveryIf_->discoveryResponseMessage(responseHeader, secureChannelTransaction);\n\t\t}\n\t}\n\n\n\tvoid\n\tDiscoveryService::receive(Message::SPtr message)\n\t{\n#if 0\n\t\tServiceTransaction::SPtr serviceTransaction = boost::static_pointer_cast<ServiceTransaction>(message);\n\t\tswitch (serviceTransaction->nodeTypeRequest().nodeId<uint32_t>())\n\t\t{\n\t\t\tcase OpcUaId_RegisterServerRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveRegisterServerRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tLog(Error, \"discovery service received unknown message type\")\n\t\t\t\t\t.parameter(\"TypeId\", serviceTransaction->nodeTypeRequest());\n\n\t\t\t\tserviceTransaction->statusCode(BadInternalError);\n\t\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t}\n#if 0\n\tvoid\n\tDiscoveryService::receiveRegisterServerRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionRegisterServer::SPtr trx = boost::static_pointer_cast<ServiceTransactionRegisterServer>(serviceTransaction);\n\n\t\tRegisterServerRequest::SPtr registerServerRequest = trx->request();\n\t\tRegisterServerResponse::SPtr registerServerResponse = trx->response();\n\n\t\tLog(Debug, \"discovery service register server request\")\n\t\t\t.parameter(\"Trx\", serviceTransaction->transactionId());\n\n\n\t\tApplicationRegisterServerContext ctx;\n\t\tctx.statusCode_ = BadNotSupported;\n\t\tOpcUaStatusCode statusCode = BadNotSupported;\n\t\tif (forwardGlobalSync()->registerServerService().isCallback()) {\n\n\n\t\t\tctx.applicationContext_ = forwardGlobalSync()->registerServerService().applicationContext();\n\t\t\tregisterServerRequest->server().copyTo(ctx.server_);\n\t\t\tforwardGlobalSync()->registerServerService().callback()(&ctx);\n\t\t}\n\n\t\ttrx->statusCode(ctx.statusCode_);\n\t\ttrx->componentSession()->send(serviceTransaction);\n\t}\n#endif\n\n}\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/UserTokenPolicy.h'\n:\n\n#ifndef __OpcUaStackCore_UserTokenPolicy_h__\n#define __OpcUaStackCore_UserTokenPolicy_h__\n\n#include <stdint.h>\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n\nnamespace OpcUaStackCore\n{\n\n\ttypedef enum {\n\t\tUserIdentityTokenType_Anonymous = 0,\n\t\tUserIdentityTokenType_Username = 1,\n\t\tUserIdentityTokenType_Certificate = 2,\n\t\tUserIdentityTokenType_IssuedToken = 3\n\t} UserIdentityTokenType;\n\n\tclass DLLEXPORT UserTokenPolicy\n\t: public  Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<UserTokenPolicy> SPtr;\n\n\t\tUserTokenPolicy(void);\n\t\tvirtual ~UserTokenPolicy(void);\n\n\t\tvoid policyId(const std::string& policyId);\n\t\tstd::string policyId(void) const;\n\t\tvoid tokenType(const UserIdentityTokenType tokenType);\n\t\tUserIdentityTokenType tokenType(void) const;\n\t\tvoid issuedTokenType(const std::string& issuedTokenType);\n\t\tstd::string issuedTokenType(void) const;\n\t\tvoid issuerEndpointUrl(const std::string& issuerEndpointUrl);\n\t\tstd::string issuerEndpointUrl(void) const;\n\t\tvoid securityPolicyUri(const std::string& securityPolicyUri);\n\t\tstd::string securityPolicyUri(void) const;\n\n\t\tvoid opcUaBinaryEncode(std::ostream& os) const;\n\t\tvoid opcUaBinaryDecode(std::istream& is);\n\n\t  private:\n\t\tOpcUaString policyId_;\n\t\tUserIdentityTokenType tokenType_;\n\t\tOpcUaString issuedTokenType_;\n\t\tOpcUaString issuerEndpointUrl_;\n\t\tOpcUaString securityPolicyUri_;\n\t};\n\n\tclass UserTokenPolicyArray\n\t: public OpcUaArray<UserTokenPolicy::SPtr, SPtrTypeCoder<UserTokenPolicy> >\n\t, public Object\n\t{\n\t  public:\n\t\t  typedef boost::shared_ptr<UserTokenPolicyArray> SPtr;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/GetEndpointsResponse.h'\n:\n\n#ifndef __OpcUaStackCore_GetEndpointsResponse_h__\n#define __OpcUaStackCore_GetEndpointsResponse_h__\n\n#include <stdint.h>\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n#include \"OpcUaStackCore/ServiceSet/EndpointDescription.h\"\n#include \"OpcUaStackCore/SecureChannel/ResponseHeader.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT GetEndpointsResponse\n\t: public Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<GetEndpointsResponse> SPtr;\n\n\t\tGetEndpointsResponse(void);\n\t\tvirtual ~GetEndpointsResponse(void);\n\n\t\tvoid responseHeader(const ResponseHeader::SPtr responseHeader);\n\t\tResponseHeader::SPtr responseHeader(void) const;\n\t\tvoid endpoints(const EndpointDescriptionArray::SPtr endpoints);\n\t\tEndpointDescriptionArray::SPtr endpoints(void) const;\n\n\t\tvoid opcUaBinaryEncode(std::ostream& os) const;\n\t\tvoid opcUaBinaryDecode(std::istream& is);\n\n\t  private:\n\t\tResponseHeader::SPtr responseHeader_;\n\t\tEndpointDescriptionArray::SPtr endpointArraySPtr_;\n\t};\n\n}\n\n#endif\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/UserTokenPolicy.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/EndpointDescription.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/GetEndpointsResponse.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/DiscoveryService.cpp'"
        ]
    },
    {
        "files": [
            "'lsdpack/libgambatte/src/mem/rtc.h'",
            "'lsdpack/libgambatte/src/cpu.h'",
            "'lsdpack/libgambatte/src/memory.h'",
            "'lsdpack/libgambatte/src/gambatte.cpp'",
            "'lsdpack/libgambatte/src/mem/cartridge.h'"
        ],
        "content": "'lsdpack/libgambatte/src/mem/rtc.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef RTC_H\n#define RTC_H\n\n#include <ctime>\n\nnamespace gambatte {\n\nstruct SaveState;\n\nclass Rtc {\npublic:\n\tRtc();\n\tunsigned char const * activeData() const { return activeData_; }\n\tstd::time_t baseTime() const { return baseTime_; }\n\tvoid setBaseTime(std::time_t baseTime) { baseTime_ = baseTime; }\n\n\tvoid latch(unsigned data) {\n\t\tif (!lastLatchData_ && data == 1)\n\t\t\tdoLatch();\n\n\t\tlastLatchData_ = data;\n\t}\n\n\tvoid saveState(SaveState &state) const;\n\tvoid loadState(SaveState const &state);\n\n\tvoid set(bool enabled, unsigned bank) {\n\t\tbank &= 0xF;\n\t\tbank -= 8;\n\n\t\tenabled_ = enabled;\n\t\tindex_ = bank;\n\t\tdoSwapActive();\n\t}\n\n\tvoid write(unsigned data) {\n\t\t(this->*activeSet_)(data);\n\t\t*activeData_ = data;\n\t}\n\nprivate:\n\tunsigned char *activeData_;\n\tvoid (Rtc::*activeSet_)(unsigned);\n\tstd::time_t baseTime_;\n\tstd::time_t haltTime_;\n\tunsigned char index_;\n\tunsigned char dataDh_;\n\tunsigned char dataDl_;\n\tunsigned char dataH_;\n\tunsigned char dataM_;\n\tunsigned char dataS_;\n\tbool enabled_;\n\tbool lastLatchData_;\n\n\tvoid doLatch();\n\tvoid doSwapActive();\n\tvoid setDh(unsigned newDh);\n\tvoid setDl(unsigned newLowdays);\n\tvoid setH(unsigned newHours);\n\tvoid setM(unsigned newMinutes);\n\tvoid setS(unsigned newSeconds);\n};\n\n}\n\n#endif\n\n'lsdpack/libgambatte/src/cpu.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef CPU_H\n#define CPU_H\n\n#include \"memory.h\"\n\nnamespace gambatte {\n\nclass CPU {\npublic:\n\tCPU();\n\tlong runFor(unsigned long cycles);\n\tvoid setStatePtrs(SaveState &state);\n\tvoid saveState(SaveState &state);\n\tvoid loadState(SaveState const &state);\n\tvoid loadSavedata() { mem_.loadSavedata(); }\n\tvoid saveSavedata() { mem_.saveSavedata(); }\n\n\tvoid setVideoBuffer(uint_least32_t *videoBuf, std::ptrdiff_t pitch) {\n\t\tmem_.setVideoBuffer(videoBuf, pitch);\n\t}\n\n\tvoid setInputGetter(InputGetter *getInput) {\n\t\tmem_.setInputGetter(getInput);\n\t}\n\n\tvoid setSaveDir(std::string const &sdir) {\n\t\tmem_.setSaveDir(sdir);\n\t}\n\n\tstd::string const saveBasePath() const {\n\t\treturn mem_.saveBasePath();\n\t}\n\n\tvoid setOsdElement(transfer_ptr<OsdElement> osdElement) {\n\t\tmem_.setOsdElement(osdElement);\n\t}\n\n\tLoadRes load(std::string const &romfile, bool forceDmg, bool multicartCompat) {\n\t\treturn mem_.loadROM(romfile, forceDmg, multicartCompat);\n\t}\n\n\tbool loaded() const { return mem_.loaded(); }\n\tchar const * romTitle() const { return mem_.romTitle(); }\n\tPakInfo const pakInfo(bool multicartCompat) const { return mem_.pakInfo(multicartCompat); }\n\tvoid setSoundBuffer(uint_least32_t *buf) { mem_.setSoundBuffer(buf); }\n\tstd::size_t fillSoundBuffer() { return mem_.fillSoundBuffer(cycleCounter_); }\n\tbool isCgb() const { return mem_.isCgb(); }\n\n\tvoid setDmgPaletteColor(int palNum, int colorNum, unsigned long rgb32) {\n\t\tmem_.setDmgPaletteColor(palNum, colorNum, rgb32);\n\t}\n\n\tvoid setGameGenie(std::string const &codes) { mem_.setGameGenie(codes); }\n\tvoid setGameShark(std::string const &codes) { mem_.setGameShark(codes); }\n    void setWriteHandler(void (*writeHandler)(char, char, unsigned long)) { mem_.setWriteHandler(writeHandler); }\n    void setLcdHandler(void (*lcdHandler)()) { mem_.setLcdHandler(lcdHandler); }\n    bool isSongEmpty() { return mem_.isSongEmpty(); }\n\nprivate:\n\tMemory mem_;\n\tunsigned long cycleCounter_;\n\tunsigned short pc_;\n\tunsigned short sp;\n\tunsigned hf1, hf2, zf, cf;\n\tunsigned char a_, b, c, d, e,  h, l;\n\tbool skip_;\n\n\tvoid process(unsigned long cycles);\n};\n\n}\n\n#endif\n\n'lsdpack/libgambatte/src/memory.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef MEMORY_H\n#define MEMORY_H\n\n#include \"mem/cartridge.h\"\n#include \"interrupter.h\"\n#include \"pakinfo.h\"\n#include \"sound.h\"\n#include \"tima.h\"\n#include \"video.h\"\n\nnamespace gambatte {\n\nclass InputGetter;\nclass FilterInfo;\n\nclass Memory {\npublic:\n\texplicit Memory(Interrupter const &interrupter);\n\tbool loaded() const { return cart_.loaded(); }\n\tchar const * romTitle() const { return cart_.romTitle(); }\n\tPakInfo const pakInfo(bool multicartCompat) const { return cart_.pakInfo(multicartCompat); }\n\tvoid setStatePtrs(SaveState &state);\n\tunsigned long saveState(SaveState &state, unsigned long cc);\n\tvoid loadState(SaveState const &state);\n\tvoid loadSavedata() { cart_.loadSavedata(); }\n\tvoid saveSavedata() { cart_.saveSavedata(); }\n\tstd::string const saveBasePath() const { return cart_.saveBasePath(); }\n\n\tvoid setOsdElement(transfer_ptr<OsdElement> osdElement) {\n\t\tlcd_.setOsdElement(osdElement);\n\t}\n\n\tunsigned long stop(unsigned long cycleCounter);\n\tbool isCgb() const { return lcd_.isCgb(); }\n\tbool ime() const { return intreq_.ime(); }\n\tbool halted() const { return intreq_.halted(); }\n\tunsigned long nextEventTime() const { return intreq_.minEventTime(); }\n\tbool isActive() const { return intreq_.eventTime(intevent_end) != disabled_time; }\n\n\tlong cyclesSinceBlit(unsigned long cc) const {\n\t\tif (cc < intreq_.eventTime(intevent_blit))\n\t\t\treturn -1;\n\n\t\treturn (cc - intreq_.eventTime(intevent_blit)) >> isDoubleSpeed();\n\t}\n\n\tvoid halt() { intreq_.halt(); }\n\tvoid ei(unsigned long cycleCounter) { if (!ime()) { intreq_.ei(cycleCounter); } }\n\tvoid di() { intreq_.di(); }\n\n\tunsigned ff_read(unsigned p, unsigned long cc) {\n\t\treturn p < 0x80 ? nontrivial_ff_read(p, cc) : ioamhram_[p + 0x100];\n\t}\n\n\tunsigned read(unsigned p, unsigned long cc) {\n\t\treturn cart_.rmem(p >> 12) ? cart_.rmem(p >> 12)[p] : nontrivial_read(p, cc);\n\t}\n\n\tvoid write(unsigned p, unsigned data, unsigned long cc) {\n\t\tif (cart_.wmem(p >> 12)) {\n\t\t\tcart_.wmem(p >> 12)[p] = data;\n\t\t} else\n\t\t\tnontrivial_write(p, data, cc);\n\t}\n\n\tvoid ff_write(unsigned p, unsigned data, unsigned long cc) {\n\t\tif (p - 0x80u < 0x7Fu) {\n\t\t\tioamhram_[p + 0x100] = data;\n\t\t} else\n\t\t\tnontrivial_ff_write(p, data, cc);\n\t}\n\n\tunsigned long event(unsigned long cycleCounter);\n\tunsigned long resetCounters(unsigned long cycleCounter);\n\tLoadRes loadROM(std::string const &romfile, bool forceDmg, bool multicartCompat);\n\tvoid setSaveDir(std::string const &dir) { cart_.setSaveDir(dir); }\n\tvoid setInputGetter(InputGetter *getInput) { getInput_ = getInput; }\n\tvoid setEndtime(unsigned long cc, unsigned long inc);\n\tvoid setSoundBuffer(uint_least32_t *buf) { psg_.setBuffer(buf); }\n\tstd::size_t fillSoundBuffer(unsigned long cc);\n\n\tvoid setVideoBuffer(uint_least32_t *videoBuf, std::ptrdiff_t pitch) {\n\t\tlcd_.setVideoBuffer(videoBuf, pitch);\n\t}\n\n\tvoid setDmgPaletteColor(int palNum, int colorNum, unsigned long rgb32) {\n\t\tlcd_.setDmgPaletteColor(palNum, colorNum, rgb32);\n\t}\n\n\tvoid setGameGenie(std::string const &codes) { cart_.setGameGenie(codes); }\n\tvoid setGameShark(std::string const &codes) { interrupter_.setGameShark(codes); }\n    void setWriteHandler(void (*writeHandler)(char, char, unsigned long)) { writeHandler_ = writeHandler; }\n    void setLcdHandler(void (*lcdHandler)()) { lcdHandler_ = lcdHandler; }\n\tvoid updateInput();\n    bool isSongEmpty() {\n        write(0, 0xa, 0);\n        write(0x4000, 0, 0);\n\n        for (unsigned i = 0xa000; i < 0xaff0; ++i) {\n            int val = read(i, 0);\n            if (val) {\n                return false;\n            }\n        }\n        return true;\n    }\n\nprivate:\n\tCartridge cart_;\n\tunsigned char ioamhram_[0x200];\n\tInputGetter *getInput_;\n\tunsigned long divLastUpdate_;\n\tunsigned long lastOamDmaUpdate_;\n\tInterruptRequester intreq_;\n\tTima tima_;\n\tLCD lcd_;\n\tPSG psg_;\n\tInterrupter interrupter_;\n\tunsigned short dmaSource_;\n\tunsigned short dmaDestination_;\n\tunsigned char oamDmaPos_;\n\tunsigned char serialCnt_;\n\tbool blanklcd_;\n    void (*writeHandler_)(char, char, unsigned long);\n    void (*lcdHandler_)();\n\n\tvoid decEventCycles(IntEventId eventId, unsigned long dec);\n\tvoid oamDmaInitSetup();\n\tvoid updateOamDma(unsigned long cycleCounter);\n\tvoid startOamDma(unsigned long cycleCounter);\n\tvoid endOamDma(unsigned long cycleCounter);\n\tunsigned char const * oamDmaSrcPtr() const;\n\tunsigned nontrivial_ff_read(unsigned p, unsigned long cycleCounter);\n\tunsigned nontrivial_read(unsigned p, unsigned long cycleCounter);\n\tvoid nontrivial_ff_write(unsigned p, unsigned data, unsigned long cycleCounter);\n\tvoid nontrivial_write(unsigned p, unsigned data, unsigned long cycleCounter);\n\tvoid updateSerial(unsigned long cc);\n\tvoid updateTimaIrq(unsigned long cc);\n\tvoid updateIrqs(unsigned long cc);\n\tbool isDoubleSpeed() const { return lcd_.isDoubleSpeed(); }\n};\n\n}\n\n#endif\n\n'lsdpack/libgambatte/src/gambatte.cpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"gambatte.h\"\n#include \"cpu.h\"\n#include \"initstate.h\"\n#include \"savestate.h\"\n#include \"state_osd_elements.h\"\n#include \"statesaver.h\"\n#include <cstring>\n#include <sstream>\n\nstatic std::string const itos(int i) {\n\tstd::stringstream ss;\n\tss << i;\n\treturn ss.str();\n}\n\nstatic std::string const statePath(std::string const &basePath, int stateNo) {\n\treturn basePath + \"_\" + itos(stateNo) + \".gqs\";\n}\n\nnamespace gambatte {\n\nstruct GB::Priv {\n\tCPU cpu;\n\tint stateNo;\n\tunsigned loadflags;\n\n\tPriv() : stateNo(1), loadflags(0) {}\n};\n\nGB::GB() : p_(new Priv) {}\n\nGB::~GB() {\n\tif (p_->cpu.loaded())\n\t\tp_->cpu.saveSavedata();\n\n\tdelete p_;\n}\n\nstd::ptrdiff_t GB::runFor(gambatte::uint_least32_t *const videoBuf, std::ptrdiff_t const pitch,\n                          gambatte::uint_least32_t *const soundBuf, std::size_t &samples) {\n\tif (!p_->cpu.loaded()) {\n\t\tsamples = 0;\n\t\treturn -1;\n\t}\n\n\tp_->cpu.setVideoBuffer(videoBuf, pitch);\n\tp_->cpu.setSoundBuffer(soundBuf);\n\n\tlong const cyclesSinceBlit = p_->cpu.runFor(samples * 2);\n\tsamples = p_->cpu.fillSoundBuffer();\n\treturn cyclesSinceBlit >= 0\n\t     ? static_cast<std::ptrdiff_t>(samples) - (cyclesSinceBlit >> 1)\n\t     : cyclesSinceBlit;\n}\n\nvoid GB::reset() {\n\tif (p_->cpu.loaded()) {\n\t\tp_->cpu.saveSavedata();\n\n\t\tSaveState state;\n\t\tp_->cpu.setStatePtrs(state);\n\t\tsetInitState(state, p_->cpu.isCgb(), p_->loadflags & GBA_CGB);\n\t\tp_->cpu.loadState(state);\n\t\tp_->cpu.loadSavedata();\n\t}\n}\n\nvoid GB::setInputGetter(InputGetter *getInput) {\n\tp_->cpu.setInputGetter(getInput);\n}\n\nvoid GB::setSaveDir(std::string const &sdir) {\n\tp_->cpu.setSaveDir(sdir);\n}\n\nLoadRes GB::load(std::string const &romfile, unsigned const flags) {\n\tif (p_->cpu.loaded())\n\t\tp_->cpu.saveSavedata();\n\n\tLoadRes const loadres = p_->cpu.load(romfile,\n\t                                     flags & FORCE_DMG,\n\t                                     flags & MULTICART_COMPAT);\n\tif (loadres == LOADRES_OK) {\n\t\tSaveState state;\n\t\tp_->cpu.setStatePtrs(state);\n\t\tp_->loadflags = flags;\n\t\tsetInitState(state, p_->cpu.isCgb(), flags & GBA_CGB);\n\t\tp_->cpu.loadState(state);\n\t\tp_->cpu.loadSavedata();\n\n\t\tp_->stateNo = 1;\n\t\tp_->cpu.setOsdElement(transfer_ptr<OsdElement>());\n\t}\n\n\treturn loadres;\n}\n\nbool GB::isCgb() const {\n\treturn p_->cpu.isCgb();\n}\n\nbool GB::isLoaded() const {\n\treturn p_->cpu.loaded();\n}\n\nvoid GB::saveSavedata() {\n\tif (p_->cpu.loaded())\n\t\tp_->cpu.saveSavedata();\n}\n\nvoid GB::setDmgPaletteColor(int palNum, int colorNum, unsigned long rgb32) {\n\tp_->cpu.setDmgPaletteColor(palNum, colorNum, rgb32);\n}\n\nbool GB::loadState(std::string const &filepath) {\n\tif (p_->cpu.loaded()) {\n\t\tp_->cpu.saveSavedata();\n\n\t\tSaveState state;\n\t\tp_->cpu.setStatePtrs(state);\n\n\t\tif (StateSaver::loadState(state, filepath)) {\n\t\t\tp_->cpu.loadState(state);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool GB::saveState(gambatte::uint_least32_t const *videoBuf, std::ptrdiff_t pitch) {\n\tif (saveState(videoBuf, pitch, statePath(p_->cpu.saveBasePath(), p_->stateNo))) {\n\t\tp_->cpu.setOsdElement(newStateSavedOsdElement(p_->stateNo));\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool GB::loadState() {\n\tif (loadState(statePath(p_->cpu.saveBasePath(), p_->stateNo))) {\n\t\tp_->cpu.setOsdElement(newStateLoadedOsdElement(p_->stateNo));\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool GB::saveState(gambatte::uint_least32_t const *videoBuf, std::ptrdiff_t pitch,\n                   std::string const &filepath) {\n\tif (p_->cpu.loaded()) {\n\t\tSaveState state;\n\t\tp_->cpu.setStatePtrs(state);\n\t\tp_->cpu.saveState(state);\n\t\treturn StateSaver::saveState(state, videoBuf, pitch, filepath);\n\t}\n\n\treturn false;\n}\n\nvoid GB::selectState(int n) {\n\tn -= (n / 10) * 10;\n\tp_->stateNo = n < 0 ? n + 10 : n;\n\n\tif (p_->cpu.loaded()) {\n\t\tstd::string const &path = statePath(p_->cpu.saveBasePath(), p_->stateNo);\n\t\tp_->cpu.setOsdElement(newSaveStateOsdElement(path, p_->stateNo));\n\t}\n}\n\nint GB::currentState() const { return p_->stateNo; }\n\nstd::string const GB::romTitle() const {\n\tif (p_->cpu.loaded()) {\n\t\tchar title[0x11];\n\t\tstd::memcpy(title, p_->cpu.romTitle(), 0x10);\n\t\ttitle[title[0xF] & 0x80 ? 0xF : 0x10] = '\\0';\n\t\treturn std::string(title);\n\t}\n\n\treturn std::string();\n}\n\nPakInfo const GB::pakInfo() const { return p_->cpu.pakInfo(p_->loadflags & MULTICART_COMPAT); }\n\nvoid GB::setGameGenie(std::string const &codes) {\n\tp_->cpu.setGameGenie(codes);\n}\n\nvoid GB::setGameShark(std::string const &codes) {\n\tp_->cpu.setGameShark(codes);\n}\n\nvoid GB::setWriteHandler(void (*writeHandler)(char, char, unsigned long)) {\n\tp_->cpu.setWriteHandler(writeHandler);\n}\n\nvoid GB::setLcdHandler(void (*lcdHandler)()) {\n\tp_->cpu.setLcdHandler(lcdHandler);\n}\n\nbool GB::isSongEmpty() const {\n    return p_->cpu.isSongEmpty();\n}\n\n}\n\n'lsdpack/libgambatte/src/mem/cartridge.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef CARTRIDGE_H\n#define CARTRIDGE_H\n\n#include \"loadres.h\"\n#include \"memptrs.h\"\n#include \"rtc.h\"\n#include \"savestate.h\"\n#include \"scoped_ptr.h\"\n#include <string>\n#include <vector>\n\nnamespace gambatte {\n\nclass Mbc {\npublic:\n\tvirtual ~Mbc() {}\n\tvirtual void romWrite(unsigned P, unsigned data) = 0;\n\tvirtual void saveState(SaveState::Mem &ss) const = 0;\n\tvirtual void loadState(SaveState::Mem const &ss) = 0;\n\tvirtual bool isAddressWithinAreaRombankCanBeMappedTo(unsigned address, unsigned rombank) const = 0;\n};\n\nclass Cartridge {\npublic:\n\tvoid setStatePtrs(SaveState &);\n\tvoid saveState(SaveState &) const;\n\tvoid loadState(SaveState const &);\n\tbool loaded() const { return mbc_.get(); }\n\tunsigned char const * rmem(unsigned area) const { return memptrs_.rmem(area); }\n\tunsigned char * wmem(unsigned area) const { return memptrs_.wmem(area); }\n\tunsigned char * vramdata() const { return memptrs_.vramdata(); }\n\tunsigned char * romdata(unsigned area) const { return memptrs_.romdata(area); }\n\tunsigned char * wramdata(unsigned area) const { return memptrs_.wramdata(area); }\n\tunsigned char const * rdisabledRam() const { return memptrs_.rdisabledRam(); }\n\tunsigned char const * rsrambankptr() const { return memptrs_.rsrambankptr(); }\n\tunsigned char * wsrambankptr() const { return memptrs_.wsrambankptr(); }\n\tunsigned char * vrambankptr() const { return memptrs_.vrambankptr(); }\n\tOamDmaSrc oamDmaSrc() const { return memptrs_.oamDmaSrc(); }\n\tvoid setVrambank(unsigned bank) { memptrs_.setVrambank(bank); }\n\tvoid setWrambank(unsigned bank) { memptrs_.setWrambank(bank); }\n\tvoid setOamDmaSrc(OamDmaSrc oamDmaSrc) { memptrs_.setOamDmaSrc(oamDmaSrc); }\n\tvoid mbcWrite(unsigned addr, unsigned data) { mbc_->romWrite(addr, data); }\n\tbool isCgb() const { return gambatte::isCgb(memptrs_); }\n\tvoid rtcWrite(unsigned data) { rtc_.write(data); }\n\tunsigned char rtcRead() const { return *rtc_.activeData(); }\n\tvoid loadSavedata();\n\tvoid saveSavedata();\n\tstd::string const saveBasePath() const;\n\tvoid setSaveDir(std::string const &dir);\n\tLoadRes loadROM(std::string const &romfile, bool forceDmg, bool multicartCompat);\n\tchar const * romTitle() const { return reinterpret_cast<char const *>(memptrs_.romdata() + 0x134); }\n\tclass PakInfo const pakInfo(bool multicartCompat) const;\n\tvoid setGameGenie(std::string const &codes);\n\nprivate:\n\tstruct AddrData {\n\t\tunsigned long addr;\n\t\tunsigned char data;\n\t\tAddrData(unsigned long addr, unsigned data) : addr(addr), data(data) {}\n\t};\n\n\tMemPtrs memptrs_;\n\tRtc rtc_;\n\tscoped_ptr<Mbc> mbc_;\n\tstd::string defaultSaveBasePath_;\n\tstd::string saveDir_;\n\tstd::vector<AddrData> ggUndoList_;\n\n\tvoid applyGameGenie(std::string const &code);\n};\n\n}\n\n#endif\n",
        "gt": [
            "'lsdpack/libgambatte/src/mem/rtc.h'",
            "'lsdpack/libgambatte/src/mem/cartridge.h'",
            "'lsdpack/libgambatte/src/memory.h'",
            "'lsdpack/libgambatte/src/cpu.h'",
            "'lsdpack/libgambatte/src/gambatte.cpp'"
        ]
    },
    {
        "files": [
            "'PeaceMaker/PeaceMaker Kernel/ThreadFilter.cpp'",
            "'PeaceMaker/PeaceMaker Kernel/DetectionLogic.h'",
            "'PeaceMaker/PeaceMaker Kernel/ThreadFilter.h'",
            "'PeaceMaker/PeaceMaker Kernel/ImageHistoryFilter.h'"
        ],
        "content": "'PeaceMaker/PeaceMaker Kernel/ThreadFilter.cpp'\n:\n#include \"ThreadFilter.h\"\n\nPDETECTION_LOGIC ThreadFilter::Detector;\nSTACK_WALKER ThreadFilter::Walker;\n\n\nThreadFilter::ThreadFilter (\n\t_In_ PDETECTION_LOGIC DetectionLogic,\n\t_Inout_ NTSTATUS* InitializeStatus\n\t)\n{\n\tThreadFilter::Detector = DetectionLogic;\n\n\n\n\n\t*InitializeStatus = PsSetCreateThreadNotifyRoutine(ThreadFilter::ThreadNotifyRoutine);\n\tif (NT_SUCCESS(*InitializeStatus) == FALSE)\n\t{\n\t\tDBGPRINT(\"ThreadFilter!ThreadFilter: Failed to create thread notify routine with status 0x%X.\", *InitializeStatus);\n\t}\n}\n\n\nThreadFilter::~ThreadFilter (\n\tVOID\n\t)\n{\n\tPsRemoveCreateThreadNotifyRoutine(ThreadFilter::ThreadNotifyRoutine);\n}\n\n\nPVOID\nThreadFilter::GetThreadStartAddress (\n\t_In_ HANDLE ThreadId\n\t)\n{\n\tNTSTATUS status;\n\tPVOID startAddress;\n\tPETHREAD threadObject;\n\tHANDLE threadHandle;\n\tULONG returnLength;\n\n\tstartAddress = NULL;\n\tthreadHandle = NULL;\n\n\n\n\n\tstatus = PsLookupThreadByThreadId(ThreadId, &threadObject);\n\tif (NT_SUCCESS(status) == FALSE)\n\t{\n\t\tDBGPRINT(\"ThreadFilter!GetThreadStartAddress: Failed to lookup thread 0x%X by its ID.\", ThreadId);\n\t\tgoto Exit;\n\t}\n\n\n\n\n\tstatus = ObOpenObjectByPointer(threadObject, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, GENERIC_ALL, *PsThreadType, KernelMode, &threadHandle);\n\tif (NT_SUCCESS(status) == FALSE)\n\t{\n\t\tDBGPRINT(\"ThreadFilter!GetThreadStartAddress: Failed to open handle to process with status 0x%X.\", status);\n\t\tgoto Exit;\n\t}\n\n\n\n\n\tstatus = NtQueryInformationThread(threadHandle, ThreadQuerySetWin32StartAddress, &startAddress, sizeof(startAddress), &returnLength);\n\tif (NT_SUCCESS(status) == FALSE)\n\t{\n\t\tDBGPRINT(\"ThreadFilter!GetThreadStartAddress: Failed to query thread start address with status 0x%X.\", status);\n\t\tgoto Exit;\n\t}\nExit:\n\tif (threadHandle != NULL)\n\t{\n\t\tZwClose(threadHandle);\n\t}\n\treturn startAddress;\n}\n\n\nVOID\nThreadFilter::ThreadNotifyRoutine (\n\t_In_ HANDLE ProcessId,\n\t_In_ HANDLE ThreadId,\n\t_In_ BOOLEAN Create\n\t)\n{\n\tULONG processThreadCount;\n\tPVOID threadStartAddress;\n\tPSTACK_RETURN_INFO threadCreateStack;\n\tULONG threadCreateStackSize;\n\tPUNICODE_STRING threadCallerName;\n\tPUNICODE_STRING threadTargetName;\n\n\tthreadCreateStack = NULL;\n\tthreadCreateStackSize = 20;\n\tthreadCallerName = NULL;\n\tthreadTargetName = NULL;\n\n\n\n\n\tif (Create == FALSE || ExGetPreviousMode() == KernelMode)\n\t{\n\t\treturn;\n\t}\n\n\n\n\n\tif (ImageHistoryFilter::AddProcessThreadCount(ProcessId, &processThreadCount) == FALSE ||\n\t\tprocessThreadCount <= 1)\n\t{\n\t\treturn;\n\t}\n\n\n\n\n\tThreadFilter::Walker.WalkAndResolveStack(&threadCreateStack, &threadCreateStackSize, STACK_HISTORY_TAG);\n\n\n\n\n\tif (ImageHistoryFilter::GetProcessImageFileName(PsGetCurrentProcessId(), &threadCallerName) == FALSE)\n\t{\n\t\tgoto Exit;\n\t}\n\n\tthreadTargetName = threadCallerName;\n\n\n\n\n\tif (PsGetCurrentProcessId() != ProcessId)\n\t{\n\n\n\n\t\tif (ImageHistoryFilter::GetProcessImageFileName(ProcessId, &threadTargetName) == FALSE)\n\t\t{\n\t\t\tgoto Exit;\n\t\t}\n\t}\n\n\n\n\n\tthreadStartAddress = ThreadFilter::GetThreadStartAddress(ThreadId);\n\n\n\n\n\tThreadFilter::Detector->AuditUserPointer(ThreadCreate, threadStartAddress, PsGetCurrentProcessId(), threadCallerName, threadTargetName, threadCreateStack, threadCreateStackSize);\n\n\n\n\n\tThreadFilter::Detector->AuditUserStackWalk(ThreadCreate, PsGetCurrentProcessId(), threadCallerName, threadTargetName, threadCreateStack, threadCreateStackSize);\n\n\n\n\n\tThreadFilter::Detector->AuditCallerProcessId(ThreadCreate, PsGetCurrentProcessId(), ProcessId, threadCallerName, threadTargetName, threadCreateStack, threadCreateStackSize);\nExit:\n\tif (threadCreateStack != NULL)\n\t{\n\t\tExFreePoolWithTag(threadCreateStack, STACK_HISTORY_TAG);\n\t}\n\tif (threadCallerName != NULL)\n\t{\n\t\tExFreePoolWithTag(threadCallerName, IMAGE_NAME_TAG);\n\t}\n\tif (threadCallerName != threadTargetName && threadTargetName != NULL)\n\t{\n\t\tExFreePoolWithTag(threadTargetName, IMAGE_NAME_TAG);\n\t}\n}\n'PeaceMaker/PeaceMaker Kernel/DetectionLogic.h'\n:\n#pragma once\n#include \"common.h\"\n#include \"AlertQueue.h\"\n#include \"StackWalker.h\"\n#include \"shared.h\"\n\ntypedef class DetectionLogic\n{\n\tPALERT_QUEUE alerts;\n\tStackWalker resolver;\n\n\tVOID PushStackViolationAlert (\n\t\t_In_ DETECTION_SOURCE DetectionSource,\n\t\t_In_ PVOID ViolatingAddress,\n\t\t_In_ HANDLE SourceProcessId,\n\t\t_In_ PUNICODE_STRING SourcePath,\n\t\t_In_ PUNICODE_STRING TargetPath,\n\t\t_In_ STACK_RETURN_INFO StackHistory[],\n\t\t_In_ ULONG StackHistorySize\n\t\t);\n\npublic:\n\tDetectionLogic();\n\t~DetectionLogic();\n\n\tPALERT_QUEUE GetAlertQueue (\n\t\tVOID\n\t\t);\n\n\tVOID AuditUserStackWalk (\n\t\t_In_ DETECTION_SOURCE DetectionSource,\n\t\t_In_ HANDLE SourceProcessId,\n\t\t_In_ PUNICODE_STRING SourcePath,\n\t\t_In_ PUNICODE_STRING TargetPath,\n\t\t_In_ STACK_RETURN_INFO StackHistory[],\n\t\t_In_ ULONG StackHistorySize\n\t\t);\n\n\tVOID AuditUserPointer (\n\t\t_In_ DETECTION_SOURCE DetectionSource,\n\t\t_In_ PVOID UserPtr,\n\t\t_In_ HANDLE SourceProcessId,\n\t\t_In_ PUNICODE_STRING SourcePath,\n\t\t_In_ PUNICODE_STRING TargetPath,\n\t\t_In_ STACK_RETURN_INFO StackHistory[],\n\t\t_In_ ULONG StackHistorySize\n\t\t);\n\n\tVOID AuditCallerProcessId (\n\t\t_In_ DETECTION_SOURCE DetectionSource,\n\t\t_In_ HANDLE CallerProcessId,\n\t\t_In_ HANDLE TargetProcessId,\n\t\t_In_ PUNICODE_STRING SourcePath,\n\t\t_In_ PUNICODE_STRING TargetPath,\n\t\t_In_ STACK_RETURN_INFO StackHistory[],\n\t\t_In_ ULONG StackHistorySize\n\t\t);\n\n\tVOID ReportFilterViolation (\n\t\t_In_ DETECTION_SOURCE DetectionSource,\n\t\t_In_ HANDLE CallerProcessId,\n\t\t_In_ PUNICODE_STRING CallerPath,\n\t\t_In_ PUNICODE_STRING ViolatingPath,\n\t\t_In_ STACK_RETURN_INFO StackHistory[],\n\t\t_In_ ULONG StackHistorySize\n\t\t);\n} DETECTION_LOGIC, *PDETECTION_LOGIC;\n\n#define ALERT_QUEUE_TAG 'qAmP'\n#define STACK_VIOLATION_TAG 'vSmP'\n'PeaceMaker/PeaceMaker Kernel/ThreadFilter.h'\n:\n#pragma once\n#include \"common.h\"\n#include \"DetectionLogic.h\"\n#include \"ImageHistoryFilter.h\"\n#include \"StackWalker.h\"\n\ntypedef class ThreadFilter\n{\n\tstatic PDETECTION_LOGIC Detector;\n\tstatic STACK_WALKER Walker;\n\n\tstatic PVOID GetThreadStartAddress(\n\t\t_In_ HANDLE ThreadId\n\t\t);\n\n\tstatic VOID ThreadNotifyRoutine(\n\t\tHANDLE ProcessId,\n\t\tHANDLE ThreadId,\n\t\tBOOLEAN Create\n\t\t);\npublic:\n\tThreadFilter(\n\t\t_In_ PDETECTION_LOGIC DetectionLogic,\n\t\t_Inout_ NTSTATUS* InitializeStatus\n\t\t);\n\t~ThreadFilter(VOID);\n\n\n} THREAD_FILTER, *PTHREAD_FILTER;\n'PeaceMaker/PeaceMaker Kernel/ImageHistoryFilter.h'\n:\n#pragma once\n#include \"common.h\"\n#include \"StackWalker.h\"\n#include \"shared.h\"\n#include \"DetectionLogic.h\"\n\n#define IMAGE_NAME_TAG 'nImP'\n#define IMAGE_COMMMAND_TAG 'cImP'\n#define PROCESS_HISTORY_TAG 'hPmP'\n#define STACK_HISTORY_TAG 'hSmP'\n#define IMAGE_HISTORY_TAG 'hImP'\n\ntypedef struct ImageLoadHistoryEntry\n{\n\tLIST_ENTRY ListEntry;\n\tUNICODE_STRING ImageFileName;\n\tHANDLE CallerProcessId;\n\tBOOLEAN RemoteImage;\n\tPUNICODE_STRING CallerImageFileName;\n\tPSTACK_RETURN_INFO CallerStackHistory;\n\tULONG CallerStackHistorySize;\n} IMAGE_LOAD_HISTORY_ENTRY, *PIMAGE_LOAD_HISTORY_ENTRY;\n\ntypedef struct ProcessHistoryEntry\n{\n\tLIST_ENTRY ListEntry;\n\n\tHANDLE CallerId;\n\tPUNICODE_STRING CallerImageFileName;\n\n\tHANDLE ParentId;\n\tPUNICODE_STRING ParentImageFileName;\n\n\tHANDLE ProcessId;\n\tPUNICODE_STRING ProcessImageFileName;\n\n\tPUNICODE_STRING ProcessCommandLine;\n\n\tULONG ProcessThreadCount;\n\n\tULONGLONG EpochExecutionTime;\n\tBOOLEAN ProcessTerminated;\n\n\tPSTACK_RETURN_INFO CallerStackHistory;\n\tULONG CallerStackHistorySize;\n\n\tPIMAGE_LOAD_HISTORY_ENTRY ImageLoadHistory;\n\tEX_PUSH_LOCK ImageLoadHistoryLock;\n\tULONG ImageLoadHistorySize;\n} PROCESS_HISTORY_ENTRY, *PPROCESS_HISTORY_ENTRY;\n\ntypedef class ImageHistoryFilter\n{\n\n\tstatic VOID CreateProcessNotifyRoutine (\n\t\t_In_ PEPROCESS Process,\n\t\t_In_ HANDLE ProcessId,\n\t\t_In_ PPS_CREATE_NOTIFY_INFO CreateInfo\n\t\t);\n\n\tstatic VOID LoadImageNotifyRoutine (\n\t\t_In_ PUNICODE_STRING FullImageName,\n\t\t_In_ HANDLE ProcessId,\n\t\t_In_ PIMAGE_INFO ImageInfo\n\t\t);\n\n\tstatic StackWalker walker;\n\tstatic PPROCESS_HISTORY_ENTRY ProcessHistoryHead;\n\tstatic EX_PUSH_LOCK ProcessHistoryLock;\n\tstatic BOOLEAN destroying;\n\tstatic PDETECTION_LOGIC detector;\n\n\tstatic VOID AddProcessToHistory(\n\t\t_In_ HANDLE ProcessId,\n\t\t_In_ PPS_CREATE_NOTIFY_INFO CreateInfo\n\t\t);\n\n\tstatic VOID TerminateProcessInHistory(\n\t\t_In_ HANDLE ProcessId\n\t\t);\n\npublic:\n\tImageHistoryFilter(\n\t\t_In_ PDETECTION_LOGIC Detector,\n\t\t_Out_ NTSTATUS* InitializeStatus\n\t\t);\n\t~ImageHistoryFilter(VOID);\n\n\tstatic BOOLEAN GetProcessImageFileName(\n\t\t_In_ HANDLE ProcessId,\n\t\t_Inout_ PUNICODE_STRING* ImageFileName\n\t\t);\n\n\tULONG GetProcessHistorySummary(\n\t\t_In_ ULONG SkipCount,\n\t\t_Inout_ PPROCESS_SUMMARY_ENTRY ProcessSummaries,\n\t\t_In_ ULONG MaxProcessSummaries\n\t\t);\n\n\tVOID PopulateProcessDetailedRequest(\n\t\t_Inout_ PPROCESS_DETAILED_REQUEST ProcessDetailedRequest\n\t\t);\n\n\tVOID PopulateProcessSizes(\n\t\t_Inout_ PPROCESS_SIZES_REQUEST ProcessSizesRequest\n\t\t);\n\n\tVOID PopulateImageDetailedRequest(\n\t\t_Inout_ PIMAGE_DETAILED_REQUEST ImageDetailedRequest\n\t\t);\n\n\tstatic BOOLEAN AddProcessThreadCount(\n\t\t_In_ HANDLE ProcessId,\n\t\t_Inout_ ULONG* ThreadCount\n\t\t);\n\tstatic ULONG64 ProcessHistorySize;\n} IMAGE_HISTORY_FILTER, *PIMAGE_HISTORY_FILTER;",
        "gt": [
            "'PeaceMaker/PeaceMaker Kernel/DetectionLogic.h'",
            "'PeaceMaker/PeaceMaker Kernel/ImageHistoryFilter.h'",
            "'PeaceMaker/PeaceMaker Kernel/ThreadFilter.h'",
            "'PeaceMaker/PeaceMaker Kernel/ThreadFilter.cpp'"
        ]
    },
    {
        "files": [
            "'metapp/include/metapp/implement/variant_intf.h'",
            "'metapp/include/metapp/metatypes/default_args_function.h'",
            "'metapp/include/metapp/allmetatypes.h'",
            "'metapp/include/metapp/variant.h'",
            "'metapp/tests/unittest/metatypes/test_std_queue.cpp'"
        ],
        "content": "'metapp/include/metapp/implement/variant_intf.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef METAPP_VARIANT_INTF_H_969872685611\n#define METAPP_VARIANT_INTF_H_969872685611\n\n#include \"metapp/variantdata.h\"\n#include \"metapp/typekind.h\"\n#include \"metapp/implement/internal/typeutil_i.h\"\n#include \"metapp/exception.h\"\n\n#include <type_traits>\n#include <cassert>\n\nnamespace metapp {\n\nclass MetaType;\nclass MetaItem;\n\nclass Variant\n{\nprivate:\n\tstruct ConstructTag {};\n\npublic:\n\ttemplate <typename T>\n\tstatic Variant create(const typename std::remove_reference<T>::type & value,\n\t\ttypename std::enable_if<! internal_::IsVariant<T>::value>::type * = nullptr);\n\ttemplate <typename T>\n\tstatic Variant create(typename std::remove_reference<T>::type && value,\n\t\ttypename std::enable_if<! internal_::IsVariant<T>::value>::type * = nullptr);\n\tstatic Variant create(const Variant & value);\n\n\ttemplate <typename T>\n\tstatic Variant reference(T && value);\n\tstatic Variant retype(const MetaType * metaType, const Variant & var);\n\tstatic Variant takeFrom(const MetaType * metaType, void * instance);\n\tstatic Variant takeFrom(const Variant & var);\n\n\tVariant() noexcept;\n\t~Variant() = default;\n\n\ttemplate <typename T>\n\tVariant(T && value,\n\t\ttypename std::enable_if<! internal_::IsVariant<T>::value, ConstructTag>::type = ConstructTag{});\n\n\tVariant(const MetaType * metaType, const void * copyFrom);\n\tVariant(const MetaType * metaType, const void * copyFrom, const CopyStrategy copyStrategy);\n\n\tVariant(const Variant & other) noexcept;\n\tVariant(Variant && other) noexcept;\n\n\n\n\n\tVariant(const MetaItem &) = delete;\n\n\ttemplate <typename T>\n\tauto operator = (T && value)\n\t\t-> typename std::enable_if<! internal_::IsVariant<T>::value, Variant &>::type;\n\n\tVariant & operator = (const Variant & other) noexcept;\n\tVariant & operator = (Variant && other) noexcept;\n\n\tconst MetaType * getMetaType() const noexcept {\n\t\treturn metaType;\n\t}\n\n\tvoid * getAddress() const {\n\t\treturn data.getAddress();\n\t}\n\n\ttemplate <typename T>\n\tbool canGet(typename std::enable_if<! internal_::IsVariant<T>::value>::type * = nullptr) const;\n\ttemplate <typename T>\n\tbool canGet(typename std::enable_if<internal_::IsVariant<T>::value>::type * = nullptr) const;\n\tbool canGet(const MetaType * toMetaType) const;\n\n\ttemplate <typename T>\n\tauto get(typename std::enable_if<! internal_::IsVariant<T>::value>::type * = nullptr) const\n\t\t-> typename internal_::VariantReturnType<T>::Type;\n\ttemplate <typename T>\n\tauto get(typename std::enable_if<internal_::IsVariant<T>::value>::type * = nullptr) const\n\t\t-> typename internal_::VariantReturnType<T>::Type;\n\ttemplate <typename T>\n\tauto checkedGet() const -> typename internal_::VariantReturnType<T>::Type;\n\n\tbool canCast(const MetaType * toMetaType) const;\n\ttemplate <typename T>\n\tbool canCast() const;\n\n\tVariant cast(const MetaType * toMetaType) const;\n\ttemplate <typename T>\n\tVariant cast() const;\n\n\tVariant castSilently(const MetaType * toMetaType) const;\n\ttemplate <typename T>\n\tVariant castSilently() const;\n\n\tbool isEmpty() const noexcept;\n\n\tVariant clone() const;\n\n\tVariant & assign(const Variant & other);\n\n\tvoid swap(Variant & other) noexcept;\n\n\tfriend std::istream & operator >> (std::istream & stream, Variant & v);\n\tfriend std::ostream & operator << (std::ostream & stream, const Variant & v);\n\nprivate:\n\tVariant(const MetaType * metaType, const VariantData & data);\n\nprivate:\n\tconst MetaType * metaType;\n\tVariantData data;\n};\n\nvoid swap(Variant & a, Variant & b) noexcept;\n\nTypeKind getTypeKind(const Variant & v);\n\n}\n\n\n#endif\n\n\n'metapp/include/metapp/metatypes/default_args_function.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef METAPP_DEFAULT_ARGS_FUNCTION_H_969872685611\n#define METAPP_DEFAULT_ARGS_FUNCTION_H_969872685611\n\n#include \"metapp/metatype.h\"\n#include \"metapp/variant.h\"\n#include \"metapp/interfaces/metacallable.h\"\n#include \"metapp/implement/internal/declareutil_i.h\"\n#include \"metapp/utilities/utility.h\"\n\n#include \"metapp/metatypes/function.h\"\n#include \"metapp/metatypes/member_function.h\"\n#include \"metapp/metatypes/constructor.h\"\n#include \"metapp/metatypes/std_function.h\"\n\n#include <vector>\n#include <initializer_list>\n\nnamespace metapp {\n\ntemplate <typename FT>\nclass DefaultArgsFunction\n{\npublic:\n\tDefaultArgsFunction() : func(), defaultArgs() {\n\t}\n\n\tDefaultArgsFunction(const Variant & func, std::vector<Variant> defaultArgs)\n\t\t: func(func), defaultArgs(std::move(defaultArgs)) {\n\t}\n\n\tconst Variant & getFunc() const {\n\t\treturn func;\n\t}\n\n\tconst Variant * getDefaultArgs() const {\n\t\treturn defaultArgs.data();\n\t}\n\n\tint getDefaultArgsCount() const {\n\t\treturn static_cast<int>(defaultArgs.size());\n\t}\n\nprivate:\n\tVariant func;\n\tstd::vector<Variant> defaultArgs;\n};\n\ntemplate <typename FT>\nauto createDefaultArgsFunction(FT && func, std::vector<Variant> defaultArgs)\n\t-> DefaultArgsFunction<FT>\n{\n\treturn DefaultArgsFunction<FT>(std::forward<FT>(func), std::move(defaultArgs));\n}\n\ntemplate <typename FT>\nstruct DeclareMetaTypeBase <DefaultArgsFunction<FT> >\n{\nprivate:\n\tusing Underlying = DeclareMetaType<FT>;\n\tusing FunctionType = DefaultArgsFunction<FT>;\n\tusing ClassType = typename Underlying::ClassType;\n\tusing ReturnType = typename Underlying::ReturnType;\n\tusing ArgumentTypeList = typename Underlying::ArgumentTypeList;\n\n\tstatic constexpr int argsCount = TypeListCount<ArgumentTypeList>::value;\n\npublic:\n\tusing UpType = typename Underlying::UpType;\n\tstatic constexpr TypeKind typeKind = tkDefaultArgsFunction;\n\n\tstatic const MetaCallable * getMetaCallable() {\n\t\tstatic const MetaCallable metaCallable(\n\t\t\t&metaCallableGetClassType,\n\t\t\t&metaCallableGetParameterCountInfo,\n\t\t\t&metaCallableGetReturnType,\n\t\t\t&metaCallableGetParameterType,\n\t\t\t&metaCallableRankInvoke,\n\t\t\t&metaCallableCanInvoke,\n\t\t\t&metaCallableInvoke\n\t\t);\n\t\treturn &metaCallable;\n\t}\n\n\tstatic bool isValidArgumentCount(const Variant & func, const std::size_t argumentCount)\n\t{\n\t\treturn ((int)argumentCount >= argsCount - func.get<FunctionType &>().getDefaultArgsCount())\n\t\t\t&& ((int)argumentCount <= argsCount)\n\t\t;\n\t}\n\n\tstatic const MetaType * metaCallableGetClassType(const Variant & func)\n\t{\n\t\tconst FunctionType & defaultArgsFunc = func.get<FunctionType &>();\n\t\tconst Variant & underlyingFunc = defaultArgsFunc.getFunc();\n\t\treturn underlyingFunc.getMetaType()->getMetaCallable()->getClassType(underlyingFunc);\n\t}\n\n\tstatic MetaCallable::ParameterCountInfo metaCallableGetParameterCountInfo(const Variant & func)\n\t{\n\t\treturn MetaCallable::ParameterCountInfo {\n\t\t\tMetaCallable::detectResultCount<ReturnType>(),\n\t\t\targsCount - func.get<FunctionType &>().getDefaultArgsCount(),\n\t\t\targsCount\n\t\t};\n\t}\n\n\tstatic const MetaType * metaCallableGetReturnType(const Variant & )\n\t{\n\t\treturn getMetaType<ReturnType>();\n\t}\n\n\tstatic const MetaType * metaCallableGetParameterType(const Variant & , const int index)\n\t{\n\t\treturn internal_::getMetaTypeAt(index, ArgumentTypeList());\n\t}\n\n\tstatic int metaCallableRankInvoke(const Variant & func, const Variant & , const ArgumentSpan & arguments)\n\t{\n\t\tif(! isValidArgumentCount(func, arguments.size())) {\n\t\t\treturn invokeRankNone;\n\t\t}\n\n\t\treturn internal_::MetaCallableInvokeChecker<ArgumentTypeList>::rankInvoke(arguments);\n\t}\n\n\tstatic bool metaCallableCanInvoke(const Variant & func, const Variant & , const ArgumentSpan & arguments)\n\t{\n\t\tif(! isValidArgumentCount(func, arguments.size())) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn internal_::MetaCallableInvokeChecker<ArgumentTypeList>::canInvoke(arguments);\n\t}\n\n\tstatic Variant metaCallableInvoke(const Variant & func, const Variant & instance, const ArgumentSpan & arguments)\n\t{\n\t\tif(! isValidArgumentCount(func, arguments.size())) {\n\t\t\traiseException<IllegalArgumentException>();\n\t\t\treturn Variant();\n\t\t}\n\n\t\tconst FunctionType & defaultArgsFunc = func.get<FunctionType &>();\n\t\tconst Variant & underlyingFunc = defaultArgsFunc.getFunc();\n\t\tif(arguments.size() == argsCount) {\n\t\t\treturn underlyingFunc.getMetaType()->getMetaCallable()->invoke(underlyingFunc, instance, arguments);\n\t\t}\n\t\telse {\n\t\t\tstd::array<Variant, argsCount> newArguments;\n\t\t\tint i = 0;\n\t\t\tfor(; i < (int)arguments.size(); ++i) {\n\t\t\t\tnewArguments[i] = arguments[i];\n\t\t\t}\n\t\t\twhile(i < argsCount) {\n\t\t\t\tnewArguments[i] = defaultArgsFunc.getDefaultArgs()[argsCount - i - 1];\n\t\t\t\t++i;\n\t\t\t}\n\t\t\treturn underlyingFunc.getMetaType()->getMetaCallable()->invoke(underlyingFunc, instance, newArguments);\n\t\t}\n\t}\n\n};\n\n\n}\n\n\n#endif\n\n\n'metapp/include/metapp/allmetatypes.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef METAPP_ALLMETATYPES_H_969872685611\n#define METAPP_ALLMETATYPES_H_969872685611\n\n#include \"metapp/compiler.h\"\n\n#include \"metapp/metatypes/accessor.h\"\n#include \"metapp/metatypes/arithmetic.h\"\n#include \"metapp/metatypes/array.h\"\n#include \"metapp/metatypes/constructor.h\"\n#include \"metapp/metatypes/cv.h\"\n#include \"metapp/metatypes/default_args_function.h\"\n#include \"metapp/metatypes/enum.h\"\n#include \"metapp/metatypes/function.h\"\n#include \"metapp/metatypes/member_data.h\"\n#include \"metapp/metatypes/member_function.h\"\n#include \"metapp/metatypes/metatype_metatype.h\"\n#include \"metapp/metatypes/metarepo_metatype.h\"\n#include \"metapp/metatypes/overloaded_function.h\"\n#include \"metapp/metatypes/pointer.h\"\n#include \"metapp/metatypes/reference.h\"\n#include \"metapp/metatypes/std_deque.h\"\n#include \"metapp/metatypes/std_forward_list.h\"\n#include \"metapp/metatypes/std_list.h\"\n#include \"metapp/metatypes/std_map.h\"\n#include \"metapp/metatypes/std_pair.h\"\n#include \"metapp/metatypes/std_queue.h\"\n#include \"metapp/metatypes/std_set.h\"\n#include \"metapp/metatypes/std_stack.h\"\n#include \"metapp/metatypes/std_string.h\"\n#include \"metapp/metatypes/std_shared_ptr.h\"\n#include \"metapp/metatypes/std_array.h\"\n#include \"metapp/metatypes/std_function.h\"\n#include \"metapp/metatypes/std_tuple.h\"\n#include \"metapp/metatypes/std_unique_ptr.h\"\n#include \"metapp/metatypes/std_unordered_map.h\"\n#include \"metapp/metatypes/std_unordered_set.h\"\n#include \"metapp/metatypes/std_vector.h\"\n#include \"metapp/metatypes/std_weak_ptr.h\"\n#include \"metapp/metatypes/variadic_function.h\"\n#include \"metapp/metatypes/variant_metatype.h\"\n\n#ifdef METAPP_SUPPORT_STANDARD_17\n#include \"metapp/metatypes/std_any.h\"\n#include \"metapp/metatypes/std_variant.h\"\n#endif\n\n#endif\n\n\n'metapp/include/metapp/variant.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef METAPP_VARIANT_H_969872685611\n#define METAPP_VARIANT_H_969872685611\n\n#include \"metapp/implement/variant_intf.h\"\n\n#include \"metapp/metatype.h\"\n\n#include \"metapp/implement/variant_impl.h\"\n\n#endif\n\n'metapp/tests/unittest/metatypes/test_std_queue.cpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"test.h\"\n\n#include \"metapp/variant.h\"\n#include \"metapp/allmetatypes.h\"\n\nTEST_CASE(\"metatypes, std::queue<std::string>\")\n{\n\tusing Type = std::queue<std::string>;\n\tType container;\n\tmetapp::Variant v(container);\n\tREQUIRE(metapp::getTypeKind(v) == metapp::tkStdQueue);\n\tv.get<Type &>().push(\"good\");\n\tv.get<Type &>().push(\"great\");\n\tREQUIRE(v.get<Type &>().front() == \"good\");\n\tREQUIRE(v.get<Type &>().back() == \"great\");\n\tREQUIRE(v.getMetaType()->equal(metapp::getMetaType<std::queue<std::string> >()));\n}\n\nTEST_CASE(\"metatypes, std::priority_queue<int>\")\n{\n\tusing Type = std::priority_queue<int>;\n\tType container;\n\tmetapp::Variant v(container);\n\tREQUIRE(metapp::getTypeKind(v) == metapp::tkStdPriorityQueue);\n\tv.get<Type &>().push(1);\n\tv.get<Type &>().push(5);\n\tREQUIRE(v.get<Type &>().top() == 5);\n\tREQUIRE(v.getMetaType()->equal(metapp::getMetaType<std::priority_queue<int> >()));\n}\n\n",
        "gt": [
            "'metapp/include/metapp/implement/variant_intf.h'",
            "'metapp/include/metapp/variant.h'",
            "'metapp/include/metapp/metatypes/default_args_function.h'",
            "'metapp/include/metapp/allmetatypes.h'",
            "'metapp/tests/unittest/metatypes/test_std_queue.cpp'"
        ]
    },
    {
        "files": [
            "'jarkViewer/jarkViewer/include/opencv2/gapi.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/render/render.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/gcall.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/streaming/desync.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/render.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/garg.hpp'"
        ],
        "content": "'jarkViewer/jarkViewer/include/opencv2/gapi.hpp'\n:\n\n\n\n\n\n\n#ifndef OPENCV_GAPI_HPP\n#define OPENCV_GAPI_HPP\n\n#include <memory>\n\n\n\n#include <opencv2/gapi/gmat.hpp>\n#include <opencv2/gapi/garray.hpp>\n#include <opencv2/gapi/gscalar.hpp>\n#include <opencv2/gapi/gopaque.hpp>\n#include <opencv2/gapi/gframe.hpp>\n#include <opencv2/gapi/gcomputation.hpp>\n#include <opencv2/gapi/gcompiled.hpp>\n#include <opencv2/gapi/gtyped.hpp>\n#include <opencv2/gapi/gkernel.hpp>\n#include <opencv2/gapi/operators.hpp>\n\n\n\n#include <opencv2/gapi/streaming/desync.hpp>\n#include <opencv2/gapi/streaming/format.hpp>\n\n#endif\n\n'jarkViewer/jarkViewer/include/opencv2/gapi/render/render.hpp'\n:\n\n\n\n\n\n\n#ifndef OPENCV_GAPI_RENDER_HPP\n#define OPENCV_GAPI_RENDER_HPP\n\n#include <opencv2/gapi/render/render_types.hpp>\n\n#include <opencv2/gapi.hpp>\n\n\n\nnamespace cv\n{\nnamespace gapi\n{\nnamespace wip\n{\nnamespace draw\n{\n\nusing GMat2     = std::tuple<cv::GMat,cv::GMat>;\nusing GMatDesc2 = std::tuple<cv::GMatDesc,cv::GMatDesc>;\n\n\n\n\nvoid GAPI_EXPORTS_W render(cv::Mat& bgr,\n                           const Prims& prims,\n                           cv::GCompileArgs&& args = {});\n\n\nvoid GAPI_EXPORTS_W render(cv::Mat& y_plane,\n                           cv::Mat& uv_plane,\n                           const Prims& prims,\n                           cv::GCompileArgs&& args = {});\n\n\nvoid GAPI_EXPORTS render(cv::MediaFrame& frame,\n                         const Prims& prims,\n                         cv::GCompileArgs&& args = {});\n\n\nG_TYPED_KERNEL_M(GRenderNV12, <GMat2(cv::GMat,cv::GMat,cv::GArray<wip::draw::Prim>)>, \"org.opencv.render.nv12\")\n{\n     static GMatDesc2 outMeta(GMatDesc y_plane, GMatDesc uv_plane, GArrayDesc)\n     {\n         return std::make_tuple(y_plane, uv_plane);\n     }\n};\n\nG_TYPED_KERNEL(GRenderBGR, <cv::GMat(cv::GMat,cv::GArray<wip::draw::Prim>)>, \"org.opencv.render.bgr\")\n{\n     static GMatDesc outMeta(GMatDesc bgr, GArrayDesc)\n     {\n         return bgr;\n     }\n};\n\nG_TYPED_KERNEL(GRenderFrame, <cv::GFrame(cv::GFrame, cv::GArray<wip::draw::Prim>)>, \"org.opencv.render.frame\")\n{\n    static GFrameDesc outMeta(GFrameDesc desc, GArrayDesc)\n    {\n        return desc;\n    }\n};\n\n\nGAPI_EXPORTS_W GMat render3ch(const GMat& src, const GArray<Prim>& prims);\n\n\nGAPI_EXPORTS_W GMat2 renderNV12(const GMat& y,\n                                const GMat& uv,\n                                const GArray<Prim>& prims);\n\n\nGAPI_EXPORTS GFrame renderFrame(const GFrame& m_frame,\n                                const GArray<Prim>& prims);\n\n\n\n}\n}\n\n\nnamespace render\n{\nnamespace ocv\n{\n    GAPI_EXPORTS_W cv::GKernelPackage kernels();\n\n}\n}\n}\n\nnamespace detail\n{\n    template<> struct CompileArgTag<cv::gapi::wip::draw::freetype_font>\n    {\n        static const char* tag() { return \"gapi.freetype_font\"; }\n    };\n}\n\n}\n\n#endif\n\n'jarkViewer/jarkViewer/include/opencv2/gapi/gcall.hpp'\n:\n\n\n\n\n\n\n#ifndef OPENCV_GAPI_GCALL_HPP\n#define OPENCV_GAPI_GCALL_HPP\n\n#include <opencv2/gapi/garg.hpp>\n#include <opencv2/gapi/gmat.hpp>\n#include <opencv2/gapi/gscalar.hpp>\n#include <opencv2/gapi/gframe.hpp>\n#include <opencv2/gapi/garray.hpp>\n#include <opencv2/gapi/gopaque.hpp>\n\nnamespace cv {\n\nstruct GKernel;\n\n\n\n\n\nclass GAPI_EXPORTS GCall final\n{\npublic:\n    class Priv;\n\n    explicit GCall(const GKernel &k);\n    ~GCall();\n\n    template<typename... Ts>\n    GCall& pass(Ts&&... args)\n    {\n        setArgs({cv::GArg(std::move(args))...});\n        return *this;\n    }\n\n\n    GMat    yield      (int output = 0);\n    GMatP   yieldP     (int output = 0);\n    GScalar yieldScalar(int output = 0);\n    GFrame  yieldFrame (int output = 0);\n\n    template<class T> GArray<T> yieldArray(int output = 0)\n    {\n        return GArray<T>(yieldArray(output));\n    }\n\n    template<class T> GOpaque<T> yieldOpaque(int output = 0)\n    {\n        return GOpaque<T>(yieldOpaque(output));\n    }\n\n\n    Priv& priv();\n    const Priv& priv() const;\n\n\n\n    GKernel& kernel();\n    cv::util::any& params();\n\n    void setArgs(std::vector<GArg> &&args);\n\nprotected:\n    std::shared_ptr<Priv> m_priv;\n\n\n    detail::GArrayU yieldArray(int output = 0);\n    detail::GOpaqueU yieldOpaque(int output = 0);\n};\n\n}\n\n#endif\n\n'jarkViewer/jarkViewer/include/opencv2/gapi/streaming/desync.hpp'\n:\n\n\n\n\n\n\n#ifndef OPENCV_GAPI_GSTREAMING_DESYNC_HPP\n#define OPENCV_GAPI_GSTREAMING_DESYNC_HPP\n\n#include <tuple>\n\n#include <opencv2/gapi/util/util.hpp>\n#include <opencv2/gapi/gtype_traits.hpp>\n#include <opencv2/gapi/garg.hpp>\n#include <opencv2/gapi/gcall.hpp>\n#include <opencv2/gapi/gkernel.hpp>\n\nnamespace cv {\nnamespace gapi {\nnamespace streaming {\n\nnamespace detail {\nstruct GDesync {\n    static const char *id() {\n        return \"org.opencv.streaming.desync\";\n    }\n\n\n\n\n\n\n    template<typename... R, int... IIs>\n    static std::tuple<R...> yield(cv::GCall &call, cv::detail::Seq<IIs...>) {\n        return std::make_tuple(cv::detail::Yield<R>::yield(call, IIs)...);\n    }\n};\n\ntemplate<typename G>\nG desync(const G &g) {\n    cv::GKernel k{\n          GDesync::id()\n        , \"\"\n        , [](const GMetaArgs &a, const GArgs &) {return a;}\n        , {cv::detail::GTypeTraits<G>::shape}\n        , {cv::detail::GTypeTraits<G>::op_kind}\n        , {cv::detail::GObtainCtor<G>::get()}\n        , {cv::detail::GTypeTraits<G>::op_kind}\n    };\n    cv::GCall call(std::move(k));\n    call.pass(g);\n    return std::get<0>(GDesync::yield<G>(call, cv::detail::MkSeq<1>::type()));\n}\n}\n\n\nGAPI_EXPORTS GMat desync(const GMat &g);\nGAPI_EXPORTS GFrame desync(const GFrame &f);\n\n}\n}\n}\n\n#endif\n\n'jarkViewer/jarkViewer/include/opencv2/gapi/render.hpp'\n:\n\n\n\n\n\n#ifndef OPENCV_GAPI_RENDER_ROOT_HPP\n#define OPENCV_GAPI_RENDER_ROOT_HPP\n\n\n\n#include <opencv2/gapi/render/render.hpp>\n\n#endif\n\n'jarkViewer/jarkViewer/include/opencv2/gapi/garg.hpp'\n:\n\n\n\n\n\n\n#ifndef OPENCV_GAPI_GARG_HPP\n#define OPENCV_GAPI_GARG_HPP\n\n#include <vector>\n#include <unordered_map>\n#include <type_traits>\n\n#include <opencv2/gapi/opencv_includes.hpp>\n#include <opencv2/gapi/own/mat.hpp>\n#include <opencv2/gapi/media.hpp>\n\n#include <opencv2/gapi/util/util.hpp>\n#include <opencv2/gapi/util/any.hpp>\n#include <opencv2/gapi/util/variant.hpp>\n\n#include <opencv2/gapi/gmat.hpp>\n#include <opencv2/gapi/gscalar.hpp>\n#include <opencv2/gapi/garray.hpp>\n#include <opencv2/gapi/gopaque.hpp>\n#include <opencv2/gapi/gframe.hpp>\n#include <opencv2/gapi/gtype_traits.hpp>\n#include <opencv2/gapi/gmetaarg.hpp>\n#include <opencv2/gapi/streaming/source.hpp>\n#include <opencv2/gapi/rmat.hpp>\n\nnamespace cv {\n\nclass GArg;\n\nnamespace detail {\n    template<typename T>\n    using is_garg = std::is_same<GArg, typename std::decay<T>::type>;\n}\n\n\n\n\n\nclass GAPI_EXPORTS GArg\n{\npublic:\n    GArg() {}\n\n    template<typename T, typename std::enable_if<!detail::is_garg<T>::value, int>::type = 0>\n    explicit GArg(const T &t)\n        : kind(detail::GTypeTraits<T>::kind)\n        , opaque_kind(detail::GOpaqueTraits<T>::kind)\n        , value(detail::wrap_gapi_helper<T>::wrap(t))\n    {\n    }\n\n    template<typename T, typename std::enable_if<!detail::is_garg<T>::value, int>::type = 0>\n    explicit GArg(T &&t)\n        : kind(detail::GTypeTraits<typename std::decay<T>::type>::kind)\n        , opaque_kind(detail::GOpaqueTraits<typename std::decay<T>::type>::kind)\n        , value(detail::wrap_gapi_helper<T>::wrap(t))\n    {\n    }\n\n    template<typename T> inline T& get()\n    {\n        return util::any_cast<typename std::remove_reference<T>::type>(value);\n    }\n\n    template<typename T> inline const T& get() const\n    {\n        return util::any_cast<typename std::remove_reference<T>::type>(value);\n    }\n\n    template<typename T> inline T& unsafe_get()\n    {\n        return util::unsafe_any_cast<typename std::remove_reference<T>::type>(value);\n    }\n\n    template<typename T> inline const T& unsafe_get() const\n    {\n        return util::unsafe_any_cast<typename std::remove_reference<T>::type>(value);\n    }\n\n    detail::ArgKind kind = detail::ArgKind::OPAQUE_VAL;\n    detail::OpaqueKind opaque_kind = detail::OpaqueKind::CV_UNKNOWN;\n\nprotected:\n    util::any value;\n};\n\nusing GArgs = std::vector<GArg>;\n\n\n\nusing GRunArgBase  = util::variant<\n#if !defined(GAPI_STANDALONE)\n    cv::UMat,\n#endif\n    cv::RMat,\n    cv::gapi::wip::IStreamSource::Ptr,\n    cv::Mat,\n    cv::Scalar,\n    cv::detail::VectorRef,\n    cv::detail::OpaqueRef,\n    cv::MediaFrame\n    >;\n\nnamespace detail {\ntemplate<typename,typename>\nstruct in_variant;\n\ntemplate<typename T, typename... Types>\nstruct in_variant<T, util::variant<Types...> >\n    : std::integral_constant<bool, cv::detail::contains<T, Types...>::value > {\n};\n}\n\nstruct GAPI_EXPORTS GRunArg: public GRunArgBase\n{\n\n    using Meta = std::unordered_map<std::string, util::any>;\n    Meta meta;\n\n\n\n    GRunArg();\n    GRunArg(const cv::GRunArg &arg);\n    GRunArg(cv::GRunArg &&arg);\n\n    GRunArg& operator= (const GRunArg &arg);\n    GRunArg& operator= (GRunArg &&arg);\n\n    template <typename T>\n    GRunArg(const T &t,\n            const Meta &m = Meta{},\n            typename std::enable_if< detail::in_variant<T, GRunArgBase>::value, int>::type = 0)\n        : GRunArgBase(t)\n        , meta(m)\n    {\n    }\n    template <typename T>\n    GRunArg(T &&t,\n            const Meta &m = Meta{},\n            typename std::enable_if< detail::in_variant<T, GRunArgBase>::value, int>::type = 0)\n        : GRunArgBase(std::move(t))\n        , meta(m)\n    {\n    }\n    template <typename T> auto operator= (const T &t)\n        -> typename std::enable_if< detail::in_variant<T, GRunArgBase>::value, cv::GRunArg>::type&\n    {\n        GRunArgBase::operator=(t);\n        return *this;\n    }\n    template <typename T> auto operator= (T&& t)\n        -> typename std::enable_if< detail::in_variant<T, GRunArgBase>::value, cv::GRunArg>::type&\n    {\n        GRunArgBase::operator=(std::move(t));\n        return *this;\n    }\n};\nusing GRunArgs = std::vector<GRunArg>;\n\n\n\ninline GRunArgs& operator += (GRunArgs &lhs, const GRunArgs &rhs)\n{\n    lhs.reserve(lhs.size() + rhs.size());\n    lhs.insert(lhs.end(), rhs.begin(), rhs.end());\n    return lhs;\n}\n\nnamespace gapi\n{\nnamespace wip\n{\n\nstruct GAPI_EXPORTS Data: public GRunArg\n{\n    using GRunArg::GRunArg;\n    template <typename T>\n    Data& operator= (const T& t) { GRunArg::operator=(t); return *this; }\n    template <typename T>\n    Data& operator= (T&& t) { GRunArg::operator=(std::move(t)); return *this; }\n};\n}\n}\n\nusing GRunArgP = util::variant<\n#if !defined(GAPI_STANDALONE)\n    cv::UMat*,\n#endif\n    cv::Mat*,\n    cv::RMat*,\n    cv::Scalar*,\n    cv::MediaFrame*,\n    cv::detail::VectorRef,\n    cv::detail::OpaqueRef\n    >;\nusing GRunArgsP = std::vector<GRunArgP>;\n\n\n\ninline GRunArgsP& operator += (GRunArgsP &lhs, const GRunArgsP &rhs)\n{\n    lhs.reserve(lhs.size() + rhs.size());\n    lhs.insert(lhs.end(), rhs.begin(), rhs.end());\n    return lhs;\n}\n\nnamespace gapi\n{\n\n\n\nGAPI_EXPORTS cv::GRunArgsP bind(cv::GRunArgs &out_args);\n\n\nGAPI_EXPORTS cv::GRunArg   bind(cv::GRunArgP &out);\n\n}\n\ntemplate<typename... Ts> inline GRunArgs gin(const Ts&... args)\n{\n    return GRunArgs{ GRunArg(detail::wrap_host_helper<Ts>::wrap_in(args))... };\n}\n\ntemplate<typename... Ts> inline GRunArgsP gout(Ts&... args)\n{\n    return GRunArgsP{ GRunArgP(detail::wrap_host_helper<Ts>::wrap_out(args))... };\n}\n\nstruct GTypeInfo;\nusing GTypesInfo = std::vector<GTypeInfo>;\n\n\nnamespace detail {\nstruct ExtractArgsCallback\n{\n    cv::GRunArgs operator()(const cv::GTypesInfo& info) const { return c(info); }\n    using CallBackT = std::function<cv::GRunArgs(const cv::GTypesInfo& info)>;\n    CallBackT c;\n};\n\nstruct ExtractMetaCallback\n{\n    cv::GMetaArgs operator()(const cv::GTypesInfo& info) const { return c(info); }\n    using CallBackT = std::function<cv::GMetaArgs(const cv::GTypesInfo& info)>;\n    CallBackT c;\n};\n\nvoid constructGraphOutputs(const cv::GTypesInfo &out_info,\n                           cv::GRunArgs         &args,\n                           cv::GRunArgsP        &outs);\n}\n\n}\n\n#endif\n",
        "gt": [
            "'jarkViewer/jarkViewer/include/opencv2/gapi/garg.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/gcall.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/streaming/desync.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/render/render.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/render.hpp'"
        ]
    },
    {
        "files": [
            "'LuaSTGPlus/include/lstg/Core/Subsystem/Audio/SampleBuffer.hpp'",
            "'LuaSTGPlus/src/Core/Subsystem/AudioSystem.cpp'",
            "'LuaSTGPlus/src/Core/Subsystem/Audio/DspPlugins/Reverb.hpp'",
            "'LuaSTGPlus/include/lstg/Core/Subsystem/Audio/BusChannel.hpp'",
            "'LuaSTGPlus/include/lstg/Core/Subsystem/Audio/SampleView.hpp'"
        ],
        "content": "'LuaSTGPlus/include/lstg/Core/Subsystem/Audio/SampleBuffer.hpp'\n:\n#pragma once\n#include \"SampleView.hpp\"\n\nnamespace lstg::Subsystem::Audio\n{\n\n    template <size_t ChannelCount, size_t SampleCount>\n    class alignas(16) StaticSampleBuffer\n    {\n    public:\n        StaticSampleBuffer()\n        {\n            Clear();\n        }\n\n        const float* operator[](size_t channel) const noexcept\n        {\n            assert(channel < ChannelCount);\n            return m_stSamples[channel];\n        }\n\n        float* operator[](size_t channel) noexcept\n        {\n            assert(channel < ChannelCount);\n            return m_stSamples[channel];\n        }\n\n    public:\n\n        size_t GetSampleCount() const noexcept { return SampleCount; }\n\n\n        void Clear() noexcept\n        {\n            ::memset(m_stSamples, 0, sizeof(m_stSamples));\n        }\n\n    private:\n        static_assert((SampleCount * sizeof(float)) % 16 == 0);\n        float m_stSamples[ChannelCount][SampleCount];\n    };\n\n    template <size_t ChannelCount, size_t SampleCount>\n    SampleView<ChannelCount> ToSampleView(StaticSampleBuffer<ChannelCount, SampleCount>& buffer) noexcept\n    {\n        std::array<float*, ChannelCount> channels;\n        for (size_t i = 0; i < ChannelCount; ++i)\n            channels[i] = buffer[i];\n        return { channels, buffer.GetSampleCount() };\n    }\n}\n\n'LuaSTGPlus/src/Core/Subsystem/AudioSystem.cpp'\n:\n#include <lstg/Core/Subsystem/AudioSystem.hpp>\n\n#include \"Audio/DspPlugins/Limiter.hpp\"\n#include \"Audio/DspPlugins/Filter.hpp\"\n#include \"Audio/DspPlugins/Reverb.hpp\"\n\nusing namespace std;\nusing namespace lstg;\nusing namespace lstg::Subsystem;\n\nAudioSystem::AudioSystem(SubsystemContainer& container)\n{\n\n    m_pEngine = make_unique<Audio::AudioEngine>();\n\n\n    RegisterDspPlugin<Audio::DspPlugins::Limiter>();\n    RegisterDspPlugin<Audio::DspPlugins::Filter>();\n    RegisterDspPlugin<Audio::DspPlugins::Reverb>();\n}\n\nAudioSystem::~AudioSystem()\n{\n}\n\nResult<Audio::DspPluginPtr> AudioSystem::CreateDspPlugin(std::string_view name) noexcept\n{\n    auto it = m_stDspPluginFactory.find(name);\n    if (it == m_stDspPluginFactory.end())\n        return make_error_code(errc::no_such_file_or_directory);\n    try\n    {\n        assert(it->second);\n        return it->second();\n    }\n    catch (...)\n    {\n        return make_error_code(errc::not_enough_memory);\n    }\n}\n\nvoid AudioSystem::OnUpdate(double elapsedTime) noexcept\n{\n    m_pEngine->Update(elapsedTime);\n}\n\n'LuaSTGPlus/src/Core/Subsystem/Audio/DspPlugins/Reverb.hpp'\n:\n#pragma once\n#include <vector>\n#include <lstg/Core/Subsystem/Audio/IDspPlugin.hpp>\n#include <lstg/Core/Subsystem/Audio/ISoundDecoder.hpp>\n#include <lstg/Core/Subsystem/Audio/BusChannel.hpp>\n\nnamespace lstg::Subsystem::Audio::DspPlugins\n{\n\n    class Reverb :\n        public IDspPlugin\n    {\n        class MonoReverb\n        {\n        public:\n            MonoReverb(float extraSpreadBase = 0.f);\n\n        public:\n            void Process(SampleView<1> samples) noexcept;\n\n        public:\n            float GetRoomSize() const noexcept { return m_fRoomSize.load(std::memory_order_relaxed); }\n            void SetRoomSize(float roomSize) noexcept;\n\n            float GetDamp() const noexcept { return m_fDamp.load(std::memory_order_relaxed); }\n            void SetDamp(float damp) noexcept;\n\n            float GetWet() const noexcept { return m_fWet.load(std::memory_order_relaxed); }\n            void SetWet(float wet) noexcept { m_fWet.store(wet, std::memory_order_relaxed); }\n\n            float GetDry() const noexcept { return m_fDry.load(std::memory_order_relaxed); }\n            void SetDry(float dry) noexcept { m_fDry.store(dry, std::memory_order_relaxed); }\n\n            float GetExtraSpread() const noexcept { return m_fExtraSpread.load(std::memory_order_relaxed); }\n            void SetExtraSpread(float v) noexcept { m_fExtraSpread.store(v, std::memory_order_relaxed); }\n\n            float GetPreDelay() const noexcept { return m_fPreDelay.load(std::memory_order_relaxed); }\n            void SetPreDelay(float v) noexcept { m_fPreDelay.store(v, std::memory_order_relaxed); }\n\n            float GetPreDelayFeedback() const noexcept { return m_fPreDelayFeedback.load(std::memory_order_relaxed); }\n            void SetPreDelayFeedback(float v) noexcept { m_fPreDelayFeedback.store(v, std::memory_order_relaxed); }\n\n            float GetHighPassFilter() const noexcept { return m_fHighPassFilter.load(std::memory_order_relaxed); }\n            void SetHighPassFilter(float v) noexcept;\n\n        private:\n            void CheckParameters() noexcept;\n            void RefreshParameters() noexcept;\n\n        private:\n            enum {\n                kCombs = 8,\n                kAllPasses = 4,\n                kMaxEchoMs = 500,\n                kEchoBufferSize = static_cast<size_t>((static_cast<float>(kMaxEchoMs) / 1000.0) * ISoundDecoder::kSampleRate + 1.0),\n            };\n\n\n            std::atomic<float> m_fRoomSize;\n            std::atomic<float> m_fDamp;\n            std::atomic<float> m_fWet;\n            std::atomic<float> m_fDry;\n            std::atomic<float> m_fExtraSpread;\n            std::atomic<float> m_fPreDelay;\n            std::atomic<float> m_fPreDelayFeedback;\n            std::atomic<float> m_fHighPassFilter;\n\n\n            uint32_t m_uCurrentVersion = 0;\n            std::atomic<uint32_t> m_bDirtyVersion;\n\n            struct Comb\n            {\n                size_t Pos = 0;\n                std::vector<float> Buffer;\n                float Feedback = 0;\n                float Damp = 0;\n                float DampHistory = 0;\n                int32_t ExtraSpreadFrames = 0;\n            };\n\n            struct AllPass\n            {\n                size_t Pos = 0;\n                std::vector<float> Buffer;\n                int32_t ExtraSpreadFrames = 0;\n            };\n\n\n            Comb m_stComb[kCombs];\n            AllPass m_stAllPass[kAllPasses];\n            int32_t m_iEchoBufferPos = 0;\n            std::array<float, kEchoBufferSize> m_stEchoBuffer;\n            std::array<float, BusChannel::kSampleCount> m_stInputBuffer;\n            std::array<float, BusChannel::kSampleCount> m_stOutputBuffer;\n\n            float m_fHpfH1 = 0.f;\n            float m_fHpfH2 = 0.f;\n        };\n\n    public:\n        static const char* GetNameStatic() noexcept;\n\n    public:\n        Reverb();\n\n    public:\n        const char* GetName() const noexcept override;\n        size_t GetParameterCount() const noexcept override;\n        const DspPluginParameterInfo& GetParameterInfo(size_t index) const noexcept override;\n        Result<float> GetSliderParameter(std::string_view id) const noexcept override;\n        Result<void> SetSliderParameter(std::string_view id, float value) noexcept override;\n        Result<int32_t> GetEnumParameter(std::string_view id) const noexcept override;\n        Result<void> SetEnumParameter(std::string_view id, int32_t value) noexcept override;\n        void Process(SampleView<2> samples) noexcept override;\n\n    private:\n        MonoReverb m_stReverb[2] { 0.f, 0.000521f };\n    };\n}\n\n'LuaSTGPlus/include/lstg/Core/Subsystem/Audio/BusChannel.hpp'\n:\n#pragma once\n#include <vector>\n#include \"IDspPlugin.hpp\"\n#include \"SampleBuffer.hpp\"\n#include \"ISoundDecoder.hpp\"\n\n#ifndef LSTG_AUDIO_SINGLE_THREADED\n#ifdef LSTG_PLATFORM_EMSCRIPTEN\n#define LSTG_AUDIO_SINGLE_THREADED\n#endif\n#endif\n\n#ifndef LSTG_AUDIO_SINGLE_THREADED\n#include <mutex>\n#endif\n\nnamespace lstg::Subsystem::Audio\n{\n\n    using BusId = size_t;\n\n    enum class BusSendStages\n    {\n        BeforeVolume = 0,\n        AfterVolume,\n        AfterPan,\n        Count_,\n    };\n\n\n    struct BusSend\n    {\n\n        BusId Target = 0;\n\n\n        float Volume = 1.f;\n    };\n\n\n    struct alignas(16) BusChannel\n    {\n        enum {\n            kSampleCount = 1024,\n        };\n\n#ifndef LSTG_AUDIO_SINGLE_THREADED\n        mutable std::mutex Mutex;\n#endif\n\n\n        StaticSampleBuffer<ISoundDecoder::kChannels, kSampleCount> MixBuffer;\n\n\n        std::array<std::atomic<float>, ISoundDecoder::kChannels> PeakVolume {};\n\n\n        std::vector<size_t> Playlists;\n\n\n        std::atomic<bool> Muted;\n\n\n        std::atomic<float> Volume;\n\n\n        std::atomic<float> Pan;\n\n\n        std::vector<DspPluginPtr> PluginList;\n\n\n        std::vector<BusSend> SendList[static_cast<int>(BusSendStages::Count_)];\n\n\n        BusId OutputTarget = static_cast<size_t>(-1);\n\n        BusChannel() noexcept\n        {\n            for (size_t i = 0; i < ISoundDecoder::kChannels; ++i)\n                PeakVolume[i].store(0.f, std::memory_order_relaxed);\n            Muted.store(false, std::memory_order_release);\n            Volume.store(1.f, std::memory_order_release);\n            Pan.store(0.f, std::memory_order_release);\n        }\n    };\n}\n\n'LuaSTGPlus/include/lstg/Core/Subsystem/Audio/SampleView.hpp'\n:\n#pragma once\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <array>\n#include <vector>\n\nnamespace lstg::Subsystem::Audio\n{\n    namespace detail\n    {\n        void MixSamples(float* output, const float* input, size_t samples, float scale) noexcept;\n        void ScaleSamples(float* data, size_t samples, float scale) noexcept;\n    }\n\n\n    template <size_t ChannelCount>\n    class SampleView\n    {\n    public:\n        SampleView() noexcept\n        {\n            ::memset(m_pChannelData, 0, sizeof(m_pChannelData));\n        }\n\n        SampleView(float* (&data)[ChannelCount], size_t count) noexcept\n            : m_uSampleCount(count)\n        {\n            for (size_t i = 0; i < ChannelCount; ++i)\n                m_pChannelData[i] = data[i];\n        }\n\n        SampleView(std::array<float*, ChannelCount> data, size_t count) noexcept\n            : m_uSampleCount(count)\n        {\n            for (size_t i = 0; i < ChannelCount; ++i)\n                m_pChannelData[i] = data[i];\n        }\n\n        SampleView(std::vector<float> (&data)[ChannelCount]) noexcept\n        {\n            m_uSampleCount = data[0].size();\n            for (size_t i = 0; i < ChannelCount; ++i)\n            {\n                m_pChannelData[i] = data[i].data();\n                assert(data[i].size() == m_uSampleCount);\n            }\n        }\n\n        SampleView(const SampleView& org) noexcept\n            : m_uSampleCount(org.m_uSampleCount)\n        {\n            for (size_t i = 0; i < ChannelCount; ++i)\n                m_pChannelData[i] = org.m_pChannelData[i];\n        }\n\n        SampleView& operator=(const SampleView& rhs) noexcept\n        {\n            if (this == &rhs)\n                return *this;\n            m_uSampleCount = rhs.m_uSampleCount;\n            for (size_t i = 0; i < ChannelCount; ++i)\n                m_pChannelData[i] = rhs.m_pChannelData[i];\n            return *this;\n        }\n\n        const float* operator[](size_t channel) const noexcept\n        {\n            assert(channel < ChannelCount);\n            return m_pChannelData[channel];\n        }\n\n        float* operator[](size_t channel) noexcept\n        {\n            assert(channel < ChannelCount);\n            return m_pChannelData[channel];\n        }\n\n        SampleView& operator+=(const SampleView& rhs) noexcept\n        {\n            assert(GetSampleCount() == rhs.GetSampleCount());\n\n            std::array<float, ChannelCount> scale {};\n            scale.fill(1.f);\n\n            MixSamples(rhs, scale);\n            return *this;\n        }\n\n        SampleView& operator*=(float value) noexcept\n        {\n            for (size_t i = 0; i < ChannelCount; ++i)\n                detail::ScaleSamples(operator[](i), GetSampleCount(), value);\n            return *this;\n        }\n\n        SampleView& operator*=(const std::array<float, ChannelCount>& value) noexcept\n        {\n            for (size_t i = 0; i < ChannelCount; ++i)\n                detail::ScaleSamples(operator[](i), GetSampleCount(), value[i]);\n            return *this;\n        }\n\n    public:\n\n        [[nodiscard]] size_t GetSampleCount() const noexcept { return m_uSampleCount; }\n\n\n        SampleView<ChannelCount> Slice(size_t begin, size_t end) noexcept\n        {\n            begin = std::min(m_uSampleCount, begin);\n            end = std::min(m_uSampleCount, end);\n            if (begin > end)\n                std::swap(begin, end);\n            auto len = end - begin;\n\n            std::array<float*, ChannelCount> data {};\n            for (size_t i = 0; i < ChannelCount; ++i)\n                data[i] = m_pChannelData[i] + begin;\n            return { data, len };\n        }\n\n\n        void MixSamples(const SampleView& rhs, std::array<float, ChannelCount>& scale) noexcept\n        {\n            assert(GetSampleCount() == rhs.GetSampleCount());\n\n            for (size_t i = 0; i < ChannelCount; ++i)\n                detail::MixSamples(operator[](i), rhs[i], GetSampleCount(), scale[i]);\n        }\n\n\n        std::array<float, ChannelCount> GetPeakValue() const noexcept\n        {\n            std::array<float, ChannelCount> ret {};\n            ret.fill(0.f);\n\n            for (size_t i = 0; i < ChannelCount; ++i)\n            {\n                for (size_t j = 0; j < m_uSampleCount; ++j)\n                {\n                    float l = std::abs(m_pChannelData[i][j]);\n                    if (l > ret[i])\n                        ret[i] = l;\n                }\n            }\n            return ret;\n        }\n\n\n        SampleView<1> GetChannel(size_t ch) const noexcept\n        {\n            assert(ch < ChannelCount);\n            float* arr[1] = { m_pChannelData[ch] };\n            return { arr, m_uSampleCount };\n        }\n\n    protected:\n        size_t m_uSampleCount = 0;\n        float* m_pChannelData[ChannelCount];\n    };\n}\n",
        "gt": [
            "'LuaSTGPlus/include/lstg/Core/Subsystem/Audio/SampleView.hpp'",
            "'LuaSTGPlus/include/lstg/Core/Subsystem/Audio/SampleBuffer.hpp'",
            "'LuaSTGPlus/include/lstg/Core/Subsystem/Audio/BusChannel.hpp'",
            "'LuaSTGPlus/src/Core/Subsystem/Audio/DspPlugins/Reverb.hpp'",
            "'LuaSTGPlus/src/Core/Subsystem/AudioSystem.cpp'"
        ]
    },
    {
        "files": [
            "'Luz/deps/glm/glm.hpp'",
            "'Luz/deps/glm/ext.hpp'",
            "'Luz/deps/glm/mat4x2.hpp'"
        ],
        "content": "'Luz/deps/glm/glm.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"detail/_fixes.hpp\"\n\n#include \"detail/setup.hpp\"\n\n#pragma once\n\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <limits>\n#include <cassert>\n#include \"fwd.hpp\"\n\n#include \"vec2.hpp\"\n#include \"vec3.hpp\"\n#include \"vec4.hpp\"\n#include \"mat2x2.hpp\"\n#include \"mat2x3.hpp\"\n#include \"mat2x4.hpp\"\n#include \"mat3x2.hpp\"\n#include \"mat3x3.hpp\"\n#include \"mat3x4.hpp\"\n#include \"mat4x2.hpp\"\n#include \"mat4x3.hpp\"\n#include \"mat4x4.hpp\"\n\n#include \"trigonometric.hpp\"\n#include \"exponential.hpp\"\n#include \"common.hpp\"\n#include \"packing.hpp\"\n#include \"geometric.hpp\"\n#include \"matrix.hpp\"\n#include \"vector_relational.hpp\"\n#include \"integer.hpp\"\n\n'Luz/deps/glm/ext.hpp'\n:\n\n\n\n#include \"detail/setup.hpp\"\n\n#pragma once\n\n#include \"glm.hpp\"\n\n#if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_MESSAGE_EXT_INCLUDED_DISPLAYED)\n#\tdefine GLM_MESSAGE_EXT_INCLUDED_DISPLAYED\n#\tpragma message(\"GLM: All extensions included (not recommended)\")\n#endif\n\n#include \"./ext/matrix_clip_space.hpp\"\n#include \"./ext/matrix_common.hpp\"\n\n#include \"./ext/matrix_double2x2.hpp\"\n#include \"./ext/matrix_double2x2_precision.hpp\"\n#include \"./ext/matrix_double2x3.hpp\"\n#include \"./ext/matrix_double2x3_precision.hpp\"\n#include \"./ext/matrix_double2x4.hpp\"\n#include \"./ext/matrix_double2x4_precision.hpp\"\n#include \"./ext/matrix_double3x2.hpp\"\n#include \"./ext/matrix_double3x2_precision.hpp\"\n#include \"./ext/matrix_double3x3.hpp\"\n#include \"./ext/matrix_double3x3_precision.hpp\"\n#include \"./ext/matrix_double3x4.hpp\"\n#include \"./ext/matrix_double3x4_precision.hpp\"\n#include \"./ext/matrix_double4x2.hpp\"\n#include \"./ext/matrix_double4x2_precision.hpp\"\n#include \"./ext/matrix_double4x3.hpp\"\n#include \"./ext/matrix_double4x3_precision.hpp\"\n#include \"./ext/matrix_double4x4.hpp\"\n#include \"./ext/matrix_double4x4_precision.hpp\"\n\n#include \"./ext/matrix_float2x2.hpp\"\n#include \"./ext/matrix_float2x2_precision.hpp\"\n#include \"./ext/matrix_float2x3.hpp\"\n#include \"./ext/matrix_float2x3_precision.hpp\"\n#include \"./ext/matrix_float2x4.hpp\"\n#include \"./ext/matrix_float2x4_precision.hpp\"\n#include \"./ext/matrix_float3x2.hpp\"\n#include \"./ext/matrix_float3x2_precision.hpp\"\n#include \"./ext/matrix_float3x3.hpp\"\n#include \"./ext/matrix_float3x3_precision.hpp\"\n#include \"./ext/matrix_float3x4.hpp\"\n#include \"./ext/matrix_float3x4_precision.hpp\"\n#include \"./ext/matrix_float4x2.hpp\"\n#include \"./ext/matrix_float4x2_precision.hpp\"\n#include \"./ext/matrix_float4x3.hpp\"\n#include \"./ext/matrix_float4x3_precision.hpp\"\n#include \"./ext/matrix_float4x4.hpp\"\n#include \"./ext/matrix_float4x4_precision.hpp\"\n\n#include \"./ext/matrix_int2x2.hpp\"\n#include \"./ext/matrix_int2x2_sized.hpp\"\n#include \"./ext/matrix_int2x3.hpp\"\n#include \"./ext/matrix_int2x3_sized.hpp\"\n#include \"./ext/matrix_int2x4.hpp\"\n#include \"./ext/matrix_int2x4_sized.hpp\"\n#include \"./ext/matrix_int3x2.hpp\"\n#include \"./ext/matrix_int3x2_sized.hpp\"\n#include \"./ext/matrix_int3x3.hpp\"\n#include \"./ext/matrix_int3x3_sized.hpp\"\n#include \"./ext/matrix_int3x4.hpp\"\n#include \"./ext/matrix_int3x4_sized.hpp\"\n#include \"./ext/matrix_int4x2.hpp\"\n#include \"./ext/matrix_int4x2_sized.hpp\"\n#include \"./ext/matrix_int4x3.hpp\"\n#include \"./ext/matrix_int4x3_sized.hpp\"\n#include \"./ext/matrix_int4x4.hpp\"\n#include \"./ext/matrix_int4x4_sized.hpp\"\n\n#include \"./ext/matrix_uint2x2.hpp\"\n#include \"./ext/matrix_uint2x2_sized.hpp\"\n#include \"./ext/matrix_uint2x3.hpp\"\n#include \"./ext/matrix_uint2x3_sized.hpp\"\n#include \"./ext/matrix_uint2x4.hpp\"\n#include \"./ext/matrix_uint2x4_sized.hpp\"\n#include \"./ext/matrix_uint3x2.hpp\"\n#include \"./ext/matrix_uint3x2_sized.hpp\"\n#include \"./ext/matrix_uint3x3.hpp\"\n#include \"./ext/matrix_uint3x3_sized.hpp\"\n#include \"./ext/matrix_uint3x4.hpp\"\n#include \"./ext/matrix_uint3x4_sized.hpp\"\n#include \"./ext/matrix_uint4x2.hpp\"\n#include \"./ext/matrix_uint4x2_sized.hpp\"\n#include \"./ext/matrix_uint4x3.hpp\"\n#include \"./ext/matrix_uint4x3_sized.hpp\"\n#include \"./ext/matrix_uint4x4.hpp\"\n#include \"./ext/matrix_uint4x4_sized.hpp\"\n\n#include \"./ext/matrix_projection.hpp\"\n#include \"./ext/matrix_relational.hpp\"\n#include \"./ext/matrix_transform.hpp\"\n\n#include \"./ext/quaternion_common.hpp\"\n#include \"./ext/quaternion_double.hpp\"\n#include \"./ext/quaternion_double_precision.hpp\"\n#include \"./ext/quaternion_float.hpp\"\n#include \"./ext/quaternion_float_precision.hpp\"\n#include \"./ext/quaternion_exponential.hpp\"\n#include \"./ext/quaternion_geometric.hpp\"\n#include \"./ext/quaternion_relational.hpp\"\n#include \"./ext/quaternion_transform.hpp\"\n#include \"./ext/quaternion_trigonometric.hpp\"\n\n#include \"./ext/scalar_common.hpp\"\n#include \"./ext/scalar_constants.hpp\"\n#include \"./ext/scalar_integer.hpp\"\n#include \"./ext/scalar_packing.hpp\"\n#include \"./ext/scalar_relational.hpp\"\n#include \"./ext/scalar_ulp.hpp\"\n\n#include \"./ext/scalar_int_sized.hpp\"\n#include \"./ext/scalar_uint_sized.hpp\"\n\n#include \"./ext/vector_common.hpp\"\n#include \"./ext/vector_integer.hpp\"\n#include \"./ext/vector_packing.hpp\"\n#include \"./ext/vector_relational.hpp\"\n#include \"./ext/vector_ulp.hpp\"\n\n#include \"./ext/vector_bool1.hpp\"\n#include \"./ext/vector_bool1_precision.hpp\"\n#include \"./ext/vector_bool2.hpp\"\n#include \"./ext/vector_bool2_precision.hpp\"\n#include \"./ext/vector_bool3.hpp\"\n#include \"./ext/vector_bool3_precision.hpp\"\n#include \"./ext/vector_bool4.hpp\"\n#include \"./ext/vector_bool4_precision.hpp\"\n\n#include \"./ext/vector_double1.hpp\"\n#include \"./ext/vector_double1_precision.hpp\"\n#include \"./ext/vector_double2.hpp\"\n#include \"./ext/vector_double2_precision.hpp\"\n#include \"./ext/vector_double3.hpp\"\n#include \"./ext/vector_double3_precision.hpp\"\n#include \"./ext/vector_double4.hpp\"\n#include \"./ext/vector_double4_precision.hpp\"\n\n#include \"./ext/vector_float1.hpp\"\n#include \"./ext/vector_float1_precision.hpp\"\n#include \"./ext/vector_float2.hpp\"\n#include \"./ext/vector_float2_precision.hpp\"\n#include \"./ext/vector_float3.hpp\"\n#include \"./ext/vector_float3_precision.hpp\"\n#include \"./ext/vector_float4.hpp\"\n#include \"./ext/vector_float4_precision.hpp\"\n\n#include \"./ext/vector_int1.hpp\"\n#include \"./ext/vector_int1_sized.hpp\"\n#include \"./ext/vector_int2.hpp\"\n#include \"./ext/vector_int2_sized.hpp\"\n#include \"./ext/vector_int3.hpp\"\n#include \"./ext/vector_int3_sized.hpp\"\n#include \"./ext/vector_int4.hpp\"\n#include \"./ext/vector_int4_sized.hpp\"\n\n#include \"./ext/vector_uint1.hpp\"\n#include \"./ext/vector_uint1_sized.hpp\"\n#include \"./ext/vector_uint2.hpp\"\n#include \"./ext/vector_uint2_sized.hpp\"\n#include \"./ext/vector_uint3.hpp\"\n#include \"./ext/vector_uint3_sized.hpp\"\n#include \"./ext/vector_uint4.hpp\"\n#include \"./ext/vector_uint4_sized.hpp\"\n\n#include \"./gtc/bitfield.hpp\"\n#include \"./gtc/color_space.hpp\"\n#include \"./gtc/constants.hpp\"\n#include \"./gtc/epsilon.hpp\"\n#include \"./gtc/integer.hpp\"\n#include \"./gtc/matrix_access.hpp\"\n#include \"./gtc/matrix_integer.hpp\"\n#include \"./gtc/matrix_inverse.hpp\"\n#include \"./gtc/matrix_transform.hpp\"\n#include \"./gtc/noise.hpp\"\n#include \"./gtc/packing.hpp\"\n#include \"./gtc/quaternion.hpp\"\n#include \"./gtc/random.hpp\"\n#include \"./gtc/reciprocal.hpp\"\n#include \"./gtc/round.hpp\"\n#include \"./gtc/type_precision.hpp\"\n#include \"./gtc/type_ptr.hpp\"\n#include \"./gtc/ulp.hpp\"\n#include \"./gtc/vec1.hpp\"\n#if GLM_CONFIG_ALIGNED_GENTYPES == GLM_ENABLE\n#\tinclude \"./gtc/type_aligned.hpp\"\n#endif\n\n#ifdef GLM_ENABLE_EXPERIMENTAL\n#include \"./gtx/associated_min_max.hpp\"\n#include \"./gtx/bit.hpp\"\n#include \"./gtx/closest_point.hpp\"\n#include \"./gtx/color_encoding.hpp\"\n#include \"./gtx/color_space.hpp\"\n#include \"./gtx/color_space_YCoCg.hpp\"\n#include \"./gtx/compatibility.hpp\"\n#include \"./gtx/component_wise.hpp\"\n#include \"./gtx/dual_quaternion.hpp\"\n#include \"./gtx/euler_angles.hpp\"\n#include \"./gtx/extend.hpp\"\n#include \"./gtx/extended_min_max.hpp\"\n#include \"./gtx/fast_exponential.hpp\"\n#include \"./gtx/fast_square_root.hpp\"\n#include \"./gtx/fast_trigonometry.hpp\"\n#include \"./gtx/functions.hpp\"\n#include \"./gtx/gradient_paint.hpp\"\n#include \"./gtx/handed_coordinate_space.hpp\"\n#include \"./gtx/integer.hpp\"\n#include \"./gtx/intersect.hpp\"\n#include \"./gtx/log_base.hpp\"\n#include \"./gtx/matrix_cross_product.hpp\"\n#include \"./gtx/matrix_interpolation.hpp\"\n#include \"./gtx/matrix_major_storage.hpp\"\n#include \"./gtx/matrix_operation.hpp\"\n#include \"./gtx/matrix_query.hpp\"\n#include \"./gtx/mixed_product.hpp\"\n#include \"./gtx/norm.hpp\"\n#include \"./gtx/normal.hpp\"\n#include \"./gtx/normalize_dot.hpp\"\n#include \"./gtx/number_precision.hpp\"\n#include \"./gtx/optimum_pow.hpp\"\n#include \"./gtx/orthonormalize.hpp\"\n#include \"./gtx/perpendicular.hpp\"\n#include \"./gtx/polar_coordinates.hpp\"\n#include \"./gtx/projection.hpp\"\n#include \"./gtx/quaternion.hpp\"\n#include \"./gtx/raw_data.hpp\"\n#include \"./gtx/rotate_vector.hpp\"\n#include \"./gtx/spline.hpp\"\n#include \"./gtx/std_based_type.hpp\"\n#if !(GLM_COMPILER & GLM_COMPILER_CUDA)\n#\tinclude \"./gtx/string_cast.hpp\"\n#endif\n#include \"./gtx/transform.hpp\"\n#include \"./gtx/transform2.hpp\"\n#include \"./gtx/vec_swizzle.hpp\"\n#include \"./gtx/vector_angle.hpp\"\n#include \"./gtx/vector_query.hpp\"\n#include \"./gtx/wrap.hpp\"\n\n#if GLM_HAS_TEMPLATE_ALIASES\n#\tinclude \"./gtx/scalar_multiplication.hpp\"\n#endif\n\n#if GLM_HAS_RANGE_FOR\n#\tinclude \"./gtx/range.hpp\"\n#endif\n#endif\n\n'Luz/deps/glm/mat4x2.hpp'\n:\n\n\n#pragma once\n#include \"./ext/matrix_double4x2.hpp\"\n#include \"./ext/matrix_double4x2_precision.hpp\"\n#include \"./ext/matrix_float4x2.hpp\"\n#include \"./ext/matrix_float4x2_precision.hpp\"\n\n",
        "gt": [
            "'Luz/deps/glm/mat4x2.hpp'",
            "'Luz/deps/glm/glm.hpp'",
            "'Luz/deps/glm/ext.hpp'"
        ]
    },
    {
        "files": [
            "'LittleEngineVk/engine/include/le/graphics/particle.hpp'",
            "'LittleEngineVk/engine/include/le/graphics/primitive.hpp'",
            "'LittleEngineVk/engine/src/graphics/particle.cpp'"
        ],
        "content": "'LittleEngineVk/engine/include/le/graphics/particle.hpp'\n:#pragma once\n#include <le/core/inclusive_range.hpp>\n#include <le/core/time.hpp>\n#include <le/core/transform.hpp>\n#include <le/graphics/material.hpp>\n#include <le/graphics/primitive.hpp>\n#include <le/graphics/render_object.hpp>\n#include <le/graphics/rgba.hpp>\n\nnamespace le::graphics {\nstruct Particle {\n\tstruct Config;\n\tclass Emitter;\n\n\tenum Flag : std::uint32_t {\n\t\teTranslate = 1 << 0,\n\t\teRotate = 1 << 1,\n\t\teScale = 1 << 2,\n\t\teTint = 1 << 3,\n\t};\n\n\tusing Modifiers = std::uint32_t;\n\n\tstruct {\n\t\tglm::vec3 linear{};\n\t\tRadians angular{};\n\t} velocity{};\n\n\tstruct {\n\t\tInclusiveRange<graphics::Rgba> tint{};\n\t\tInclusiveRange<glm::vec2> scale{};\n\t} lerp{};\n\n\tDuration ttl{};\n\n\tglm::vec3 position{};\n\tRadians rotation{};\n\tglm::vec2 scale{};\n\tgraphics::Rgba tint{};\n\tDuration elapsed{};\n\tfloat alpha{};\n};\n\nstruct Particle::Config {\n\tstruct {\n\t\tInclusiveRange<glm::vec3> position{};\n\t\tInclusiveRange<Radians> rotation{};\n\t} initial{};\n\n\tstruct {\n\t\tstruct {\n\t\t\tInclusiveRange<Radians> angle{Degrees{-180.0f}, Degrees{180.0f}};\n\t\t\tInclusiveRange<float> speed{-1.0f, 1.0f};\n\t\t} linear{};\n\t\tInclusiveRange<Radians> angular{Degrees{-90.0f}, Degrees{90.0f}};\n\t} velocity{};\n\n\tstruct {\n\t\tInclusiveRange<graphics::Rgba> tint{graphics::white_v, graphics::Rgba{.channels = {0xff, 0xff, 0xff, 0x0}}};\n\t\tInclusiveRange<glm::vec2> scale{glm::vec3{1.0f}, glm::vec3{0.0f}};\n\t} lerp{};\n\n\tInclusiveRange<Duration> ttl{2s, 10s};\n\tglm::vec2 quad_size{100.0f};\n\tstd::size_t count{100};\n\tbool respawn{true};\n};\n\nclass Particle::Emitter {\n  public:\n\tConfig config{};\n\tgraphics::UnlitMaterial material{};\n\tModifiers modifiers{eTranslate};\n\tTransform transform{};\n\n\tauto respawn_all(glm::quat const& view) -> void;\n\tauto update(glm::quat const& view, Duration dt) -> void;\n\t[[nodiscard]] auto render_object() const -> graphics::RenderObject;\n\n\t[[nodiscard]] auto active_particles() const -> std::size_t { return m_particles.size(); }\n\n  private:\n\t[[nodiscard]] auto make_particle() const -> Particle;\n\n\tstd::unique_ptr<graphics::DynamicPrimitive> m_primitive{std::make_unique<graphics::DynamicPrimitive>()};\n\tstd::vector<Particle> m_particles{};\n\tstd::vector<graphics::RenderInstance> m_instances{};\n};\n}\n\n'LittleEngineVk/engine/include/le/graphics/primitive.hpp'\n:#pragma once\n#include <le/core/ptr.hpp>\n#include <le/graphics/buffering.hpp>\n#include <le/graphics/defer.hpp>\n#include <le/graphics/geometry.hpp>\n#include <le/graphics/resource.hpp>\n\nnamespace le::graphics {\nclass Primitive {\n  public:\n\tPrimitive(Primitive const&) = delete;\n\tauto operator=(Primitive const&) -> Primitive& = delete;\n\n\tPrimitive(Primitive&&) = default;\n\tauto operator=(Primitive&&) -> Primitive& = default;\n\n\tPrimitive() = default;\n\tvirtual ~Primitive() = default;\n\n\tstruct Layout {\n\t\tstd::uint32_t vertex_count{};\n\t\tstd::uint32_t index_count{};\n\t\tstd::uint32_t bone_count{};\n\t};\n\n\t[[nodiscard]] auto layout() const -> Layout const& { return m_layout; }\n\n\tvirtual auto set_geometry(Geometry const& geometry) -> void = 0;\n\tvirtual auto set_geometry(Geometry&& geometry) -> void;\n\tvirtual auto draw(std::uint32_t instances, vk::CommandBuffer cmd) const -> void = 0;\n\n  protected:\n\tstruct Buffers {\n\t\tvk::Buffer vertices{};\n\t\tvk::Buffer indices{};\n\t\tvk::Buffer bones{};\n\t\tvk::DeviceSize index_offset{};\n\t};\n\n\tauto draw(Buffers const& buffers, std::uint32_t instances, vk::CommandBuffer cmd) const -> void;\n\n\tLayout m_layout{};\n};\n\nclass StaticPrimitive : public Primitive {\n  public:\n\tauto set_geometry(Geometry const& geometry) -> void final;\n\tauto draw(std::uint32_t instances, vk::CommandBuffer cmd) const -> void final;\n\n  protected:\n\tstruct Data {\n\t\tstd::unique_ptr<DeviceBuffer> vertices_indices{};\n\t\tstd::unique_ptr<DeviceBuffer> bones{};\n\t\tvk::DeviceSize index_offset{};\n\t};\n\n\tDefer<Data> m_data{};\n};\n\nclass DynamicPrimitive : public Primitive {\n  public:\n\tDynamicPrimitive();\n\n\tauto set_geometry(Geometry const& geometry) -> void final;\n\tauto set_geometry(Geometry&& geometry) -> void final;\n\tauto draw(std::uint32_t instances, vk::CommandBuffer cmd) const -> void final;\n\n  protected:\n\tauto write_at(FrameIndex index) const -> void;\n\n\tGeometry m_geometry{};\n\tBuffered<std::shared_ptr<HostBuffer>> m_vertices_indices{};\n\tmutable vk::DeviceSize m_index_offset{};\n};\n}\n\n'LittleEngineVk/engine/src/graphics/particle.cpp'\n:#include <le/core/nvec3.hpp>\n#include <le/core/random.hpp>\n#include <le/core/visitor.hpp>\n#include <le/core/zip_ranges.hpp>\n#include <le/graphics/device.hpp>\n#include <le/graphics/particle.hpp>\n#include <algorithm>\n\nnamespace le::graphics {\nnamespace {\nauto random_vec3(InclusiveRange<glm::vec3> const& range) -> glm::vec3 {\n\tauto ret = glm::vec3{};\n\tret.x = random_range(range.lo.x, range.hi.x);\n\tret.y = random_range(range.lo.y, range.hi.y);\n\tret.z = random_range(range.lo.z, range.hi.z);\n\treturn ret;\n}\n\nauto translate(Particle& out, Duration dt) -> void { out.position += out.velocity.linear * dt.count(); }\nauto rotate(Particle& out, Duration dt) -> void { out.rotation.value += out.velocity.angular.value * dt.count(); }\nauto scaleify(Particle& out) -> void { out.scale = glm::mix(out.lerp.scale.lo, out.lerp.scale.hi, out.alpha); }\nauto tintify(Particle& out) -> void { out.tint.channels = glm::mix(out.lerp.tint.lo.channels, out.lerp.tint.hi.channels, out.alpha); }\n}\n\nauto Particle::Emitter::make_particle() const -> Particle {\n\tauto ret = Particle{};\n\n\tauto const spread = Degrees{random_range(config.velocity.linear.angle.lo.value, config.velocity.linear.angle.hi.value)};\n\tauto const direction = glm::vec3{glm::sin(spread), glm::cos(spread), 0.0f};\n\tret.velocity.linear = random_range(config.velocity.linear.speed.lo, config.velocity.linear.speed.hi) * direction;\n\tret.velocity.angular = random_range(config.velocity.angular.lo.value, config.velocity.angular.hi.value);\n\n\tret.lerp.scale = config.lerp.scale;\n\tret.lerp.tint = config.lerp.tint;\n\n\tauto const initial_position = [&] {\n\t\tauto ret = config.initial.position;\n\t\tif (std::abs(ret.lo.z - ret.hi.z) < 0.01f) {\n\n\t\t\tret.hi.z = ret.lo.z + 0.1f;\n\t\t}\n\t\treturn ret;\n\t}();\n\tret.position = random_vec3(initial_position);\n\tret.rotation = random_range(config.initial.rotation.lo.value, config.initial.rotation.hi.value);\n\tret.scale = config.lerp.scale.lo;\n\n\tret.ttl = Duration{random_range(config.ttl.lo.count(), config.ttl.hi.count())};\n\tret.tint = ret.lerp.tint.lo;\n\n\treturn ret;\n}\n\nvoid Particle::Emitter::respawn_all(glm::quat const& view) {\n\tm_particles.clear();\n\tm_particles.reserve(config.count);\n\tauto respawn = config.respawn;\n\tconfig.respawn = true;\n\tupdate(view, {});\n\tconfig.respawn = respawn;\n}\n\nvoid Particle::Emitter::update(glm::quat const& view, Duration dt) {\n\tstd::erase_if(m_particles, [](Particle const& p) { return p.elapsed >= p.ttl; });\n\n\tif (config.respawn) {\n\t\tm_particles.reserve(config.count);\n\t\twhile (m_particles.size() < config.count) { m_particles.push_back(make_particle()); }\n\t}\n\n\tm_instances.resize(m_particles.size());\n\n\n\tauto const view_inverse = glm::inverse(view);\n\tfor (auto [particle, instance] : zip_ranges(m_particles, m_instances)) {\n\t\tparticle.elapsed += dt;\n\t\tparticle.alpha = std::clamp(particle.elapsed / particle.ttl, 0.0f, 1.0f);\n\t\tif ((modifiers & eTranslate) != 0) { translate(particle, dt); }\n\t\tif ((modifiers & eRotate) != 0) { rotate(particle, dt); }\n\t\tif ((modifiers & eScale) != 0) { scaleify(particle); }\n\t\tif ((modifiers & eTint) != 0) { tintify(particle); }\n\t\tauto const orientation = view_inverse * glm::rotate(glm::identity<glm::quat>(), particle.rotation.value, front_v);\n\t\tinstance.transform.set_orientation(orientation);\n\t\tinstance.transform.set_position(particle.position);\n\t\tinstance.transform.set_scale(glm::vec3{particle.scale, 1.0f});\n\t\tinstance.tint = particle.tint;\n\t}\n\n\tm_primitive->set_geometry(Geometry::from(Quad{.size = config.quad_size}));\n}\n\nauto Particle::Emitter::render_object() const -> RenderObject {\n\tauto ret = RenderObject{\n\t\t.material = &material,\n\t\t.primitive = m_primitive.get(),\n\t\t.parent = transform.matrix(),\n\t\t.instances = m_instances,\n\t};\n\treturn ret;\n}\n}\n",
        "gt": [
            "'LittleEngineVk/engine/include/le/graphics/primitive.hpp'",
            "'LittleEngineVk/engine/include/le/graphics/particle.hpp'",
            "'LittleEngineVk/engine/src/graphics/particle.cpp'"
        ]
    },
    {
        "files": [
            "'PreMulAlpha/BlendDemo/Framework3/glm/detail/glm.cpp'",
            "'PreMulAlpha/BlendDemo/Framework3/glm/matrix.hpp'",
            "'PreMulAlpha/BlendDemo/Framework3/glm/glm.hpp'",
            "'PreMulAlpha/BlendDemo/Framework3/glm/detail/func_matrix.hpp'"
        ],
        "content": "'PreMulAlpha/BlendDemo/Framework3/glm/detail/glm.cpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <glm/glm.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/gtx/dual_quaternion.hpp>\n\nnamespace glm{\nnamespace detail\n{\n\n\n\ntemplate struct tvec2<uint8, lowp>;\ntemplate struct tvec2<uint16, lowp>;\ntemplate struct tvec2<uint32, lowp>;\ntemplate struct tvec2<uint64, lowp>;\ntemplate struct tvec2<int8, lowp>;\ntemplate struct tvec2<int16, lowp>;\ntemplate struct tvec2<int32, lowp>;\ntemplate struct tvec2<int64, lowp>;\ntemplate struct tvec2<float32, lowp>;\ntemplate struct tvec2<float64, lowp>;\n\ntemplate struct tvec2<uint8, mediump>;\ntemplate struct tvec2<uint16, mediump>;\ntemplate struct tvec2<uint32, mediump>;\ntemplate struct tvec2<uint64, mediump>;\ntemplate struct tvec2<int8, mediump>;\ntemplate struct tvec2<int16, mediump>;\ntemplate struct tvec2<int32, mediump>;\ntemplate struct tvec2<int64, mediump>;\ntemplate struct tvec2<float32, mediump>;\ntemplate struct tvec2<float64, mediump>;\n\ntemplate struct tvec2<uint8, highp>;\ntemplate struct tvec2<uint16, highp>;\ntemplate struct tvec2<uint32, highp>;\ntemplate struct tvec2<uint64, highp>;\ntemplate struct tvec2<int8, highp>;\ntemplate struct tvec2<int16, highp>;\ntemplate struct tvec2<int32, highp>;\ntemplate struct tvec2<int64, highp>;\ntemplate struct tvec2<float32, highp>;\ntemplate struct tvec2<float64, highp>;\n\n\ntemplate struct tvec3<uint8, lowp>;\ntemplate struct tvec3<uint16, lowp>;\ntemplate struct tvec3<uint32, lowp>;\ntemplate struct tvec3<uint64, lowp>;\ntemplate struct tvec3<int8, lowp>;\ntemplate struct tvec3<int16, lowp>;\ntemplate struct tvec3<int32, lowp>;\ntemplate struct tvec3<int64, lowp>;\ntemplate struct tvec3<float32, lowp>;\ntemplate struct tvec3<float64, lowp>;\n\ntemplate struct tvec3<uint8, mediump>;\ntemplate struct tvec3<uint16, mediump>;\ntemplate struct tvec3<uint32, mediump>;\ntemplate struct tvec3<uint64, mediump>;\ntemplate struct tvec3<int8, mediump>;\ntemplate struct tvec3<int16, mediump>;\ntemplate struct tvec3<int32, mediump>;\ntemplate struct tvec3<int64, mediump>;\ntemplate struct tvec3<float32, mediump>;\ntemplate struct tvec3<float64, mediump>;\n\ntemplate struct tvec3<uint8, highp>;\ntemplate struct tvec3<uint16, highp>;\ntemplate struct tvec3<uint32, highp>;\ntemplate struct tvec3<uint64, highp>;\ntemplate struct tvec3<int8, highp>;\ntemplate struct tvec3<int16, highp>;\ntemplate struct tvec3<int32, highp>;\ntemplate struct tvec3<int64, highp>;\ntemplate struct tvec3<float32, highp>;\ntemplate struct tvec3<float64, highp>;\n\n\ntemplate struct tvec4<uint8, lowp>;\ntemplate struct tvec4<uint16, lowp>;\ntemplate struct tvec4<uint32, lowp>;\ntemplate struct tvec4<uint64, lowp>;\ntemplate struct tvec4<int8, lowp>;\ntemplate struct tvec4<int16, lowp>;\ntemplate struct tvec4<int32, lowp>;\ntemplate struct tvec4<int64, lowp>;\ntemplate struct tvec4<float32, lowp>;\ntemplate struct tvec4<float64, lowp>;\n\ntemplate struct tvec4<uint8, mediump>;\ntemplate struct tvec4<uint16, mediump>;\ntemplate struct tvec4<uint32, mediump>;\ntemplate struct tvec4<uint64, mediump>;\ntemplate struct tvec4<int8, mediump>;\ntemplate struct tvec4<int16, mediump>;\ntemplate struct tvec4<int32, mediump>;\ntemplate struct tvec4<int64, mediump>;\ntemplate struct tvec4<float32, mediump>;\ntemplate struct tvec4<float64, mediump>;\n\ntemplate struct tvec4<uint8, highp>;\ntemplate struct tvec4<uint16, highp>;\ntemplate struct tvec4<uint32, highp>;\ntemplate struct tvec4<uint64, highp>;\ntemplate struct tvec4<int8, highp>;\ntemplate struct tvec4<int16, highp>;\ntemplate struct tvec4<int32, highp>;\ntemplate struct tvec4<int64, highp>;\ntemplate struct tvec4<float32, highp>;\ntemplate struct tvec4<float64, highp>;\n\n\ntemplate struct tmat2x2<float32, lowp>;\ntemplate struct tmat2x2<float64, lowp>;\n\ntemplate struct tmat2x2<float32, mediump>;\ntemplate struct tmat2x2<float64, mediump>;\n\ntemplate struct tmat2x2<float32, highp>;\ntemplate struct tmat2x2<float64, highp>;\n\n\ntemplate struct tmat2x3<float32, lowp>;\ntemplate struct tmat2x3<float64, lowp>;\n\ntemplate struct tmat2x3<float32, mediump>;\ntemplate struct tmat2x3<float64, mediump>;\n\ntemplate struct tmat2x3<float32, highp>;\ntemplate struct tmat2x3<float64, highp>;\n\n\ntemplate struct tmat2x4<float32, lowp>;\ntemplate struct tmat2x4<float64, lowp>;\n\ntemplate struct tmat2x4<float32, mediump>;\ntemplate struct tmat2x4<float64, mediump>;\n\ntemplate struct tmat2x4<float32, highp>;\ntemplate struct tmat2x4<float64, highp>;\n\n\ntemplate struct tmat3x2<float32, lowp>;\ntemplate struct tmat3x2<float64, lowp>;\n\ntemplate struct tmat3x2<float32, mediump>;\ntemplate struct tmat3x2<float64, mediump>;\n\ntemplate struct tmat3x2<float32, highp>;\ntemplate struct tmat3x2<float64, highp>;\n\n\ntemplate struct tmat3x3<float32, lowp>;\ntemplate struct tmat3x3<float64, lowp>;\n\ntemplate struct tmat3x3<float32, mediump>;\ntemplate struct tmat3x3<float64, mediump>;\n\ntemplate struct tmat3x3<float32, highp>;\ntemplate struct tmat3x3<float64, highp>;\n\n\ntemplate struct tmat3x4<float32, lowp>;\ntemplate struct tmat3x4<float64, lowp>;\n\ntemplate struct tmat3x4<float32, mediump>;\ntemplate struct tmat3x4<float64, mediump>;\n\ntemplate struct tmat3x4<float32, highp>;\ntemplate struct tmat3x4<float64, highp>;\n\n\ntemplate struct tmat4x2<float32, lowp>;\ntemplate struct tmat4x2<float64, lowp>;\n\ntemplate struct tmat4x2<float32, mediump>;\ntemplate struct tmat4x2<float64, mediump>;\n\ntemplate struct tmat4x2<float32, highp>;\ntemplate struct tmat4x2<float64, highp>;\n\n\ntemplate struct tmat4x3<float32, lowp>;\ntemplate struct tmat4x3<float64, lowp>;\n\ntemplate struct tmat4x3<float32, mediump>;\ntemplate struct tmat4x3<float64, mediump>;\n\ntemplate struct tmat4x3<float32, highp>;\ntemplate struct tmat4x3<float64, highp>;\n\n\ntemplate struct tmat4x4<float32, lowp>;\ntemplate struct tmat4x4<float64, lowp>;\n\ntemplate struct tmat4x4<float32, mediump>;\ntemplate struct tmat4x4<float64, mediump>;\n\ntemplate struct tmat4x4<float32, highp>;\ntemplate struct tmat4x4<float64, highp>;\n\n\ntemplate struct tquat<float32, lowp>;\ntemplate struct tquat<float64, lowp>;\n\ntemplate struct tquat<float32, mediump>;\ntemplate struct tquat<float64, mediump>;\n\ntemplate struct tquat<float32, highp>;\ntemplate struct tquat<float64, highp>;\n\n\ntemplate struct tdualquat<float32, lowp>;\ntemplate struct tdualquat<float64, lowp>;\n\ntemplate struct tdualquat<float32, mediump>;\ntemplate struct tdualquat<float64, mediump>;\n\ntemplate struct tdualquat<float32, highp>;\ntemplate struct tdualquat<float64, highp>;\n\n}\n}\n\n\n'PreMulAlpha/BlendDemo/Framework3/glm/matrix.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef GLM_MATRIX_INCLUDED\n#define GLM_MATRIX_INCLUDED\n\n#include \"detail/func_matrix.hpp\"\n\n#endif\n\n'PreMulAlpha/BlendDemo/Framework3/glm/glm.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"detail/_fixes.hpp\"\n\n#ifndef GLM_INCLUDED\n#define GLM_INCLUDED\n\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <limits>\n#include <cassert>\n#include \"fwd.hpp\"\n\n#if(defined(GLM_MESSAGES) && !defined(GLM_MESSAGE_CORE_INCLUDED_DISPLAYED))\n#\tdefine GLM_MESSAGE_CORE_INCLUDED_DISPLAYED\n#\tpragma message(\"GLM: Core library included\")\n#endif\n\n#include \"vec2.hpp\"\n#include \"vec3.hpp\"\n#include \"vec4.hpp\"\n#include \"mat2x2.hpp\"\n#include \"mat2x3.hpp\"\n#include \"mat2x4.hpp\"\n#include \"mat3x2.hpp\"\n#include \"mat3x3.hpp\"\n#include \"mat3x4.hpp\"\n#include \"mat4x2.hpp\"\n#include \"mat4x3.hpp\"\n#include \"mat4x4.hpp\"\n\n#include \"trigonometric.hpp\"\n#include \"exponential.hpp\"\n#include \"common.hpp\"\n#include \"packing.hpp\"\n#include \"geometric.hpp\"\n#include \"matrix.hpp\"\n#include \"vector_relational.hpp\"\n#include \"integer.hpp\"\n\n#endif\n\n'PreMulAlpha/BlendDemo/Framework3/glm/detail/func_matrix.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef GLM_CORE_func_matrix\n#define GLM_CORE_func_matrix\n\n\n#include \"../detail/precision.hpp\"\n#include \"../detail/setup.hpp\"\n#include \"../detail/type_mat.hpp\"\n#include \"../vec2.hpp\"\n#include \"../vec3.hpp\"\n#include \"../vec4.hpp\"\n#include \"../mat2x2.hpp\"\n#include \"../mat2x3.hpp\"\n#include \"../mat2x4.hpp\"\n#include \"../mat3x2.hpp\"\n#include \"../mat3x3.hpp\"\n#include \"../mat3x4.hpp\"\n#include \"../mat4x2.hpp\"\n#include \"../mat4x3.hpp\"\n#include \"../mat4x4.hpp\"\n\nnamespace glm{\nnamespace detail\n{\n\ttemplate <typename T, precision P>\n\tstruct outerProduct_trait<T, P, tvec2, tvec2>\n\t{\n\t\ttypedef tmat2x2<T, P> type;\n\t};\n\n\ttemplate <typename T, precision P>\n\tstruct outerProduct_trait<T, P, tvec2, tvec3>\n\t{\n\t\ttypedef tmat2x3<T, P> type;\n\t};\n\n\ttemplate <typename T, precision P>\n\tstruct outerProduct_trait<T, P, tvec2, tvec4>\n\t{\n\t\ttypedef tmat2x4<T, P> type;\n\t};\n\n\ttemplate <typename T, precision P>\n\tstruct outerProduct_trait<T, P, tvec3, tvec2>\n\t{\n\t\ttypedef tmat3x2<T, P> type;\n\t};\n\n\ttemplate <typename T, precision P>\n\tstruct outerProduct_trait<T, P, tvec3, tvec3>\n\t{\n\t\ttypedef tmat3x3<T, P> type;\n\t};\n\n\ttemplate <typename T, precision P>\n\tstruct outerProduct_trait<T, P, tvec3, tvec4>\n\t{\n\t\ttypedef tmat3x4<T, P> type;\n\t};\n\n\ttemplate <typename T, precision P>\n\tstruct outerProduct_trait<T, P, tvec4, tvec2>\n\t{\n\t\ttypedef tmat4x2<T, P> type;\n\t};\n\n\ttemplate <typename T, precision P>\n\tstruct outerProduct_trait<T, P, tvec4, tvec3>\n\t{\n\t\ttypedef tmat4x3<T, P> type;\n\t};\n\n\ttemplate <typename T, precision P>\n\tstruct outerProduct_trait<T, P, tvec4, tvec4>\n\t{\n\t\ttypedef tmat4x4<T, P> type;\n\t};\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\ttemplate <typename T, precision P, template <typename, precision> class matType>\n\tGLM_FUNC_DECL matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y);\n\n\n\n\n\n\n\n\n\n\n\n\ttemplate <typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>\n\tGLM_FUNC_DECL typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r);\n\n\n\n\n\n\n\n#\tif((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC11))\n\t\ttemplate <typename T, precision P, template <typename, precision> class matType>\n\t\tGLM_FUNC_DECL typename matType<T, P>::transpose_type transpose(matType<T, P> const & x);\n#\tendif\n\n\n\n\n\n\n\n\ttemplate <typename T, precision P, template <typename, precision> class matType>\n\tGLM_FUNC_DECL T determinant(matType<T, P> const & m);\n\n\n\n\n\n\n\n\ttemplate <typename T, precision P, template <typename, precision> class matType>\n\tGLM_FUNC_DECL matType<T, P> inverse(matType<T, P> const & m);\n\n\n}\n\n#include \"func_matrix.inl\"\n\n#endif\n",
        "gt": [
            "'PreMulAlpha/BlendDemo/Framework3/glm/detail/func_matrix.hpp'",
            "'PreMulAlpha/BlendDemo/Framework3/glm/matrix.hpp'",
            "'PreMulAlpha/BlendDemo/Framework3/glm/glm.hpp'",
            "'PreMulAlpha/BlendDemo/Framework3/glm/detail/glm.cpp'"
        ]
    },
    {
        "files": [
            "'elaphureLink/elaphureLinkProxy/SocketClient.hpp'",
            "'elaphureLink/elaphureLinkProxy/proxy.cpp'",
            "'elaphureLink/thirdparty/asio/include/asio.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/execution/receiver_invocation_error.hpp'"
        ],
        "content": "'elaphureLink/elaphureLinkProxy/SocketClient.hpp'\n:﻿#pragma once\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n\n#include <sdkddkver.h>\n#include \"thirdparty/asio/include/asio.hpp\"\n\n#include \"pch.h\"\n\nusing asio::ip::tcp;\n\nclass SocketClient\n{\n    public:\n    SocketClient()\n        : is_running_(false),\n          connect_callback_(nullptr),\n          disconnect_callback_(nullptr)\n    {\n    }\n\n    void do_something();\n\n    ~SocketClient()\n    {\n\n\n\n        if (main_thread_.joinable()) {\n            main_thread_.join();\n        }\n    }\n\n    int init_socket(std::string address, std::string port = \"3240\")\n    {\n        socket_.reset(nullptr);\n\n        io_context_ = std::make_unique<asio::io_context>();\n        tcp::resolver resolver(get_io_context());\n\n        socket_ = std::make_unique<asio::ip::tcp::socket>(get_io_context());\n\n        try {\n            endpoint_ = resolver.resolve(address, port);\n        } catch (std::exception &e) {\n            return -1;\n        }\n\n        return 0;\n    }\n\n\n    void kill()\n    {\n        is_running_ = false;\n        if (k_is_proxy_init) {\n            k_shared_memory_ptr->info_page.is_proxy_ready       = 0;\n            k_shared_memory_ptr->consumer_page.command_response = 0xFFFFFFFF;\n            SetEvent(k_producer_event);\n            SetEvent(k_consumer_event);\n        }\n\n        socket_.get()->close();\n        io_context_.get()->stop();\n\n        Sleep(100);\n    }\n\n    int start()\n    {\n        using namespace std::chrono_literals;\n\n        std::unique_lock<std::mutex> lk(running_status_mutex_);\n        if (is_running_) {\n            return 0;\n        }\n\n        is_running_post_done_ = false;\n        is_running_           = true;\n\n        do_connect(endpoint_);\n\n        main_thread_ = std::thread([&]() {\n            try {\n                get_io_context().run();\n            } catch (std::exception &e) {\n                set_running_status(false, e.what());\n            }\n\n        });\n\n        running_cv_.wait(lk, [this]() { return is_running_post_done_; });\n\n        return !is_running_;\n    }\n\n    void wait_main_thread()\n    {\n        main_thread_.join();\n    }\n\n\n\n\n\n    public:\n    asio::io_context &get_io_context()\n    {\n        return *(io_context_.get());\n    }\n\n    asio::ip::tcp::socket &get_socket()\n    {\n        return *(socket_.get());\n    }\n\n    bool is_socket_running()\n    {\n        return is_running_;\n    }\n\n    void set_running_status(bool status, const std::string msg)\n    {\n        is_running_ = status;\n        if (status) {\n            if (connect_callback_) {\n                connect_callback_(msg.c_str());\n            }\n        } else {\n            if (disconnect_callback_) {\n                disconnect_callback_(msg.c_str());\n            }\n        }\n    }\n\n    void set_connect_callback(onSocketConnectCallbackType callback)\n    {\n        connect_callback_ = callback;\n    }\n\n    void set_disconnect_callback(onSocketDisconnectCallbackType callback)\n    {\n        disconnect_callback_ = callback;\n    }\n\n    private:\n    void close()\n    {\n        is_running_ = false;\n        if (k_is_proxy_init) {\n            k_shared_memory_ptr->info_page.is_proxy_ready       = 0;\n            k_shared_memory_ptr->consumer_page.command_response = 0xFFFFFFFF;\n            SetEvent(k_producer_event);\n            SetEvent(k_consumer_event);\n        }\n\n        asio::post(get_io_context(),\n                   [this]() {\n                       get_socket().close();\n                   });\n    }\n\n    void do_connect(const tcp::resolver::results_type &endpoints)\n    {\n        asio::async_connect(get_socket(), endpoints,\n                            [&](std::error_code ec, tcp::endpoint) {\n\n                                if (!ec) {\n                                    asio::ip::tcp::no_delay option(true);\n                                    get_socket().set_option(option);\n\n                                    set_keep_alive();\n\n                                    do_handshake();\n                                } else {\n                                    notify_connection_status(false, ec.message());\n                                    close();\n                                }\n                            });\n    }\n    void set_keep_alive();\n\n\n    void do_handshake();\n\n\n    void get_device_info();\n    void do_data_process();\n\n    void notify_connection_status(bool status, const std::string msg)\n    {\n        is_running_post_done_ = true;\n        set_running_status(status, msg);\n        running_cv_.notify_all();\n    }\n\n\n    private:\n    bool                    is_running_;\n    bool                    is_running_post_done_;\n    std::mutex              running_status_mutex_;\n    std::condition_variable running_cv_;\n\n    std::unique_ptr<asio::io_context> io_context_;\n    std::unique_ptr<tcp::socket>      socket_;\n\n    tcp::resolver::results_type endpoint_;\n\n    std::thread main_thread_;\n\n    onSocketConnectCallbackType    connect_callback_;\n    onSocketDisconnectCallbackType disconnect_callback_;\n};\n\n'elaphureLink/elaphureLinkProxy/proxy.cpp'\n:﻿#include \"pch.h\"\n\n#include \"SocketClient.hpp\"\n\n\nclass ProxyManager\n{\n    public:\n    ProxyManager()\n        : on_connect_callback_(nullptr),\n          on_socket_disconnect_callback_(nullptr)\n    {\n    }\n\n    bool is_proxy_running()\n    {\n        if (client_.get()) {\n            return client_.get()->is_socket_running();\n        }\n\n        return false;\n    }\n\n    void set_on_proxy_connect_callback(onSocketConnectCallbackType callback)\n    {\n        on_connect_callback_ = callback;\n\n        if (client_.get()) {\n            client_.get()->set_connect_callback(callback);\n        }\n    }\n\n    void set_on_proxy_disconnect_callback(onSocketDisconnectCallbackType callback)\n    {\n        on_socket_disconnect_callback_ = callback;\n\n        if (client_.get()) {\n            client_.get()->set_disconnect_callback(callback);\n        }\n    }\n\n    int start_with_address(std::string address)\n    {\n        stop();\n        client_ = std::make_unique<SocketClient>();\n\n        if (on_connect_callback_) {\n            client_.get()->set_connect_callback(on_connect_callback_);\n        }\n        if (on_socket_disconnect_callback_) {\n            client_.get()->set_disconnect_callback(on_socket_disconnect_callback_);\n        }\n\n        int ret = client_.get()->init_socket(address, \"3240\");\n        if (ret != 0) {\n            return ret;\n        }\n\n        return client_.get()->start();\n    }\n\n    void stop()\n    {\n        if (client_.get()) {\n            client_.get()->kill();\n        }\n        client_.reset(nullptr);\n    }\n\n    private:\n    onSocketConnectCallbackType    on_connect_callback_;\n    onSocketDisconnectCallbackType on_socket_disconnect_callback_;\n    std::unique_ptr<SocketClient>  client_;\n};\n\nProxyManager k_manager;\n\n\nPROXY_DLL_FUNCTION int el_proxy_start_with_address(char *address)\n{\n    return k_manager.start_with_address(address);\n}\n\n\nPROXY_DLL_FUNCTION void el_proxy_stop()\n{\n    if (k_is_proxy_init) {\n        return k_manager.stop();\n    }\n}\n\n\nPROXY_DLL_FUNCTION void el_proxy_set_on_connect_callback(onSocketConnectCallbackType callback)\n{\n    return k_manager.set_on_proxy_connect_callback(callback);\n}\n\n\nPROXY_DLL_FUNCTION void el_proxy_set_on_disconnect_callback(onSocketDisconnectCallbackType callback)\n{\n    return k_manager.set_on_proxy_disconnect_callback(callback);\n}\n\n'elaphureLink/thirdparty/asio/include/asio.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_HPP\n#define ASIO_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/associated_allocator.hpp\"\n#include \"asio/associated_executor.hpp\"\n#include \"asio/associated_cancellation_slot.hpp\"\n#include \"asio/associator.hpp\"\n#include \"asio/async_result.hpp\"\n#include \"asio/awaitable.hpp\"\n#include \"asio/basic_datagram_socket.hpp\"\n#include \"asio/basic_deadline_timer.hpp\"\n#include \"asio/basic_file.hpp\"\n#include \"asio/basic_io_object.hpp\"\n#include \"asio/basic_random_access_file.hpp\"\n#include \"asio/basic_raw_socket.hpp\"\n#include \"asio/basic_readable_pipe.hpp\"\n#include \"asio/basic_seq_packet_socket.hpp\"\n#include \"asio/basic_serial_port.hpp\"\n#include \"asio/basic_signal_set.hpp\"\n#include \"asio/basic_socket.hpp\"\n#include \"asio/basic_socket_acceptor.hpp\"\n#include \"asio/basic_socket_iostream.hpp\"\n#include \"asio/basic_socket_streambuf.hpp\"\n#include \"asio/basic_stream_file.hpp\"\n#include \"asio/basic_stream_socket.hpp\"\n#include \"asio/basic_streambuf.hpp\"\n#include \"asio/basic_waitable_timer.hpp\"\n#include \"asio/basic_writable_pipe.hpp\"\n#include \"asio/bind_allocator.hpp\"\n#include \"asio/bind_cancellation_slot.hpp\"\n#include \"asio/bind_executor.hpp\"\n#include \"asio/buffer.hpp\"\n#include \"asio/buffer_registration.hpp\"\n#include \"asio/buffered_read_stream_fwd.hpp\"\n#include \"asio/buffered_read_stream.hpp\"\n#include \"asio/buffered_stream_fwd.hpp\"\n#include \"asio/buffered_stream.hpp\"\n#include \"asio/buffered_write_stream_fwd.hpp\"\n#include \"asio/buffered_write_stream.hpp\"\n#include \"asio/buffers_iterator.hpp\"\n#include \"asio/cancellation_signal.hpp\"\n#include \"asio/cancellation_state.hpp\"\n#include \"asio/cancellation_type.hpp\"\n#include \"asio/co_spawn.hpp\"\n#include \"asio/completion_condition.hpp\"\n#include \"asio/compose.hpp\"\n#include \"asio/connect.hpp\"\n#include \"asio/connect_pipe.hpp\"\n#include \"asio/coroutine.hpp\"\n#include \"asio/deadline_timer.hpp\"\n#include \"asio/defer.hpp\"\n#include \"asio/detached.hpp\"\n#include \"asio/dispatch.hpp\"\n#include \"asio/error.hpp\"\n#include \"asio/error_code.hpp\"\n#include \"asio/execution.hpp\"\n#include \"asio/execution/allocator.hpp\"\n#include \"asio/execution/any_executor.hpp\"\n#include \"asio/execution/blocking.hpp\"\n#include \"asio/execution/blocking_adaptation.hpp\"\n#include \"asio/execution/bulk_execute.hpp\"\n#include \"asio/execution/bulk_guarantee.hpp\"\n#include \"asio/execution/connect.hpp\"\n#include \"asio/execution/context.hpp\"\n#include \"asio/execution/context_as.hpp\"\n#include \"asio/execution/execute.hpp\"\n#include \"asio/execution/executor.hpp\"\n#include \"asio/execution/invocable_archetype.hpp\"\n#include \"asio/execution/mapping.hpp\"\n#include \"asio/execution/occupancy.hpp\"\n#include \"asio/execution/operation_state.hpp\"\n#include \"asio/execution/outstanding_work.hpp\"\n#include \"asio/execution/prefer_only.hpp\"\n#include \"asio/execution/receiver.hpp\"\n#include \"asio/execution/receiver_invocation_error.hpp\"\n#include \"asio/execution/relationship.hpp\"\n#include \"asio/execution/schedule.hpp\"\n#include \"asio/execution/scheduler.hpp\"\n#include \"asio/execution/sender.hpp\"\n#include \"asio/execution/set_done.hpp\"\n#include \"asio/execution/set_error.hpp\"\n#include \"asio/execution/set_value.hpp\"\n#include \"asio/execution/start.hpp\"\n#include \"asio/execution_context.hpp\"\n#include \"asio/executor.hpp\"\n#include \"asio/executor_work_guard.hpp\"\n#include \"asio/file_base.hpp\"\n#include \"asio/generic/basic_endpoint.hpp\"\n#include \"asio/generic/datagram_protocol.hpp\"\n#include \"asio/generic/raw_protocol.hpp\"\n#include \"asio/generic/seq_packet_protocol.hpp\"\n#include \"asio/generic/stream_protocol.hpp\"\n#include \"asio/handler_alloc_hook.hpp\"\n#include \"asio/handler_continuation_hook.hpp\"\n#include \"asio/handler_invoke_hook.hpp\"\n#include \"asio/high_resolution_timer.hpp\"\n#include \"asio/io_context.hpp\"\n#include \"asio/io_context_strand.hpp\"\n#include \"asio/io_service.hpp\"\n#include \"asio/io_service_strand.hpp\"\n#include \"asio/ip/address.hpp\"\n#include \"asio/ip/address_v4.hpp\"\n#include \"asio/ip/address_v4_iterator.hpp\"\n#include \"asio/ip/address_v4_range.hpp\"\n#include \"asio/ip/address_v6.hpp\"\n#include \"asio/ip/address_v6_iterator.hpp\"\n#include \"asio/ip/address_v6_range.hpp\"\n#include \"asio/ip/network_v4.hpp\"\n#include \"asio/ip/network_v6.hpp\"\n#include \"asio/ip/bad_address_cast.hpp\"\n#include \"asio/ip/basic_endpoint.hpp\"\n#include \"asio/ip/basic_resolver.hpp\"\n#include \"asio/ip/basic_resolver_entry.hpp\"\n#include \"asio/ip/basic_resolver_iterator.hpp\"\n#include \"asio/ip/basic_resolver_query.hpp\"\n#include \"asio/ip/host_name.hpp\"\n#include \"asio/ip/icmp.hpp\"\n#include \"asio/ip/multicast.hpp\"\n#include \"asio/ip/resolver_base.hpp\"\n#include \"asio/ip/resolver_query_base.hpp\"\n#include \"asio/ip/tcp.hpp\"\n#include \"asio/ip/udp.hpp\"\n#include \"asio/ip/unicast.hpp\"\n#include \"asio/ip/v6_only.hpp\"\n#include \"asio/is_applicable_property.hpp\"\n#include \"asio/is_executor.hpp\"\n#include \"asio/is_read_buffered.hpp\"\n#include \"asio/is_write_buffered.hpp\"\n#include \"asio/local/basic_endpoint.hpp\"\n#include \"asio/local/connect_pair.hpp\"\n#include \"asio/local/datagram_protocol.hpp\"\n#include \"asio/local/stream_protocol.hpp\"\n#include \"asio/multiple_exceptions.hpp\"\n#include \"asio/packaged_task.hpp\"\n#include \"asio/placeholders.hpp\"\n#include \"asio/posix/basic_descriptor.hpp\"\n#include \"asio/posix/basic_stream_descriptor.hpp\"\n#include \"asio/posix/descriptor.hpp\"\n#include \"asio/posix/descriptor_base.hpp\"\n#include \"asio/posix/stream_descriptor.hpp\"\n#include \"asio/post.hpp\"\n#include \"asio/prefer.hpp\"\n#include \"asio/query.hpp\"\n#include \"asio/random_access_file.hpp\"\n#include \"asio/read.hpp\"\n#include \"asio/read_at.hpp\"\n#include \"asio/read_until.hpp\"\n#include \"asio/readable_pipe.hpp\"\n#include \"asio/recycling_allocator.hpp\"\n#include \"asio/redirect_error.hpp\"\n#include \"asio/registered_buffer.hpp\"\n#include \"asio/require.hpp\"\n#include \"asio/require_concept.hpp\"\n#include \"asio/serial_port.hpp\"\n#include \"asio/serial_port_base.hpp\"\n#include \"asio/signal_set.hpp\"\n#include \"asio/socket_base.hpp\"\n#include \"asio/static_thread_pool.hpp\"\n#include \"asio/steady_timer.hpp\"\n#include \"asio/strand.hpp\"\n#include \"asio/stream_file.hpp\"\n#include \"asio/streambuf.hpp\"\n#include \"asio/system_context.hpp\"\n#include \"asio/system_error.hpp\"\n#include \"asio/system_executor.hpp\"\n#include \"asio/system_timer.hpp\"\n#include \"asio/this_coro.hpp\"\n#include \"asio/thread.hpp\"\n#include \"asio/thread_pool.hpp\"\n#include \"asio/time_traits.hpp\"\n#include \"asio/use_awaitable.hpp\"\n#include \"asio/use_future.hpp\"\n#include \"asio/uses_executor.hpp\"\n#include \"asio/version.hpp\"\n#include \"asio/wait_traits.hpp\"\n#include \"asio/windows/basic_object_handle.hpp\"\n#include \"asio/windows/basic_overlapped_handle.hpp\"\n#include \"asio/windows/basic_random_access_handle.hpp\"\n#include \"asio/windows/basic_stream_handle.hpp\"\n#include \"asio/windows/object_handle.hpp\"\n#include \"asio/windows/overlapped_handle.hpp\"\n#include \"asio/windows/overlapped_ptr.hpp\"\n#include \"asio/windows/random_access_handle.hpp\"\n#include \"asio/windows/stream_handle.hpp\"\n#include \"asio/writable_pipe.hpp\"\n#include \"asio/write.hpp\"\n#include \"asio/write_at.hpp\"\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/execution/receiver_invocation_error.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_EXECUTION_RECEIVER_INVOCATION_ERROR_HPP\n#define ASIO_EXECUTION_RECEIVER_INVOCATION_ERROR_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include <stdexcept>\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace execution {\n\n\n\nclass receiver_invocation_error\n  : public std::runtime_error\n#if defined(ASIO_HAS_STD_NESTED_EXCEPTION)\n  , public std::nested_exception\n#endif\n{\npublic:\n\n  ASIO_DECL receiver_invocation_error();\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#if defined(ASIO_HEADER_ONLY)\n# include \"asio/execution/impl/receiver_invocation_error.ipp\"\n#endif\n\n#endif\n",
        "gt": [
            "'elaphureLink/thirdparty/asio/include/asio/execution/receiver_invocation_error.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio.hpp'",
            "'elaphureLink/elaphureLinkProxy/SocketClient.hpp'",
            "'elaphureLink/elaphureLinkProxy/proxy.cpp'"
        ]
    },
    {
        "files": [
            "'svaba/src/SGA/Bigraph/Edge.cpp'",
            "'svaba/src/SGA/Bigraph/Vertex.h'",
            "'svaba/src/SGA/Util/QualityVector.h'",
            "'svaba/src/SGA/Util/DNADouble.h'"
        ],
        "content": "'svaba/src/SGA/Bigraph/Edge.cpp'\n:\n\n\n\n\n\n\n\n#include \"Edge.h\"\n#include \"Vertex.h\"\n\n\nEdgeDesc Edge::getTwinDesc() const\n{\n    return EdgeDesc(getStart(), getTwinDir(), getComp());\n}\n\n\nstd::string Edge::getLabel() const\n{\n    const Edge* pTwin = getTwin();\n    const Vertex* pEndpoint = m_pEnd;\n\n\n    SeqCoord unmatched = pTwin->getMatchCoord().complement();\n    std::string seq = unmatched.getSubstring(pEndpoint->getStr());\n\n    if(getComp() == EC_REVERSE)\n        seq = reverseComplement(seq);\n\n    return seq;\n}\n\n\n\nvoid Edge::join(const Edge* pEdge)\n{\n\n    Match m12 = pEdge->getMatch();\n    Match m23 = getMatch();\n    m_matchCoord = m12.inverseTranslate(m23.coord[0]);\n\n    if(pEdge->getComp() == EC_REVERSE)\n        flip();\n\n\n    m_pTwin->extend(pEdge->getTwin());\n}\n\n\nvoid Edge::extend(const Edge* pEdge)\n{\n    if(pEdge->getComp() == EC_REVERSE)\n        flipComp();\n    m_pEnd = pEdge->getEnd();\n}\n\n\n\n\nMatch Edge::getMatch() const\n{\n    const SeqCoord& sc = getMatchCoord();\n    const SeqCoord& tsc = m_pTwin->getMatchCoord();\n    return Match(sc, tsc, getComp() == EC_REVERSE, -1);\n}\n\n\nOverlap Edge::getOverlap() const\n{\n    return Overlap(getStartID(), getEndID(), getMatch());\n}\n\n\nstd::string Edge::getMatchStr() const\n{\n    return m_matchCoord.getSubstring(getStart()->getStr());\n}\n\n\nsize_t Edge::getSeqLen() const\n{\n    SeqCoord unmatched = m_pTwin->getMatchCoord().complement();\n    return unmatched.length();\n}\n\nvoid Edge::offsetMatch(int offset)\n{\n    m_matchCoord.interval.start += offset;\n    m_matchCoord.interval.end += offset;\n}\n\nvoid Edge::extendMatch(int ext_len)\n{\n    m_matchCoord.interval.end += ext_len;\n}\n\n\n\nvoid Edge::extendMatchFullLength()\n{\n    if(m_matchCoord.isLeftExtreme())\n        m_matchCoord.interval.end = m_matchCoord.seqlen - 1;\n    else\n        m_matchCoord.interval.start = 0;\n}\n\nvoid Edge::updateSeqLen(int newLen)\n{\n    m_matchCoord.seqlen = newLen;\n}\n\n\nvoid Edge::validate() const\n{\n    const Edge* pTwin = getTwin();\n    std::string m_v1 = getMatchStr();\n    std::string m_v2 = pTwin->getMatchStr();\n\n    if(getComp() == EC_REVERSE)\n        m_v2 = reverseComplement(m_v2);\n\n    bool error = false;\n    if(m_v1.length() != m_v2.length())\n    {\n        std::cerr << \"Error, matching strings are not the same length\\n\";\n        error = true;\n    }\n\n    if(error)\n    {\n        std::cerr << \"V1M: \" << m_v1 << \"\\n\";\n        std::cerr << \"V2M: \" << m_v2 << \"\\n\";\n        std::cerr << \"V1MC: \" << getMatchCoord() << \"\\n\";\n        std::cerr << \"V2MC: \" << pTwin->getMatchCoord() << \"\\n\";\n        std::cerr << \"V1: \" << getStart()->getSeq() << \"\\n\";\n        std::cerr << \"Validation failed for edge \" << *this << \"\\n\";\n        assert(false);\n    }\n}\n\n\nstd::ostream& operator<<(std::ostream& out, const Edge& obj)\n{\n    out << obj.m_pEnd->getID() << \",\" << obj.getDir() << \",\" << obj.getComp();\n    return out;\n}\n\n\n'svaba/src/SGA/Bigraph/Vertex.h'\n:\n\n\n\n\n\n\n\n#ifndef VERTEX_H\n#define VERTEX_H\n\n\n#include <stdio.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <list>\n#include <ostream>\n#include <iostream>\n#include <iterator>\n#include \"GraphCommon.h\"\n#include \"QualityVector.h\"\n#include \"EncodedString.h\"\n#include \"SimpleAllocator.h\"\n#include \"EdgeDesc.h\"\n#include \"MultiOverlap.h\"\n\n\nclass Edge;\n\n\nstruct EdgeIDComp\n{\n    bool operator()(const Edge* pA, const Edge* pB);\n};\n\n\nstruct EdgeLenComp\n{\n    bool operator()(const Edge* pA, const Edge* pB);\n};\n\n\n\ntypedef std::map<EdgeDesc, Edge*> EdgePtrMap;\ntypedef std::vector<Edge*> EdgePtrVec;\ntypedef std::set<EdgeDesc> EdgeDescSet;\ntypedef std::list<Edge*> EdgePtrList;\ntypedef EdgePtrMap::iterator EdgePtrMapIter;\ntypedef EdgePtrMap::const_iterator EdgePtrMapConstIter;\ntypedef EdgePtrVec::iterator EdgePtrVecIter;\ntypedef EdgePtrVec::const_iterator EdgePtrVecConstIter;\ntypedef EdgePtrList::iterator EdgePtrListIter;\ntypedef EdgePtrList::const_iterator EdgePtrListConstIter;\n\nclass Vertex\n{\n    public:\n\n        Vertex(VertexID id, const std::string& s) : m_id(id),\n                                                    m_seq(s),\n                                                    m_color(GC_WHITE),\n                                                    m_coverage(1),\n\t  m_isContained(false), m_isSuperRepeat(false) {\n\n\n         }\n        ~Vertex();\n\n\n\n\n        void merge(Edge* pEdge);\n\n\n        void sortAdjListByID();\n\n\n        void sortAdjListByLen();\n\n\n        bool markDuplicateEdges(GraphColor dupColor);\n\n\n\n\n\n\n        MultiOverlap getMultiOverlap() const;\n\n\n        void addEdge(Edge* ep);\n        void removeEdge(Edge* pEdge);\n        void removeEdge(const EdgeDesc& ed);\n        void deleteEdge(Edge* pEdge);\n        void deleteEdges();\n\n        int sweepEdges(GraphColor c);\n        bool hasEdge(Edge* pEdge) const;\n        bool hasEdge(const EdgeDesc& ed) const;\n        bool hasEdgeTo(const Vertex* pY) const;\n\n        Edge* getEdge(const EdgeDesc& ed);\n        EdgePtrVec findEdgesTo(VertexID id);\n        EdgePtrVec getEdges(EdgeDir dir) const;\n        EdgePtrVec getEdges() const;\n        EdgePtrVecIter findEdge(const EdgeDesc& ed);\n        EdgePtrVecConstIter findEdge(const EdgeDesc& ed) const;\n        Edge* getLongestOverlapEdge(EdgeDir dir) const;\n\n        size_t countEdges() const;\n        size_t countEdges(EdgeDir dir);\n\n\n\n        int getOverlapLengthDiff(EdgeDir dir) const;\n\n\n        void validate() const;\n\n\n        void setID(VertexID id) { m_id = id; }\n        void setEdgeColors(GraphColor c);\n        void setSeq(const std::string& s) { m_seq = s; }\n        void setColor(GraphColor c) { m_color = c; }\n        void setContained(bool c) { m_isContained = c; }\n        void setSuperRepeat(bool b) { m_isSuperRepeat = b; }\n\n\n        VertexID getID() const { return m_id; }\n        GraphColor getColor() const { return m_color; }\n        const DNAEncodedString& getSeq() const { return m_seq; }\n        std::string getStr() const { return m_seq.toString(); }\n        size_t getSeqLen() const { return m_seq.length(); }\n        size_t getMemSize() const;\n        bool isContained() const { return m_isContained; }\n        bool isSuperRepeat() const { return m_isSuperRepeat; }\n        uint16_t getCoverage() const { return m_coverage; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        void writeEdges(std::ostream& out, int dotFlags) const;\n\n    private:\n\n\n\n\n\n        bool markDuplicateEdges(EdgeDir dir, GraphColor dupColor);\n\n        VertexID m_id;\n\n        EdgePtrVec m_edges;\n        DNAEncodedString m_seq;\n        GraphColor m_color;\n\n\n        uint16_t m_coverage;\n\n        bool m_isContained;\n        bool m_isSuperRepeat;\n};\n\n#endif\n\n'svaba/src/SGA/Util/QualityVector.h'\n:\n\n\n\n\n\n\n\n\n#ifndef QUALITYVECTOR_H\n#define QUALITYVECTOR_H\n\n#include <vector>\n#include \"Alphabet.h\"\n#include \"DNADouble.h\"\n\ntypedef std::vector<DNADouble> APVec;\n\nclass QualityVector\n{\n    public:\n\n\n        QualityVector();\n        QualityVector(const QualityVector& vec, int start, int size);\n\n\n        void add(DNADouble v);\n        void set(size_t idx, DNADouble v);\n        DNADouble get(size_t idx) const;\n        size_t size() const;\n        bool empty() const;\n\n\n        void reverseComplement();\n\n    private:\n        APVec m_data;\n\n};\n\n#endif\n\n'svaba/src/SGA/Util/DNADouble.h'\n:\n\n\n\n\n\n\n\n\n#ifndef ALPHADOUBLE_H\n#define ALPHADOUBLE_H\n\n#include \"Alphabet.h\"\n\nclass DNADouble\n{\n    public:\n\n\n        inline DNADouble()\n        {\n            memset(m_vals, 0, DNA_ALPHABET::size * sizeof(double));\n        }\n\n\n        inline size_t getAlphabetSize() const\n        {\n            return DNA_ALPHABET::size;\n        }\n\n\n        inline void set(char b, double lp)\n        {\n            m_vals[DNA_ALPHABET::getBaseRank(b)] = lp;\n        }\n\n\n        inline double get(char b) const\n        {\n            return m_vals[DNA_ALPHABET::getBaseRank(b)];\n        }\n\n\n        inline char getMaxBase() const\n        {\n            char base;\n            double val;\n            getMax(base, val);\n            return base;\n        }\n\n\n        inline double getMaxVal() const\n        {\n            char base;\n            double val;\n            getMax(base, val);\n            return val;\n        }\n\n\n        inline void getMax(char& base, double& val) const\n        {\n            double max = -std::numeric_limits<double>::max();\n            int maxIdx = 0;\n            for(int i = 0; i < DNA_ALPHABET::size; ++i)\n            {\n                if(m_vals[i] > max)\n                {\n                    max = m_vals[i];\n                    maxIdx = i;\n                }\n            }\n            base = DNA_ALPHABET::getBase(maxIdx);\n            val = max;\n        }\n\n\n\n        inline double getByIdx(const int i) const\n        {\n            return m_vals[i];\n        }\n\n\n        static char getBase(size_t i)\n        {\n            assert(i < DNA_ALPHABET::size);\n            return DNA_ALPHABET::getBase(i);\n        }\n\n\n        inline void complement()\n        {\n            double tmp;\n\n\n            tmp = m_vals[3];\n            m_vals[3] = m_vals[0];\n            m_vals[0] = tmp;\n\n\n            tmp = m_vals[2];\n            m_vals[2] = m_vals[1];\n            m_vals[1] = tmp;\n        }\n\n\n\n        double marginalize(double prior) const\n        {\n            double direct = 0.0f;\n            for(int i = 0; i < DNA_ALPHABET::size; ++i)\n            {\n                direct += exp(m_vals[i]);\n            }\n            double ld = log(direct) + log(prior);\n\n            return ld;\n        }\n\n\n        inline void add(double val)\n        {\n            m_vals[0] += val;\n            m_vals[1] += val;\n            m_vals[2] += val;\n            m_vals[3] += val;\n        }\n\n\n        inline void subtract(double val)\n        {\n            m_vals[0] -= val;\n            m_vals[1] -= val;\n            m_vals[2] -= val;\n            m_vals[3] -= val;\n        }\n\n        inline DNADouble& operator+=(const DNADouble& other)\n        {\n            assert(DNA_ALPHABET::size == 4);\n\n            m_vals[0] += other.m_vals[0];\n            m_vals[1] += other.m_vals[1];\n            m_vals[2] += other.m_vals[2];\n            m_vals[3] += other.m_vals[3];\n            return *this;\n        }\n\n        inline DNADouble& operator-=(const DNADouble& other)\n        {\n            assert(DNA_ALPHABET::size == 4);\n\n            m_vals[0] -= other.m_vals[0];\n            m_vals[1] -= other.m_vals[1];\n            m_vals[2] -= other.m_vals[2];\n            m_vals[3] -= other.m_vals[3];\n            return *this;\n        }\n\n\n\n        void printVerbose() const\n        {\n            std::cout << \"AP \";\n            for(int i = 0; i < DNA_ALPHABET::size; ++i)\n            {\n                char b = DNA_ALPHABET::getBase(i);\n                std::cout << b << \": \" << m_vals[i] << \" \";\n            }\n            std::cout << \"\\n\";\n        }\n\n    private:\n        double m_vals[DNA_ALPHABET::size];\n};\n\n#endif\n",
        "gt": [
            "'svaba/src/SGA/Util/DNADouble.h'",
            "'svaba/src/SGA/Util/QualityVector.h'",
            "'svaba/src/SGA/Bigraph/Vertex.h'",
            "'svaba/src/SGA/Bigraph/Edge.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecurityHeader.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/Certificate.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CertificateChain.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CertificateExtension.h'",
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecurityHeader.cpp'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecurityHeader.h'\n:\n\n#ifndef __OpcUaStackCore_SecurityHeader_h__\n#define __OpcUaStackCore_SecurityHeader_h__\n\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaByteString.h\"\n#include \"OpcUaStackCore/Certificate/CertificateChain.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT SecurityHeader\n\t: public  Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<SecurityHeader> SPtr;\n\n\t\tSecurityHeader(void);\n\t\tvirtual ~SecurityHeader(void);\n\n\t\tvoid securityPolicyUri(OpcUaByte **buf, OpcUaInt32* bufLen) const;\n\t\tvoid securityPolicyUri(OpcUaByte *buf, OpcUaInt32 bufLen);\n\t\tOpcUaByteString& securityPolicyUri(void);\n\t\tvoid senderCertificate(OpcUaByte **buf, OpcUaInt32* bufLen) const;\n\t\tvoid senderCertificate(OpcUaByte *buf, OpcUaInt32 bufLen);\n\t\tOpcUaByteString& senderCertificate(void);\n\t\tvoid receiverCertificateThumbprint(OpcUaByte *buf, OpcUaInt32 bufLen);\n\t\tvoid receiverCertificateThumbprint(OpcUaByte **buf, OpcUaInt32* bufLen) const;\n\t\tvoid receiverCertificateThumbprint(OpcUaByteString& receiverCertificateThumbprint);\n\t\tOpcUaByteString& receiverCertificateThumbprint(void);\n\t\tCertificateChain& certificateChain(void);\n\n\t\tbool isEncryptionEnabled(void);\n\t\tbool isSignatureEnabled(void);\n\n\t\tbool opcUaBinaryEncode(std::ostream& os) const;\n\t\tbool opcUaBinaryDecode(std::istream& is);\n\n\t  private:\n\t\tOpcUaByteString securityPolicyUri_;\n\t\tOpcUaByteString senderCertificate_;\n\t\tOpcUaByteString receiverCertificateThumbprint_;\n\t\tCertificateChain certificateChain_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/Certificate/Certificate.h'\n:\n\n#ifndef __OpcUaStackCore_Certificate_h__\n#define __OpcUaStackCore_Certificate_h__\n\n#include <boost/shared_ptr.hpp>\n\n#include <vector>\n#include <string>\n#include <list>\n\n#include <openssl/x509.h>\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/MemoryBuffer.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaByteString.h\"\n#include \"OpcUaStackCore/Certificate/CertificateInfo.h\"\n#include \"OpcUaStackCore/Certificate/OpenSSLError.h\"\n#include \"OpcUaStackCore/Certificate/CertificateEnums.h\"\n#include \"OpcUaStackCore/Certificate/CertificateExtension.h\"\n#include \"OpcUaStackCore/Certificate/Identity.h\"\n#include \"OpcUaStackCore/Certificate/RSAKey.h\"\n#include \"OpcUaStackCore/Certificate/CertificateInfo.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT Certificate\n\t: public OpenSSLError\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<Certificate> SPtr;\n\t\ttypedef std::list<Certificate::SPtr> List;\n\t\ttypedef std::vector<Certificate::SPtr> Vec;\n\n\t\tCertificate(void);\n\t\tCertificate(\n\t\t\tCertificateInfo& info,\n\t\t\tIdentity& subject,\n\t\t    RSAKey& rsaKey,\n\t\t    bool useCACert = false,\n\t\t    SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm_Sha1\n\t\t);\n\t\tCertificate(\n\t\t\tCertificateInfo& info,\n\t\t\tIdentity& subject,\n\t\t\tPublicKey& subjectPublicKey,\n\t\t\tCertificate&  issuerCertificate,\n\t\t\tPrivateKey& issuerPrivateKey,\n\t\t    bool useCACert = false,\n\t\t    SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm_Sha1\n\t\t);\n\t\t~Certificate(void);\n\n\t\tbool getSubject(Identity& subject);\n\t\tbool getIssuer(Identity& issuer);\n\t\tbool getInfo(CertificateInfo& info);\n\t\tbool getExtension(CertificateExtension& certificateExtension);\n\n\t\tOpcUaByteString thumbPrint(void);\n\t\tbool thumbPrint(char* buf, uint32_t* bufLen);\n\t\tbool toDERFile(const std::string& fileName);\n\t\tbool fromDERFile(const std::string& fileName);\n\t\tbool toDERBufLen(uint32_t* bufLen);\n\t\tbool toDERBuf(char* buf, uint32_t* bufLen);\n\t\tbool toDERBuf(OpcUaByteString& derBuf);\n\t\tbool toDERBuf(MemoryBuffer& derBuf);\n\t\tbool fromDERBuf(char* buf, uint32_t bufLen);\n\t\tbool fromDERBuf(MemoryBuffer& derBuf);\n\n\t\tuint32_t getDERBufSize(void);\n\t\tPublicKey publicKey(void);\n\n\t\tbool isSelfSigned(void) const;\n\n\t  private:\n\t\tX509 *cert_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/Certificate/CertificateChain.h'\n:\n\n#ifndef __OpcUaStackCore_CertificateChain_h__\n#define __OpcUaStackCore_CertificateChain_h__\n\n#include <boost/shared_ptr.hpp>\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaByteString.h\"\n#include \"OpcUaStackCore/Certificate/Certificate.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT CertificateChain\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<CertificateChain> SPtr;\n\n\t\tCertificateChain(void);\n\t\t~CertificateChain(void);\n\n\t\tvoid clear(void);\n\t\tCertificate::Vec& certificateVec(void);\n\t\tvoid addCertificate(Certificate::SPtr& certificate);\n\t\tCertificate::SPtr getCertificate(uint32_t idx = 0);\n\n\t\tuint32_t size(void);\n\t\tbool fromByteString(OpcUaByteString& byteString);\n\t\tbool toByteString(OpcUaByteString& byteString);\n\n\t  private:\n\t\tCertificate::Vec certificateVec_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/Certificate/CertificateExtension.h'\n:\n\n#ifndef __OpcUaStackCore_CertificateExtension_h__\n#define __OpcUaStackCore_CertificateExtension_h__\n\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Certificate/OpenSSLError.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT CertificateExtension\n\t: public OpenSSLError\n\t{\n\t  public:\n\t\tCertificateExtension(bool useCACert = false);\n\t\t~CertificateExtension(void);\n\n\t\tvoid clear(void);\n\t\tvoid basicConstraints(const std::string& basicConstraints);\n\t\tstd::string& basicConstraints(void);\n\t\tvoid nsComment(const std::string& nsComment);\n\t\tstd::string& nsComment(void);\n\t\tvoid subjectKeyIdentifier(const std::string& subjectKeyIdentifier);\n\t\tstd::string& subjectKeyIdentifier(void);\n\t\tvoid authorityKeyIdentifier(const std::string& authorityKeyIdentifier);\n\t\tstd::string& authorityKeyIdentifier(void);\n\t\tvoid keyUsage(const std::string& keyUsage);\n\t\tstd::string& keyUsage(void);\n\t\tvoid extendedKeyUsage(const std::string& extendedKeyUsage);\n\t\tstd::string& extendedKeyUsage(void);\n\t\tvoid subjectAltName(const std::string& subjectAltName);\n\t\tstd::string& subjectAltName(void);\n\n\t\tbool encodeX509(X509 *cert, X509V3_CTX& ctx);\n\t\tbool decodeX509(X509 *cert);\n\n\t  private:\n\t\tbool encodeX509Extension(X509 *cert, X509V3_CTX& ctx, const std::string& key, const std::string& value);\n\t\tbool decodeX509Extension(X509 *cert, int32_t key, std::string& value);\n\n\t\tbool useCACert_;\n\t\tstd::string basicConstraints_;\n\t\tstd::string nsComment_;\n\t\tstd::string subjectKeyIdentifier_;\n\t\tstd::string authorityKeyIdentifier_;\n\t\tstd::string keyUsage_;\n\t\tstd::string extendedKeyUsage_;\n\t\tstd::string subjectAltName_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecurityHeader.cpp'\n:\n\n#include \"OpcUaStackCore/SecureChannel/SecurityHeader.h\"\n#include \"OpcUaStackCore/SecureChannel/MessageDefaults.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tSecurityHeader::SecurityHeader(void)\n\t: securityPolicyUri_()\n\t, senderCertificate_()\n\t, receiverCertificateThumbprint_()\n\t, certificateChain_()\n\t{\n\t}\n\n\tSecurityHeader::~SecurityHeader(void)\n\t{\n\t}\n\n\tvoid\n\tSecurityHeader::securityPolicyUri(OpcUaByte *buf, OpcUaInt32 bufLen)\n\t{\n\t\tsecurityPolicyUri_.value(buf, bufLen);\n\t}\n\n\tvoid\n\tSecurityHeader::securityPolicyUri(OpcUaByte **buf, OpcUaInt32* bufLen) const\n\t{\n\t\tsecurityPolicyUri_.value(buf, bufLen);\n\t}\n\n\tOpcUaByteString&\n\tSecurityHeader::securityPolicyUri(void)\n\t{\n\t\treturn securityPolicyUri_;\n\t}\n\n\tvoid\n\tSecurityHeader::senderCertificate(OpcUaByte *buf, OpcUaInt32 bufLen)\n\t{\n\t\tsenderCertificate_.value(buf, bufLen);\n\t}\n\n\tvoid\n\tSecurityHeader::senderCertificate(OpcUaByte **buf, OpcUaInt32* bufLen) const\n\t{\n\t\tsenderCertificate_.value(buf, bufLen);\n\t}\n\n\tOpcUaByteString&\n\tSecurityHeader::senderCertificate(void)\n\t{\n\t\treturn senderCertificate_;\n\t}\n\n\tvoid\n\tSecurityHeader::receiverCertificateThumbprint(OpcUaByte *buf, OpcUaInt32 bufLen)\n\t{\n\t\treceiverCertificateThumbprint_.value(buf, bufLen);\n\t}\n\n\tvoid\n\tSecurityHeader::receiverCertificateThumbprint(OpcUaByte **buf, OpcUaInt32* bufLen) const\n\t{\n\t\treceiverCertificateThumbprint_.value(buf, bufLen);\n\t}\n\n\tvoid\n\tSecurityHeader::receiverCertificateThumbprint(OpcUaByteString& receiverCertificateThumbprint)\n\t{\n\t\treceiverCertificateThumbprint_ = receiverCertificateThumbprint;\n\t}\n\n\tOpcUaByteString&\n\tSecurityHeader::receiverCertificateThumbprint(void)\n\t{\n\t\treturn receiverCertificateThumbprint_;\n\t}\n\n\tCertificateChain&\n\tSecurityHeader::certificateChain(void)\n\t{\n\t\treturn certificateChain_;\n\t}\n\n\tbool\n\tSecurityHeader::isEncryptionEnabled(void)\n\t{\n\t\treturn senderCertificate_.exist();\n\t}\n\n\tbool\n\tSecurityHeader::isSignatureEnabled(void)\n\t{\n\t\treturn receiverCertificateThumbprint_.exist();\n\t}\n\n\tbool\n\tSecurityHeader::opcUaBinaryEncode(std::ostream& os) const\n\t{\n\t\tsecurityPolicyUri_.opcUaBinaryEncode(os);\n\t\tsenderCertificate_.opcUaBinaryEncode(os);\n\t\treceiverCertificateThumbprint_.opcUaBinaryEncode(os);\n\t\treturn true;\n\t}\n\n\tbool\n\tSecurityHeader::opcUaBinaryDecode(std::istream& is)\n\t{\n\n\t\tsecurityPolicyUri_.opcUaBinaryDecode(is);\n\t\tsenderCertificate_.opcUaBinaryDecode(is);\n\t\treceiverCertificateThumbprint_.opcUaBinaryDecode(is);\n\n\n\t\tif (senderCertificate_.exist()) {\n\t\t\tif (!certificateChain_.fromByteString(senderCertificate_)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n}\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CertificateExtension.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/Certificate.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CertificateChain.h'",
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecurityHeader.h'",
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecurityHeader.cpp'"
        ]
    },
    {
        "files": [
            "'jarkViewer/jarkViewer/include/libwebp2/src/utils/quantizer.h'",
            "'jarkViewer/jarkViewer/include/libwebp2/src/enc/trellis.h'",
            "'jarkViewer/jarkViewer/include/libwebp2/src/enc/symbols_enc.h'"
        ],
        "content": "'jarkViewer/jarkViewer/include/libwebp2/src/utils/quantizer.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef WP2_ENC_LOSSLESS_QUANTIZER_H_\n#define WP2_ENC_LOSSLESS_QUANTIZER_H_\n\n#include <cstddef>\n#include <cstdint>\n\n#include \"src/utils/ans_enc.h\"\n#include \"src/utils/ans_utils.h\"\n#include \"src/utils/vector.h\"\n#include \"src/wp2/base.h\"\n\nnamespace WP2 {\n\nclass Quantizer {\n public:\n  enum ConfigType { Raw, Huffman };\n\n\n\n\n\n\n\n\n\n\n\n\n  struct ConfigParam {\n\n    ConfigType type;\n    bool is_sparse;\n    uint8_t max_freq_bits;\n\n    uint32_t prefix_code_histo_len;\n    uint32_t prefix_code_prefix_size;\n  };\n  struct HistogramSparse {\n    uint32_t* counts;\n    const uint16_t* mapping;\n    uint32_t nnz;\n  };\n  struct Config {\n\n    void WriteHistogramHeader(uint32_t symbol_range,\n                              OptimizeArrayStorageStat* stats,\n                              uint32_t stats_size, ANSEncBase* enc) const;\n    void WriteHistogramCounts(uint32_t symbol_range, uint32_t max_count,\n                              OptimizeArrayStorageStat* stats,\n                              uint32_t stats_size, ANSEncBase* enc) const;\n\n    ConfigParam param;\n\n\n\n    uint32_t* histogram_to_write;\n    size_t size_to_write;\n    HistogramSparse histo;\n\n    float cost_symbols_only;\n\n    float cost;\n  };\n\n\n  WP2Status Allocate(uint32_t range_max);\n\n\n\n\n\n\n\n\n\n\n\n\n\n  bool Quantize(const uint32_t* histogram, const uint16_t* mapping,\n                size_t size_sparse, uint32_t symbol_range, uint32_t max_count,\n                float cost_max, float cost_offset, int effort);\n\n\n\n  Config* GetBest() { return config_best_; }\n\n  void ResetBest() { config_best_ = nullptr; }\n\n private:\n\n\n\n  void QuantizeImpl(const uint32_t* histogram, const uint16_t* mapping,\n                    size_t size_sparse, uint32_t symbol_range,\n                    uint32_t max_count, int effort);\n\n  static constexpr size_t kConfigNbr = 2;\n  Config configs_[kConfigNbr];\n\n  Config* config_best_ = nullptr;\n  uint32_t histogram_size_max_;\n\n  Vector_u32 buffer_;\n\n  VectorNoCtor<OptimizeArrayStorageStat> stats_buffer_;\n};\n}\n\n#endif\n\n'jarkViewer/jarkViewer/include/libwebp2/src/enc/trellis.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef WP2_ENC_TRELLIS_H_\n#define WP2_ENC_TRELLIS_H_\n\n#include <cstdint>\n\n#include \"src/common/lossy/block_size.h\"\n#include \"src/common/lossy/quant_mtx.h\"\n#include \"src/common/lossy/transforms.h\"\n#include \"src/enc/symbols_enc.h\"\n#include \"src/wp2/format_constants.h\"\n\nnamespace WP2 {\n\n\n\n\n\n\n\n\n\nvoid Av1CoeffOptimization(Channel channel, TransformPair tx_type, TrfSize tdim,\n                          const QuantMtx& quant, bool first_is_dc,\n                          const int32_t* residuals, int16_t* coeffs,\n                          uint32_t* num_coeffs, int16_t* dequantized_coeffs,\n                          SymbolCounter* counter, float* rate_cost);\n\n\n\n\nvoid DropoutCoeffs(TrfSize tdim, int quality_factor, int16_t* coeffs,\n                   uint32_t* num_coeffs, int16_t* dequantized_coeffs);\n\n\nvoid DropoutCoeffs(TrfSize tdim, uint32_t dropout_num_before,\n                   uint32_t dropout_num_after, int16_t coeffs[],\n                   uint32_t* num_coeffs, int16_t dequantized_coeffs[]);\n\n}\n\n#endif\n\n'jarkViewer/jarkViewer/include/libwebp2/src/enc/symbols_enc.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef WP2_ENC_SYMBOLS_ENC_H_\n#define WP2_ENC_SYMBOLS_ENC_H_\n\n#include <array>\n#include <cstdint>\n#include <initializer_list>\n#include <limits>\n\n#include \"src/common/lossy/residuals.h\"\n#include \"src/common/symbols.h\"\n#include \"src/utils/ans.h\"\n#include \"src/utils/ans_enc.h\"\n#include \"src/utils/ans_utils.h\"\n#include \"src/utils/quantizer.h\"\n#include \"src/utils/utils.h\"\n#include \"src/utils/vector.h\"\n#include \"src/wp2/base.h\"\n\nnamespace WP2 {\n\n\nclass SymbolManager {\n public:\n  virtual ~SymbolManager() = default;\n\n\n\n  int32_t Process(uint32_t sym, uint32_t cluster, int32_t value, WP2_OPT_LABEL,\n                  ANSEncBase* enc) {\n    return ProcessInternal(sym, cluster, value, false,\n                           0, label, enc, nullptr);\n  }\n\n  int32_t Process(uint32_t sym, int32_t value, WP2_OPT_LABEL, ANSEncBase* enc) {\n    return Process(sym, 0, value, label, enc);\n  }\n\n\n\n\n\n\n  int32_t Process(uint32_t sym, uint32_t cluster, int32_t value,\n                  uint32_t max_value, WP2_OPT_LABEL, ANSEncBase* enc) {\n    return ProcessInternal(sym, cluster, value, true,\n                           max_value, label, enc, nullptr);\n  }\n\n\n\n  void ProcessWithCost(uint32_t sym, uint32_t cluster, int32_t value,\n                       WP2_OPT_LABEL, ANSEncBase* enc, float* cost) {\n    ProcessInternal(sym, cluster, value, false,\n                    0, label, enc, cost);\n  }\n  void ProcessWithCost(uint32_t sym, uint32_t cluster, int32_t value,\n                       uint32_t max_value, WP2_OPT_LABEL, ANSEncBase* enc,\n                       float* cost) {\n    ProcessInternal(sym, cluster, value, true, max_value,\n                    label, enc, cost);\n  }\n\n  virtual const SymbolsInfo& symbols_info() const = 0;\n\n protected:\n  virtual int32_t ProcessInternal(uint32_t sym, uint32_t cluster, int32_t value,\n                                  bool use_max_value, uint32_t max_value,\n                                  WP2_OPT_LABEL, ANSEncBase* enc,\n                                  float* cost) = 0;\n};\n\n\n\n\nclass SymbolRecorder : public SymbolManager {\n public:\n  const SymbolsInfo& symbols_info() const override { return symbols_info_; }\n\n\n\n\n\n  WP2Status Allocate(const SymbolsInfo& symbols_info, uint32_t num_records);\n  WP2Status CopyFrom(const SymbolRecorder& other);\n  void DeepClear();\n\n  void ResetCounts();\n\n\n  WP2Status MakeBackup();\n\n\n  WP2Status ResetRecord(bool reset_backup);\n\n  const ANSDictionary& GetRecordedDict(uint32_t sym, uint32_t cluster) const;\n  const Vector_u8& GetRecordedValues(uint32_t sym, uint32_t cluster) const;\n  const ANSBinSymbol& GetABit(uint32_t sym, uint32_t cluster) const;\n  const ANSAdaptiveSymbol& GetASymbol(uint32_t sym, uint32_t cluster) const;\n\n\n  const ANSAdaptiveSymbol& GetASymbolWithSpeed(uint32_t sym,\n                                               uint32_t cluster) const;\n\n\n\n  const ANSDictionary& GetDictPreviousPass(uint32_t sym,\n                                           uint32_t cluster) const;\n\n protected:\n  int32_t ProcessInternal(uint32_t sym, uint32_t cluster, int32_t value,\n                          bool use_max_value, uint32_t max_value, WP2_OPT_LABEL,\n                          ANSEncBase* enc, float*) override;\n\n private:\n  ANSDictionary* GetDict(uint32_t sym, uint32_t cluster);\n  ANSBinSymbol* GetABit(uint32_t sym, uint32_t cluster);\n  ANSAdaptiveSymbol* GetASymbol(uint32_t sym, uint32_t cluster);\n\n  SymbolsInfo symbols_info_;\n\n\n\n  std::array<uint32_t, kSymbolNumMax> index_;\n\n  std::array<uint32_t, kSymbolNumMax> values_index_;\n\n  ANSDictionaries dicts_;\n  ANSDictionaries dicts_previous_pass_;\n\n  ANSAdaptiveBits a_bits_;\n\n  ANSAdaptiveSymbols a_symbols_;\n\n  Vector<Vector_u8> values_;\n};\n\n\n\n\n\n\nclass SymbolCounter : public SymbolManager, public WP2Allocable {\n public:\n  static constexpr uint32_t kMaxLossyClusters =\n      kResidualClusters * ResidualIO::kNumSectors;\n\n  explicit SymbolCounter(const SymbolRecorder* recorder)\n      : recorder_(recorder), symbols_info_(recorder_->symbols_info()) {}\n\n  const SymbolsInfo& symbols_info() const override { return symbols_info_; }\n\n\n\n\n  virtual WP2Status Allocate(std::initializer_list<uint32_t> syms);\n  virtual void Clear();\n\n protected:\n  int32_t ProcessInternal(uint32_t sym, uint32_t cluster, int32_t value_in,\n                          bool use_max_value, uint32_t max_value, WP2_OPT_LABEL,\n                          ANSEncBase* enc, float*) override;\n\n  const SymbolRecorder* const recorder_;\n  const SymbolsInfo& symbols_info_;\n  static constexpr uint32_t kInvalidIndex =\n      std::numeric_limits<uint32_t>::max();\n};\n\n\n\nclass UpdatingSymbolCounter : public SymbolCounter {\n public:\n  explicit UpdatingSymbolCounter(const SymbolRecorder* recorder)\n      : SymbolCounter(recorder) {}\n\n  WP2Status CopyFrom(const UpdatingSymbolCounter& other);\n\n  WP2Status Allocate(std::initializer_list<uint32_t> syms) override;\n  void Clear() override;\n\n protected:\n  int32_t ProcessInternal(uint32_t sym, uint32_t cluster, int32_t value_in,\n                          bool use_max_value, uint32_t max_value, WP2_OPT_LABEL,\n                          ANSEncBase* enc, float*) override;\n\n private:\n  ANSBinSymbol* GetABit(uint32_t sym, uint32_t cluster);\n  ANSAdaptiveSymbol* GetASymbol(uint32_t sym, uint32_t cluster);\n\n\n\n  std::array<uint32_t, kSymbolNumMax> indices_;\n\n\n\n\n\n  uint32_t num_a_bits_;\n  std::array<bool, 3094> a_bit_initialized_;\n  ANSAdaptiveBits a_bits_;\n\n  uint32_t num_a_symbols_;\n  std::array<bool, 892> a_symbol_initialized_;\n  ANSAdaptiveSymbols a_symbols_;\n};\n\n\n\n\n\n\n\n\nstruct SymbolWriterStatExtra {\n  const ANSDictionary* dict;\n  uint32_t mapping_size;\n};\nclass SymbolWriter : public SymbolManager,\n                     public SymbolIO<SymbolWriterStatExtra>,\n                     public WP2Allocable {\n public:\n\n  WP2Status Init(const SymbolsInfo& symbols_info, int effort) {\n    WP2_CHECK_STATUS(SymbolIO<SymbolWriterStatExtra>::Init(symbols_info));\n    effort_ = effort;\n    return WP2_STATUS_OK;\n  }\n\n  const SymbolsInfo& symbols_info() const override { return symbols_info_; }\n\n\n  WP2Status Allocate() override;\n\n\n  WP2Status CopyFrom(const SymbolWriter& other,\n                     const ANSDictionaries& original_dicts,\n                     const ANSDictionaries& copied_dicts);\n\n\n\n  void AddTrivial(uint32_t sym, uint32_t cluster, bool is_symmetric,\n                  int32_t value);\n\n\n\n\n\n\n\n\n\n\n  WP2Status WriteHeader(uint32_t sym, uint32_t cluster, uint32_t max_nnz,\n                        const uint32_t* counts, WP2_OPT_LABEL, ANSEncBase* enc,\n                        ANSDictionaries* dicts, float* storage_cost = nullptr);\n\n  WP2Status WriteHeader(uint32_t sym, uint32_t cluster, uint32_t max_nnz,\n                        const SymbolRecorder& syntax_recorder, WP2_OPT_LABEL,\n                        ANSEncBase* enc, ANSDictionaries* dicts,\n                        float* storage_cost = nullptr);\n\n  WP2Status WriteHeader(uint32_t sym, uint32_t max_nnz,\n                        const SymbolRecorder& syntax_recorder, WP2_OPT_LABEL,\n                        ANSEncBase* enc, ANSDictionaries* dicts);\n\n\n\n  void GetPotentialUsage(uint32_t sym, uint32_t cluster, bool is_maybe_used[],\n                         uint32_t size) const override;\n\n protected:\n\n\n\n\n\n  void AddRange(uint32_t sym, uint32_t cluster, bool is_symmetric,\n                const uint16_t* mapping, uint32_t size, uint16_t max_range);\n\n\n\n  WP2Status AddDict(uint32_t sym, uint32_t cluster, bool is_symmetric,\n                    const uint32_t* counts, const uint32_t* quantized_counts,\n                    const uint16_t* mapping, uint32_t size,\n                    ANSDictionaries* dicts);\n\n\n\n\n  WP2Status AddPrefixCode(uint32_t sym, uint32_t cluster, bool is_symmetric,\n                          const uint32_t* counts,\n                          const uint32_t* quantized_counts,\n                          const uint16_t* mapping, uint32_t size,\n                          uint32_t prefix_size, ANSDictionaries* dicts);\n\n\n  static void SetMapping(Stat* stat, const uint16_t mapping[], uint32_t size);\n\n private:\n\n\n\n\n  int32_t ProcessInternal(uint32_t sym, uint32_t cluster, int32_t value_in,\n                          bool use_max_value, uint32_t max_value, WP2_OPT_LABEL,\n                          ANSEncBase* enc, float* cost) override;\n\n\n  void WriteHistogram(const Quantizer::Config& config, uint32_t symbol_range,\n                      uint32_t max_count, ANSEncBase* enc);\n\n\n  uint32_t FillCachedPrefixCodeHistogram(uint32_t range, uint32_t size,\n                                         uint32_t prefix_size);\n\n\n\n  bool ComputeCachedPrefixCodeHistogramCost(uint32_t range, uint32_t max_nnz,\n                                            uint32_t size, uint32_t prefix_size,\n                                            float cost_max);\n\n  uint32_t ConvertCountsToCachedHistogram(const uint32_t counts[], int min,\n                                          int max, bool is_symmetric,\n                                          uint32_t counts_total[]);\n\n\n\n\n  static uint32_t FindLargestMappingIndex(const Stat& stat, uint32_t max_index);\n\n private:\n\n  Vector_u32 histogram_;\n\n  Vector_u16 mapping_;\n  Vector_u32 histogram_prefix_code_;\n  Vector_u16 mapping_prefix_code_;\n\n  Quantizer quantizer_;\n  VectorNoCtor<OptimizeArrayStorageStat> stats_buffer_;\n  int effort_;\n};\n\n}\n\n#endif\n",
        "gt": [
            "'jarkViewer/jarkViewer/include/libwebp2/src/utils/quantizer.h'",
            "'jarkViewer/jarkViewer/include/libwebp2/src/enc/symbols_enc.h'",
            "'jarkViewer/jarkViewer/include/libwebp2/src/enc/trellis.h'"
        ]
    },
    {
        "files": [
            "'tiny_csg/3rdp/glm/glm/glm.hpp'",
            "'tiny_csg/3rdp/glm/glm/matrix.hpp'",
            "'tiny_csg/3rdp/glm/glm/mat3x3.hpp'",
            "'tiny_csg/demo.cpp'"
        ],
        "content": "'tiny_csg/3rdp/glm/glm/glm.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"detail/_fixes.hpp\"\n\n#include \"detail/setup.hpp\"\n\n#pragma once\n\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <limits>\n#include <cassert>\n#include \"fwd.hpp\"\n\n#include \"vec2.hpp\"\n#include \"vec3.hpp\"\n#include \"vec4.hpp\"\n#include \"mat2x2.hpp\"\n#include \"mat2x3.hpp\"\n#include \"mat2x4.hpp\"\n#include \"mat3x2.hpp\"\n#include \"mat3x3.hpp\"\n#include \"mat3x4.hpp\"\n#include \"mat4x2.hpp\"\n#include \"mat4x3.hpp\"\n#include \"mat4x4.hpp\"\n\n#include \"trigonometric.hpp\"\n#include \"exponential.hpp\"\n#include \"common.hpp\"\n#include \"packing.hpp\"\n#include \"geometric.hpp\"\n#include \"matrix.hpp\"\n#include \"vector_relational.hpp\"\n#include \"integer.hpp\"\n\n'tiny_csg/3rdp/glm/glm/matrix.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n\n#include \"detail/qualifier.hpp\"\n#include \"detail/setup.hpp\"\n#include \"vec2.hpp\"\n#include \"vec3.hpp\"\n#include \"vec4.hpp\"\n#include \"mat2x2.hpp\"\n#include \"mat2x3.hpp\"\n#include \"mat2x4.hpp\"\n#include \"mat3x2.hpp\"\n#include \"mat3x3.hpp\"\n#include \"mat3x4.hpp\"\n#include \"mat4x2.hpp\"\n#include \"mat4x3.hpp\"\n#include \"mat4x4.hpp\"\n\nnamespace glm {\nnamespace detail\n{\n\ttemplate<length_t C, length_t R, typename T, qualifier Q>\n\tstruct outerProduct_trait{};\n\n\ttemplate<typename T, qualifier Q>\n\tstruct outerProduct_trait<2, 2, T, Q>\n\t{\n\t\ttypedef mat<2, 2, T, Q> type;\n\t};\n\n\ttemplate<typename T, qualifier Q>\n\tstruct outerProduct_trait<2, 3, T, Q>\n\t{\n\t\ttypedef mat<3, 2, T, Q> type;\n\t};\n\n\ttemplate<typename T, qualifier Q>\n\tstruct outerProduct_trait<2, 4, T, Q>\n\t{\n\t\ttypedef mat<4, 2, T, Q> type;\n\t};\n\n\ttemplate<typename T, qualifier Q>\n\tstruct outerProduct_trait<3, 2, T, Q>\n\t{\n\t\ttypedef mat<2, 3, T, Q> type;\n\t};\n\n\ttemplate<typename T, qualifier Q>\n\tstruct outerProduct_trait<3, 3, T, Q>\n\t{\n\t\ttypedef mat<3, 3, T, Q> type;\n\t};\n\n\ttemplate<typename T, qualifier Q>\n\tstruct outerProduct_trait<3, 4, T, Q>\n\t{\n\t\ttypedef mat<4, 3, T, Q> type;\n\t};\n\n\ttemplate<typename T, qualifier Q>\n\tstruct outerProduct_trait<4, 2, T, Q>\n\t{\n\t\ttypedef mat<2, 4, T, Q> type;\n\t};\n\n\ttemplate<typename T, qualifier Q>\n\tstruct outerProduct_trait<4, 3, T, Q>\n\t{\n\t\ttypedef mat<3, 4, T, Q> type;\n\t};\n\n\ttemplate<typename T, qualifier Q>\n\tstruct outerProduct_trait<4, 4, T, Q>\n\t{\n\t\ttypedef mat<4, 4, T, Q> type;\n\t};\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t C, length_t R, typename T, qualifier Q>\n\tGLM_FUNC_DECL mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);\n\n\n\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t C, length_t R, typename T, qualifier Q>\n\tGLM_FUNC_DECL typename detail::outerProduct_trait<C, R, T, Q>::type outerProduct(vec<C, T, Q> const& c, vec<R, T, Q> const& r);\n\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t C, length_t R, typename T, qualifier Q>\n\tGLM_FUNC_DECL typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& x);\n\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t C, length_t R, typename T, qualifier Q>\n\tGLM_FUNC_DECL T determinant(mat<C, R, T, Q> const& m);\n\n\n\n\n\n\n\n\n\n\n\ttemplate<length_t C, length_t R, typename T, qualifier Q>\n\tGLM_FUNC_DECL mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m);\n\n\n}\n\n#include \"detail/func_matrix.inl\"\n\n'tiny_csg/3rdp/glm/glm/mat3x3.hpp'\n:\n\n\n#pragma once\n#include \"./ext/matrix_double3x3.hpp\"\n#include \"./ext/matrix_double3x3_precision.hpp\"\n#include \"./ext/matrix_float3x3.hpp\"\n#include \"./ext/matrix_float3x3_precision.hpp\"\n\n'tiny_csg/demo.cpp'\n:#include \"csg.hpp\"\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n\n#define SDL_MAIN_HANDLED\n#include <SDL2/SDL.h>\n#include <GL/glew.h>\n\n#include \"flythrough_camera.h\"\n#include \"shader_program.hpp\"\n#include \"defer.hpp\"\n#include <randomcolor.h>\n\nusing namespace csg;\nusing namespace glm;\nusing namespace std;\n\nstatic RandomColor random_color;\n\nstatic float signed_distance(const vec3& point, const plane_t& plane) {\n    return dot(plane.normal, point) + plane.offset;\n}\n\nstatic vec3 project_point(const vec3& point,\n                          const plane_t& plane)\n{\n    return point - signed_distance(point, plane) * plane.normal;\n}\n\nstatic plane_t make_plane(\n    const vec3& point,\n    const vec3& normal)\n{\n    return plane_t{ normal, -dot(point, normal) };\n}\n\nstatic plane_t transformed(\n    const plane_t& plane,\n    const mat4& transform)\n{\n    vec3 origin_transformed = vec3(\n        transform * vec4(project_point(vec3(0,0,0), plane), 1.0f)\n    );\n    vec3 normal_transformed = glm::normalize(vec3(\n        transpose(inverse(transform)) * vec4(plane.normal, 0.0f)\n    ));\n    plane_t transformed_plane =  make_plane(origin_transformed, normal_transformed);\n    return transformed_plane;\n}\n\nstatic constexpr volume_t AIR = 0;\nstatic constexpr volume_t SOLID = 1;\n\nenum brush_type_t {\n    AIR_BRUSH,\n    SOLID_BRUSH\n};\n\nstruct cube_brush_userdata_t {\n    void set_brush_type(brush_type_t type){\n        this->type = type;\n        switch (type) {\n            case AIR_BRUSH: brush->set_volume_operation(make_fill_operation(AIR)); break;\n            case SOLID_BRUSH: brush->set_volume_operation(make_fill_operation(SOLID)); break;\n            default: ;\n        }\n    }\n\n    brush_type_t get_brush_type() const {\n        return type;\n    }\n\n    void set_transform(const mat4& transform) {\n        static vector<plane_t> cube_planes = {\n            make_plane(vec3(+1,0,0), vec3(+1,0,0)),\n            make_plane(vec3(-1,0,0), vec3(-1,0,0)),\n            make_plane(vec3(0,+1,0), vec3(0,+1,0)),\n            make_plane(vec3(0,-1,0), vec3(0,-1,0)),\n            make_plane(vec3(0,0,+1), vec3(0,0,+1)),\n            make_plane(vec3(0,0,-1), vec3(0,0,-1))\n        };\n\n        this->transform = transform;\n\n        vector<plane_t> transformed_planes ;\n        for (const plane_t& plane: cube_planes)\n            transformed_planes.push_back( transformed(plane, transform) );\n\n        brush->set_planes(transformed_planes);\n    }\n\n    const mat4& get_transform() const {\n        return transform;\n    }\n\n    void update_display_list() {\n        glNewList(display_list, GL_COMPILE);\n\n        auto faces = brush->get_faces();\n        for (face_t& face: faces) {\n            glBegin(GL_TRIANGLES);\n            for (fragment_t& fragment: face.fragments) {\n                if (fragment.back_volume == fragment.front_volume) {\n                    continue;\n                }\n\n                const vector<vertex_t>& vertices = fragment.vertices;\n\n                vec3 normal = face.plane->normal;\n                bool flip_face = fragment.back_volume == AIR;\n                if (flip_face) {\n                    normal = -normal;\n                }\n\n                glNormal3fv(value_ptr(normal));\n\n                vector<triangle_t> tris = triangulate(fragment);\n                for (triangle_t& tri: tris) {\n                    if (flip_face) {\n                        glVertex3fv(value_ptr(vertices[tri.i].position));\n                        glVertex3fv(value_ptr(vertices[tri.k].position));\n                        glVertex3fv(value_ptr(vertices[tri.j].position));\n                    } else {\n                        glVertex3fv(value_ptr(vertices[tri.i].position));\n                        glVertex3fv(value_ptr(vertices[tri.j].position));\n                        glVertex3fv(value_ptr(vertices[tri.k].position));\n                    }\n                }\n            }\n            glEnd();\n        }\n        glEndList();\n    }\n\n    void render_fill() {\n        glColor3ub(red, green, blue);\n        glCallList(display_list);\n    }\n\n    void render_wire() {\n        glCallList(display_list);\n    }\n\n    cube_brush_userdata_t(brush_t* brush): brush(brush) {\n        display_list = glGenLists(1);\n\n        int argb = random_color.generate();\n        blue = (argb >> 0) & 0xff;\n        green = (argb >> 8) & 0xff;\n        red = (argb >> 16) & 0xff;\n    }\n\nprivate:\n    mat4 transform;\n    char red,green,blue;\n    brush_t *brush;\n    brush_type_t type;\n    GLuint display_list;\n};\n\nvoid render_world(world_t& world, const mat4& viewproj, ShaderProgram* shader) {\n    glEnable(GL_CULL_FACE);\n    glCullFace(GL_BACK);\n    glColor3f(1,1,1);\n\n\n        vector<brush_t*> visible = world.query_frustum(viewproj);\n\n\n\n        shader->use();\n        for (brush_t* brush: visible) {\n            any_cast<cube_brush_userdata_t>(&brush->userdata)->render_fill();\n        }\n        glUseProgram(0);\n\n\n\n        glEnable(GL_POLYGON_OFFSET_LINE);\n        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);\n        glPolygonOffset(-1.0f, -1.0f);\n        glColor3f(1,1,1);\n\n        for (brush_t* brush: visible) {\n            any_cast<cube_brush_userdata_t>(&brush->userdata)->render_wire();\n        }\n\n        glPolygonOffset(0.0f, 0.0f);\n        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);\n        glDisable(GL_POLYGON_OFFSET_LINE);\n\n    glDisable(GL_CULL_FACE);\n}\n\n\n\nconst char *solid_vert = R\"(\n    #version 120\n\n    varying vec3 v_vertex_viewspace;\n    varying vec3 v_color;\n    varying vec3 v_normal_viewspace;\n\n    void main() {\n        gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n        v_vertex_viewspace = (gl_ModelViewMatrix * gl_Vertex).xyz;\n        v_color = gl_Color.rgb;\n        v_normal_viewspace = (gl_ModelViewMatrix * vec4(gl_Normal,0)).xyz;\n    }\n)\";\nconst char *solid_frag = R\"(\n    #version 120\n\n    varying vec3 v_vertex_viewspace;\n    varying vec3 v_color;\n    varying vec3 v_normal_viewspace;\n\n    void main() {\n        vec3 to_camera = -normalize(v_vertex_viewspace);\n        float distance = length(v_vertex_viewspace);\n        float density = 0.1;\n        float lambert = dot(normalize(v_normal_viewspace), to_camera);\n\n        gl_FragColor.rgb = v_color * lambert * (1/exp(distance*density));\n        gl_FragColor.a = 1;\n    }\n)\";\n\n\nint main(int, char**) {\n    SDL_Init(SDL_INIT_EVERYTHING);\n    DEFER( SDL_Quit() );\n\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);\n    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);\n    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 2);\n\n    SDL_Window *window = SDL_CreateWindow(\n        \"tiny_csg demo\",\n        SDL_WINDOWPOS_CENTERED,\n        SDL_WINDOWPOS_CENTERED,\n        800, 600,\n        SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_MAXIMIZED\n    );\n    DEFER( SDL_DestroyWindow(window) );\n\n    SDL_SetRelativeMouseMode(SDL_TRUE);\n\n    SDL_GLContext context = SDL_GL_CreateContext(window);\n    SDL_GL_MakeCurrent(window, context);\n    DEFER( SDL_GL_DeleteContext(context) );\n\n\n    if (SDL_GL_SetSwapInterval(-1) != 0 )\n        SDL_GL_SetSwapInterval(1);\n\n    glewInit();\n\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    glEnable(GL_DEPTH_TEST);\n\n\n    ShaderProgram *solid_shader = 0;\n    {\n        Shader *vert = new Shader(solid_vert, strlen(solid_vert), GL_VERTEX_SHADER);\n        DEFER( delete vert );\n        Shader *frag = new Shader(solid_frag, strlen(solid_frag), GL_FRAGMENT_SHADER);\n        DEFER( delete frag );\n        vert->compile();\n        frag->compile();\n        Shader *shaders[] = {vert, frag};\n        solid_shader = new ShaderProgram(shaders, 2);\n    }\n    DEFER( delete solid_shader );\n\n\n    vec3 eye(0,0,0);\n    vec3 look(0,0,-1);\n    vec3 up(0,1,0);\n    mat4 view(1);\n\n\n    world_t world;\n    world.set_void_volume(SOLID);\n\n    brush_t *room = world.add();\n    {\n        room->userdata = cube_brush_userdata_t(room);\n        cube_brush_userdata_t *userdata = any_cast<cube_brush_userdata_t>(&room->userdata);\n        userdata->set_brush_type(AIR_BRUSH);\n        userdata->set_transform(mat4(1));\n    }\n\n    brush_t *pillar = world.add();\n    {\n        pillar->userdata = cube_brush_userdata_t(pillar);\n        cube_brush_userdata_t *userdata = any_cast<cube_brush_userdata_t>(&pillar->userdata);\n        userdata->set_brush_type(SOLID_BRUSH);\n        userdata->set_transform(\n            scale(mat4(1), vec3(0.25f, 2.0f, 0.25f))\n        );\n    }\n\n    brush_t *tunnel = world.add();\n    {\n        tunnel->userdata = cube_brush_userdata_t(tunnel);\n        cube_brush_userdata_t *userdata = any_cast<cube_brush_userdata_t>(&tunnel->userdata);\n        userdata->set_brush_type(AIR_BRUSH);\n        userdata->set_transform(\n            scale(mat4(1), vec3(2.0f, 0.25f, 0.25f))\n        );\n    }\n\n\n    bool done = false;\n    int ticks_now = SDL_GetTicks();\n    int ticks_last = 0;\n    float delta_time = 0;\n    while (!done) {\n        ticks_last = ticks_now;\n        ticks_now = SDL_GetTicks();\n        delta_time = (ticks_now - ticks_last) / 1000.0f;\n\n        ivec2 mouse_delta(0,0);\n\n        SDL_Event ev;\n        while (SDL_PollEvent(&ev)) {\n            switch (ev.type) {\n                case SDL_QUIT:\n                    done = true;\n                    break;\n                case SDL_MOUSEMOTION:\n                    mouse_delta = ivec2(ev.motion.xrel, ev.motion.yrel);\n                    break;\n            }\n        }\n\n\n\n        static cube_brush_userdata_t*\n            tunnel_userdata = any_cast<cube_brush_userdata_t>(&tunnel->userdata);\n\n        static const mat4\n            tunnel_original_transform = tunnel_userdata->get_transform();\n\n        float seconds_now = ticks_now / 1000.0f;\n\n        tunnel_userdata->set_transform(\n            glm::rotate(mat4(1), radians(seconds_now*45.0f), vec3(0,1,0)) *\n            tunnel_original_transform\n        );\n\n\n\n\n        auto rebuilt = world.rebuild();\n        for (brush_t* b: rebuilt)\n            any_cast<cube_brush_userdata_t>(&b->userdata)->update_display_list();\n\n\n\n\n        auto keys_down = SDL_GetKeyboardState(NULL);\n        flythrough_camera_update(\n            value_ptr(eye), value_ptr(look), value_ptr(up), value_ptr(view),\n            delta_time, 4.0f, 0.4f, 80.0f,\n            mouse_delta.x, mouse_delta.y,\n            keys_down[SDL_SCANCODE_W],\n            keys_down[SDL_SCANCODE_A],\n            keys_down[SDL_SCANCODE_S],\n            keys_down[SDL_SCANCODE_D],\n            keys_down[SDL_SCANCODE_SPACE],\n            keys_down[SDL_SCANCODE_C],\n            0\n        ) ;\n\n        int w, h;\n        SDL_GetWindowSize(window, &w, &h);\n\n        mat4 proj = perspective(\n            radians(60.0f),\n            float(w)/h,\n            0.01f,\n            20.0f\n        );\n\n\n\n\n        glMatrixMode(GL_MODELVIEW);\n        glLoadMatrixf(value_ptr(view));\n        glMatrixMode(GL_PROJECTION);\n        glLoadMatrixf(value_ptr(proj));\n\n        mat4 viewproj = proj * view;\n\n        glViewport(0,0,w,h);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        render_world(world, viewproj, solid_shader);\n\n\n\n        SDL_GL_SwapWindow(window);\n    }\n\n    return 0;\n}\n",
        "gt": [
            "'tiny_csg/3rdp/glm/glm/mat3x3.hpp'",
            "'tiny_csg/3rdp/glm/glm/matrix.hpp'",
            "'tiny_csg/3rdp/glm/glm/glm.hpp'",
            "'tiny_csg/demo.cpp'"
        ]
    },
    {
        "files": [
            "'EmptyHeaded/storage_engine/include/TrieBuilder.hpp'",
            "'EmptyHeaded/storage_engine/include/utils/utils.hpp'",
            "'EmptyHeaded/storage_engine/apps/run.hpp'",
            "'EmptyHeaded/storage_engine/apps/run.cpp'",
            "'EmptyHeaded/storage_engine/include/utils/timer.hpp'"
        ],
        "content": "'EmptyHeaded/storage_engine/include/TrieBuilder.hpp'\n:\n#ifndef _TRIEBUILDER_H_\n#define _TRIEBUILDER_H_\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <functional>\n#include \"utils/MemoryBuffer.hpp\"\n#include \"trie/NextLevel.hpp\"\n#include \"utils/utils.hpp\"\n#include \"trie/set/Set.hpp\"\n#include \"trie/TrieBlock.hpp\"\n\ntemplate<class A, class M> struct Trie;\n\n\ntemplate<class A, class M>\nstruct TrieBuilder{\n  Trie<A,M>* trie;\n  std::vector<MemoryBuffer*> tmp_buffers;\n  std::vector<NextLevel> next;\n  std::vector<const Set<hybrid>*> aggregate_sets;\n  TrieBuilder<A,M>(Trie<A,M>* t_in,const size_t num_attributes);\n  uint32_t cur_level;\n  uint32_t tmp_level;\n\n  size_t build_aggregated_equality_selection_set(\n    const TrieBlock<hybrid,M> *s1);\n\n  size_t build_aggregated_set(\n    const TrieBlock<hybrid,M> *s1);\n\n  size_t build_aggregated_set(\n    const TrieBlock<hybrid,M> *s1,\n    const TrieBlock<hybrid,M> *s2);\n\n  size_t build_aggregated_set(\n    std::vector<const TrieBlock<hybrid,M> *>* isets);\n\n  size_t count_set(\n    const TrieBlock<hybrid,M> *s1);\n\n  size_t count_set(\n    const TrieBlock<hybrid,M> *s1,\n    const TrieBlock<hybrid,M> *s2);\n\n  size_t build_set(\n    const size_t tid,\n    const TrieBlock<hybrid,M> *s1);\n\n  size_t build_set(\n    const size_t tid,\n    const TrieBlock<hybrid,M> *s1,\n    const TrieBlock<hybrid,M> *s2);\n\n  size_t build_set(\n    const size_t tid,\n    std::vector<const TrieBlock<hybrid,M> *>* isets);\n\n  void set_level(\n    const uint32_t index,\n    const uint32_t data);\n\n  void allocate_next(\n    const size_t tid);\n\n  void allocate_annotation(\n    const size_t tid);\n\n  void set_annotation(\n    const A value,\n    const uint32_t index,\n    const uint32_t data);\n\n  template<typename F>\n  inline void foreach_aggregate(F f){\n    const Set<hybrid> *s = aggregate_sets.at(tmp_level);\n    auto buf = tmp_buffers.at(tmp_level);\n    tmp_level++;\n    s->foreach(sizeof(Set<hybrid>),buf,f);\n    tmp_level--;\n  }\n\n  template<typename F>\n  inline void foreach_builder(F f){\n    const int cur_index = next.at(cur_level).index;\n    if(cur_index == -1){\n      return;\n    }\n    const size_t cur_offset = next.at(cur_level).offset;\n\n    auto buf = trie->memoryBuffers->elements.at(cur_index);\n    uint8_t* place = (uint8_t*)(buf->get_address(cur_offset)+sizeof(TrieBlock<hybrid,M>));\n\n    Set<hybrid> *s = (Set<hybrid>*)place;\n\n    cur_level++;\n    s->foreach_index(\n      (cur_offset+sizeof(TrieBlock<hybrid,M>)+sizeof(Set<hybrid>)),\n      buf,\n      f);\n    cur_level--;\n  }\n};\n\ntemplate<class A, class M>\nstruct ParTrieBuilder{\n  Trie<A,M>* trie;\n  std::vector<TrieBuilder<A,M>*> builders;\n  ParTrieBuilder<A,M>(Trie<A,M>* t_in,const size_t num_attributes);\n  const TrieBlock<hybrid,M>* tmp_head;\n\n  size_t build_aggregated_equality_selection_set(\n    const uint32_t data,\n    const TrieBlock<hybrid,M> *s1);\n\n  size_t build_aggregated_set(\n    const TrieBlock<hybrid,M> *s1);\n\n  size_t build_aggregated_set(\n    const TrieBlock<hybrid,M> *s1,\n    const TrieBlock<hybrid,M> *s2);\n\n  size_t build_aggregated_set(\n    std::vector<const TrieBlock<hybrid,M> *>* isets);\n\n  size_t build_set(\n    const TrieBlock<hybrid,M> *s1);\n\n  size_t build_set(\n    const TrieBlock<hybrid,M> *tb1,\n    const TrieBlock<hybrid,M> *tb2);\n\n  size_t build_set(\n    std::vector<const TrieBlock<hybrid,M> *>* isets);\n\n  void allocate_next();\n\n  void allocate_annotation();\n\n  template<typename F>\n  void par_foreach_aggregate(F f){\n    const TrieBlock<hybrid,M>* block = tmp_head;\n    Set<hybrid>* s = (Set<hybrid>*)((uint8_t*)block+sizeof(TrieBlock<hybrid,M>));\n    s->par_foreach(f);\n  }\n\n  template<typename F>\n  void par_foreach_builder(F f){\n    const TrieBlock<hybrid,M>* block = trie->getHead();\n    Set<hybrid>* s = (Set<hybrid>*)((uint8_t*)block+sizeof(TrieBlock<hybrid,M>));\n    s->par_foreach_index(f);\n  }\n};\n\n#endif\n\n'EmptyHeaded/storage_engine/include/utils/utils.hpp'\n:\n\n#ifndef UTILS_H\n#define UTILS_H\n\n#include \"timer.hpp\"\n#include \"io.hpp\"\n#include \"parallel.hpp\"\n#include \"thread_pool.hpp\"\n#include \"debug.hpp\"\n#include \"common.hpp\"\n#include \"ParMMapBuffer.hpp\"\n#include \"ParMemoryBuffer.hpp\"\n\nnamespace utils {\n\n  template<typename F>\n  long binary_search(const uint32_t * const data, size_t first, size_t last, uint32_t search_key, F f){\n   long index;\n   if (first > last){\n    index = -1;\n   } else{\n    size_t mid = (last+first)/2;\n    if (search_key == data[f(mid)])\n      index = mid;\n    else{\n      if (search_key < data[f(mid)]){\n        if(mid == 0)\n          index = -1;\n        else\n          index = binary_search(data,first,mid-1,search_key,f);\n      }\n      else\n        index = binary_search(data,mid+1,last,search_key,f);\n    }\n   }\n   return index;\n  }\n\n}\n\n#endif\n\n'EmptyHeaded/storage_engine/apps/run.hpp'\n:\n#include \"utils/thread_pool.hpp\"\n#include \"Trie.hpp\"\n#include \"TrieBuilder.hpp\"\n#include \"TrieIterator.hpp\"\n#include \"utils/timer.hpp\"\n#include \"Encoding.hpp\"\n\ntypedef std::unordered_map<std::string, void *> mymap;\n\nvoid run(mymap *input_tries) {\n  thread_pool::initializeThreadPool();\n  Trie<float, ParMemoryBuffer> *Trie_InvDegree_0 = NULL;\n  {\n    auto start_time = timer::start_clock();\n    Trie_InvDegree_0 = Trie<float, ParMemoryBuffer>::load(\n        \"/Users/caberger/Documents/Research/code/EmptyHeaded/examples/graph/\"\n        \"data/db_duplicated/relations/InvDegree/InvDegree_0\");\n    timer::stop_clock(\"LOADING Trie InvDegree_0\", start_time);\n  }\n  Trie_InvDegree_0->foreach([&](std::vector<uint32_t>* d, float a){\n    std::cout << d->at(0) << \" \" << a << std::endl;\n  });\n  Trie<void *, ParMemoryBuffer> *Trie_Edge_0_1 = NULL;\n  {\n    auto start_time = timer::start_clock();\n    Trie_Edge_0_1 = Trie<void *, ParMemoryBuffer>::load(\n        \"/Users/caberger/Documents/Research/code/EmptyHeaded/examples/graph/\"\n        \"data/db_duplicated/relations/Edge/Edge_0_1\");\n    timer::stop_clock(\"LOADING Trie Edge_0_1\", start_time);\n  }\n\n  auto e_loading_uint32_t = timer::start_clock();\n  Encoding<uint32_t> *Encoding_uint32_t = Encoding<uint32_t>::from_binary(\n      \"/Users/caberger/Documents/Research/code/EmptyHeaded/examples/graph/data/\"\n      \"db_duplicated/encodings/uint32_t/\");\n  (void)Encoding_uint32_t;\n  timer::stop_clock(\"LOADING ENCODINGS uint32_t\", e_loading_uint32_t);\n  par::reducer<size_t> num_rows_reducer(\n      0, [](size_t a, size_t b) { return a + b; });\n\n\n\n  auto query_timer = timer::start_clock();\n  Trie<long, ParMemoryBuffer> *Trie_N_ = new Trie<long, ParMemoryBuffer>(\n      \"/Users/caberger/Documents/Research/code/EmptyHeaded/examples/graph/data/\"\n      \"db_duplicated/relations/N\",\n      0, true);\n  long N;\n  {\n    auto bag_timer = timer::start_clock();\n    num_rows_reducer.clear();\n    ParTrieBuilder<long, ParMemoryBuffer> Builders(Trie_N_, 1);\n    ParTrieIterator<void *, ParMemoryBuffer> Iterators_Edge_x_y(Trie_Edge_0_1);\n    const size_t count_x =\n        Builders.build_aggregated_set(Iterators_Edge_x_y.head);\n    par::reducer<long> annotation_x(0, [&](long a, long b) { return a + b; });\n    num_rows_reducer.update(0, count_x);\n    const long intermediate_x = (long)1 * count_x;\n    annotation_x.update(0, intermediate_x);\n    Builders.trie->annotation = annotation_x.evaluate(0);\n    N = Builders.trie->annotation;\n    Builders.trie->num_rows = num_rows_reducer.evaluate(0);\n    std::cout << \"NUM ROWS: \" << Builders.trie->num_rows\n              << \" ANNOTATION: \" << Builders.trie->annotation << std::endl;\n    timer::stop_clock(\"BAG N TIME\", bag_timer);\n    Trie_N_->memoryBuffers = Builders.trie->memoryBuffers;\n    Trie_N_->num_rows = 0;\n    Trie_N_->encodings = Builders.trie->encodings;\n  }\n  Trie<float, ParMemoryBuffer> *Trie_PageRank_basecase_0 =\n      new Trie<float, ParMemoryBuffer>(\n          \"/Users/caberger/Documents/Research/code/EmptyHeaded/examples/graph/\"\n          \"data/db_duplicated/relations/PageRank_basecase\",\n          1, true);\n  {\n    auto bag_timer = timer::start_clock();\n    num_rows_reducer.clear();\n    ParTrieBuilder<float, ParMemoryBuffer> Builders(Trie_PageRank_basecase_0,\n                                                    2);\n    Builders.trie->encodings.push_back((void *)Encoding_uint32_t);\n    ParTrieIterator<void *, ParMemoryBuffer> Iterators_Edge_x_z(Trie_Edge_0_1);\n    const size_t count_x = Builders.build_set(Iterators_Edge_x_z.head);\n    Builders.allocate_annotation();\n    Builders.par_foreach_builder([&](const size_t tid, const uint32_t x_i,\n                                     const uint32_t x_d) {\n      TrieBuilder<float, ParMemoryBuffer> *Builder = Builders.builders.at(tid);\n      TrieIterator<void *, ParMemoryBuffer> *Iterator_Edge_x_z =\n          Iterators_Edge_x_z.iterators.at(tid);\n      Iterator_Edge_x_z->get_next_block(0, x_d);\n      const size_t count_z =\n          Builder->build_aggregated_set(Iterator_Edge_x_z->get_block(1));\n      num_rows_reducer.update(tid, 1);\n      float annotation_z = (float)0;\n      annotation_z = (1.0 / N);\n      Builder->set_annotation(annotation_z, x_i, x_d);\n    });\n    Builders.trie->num_rows = num_rows_reducer.evaluate(0);\n    std::cout << \"NUM ROWS: \" << Builders.trie->num_rows\n              << \" ANNOTATION: \" << Builders.trie->annotation << std::endl;\n    timer::stop_clock(\"BAG PageRank_basecase TIME\", bag_timer);\n    Trie_PageRank_basecase_0->memoryBuffers = Builders.trie->memoryBuffers;\n    Trie_PageRank_basecase_0->num_rows = Builders.trie->num_rows;\n    Trie_PageRank_basecase_0->encodings = Builders.trie->encodings;\n  }\n  Trie<float, ParMemoryBuffer> *Trie_PageRank_0 =\n      new Trie<float, ParMemoryBuffer>(\"/Users/caberger/Documents/Research/\"\n                                       \"code/EmptyHeaded/examples/graph/data/\"\n                                       \"db_duplicated/relations/PageRank\",\n                                       1, true);\n  {\n    size_t num_iterations = 0;\n    while (num_iterations < 2) {\n      auto bag_timer = timer::start_clock();\n      num_rows_reducer.clear();\n      ParTrieBuilder<float, ParMemoryBuffer> Builders(Trie_PageRank_0, 2);\n      Builders.trie->encodings.push_back((void *)Encoding_uint32_t);\n      ParTrieIterator<void *, ParMemoryBuffer> Iterators_Edge_x_z(\n          Trie_Edge_0_1);\n      ParTrieIterator<float, ParMemoryBuffer> Iterators_PageRank_basecase_z(\n          Trie_PageRank_basecase_0);\n      ParTrieIterator<float, ParMemoryBuffer> Iterators_InvDegree_z(\n          Trie_InvDegree_0);\n      const size_t count_x = Builders.build_set(Iterators_Edge_x_z.head);\n      Builders.allocate_annotation();\n      Builders.par_foreach_builder([&](const size_t tid, const uint32_t x_i,\n                                       const uint32_t x_d) {\n        TrieBuilder<float, ParMemoryBuffer> *Builder =\n            Builders.builders.at(tid);\n        TrieIterator<void *, ParMemoryBuffer> *Iterator_Edge_x_z =\n            Iterators_Edge_x_z.iterators.at(tid);\n        TrieIterator<float, ParMemoryBuffer> *Iterator_PageRank_basecase_z =\n            Iterators_PageRank_basecase_z.iterators.at(tid);\n        TrieIterator<float, ParMemoryBuffer> *Iterator_InvDegree_z =\n            Iterators_InvDegree_z.iterators.at(tid);\n        Iterator_Edge_x_z->get_next_block(0, x_d);\n        std::vector<const TrieBlock<hybrid, ParMemoryBuffer> *> z_sets;\n        z_sets.push_back(Iterator_PageRank_basecase_z->get_block(0));\n        z_sets.push_back(Iterator_Edge_x_z->get_block(1));\n        z_sets.push_back(Iterator_InvDegree_z->get_block(0));\n        const size_t count_z = Builder->build_aggregated_set(&z_sets);\n        num_rows_reducer.update(tid, 1);\n        float annotation_z = (float)0;\n        Builder->foreach_aggregate([&](const uint32_t z_d) {\n          std::cout << \"a: \" << z_d << \" \" << Iterator_InvDegree_z->get_annotation(0, z_d) << \" \" << Iterator_PageRank_basecase_z->get_annotation(0, z_d) << std::endl;\n          const float intermediate_z =\n              (float)1 * Iterator_PageRank_basecase_z->get_annotation(0, z_d) *\n              1.0 * Iterator_InvDegree_z->get_annotation(0, z_d);\n          annotation_z += intermediate_z;\n        });\n        annotation_z = 0.15 + 0.85 * annotation_z;\n        Builder->set_annotation(annotation_z, x_i, x_d);\n        std::cout << \"SETTING: \" << x_i << \" \" << x_d << \" \" << annotation_z << std::endl;\n      });\n      Builders.trie->num_rows = num_rows_reducer.evaluate(0);\n      std::cout << \"NUM ROWS: \" << Builders.trie->num_rows\n                << \" ANNOTATION: \" << Builders.trie->annotation << std::endl;\n      timer::stop_clock(\"BAG PageRank TIME\", bag_timer);\n      Trie_PageRank_0->memoryBuffers = Builders.trie->memoryBuffers;\n      Trie_PageRank_0->num_rows = Builders.trie->num_rows;\n      Trie_PageRank_0->encodings = Builders.trie->encodings;\n      Trie_PageRank_0 = Builders.trie;\n      num_iterations++;\n    }\n  }\n  input_tries->insert(std::make_pair(\"N_\", Trie_N_));\n\n  input_tries->insert(std::make_pair(\"PageRank_0\", Trie_PageRank_0));\n\n  timer::stop_clock(\"QUERY TIME\", query_timer);\n\n  thread_pool::deleteThreadPool();\n}\n\n'EmptyHeaded/storage_engine/apps/run.cpp'\n:#include \"run.hpp\"\n\nint main()\n{\n  std::unordered_map<std::string, void *>* input = new std::unordered_map<std::string, void *>();\n\n  run(input);\n  return 0;\n}\n\n'EmptyHeaded/storage_engine/include/utils/timer.hpp'\n:#ifndef TIMER_H\n#define TIMER_H\n\n#include <iostream>\n#include <chrono>\n\nnamespace timer{\n  static std::chrono::time_point<std::chrono::system_clock> start_clock (){\n    return std::chrono::system_clock::now();\n  }\n\n  static inline double stop_clock(std::chrono::time_point<std::chrono::system_clock> t_in){\n    std::chrono::duration<double> elapsed_seconds = std::chrono::system_clock::now()-t_in;\n    return elapsed_seconds.count();\n  }\n  static double stop_clock(std::string in,std::chrono::time_point<std::chrono::system_clock> t_in){\n    double t2= stop_clock(t_in);\n    std::cout << \"Time[\"+in+\"]: \" << t2 << \" s\" << std::endl;\n    return t2;\n  }\n}\n#endif\n",
        "gt": [
            "'EmptyHeaded/storage_engine/include/utils/timer.hpp'",
            "'EmptyHeaded/storage_engine/include/utils/utils.hpp'",
            "'EmptyHeaded/storage_engine/include/TrieBuilder.hpp'",
            "'EmptyHeaded/storage_engine/apps/run.hpp'",
            "'EmptyHeaded/storage_engine/apps/run.cpp'"
        ]
    },
    {
        "files": [
            "'knowrob/include/knowrob/semweb/Vocabulary.h'",
            "'knowrob/tests/DataSourceTest.cpp'",
            "'knowrob/include/knowrob/semweb/Class.h'",
            "'knowrob/include/knowrob/semweb/Resource.h'",
            "'knowrob/include/knowrob/DataSource.h'"
        ],
        "content": "'knowrob/include/knowrob/semweb/Vocabulary.h'\n:\n\n#ifndef KNOWROB_VOCABULARY_H\n#define KNOWROB_VOCABULARY_H\n\n#include <memory>\n#include <string>\n#include <string_view>\n#include <map>\n#include \"Property.h\"\n#include \"Class.h\"\n#include \"ImportHierarchy.h\"\n\nnamespace knowrob {\n\n\tclass Vocabulary {\n\tpublic:\n\t\tVocabulary();\n\n\t\t~Vocabulary();\n\n\n\t\tvoid addResourceType(const std::string_view &resource_iri, const std::string_view &type_iri);\n\n\n\t\tbool isDefinedClass(const std::string_view &iri);\n\n\n\t\tsemweb::ClassPtr getDefinedClass(const std::string_view &iri) const;\n\n\n\t\tstd::vector<semweb::ClassPtr> getDefinedClassesWithPrefix(const std::string_view &prefix) const;\n\n\n\t\tstd::vector<std::string_view> getDefinedClassNamesWithPrefix(const std::string_view &prefix) const;\n\n\n\t\tsemweb::ClassPtr defineClass(const std::string_view &iri);\n\n\n\t\tvoid addSubClassOf(const std::string_view &subClass, const std::string_view &superClass,\n\t\t\t\t\t\t   std::optional<std::string_view> graph);\n\n\n\t\tbool isSubClassOf(const std::string_view &subClass, const std::string_view &superClass);\n\n\n\t\tbool isDefinedProperty(const std::string_view &iri);\n\n\n\t\tbool isDefinedReification(const std::string_view &iri);\n\n\n\t\tsemweb::PropertyPtr getDefinedProperty(const std::string_view &iri) const;\n\n\n\t\tsemweb::PropertyPtr getDefinedReification(const std::string_view &iri) const;\n\n\n\t\tstd::vector<semweb::PropertyPtr> getDefinedPropertiesWithPrefix(const std::string_view &prefix) const;\n\n\n\t\tstd::vector<std::string_view> getDefinedPropertyNamesWithPrefix(const std::string_view &prefix) const;\n\n\n\t\tsemweb::PropertyPtr defineProperty(const std::string_view &iri);\n\n\n\t\tsemweb::PropertyPtr defineProperty(const IRIAtomPtr &iri);\n\n\n\t\tvoid addSubPropertyOf(const std::string_view &subProperty, const std::string_view &superProperty,\n\t\t\t\t\t\t\t  std::optional<std::string_view> graph);\n\n\n\t\tvoid setInverseOf(const std::string_view &a, const std::string_view &b);\n\n\n\t\tvoid setPropertyFlag(const std::string_view &iri, semweb::PropertyFlag flag);\n\n\n\t\tvoid setPropertyFlag(const IRIAtomPtr &iri, semweb::PropertyFlag flag);\n\n\n\t\tbool isAnnotationProperty(const std::string_view &iri);\n\n\n\t\tbool isObjectProperty(const std::string_view &iri);\n\n\n\t\tbool isDatatypeProperty(const std::string_view &iri);\n\n\n\t\tstatic bool isTaxonomicProperty(const std::string_view &iri);\n\n\n\t\tvoid setFrequency(const std::string_view &iri, uint64_t frequency);\n\n\n\t\tvoid increaseFrequency(const std::string_view &iri);\n\n\n\t\tuint64_t frequency(const std::string_view &iri) const;\n\n\n\t\tconst std::shared_ptr<ImportHierarchy> &importHierarchy() const { return importHierarchy_; }\n\n\n\t\ttemplate<typename T>\n\t\tstd::shared_ptr<T> define(const std::string_view &iri);\n\n\tprotected:\n\t\tstd::map<std::string_view, semweb::ClassPtr, std::less<>> definedClasses_;\n\t\tstd::map<std::string_view, semweb::PropertyPtr, std::less<>> definedProperties_;\n\t\tstd::map<std::string_view, semweb::PropertyPtr, std::less<>> definedReifications_;\n\t\tstd::map<std::string_view, uint64_t> frequency_;\n\t\tstd::shared_ptr<ImportHierarchy> importHierarchy_;\n\n\t\tsemweb::PropertyPtr defineProperty_(const std::shared_ptr<semweb::Property> &p);\n\t};\n\n\tusing VocabularyPtr = std::shared_ptr<Vocabulary>;\n\n}\n\n#endif\n\n'knowrob/tests/DataSourceTest.cpp'\n:\n\n#include <filesystem>\n#include <gtest/gtest.h>\n#include \"knowrob/integration/python/utils.h\"\n#include \"knowrob/DataSource.h\"\n#include \"knowrob/semweb/OntologyFile.h\"\n\nusing namespace knowrob;\n\n\nnamespace knowrob::testing {\n\tclass DataSourceTest : public ::testing::Test {\n\tprotected:\n\t\tvoid SetUp() override {}\n\n\t};\n}\nusing namespace knowrob::testing;\n\nTEST_F(DataSourceTest, IsGraphVersionString) {\n\tEXPECT_TRUE(DataSource::isVersionString(\"v1.1\"));\n\tEXPECT_TRUE(DataSource::isVersionString(\"v10.1.54\"));\n\tEXPECT_TRUE(DataSource::isVersionString(\"1.1\"));\n\tEXPECT_TRUE(DataSource::isVersionString(\"10.1.54\"));\n\tEXPECT_FALSE(DataSource::isVersionString(\"10\"));\n\tEXPECT_FALSE(DataSource::isVersionString(\"x10.54.3\"));\n\tEXPECT_FALSE(DataSource::isVersionString(\"x.y.z\"));\n}\n\nTEST_F(DataSourceTest, GraphNameFromURI) {\n\tEXPECT_EQ(DataSource::getNameFromURI(\"https:\n\tEXPECT_EQ(DataSource::getNameFromURI(\"file:\n\tEXPECT_EQ(DataSource::getNameFromURI(\"./ont/SOMA.owl\"), \"SOMA\");\n\tEXPECT_EQ(DataSource::getNameFromURI(\"SOMA.owl\"), \"SOMA\");\n\tEXPECT_EQ(DataSource::getNameFromURI(\"SOMA\"), \"SOMA\");\n}\n\nTEST_F(DataSourceTest, GraphVersionFromURI) {\n\tEXPECT_EQ(DataSource::getVersionFromURI(\"https:\n}\n\n'knowrob/include/knowrob/semweb/Class.h'\n:\n\n\n\n#ifndef KNOWROB_SEMWEB_CLASS_H\n#define KNOWROB_SEMWEB_CLASS_H\n\n#include <memory>\n#include <list>\n#include <functional>\n#include \"Resource.h\"\n\nnamespace knowrob::semweb {\n\n\n\tclass Class;\n\n\n\tusing ClassVisitor = std::function<void(Class &)>;\n\n\tusing ClassTupleVisitor = std::function<void(Class &, Class &)>;\n\n\n\tclass Class : public Resource, public std::enable_shared_from_this<Class> {\n\tpublic:\n\n\t\texplicit Class(std::string_view iri);\n\n\n\t\texplicit Class(const IRIAtomPtr &iri);\n\n\n\t\tvoid addDirectParent(const std::shared_ptr<Class> &directParent, std::optional<std::string_view> graph);\n\n\n\t\tvoid removeDirectParent(const std::shared_ptr<Class> &directParent, std::optional<std::string_view> graph);\n\n\n\t\tconst auto &directParents() const { return directParents_; }\n\n\n\t\tbool isDirectSubClassOf(const std::shared_ptr<Class> &directParent);\n\n\n\t\tbool isSubClassOf(const std::shared_ptr<Class> &parent, bool includeSelf = true);\n\n\n\t\tvoid forallParents(const ClassVisitor &visitor, bool includeSelf = true, bool skipDuplicates = true);\n\n\n\t\tvoid forallChildren(const ClassTupleVisitor &visitor, bool skipDuplicates = true);\n\n\n\t\tvoid detach();\n\n\tprotected:\n\t\tstruct ClassComparator {\n\t\t\tbool operator()(const std::shared_ptr<Class> &lhs, const std::shared_ptr<Class> &rhs) const;\n\t\t};\n\n\t\tstd::map<std::shared_ptr<Class>,\n\t\t\t\tstd::set<AtomPtr, AtomComparator>,\n\t\t\t\tClassComparator> directParents_;\n\t\tstd::set<std::shared_ptr<Class>, ClassComparator> directChildren_;\n\t};\n\n\tusing ClassPtr = std::shared_ptr<Class>;\n\n}\n\n#endif\n\n'knowrob/include/knowrob/semweb/Resource.h'\n:\n\n#ifndef KNOWROB_SEMWEB_RESOURCE_H\n#define KNOWROB_SEMWEB_RESOURCE_H\n\n#include <string>\n#include \"knowrob/terms/Atom.h\"\n#include \"knowrob/terms/IRIAtom.h\"\n\nnamespace knowrob::semweb {\n\n\tclass Resource {\n\tpublic:\n\t\texplicit Resource(std::string_view iri);\n\n\t\texplicit Resource(const IRIAtomPtr &iri) : iri_(iri) {}\n\n\n\t\tauto iri() const { return iri_->stringForm(); }\n\n\n\t\tauto iriAtom() const { return iri_; }\n\n\n\t\tstd::string_view name() const;\n\n\n\t\tstd::string_view ns(bool includeDelimiter = false) const;\n\n\n\t\tstatic IRIAtomPtr unique_iri(std::string_view ns, std::string_view name);\n\n\n\t\tstatic IRIAtomPtr unique_iri(std::string_view type_iri);\n\n\n\t\tstatic std::string_view iri_name(std::string_view iri);\n\n\n\t\tstatic std::string_view iri_ns(std::string_view iri, bool includeDelimiter = false);\n\n\n\t\tstatic AtomPtr graph_atom(std::optional<std::string_view> graph);\n\n\tprotected:\n\t\tknowrob::AtomPtr iri_;\n\n\t\tstruct AtomComparator {\n\t\t\tbool operator()(const AtomPtr &lhs, const AtomPtr &rhs) const;\n\t\t};\n\t};\n\n}\n\n#endif\n\n'knowrob/include/knowrob/DataSource.h'\n:\n\n#ifndef KNOWROB_DATA_SOURCES_H_\n#define KNOWROB_DATA_SOURCES_H_\n\n#include <string>\n#include \"knowrob/URI.h\"\n#include \"knowrob/semweb/Vocabulary.h\"\n\nnamespace knowrob {\n\n\tenum class DataSourceType {\n\t\tONTOLOGY,\n\t\tUNSPECIFIED\n\t};\n\n\n\tclass DataSource {\n\tpublic:\n\n\t\tDataSource(URI uri, std::string_view format, DataSourceType dataSourceType);\n\n\n\t\tconst auto &uri() const { return uri_(); }\n\n\n\t\tconst auto &path() const { return uri_.path(); }\n\n\n\t\tconst auto &format() const { return format_; }\n\n\n\t\tDataSourceType dataSourceType() const { return dataSourceType_; }\n\n\n\t\tauto name() const { return getNameFromURI(uri()); }\n\n\n\t\tauto version() const { return getVersionFromURI(uri()); }\n\n\n\t\tstatic std::string getNameFromURI(const std::string &uriString);\n\n\n\t\tstatic std::string getVersionFromURI(const std::string &uriString);\n\n\n\t\tstatic bool isVersionString(const std::string &versionString);\n\n\n\t\tstatic std::shared_ptr<DataSource>\n\t\tcreate(const VocabularyPtr &vocabulary, const boost::property_tree::ptree &config);\n\n\tprotected:\n\t\tDataSourceType dataSourceType_;\n\t\tstd::string format_;\n\t\tURI uri_;\n\t};\n\n\n\tusing DataSourcePtr = std::shared_ptr<DataSource>;\n}\n\n#endif\n",
        "gt": [
            "'knowrob/include/knowrob/semweb/Resource.h'",
            "'knowrob/include/knowrob/semweb/Class.h'",
            "'knowrob/include/knowrob/semweb/Vocabulary.h'",
            "'knowrob/include/knowrob/DataSource.h'",
            "'knowrob/tests/DataSourceTest.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/NodeManagementServiceTransaction.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/AddReferencesRequest.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/NodeManagementService.h'",
            "'OpcUaStack/tst/OpcUaStackServer/Session_t.cpp'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceManager/ServiceManager.h'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackCore/ServiceSet/NodeManagementServiceTransaction.h'\n:\n\n#ifndef __OpcUaStackCore_NodeManagementServiceTransaction_h__\n#define __OpcUaStackCore_NodeManagementServiceTransaction_h__\n\n#include \"OpcUaStackCore/BuildInTypes/OpcUaIdentifier.h\"\n#include \"OpcUaStackCore/ServiceSet/ServiceTransactionTemplate.h\"\n#include \"OpcUaStackCore/ServiceSet/AddNodesRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/AddNodesResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/AddReferencesRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/AddReferencesResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/DeleteNodesRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/DeleteNodesResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/DeleteReferencesRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/DeleteReferencesResponse.h\"\n\nnamespace OpcUaStackCore\n{\n\n\ttypedef ServiceTransactionTemplate<\n\t\tAddNodesRequest,\n\t\tAddNodesResponse,\n\t\tOpcUaId_AddNodesRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_AddNodesResponse_Encoding_DefaultBinary\n\t> ServiceTransactionAddNodes;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tAddReferencesRequest,\n\t\tAddReferencesResponse,\n\t\tOpcUaId_AddReferencesRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_AddReferencesResponse_Encoding_DefaultBinary\n\t> ServiceTransactionAddReferences;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tDeleteNodesRequest,\n\t\tDeleteNodesResponse,\n\t\tOpcUaId_DeleteNodesRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_DeleteNodesResponse_Encoding_DefaultBinary\n\t> ServiceTransactionDeleteNodes;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tDeleteReferencesRequest,\n\t\tDeleteReferencesResponse,\n\t\tOpcUaId_DeleteReferencesRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_DeleteReferencesResponse_Encoding_DefaultBinary\n\t> ServiceTransactionDeleteReferences;\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/AddReferencesRequest.h'\n:\n\n#ifndef __OpcUaStackCore_AddReferencesRequest_h__\n#define __OpcUaStackCore_AddReferencesRequest_h__\n\n#include <stdint.h>\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n#include \"OpcUaStackCore/SecureChannel/RequestHeader.h\"\n#include \"OpcUaStackCore/ServiceSet/AddReferencesItem.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT AddReferencesRequest\n\t: public  Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<AddReferencesRequest> SPtr;\n\n\t\tAddReferencesRequest(void);\n\t\tvirtual ~AddReferencesRequest(void);\n\n\t\tvoid referencesToAdd(const AddReferencesItemArray::SPtr addReferencesItemArray);\n\t\tAddReferencesItemArray::SPtr referencesToAdd() const;\n\n\t\tvoid opcUaBinaryEncode(std::ostream& os) const;\n\t\tvoid opcUaBinaryDecode(std::istream& is);\n\n\t  private:\n\t\tAddReferencesItemArray::SPtr addReferencesItemArray_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackServer/ServiceSet/NodeManagementService.h'\n:\n\n#ifndef __OpcUaStackServer_NodeManagementService_h__\n#define __OpcUaStackServer_NodeManagementService_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/ServiceSet/ServiceTransactionIf.h\"\n#include \"OpcUaStackCore/ServiceSet/NodeManagementServiceTransaction.h\"\n#include \"OpcUaStackServer/ServiceSet/ServiceSetBase.h\"\n#include \"OpcUaStackServer/AddressSpaceModel/BaseNodeClass.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackServer\n{\n\n\tclass DLLEXPORT NodeManagementService\n\t: public ServiceSetBase\n\t, public Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<NodeManagementService> SPtr;\n\n\t\tNodeManagementService(void);\n\t\t~NodeManagementService(void);\n\n\n\t\tvoid receive(Message::SPtr message);\n\n\n\t  private:\n\t\tvoid receiveAddNodesRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveAddReferencesRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveDeleteNodesRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveDeleteReferencesRequest(ServiceTransaction::SPtr serviceTransaction);\n\n\t\tOpcUaStatusCode addNodeAndReference(\n\t\t\tBaseNodeClass::SPtr baseNodeClass,\n\t\t\tAddNodesItem::SPtr& addNodesItem\n\t\t);\n\t\tOpcUaStatusCode addNode(\n\t\t\tuint32_t,\n\t\t\tBaseNodeClass::SPtr baseNodeClass\n\t\t);\n\t\tOpcUaStatusCode addNode(\n\t\t\tuint32_t pos,\n\t\t\tAddNodesItem::SPtr addNodesItem,\n\t\t\tAddNodesResult::SPtr addNodesResult\n\t\t);\n\t\tOpcUaStatusCode addBaseNodeClass(\n\t\t\tuint32_t pos,\n\t\t\tBaseNodeClass::SPtr baseNodeClass,\n\t\t\tAddNodesItem::SPtr addNodesItem,\n\t\t\tAddNodesResult::SPtr addNodesResult\n\t\t);\n\t\tOpcUaStatusCode addNodeObject(\n\t\t\tuint32_t pos,\n\t\t\tAddNodesItem::SPtr addNodesItem,\n\t\t\tAddNodesResult::SPtr addNodesResult\n\t\t);\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/tst/OpcUaStackServer/Session_t.cpp'\n:#include \"unittest.h\"\n#include \"OpcUaStackCore/Base/Config.h\"\n#include \"OpcUaStackCore/Base/IOService.h\"\n#include \"OpcUaStackCore/Base/Utility.h\"\n#include \"OpcUaStackCore/Base/ConfigXml.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaIdentifier.h\"\n#include \"OpcUaStackCore/ServiceSet/AnonymousIdentityToken.h\"\n#include \"OpcUaStackCore/ServiceSet/ExtensibleParameter.h\"\n#include \"OpcUaStackCore/ServiceSet/EventFilter.h\"\n#include \"OpcUaStackCore/ServiceSet/LiteralOperand.h\"\n\n#include \"OpcUaStackServer/NodeSet/NodeSetXmlParser.h\"\n#include \"OpcUaStackServer/InformationModel/InformationModelNodeSet.h\"\n#include \"OpcUaStackServer/ServiceSet/SessionManager.h\"\n#include \"OpcUaStackServer/ServiceSet/DiscoveryService.h\"\n#include \"OpcUaStackServer/ServiceSet/EndpointDescriptionConfig.h\"\n#include \"OpcUaStackServer/ServiceManager/ServiceManager.h\"\n\n#include <boost/asio/error.hpp>\n\n\n#define TEST_HOST\t\t\"127.0.0.1\"\n#define TEST_PORT\t\t\"4842\"\n\n\nusing namespace OpcUaStackCore;\nusing namespace OpcUaStackServer;\n\nBOOST_AUTO_TEST_SUITE(Session_)\n\nBOOST_AUTO_TEST_CASE(Session_)\n{\n\tstd::cout << \"Session_t\" << std::endl;\n}\n\nBOOST_AUTO_TEST_CASE(Session_open)\n{\n\tbool rc;\n\tConfig serverConfig;\n\tIOService ioService;\n\n\n\n\n\n\n\n\n\tConfig endpoint;\n\tConfig userTokenPolicy;\n\n\tendpoint.clear();\n\tendpoint.setValue(\"EndpointUrl\", \"opc.tcp:\n\tendpoint.setValue(\"ApplicationUri\", \"urn:localhost:compyny:Unittest\");\n\tendpoint.setValue(\"ProductUri\", \"urn:company:Unittest\");\n\tendpoint.setValue(\"ApplicationName\", \"company Unittest\");\n\tendpoint.addValue(\"DiscoveryUrl\", \"opc.tcp:\n\tendpoint.setValue(\"SecurityPolicyUri\", \"http:\n\n\tuserTokenPolicy.clear();\n\tuserTokenPolicy.setValue(\"PolicyId\", \"OpcUaStack\");\n\tuserTokenPolicy.setValue(\"TokenType\", \"Anonymous\");\n\tendpoint.setChild(\"UserTokenPolicy\", userTokenPolicy);\n\n\tendpoint.setValue(\"TransportProfileUri\", \"http:\n\tendpoint.setValue(\"SecurityLevel\", \"0\");\n\tserverConfig.addChild(\"TestConfig.EndpointDescription\", endpoint);\n\n\n\tendpoint.clear();\n\tendpoint.setValue(\"EndpointUrl\", \"opc.tcp:\n\tendpoint.setValue(\"ApplicationUri\", \"urn:localhost:compyny:Unittest\");\n\tendpoint.setValue(\"ProductUri\", \"urn:company:Unittest\");\n\tendpoint.setValue(\"ApplicationName\", \"company Unittest\");\n\tendpoint.addValue(\"DiscoveryUrl\", \"opc.tcp:\n\tendpoint.setValue(\"SecurityPolicyUri\", \"http:\n\n\tuserTokenPolicy.clear();\n\tuserTokenPolicy.setValue(\"PolicyId\", \"OpcUaStack\");\n\tuserTokenPolicy.setValue(\"TokenType\", \"Anonymous\");\n\tendpoint.setChild(\"UserTokenPolicy\", userTokenPolicy);\n\n\tendpoint.setValue(\"TransportProfileUri\", \"http:\n\tendpoint.setValue(\"SecurityLevel\", \"1\");\n\tserverConfig.addChild(\"TestConfig.EndpointDescription\", endpoint);\n\n\n\tendpoint.clear();\n\tendpoint.setValue(\"EndpointUrl\", \"opc.tcp:\n\tendpoint.setValue(\"ApplicationUri\", \"urn:localhost:compyny:Unittest\");\n\tendpoint.setValue(\"ProductUri\", \"urn:company:Unittest\");\n\tendpoint.setValue(\"ApplicationName\", \"company Unittest\");\n\tendpoint.addValue(\"DiscoveryUrl\", \"opc.tcp:\n\tendpoint.setValue(\"SecurityPolicyUri\", \"http:\n\n\tuserTokenPolicy.clear();\n\tuserTokenPolicy.setValue(\"PolicyId\", \"OpcUaStack\");\n\tuserTokenPolicy.setValue(\"TokenType\", \"Anonymous\");\n\tendpoint.setChild(\"UserTokenPolicy\", userTokenPolicy);\n\n\tendpoint.setValue(\"TransportProfileUri\", \"http:\n\tendpoint.setValue(\"SecurityLevel\", \"3\");\n\tserverConfig.addChild(\"TestConfig.EndpointDescription\", endpoint);\n\n\n\tboost::optional<Config> childConfig = serverConfig.getChild(\"TestConfig\");\n\tEndpointDescriptionArray::SPtr endpointDescriptionArray = EndpointDescriptionArray::construct();\n\trc = EndpointDescriptionConfig::endpointDescriptions(\n\t\tendpointDescriptionArray,\n\t\t\"TestConfig\",\n\t\t&*childConfig,\n\t\t\"Unknown\"\n\t);\n\tBOOST_REQUIRE(rc == true);\n\n\n\n\n\n\n\n\n\n\tserverConfig.setValue(\"TestConfig.EndpointUrl\", \"opc.tcp:\n\n\n\tExtensibleParameter ep;\n\tep.registerFactoryElement<AnonymousIdentityToken>(OpcUaId_AnonymousIdentityToken_Encoding_DefaultBinary);\n\tep.registerFactoryElement<EventFilter>(OpcUaId_EventFilter_Encoding_DefaultBinary);\n\tep.registerFactoryElement<LiteralOperand>(OpcUaId_LiteralOperand_Encoding_DefaultBinary);\n\n\tConfigXml configXml;\n\tNodeSetXmlParser nodeSetXmlParser;\n\tInformationModel::SPtr informationModel = InformationModel::construct();\n\tSessionManager sessionManager;\n\tServiceManager serviceManager;\n\n\n\n\n\tBOOST_REQUIRE(configXml.parse(\"TestData/Opc.Ua.NodeSet2.xml\") == true);\n\tBOOST_REQUIRE(nodeSetXmlParser.decode(configXml.ptree()) == true);\n\tBOOST_REQUIRE(InformationModelNodeSet::initial(informationModel, nodeSetXmlParser) == true);\n\n\tOpcUaString::SPtr stringValue;\n\n\n\t{\n\t\tOpcUaVariant variant;\n\n\t\tstringValue = OpcUaString::construct();\n\t\t*stringValue = \"http:\n\t\tvariant.variant(0, stringValue);\n\n\t\tvariant.arrayLength(1);\n\t\tBOOST_REQUIRE(informationModel->setValue(OpcUaId_Server_NamespaceArray, AttributeId_Value, variant) == true);\n\t}\n\n\t{\n\t\tOpcUaVariant variant;\n\t\tvariant.variant((OpcUaUInt32)0);\n\t\tBOOST_REQUIRE(informationModel->setValue(OpcUaId_Server_ServerStatus_State, AttributeId_Value, variant) == true);\n\t}\n\n\n\n\n\n\tBOOST_REQUIRE(serviceManager.init(sessionManager) == true);\n\tBOOST_REQUIRE(serviceManager.informatinModel(informationModel) == true);\n\tBOOST_REQUIRE(serviceManager.ioService(&ioService));\n\tserviceManager.init();\n\n\n\n\n\n\tDiscoveryService::SPtr discoveryService = DiscoveryService::construct();\n\tdiscoveryService->endpointDescriptionArray(endpointDescriptionArray);\n\tsessionManager.discoveryService(discoveryService);\n\tsessionManager.ioService(&ioService);\n\n\n\n\n\tioService.start();\n\tsessionManager.openServerSocket(\n\t\t\"TestConfig\", serverConfig,\n\t\t\"TestConfig\", serverConfig\n\t);\n\n\tIOService::secSleep(40000);\n\n\tioService.stop();\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n'OpcUaStack/src/OpcUaStackServer/ServiceManager/ServiceManager.h'\n:\n\n#ifndef __OpcUaStackServer_ServiceManager_h__\n#define __OpcUaStackServer_ServiceManager_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/IOService.h\"\n#include \"OpcUaStackServer/InformationModel/InformationModel.h\"\n#include \"OpcUaStackServer/ServiceSet/SessionManager.h\"\n#include \"OpcUaStackServer/ServiceSet/AttributeService.h\"\n#include \"OpcUaStackServer/ServiceSet/MethodService.h\"\n#include \"OpcUaStackServer/ServiceSet/NodeManagementService.h\"\n#include \"OpcUaStackServer/ServiceSet/MonitoredItemService.h\"\n#include \"OpcUaStackServer/ServiceSet/QueryService.h\"\n#include \"OpcUaStackServer/ServiceSet/SubscriptionService.h\"\n#include \"OpcUaStackServer/ServiceSet/ViewService.h\"\n#include \"OpcUaStackServer/ServiceSet/DiscoveryService.h\"\n#include \"OpcUaStackServer/ServiceSetApplication/ApplicationService.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackServer\n{\n\n\tclass DLLEXPORT ServiceManager\n\t{\n\t  public:\n\t\tServiceManager(void);\n\t\t~ServiceManager(void);\n\n\t\tbool init(SessionManager& sessionManager);\n\t\tbool informatinModel(InformationModel::SPtr informatinModel);\n\t\tbool ioThread(IOThread* ioThread);\n\t\tbool init(void);\n\t\tbool shutdown(void);\n\n\t\tApplicationService::SPtr applicationService(void);\n\t\tDiscoveryService::SPtr discoveryService(void);\n\n\t  private:\n\t\tvoid initForwardGlobalSync(void);\n\n\t\tForwardGlobalSync::SPtr forwardGlobalSync_;\n\n\t\tTransactionManager::SPtr transactionManager_;\n\t\tAttributeService::SPtr attributeService_;\n\t\tMethodService::SPtr methodService_;\n\t\tMonitoredItemService::SPtr monitoredItemService_;\n\t\tNodeManagementService::SPtr nodeManagementService_;\n\t\tQueryService::SPtr queryService_;\n\t\tSubscriptionService::SPtr subscriptionService_;\n\t\tViewService::SPtr viewService_;\n\t\tApplicationService::SPtr applicationService_;\n\t\tDiscoveryService::SPtr discoveryService_;\n\t};\n\n}\n\n#endif\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/AddReferencesRequest.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/NodeManagementServiceTransaction.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/NodeManagementService.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceManager/ServiceManager.h'",
            "'OpcUaStack/tst/OpcUaStackServer/Session_t.cpp'"
        ]
    },
    {
        "files": [
            "'elaphureLink/thirdparty/asio/include/asio/detail/impl/dev_poll_reactor.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/thread_context.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/scheduler.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/dev_poll_reactor.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/call_stack.hpp'"
        ],
        "content": "'elaphureLink/thirdparty/asio/include/asio/detail/impl/dev_poll_reactor.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_DETAIL_IMPL_DEV_POLL_REACTOR_HPP\n#define ASIO_DETAIL_IMPL_DEV_POLL_REACTOR_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n\n#if defined(ASIO_HAS_DEV_POLL)\n\n#include \"asio/detail/scheduler.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace detail {\n\ninline void dev_poll_reactor::post_immediate_completion(\n    reactor_op* op, bool is_continuation)\n{\n  scheduler_.post_immediate_completion(op, is_continuation);\n}\n\ntemplate <typename Time_Traits>\nvoid dev_poll_reactor::add_timer_queue(timer_queue<Time_Traits>& queue)\n{\n  do_add_timer_queue(queue);\n}\n\ntemplate <typename Time_Traits>\nvoid dev_poll_reactor::remove_timer_queue(timer_queue<Time_Traits>& queue)\n{\n  do_remove_timer_queue(queue);\n}\n\ntemplate <typename Time_Traits>\nvoid dev_poll_reactor::schedule_timer(timer_queue<Time_Traits>& queue,\n    const typename Time_Traits::time_type& time,\n    typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op)\n{\n  asio::detail::mutex::scoped_lock lock(mutex_);\n\n  if (shutdown_)\n  {\n    scheduler_.post_immediate_completion(op, false);\n    return;\n  }\n\n  bool earliest = queue.enqueue_timer(time, timer, op);\n  scheduler_.work_started();\n  if (earliest)\n    interrupter_.interrupt();\n}\n\ntemplate <typename Time_Traits>\nstd::size_t dev_poll_reactor::cancel_timer(timer_queue<Time_Traits>& queue,\n    typename timer_queue<Time_Traits>::per_timer_data& timer,\n    std::size_t max_cancelled)\n{\n  asio::detail::mutex::scoped_lock lock(mutex_);\n  op_queue<operation> ops;\n  std::size_t n = queue.cancel_timer(timer, ops, max_cancelled);\n  lock.unlock();\n  scheduler_.post_deferred_completions(ops);\n  return n;\n}\n\ntemplate <typename Time_Traits>\nvoid dev_poll_reactor::cancel_timer_by_key(timer_queue<Time_Traits>& queue,\n    typename timer_queue<Time_Traits>::per_timer_data* timer,\n    void* cancellation_key)\n{\n  asio::detail::mutex::scoped_lock lock(mutex_);\n  op_queue<operation> ops;\n  queue.cancel_timer_by_key(timer, ops, cancellation_key);\n  lock.unlock();\n  scheduler_.post_deferred_completions(ops);\n}\n\ntemplate <typename Time_Traits>\nvoid dev_poll_reactor::move_timer(timer_queue<Time_Traits>& queue,\n    typename timer_queue<Time_Traits>::per_timer_data& target,\n    typename timer_queue<Time_Traits>::per_timer_data& source)\n{\n  asio::detail::mutex::scoped_lock lock(mutex_);\n  op_queue<operation> ops;\n  queue.cancel_timer(target, ops);\n  queue.move_timer(target, source);\n  lock.unlock();\n  scheduler_.post_deferred_completions(ops);\n}\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/detail/thread_context.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_DETAIL_THREAD_CONTEXT_HPP\n#define ASIO_DETAIL_THREAD_CONTEXT_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include <climits>\n#include <cstddef>\n#include \"asio/detail/call_stack.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace detail {\n\nclass thread_info_base;\n\n\nclass thread_context\n{\npublic:\n\n\n  ASIO_DECL static thread_info_base* top_of_thread_call_stack();\n\nprotected:\n\n  typedef call_stack<thread_context, thread_info_base> thread_call_stack;\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#if defined(ASIO_HEADER_ONLY)\n# include \"asio/detail/impl/thread_context.ipp\"\n#endif\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/detail/scheduler.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_DETAIL_SCHEDULER_HPP\n#define ASIO_DETAIL_SCHEDULER_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n\n#include \"asio/error_code.hpp\"\n#include \"asio/execution_context.hpp\"\n#include \"asio/detail/atomic_count.hpp\"\n#include \"asio/detail/conditionally_enabled_event.hpp\"\n#include \"asio/detail/conditionally_enabled_mutex.hpp\"\n#include \"asio/detail/op_queue.hpp\"\n#include \"asio/detail/scheduler_operation.hpp\"\n#include \"asio/detail/scheduler_task.hpp\"\n#include \"asio/detail/thread.hpp\"\n#include \"asio/detail/thread_context.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace detail {\n\nstruct scheduler_thread_info;\n\nclass scheduler\n  : public execution_context_service_base<scheduler>,\n    public thread_context\n{\npublic:\n  typedef scheduler_operation operation;\n\n\n  typedef scheduler_task* (*get_task_func_type)(\n      asio::execution_context&);\n\n\n\n  ASIO_DECL scheduler(asio::execution_context& ctx,\n      int concurrency_hint = 0, bool own_thread = true,\n      get_task_func_type get_task = &scheduler::get_default_task);\n\n\n  ASIO_DECL ~scheduler();\n\n\n  ASIO_DECL void shutdown();\n\n\n  ASIO_DECL void init_task();\n\n\n  ASIO_DECL std::size_t run(asio::error_code& ec);\n\n\n  ASIO_DECL std::size_t run_one(asio::error_code& ec);\n\n\n  ASIO_DECL std::size_t wait_one(\n      long usec, asio::error_code& ec);\n\n\n  ASIO_DECL std::size_t poll(asio::error_code& ec);\n\n\n  ASIO_DECL std::size_t poll_one(asio::error_code& ec);\n\n\n  ASIO_DECL void stop();\n\n\n  ASIO_DECL bool stopped() const;\n\n\n  ASIO_DECL void restart();\n\n\n  void work_started()\n  {\n    ++outstanding_work_;\n  }\n\n\n\n  ASIO_DECL void compensating_work_started();\n\n\n  void work_finished()\n  {\n    if (--outstanding_work_ == 0)\n      stop();\n  }\n\n\n  ASIO_DECL bool can_dispatch();\n\n\n  ASIO_DECL void capture_current_exception();\n\n\n\n  ASIO_DECL void post_immediate_completion(\n      operation* op, bool is_continuation);\n\n\n\n  ASIO_DECL void post_immediate_completions(std::size_t n,\n      op_queue<operation>& ops, bool is_continuation);\n\n\n\n  ASIO_DECL void post_deferred_completion(operation* op);\n\n\n\n  ASIO_DECL void post_deferred_completions(op_queue<operation>& ops);\n\n\n\n  ASIO_DECL void do_dispatch(operation* op);\n\n\n\n  ASIO_DECL void abandon_operations(op_queue<operation>& ops);\n\n\n  int concurrency_hint() const\n  {\n    return concurrency_hint_;\n  }\n\nprivate:\n\n  typedef conditionally_enabled_mutex mutex;\n\n\n  typedef conditionally_enabled_event event;\n\n\n  typedef scheduler_thread_info thread_info;\n\n\n  ASIO_DECL std::size_t do_run_one(mutex::scoped_lock& lock,\n      thread_info& this_thread, const asio::error_code& ec);\n\n\n  ASIO_DECL std::size_t do_wait_one(mutex::scoped_lock& lock,\n      thread_info& this_thread, long usec, const asio::error_code& ec);\n\n\n  ASIO_DECL std::size_t do_poll_one(mutex::scoped_lock& lock,\n      thread_info& this_thread, const asio::error_code& ec);\n\n\n  ASIO_DECL void stop_all_threads(mutex::scoped_lock& lock);\n\n\n  ASIO_DECL void wake_one_thread_and_unlock(\n      mutex::scoped_lock& lock);\n\n\n  ASIO_DECL static scheduler_task* get_default_task(\n      asio::execution_context& ctx);\n\n\n  class thread_function;\n  friend class thread_function;\n\n\n  struct task_cleanup;\n  friend struct task_cleanup;\n\n\n  struct work_cleanup;\n  friend struct work_cleanup;\n\n\n  const bool one_thread_;\n\n\n  mutable mutex mutex_;\n\n\n  event wakeup_event_;\n\n\n  scheduler_task* task_;\n\n\n  get_task_func_type get_task_;\n\n\n  struct task_operation : operation\n  {\n    task_operation() : operation(0) {}\n  } task_operation_;\n\n\n  bool task_interrupted_;\n\n\n  atomic_count outstanding_work_;\n\n\n  op_queue<operation> op_queue_;\n\n\n  bool stopped_;\n\n\n  bool shutdown_;\n\n\n  const int concurrency_hint_;\n\n\n  asio::detail::thread* thread_;\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#if defined(ASIO_HEADER_ONLY)\n# include \"asio/detail/impl/scheduler.ipp\"\n#endif\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/detail/dev_poll_reactor.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_DETAIL_DEV_POLL_REACTOR_HPP\n#define ASIO_DETAIL_DEV_POLL_REACTOR_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n\n#if defined(ASIO_HAS_DEV_POLL)\n\n#include <cstddef>\n#include <vector>\n#include <sys/devpoll.h>\n#include \"asio/detail/hash_map.hpp\"\n#include \"asio/detail/limits.hpp\"\n#include \"asio/detail/mutex.hpp\"\n#include \"asio/detail/op_queue.hpp\"\n#include \"asio/detail/reactor_op.hpp\"\n#include \"asio/detail/reactor_op_queue.hpp\"\n#include \"asio/detail/scheduler_task.hpp\"\n#include \"asio/detail/select_interrupter.hpp\"\n#include \"asio/detail/socket_types.hpp\"\n#include \"asio/detail/timer_queue_base.hpp\"\n#include \"asio/detail/timer_queue_set.hpp\"\n#include \"asio/detail/wait_op.hpp\"\n#include \"asio/execution_context.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace detail {\n\nclass dev_poll_reactor\n  : public execution_context_service_base<dev_poll_reactor>,\n    public scheduler_task\n{\npublic:\n  enum op_types { read_op = 0, write_op = 1,\n    connect_op = 1, except_op = 2, max_ops = 3 };\n\n\n  struct per_descriptor_data\n  {\n  };\n\n\n  ASIO_DECL dev_poll_reactor(asio::execution_context& ctx);\n\n\n  ASIO_DECL ~dev_poll_reactor();\n\n\n  ASIO_DECL void shutdown();\n\n\n  ASIO_DECL void notify_fork(\n      asio::execution_context::fork_event fork_ev);\n\n\n  ASIO_DECL void init_task();\n\n\n\n  ASIO_DECL int register_descriptor(socket_type, per_descriptor_data&);\n\n\n\n  ASIO_DECL int register_internal_descriptor(\n      int op_type, socket_type descriptor,\n      per_descriptor_data& descriptor_data, reactor_op* op);\n\n\n  ASIO_DECL void move_descriptor(socket_type descriptor,\n      per_descriptor_data& target_descriptor_data,\n      per_descriptor_data& source_descriptor_data);\n\n\n  void post_immediate_completion(reactor_op* op, bool is_continuation);\n\n\n\n  ASIO_DECL void start_op(int op_type, socket_type descriptor,\n      per_descriptor_data&, reactor_op* op,\n      bool is_continuation, bool allow_speculative);\n\n\n\n\n  ASIO_DECL void cancel_ops(socket_type descriptor, per_descriptor_data&);\n\n\n\n\n  ASIO_DECL void cancel_ops_by_key(socket_type descriptor,\n      per_descriptor_data& descriptor_data,\n      int op_type, void* cancellation_key);\n\n\n\n\n  ASIO_DECL void deregister_descriptor(socket_type descriptor,\n      per_descriptor_data&, bool closing);\n\n\n\n\n  ASIO_DECL void deregister_internal_descriptor(\n      socket_type descriptor, per_descriptor_data&);\n\n\n\n  ASIO_DECL void cleanup_descriptor_data(per_descriptor_data&);\n\n\n  template <typename Time_Traits>\n  void add_timer_queue(timer_queue<Time_Traits>& queue);\n\n\n  template <typename Time_Traits>\n  void remove_timer_queue(timer_queue<Time_Traits>& queue);\n\n\n\n  template <typename Time_Traits>\n  void schedule_timer(timer_queue<Time_Traits>& queue,\n      const typename Time_Traits::time_type& time,\n      typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op);\n\n\n\n  template <typename Time_Traits>\n  std::size_t cancel_timer(timer_queue<Time_Traits>& queue,\n      typename timer_queue<Time_Traits>::per_timer_data& timer,\n      std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)());\n\n\n  template <typename Time_Traits>\n  void cancel_timer_by_key(timer_queue<Time_Traits>& queue,\n      typename timer_queue<Time_Traits>::per_timer_data* timer,\n      void* cancellation_key);\n\n\n  template <typename Time_Traits>\n  void move_timer(timer_queue<Time_Traits>& queue,\n      typename timer_queue<Time_Traits>::per_timer_data& target,\n      typename timer_queue<Time_Traits>::per_timer_data& source);\n\n\n  ASIO_DECL void run(long usec, op_queue<operation>& ops);\n\n\n  ASIO_DECL void interrupt();\n\nprivate:\n\n\n  ASIO_DECL static int do_dev_poll_create();\n\n\n  ASIO_DECL void do_add_timer_queue(timer_queue_base& queue);\n\n\n  ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);\n\n\n\n\n  ASIO_DECL int get_timeout(int msec);\n\n\n\n\n  ASIO_DECL void cancel_ops_unlocked(socket_type descriptor,\n      const asio::error_code& ec);\n\n\n  ASIO_DECL ::pollfd& add_pending_event_change(int descriptor);\n\n\n  scheduler& scheduler_;\n\n\n  asio::detail::mutex mutex_;\n\n\n  int dev_poll_fd_;\n\n\n  std::vector< ::pollfd> pending_event_changes_;\n\n\n  hash_map<int, std::size_t> pending_event_change_index_;\n\n\n  select_interrupter interrupter_;\n\n\n  reactor_op_queue<socket_type> op_queue_[max_ops];\n\n\n  timer_queue_set timer_queues_;\n\n\n  bool shutdown_;\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#include \"asio/detail/impl/dev_poll_reactor.hpp\"\n#if defined(ASIO_HEADER_ONLY)\n# include \"asio/detail/impl/dev_poll_reactor.ipp\"\n#endif\n\n#endif\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/detail/call_stack.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_DETAIL_CALL_STACK_HPP\n#define ASIO_DETAIL_CALL_STACK_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include \"asio/detail/noncopyable.hpp\"\n#include \"asio/detail/tss_ptr.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace detail {\n\n\n\ntemplate <typename Key, typename Value = unsigned char>\nclass call_stack\n{\npublic:\n\n  class context\n    : private noncopyable\n  {\n  public:\n\n    explicit context(Key* k)\n      : key_(k),\n        next_(call_stack<Key, Value>::top_)\n    {\n      value_ = reinterpret_cast<unsigned char*>(this);\n      call_stack<Key, Value>::top_ = this;\n    }\n\n\n    context(Key* k, Value& v)\n      : key_(k),\n        value_(&v),\n        next_(call_stack<Key, Value>::top_)\n    {\n      call_stack<Key, Value>::top_ = this;\n    }\n\n\n    ~context()\n    {\n      call_stack<Key, Value>::top_ = next_;\n    }\n\n\n    Value* next_by_key() const\n    {\n      context* elem = next_;\n      while (elem)\n      {\n        if (elem->key_ == key_)\n          return elem->value_;\n        elem = elem->next_;\n      }\n      return 0;\n    }\n\n  private:\n    friend class call_stack<Key, Value>;\n\n\n    Key* key_;\n\n\n    Value* value_;\n\n\n    context* next_;\n  };\n\n  friend class context;\n\n\n\n  static Value* contains(Key* k)\n  {\n    context* elem = top_;\n    while (elem)\n    {\n      if (elem->key_ == k)\n        return elem->value_;\n      elem = elem->next_;\n    }\n    return 0;\n  }\n\n\n  static Value* top()\n  {\n    context* elem = top_;\n    return elem ? elem->value_ : 0;\n  }\n\nprivate:\n\n  static tss_ptr<context> top_;\n};\n\ntemplate <typename Key, typename Value>\ntss_ptr<typename call_stack<Key, Value>::context>\ncall_stack<Key, Value>::top_;\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n",
        "gt": [
            "'elaphureLink/thirdparty/asio/include/asio/detail/call_stack.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/thread_context.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/scheduler.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/impl/dev_poll_reactor.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/detail/dev_poll_reactor.hpp'"
        ]
    },
    {
        "files": [
            "'Birch/membirch/membirch/Copier.hpp'",
            "'Birch/membirch/membirch/Bridger.hpp'",
            "'Birch/membirch/membirch/Shared.hpp'",
            "'Birch/membirch/membirch/Copier.cpp'"
        ],
        "content": "'Birch/membirch/membirch/Copier.hpp'\n:\n#pragma once\n\n#include \"membirch/external.hpp\"\n#include \"membirch/internal.hpp\"\n#include \"membirch/type.hpp\"\n#include \"membirch/Memo.hpp\"\n\nnamespace membirch {\n\nclass Copier {\npublic:\n  void visit() {\n\n  }\n\n  template<class T, std::enable_if_t<\n      is_visitable<T,Copier>::value,int> = 0>\n  void visit(T& o) {\n    o.accept_(*this);\n  }\n\n  template<class T, std::enable_if_t<\n      !is_visitable<T,Copier>::value &&\n      is_iterable<T>::value,int> = 0>\n  void visit(T& o) {\n    if (!std::is_trivial<typename T::value_type>::value) {\n      auto iter = o.begin();\n      auto last = o.end();\n      for (; iter != last; ++iter) {\n        visit(*iter);\n      }\n    }\n  }\n\n  template<class T, std::enable_if_t<\n      !is_visitable<T,Copier>::value &&\n      !is_iterable<T>::value,int> = 0>\n  void visit(T& arg) {\n\n  }\n\n  template<class Arg, class... Args>\n  void visit(Arg& arg, Args&... args) {\n    visit(arg);\n    visit(args...);\n  }\n\n  template<class... Args>\n  void visit(std::tuple<Args...>& o) {\n    std::apply([&](Args&... args) { return visit(args...); }, o);\n  }\n\n  template<class T>\n  void visit(std::optional<T>& o) {\n    if (o.has_value()) {\n      visit(o.value());\n    }\n  }\n\n  template<class T>\n  void visit(Shared<T>& o);\n\n  Any* visitObject(Any* o);\n\nprivate:\n\n  Memo m;\n};\n}\n\n#include \"membirch/Shared.hpp\"\n\ntemplate<class T>\nvoid membirch::Copier::visit(Shared<T>& o) {\n  auto [ptr, bridge] = o.unpack();\n  if (!bridge && ptr) {\n    ptr = static_cast<T*>(visitObject(ptr));\n    ptr->incShared_();\n    o.store(ptr);\n  }\n}\n\n'Birch/membirch/membirch/Bridger.hpp'\n:\n#pragma once\n\n#include \"membirch/external.hpp\"\n#include \"membirch/internal.hpp\"\n#include \"membirch/type.hpp\"\n\nnamespace membirch {\n\nclass Bridger {\npublic:\n  static constexpr int MAX = std::numeric_limits<int>::max();\n\n  std::tuple<int,int,int,int> visit(const int j, const int k) {\n    return std::make_tuple(MAX, 0, 0, 0);\n  }\n\n  template<class T, std::enable_if_t<\n      is_visitable<T,Bridger>::value,int> = 0>\n  std::tuple<int,int,int,int> visit(const int j, const int k, T& o) {\n    return o.accept_(*this, j, k);\n  }\n\n  template<class T, std::enable_if_t<\n      !is_visitable<T,Bridger>::value &&\n      is_iterable<T>::value,int> = 0>\n  std::tuple<int,int,int,int> visit(const int j, const int k, T& o) {\n    int l = MAX, h = 0, m = 0, n = 0, l1, h1, m1, n1;\n    if (!std::is_trivial<typename T::value_type>::value) {\n      auto iter = o.begin();\n      auto last = o.end();\n      for (; iter != last; ++iter) {\n        std::tie(l1, h1, m1, n1) = visit(j + m, k + n, *iter);\n        l = std::min(l, l1);\n        h = std::max(h, h1);\n        m += m1;\n        n += n1;\n      }\n    }\n    return std::make_tuple(l, h, m, n);\n  }\n\n  template<class T, std::enable_if_t<\n      !is_visitable<T,Bridger>::value &&\n      !is_iterable<T>::value,int> = 0>\n  std::tuple<int,int,int,int> visit(const int j, const int k, T& o) {\n    return std::make_tuple(MAX, 0, 0, 0);\n  }\n\n  template<class Arg, class... Args>\n  std::tuple<int,int,int,int> visit(const int j, const int k, Arg& arg,\n      Args&... args) {\n    int l, h, m, n, l1, h1, m1, n1;\n    std::tie(l, h, m, n) = visit(j, k, arg);\n    std::tie(l1, h1, m1, n1) = visit(j + m, k + n, args...);\n    l = std::min(l, l1);\n    h = std::max(h, h1);\n    m += m1;\n    n += n1;\n    return std::make_tuple(l, h, m, n);\n  }\n\n  template<class... Args>\n  std::tuple<int,int,int,int> visit(const int j, const int k,\n      std::tuple<Args...>& o) {\n    return std::apply([&](Args&... args) { return visit(j, k, args...); }, o);\n  }\n\n  template<class T>\n  std::tuple<int,int,int,int> visit(const int j, const int k,\n      std::optional<T>& o) {\n    if (o.has_value()) {\n      return visit(j, k, o.value());\n    } else {\n      return std::make_tuple(MAX, 0, 0, 0);\n    }\n  }\n\n  template<class T>\n  std::tuple<int,int,int,int> visit(const int j, const int k, Shared<T>& o);\n\n  std::tuple<int,int,int,int> visitObject(const int j, const int k, Any* o);\n};\n}\n\n#include \"membirch/Shared.hpp\"\n\ntemplate<class T>\nstd::tuple<int,int,int,int> membirch::Bridger::visit(const int j, const int k,\n    Shared<T>& o) {\n  auto [ptr, bridge] = o.unpack();\n  if (!bridge) {\n    int l, h, m, n;\n    std::tie(l, h, m, n) = visitObject(j, k, ptr);\n    if (l == j && h < j + m) {\n\n      o.setBridge();\n      n = 0;\n    }\n    return std::make_tuple(l, h, m, n);\n  } else {\n    return std::make_tuple(MAX, 0, 0, 0);\n  }\n}\n\n'Birch/membirch/membirch/Shared.hpp'\n:\n#pragma once\n\n#include \"membirch/Atomic.hpp\"\n#include \"membirch/type.hpp\"\n#include \"membirch/memory.hpp\"\n\nnamespace membirch {\n\ntemplate<class T>\nclass Shared {\n  template<class U> friend class Shared;\n  friend class Marker;\n  friend class Scanner;\n  friend class Reacher;\n  friend class Collector;\n  friend class BiconnectedCollector;\n  friend class Spanner;\n  friend class Bridger;\n  friend class Copier;\n  friend class BiconnectedCopier;\n  friend class Destroyer;\npublic:\n  using value_type = T;\n\n\n  Shared() :\n      Shared(new T(), false) {\n\n  }\n\n\n  template<class... Args>\n  Shared(std::in_place_t, Args&&... args) :\n      Shared(new T(std::forward<Args>(args)...), false) {\n\n  }\n\n\n  Shared(T* ptr, const bool bridge = false) {\n    if (ptr) {\n      ptr->incShared_();\n    }\n    pack(ptr, bridge);\n  }\n\n\n  Shared(const Shared& o) {\n    auto [ptr, bridge] = o.unpack();\n    if (ptr) {\n      if (in_copy()) {\n        if (bridge) {\n\n          ptr->incShared_();\n        } else {\n\n        }\n      } else {\n        if (bridge) {\n\n          ptr = o.get();\n          bridge = false;\n        }\n        ptr->incShared_();\n      }\n    }\n    pack(ptr, bridge);\n  }\n\n\n  template<class U, std::enable_if_t<std::is_base_of<T,U>::value,int> = 0>\n  Shared(const Shared<U>& o) {\n    auto [ptr, bridge] = o.unpack();\n    if (ptr) {\n      if (bridge) {\n\n        ptr = o.get();\n        bridge = false;\n      }\n      ptr->incShared_();\n    }\n    pack(ptr, bridge);\n  }\n\n\n  Shared(Shared&& o) {\n    packed.store(o.packed.exchange(0));\n  }\n\n\n  template<class U, std::enable_if_t<std::is_base_of<T,U>::value,int> = 0>\n  Shared(Shared<U>&& o) {\n    packed.store(o.packed.exchange(0));\n  }\n\n\n  ~Shared() {\n    release();\n  }\n\n\n  Shared& operator=(const Shared& o) {\n    replace(o);\n    return *this;\n  }\n\n\n  template<class U, std::enable_if_t<std::is_base_of<T,U>::value,int> = 0>\n  Shared& operator=(const Shared<U>& o) {\n    replace(o);\n    return *this;\n  }\n\n\n  Shared& operator=(Shared&& o) {\n    replace(std::move(o));\n    return *this;\n  }\n\n\n  template<class U, std::enable_if_t<std::is_base_of<T,U>::value,int> = 0>\n  Shared& operator=(Shared<U>&& o) {\n    replace(std::move(o));\n    return *this;\n  }\n\n\n  template<class U, std::enable_if_t<!std::is_base_of<T,U>::value,int> = 0>\n  Shared<T>& operator=(const U& o) {\n    *get() = o;\n    return *this;\n  }\n\n\n  template<class U, std::enable_if_t<!std::is_base_of<T,U>::value,int> = 0>\n  const Shared<T>& operator=(const U& o) const {\n    *get() = o;\n    return *this;\n  }\n\n\n  bool query() const {\n    return load() != nullptr;\n  }\n\n\n  T* get();\n\n\n  T* get() const {\n    return const_cast<Shared<T>*>(this)->get();\n  }\n\n\n  T* load() const {\n    return packed.load() & POINTER;\n  }\n\n\n  void bridge();\n\n\n  void bridge() const {\n    return const_cast<Shared<T>*>(this)->bridge();\n  }\n\n\n  Shared<T> copy();\n\n\n  Shared<T> copy() const {\n    return const_cast<Shared<T>*>(this)->copy();\n  }\n\n\n  template<class U>\n  void replace(const Shared<U>& o) {\n    auto [old, bridge] = unpack();\n\n\n    auto ptr = o.get();\n    if (ptr) {\n      ptr->incShared_();\n    }\n    pack(ptr, false);\n\n    if (old) {\n      if (old == ptr) {\n        old->decSharedReachable_();\n      } else if (bridge) {\n        old->decSharedBridge_();\n      } else {\n        old->decShared_();\n      }\n    }\n  }\n\n\n  template<class U>\n  void replace(Shared<U>&& o) {\n    auto packed1 = o.packed.exchange(0);\n    auto ptr = (U*)(packed1 & POINTER);\n    auto [old, bridge] = unpack(packed.exchange(packed1));\n    if (old) {\n      if (old == ptr) {\n        old->decSharedReachable_();\n      } else if (bridge) {\n        old->decSharedBridge_();\n      } else {\n        old->decShared_();\n      }\n    }\n  }\n\n\n  void release() {\n    auto [old, bridge] = unpack(packed.exchange(0));\n    if (old) {\n      if (bridge) {\n        old->decSharedBridge_();\n      } else {\n        old->decShared_();\n      }\n    }\n  }\n\n\n  void releaseBiconnected() {\n    auto [old, bridge] = unpack(packed.exchange(0));\n    if (old) {\n      if (bridge) {\n        old->decSharedBridge_();\n      } else {\n        old->decSharedBiconnected_();\n      }\n    }\n  }\n\n\n  T& operator*() {\n    return *get();\n  }\n\n\n  T& operator*() const {\n    return *get();\n  }\n\n\n  T* operator->() {\n    return get();\n  }\n\n\n  T* operator->() const {\n    return get();\n  }\n\n\n  template<class U>\n  bool operator==(const Shared<U>& o) const {\n    return get() == o.get();\n  }\n\n\n  template<class U>\n  bool operator!=(const Shared<U>& o) const {\n    return get() != o.get();\n  }\n\n\n  template<class... Args>\n  auto& operator()(Args&&... args) {\n    return (*get())(std::forward<Args>(args)...);\n  }\n\n\n  template<class... Args>\n  auto& operator()(Args&&... args) const {\n    return const_cast<Shared<T>*>(this)->operator()(std::forward<Args>(args)...);\n  }\n\nprivate:\n\n  void store(T* ptr) {\n    pack(ptr, false);\n  }\n\n\n  void setBridge() {\n    packed.maskOr(BRIDGE);\n  }\n\n\n  std::tuple<T*,bool> unpack(const int64_t p) const {\n    return std::make_tuple((T*)(p & POINTER), bool(p & BRIDGE));\n  }\n\n\n  std::tuple<T*,bool> unpack() const {\n    return unpack(packed.load());\n  }\n\n\n  std::tuple<T*,bool> lock() {\n    auto p = packed.exchangeOr(LOCK);\n    while (p & LOCK) {\n      p = packed.exchangeOr(LOCK);\n    }\n    return unpack(p);\n  }\n\n\n  void pack(T* ptr, const bool bridge) {\n    packed.store((int64_t(ptr) & POINTER) | (bridge ? BRIDGE : 0));\n  }\n\n\n  Atomic<int64_t> packed;\n};\n\ntemplate<class T>\nstruct is_pointer<Shared<T>> {\n  static const bool value = true;\n};\n\ntemplate<class T>\nstruct unwrap_pointer<Shared<T>> {\n  using type = T;\n};\n}\n\n#include \"membirch/Spanner.hpp\"\n#include \"membirch/Bridger.hpp\"\n#include \"membirch/Copier.hpp\"\n#include \"membirch/BiconnectedCopier.hpp\"\n\ntemplate<class T>\nT* membirch::Shared<T>::get() {\n  auto [ptr, bridge] = unpack();\n  auto o = ptr;\n  if (bridge) {\n    std::tie(ptr, bridge) = lock();\n    o = ptr;\n    if (bridge) {\n      if (!o->isUniqueHead_()) {\n\n        set_copy();\n        o = static_cast<T*>(BiconnectedCopier(o).visitObject(o));\n        unset_copy();\n\n\n        o->incShared_();\n      }\n    }\n    pack(o, false);\n    if (ptr != o) {\n      ptr->decSharedBridge_();\n    }\n  }\n  return o;\n}\n\ntemplate<class T>\nvoid membirch::Shared<T>::bridge() {\n  Spanner().visit(0, 1, *this);\n  Bridger().visit(1, 0, *this);\n}\n\ntemplate<class T>\nmembirch::Shared<T> membirch::Shared<T>::copy() {\n  auto [ptr, bridge] = unpack();\n  if (!bridge) {\n\n    set_copy();\n    ptr = static_cast<T*>(Copier().visitObject(ptr));\n    unset_copy();\n  }\n  return Shared<T>(ptr, bridge);\n}\n\n'Birch/membirch/membirch/Copier.cpp'\n:\n#include \"membirch/Copier.hpp\"\n\n#include \"membirch/Any.hpp\"\n\nmembirch::Any* membirch::Copier::visitObject(Any* o) {\n  auto& value = m.get(o);\n  if (value) {\n    return value;\n  } else {\n    value = o->copy_();\n\n\n    Any* result = value;\n    result->accept_(*this);\n    return result;\n  }\n}\n",
        "gt": [
            "'Birch/membirch/membirch/Bridger.hpp'",
            "'Birch/membirch/membirch/Shared.hpp'",
            "'Birch/membirch/membirch/Copier.hpp'",
            "'Birch/membirch/membirch/Copier.cpp'"
        ]
    },
    {
        "files": [
            "'Implicit-SVSDF-Planner/src/utils/include/igl/cross_field_mismatch.cpp'",
            "'Implicit-SVSDF-Planner/src/utils/include/igl/cross_field_mismatch.h'",
            "'Implicit-SVSDF-Planner/src/utils/include/igl/triangle_triangle_adjacency.h'"
        ],
        "content": "'Implicit-SVSDF-Planner/src/utils/include/igl/cross_field_mismatch.cpp'\n:\n\n\n\n\n\n\n\n#include \"cross_field_mismatch.h\"\n\n#include <cmath>\n#include <vector>\n#include <deque>\n#include \"comb_cross_field.h\"\n#include \"per_face_normals.h\"\n#include \"is_border_vertex.h\"\n#include \"vertex_triangle_adjacency.h\"\n#include \"triangle_triangle_adjacency.h\"\n#include \"rotation_matrix_from_directions.h\"\n#include \"PI.h\"\n\nnamespace igl {\n  template <typename DerivedV, typename DerivedF, typename DerivedM>\n  class MismatchCalculator\n  {\n  public:\n\n    const Eigen::MatrixBase<DerivedV> &V;\n    const Eigen::MatrixBase<DerivedF> &F;\n    const Eigen::MatrixBase<DerivedV> &PD1;\n    const Eigen::MatrixBase<DerivedV> &PD2;\n\n    DerivedV N;\n\n  private:\n\n    std::vector<bool> V_border;\n    std::vector<std::vector<int> > VF;\n    std::vector<std::vector<int> > VFi;\n\n    DerivedF TT;\n    DerivedF TTi;\n\n\n  private:\n\n    inline int mismatchByCross(const int f0,\n                               const int f1)\n    {\n      Eigen::Matrix<typename DerivedV::Scalar, 3, 1> dir1 = PD1.row(f1);\n      Eigen::Matrix<typename DerivedV::Scalar, 3, 1> n0 = N.row(f0);\n      Eigen::Matrix<typename DerivedV::Scalar, 3, 1> n1 = N.row(f1);\n\n      Eigen::Matrix<typename DerivedV::Scalar, 3, 1> dir1Rot = igl::rotation_matrix_from_directions(n1,n0)*dir1;\n      dir1Rot.normalize();\n\n      double angle_diff = atan2(dir1Rot.dot(PD2.row(f0)),dir1Rot.dot(PD1.row(f0)));\n\n      double step=igl::PI/2.0;\n      int i=(int)std::floor((angle_diff/step)+0.5);\n      int k=0;\n      if (i>=0)\n        k=i%4;\n      else\n        k=(-(3*i))%4;\n      return k;\n    }\n\n\npublic:\n  inline MismatchCalculator(const Eigen::MatrixBase<DerivedV> &_V,\n                            const Eigen::MatrixBase<DerivedF> &_F,\n                            const Eigen::MatrixBase<DerivedV> &_PD1,\n                            const Eigen::MatrixBase<DerivedV> &_PD2):\n  V(_V),\n  F(_F),\n  PD1(_PD1),\n  PD2(_PD2)\n  {\n    igl::per_face_normals(V,F,N);\n    V_border = igl::is_border_vertex(F);\n    igl::vertex_triangle_adjacency(V,F,VF,VFi);\n    igl::triangle_triangle_adjacency(F,TT,TTi);\n  }\n\n  inline void calculateMismatch(Eigen::PlainObjectBase<DerivedM> &Handle_MMatch)\n  {\n    Handle_MMatch.setConstant(F.rows(),3,-1);\n    for (size_t i=0;i<F.rows();i++)\n    {\n      for (int j=0;j<3;j++)\n      {\n        if (((int)i)==TT(i,j) || TT(i,j) == -1)\n          Handle_MMatch(i,j)=0;\n        else\n          Handle_MMatch(i,j) = mismatchByCross(i, TT(i, j));\n      }\n    }\n  }\n\n};\n}\ntemplate <typename DerivedV, typename DerivedF, typename DerivedM>\nIGL_INLINE void igl::cross_field_mismatch(const Eigen::MatrixBase<DerivedV> &V,\n                                          const Eigen::MatrixBase<DerivedF> &F,\n                                          const Eigen::MatrixBase<DerivedV> &PD1,\n                                          const Eigen::MatrixBase<DerivedV> &PD2,\n                                          const bool isCombed,\n                                          Eigen::PlainObjectBase<DerivedM> &mismatch)\n{\n  DerivedV PD1_combed;\n  DerivedV PD2_combed;\n\n  if (!isCombed)\n    igl::comb_cross_field(V,F,PD1,PD2,PD1_combed,PD2_combed);\n  else\n  {\n    PD1_combed = PD1;\n    PD2_combed = PD2;\n  }\n  igl::MismatchCalculator<DerivedV, DerivedF, DerivedM> sf(V, F, PD1_combed, PD2_combed);\n  sf.calculateMismatch(mismatch);\n}\n\n#ifdef IGL_STATIC_LIBRARY\n\ntemplate void igl::cross_field_mismatch<Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3> >(Eigen::MatrixBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const &, Eigen::MatrixBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > const &,  Eigen::MatrixBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const &,  Eigen::MatrixBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const &, const bool,  Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > &);\ntemplate void igl::cross_field_mismatch<Eigen::Matrix<double, -1, -1, 0, -1, -1>, Eigen::Matrix<int, -1, -1, 0, -1, -1> >( Eigen::MatrixBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const &, Eigen::MatrixBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> > const &, Eigen::MatrixBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const &, Eigen::MatrixBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const &, const bool, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> > &);\ntemplate void igl::cross_field_mismatch<Eigen::Matrix<double, -1, -1, 0, -1, -1>, Eigen::Matrix<int, -1, -1, 0, -1, -1>, Eigen::Matrix<int, -1, 3, 0, -1, 3> >(Eigen::MatrixBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const &, Eigen::MatrixBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> > const &, Eigen::MatrixBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const &, Eigen::MatrixBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const &, const bool, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > &);\n\n#endif\n\n'Implicit-SVSDF-Planner/src/utils/include/igl/cross_field_mismatch.h'\n:\n\n\n\n\n\n\n\n#ifndef IGL_CROSS_FIELD_MISMATCH_H\n#define IGL_CROSS_FIELD_MISMATCH_H\n#include \"igl_inline.h\"\n#include <Eigen/Core>\nnamespace igl\n{\n\n\n\n\n\n\n\n\n\n\n\n\n\n  template <typename DerivedV, typename DerivedF, typename DerivedM>\n  IGL_INLINE void cross_field_mismatch(const Eigen::MatrixBase<DerivedV> &V,\n                                       const Eigen::MatrixBase<DerivedF> &F,\n                                       const Eigen::MatrixBase<DerivedV> &PD1,\n                                       const Eigen::MatrixBase<DerivedV> &PD2,\n                                       const bool isCombed,\n                                       Eigen::PlainObjectBase<DerivedM> &mismatch);\n}\n#ifndef IGL_STATIC_LIBRARY\n#include \"cross_field_mismatch.cpp\"\n#endif\n\n#endif\n\n'Implicit-SVSDF-Planner/src/utils/include/igl/triangle_triangle_adjacency.h'\n:\n\n\n\n\n\n\n#ifndef IGL_TRIANGLE_TRIANGLE_ADJACENCY_H\n#define IGL_TRIANGLE_TRIANGLE_ADJACENCY_H\n#include \"igl_inline.h\"\n#include <Eigen/Core>\n#include <vector>\n\nnamespace igl\n{\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  template <typename DerivedF, typename DerivedTT, typename DerivedTTi>\n  IGL_INLINE void triangle_triangle_adjacency(\n    const Eigen::MatrixBase<DerivedF>& F,\n    Eigen::PlainObjectBase<DerivedTT>& TT,\n    Eigen::PlainObjectBase<DerivedTTi>& TTi);\n\n  template <typename DerivedF, typename DerivedTT>\n  IGL_INLINE void triangle_triangle_adjacency(\n    const Eigen::MatrixBase<DerivedF>& F,\n    Eigen::PlainObjectBase<DerivedTT>& TT);\n\n\n\n\n\n\n  template <typename DerivedF, typename TTT_type>\n  IGL_INLINE void triangle_triangle_adjacency_preprocess(\n    const Eigen::MatrixBase<DerivedF>& F,\n    std::vector<std::vector<TTT_type> >& TTT);\n\n\n\n\n\n\n\n\n  template <typename DerivedF, typename TTT_type, typename DerivedTT>\n  IGL_INLINE void triangle_triangle_adjacency_extractTT(\n    const Eigen::MatrixBase<DerivedF>& F,\n    std::vector<std::vector<TTT_type> >& TTT,\n    Eigen::PlainObjectBase<DerivedTT>& TT);\n\n\n\n\n\n\n\n\n  template <typename DerivedF, typename TTT_type, typename DerivedTTi>\n  IGL_INLINE void triangle_triangle_adjacency_extractTTi(\n    const Eigen::MatrixBase<DerivedF>& F,\n    std::vector<std::vector<TTT_type> >& TTT,\n    Eigen::PlainObjectBase<DerivedTTi>& TTi);\n\n\n\n\n\n\n\n\n\n  template <\n    typename DerivedF,\n    typename TTIndex,\n    typename TTiIndex>\n    IGL_INLINE void triangle_triangle_adjacency(\n      const Eigen::MatrixBase<DerivedF> & F,\n      std::vector<std::vector<std::vector<TTIndex> > > & TT,\n      std::vector<std::vector<std::vector<TTiIndex> > > & TTi);\n\n  template < typename DerivedF, typename TTIndex>\n    IGL_INLINE void triangle_triangle_adjacency(\n      const Eigen::MatrixBase<DerivedF> & F,\n      std::vector<std::vector<std::vector<TTIndex> > > & TT);\n\n\n\n\n  template <\n    typename DerivedF,\n    typename TTIndex,\n    typename TTiIndex>\n    IGL_INLINE void triangle_triangle_adjacency(\n      const Eigen::MatrixBase<DerivedF> & F,\n      const bool construct_TTi,\n      std::vector<std::vector<std::vector<TTIndex> > > & TT,\n      std::vector<std::vector<std::vector<TTiIndex> > > & TTi);\n\n\n\n\n\n\n\n\n\n\n  template <\n    typename DerivedE,\n    typename DerivedEMAP,\n    typename uE2EType,\n    typename TTIndex,\n    typename TTiIndex>\n    IGL_INLINE void triangle_triangle_adjacency(\n      const Eigen::MatrixBase<DerivedE> & E,\n      const Eigen::MatrixBase<DerivedEMAP> & EMAP,\n      const std::vector<std::vector<uE2EType > > & uE2E,\n      const bool construct_TTi,\n      std::vector<std::vector<std::vector<TTIndex> > > & TT,\n      std::vector<std::vector<std::vector<TTiIndex> > > & TTi);\n\n\n\n\n\n\n\n  template <\n    typename DerivedEMAP,\n    typename DeriveduEC,\n    typename DeriveduEE,\n    typename TTIndex,\n    typename TTiIndex>\n  IGL_INLINE void triangle_triangle_adjacency(\n    const Eigen::MatrixBase<DerivedEMAP> & EMAP,\n    const Eigen::MatrixBase<DeriveduEC> & uEC,\n    const Eigen::MatrixBase<DeriveduEE> & uEE,\n    const bool construct_TTi,\n    std::vector<std::vector<std::vector<TTIndex> > > & TT,\n    std::vector<std::vector<std::vector<TTiIndex> > > & TTi);\n}\n\n#ifndef IGL_STATIC_LIBRARY\n#  include \"triangle_triangle_adjacency.cpp\"\n#endif\n\n#endif\n",
        "gt": [
            "'Implicit-SVSDF-Planner/src/utils/include/igl/triangle_triangle_adjacency.h'",
            "'Implicit-SVSDF-Planner/src/utils/include/igl/cross_field_mismatch.cpp'",
            "'Implicit-SVSDF-Planner/src/utils/include/igl/cross_field_mismatch.h'"
        ]
    },
    {
        "files": [
            "'PrivacyGo/dpca-psi/src/dpca-psi/crypto/prng.h'",
            "'PrivacyGo/dpca-psi/src/dpca-psi/common/utils.h'",
            "'PrivacyGo/ppam/example/ppam_example.cpp'"
        ],
        "content": "'PrivacyGo/dpca-psi/src/dpca-psi/crypto/prng.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n#include <algorithm>\n#include <cstring>\n#include <vector>\n\n#include \"dpca-psi/crypto/aes.h\"\n\nnamespace privacy_go {\nnamespace dpca_psi {\n\nclass PRNG {\npublic:\n    PRNG();\n\n    explicit PRNG(const block& seed, std::uint64_t buffer_size = 256);\n\n    PRNG(PRNG&& s);\n\n    PRNG(const PRNG&) = delete;\n\n    void operator=(PRNG&&);\n\n    void set_seed(const block& b, std::uint64_t buffer_size = 256);\n\n    const block get_seed() const;\n\n    template <typename T>\n    T get() {\n        T ret;\n        get(&ret, 1);\n        return ret;\n    }\n\n    template <typename T>\n    void get(T* dest, std::uint64_t length) {\n        std::uint64_t length_u8 = length * sizeof(T);\n        std::uint8_t* dest_u8 = reinterpret_cast<std::uint8_t*>(dest);\n\n        impl_get(dest_u8, length_u8);\n    }\n\n    std::uint8_t get_bit();\n\n    typedef std::uint64_t result_type;\n    static constexpr result_type min() {\n        return 0;\n    }\n    static constexpr result_type max() {\n        return (result_type)-1;\n    }\n    result_type operator()() {\n        return get<result_type>();\n    }\n\nprivate:\n    void refill_buffer();\n\n    void impl_get(std::uint8_t* data_u8, std::uint64_t length_u8);\n\n    std::vector<block> buffer_;\n\n    AES aes_;\n\n    std::uint64_t bytes_idx_;\n    std::uint64_t block_idx_;\n    std::uint64_t buffer_byte_capacity_;\n};\n\ntemplate <>\ninline void PRNG::get<bool>(bool* dest, std::uint64_t length) {\n    get(reinterpret_cast<std::uint8_t*>(dest), length);\n    for (std::uint64_t i = 0; i < length; ++i) {\n        dest[i] = (reinterpret_cast<std::uint8_t*>(dest)[i]) & 1;\n    }\n}\n\ntemplate <>\ninline bool PRNG::get<bool>() {\n    std::uint8_t ret;\n    get(reinterpret_cast<std::uint8_t*>(&ret), 1);\n    return ret & 1;\n}\n\n}\n}\n\n'PrivacyGo/dpca-psi/src/dpca-psi/common/utils.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n#include <algorithm>\n#include <chrono>\n#include <fstream>\n#include <random>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"dpca-psi/crypto/prng.h\"\n\nnamespace privacy_go {\nnamespace dpca_psi {\n\ninline std::string string_2_hex(const std::string& data) {\n    const std::string hex = \"0123456789ABCDEF\";\n    std::stringstream ss;\n    for (const auto& item : data) {\n        ss << hex[(unsigned char)item >> 4] << hex[(unsigned char)item & 0xf];\n    }\n    return std::move(ss.str());\n}\n\ninline std::string hex_2_string(const std::string& data) {\n    std::string result;\n    for (std::size_t i = 0; i < data.length(); i += 2) {\n        std::string byte = data.substr(i, 2);\n        char chr = static_cast<char>(strtol(byte.c_str(), NULL, 16));\n        result.push_back(chr);\n    }\n    return result;\n}\n\ninline block read_block_from_dev_urandom() {\n    block ret;\n    std::ifstream in(\"/dev/urandom\");\n    in.read(reinterpret_cast<char*>(&ret), sizeof(ret));\n    in.close();\n    return ret;\n}\n\ntemplate <typename T>\ninline T read_data_from_dev_urandom() {\n    T ret;\n    std::ifstream in(\"/dev/urandom\");\n    in.read(reinterpret_cast<char*>(&ret), sizeof(ret));\n    in.close();\n    return ret;\n}\n\ninline std::chrono::time_point<std::chrono::high_resolution_clock> clock_start() {\n    return std::chrono::high_resolution_clock::now();\n}\n\ninline std::int64_t time_from(const std::chrono::time_point<std::chrono::high_resolution_clock>& start) {\n    return std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now() - start)\n            .count();\n}\n\n\ninline std::vector<std::size_t> generate_permutation(std::size_t n) {\n    std::vector<std::size_t> permutation(n);\n    for (std::size_t i = 0; i < n; ++i) {\n        permutation[i] = i;\n    }\n    auto seed = read_block_from_dev_urandom();\n    PRNG prng(seed);\n    std::shuffle(permutation.begin(), permutation.end(), prng);\n    return permutation;\n}\n\n\ntemplate <typename T>\ninline void permute_and_undo(const std::vector<std::size_t>& permutation, bool is_permute, std::vector<T>& data) {\n    std::vector<T> output;\n    output.resize(data.size());\n    if (is_permute) {\n        for (std::size_t i = 0; i < permutation.size(); ++i) {\n            output[permutation[i]] = data[i];\n        }\n    } else {\n        for (std::size_t i = 0; i < permutation.size(); ++i) {\n            output[i] = data[permutation[i]];\n        }\n    }\n    data.clear();\n    std::swap(output, data);\n}\n\n}\n}\n\n'PrivacyGo/ppam/example/ppam_example.cpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <random>\n#include <string>\n\n#include \"gflags/gflags.h\"\n#include \"glog/logging.h\"\n#include \"nlohmann/json.hpp\"\n\n#include \"dpca-psi/common/dummy_data_utils.h\"\n#include \"dpca-psi/common/utils.h\"\n#include \"dpca-psi/crypto/prng.h\"\n#include \"dpca-psi/dp_cardinality_psi.h\"\n#include \"dpca-psi/network/two_channel_net_io.h\"\n#include \"ppam/ppam.h\"\n\nstd::vector<double> random_features(std::size_t n, std::size_t min, std::size_t max, bool is_zero) {\n    std::vector<double> result(n, 0.0);\n    std::random_device rd(\"/dev/urandom\");\n    std::default_random_engine eng(rd());\n    std::uniform_real_distribution<double> distr(static_cast<double>(min), static_cast<double>(max));\n    if (!is_zero) {\n        for (std::size_t i = 0; i < n; ++i) {\n            result[i] = distr(eng) - (static_cast<double>(min) - static_cast<double>(max)) / 2.0;\n        }\n    }\n    return result;\n}\n\nvoid ppam_example(const std::string& config_path, const std::string& log_path, std::size_t intersection_size,\n        std::size_t intersection_ratio, std::size_t feature_size, bool use_default_tau, std::size_t default_tau) {\n    auto start = privacy_go::dpca_psi::clock_start();\n\n    std::ifstream in(config_path);\n    nlohmann::json params = nlohmann::json::parse(in, nullptr, true);\n    in.close();\n\n    bool is_sender = params[\"common\"][\"is_sender\"];\n    bool input_dp = params[\"dp_params\"][\"input_dp\"];\n    FLAGS_alsologtostderr = 1;\n    FLAGS_log_dir = log_path;\n    std::string log_file_name;\n    log_file_name = std::string(\"ppam_\") + (is_sender ? \"sender_\" : \"receiver_\") +\n                    (input_dp ? \"with_dp_\" : \"without_dp_\") + \"intersection_size_\" + std::to_string(intersection_size);\n\n    google::InitGoogleLogging(log_file_name.c_str());\n\n\n    std::string address = params[\"common\"][\"address\"];\n    std::uint16_t remote_port = params[\"common\"][\"remote_port\"];\n    std::uint16_t local_port = params[\"common\"][\"local_port\"];\n    auto net = std::make_shared<privacy_go::dpca_psi::TwoChannelNetIO>(address, remote_port, local_port);\n\n\n    std::vector<std::vector<std::string>> keys;\n    std::vector<std::vector<double>> features;\n\n    double expected_sum = 0.0;\n    double actual_sum = 0.0;\n\n    std::size_t data_size = intersection_ratio * intersection_size;\n    std::size_t key_size = params[\"common\"][\"ids_num\"];\n    privacy_go::dpca_psi::block common_seed = privacy_go::dpca_psi::kZeroBlock;\n    if (is_sender) {\n        common_seed = privacy_go::dpca_psi::read_block_from_dev_urandom();\n        net->send_value<privacy_go::dpca_psi::block>(common_seed);\n    } else {\n        common_seed = net->recv_value<privacy_go::dpca_psi::block>();\n    }\n\n    privacy_go::dpca_psi::PRNG common_prng;\n    common_prng.set_seed(common_seed);\n    privacy_go::dpca_psi::PRNG unique_prng;\n    unique_prng.set_seed(privacy_go::dpca_psi::read_block_from_dev_urandom());\n\n    keys.reserve(key_size);\n    if (key_size == 3) {\n        std::vector<double> column_intersection_ratio = {0.85, 0.1, 0.05};\n        std::size_t accumulated_intersection_size = 0;\n        for (std::size_t key_idx = 0; key_idx < key_size; ++key_idx) {\n            std::size_t cur_intersection_size = std::min(\n                    std::size_t(std::ceil(static_cast<double>(intersection_size) * column_intersection_ratio[key_idx])),\n                    intersection_size - accumulated_intersection_size);\n            auto common_keys = privacy_go::dpca_psi::random_keys(\n                    common_prng, cur_intersection_size, \"bench\" + std::to_string(key_idx));\n            std::string unique_suffix = (is_sender ? \"sender\" : \"receiver\") + std::to_string(key_idx);\n            auto unique_keys =\n                    privacy_go::dpca_psi::random_keys(unique_prng, data_size - cur_intersection_size, unique_suffix);\n            unique_keys.insert(\n                    unique_keys.begin() + accumulated_intersection_size, common_keys.begin(), common_keys.end());\n            accumulated_intersection_size += cur_intersection_size;\n            keys.emplace_back(unique_keys);\n        }\n    } else {\n        std::size_t column_intersection_size = (intersection_size + key_size - 1) / key_size;\n        for (std::size_t key_idx = 0; key_idx < key_size; ++key_idx) {\n            std::size_t cur_intersection_size =\n                    std::min(column_intersection_size, intersection_size - key_idx * column_intersection_size);\n            auto common_keys = privacy_go::dpca_psi::random_keys(\n                    common_prng, cur_intersection_size, \"bench\" + std::to_string(key_idx));\n            std::string unique_suffix = (is_sender ? \"sender\" : \"receiver\") + std::to_string(key_idx);\n            auto unique_keys =\n                    privacy_go::dpca_psi::random_keys(unique_prng, data_size - cur_intersection_size, unique_suffix);\n            unique_keys.insert(\n                    unique_keys.begin() + key_idx * column_intersection_size, common_keys.begin(), common_keys.end());\n            keys.emplace_back(unique_keys);\n        }\n    }\n\n    features.reserve(feature_size);\n    for (std::size_t i = 0; i < feature_size; ++i) {\n        features.emplace_back(random_features(data_size, 5, 10, false));\n    }\n\n    if (use_default_tau) {\n        params[\"dp_params\"][\"precomputed_tau\"] = default_tau;\n    }\n\n    std::size_t communication = 0;\n\n\n    privacy_go::ppam::PrivacyMeasurement ads_measure;\n    ads_measure.initialize(params, net);\n    actual_sum = ads_measure.measurement(15.0, keys, features);\n\n\n    auto duration = static_cast<double>(privacy_go::dpca_psi::time_from(start)) * 1.0 / 1000000.0;\n    communication = net->get_bytes_sent();\n    std::size_t remote_communication = 0;\n    if (is_sender) {\n        net->send_value<std::uint64_t>(communication);\n        remote_communication = net->recv_value<std::uint64_t>();\n    } else {\n        remote_communication = net->recv_value<std::uint64_t>();\n        net->send_value<std::uint64_t>(communication);\n    }\n\n    double self_comm = static_cast<double>(communication) * 1.0 / (1024 * 1024);\n    double remote_comm = static_cast<double>(remote_communication) * 1.0 / (1024 * 1024);\n    double total_comm = static_cast<double>(communication + remote_communication) * 1.0 / (1024 * 1024);\n\n    expected_sum = ads_measure.plain_measurement(15.0, keys, features);\n\n    LOG(INFO) << \"-------------------------------\";\n    LOG(INFO) << (is_sender ? \"Sender\" : \"Receiver\");\n    LOG(INFO) << \"Apply dp: \" << params[\"dp_params\"][\"input_dp\"];\n    LOG(INFO) << \"Total Communication is \" << total_comm << \"(\" << self_comm << \" + \" << remote_comm << \")\"\n              << \"MB.\" << std::endl;\n    LOG(INFO) << \"Total time is \" << duration << \" s.\";\n    LOG(INFO) << \"Expected / Actual sum is \" << expected_sum << \" / \" << actual_sum;\n\n    assert((expected_sum - actual_sum < 0.01));\n\n    google::ShutdownGoogleLogging();\n}\n\nDEFINE_string(\n        config_path, \"./json/sender_with_precomputed_tau.json\", \"the path where the sender's config file located\");\nDEFINE_string(log_path, \"./logs/\", \"the directory where log file located\");\nDEFINE_uint64(intersection_size, 10, \"the intersection size of both party.\");\nDEFINE_uint64(intersection_ratio, 100, \"the ratio of sender/receiver data size to intersection size.\");\nDEFINE_uint64(feature_size, 1, \"the feature size of sender/receiver data.\");\nDEFINE_bool(use_default_tau, false, \"whether or not use default tau. just for testing.\");\nDEFINE_uint64(default_tau, 1440, \"default tau. just for testing.\");\n\nint main(int argc, char* argv[]) {\n    gflags::ParseCommandLineFlags(&argc, &argv, true);\n    ppam_example(FLAGS_config_path, FLAGS_log_path, FLAGS_intersection_size, FLAGS_intersection_ratio,\n            FLAGS_feature_size, FLAGS_use_default_tau, FLAGS_default_tau);\n    return 0;\n}\n",
        "gt": [
            "'PrivacyGo/dpca-psi/src/dpca-psi/crypto/prng.h'",
            "'PrivacyGo/dpca-psi/src/dpca-psi/common/utils.h'",
            "'PrivacyGo/ppam/example/ppam_example.cpp'"
        ]
    },
    {
        "files": [
            "'OpenStudioApplication/src/openstudio_lib/SpacesTabController.cpp'",
            "'OpenStudioApplication/src/openstudio_lib/SpacesSubtabGridView.hpp'",
            "'OpenStudioApplication/src/openstudio_lib/SpacesSubsurfacesGridView.hpp'"
        ],
        "content": "'OpenStudioApplication/src/openstudio_lib/SpacesTabController.cpp'\n:\n\n#include \"SpacesTabController.hpp\"\n\n#include \"SpacesDaylightingGridView.hpp\"\n#include \"SpacesInteriorPartitionsGridView.hpp\"\n#include \"SpacesLoadsGridView.hpp\"\n#include \"SpacesShadingGridView.hpp\"\n#include \"SpacesSpacesGridView.hpp\"\n#include \"SpacesSubsurfacesGridView.hpp\"\n#include \"SpacesSurfacesGridView.hpp\"\n#include \"SpacesTabView.hpp\"\n\nnamespace openstudio {\n\nSpacesTabController::SpacesTabController(bool isIP, bool displayAdditionalProps, const model::Model& model)\n  : MainTabController(new SpacesTabView()), m_model(model), m_isIP(isIP), m_displayAdditionalProps(displayAdditionalProps) {\n  mainContentWidget()->addSubTab(\"Properties\", SPACES);\n  mainContentWidget()->addSubTab(\"Loads\", LOADS);\n  mainContentWidget()->addSubTab(\"Surfaces\", SURFACES);\n  mainContentWidget()->addSubTab(\"Subsurfaces\", SUBSURFACES);\n  mainContentWidget()->addSubTab(\"Interior Partitions\", INTERIOR_PARTITIONS);\n  mainContentWidget()->addSubTab(\"Shading\", SHADING);\n\n  connect(this->mainContentWidget(), &MainTabView::tabSelected, this, &SpacesTabController::setSubTab);\n\n\n\n}\n\nSpacesTabController::~SpacesTabController() {\n  disconnect(this->mainContentWidget(), &MainTabView::tabSelected, this, &SpacesTabController::setSubTab);\n}\n\nvoid SpacesTabController::toggleUnits(bool displayIP) {}\n\nvoid SpacesTabController::setSubTab(int index) {\n  if (m_currentIndex == index) {\n    return;\n  } else {\n    m_currentIndex = index;\n  }\n\n  if (m_currentView) {\n    m_currentView->disconnect();\n    delete m_currentView;\n  }\n\n  switch (index) {\n    case 0: {\n      auto* spacesSpacesGridView = new SpacesSpacesGridView(m_isIP, m_displayAdditionalProps, m_model);\n      connect(this, &SpacesTabController::toggleUnitsClicked, spacesSpacesGridView, &SpacesSpacesGridView::toggleUnitsClicked);\n      connect(spacesSpacesGridView, &SpacesSpacesGridView::dropZoneItemSelected, this, &SpacesTabController::dropZoneItemSelected);\n      connect(this, &SpacesTabController::toggleDisplayAdditionalPropsClicked, spacesSpacesGridView,\n              &SpacesSpacesGridView::toggleDisplayAdditionalPropsClicked);\n      mainContentWidget()->setSubTab(spacesSpacesGridView);\n      m_currentView = spacesSpacesGridView;\n      break;\n    }\n    case 1: {\n      auto* spacesLoadsGridView = new SpacesLoadsGridView(m_isIP, m_displayAdditionalProps, m_model);\n      connect(this, &SpacesTabController::toggleUnitsClicked, spacesLoadsGridView, &SpacesLoadsGridView::toggleUnitsClicked);\n      connect(spacesLoadsGridView, &SpacesLoadsGridView::dropZoneItemSelected, this, &SpacesTabController::dropZoneItemSelected);\n      connect(this, &SpacesTabController::toggleDisplayAdditionalPropsClicked, spacesLoadsGridView,\n              &SpacesLoadsGridView::toggleDisplayAdditionalPropsClicked);\n      mainContentWidget()->setSubTab(spacesLoadsGridView);\n      m_currentView = spacesLoadsGridView;\n      break;\n    }\n    case 2: {\n      auto* spacesSurfacesGridView = new SpacesSurfacesGridView(m_isIP, m_displayAdditionalProps, m_model);\n      connect(this, &SpacesTabController::toggleUnitsClicked, spacesSurfacesGridView, &SpacesSurfacesGridView::toggleUnitsClicked);\n      connect(spacesSurfacesGridView, &SpacesSurfacesGridView::dropZoneItemSelected, this, &SpacesTabController::dropZoneItemSelected);\n      connect(this, &SpacesTabController::toggleDisplayAdditionalPropsClicked, spacesSurfacesGridView,\n              &SpacesSurfacesGridView::toggleDisplayAdditionalPropsClicked);\n      mainContentWidget()->setSubTab(spacesSurfacesGridView);\n      m_currentView = spacesSurfacesGridView;\n      break;\n    }\n    case 3: {\n      auto* spacesSubsurfacesGridView = new SpacesSubsurfacesGridView(m_isIP, m_displayAdditionalProps, m_model);\n      connect(this, &SpacesTabController::toggleUnitsClicked, spacesSubsurfacesGridView, &SpacesSubsurfacesGridView::toggleUnitsClicked);\n      connect(spacesSubsurfacesGridView, &SpacesSubsurfacesGridView::dropZoneItemSelected, this, &SpacesTabController::dropZoneItemSelected);\n      connect(this, &SpacesTabController::toggleDisplayAdditionalPropsClicked, spacesSubsurfacesGridView,\n              &SpacesSubsurfacesGridView::toggleDisplayAdditionalPropsClicked);\n      mainContentWidget()->setSubTab(spacesSubsurfacesGridView);\n      m_currentView = spacesSubsurfacesGridView;\n      break;\n    }\n    case 4: {\n      auto* spacesInteriorPartitionsGridView = new SpacesInteriorPartitionsGridView(m_isIP, m_displayAdditionalProps, m_model);\n      connect(this, &SpacesTabController::toggleUnitsClicked, spacesInteriorPartitionsGridView,\n              &SpacesInteriorPartitionsGridView::toggleUnitsClicked);\n      connect(spacesInteriorPartitionsGridView, &SpacesInteriorPartitionsGridView::dropZoneItemSelected, this,\n              &SpacesTabController::dropZoneItemSelected);\n      connect(this, &SpacesTabController::toggleDisplayAdditionalPropsClicked, spacesInteriorPartitionsGridView,\n              &SpacesInteriorPartitionsGridView::toggleDisplayAdditionalPropsClicked);\n      mainContentWidget()->setSubTab(spacesInteriorPartitionsGridView);\n      m_currentView = spacesInteriorPartitionsGridView;\n      break;\n    }\n    case 5: {\n      auto* spacesShadingGridView = new SpacesShadingGridView(m_isIP, m_displayAdditionalProps, m_model);\n      connect(this, &SpacesTabController::toggleUnitsClicked, spacesShadingGridView, &SpacesShadingGridView::toggleUnitsClicked);\n      connect(spacesShadingGridView, &SpacesShadingGridView::dropZoneItemSelected, this, &SpacesTabController::dropZoneItemSelected);\n      connect(this, &SpacesTabController::toggleDisplayAdditionalPropsClicked, spacesShadingGridView,\n              &SpacesShadingGridView::toggleDisplayAdditionalPropsClicked);\n      mainContentWidget()->setSubTab(spacesShadingGridView);\n      m_currentView = spacesShadingGridView;\n      break;\n    }\n    default:\n      OS_ASSERT(false);\n      break;\n  }\n}\n\n}\n\n'OpenStudioApplication/src/openstudio_lib/SpacesSubtabGridView.hpp'\n:\n\n#ifndef OPENSTUDIO_SPACESSUBTABGRIDVIEW_HPP\n#define OPENSTUDIO_SPACESSUBTABGRIDVIEW_HPP\n\n#include \"../shared_gui_components/OSGridController.hpp\"\n\n#include \"GridViewSubTab.hpp\"\n#include \"OSItem.hpp\"\n\n#include <openstudio/model/Model.hpp>\n\nclass QComboBox;\nclass QLineEdit;\n\nnamespace openstudio {\n\nclass SpacesSubsurfacesGridController;\n\nclass SpacesSubtabGridView : public GridViewSubTab\n{\n  Q_OBJECT\n\n public:\n  SpacesSubtabGridView(bool isIP, bool displayAdditionalProps, const model::Model& model, QWidget* parent = nullptr);\n\n  virtual ~SpacesSubtabGridView() = default;\n\n  QLineEdit* m_thermalZoneNameFilter = nullptr;\n\n  QLineEdit* m_spaceNameFilter = nullptr;\n\n  QComboBox* m_storyFilter = nullptr;\n\n  QComboBox* m_thermalZoneFilter = nullptr;\n\n  QComboBox* m_spaceTypeFilter = nullptr;\n\n  QComboBox* m_subSurfaceTypeFilter = nullptr;\n\n  QComboBox* m_loadTypeFilter = nullptr;\n\n  QComboBox* m_windExposureFilter = nullptr;\n\n  QComboBox* m_sunExposureFilter = nullptr;\n\n  QComboBox* m_outsideBoundaryConditionFilter = nullptr;\n\n  QComboBox* m_surfaceTypeFilter = nullptr;\n\n  QComboBox* m_interiorPartitionGroupFilter = nullptr;\n\n protected:\n  REGISTER_LOGGER(\"openstudio.SpacesSubtabGridView\");\n\n  virtual void addObject(const openstudio::IddObjectType& iddObjectType) override;\n\n  virtual void purgeObjects(const openstudio::IddObjectType& iddObjectType) override;\n\n  void showStoryFilter();\n\n  void showThermalZoneFilter();\n\n  void showSpaceTypeFilter();\n\n  void showSubSurfaceTypeFilter();\n\n  void showSpaceNameFilter();\n\n  void showWindExposureFilter();\n\n  void showSunExposureFilter();\n\n  void showOutsideBoundaryConditionFilter();\n\n  void showSurfaceTypeFilter();\n\n  void showInteriorPartitionGroupFilter();\n\n  void showLoadTypeFilter();\n\n  void initializeStoryFilter();\n\n  void initializeThermalZoneFilter();\n\n  void initializeSpaceTypeFilter();\n\n  void initializeSubSurfaceTypeFilter();\n\n  void initializeLoadTypeFilter();\n\n  void initializeWindExposureFilter();\n\n  void initializeSunExposureFilter();\n\n  void initializeOutsideBoundaryConditionFilter();\n\n  void initializeSurfaceTypeFilter();\n\n  void initializeInteriorPartitionGroupFilter();\n\n  void filterChanged();\n\n\n\n\n  std::set<openstudio::model::ModelObject> m_objectsFilteredByStory;\n\n  std::set<openstudio::model::ModelObject> m_objectsFilteredByThermalZone;\n\n  std::set<openstudio::model::ModelObject> m_objectsFilteredBySpaceType;\n\n  std::set<openstudio::model::ModelObject> m_objectsFilteredBySubSurfaceType;\n\n  std::set<openstudio::model::ModelObject> m_objectsFilteredBySpaceName;\n\n  std::set<openstudio::model::ModelObject> m_objectsFilteredByWindExposure;\n\n  std::set<openstudio::model::ModelObject> m_objectsFilteredBySunExposure;\n\n  std::set<openstudio::model::ModelObject> m_objectsFilteredByOutsideBoundaryCondition;\n\n  std::set<openstudio::model::ModelObject> m_objectsFilteredBySurfaceType;\n\n  std::set<openstudio::model::ModelObject> m_objectsFilteredByInteriorPartitionGroup;\n\n  std::set<openstudio::model::ModelObject> m_objectsFilteredByLoadType;\n\n  QGridLayout* m_filterGridLayout = nullptr;\n\n  std::vector<model::ModelObject> m_spacesModelObjects = std::vector<model::ModelObject>();\n\n protected slots:\n\n  virtual void spaceNameFilterChanged();\n\n  virtual void subSurfaceTypeFilterChanged(const QString& text);\n\n  virtual void storyFilterChanged(const QString& text);\n\n  virtual void thermalZoneFilterChanged(const QString& text);\n\n  virtual void spaceTypeFilterChanged(const QString& text);\n\n  virtual void loadTypeFilterChanged(const QString& text);\n\n  virtual void windExposureFilterChanged(const QString& text);\n\n  virtual void sunExposureFilterChanged(const QString& text);\n\n  virtual void outsideBoundaryConditionFilterChanged(const QString& text);\n\n  virtual void surfaceTypeFilterChanged(const QString& text);\n\n  virtual void interiorPartitionGroupFilterChanged(const QString& text);\n\n private:\n\n\n  virtual bool hasSubRows() {\n    return true;\n  };\n};\n\n}\n\n#endif\n\n'OpenStudioApplication/src/openstudio_lib/SpacesSubsurfacesGridView.hpp'\n:\n\n#ifndef OPENSTUDIO_SPACESSUBSURFACESGRIDVIEW_HPP\n#define OPENSTUDIO_SPACESSUBSURFACESGRIDVIEW_HPP\n\n#include \"../shared_gui_components/OSGridController.hpp\"\n\n#include \"SpacesSubtabGridView.hpp\"\n#include \"OSItem.hpp\"\n\n#include <openstudio/model/Model.hpp>\n\nnamespace openstudio {\n\nclass SpacesSubsurfacesGridController;\n\nclass SpacesSubsurfacesGridView : public SpacesSubtabGridView\n{\n  Q_OBJECT\n\n public:\n  SpacesSubsurfacesGridView(bool isIP, bool displayAdditionalProps, const model::Model& model, QWidget* parent = nullptr);\n\n  virtual ~SpacesSubsurfacesGridView() = default;\n\n protected:\n  virtual void removeObject(openstudio::model::ModelObject modelObject) override;\n\n protected slots:\n\n  virtual void onSelectItem() override;\n\n  virtual void onClearSelection() override;\n\n private:\n  void clearSelection();\n\n  REGISTER_LOGGER(\"openstudio.SpacesSubsurfacesGridView\");\n};\n\nclass SpacesSubsurfacesGridController : public OSGridController\n{\n\n  Q_OBJECT\n\n public:\n  SpacesSubsurfacesGridController(bool isIP, bool displayAdditionalProps, const QString& headerText, IddObjectType iddObjectType,\n                                  const model::Model& model, const std::vector<model::ModelObject>& modelObjects);\n\n  virtual ~SpacesSubsurfacesGridController() = default;\n\n  virtual void refreshModelObjects() override;\n\n protected:\n  void setCategoriesAndFields();\n\n  virtual void addColumns(const QString& category, std::vector<QString>& fields) override;\n\n  virtual void checkSelectedFields() override;\n\n  virtual QString getColor(const model::ModelObject& modelObject) override;\n\n public slots:\n\n  virtual void onCategorySelected(int index) override;\n\n  virtual void onItemDropped(const OSItemId& itemId) override;\n};\n\n}\n\n#endif\n",
        "gt": [
            "'OpenStudioApplication/src/openstudio_lib/SpacesSubtabGridView.hpp'",
            "'OpenStudioApplication/src/openstudio_lib/SpacesSubsurfacesGridView.hpp'",
            "'OpenStudioApplication/src/openstudio_lib/SpacesTabController.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackCore/Component/Component.h'",
            "'OpcUaStack/src/OpcUaClient/ClientCommand/CommandBrowse.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ViewServiceBrowse.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ViewService.h'",
            "'OpcUaStack/src/OpcUaClient/Client/ClientApplication.cpp'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackCore/Component/Component.h'\n:\n\n#ifndef __OpcUaStackCore_Component_h__\n#define __OpcUaStackCore_Component_h__\n\n#include <boost/thread/mutex.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/weak_ptr.hpp>\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/IOService.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaNodeId.h\"\n#include \"OpcUaStackCore/Utility/IOThread.h\"\n#include \"OpcUaStackCore/Component/Message.h\"\n\nnamespace OpcUaStackCore\n{\n\tclass DLLEXPORT Component\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<Component> SPtr;\n\t\ttypedef std::map<std::string, Component*> ComponentMap;\n\n\t\tComponent(void);\n\t\tvirtual ~Component(void);\n\n\t\tstatic Component* getComponent(const std::string& componentName);\n\n\t\tvoid ioThread(IOThread* ioThread);\n\t\tIOThread* ioThread(void);\n\t\tvoid componentName(const std::string& componentName);\n\t\tstd::string componentName(void);\n\n\t\tComponent* component(const std::string& componentName);\n\t\tComponent* component(void);\n\n\t\tvirtual void receive(Message::SPtr message) = 0;\n\t\tvoid send(Message::SPtr message);\n\t\tvoid sendAsync(Message::SPtr message);\n\n\t\tvoid send(const std::string& componentName, Message::SPtr message);\n\t\tvoid sendAsync(const std::string& componentName, Message::SPtr message);\n\t\tvoid send(Component& component, Message::SPtr message);\n\t\tvoid sendAsync(Component& component, Message::SPtr message);\n\n\t  private:\n\t\tstatic ComponentMap componentMap_;\n\n\t\tstatic boost::mutex globalMutex_;\n\t\tstatic void addComponent(const std::string& componentName, Component& component);\n\t\tstatic void removeComponent(const std::string& componentName);\n\t\tstatic void removeComponent(Component& component);\n\n\t\tstd::string componentName_;\n\t\tIOThread* ioThread_;\n\t\tboost::mutex mutex_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaClient/ClientCommand/CommandBrowse.h'\n:\n\n#ifndef __OpcUaClient_CommandBrowse_h__\n#define __OpcUaClient_CommandBrowse_h__\n\n#include <boost/shared_ptr.hpp>\n#include \"OpcUaStackCore/BuildInTypes/OpcUaNodeId.h\"\n#include \"OpcUaClient/ClientCommand/CommandBase.h\"\n#include \"OpcUaStackClient/ServiceSet/ViewServiceBrowse.h\"\n\nusing namespace OpcUaStackCore;\nusing namespace OpcUaStackClient;\n\nnamespace OpcUaClient\n{\n\n\tclass CommandBrowse\n\t: public CommandBase\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<CommandBrowse> SPtr;\n\n\t\tCommandBrowse(void);\n\t\tvirtual ~CommandBrowse(void);\n\n\n\t\tvirtual CommandBase::SPtr createCommand(void);\n\t\tvirtual bool validateCommand(void);\n\t\tvirtual bool addParameter(const std::string& parameterName, const std::string& parameterValue);\n\t\tvirtual std::string help(void);\n\n\n\t\tOpcUaNodeId::Vec& nodeIdVec(void);\n\t\tBrowseDirectionEnum direction(void);\n\t\tbool recursive(void);\n\n\t  private:\n\t\tOpcUaNodeId::Vec nodeIdVec_;\n\t\tBrowseDirectionEnum direction_;\n\t\tbool recursive_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackClient/ServiceSet/ViewServiceBrowse.h'\n:\n\n#ifndef __OpcUaStackClient_ViewServiceBrowse_h__\n#define __OpcUaStackClient_ViewServiceBrowse_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackClient/ServiceSet/ViewService.h\"\n#include <set>\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackClient\n{\n\n\tclass DLLEXPORT ViewServiceBrowseIf\n\t{\n\t  public:\n\t\tViewServiceBrowseIf(void) {}\n\t\tvirtual ~ViewServiceBrowseIf(void) {}\n\n\t\tvirtual void viewServiceBrowseDone(OpcUaStatusCode statusCode) = 0;\n\t\tvirtual void viewServiceBrowseResult(\n\t\t\tOpcUaStatusCode statusCode,\n\t\t\tOpcUaNodeId::SPtr& nodeId,\n\t\t\tReferenceDescription::Vec& referenceDescriptionVec\n\t\t) = 0;\n\t};\n\n\n\tclass DLLEXPORT ViewServiceBrowse\n\t: public ViewServiceIf\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<ViewServiceBrowse> SPtr;\n\n\t\tViewServiceBrowse(void);\n\t\t~ViewServiceBrowse(void);\n\n\t\tvoid maxNodesInBrowse(uint32_t maxNodesInBrowse);\n\t\tvoid viewService(ViewService::SPtr& viewService);\n\t\tvoid nodeIdVec(OpcUaNodeId::Vec& nodeIdVec);\n\t\tvoid direction(BrowseDirectionEnum direction);\n\t\tvoid recursive(bool recursive);\n\t\tvoid viewServiceBrowseIf(ViewServiceBrowseIf* viewServiceBrowseIf);\n\n\t\tvoid asyncBrowse(void);\n\n\n\t    virtual void viewServiceBrowseResponse(ServiceTransactionBrowse::SPtr serviceTransactionBrowse);\n\t    virtual void viewServiceBrowseNextResponse(ServiceTransactionBrowseNext::SPtr serviceTransactionBrowseNext);\n\n\n\t  private:\n\t    void asyncBrowseNext(void);\n\t\tvoid done(OpcUaStatusCode statusCode);\n\t\tvoid browseResult(\n\t\t\tOpcUaStatusCode statusCode,\n\t\t\tOpcUaNodeId::SPtr& nodeId,\n\t\t\tReferenceDescription::Vec& referenceDescriptionVec\n\t\t);\n\n\t\tViewService::SPtr viewService_;\n\t\tViewServiceBrowseIf* viewServiceBrowseIf_;\n\n\t\tuint32_t maxNodesInBrowse_;\n\t\tOpcUaNodeId::Vec nodeIdVec_;\n\t\tBrowseDirectionEnum direction_;\n\t\tbool recursive_;\n\t\tstd::vector<ReferenceDescription::Vec> referenceDescriptionVecVec_;\n\t\tstd::vector<std::string> continuationPointVec_;\n\n\t\tstd::set<OpcUaNodeId> nodeIdToReadSet_;\n\t\tstd::set<OpcUaNodeId> nodeIdProcessedSet_;\n\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackClient/ServiceSet/ViewService.h'\n:\n\n#ifndef __OpcUaStackClient_ViewService_h__\n#define __OpcUaStackClient_ViewService_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Component/Component.h\"\n#include \"OpcUaStackCore/ServiceSet/ViewServiceTransaction.h\"\n#include \"OpcUaStackClient/ServiceSet/ViewServiceIf.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackClient\n{\n\n\tclass DLLEXPORT ViewService\n\t: public Component\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<ViewService> SPtr;\n\n\t\tViewService(IOThread* ioThread);\n\t\t~ViewService(void);\n\n\t\tvoid setConfiguration(\n\t\t\tComponent* componentSession,\n\t\t\tViewServiceIf* viewServiceIf\n\t\t);\n\t\tvoid componentSession(Component* componentSession);\n\t\tvoid viewServiceIf(ViewServiceIf* viewServiceIf);\n\n\t\tvoid syncSend(ServiceTransactionBrowse::SPtr serviceTransactionBrowse);\n\t\tvoid asyncSend(ServiceTransactionBrowse::SPtr serviceTransactionBrowse);\n\t\tvoid syncSend(ServiceTransactionBrowseNext::SPtr serviceTransactionBrowseNext);\n\t\tvoid asyncSend(ServiceTransactionBrowseNext::SPtr serviceTransactionBrowseNext);\n\t\tvoid syncSend(ServiceTransactionTranslateBrowsePathsToNodeIds::SPtr serviceTransactionTranslateBrowsePathsToNodeIds);\n\t\tvoid asyncSend(ServiceTransactionTranslateBrowsePathsToNodeIds::SPtr serviceTransactionTranslateBrowsePathsToNodeIds);\n\n\n\n\t\tvoid receive(Message::SPtr message);\n\n\n\t  private:\n\t\tComponent* componentSession_;\n\n\t\tViewServiceIf* viewServiceIf_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaClient/Client/ClientApplication.cpp'\n:\n\n\n#include \"OpcUaClient/Client/ClientApplication.h\"\n#include \"OpcUaClient/ClientCommand/CommandParser.h\"\n#include \"OpcUaClient/ClientService/ClientServiceExecute.h\"\n\n\n#include \"OpcUaClient/ClientCommand/CommandConnect.h\"\n#include \"OpcUaClient/ClientCommand/CommandDisconnect.h\"\n#include \"OpcUaClient/ClientCommand/CommandRead.h\"\n#include \"OpcUaClient/ClientCommand/CommandReadH.h\"\n#include \"OpcUaClient/ClientCommand/CommandWrite.h\"\n#include \"OpcUaClient/ClientCommand/CommandWriteH.h\"\n#include \"OpcUaClient/ClientCommand/CommandDelay.h\"\n#include \"OpcUaClient/ClientCommand/CommandNodeSetServer.h\"\n#include \"OpcUaClient/ClientCommand/CommandNodeSetFilter.h\"\n#include \"OpcUaClient/ClientCommand/CommandBrowse.h\"\n#include \"OpcUaClient/ClientCommand/CommandFunction.h\"\n#include \"OpcUaClient/ClientCommand/CommandBrowsePathToNodeId.h\"\n#include \"OpcUaClient/ClientCommand/CommandGetEndpoint.h\"\n#include \"OpcUaClient/ClientCommand/CommandFindServer.h\"\n#include \"OpcUaClient/ClientCommand/CommandRegisterServer.h\"\n\n\n#include \"OpcUaClient/ClientService/ClientServiceConnect.h\"\n#include \"OpcUaClient/ClientService/ClientServiceDisconnect.h\"\n#include \"OpcUaClient/ClientService/ClientServiceRead.h\"\n#include \"OpcUaClient/ClientService/ClientServiceReadH.h\"\n#include \"OpcUaClient/ClientService/ClientServiceWrite.h\"\n#include \"OpcUaClient/ClientService/ClientServiceWriteH.h\"\n#include \"OpcUaClient/ClientService/ClientServiceDelay.h\"\n#include \"OpcUaClient/ClientService/ClientServiceNodeSetServer.h\"\n#include \"OpcUaClient/ClientService/ClientServiceNodeSetFilter.h\"\n#include \"OpcUaClient/ClientService/ClientServiceBrowse.h\"\n#include \"OpcUaClient/ClientService/ClientServiceFunction.h\"\n#include \"OpcUaClient/ClientService/ClientServiceBrowsePathToNodeId.h\"\n#include \"OpcUaClient/ClientService/ClientServiceGetEndpoint.h\"\n#include \"OpcUaClient/ClientService/ClientServiceFindServer.h\"\n#include \"OpcUaClient/ClientService/ClientServiceRegisterServer.h\"\n\nnamespace OpcUaClient\n{\n\n\tClientApplication::ClientApplication(void)\n\t: core_()\n\t{\n\t\tcore_.init();\n\t}\n\n\tClientApplication::~ClientApplication(void)\n\t{\n\t\tcore_.cleanup();\n\t}\n\n\tint\n\tClientApplication::run(uint32_t argc, char** argv)\n\t{\n\n\t\tCommandParser::addCommand(\"CONNECT\", constructSPtr<CommandConnect>());\n\t\tCommandParser::addCommand(\"DISCONNECT\", constructSPtr<CommandDisconnect>());\n\t\tCommandParser::addCommand(\"READ\", constructSPtr<CommandRead>());\n\t\tCommandParser::addCommand(\"WRITE\", constructSPtr<CommandWrite>());\n\t\tCommandParser::addCommand(\"READH\", constructSPtr<CommandReadH>());\n\t\tCommandParser::addCommand(\"WRITEH\", constructSPtr<CommandWriteH>());\n\t\tCommandParser::addCommand(\"DELAY\", constructSPtr<CommandDelay>());\n\t\tCommandParser::addCommand(\"NODESETSERVER\", constructSPtr<CommandNodeSetServer>());\n\t\tCommandParser::addCommand(\"NODESETFILTER\", constructSPtr<CommandNodeSetFilter>());\n\t\tCommandParser::addCommand(\"BROWSE\", constructSPtr<CommandBrowse>());\n\t\tCommandParser::addCommand(\"FUNCTION\", constructSPtr<CommandFunction>());\n\t\tCommandParser::addCommand(\"BROWSEPATHTONODEID\", constructSPtr<CommandBrowsePathToNodeId>());\n\t\tCommandParser::addCommand(\"GETENDPOINT\", constructSPtr<CommandGetEndpoint>());\n\t\tCommandParser::addCommand(\"FINDSERVER\", constructSPtr<CommandFindServer>());\n\t\tCommandParser::addCommand(\"REGISTERSERVER\", constructSPtr<CommandRegisterServer>());\n\n\n\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_Connect, constructSPtr<ClientServiceConnect>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_Disconnect, constructSPtr<ClientServiceDisconnect>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_Read, constructSPtr<ClientServiceRead>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_ReadH, constructSPtr<ClientServiceReadH>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_Write, constructSPtr<ClientServiceWrite>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_WriteH, constructSPtr<ClientServiceWriteH>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_Delay, constructSPtr<ClientServiceDelay>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_NodeSetServer, constructSPtr<ClientServiceNodeSetServer>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_NodeSetFilter, constructSPtr<ClientServiceNodeSetFilter>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_Browse, constructSPtr<ClientServiceBrowse>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_Function, constructSPtr<ClientServiceFunction>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_BrowsePathToNodeId, constructSPtr<ClientServiceBrowsePathToNodeId>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_GetEndpoint, constructSPtr<ClientServiceGetEndpoint>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_FindServer, constructSPtr<ClientServiceFindServer>());\n\t\tClientServiceExecute::addClientService(CommandBase::Cmd_RegisterServer, constructSPtr<ClientServiceRegisterServer>());\n\n\n\t\tCommandParser commandParser;\n\t\tCommandBase::Vec commandBaseVec;\n\t\tif (!commandParser.parse(argc, argv, commandBaseVec)) {\n\t\t\tstd::cerr << commandParser.errorString() << std::endl;\n\t\t\treturn -1;\n\t\t}\n\n\n\t\tClientServiceExecute clientServiceExecute;\n\t\tif (!clientServiceExecute.run(commandBaseVec)) {\n\t\t\tstd::cerr << clientServiceExecute.errorString() << std::endl;\n\t\t\treturn -1;\n\t\t}\n\n\t\tstd::cout << \"OK\" << std::endl;\n\t\treturn 0;\n\t}\n\n}\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/Component/Component.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ViewService.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ViewServiceBrowse.h'",
            "'OpcUaStack/src/OpcUaClient/ClientCommand/CommandBrowse.h'",
            "'OpcUaStack/src/OpcUaClient/Client/ClientApplication.cpp'"
        ]
    },
    {
        "files": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test_external/mkl/check_mkl.cpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/algebra/range_algebra.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/euler.hpp'"
        ],
        "content": "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test_external/mkl/check_mkl.cpp'\n:\n\n#define BOOST_TEST_MODULE test_mkl\n\n#include <boost/test/unit_test.hpp>\n\n#include <boost/numeric/odeint/stepper/euler.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta4.hpp>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/numeric/odeint/external/mkl/mkl_operations.hpp>\n\nusing namespace boost::numeric::odeint;\n\ntypedef double value_type;\ntypedef boost::array< value_type , 1 > state_type;\n\n\nvoid constant_system( state_type &x , state_type &dxdt , value_type t )\n{\n    dxdt[0] = 1.0;\n}\n\nconst double eps = 1E-14;\n\n\nBOOST_AUTO_TEST_CASE( test_mkl )\n{\n\n\n    runge_kutta4< state_type , value_type , state_type , value_type , vector_space_algebra , mkl_operations > stepper;\n    state_type x;\n    x[0] = 0.0;\n\n    stepper.do_step( constant_system , x , 0.0 , 0.1 );\n\n    using std::abs;\n\n    std::cout << x[0] << \" ?= \" << 0.1 << std::endl;\n    BOOST_CHECK_SMALL( abs( x[0] - 0.1 ) , eps );\n\n}\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/algebra/range_algebra.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_ALGEBRA_RANGE_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_ALGEBRA_RANGE_ALGEBRA_HPP_INCLUDED\n\n#include <boost/range.hpp>\n#include <boost/mpl/size_t.hpp>\n\n#include <boost/numeric/odeint/algebra/detail/macros.hpp>\n#include <boost/numeric/odeint/algebra/detail/for_each.hpp>\n#include <boost/numeric/odeint/algebra/detail/reduce.hpp>\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\nstruct range_algebra\n{\n    template< class S1 , class Op >\n    static void for_each1( S1 &s1 , Op op )\n    {\n        detail::for_each1( boost::begin( s1 ) , boost::end( s1 ) ,\n                op );\n    }\n\n    template< class S1 , class S2 , class Op >\n    static void for_each2( S1 &s1 , S2 &s2 , Op op )\n    {\n        detail::for_each2( boost::begin( s1 ) , boost::end( s1 ) ,\n                boost::begin( s2 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class Op >\n    static void for_each3( S1 &s1 , S2 &s2 , S3 &s3 , Op op )\n    {\n        detail::for_each3( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class Op >\n    static void for_each4( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , Op op )\n    {\n        detail::for_each4( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class S5 , class Op >\n    static void for_each5( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , S5 &s5 , Op op )\n    {\n        detail::for_each5( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , boost::begin( s5 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class S5 , class S6 , class Op >\n    static void for_each6( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , S5 &s5 , S6 &s6 , Op op )\n    {\n        detail::for_each6( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , boost::begin( s5 ) , boost::begin( s6 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class S5 , class S6 ,class S7 , class Op >\n    static void for_each7( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , S5 &s5 , S6 &s6 , S7 &s7 , Op op )\n    {\n        detail::for_each7( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , boost::begin( s5 ) , boost::begin( s6 ) , boost::begin( s7 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class S5 , class S6 ,class S7 , class S8 , class Op >\n    static void for_each8( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , S5 &s5 , S6 &s6 , S7 &s7 , S8 &s8 , Op op )\n    {\n        detail::for_each8( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , boost::begin( s5 ) , boost::begin( s6 ) , boost::begin( s7 ) , boost::begin( s8 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class S5 , class S6 ,class S7 , class S8 , class S9 , class Op >\n    static void for_each9( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , S5 &s5 , S6 &s6 , S7 &s7 , S8 &s8 , S9 &s9 , Op op )\n    {\n        detail::for_each9( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , boost::begin( s5 ) , boost::begin( s6 ) , boost::begin( s7 ) , boost::begin( s8 ) , boost::begin( s9 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class S5 , class S6 ,class S7 , class S8 , class S9 , class S10 , class Op >\n    static void for_each10( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , S5 &s5 , S6 &s6 , S7 &s7 , S8 &s8 , S9 &s9 , S10 &s10 , Op op )\n    {\n        detail::for_each10( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , boost::begin( s5 ) , boost::begin( s6 ) , boost::begin( s7 ) , boost::begin( s8 ) , boost::begin( s9 ) , boost::begin( s10 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class S5 , class S6 ,class S7 , class S8 , class S9 , class S10 , class S11 , class Op >\n    static void for_each11( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , S5 &s5 , S6 &s6 , S7 &s7 , S8 &s8 , S9 &s9 , S10 &s10 , S11 &s11 , Op op )\n    {\n        detail::for_each11( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , boost::begin( s5 ) , boost::begin( s6 ) , boost::begin( s7 ) , boost::begin( s8 ) , boost::begin( s9 ) , boost::begin( s10 ) , boost::begin( s11 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class S5 , class S6 ,class S7 , class S8 , class S9 , class S10 , class S11 , class S12 , class Op >\n    static void for_each12( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , S5 &s5 , S6 &s6 , S7 &s7 , S8 &s8 , S9 &s9 , S10 &s10 , S11 &s11 , S12 &s12 , Op op )\n    {\n        detail::for_each12( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , boost::begin( s5 ) , boost::begin( s6 ) , boost::begin( s7 ) , boost::begin( s8 ) , boost::begin( s9 ) , boost::begin( s10 ) , boost::begin( s11 ) , boost::begin( s12 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class S5 , class S6 ,class S7 , class S8 , class S9 , class S10 , class S11 , class S12 , class S13 , class Op >\n    static void for_each13( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , S5 &s5 , S6 &s6 , S7 &s7 , S8 &s8 , S9 &s9 , S10 &s10 , S11 &s11 , S12 &s12 , S13 &s13 , Op op )\n    {\n        detail::for_each13( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , boost::begin( s5 ) , boost::begin( s6 ) , boost::begin( s7 ) , boost::begin( s8 ) , boost::begin( s9 ) , boost::begin( s10 ) , boost::begin( s11 ) , boost::begin( s12 ) , boost::begin( s13 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class S5 , class S6 ,class S7 , class S8 , class S9 , class S10 , class S11 , class S12 , class S13 , class S14 , class Op >\n    static void for_each14( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , S5 &s5 , S6 &s6 , S7 &s7 , S8 &s8 , S9 &s9 , S10 &s10 , S11 &s11 , S12 &s12 , S13 &s13 , S14 &s14 , Op op )\n    {\n        detail::for_each14( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , boost::begin( s5 ) , boost::begin( s6 ) , boost::begin( s7 ) , boost::begin( s8 ) , boost::begin( s9 ) , boost::begin( s10 ) , boost::begin( s11 ) , boost::begin( s12 ) , boost::begin( s13 ) , boost::begin( s14 ) , op );\n    }\n\n    template< class S1 , class S2 , class S3 , class S4 , class S5 , class S6 ,class S7 , class S8 , class S9 , class S10 , class S11 , class S12 , class S13 , class S14 , class S15 , class Op >\n    static void for_each15( S1 &s1 , S2 &s2 , S3 &s3 , S4 &s4 , S5 &s5 , S6 &s6 , S7 &s7 , S8 &s8 , S9 &s9 , S10 &s10 , S11 &s11 , S12 &s12 , S13 &s13 , S14 &s14 , S15 &s15 , Op op )\n    {\n        detail::for_each15( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , boost::begin( s5 ) , boost::begin( s6 ) , boost::begin( s7 ) , boost::begin( s8 ) , boost::begin( s9 ) , boost::begin( s10 ) , boost::begin( s11 ) , boost::begin( s12 ) , boost::begin( s13 ) , boost::begin( s14 ) , boost::begin( s15 ) , op );\n    }\n\n    template< class Value , class S , class Red >\n    static Value reduce( const S &s , Red red , Value init)\n    {\n        return detail::reduce( boost::begin( s ) , boost::end( s ) , red , init );\n    }\n\n    template< class Value , class S1 , class S2 , class Red >\n    static Value reduce2( const S1 &s1 , const S2 &s2 , Red red , Value init )\n    {\n        return detail::reduce2( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , red , init );\n    }\n\n    template< class Value , class S1 , class S2 , class S3 , class Red >\n    static Value reduce3( const S1 &s1 , const S2 &s2 , const S3 &s3 , Red red , Value init )\n    {\n        return detail::reduce3( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , red , init );\n    }\n\n    template< class Value , class S1 , class S2 , class S3 , class S4 , class Red >\n    static Value reduce4( const S1 &s1 , const S2 &s2 , const S3 &s3 , const S4 &s4 , Red red , Value init )\n    {\n        return detail::reduce4( boost::begin( s1 ) , boost::end( s1 ) , boost::begin( s2 ) , boost::begin( s3 ) , boost::begin( s4 ) , red , init );\n    }\n\n\n};\n\n}\n}\n}\n\n\n#endif\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/euler.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_STEPPER_EULER_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_STEPPER_EULER_HPP_INCLUDED\n\n\n#include <boost/numeric/odeint/stepper/base/explicit_stepper_base.hpp>\n#include <boost/numeric/odeint/util/resizer.hpp>\n#include <boost/numeric/odeint/algebra/range_algebra.hpp>\n#include <boost/numeric/odeint/algebra/default_operations.hpp>\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\n\ntemplate<\nclass State ,\nclass Value = double ,\nclass Deriv = State ,\nclass Time = Value ,\nclass Algebra = range_algebra ,\nclass Operations = default_operations ,\nclass Resizer = initially_resizer\n>\n#ifndef DOXYGEN_SKIP\nclass euler\n: public explicit_stepper_base<\n  euler< State , Value , Deriv , Time , Algebra , Operations , Resizer > ,\n  1 , State , Value , Deriv , Time , Algebra , Operations , Resizer >\n#else\nclass euler : public explicit_stepper_base\n#endif\n{\npublic :\n\n    #ifndef DOXYGEN_SKIP\n    typedef explicit_stepper_base< euler< State , Value , Deriv , Time , Algebra , Operations , Resizer > , 1 , State , Value , Deriv , Time , Algebra , Operations , Resizer > stepper_base_type;\n    #else\n    typedef explicit_stepper_base< euler< ... > , ... > stepper_base_type;\n    #endif\n    typedef typename stepper_base_type::state_type state_type;\n    typedef typename stepper_base_type::value_type value_type;\n    typedef typename stepper_base_type::deriv_type deriv_type;\n    typedef typename stepper_base_type::time_type time_type;\n    typedef typename stepper_base_type::algebra_type algebra_type;\n    typedef typename stepper_base_type::operations_type operations_type;\n    typedef typename stepper_base_type::resizer_type resizer_type;\n\n    #ifndef DOXYGEN_SKIP\n    typedef typename stepper_base_type::stepper_type stepper_type;\n    typedef typename stepper_base_type::wrapped_state_type wrapped_state_type;\n    typedef typename stepper_base_type::wrapped_deriv_type wrapped_deriv_type;\n    #endif\n\n\n    euler( const algebra_type &algebra = algebra_type() ) : stepper_base_type( algebra )\n    { }\n\n    template< class System , class StateIn , class DerivIn , class StateOut >\n    void do_step_impl( System system , const StateIn &in , const DerivIn &dxdt , time_type t , StateOut &out , time_type dt )\n    {\n        stepper_base_type::m_algebra.for_each3( out , in , dxdt ,\n                typename operations_type::template scale_sum2< value_type , time_type >( 1.0 , dt ) );\n\n    }\n\n    template< class StateOut , class StateIn1 , class StateIn2 >\n    void calc_state( StateOut &x , time_type t ,  const StateIn1 &old_state , time_type t_old , const StateIn2 &current_state , time_type t_new ) const\n    {\n        const time_type delta = t - t_old;\n        stepper_base_type::m_algebra.for_each3( x , old_state , stepper_base_type::m_dxdt.m_v ,\n                typename operations_type::template scale_sum2< value_type , time_type >( 1.0 , delta ) );\n    }\n\n    template< class StateType >\n    void adjust_size( const StateType &x )\n    {\n        stepper_base_type::adjust_size( x );\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}\n}\n}\n\n\n#endif\n",
        "gt": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/algebra/range_algebra.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/euler.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test_external/mkl/check_mkl.cpp'"
        ]
    },
    {
        "files": [
            "'parthenon/example/particle_tracers/main.cpp'",
            "'parthenon/src/parthenon/driver.hpp'",
            "'parthenon/example/particle_tracers/particle_tracers.hpp'",
            "'parthenon/src/utils/concepts_lite.hpp'",
            "'parthenon/src/utils/reductions.hpp'"
        ],
        "content": "'parthenon/example/particle_tracers/main.cpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"parthenon_manager.hpp\"\n\n#include \"particle_tracers.hpp\"\n\nint main(int argc, char *argv[]) {\n  using parthenon::ParthenonManager;\n  using parthenon::ParthenonStatus;\n  ParthenonManager pman;\n\n\n  pman.app_input->ProcessPackages = tracers_example::ProcessPackages;\n  pman.app_input->ProblemGenerator = tracers_example::ProblemGenerator;\n\n\n  auto manager_status = pman.ParthenonInitEnv(argc, argv);\n  if (manager_status == ParthenonStatus::complete) {\n    pman.ParthenonFinalize();\n    return 0;\n  }\n  if (manager_status == ParthenonStatus::error) {\n    pman.ParthenonFinalize();\n    return 1;\n  }\n\n\n\n\n  pman.ParthenonInitPackagesAndMesh();\n  {\n\n    tracers_example::ParticleDriver driver(pman.pinput.get(), pman.app_input.get(),\n                                           pman.pmesh.get());\n\n\n    auto driver_status = driver.Execute();\n  }\n\n  pman.ParthenonFinalize();\n\n\n\n  return (0);\n}\n\n'parthenon/src/parthenon/driver.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef PARTHENON_DRIVER_HPP_\n#define PARTHENON_DRIVER_HPP_\n\n\n#include <application_input.hpp>\n#include <basic_types.hpp>\n#include <bvals/boundary_conditions.hpp>\n#include <driver/driver.hpp>\n#include <driver/multistage.hpp>\n#include <interface/update.hpp>\n#include <mesh/mesh.hpp>\n#include <mesh/mesh_refinement.hpp>\n#include <mesh/meshblock_pack.hpp>\n#include <outputs/outputs.hpp>\n#include <parameter_input.hpp>\n#include <tasks/tasks.hpp>\n#include <utils/partition_stl_containers.hpp>\n#include <utils/reductions.hpp>\n#include <utils/unique_id.hpp>\n\n\n#include \"prelude.hpp\"\n\nnamespace parthenon {\nnamespace driver {\nnamespace prelude {\nusing namespace ::parthenon::prelude;\n\nusing ::parthenon::AllReduce;\nusing ::parthenon::ApplicationInput;\nusing ::parthenon::ApplyBoundaryConditions;\nusing ::parthenon::BlockList_t;\nusing ::parthenon::Driver;\nusing ::parthenon::DriverStatus;\nusing ::parthenon::EvolutionDriver;\nusing ::parthenon::Mesh;\nusing ::parthenon::MeshBlock;\nusing ::parthenon::MeshBlockPack;\nusing ::parthenon::MeshBlockVarFluxPack;\nusing ::parthenon::MeshBlockVarPack;\nusing ::parthenon::MultiStageBlockTaskDriver;\nusing ::parthenon::MultiStageDriver;\nusing ::parthenon::Outputs;\nusing ::parthenon::Packages_t;\nusing ::parthenon::ParameterInput;\nusing ::parthenon::ParthenonManager;\nusing ::parthenon::Reduce;\nusing ::parthenon::StagedIntegrator;\nusing ::parthenon::Task;\nusing ::parthenon::TaskCollection;\nusing ::parthenon::TaskID;\nusing ::parthenon::TaskList;\nusing ::parthenon::TaskListStatus;\nusing ::parthenon::TaskQualifier;\nusing ::parthenon::TaskRegion;\nusing ::parthenon::TaskStatus;\nusing ::parthenon::TaskType;\nusing ::parthenon::Uid_t;\nusing ::parthenon::DriverUtils::ConstructAndExecuteBlockTasks;\nusing ::parthenon::DriverUtils::ConstructAndExecuteTaskLists;\n\nnamespace partition {\nusing ::parthenon::partition::Partition_t;\nusing ::parthenon::partition::ToNPartitions;\nusing ::parthenon::partition::ToSizeN;\n}\n}\n}\n}\n\n#endif\n\n'parthenon/example/particle_tracers/particle_tracers.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef EXAMPLE_PARTICLE_TRACERS_PARTICLE_TRACERS_HPP_\n#define EXAMPLE_PARTICLE_TRACERS_PARTICLE_TRACERS_HPP_\n\n#include <memory>\n\n#include \"Kokkos_Random.hpp\"\n\n#include <parthenon/driver.hpp>\n#include <parthenon/package.hpp>\n\nusing namespace parthenon::driver::prelude;\nusing namespace parthenon::package::prelude;\nusing namespace parthenon;\n\nnamespace tracers_example {\n\nclass ParticleDriver : public MultiStageDriver {\n public:\n  ParticleDriver(ParameterInput *pin, ApplicationInput *app_in, Mesh *pm)\n      : MultiStageDriver(pin, app_in, pm) {}\n  TaskCollection MakeTaskCollection(BlockList_t &blocks, int stage);\n};\n\nvoid ProblemGenerator(MeshBlock *pmb, ParameterInput *pin);\nPackages_t ProcessPackages(std::unique_ptr<ParameterInput> &pin);\n\nnamespace particles_package {\n\nstd::shared_ptr<StateDescriptor> Initialize(ParameterInput *pin);\nReal EstimateTimestepBlock(MeshBlockData<Real> *rc);\n\n}\n\nnamespace advection_package {\n\nstd::shared_ptr<StateDescriptor> Initialize(ParameterInput *pin);\nReal EstimateTimestepBlock(MeshBlockData<Real> *rc);\n\n}\n\n}\n\n#endif\n\n'parthenon/src/utils/concepts_lite.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n#ifndef UTILS_CONCEPTS_LITE_HPP_\n#define UTILS_CONCEPTS_LITE_HPP_\n\n#include <type_traits>\n#include <utility>\n\n\n\n\n\ntemplate <class...>\nconstexpr std::false_type always_false{};\n\n\n\n\n\n#define REQUIRES(...) typename std::enable_if<(__VA_ARGS__), int>::type = 0\n#define ENABLEIF(...) typename std::enable_if<(__VA_ARGS__), int>::type\nusing TYPE_OF_SUCCESSFUL_REQUIRES = int;\n\n\n\ntemplate <class SPECIAL, template <class...> class TEMPL>\nstruct is_specialization_of : public std::false_type {};\n\ntemplate <template <class...> class TEMPL, class... TPARAMS>\nstruct is_specialization_of<TEMPL<TPARAMS...>, TEMPL> : public std::true_type {};\n\n\n\n\n\n\n\n\ntemplate <class... Ts>\nusing void_t = void;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntemplate <class T, class = void>\nstruct implements : std::false_type {};\n\n\n\ntemplate <class T, class = void>\nstruct all_implement : std::false_type {};\n\n\n\n\n\n\n\n\n\ntemplate <class Concept, class... Ts>\nstruct implements<Concept(Ts...), void_t<decltype(std::declval<Concept>().requires_(\n                                      std::declval<Ts>()...))>> : std::true_type {};\n\ntemplate <class Concept, class... Ts>\nstruct all_implement<Concept(Ts...), void_t<decltype(std::declval<Concept>().requires_(\n                                         std::declval<Ts>()))...>> : std::true_type {};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntemplate <class T, class = void>\nstruct is_fundamental_c_array : std::false_type {};\ntemplate <class T, std::size_t N>\nstruct is_fundamental_c_array<T[N], void_t<ENABLEIF(std::is_fundamental<T>::value)>>\n    : std::true_type {};\n\n\n\nstruct container {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  template <class T>\n  auto requires_(T &&x) -> void_t<decltype(x.size()), typename T::value_type>;\n};\n\n\n\n\nstruct contiguous_container {\n  template <class T>\n  auto requires_(T &&x)\n      -> void_t<decltype(x.size()), decltype(x.data()), typename T::value_type>;\n\n\n\n\n\n\n  template <class T, REQUIRES(implements<contiguous_container(T)>::value)>\n  static std::size_t size(const T &x) {\n    return x.size();\n  }\n\n  template <class T,\n            REQUIRES(!implements<container(T)>::value && std::is_fundamental<T>::value)>\n  static std::size_t size(const T &x) {\n    return 1;\n  }\n\n  template <class T, std::size_t N, REQUIRES(is_fundamental_c_array<T[N]>::value)>\n  static std::size_t size(const T (&)[N]) {\n    return N;\n  }\n\n  template <class T, REQUIRES(implements<contiguous_container(T)>::value)>\n  static typename T::value_type *data(T &x) {\n    return x.data();\n  }\n\n  template <class T,\n            REQUIRES(!implements<container(T)>::value && std::is_fundamental<T>::value)>\n  static T *data(T &x) {\n    return &x;\n  }\n\n  template <class T, std::size_t N, REQUIRES(is_fundamental_c_array<T[N]>::value)>\n  static T *data(T (&x)[N]) {\n    return x;\n  }\n\n  template <class T, REQUIRES(implements<contiguous_container(T)>::value)>\n  static typename T::value_type value_type(T &);\n\n  template <class T,\n            REQUIRES(!implements<container(T)>::value && std::is_fundamental<T>::value)>\n  static T value_type(T &);\n\n  template <class T, std::size_t N, REQUIRES(is_fundamental_c_array<T[N]>::value)>\n  static T value_type(T (&)[N]);\n};\n\nstruct integral {\n  template <class T>\n  auto requires_(T) -> void_t<ENABLEIF(std::is_integral<T>::value)>;\n};\n\nstruct integral_or_enum {\n  template <class T>\n  auto requires_(T)\n      -> void_t<ENABLEIF(std::is_integral<T>::value || std::is_enum<T>::value)>;\n};\n\nstruct scalar {\n  template <class T>\n  auto requires_(T) -> void_t<ENABLEIF(std::is_scalar<T>::value)>;\n};\n\ntemplate <typename>\nstruct is_pair : std::false_type {};\n\ntemplate <typename T, typename U>\nstruct is_pair<std::pair<T, U>> : std::true_type {};\n\nstruct integral_or_enum_or_pair {\n  template <class T>\n  auto requires_(T) -> void_t<ENABLEIF(std::is_integral<T>::value ||\n                                       std::is_enum<T>::value || is_pair<T>::value)>;\n};\n\nstruct kokkos_view {\n  template <class T>\n  auto requires_(T x) -> void_t<ENABLEIF(implements<contiguous_container(T)>::value),\n                                typename T::HostMirror, typename T::execution_space,\n                                typename T::memory_space, typename T::device_type,\n                                typename T::memory_traits, typename T::host_mirror_space>;\n};\n\n\n\n\n\n\ntemplate <int... IN>\nstruct multiply;\n\ntemplate <>\nstruct multiply<> : std::integral_constant<std::size_t, 1> {};\n\ntemplate <int I0, int... IN>\nstruct multiply<I0, IN...> : std::integral_constant<int, I0 * multiply<IN...>::value> {};\n\n\n\ntemplate <class T, class... Ts>\nstruct GetTypeIdx;\n\ntemplate <class T, class... Ts>\nstruct GetTypeIdx<T, T, Ts...> : std::integral_constant<std::size_t, 0> {};\n\ntemplate <class T, class U, class... Ts>\nstruct GetTypeIdx<T, U, Ts...>\n    : std::integral_constant<std::size_t, 1 + GetTypeIdx<T, Ts...>::value> {};\n\n\ntemplate <class T, class... Ts>\nstruct IncludesType;\n\ntemplate <class T>\nstruct IncludesType<T, T> : std::true_type {};\n\ntemplate <class T, class... Ts>\nstruct IncludesType<T, T, Ts...> : std::true_type {};\n\ntemplate <class T, class U>\nstruct IncludesType<T, U> : std::false_type {};\n\ntemplate <class T, class U, class... Ts>\nstruct IncludesType<T, U, Ts...> : IncludesType<T, Ts...> {};\n\ntemplate <class T, class = void>\nstruct UnderlyingType {\n  using type = T;\n};\n\ntemplate <class T>\nstruct UnderlyingType<T, void_t<ENABLEIF(std::is_enum<T>::value)>>\n    : std::underlying_type<T> {};\n\n#endif\n\n'parthenon/src/utils/reductions.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n#ifndef UTILS_REDUCTIONS_HPP_\n#define UTILS_REDUCTIONS_HPP_\n\n#include <memory>\n#include <vector>\n\n#include <config.hpp>\n#include <globals.hpp>\n#include <kokkos_abstraction.hpp>\n#include <parthenon_mpi.hpp>\n#include <utils/cleantypes.hpp>\n#include <utils/concepts_lite.hpp>\n#include <utils/error_checking.hpp>\n#include <utils/mpi_types.hpp>\n\nnamespace parthenon {\n\n\n\n\n#ifndef MPI_VERSION\nenum MPI_Op {\n  MPI_MAX,\n  MPI_MIN,\n  MPI_SUM,\n  MPI_PROD,\n  MPI_LAND,\n  MPI_BAND,\n  MPI_LOR,\n  MPI_BOR,\n  MPI_LXOR,\n  MPI_BXOR,\n  MPI_MAXLOC,\n  MPI_MINLOC\n};\n#endif\n\n#ifdef MPI_PARALLEL\ntemplate <class U>\nMPI_Datatype GetContainerMPIType(const U &v) {\n  using value_type = decltype(contiguous_container::value_type(v));\n  return MPITypeMap<value_type>::type();\n}\n#endif\n\ntemplate <typename T>\nstruct ReductionBase {\n  T val;\n#ifdef MPI_PARALLEL\n  MPI_Request req;\n  std::shared_ptr<MPI_Comm> pcomm;\n#endif\n  bool active = false;\n  ReductionBase() {\n#ifdef MPI_PARALLEL\n\n\n\n    pcomm = std::shared_ptr<MPI_Comm>(new MPI_Comm, MPI_Comm_disconnect);\n    PARTHENON_MPI_CHECK(MPI_Comm_dup(MPI_COMM_WORLD, pcomm.get()));\n#endif\n  }\n\n  TaskStatus CheckReduce() {\n    if (!active) return TaskStatus::complete;\n    int check = 1;\n#ifdef MPI_PARALLEL\n    PARTHENON_MPI_CHECK(MPI_Test(&req, &check, MPI_STATUS_IGNORE));\n#endif\n    if (check) {\n      active = false;\n      return TaskStatus::complete;\n    }\n    return TaskStatus::incomplete;\n  }\n};\n\ntemplate <typename T>\nstruct AllReduce : public ReductionBase<T> {\n  TaskStatus StartReduce(MPI_Op op) {\n    if (this->active) return TaskStatus::complete;\n#ifdef MPI_PARALLEL\n    PARTHENON_MPI_CHECK(\n        MPI_Iallreduce(MPI_IN_PLACE, contiguous_container::data(this->val),\n                       contiguous_container::size(this->val),\n                       GetContainerMPIType(this->val), op, *(this->pcomm), &(this->req)));\n#endif\n    this->active = true;\n    return TaskStatus::complete;\n  }\n};\n\ntemplate <typename T>\nstruct Reduce : public ReductionBase<T> {\n  TaskStatus StartReduce(const int n, MPI_Op op) {\n    if (this->active) return TaskStatus::complete;\n#ifdef MPI_PARALLEL\n    if (Globals::my_rank == n) {\n      PARTHENON_MPI_CHECK(MPI_Ireduce(MPI_IN_PLACE, contiguous_container::data(this->val),\n                                      contiguous_container::size(this->val),\n                                      GetContainerMPIType(this->val), op, n,\n                                      *(this->pcomm), &(this->req)));\n\n    } else {\n      PARTHENON_MPI_CHECK(MPI_Ireduce(contiguous_container::data(this->val), nullptr,\n                                      contiguous_container::size(this->val),\n                                      GetContainerMPIType(this->val), op, n,\n                                      *(this->pcomm), &(this->req)));\n    }\n#endif\n    this->active = true;\n    return TaskStatus::complete;\n  }\n};\n\n}\n\n#endif\n",
        "gt": [
            "'parthenon/src/utils/concepts_lite.hpp'",
            "'parthenon/src/utils/reductions.hpp'",
            "'parthenon/src/parthenon/driver.hpp'",
            "'parthenon/example/particle_tracers/particle_tracers.hpp'",
            "'parthenon/example/particle_tracers/main.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CryptoManager.cpp'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CryptoOpenSSLNONE.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CertificateEnums.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CryptoBase.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/PublicKey.h'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackCore/Certificate/CryptoManager.cpp'\n:\n\n#include \"OpcUaStackCore/Certificate/CryptoManager.h\"\n#include \"OpcUaStackCore/Certificate/CryptoOpenSSLNONE.h\"\n#include \"OpcUaStackCore/Certificate/CryptoOpenSSLBASIC256SHA256.h\"\n#include \"OpcUaStackCore/Certificate/CryptoOpenSSLBASIC256.h\"\n#include \"OpcUaStackCore/Certificate/CryptoOpenSSLBASIC128RSA15.h\"\n\n\nnamespace OpcUaStackCore\n{\n\n\tCryptoManager::CryptoManager(void)\n\t: cryptoBaseMap_()\n\t{\n\n\t\tCryptoOpenSSLNONE::SPtr cryptoOpenSSLNone(constructSPtr<CryptoOpenSSLNONE>());\n\t\tinsert(cryptoOpenSSLNone->securityPolicy(), cryptoOpenSSLNone);\n\n\n\t\tCryptoOpenSSLBASIC256SHA256::SPtr cryptoOpenSSLBASIC256SHA256(constructSPtr<CryptoOpenSSLBASIC256SHA256>());\n\t\tinsert(cryptoOpenSSLBASIC256SHA256->securityPolicy(), cryptoOpenSSLBASIC256SHA256);\n\n\n\t\tCryptoOpenSSLBASIC256::SPtr cryptoOpenSSLBASIC256(constructSPtr<CryptoOpenSSLBASIC256>());\n\t\tinsert(cryptoOpenSSLBASIC256->securityPolicy(), cryptoOpenSSLBASIC256);\n\n\n\t\tCryptoOpenSSLBASIC128RSA15::SPtr cryptoOpenSSLBASIC128RSA15(constructSPtr<CryptoOpenSSLBASIC128RSA15>());\n\t\tinsert(cryptoOpenSSLBASIC128RSA15->securityPolicy(), cryptoOpenSSLBASIC128RSA15);\n\n\t}\n\n\tCryptoManager::~CryptoManager(void)\n\t{\n\t}\n\n\tbool\n\tCryptoManager::insert(const std::string& name, CryptoBase::SPtr& cryptoBase)\n\t{\n\t\treturn cryptoBaseMap_.insert(std::make_pair(name, cryptoBase)).second;\n\t}\n\n\tbool\n\tCryptoManager::remove(const std::string& name)\n\t{\n\t\treturn cryptoBaseMap_.erase(name) == 1;\n\t}\n\n\tCryptoBase::SPtr\n\tCryptoManager::get(const std::string& name)\n\t{\n\t\tCryptoBase::Map::iterator it;\n\t\tit = cryptoBaseMap_.find(name);\n\t\tif (it == cryptoBaseMap_.end()) {\n\t\t\tCryptoBase::SPtr cryptoBase;\n\t\t\treturn cryptoBase;\n\t\t}\n\t\treturn it->second;\n\t}\n\n}\n\n'OpcUaStack/src/OpcUaStackCore/Certificate/CryptoOpenSSLNONE.h'\n:\n\n#ifndef __OpcUaStackCore_CryptoOpenSSLNONE_h__\n#define __OpcUaStackCore_CryptoOpenSSLNONE_h__\n\n#include <OpcUaStackCore/Certificate/CryptoBase.h>\n#include \"OpcUaStackCore/Base/os.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT CryptoOpenSSLNONE\n\t: public CryptoBase\n\t{\n\t  public:\n\t\tCryptoOpenSSLNONE(void);\n\t\tvirtual ~CryptoOpenSSLNONE(void);\n\n\t\tvirtual OpcUaStatusCode getAsymmetricEncryptionBlockSize(\n\t\t\tPublicKey& publicKey,\n\t\t\tuint32_t* plainTextBlockSize,\n\t\t\tuint32_t* cryptTextBlockSize\n\t\t);\n\n\t\tvirtual OpcUaStatusCode getAsymmetricSignatureBlockSize(\n\t\t\tPublicKey& publicKey,\n\t\t\tuint32_t* signTextBlockSize\n\t\t);\n\n\t\tvirtual OpcUaStatusCode getSymmetricEncryptionBlockSize(\n\t\t\tuint32_t* plainTextBlockSize,\n\t\t\tuint32_t* cryptTextBlockSize\n\t\t);\n\n\t\tvirtual OpcUaStatusCode getSymmetricSignatureBlockSize(\n\t\t\tuint32_t* signTextBlockSize\n\t\t);\n\n\t\tvirtual OpcUaStatusCode asymmetricKeyLen(\n\t\t\tPublicKey& publicKey,\n\t\t\tuint32_t* asymmetricKeyLen\n\t\t);\n\n\t\tvirtual OpcUaStatusCode asymmetricKeyLen(\n\t\t\tPrivateKey& privateKey,\n\t\t\tuint32_t* asymmetricKeyLen\n\t\t);\n\n\t\tvirtual OpcUaStatusCode asymmetricDecrypt(\n\t\t    char*       \tencryptedTextBuf,\n\t\t\tuint32_t\t\tencryptedTextLen,\n\t\t\tPrivateKey&\t\tprivateKey,\n\t\t\tchar*       \tplainTextBuf,\n\t\t\tuint32_t*\t\tplainTextLen\n\t\t);\n\n\t\tvirtual OpcUaStatusCode asymmetricEncrypt(\n\t\t    char*       \tplainTextBuf,\n\t\t\tuint32_t\t\tplainTextLen,\n\t\t\tPublicKey&\t\tpublicKey,\n\t\t\tchar*       \tencryptedTextBuf,\n\t\t\tuint32_t*\t\tencryptedTextLen\n\t\t);\n\n\t\tvirtual OpcUaStatusCode symmetricDecrypt(\n\t\t\tchar*       \tencryptedTextBuf,\n\t\t\tuint32_t\t\tencryptedTextLen,\n\t\t\tAESKey&\t   \t\taesKey,\n\t\t\tIV&\t\t   \t\tiv,\n\t\t\tchar*      \t\tplainTextBuf,\n\t\t\tuint32_t*   \tplainTextLen\n\t\t);\n\n\t\tvirtual OpcUaStatusCode symmetricEncrypt(\n\t\t\tchar*       \tplainTextBuf,\n\t\t\tuint32_t\t\tplainTextLen,\n\t\t\tAESKey&\t   \t\taesKey,\n\t\t\tIV&\t\t   \t\tiv,\n\t\t\tchar*      \t\tencryptedTextBuf,\n\t\t\tuint32_t*   \tencryptedTextLen\n\t\t);\n\n\t\tvirtual OpcUaStatusCode asymmetricSign(\n\t\t    char*       \tdataTextBuf,\n\t\t\tuint32_t\t\tdataTextLen,\n\t\t\tPrivateKey&\t\tprivateKey,\n\t\t\tchar*       \tsignatureTextBuf,\n\t\t\tuint32_t*\t\tsignatureTextLen\n\t\t);\n\n\t\tvirtual OpcUaStatusCode asymmetricVerify(\n\t\t    char*       \tplainTextBuf,\n\t\t\tuint32_t\t\tplainTextLen,\n\t\t\tPublicKey&\t\tpublicKey,\n\t\t\tchar*       \tsignTextBuf,\n\t\t\tuint32_t\t\tsignTextLen\n\t\t);\n\n\t\tvirtual OpcUaStatusCode symmetricSign(\n\t\t    char*       \tdataTextBuf,\n\t\t\tuint32_t\t\tdataTextLen,\n\t\t\tMemoryBuffer&\tkey,\n\t\t\tchar*       \tsignatureTextBuf,\n\t\t\tuint32_t*\t\tsignatureTextLen\n\t\t);\n\n\t\tvirtual OpcUaStatusCode symmetricVerify(\n\t\t    char*       \tplainTextBuf,\n\t\t\tuint32_t\t\tplainTextLen,\n\t\t\tMemoryBuffer&\tkey,\n\t\t\tchar*       \tsignTextBuf,\n\t\t\tuint32_t\t\tsignTextLen\n\t\t);\n\n\t\tvirtual OpcUaStatusCode deriveKey(\n\t\t\tMemoryBuffer& secret,\n\t\t\tMemoryBuffer& seed,\n\t\t\tMemoryBuffer& key\n\t\t);\n\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/Certificate/CertificateEnums.h'\n:\n\n#ifndef __OpcUaStackCore_CertificateEnums_h__\n#define __OpcUaStackCore_CertificateEnums_h__\n\n#include <openssl/x509.h>\n#include \"OpcUaStackCore/Base/os.h\"\n\nnamespace OpcUaStackCore\n{\n\n\ttypedef enum\n\t{\n\t\tKeyType_RSA        = EVP_PKEY_RSA,\n\t\tKeyType_DSA        = EVP_PKEY_DSA,\n\t\tKeyType_Unknown    = EVP_PKEY_NONE\n\t} KeyType;\n\n\ttypedef enum\n\t{\n\t\tExtension_SubjectAltName            = NID_subject_alt_name,\n\t\tExtension_BasicConstraints          = NID_basic_constraints,\n\t\tExtension_NetscapeComment           = NID_netscape_comment,\n\t\tExtension_SubjectKeyIdentifier      = NID_subject_key_identifier,\n\t\tExtension_AuthorityKeyIdentifier    = NID_authority_key_identifier,\n\t\tExtension_KeyUsage                  = NID_key_usage,\n\t\tExtension_ExtendedKeyUsage          = NID_ext_key_usage\n\t} CertificateExtensionId;\n\n\ttypedef enum\n\t{\n\t\tSignatureAlgorithm_Sha1,\n\t\tSignatureAlgorithm_Sha256\n\t} SignatureAlgorithm;\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/Certificate/CryptoBase.h'\n:\n\n#ifndef __OpcUaStackCore_CryptoBase_h__\n#define __OpcUaStackCore_CryptoBase_h__\n\n#include <boost/shared_ptr.hpp>\n#include <map>\n#include <string>\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaStatusCode.h\"\n#include \"OpcUaStackCore/Certificate/PrivateKey.h\"\n#include \"OpcUaStackCore/Certificate/PublicKey.h\"\n#include \"OpcUaStackCore/Certificate/CryptoAES.h\"\n#include \"OpcUaStackCore/Certificate/SecurityKeySet.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT EnryptionAlgs\n\t{\n\t  public:\n\t\tstatic const uint32_t AES_128_CBC_Id;\n\t\tstatic const uint32_t AES_256_CBC_Id;\n\t\tstatic const uint32_t RSA_PKCS1_V15_Id;\n\t\tstatic const uint32_t RSA_OAEP_Id;\n\t\tstatic const uint32_t DES3_Id;\n\n\t\tstatic std::string AES_128_CBC_Name;\n\t\tstatic std::string AES_256_CBC_Name;\n\t\tstatic std::string RSA_PKCS1_V15_Name;\n\t\tstatic std::string RSA_OAEP_Name;\n\t\tstatic std::string DES3_Name;\n\n\t\tstatic uint32_t uriToEncryptionAlg(const std::string& uri);\n\t\tstatic std::string encryptAlgToUri(uint32_t encryptAlg);\n\t};\n\n\tclass DLLEXPORT SignatureAlgs\n\t{\n\t  public:\n\t\tstatic const uint32_t RSA_PKCS1_V15_SHA1_Id;\n\t\tstatic const uint32_t RSA_PKCS1_V15_SHA256_Id;\n\t\tstatic const uint32_t HMAC_SHA1_Id;\n\t\tstatic const uint32_t HMAC_SHA256_Id;\n\t\tstatic const uint32_t RSA_PKCS1_OAEP_SHA1_Id;\n\t\tstatic const uint32_t RSA_PKCS1_OAEP_SHA256_Id;\n\n\t\tstatic std::string RSA_PKCS1_V15_SHA1_Name;\n\t\tstatic std::string RSA_PKCS1_V15_SHA256_Name;\n\t\tstatic std::string HMAC_SHA1_Name;\n\t\tstatic std::string HMAC_SHA256_Name;\n\t\tstatic std::string RSA_PKCS1_OAEP_SHA1_Name;\n\t\tstatic std::string RSA_PKCS1_OAEP_SHA256_Name;\n\n\t\tstatic uint32_t uriToSignatureAlg(const std::string& uri);\n\t\tstatic std::string signatureAlgToUri(uint32_t signatureAlg);\n\t};\n\n\tclass DLLEXPORT CryptoBase\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<CryptoBase> SPtr;\n\t\ttypedef std::map<std::string, CryptoBase::SPtr> Map;\n\n\t\tCryptoBase(void);\n\t\tvirtual ~CryptoBase(void);\n\n\t\tvoid securityPolicy(const std::string& securityPolicy);\n\t\tstd::string& securityPolicy(void);\n\t\tvoid isLogging(bool isLogging);\n\t\tbool isLogging(void);\n\n\t\tvoid nonceLen(uint32_t nonceLen);\n\t\tuint32_t nonceLen(void);\n\t\tvoid symmetricKeyLen(int32_t symmetricKeyLen);\n\t\tint32_t symmetricKeyLen(void);\n\t\tvoid asymmetricKeyLen(int32_t asymmetricKeyLen);\n\t\tint32_t asymmetricKeyLen(void);\n\t\tvoid minimumAsymmetricKeyLen(uint32_t minimumAsymmetricKeyLen);\n\t\tuint32_t minimumAsymmetricKeyLen(void);\n\t\tvoid maximumAsymmetricKeyLen(uint32_t maximumAsymmetricKeyLen);\n\t\tuint32_t maximumAsymmetricKeyLen(void);\n\t\tvoid derivedEncryptionKeyLen(uint32_t derivedEncryptionKeyLen);\n\t\tuint32_t derivedEncryptionKeyLen(void);\n\t\tvoid derivedSignatureKeyLen(uint32_t derivedSignatureKeyLen);\n\t\tuint32_t derivedSignatureKeyLen(void);\n\t\tvoid signatureDataLen(uint32_t signatureDataLen);\n\t\tuint32_t signatureDataLen(void);\n\t\tvoid asymmetricSignatureAlgorithmId(uint32_t asymmetricSignatureAlgorithmId);\n\t\tuint32_t asymmetricSignatureAlgorithmId(void);\n\t\tvoid asymmetricEncryptionAlgorithmId(uint32_t asymmetricEncryptionAlgorithmId);\n\t\tuint32_t asymmetricEncryptionAlgorithmId(void);\n\t\tvoid symmetricSignatureAlgorithmId(uint32_t symmetricSignatureAlgorithmId);\n\t\tuint32_t symmetricSignatureAlgorithmId(void);\n\t\tvoid symmetricEncryptionAlgorithmId(uint32_t symmetricEncryptionAlgorithmId);\n\t\tuint32_t symmetricEncryptionAlgorithmId(void);\n\n\t\tvirtual OpcUaStatusCode getAsymmetricEncryptionBlockSize(\n\t\t\tPublicKey& publicKey,\n\t\t\tuint32_t* plainTextBlockSize,\n\t\t\tuint32_t* cryptTextBlockSize\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode getAsymmetricSignatureBlockSize(\n\t\t\tPublicKey& publicKey,\n\t\t\tuint32_t* signTextBlockSize\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode getSymmetricEncryptionBlockSize(\n\t\t\tuint32_t* plainTextBlockSize,\n\t\t\tuint32_t* cryptTextBlockSize\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode getSymmetricSignatureBlockSize(\n\t\t\tuint32_t* signTextBlockSize\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode asymmetricKeyLen(\n\t\t\tPublicKey& publicKey,\n\t\t\tuint32_t* asymmetricKeyLen\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode asymmetricKeyLen(\n\t\t\tPrivateKey& privateKey,\n\t\t\tuint32_t* asymmetricKeyLen\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode asymmetricDecrypt(\n\t\t    char*       \tencryptedTextBuf,\n\t\t\tuint32_t\t\tencryptedTextLen,\n\t\t\tPrivateKey&\t\tprivateKey,\n\t\t\tchar*       \tplainTextBuf,\n\t\t\tuint32_t*\t\tplainTextLen\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode asymmetricEncrypt(\n\t\t    char*       \tplainTextBuf,\n\t\t\tuint32_t\t\tplainTextLen,\n\t\t\tPublicKey&\t\tpublicKey,\n\t\t\tchar*       \tencryptedTextBuf,\n\t\t\tuint32_t*\t\tencryptedTextLen\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode symmetricDecrypt(\n\t\t\tchar*       \tencryptedTextBuf,\n\t\t\tuint32_t\t\tencryptedTextLen,\n\t\t\tAESKey&\t   \t\taesKey,\n\t\t\tIV&\t\t   \t\tiv,\n\t\t\tchar*      \t\tplainTextBuf,\n\t\t\tuint32_t*   \tplainTextLen\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode symmetricEncrypt(\n\t\t\tchar*       \tplainTextBuf,\n\t\t\tuint32_t\t\tplainTextLen,\n\t\t\tAESKey&\t   \t\taesKey,\n\t\t\tIV&\t\t   \t\tiv,\n\t\t\tchar*      \t\tencryptedTextBuf,\n\t\t\tuint32_t*   \tencryptedTextLen\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode asymmetricSign(\n\t\t    char*       \tplainTextBuf,\n\t\t\tuint32_t\t\tplainTextLen,\n\t\t\tPrivateKey&\t\tprivateKey,\n\t\t\tchar*       \tsignTextBuf,\n\t\t\tuint32_t*\t\tsignTextLen\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode asymmetricVerify(\n\t\t    char*       \tplainTextBuf,\n\t\t\tuint32_t\t\tplainTextLen,\n\t\t\tPublicKey&\t\tpublicKey,\n\t\t\tchar*       \tsignTextBuf,\n\t\t\tuint32_t\t\tsignTextLen\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode symmetricSign(\n\t\t    char*       \tplainTextBuf,\n\t\t\tuint32_t\t\tplainTextLen,\n\t\t\tMemoryBuffer&\tkey,\n\t\t\tchar*       \tsignTextBuf,\n\t\t\tuint32_t*\t\tsignTextLen\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode symmetricVerify(\n\t\t    char*       \tplainTextBuf,\n\t\t\tuint32_t\t\tplainTextLen,\n\t\t\tMemoryBuffer&\tkey,\n\t\t\tchar*       \tsignTextBuf,\n\t\t\tuint32_t\t\tsignTextLen\n\t\t) = 0;\n\n\t\tvirtual OpcUaStatusCode deriveKey(\n\t\t\tMemoryBuffer& secret,\n\t\t\tMemoryBuffer& seed,\n\t\t\tMemoryBuffer& key\n\t\t) = 0;\n\n\t\tOpcUaStatusCode deriveChannelKeyset(\n\t\t    MemoryBuffer& clientNonce,\n\t\t\tMemoryBuffer& serverNonce,\n\t\t    SecurityKeySet& clientSecurityKeySet,\n\t\t    SecurityKeySet& serverSecurityKeySet\n\t\t);\n\n\t\tOpcUaStatusCode deriveChannelKeyset(\n\t\t    MemoryBuffer& remoteNonce,\n\t\t\tMemoryBuffer& localNonce,\n\t\t    SecurityKeySet& securityKeySet\n\t\t);\n\n\t  private:\n\t\tstd::string securityPolicy_;\n\t\tbool isLogging_;\n\n\t\tuint32_t nonceLen_;\n\t\tint32_t symmetricKeyLen_;\n\t\tint32_t asymmetricKeyLen_;\n\t\tuint32_t minimumAsymmetricKeyLen_;\n\t\tuint32_t maximumAsymmetricKeyLen_;\n\t\tuint32_t derivedEncryptionKeyLen_;\n\t\tuint32_t derivedSignatureKeyLen_;\n\t\tuint32_t signatureDataLen_;\n\t\tuint32_t asymmetricSignatureAlgorithmId_;\n\t\tuint32_t asymmetricEncryptionAlgorithmId_;\n\t\tuint32_t symmetricSignatureAlgorithmId_;\n\t\tuint32_t symmetricEncryptionAlgorithmId_;\n\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/Certificate/PublicKey.h'\n:\n\n#ifndef __OpcUaStackCore_PublicKey_h__\n#define __OpcUaStackCore_PublicKey_h__\n\n#include <openssl/x509.h>\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Certificate/OpenSSLError.h\"\n#include \"OpcUaStackCore/Certificate/CertificateEnums.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT PublicKey\n\t: public OpenSSLError\n\t{\n\t  public:\n\t\tPublicKey(void);\n\t\tPublicKey(EVP_PKEY *pKey);\n\t\tPublicKey(const PublicKey& copy);\n\t\tvirtual ~PublicKey(void);\n\n\t\tPublicKey& operator=(const PublicKey& copy);\n\t\toperator EVP_PKEY*(void);\n\t\tuint32_t keySizeInBytes(void) const;\n\t\tuint32_t keySize(void) const;\n\t\tKeyType keyType(void) const;\n\n\t\tbool fromDER(const char* buf, uint32_t bufLen);\n\t\tbool toDER(char* buf, uint32_t& bufLen);\n\n\t  private:\n\t\tX509_PUBKEY *publicKey_;\n\t};\n\n}\n\n#endif\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CertificateEnums.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/PublicKey.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CryptoBase.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CryptoOpenSSLNONE.h'",
            "'OpcUaStack/src/OpcUaStackCore/Certificate/CryptoManager.cpp'"
        ]
    },
    {
        "files": [
            "'elaphureLink/thirdparty/asio/include/asio/ssl/context.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/ssl/detail/verify_callback.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/ssl/verify_context.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/ssl.hpp'"
        ],
        "content": "'elaphureLink/thirdparty/asio/include/asio/ssl/context.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_SSL_CONTEXT_HPP\n#define ASIO_SSL_CONTEXT_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n\n#include <string>\n#include \"asio/buffer.hpp\"\n#include \"asio/io_context.hpp\"\n#include \"asio/ssl/context_base.hpp\"\n#include \"asio/ssl/detail/openssl_types.hpp\"\n#include \"asio/ssl/detail/openssl_init.hpp\"\n#include \"asio/ssl/detail/password_callback.hpp\"\n#include \"asio/ssl/detail/verify_callback.hpp\"\n#include \"asio/ssl/verify_mode.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace ssl {\n\nclass context\n  : public context_base,\n    private noncopyable\n{\npublic:\n\n  typedef SSL_CTX* native_handle_type;\n\n\n  ASIO_DECL explicit context(method m);\n\n\n  ASIO_DECL explicit context(native_handle_type native_handle);\n\n#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)\n\n\n  ASIO_DECL context(context&& other);\n\n\n\n  ASIO_DECL context& operator=(context&& other);\n#endif\n\n\n  ASIO_DECL ~context();\n\n\n\n  ASIO_DECL native_handle_type native_handle();\n\n\n\n  ASIO_DECL void clear_options(options o);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID clear_options(options o,\n      asio::error_code& ec);\n\n\n\n  ASIO_DECL void set_options(options o);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID set_options(options o,\n      asio::error_code& ec);\n\n\n\n  ASIO_DECL void set_verify_mode(verify_mode v);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID set_verify_mode(\n      verify_mode v, asio::error_code& ec);\n\n\n\n  ASIO_DECL void set_verify_depth(int depth);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID set_verify_depth(\n      int depth, asio::error_code& ec);\n\n\n\n  template <typename VerifyCallback>\n  void set_verify_callback(VerifyCallback callback);\n\n\n\n  template <typename VerifyCallback>\n  ASIO_SYNC_OP_VOID set_verify_callback(VerifyCallback callback,\n      asio::error_code& ec);\n\n\n\n  ASIO_DECL void load_verify_file(const std::string& filename);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID load_verify_file(\n      const std::string& filename, asio::error_code& ec);\n\n\n\n  ASIO_DECL void add_certificate_authority(const const_buffer& ca);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID add_certificate_authority(\n      const const_buffer& ca, asio::error_code& ec);\n\n\n\n\n  ASIO_DECL void set_default_verify_paths();\n\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID set_default_verify_paths(\n      asio::error_code& ec);\n\n\n\n\n  ASIO_DECL void add_verify_path(const std::string& path);\n\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID add_verify_path(\n      const std::string& path, asio::error_code& ec);\n\n\n\n  ASIO_DECL void use_certificate(\n      const const_buffer& certificate, file_format format);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID use_certificate(\n      const const_buffer& certificate, file_format format,\n      asio::error_code& ec);\n\n\n\n  ASIO_DECL void use_certificate_file(\n      const std::string& filename, file_format format);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID use_certificate_file(\n      const std::string& filename, file_format format,\n      asio::error_code& ec);\n\n\n\n  ASIO_DECL void use_certificate_chain(const const_buffer& chain);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID use_certificate_chain(\n      const const_buffer& chain, asio::error_code& ec);\n\n\n\n  ASIO_DECL void use_certificate_chain_file(const std::string& filename);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID use_certificate_chain_file(\n      const std::string& filename, asio::error_code& ec);\n\n\n\n  ASIO_DECL void use_private_key(\n      const const_buffer& private_key, file_format format);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID use_private_key(\n      const const_buffer& private_key, file_format format,\n      asio::error_code& ec);\n\n\n\n  ASIO_DECL void use_private_key_file(\n      const std::string& filename, file_format format);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID use_private_key_file(\n      const std::string& filename, file_format format,\n      asio::error_code& ec);\n\n\n\n  ASIO_DECL void use_rsa_private_key(\n      const const_buffer& private_key, file_format format);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID use_rsa_private_key(\n      const const_buffer& private_key, file_format format,\n      asio::error_code& ec);\n\n\n\n  ASIO_DECL void use_rsa_private_key_file(\n      const std::string& filename, file_format format);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID use_rsa_private_key_file(\n      const std::string& filename, file_format format,\n      asio::error_code& ec);\n\n\n\n\n  ASIO_DECL void use_tmp_dh(const const_buffer& dh);\n\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID use_tmp_dh(\n      const const_buffer& dh, asio::error_code& ec);\n\n\n\n  ASIO_DECL void use_tmp_dh_file(const std::string& filename);\n\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID use_tmp_dh_file(\n      const std::string& filename, asio::error_code& ec);\n\n\n\n  template <typename PasswordCallback>\n  void set_password_callback(PasswordCallback callback);\n\n\n\n  template <typename PasswordCallback>\n  ASIO_SYNC_OP_VOID set_password_callback(PasswordCallback callback,\n      asio::error_code& ec);\n\nprivate:\n  struct bio_cleanup;\n  struct x509_cleanup;\n  struct evp_pkey_cleanup;\n  struct rsa_cleanup;\n  struct dh_cleanup;\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID do_set_verify_callback(\n      detail::verify_callback_base* callback, asio::error_code& ec);\n\n\n  ASIO_DECL static int verify_callback_function(\n      int preverified, X509_STORE_CTX* ctx);\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID do_set_password_callback(\n      detail::password_callback_base* callback, asio::error_code& ec);\n\n\n  ASIO_DECL static int password_callback_function(\n      char* buf, int size, int purpose, void* data);\n\n\n  ASIO_DECL ASIO_SYNC_OP_VOID do_use_tmp_dh(\n      BIO* bio, asio::error_code& ec);\n\n\n  ASIO_DECL BIO* make_buffer_bio(const const_buffer& b);\n\n\n  ASIO_DECL static asio::error_code translate_error(long error);\n\n\n  native_handle_type handle_;\n\n\n  asio::ssl::detail::openssl_init<> init_;\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#include \"asio/ssl/impl/context.hpp\"\n#if defined(ASIO_HEADER_ONLY)\n# include \"asio/ssl/impl/context.ipp\"\n#endif\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/ssl/detail/verify_callback.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_SSL_DETAIL_VERIFY_CALLBACK_HPP\n#define ASIO_SSL_DETAIL_VERIFY_CALLBACK_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n\n#include \"asio/ssl/verify_context.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace ssl {\nnamespace detail {\n\nclass verify_callback_base\n{\npublic:\n  virtual ~verify_callback_base()\n  {\n  }\n\n  virtual bool call(bool preverified, verify_context& ctx) = 0;\n};\n\ntemplate <typename VerifyCallback>\nclass verify_callback : public verify_callback_base\n{\npublic:\n  explicit verify_callback(VerifyCallback callback)\n    : callback_(callback)\n  {\n  }\n\n  virtual bool call(bool preverified, verify_context& ctx)\n  {\n    return callback_(preverified, ctx);\n  }\n\nprivate:\n  VerifyCallback callback_;\n};\n\n}\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/ssl/verify_context.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_SSL_VERIFY_CONTEXT_HPP\n#define ASIO_SSL_VERIFY_CONTEXT_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n\n#include \"asio/detail/noncopyable.hpp\"\n#include \"asio/ssl/detail/openssl_types.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace ssl {\n\n\n\n\nclass verify_context\n  : private noncopyable\n{\npublic:\n\n  typedef X509_STORE_CTX* native_handle_type;\n\n\n  explicit verify_context(native_handle_type handle)\n    : handle_(handle)\n  {\n  }\n\n\n\n  native_handle_type native_handle()\n  {\n    return handle_;\n  }\n\nprivate:\n\n  native_handle_type handle_;\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/ssl.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_SSL_HPP\n#define ASIO_SSL_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/ssl/context.hpp\"\n#include \"asio/ssl/context_base.hpp\"\n#include \"asio/ssl/error.hpp\"\n#include \"asio/ssl/rfc2818_verification.hpp\"\n#include \"asio/ssl/host_name_verification.hpp\"\n#include \"asio/ssl/stream.hpp\"\n#include \"asio/ssl/stream_base.hpp\"\n#include \"asio/ssl/verify_context.hpp\"\n#include \"asio/ssl/verify_mode.hpp\"\n\n#endif\n",
        "gt": [
            "'elaphureLink/thirdparty/asio/include/asio/ssl/verify_context.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/ssl/detail/verify_callback.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/ssl/context.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/ssl.hpp'"
        ]
    },
    {
        "files": [
            "'knowrob/include/knowrob/terms/groundable.h'",
            "'knowrob/include/knowrob/semweb/GraphUnion.h'",
            "'knowrob/src/semweb/GraphTerm.cpp'",
            "'knowrob/include/knowrob/semweb/TriplePattern.h'"
        ],
        "content": "'knowrob/include/knowrob/terms/groundable.h'\n:\n\n#ifndef KNOWROB_GROUNDABLE_H\n#define KNOWROB_GROUNDABLE_H\n\n#include <memory>\n#include <sstream>\n#include \"Variable.h\"\n#include \"knowrob/Logger.h\"\n\nnamespace knowrob {\n\n\ttemplate<class TermType> class groundable {\n\tpublic:\n\t\tgroundable() = default;\n\n\n\t\texplicit groundable(const std::shared_ptr<TermType> &grounded) : grounded_(grounded) {}\n\n\n\t\texplicit groundable(const std::shared_ptr<Variable> &variable) : variable_(variable) {}\n\n\n\t\tTermPtr operator*() const { return get(); }\n\n\n\t\tTermPtr operator()() const { return get(); }\n\n\n\t\tTerm* operator->() const { return get().get(); }\n\n\n\t\tgroundable& operator=(const std::shared_ptr<TermType> &grounded) { set_grounded(grounded); return *this; }\n\n\n\t\tgroundable& operator=(const std::shared_ptr<Variable> &variable) { set_variable(variable); return *this;  }\n\n\n\t\texplicit operator bool() const { return has_grounding() || has_variable(); }\n\n\n\t\tTermPtr get() const {\n\t\t\tif (has_grounding()) {\n\t\t\t\treturn grounded();\n\t\t\t} else {\n\t\t\t\treturn variable();\n\t\t\t}\n\t\t}\n\n\n\t\tvoid set_grounded(const std::shared_ptr<TermType> &grounded) { grounded_ = grounded; variable_ = nullptr; }\n\n\n\t\tvoid set_variable(const std::shared_ptr<Variable> &variable) { grounded_ = nullptr; variable_ = variable; }\n\n\n\t\tbool has_grounding() const { return grounded_ != nullptr; }\n\n\n\t\tbool has_variable() const { return !has_grounding() && variable_ != nullptr; }\n\n\n\t\tauto grounded() const { return grounded_; }\n\n\n\t\tauto variable() const { return variable_; }\n\n\n\t\tstatic groundable<TermType> cast(const TermPtr &term) {\n\t\t\tif (term->isVariable()) {\n\t\t\t\treturn groundable<TermType>(std::static_pointer_cast<Variable>(term));\n\t\t\t}\n\t\t\tif (auto grounded = std::dynamic_pointer_cast<TermType>(term)) {\n\t\t\t\treturn groundable<TermType>(grounded);\n\t\t\t} else {\n\t\t\t\tKB_WARN(\"Cannot cast term `{}` to type `{}`.\", *term, typeid(TermType).name());\n\t\t\t\treturn groundable<TermType>();\n\t\t\t}\n\t\t}\n\n\tprotected:\n\t\tstd::shared_ptr<TermType> grounded_;\n\t\tstd::shared_ptr<Variable> variable_;\n\t};\n\n}\n\n#endif\n\n'knowrob/include/knowrob/semweb/GraphUnion.h'\n:\n\n#ifndef KNOWROB_GRAPH_UNION_H\n#define KNOWROB_GRAPH_UNION_H\n\n#include \"knowrob/semweb/GraphConnective.h\"\n#include \"knowrob/semweb/TriplePattern.h\"\n\nnamespace knowrob {\n\n\tclass GraphUnion : public GraphConnective {\n\tpublic:\n\t\tGraphUnion() : GraphConnective(GraphTermType::Union) {}\n\n\t\texplicit GraphUnion(const std::vector<std::shared_ptr<GraphTerm>> &terms)\n\t\t\t\t: GraphConnective(GraphTermType::Union, terms) {}\n\n\t\tvoid write(std::ostream &os) const override;\n\t};\n}\n\n#endif\n\n'knowrob/src/semweb/GraphTerm.cpp'\n:\n\n#include <boost/python/suite/indexing/vector_indexing_suite.hpp>\n#include \"knowrob/semweb/GraphTerm.h\"\n#include \"knowrob/integration/python/utils.h\"\n#include \"knowrob/semweb/GraphSequence.h\"\n#include \"knowrob/semweb/GraphUnion.h\"\n#include \"knowrob/semweb/GraphPattern.h\"\n#include \"knowrob/integration/python/converter/vector.h\"\n#include \"knowrob/semweb/GraphBuiltin.h\"\n\nusing namespace knowrob;\n\nnamespace knowrob {\n\tstd::shared_ptr<GraphTerm> applyBindings(const std::shared_ptr<GraphTerm> &term, const Bindings &bindings) {\n\t\tswitch (term->termType()) {\n\t\t\tcase GraphTermType::Pattern: {\n\t\t\t\tauto pattern = std::static_pointer_cast<GraphPattern>(term);\n\t\t\t\tauto orig = pattern->value();\n\t\t\t\tauto substituted = applyBindings(orig, bindings);\n\t\t\t\tif (orig != substituted) {\n\t\t\t\t\treturn std::make_shared<GraphPattern>(substituted);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase GraphTermType::Builtin: {\n\t\t\t\tauto builtin = std::static_pointer_cast<GraphBuiltin>(term);\n\t\t\t\tauto args = builtin->arguments();\n\t\t\t\tstd::vector<TermPtr> newArgs;\n\t\t\t\tfor (const auto &arg: args) {\n\t\t\t\t\tnewArgs.push_back(applyBindings(arg, bindings));\n\t\t\t\t}\n\t\t\t\treturn std::make_shared<GraphBuiltin>(builtin->builtinType(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  builtin->functor(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newArgs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  builtin->bindVar());\n\t\t\t}\n\t\t\tcase GraphTermType::Sequence: {\n\t\t\t\tauto sequence = std::static_pointer_cast<GraphSequence>(term);\n\t\t\t\tstd::vector<std::shared_ptr<GraphTerm>> newTerms;\n\t\t\t\tfor (const auto &subTerm: sequence->terms()) {\n\t\t\t\t\tnewTerms.push_back(applyBindings(subTerm, bindings));\n\t\t\t\t}\n\t\t\t\treturn std::make_shared<GraphSequence>(newTerms);\n\t\t\t}\n\t\t\tcase GraphTermType::Union: {\n\t\t\t\tauto unionTerm = std::static_pointer_cast<GraphUnion>(term);\n\t\t\t\tstd::vector<std::shared_ptr<GraphTerm>> newTerms;\n\t\t\t\tfor (const auto &subTerm: unionTerm->terms()) {\n\t\t\t\t\tnewTerms.push_back(applyBindings(subTerm, bindings));\n\t\t\t\t}\n\t\t\t\treturn std::make_shared<GraphUnion>(newTerms);\n\t\t\t}\n\t\t}\n\t\treturn term;\n\t}\n\n\tstd::shared_ptr<GraphTerm> operator&(const std::shared_ptr<GraphTerm> &a, const std::shared_ptr<GraphTerm> &b) {\n\t\tif (a->termType() == GraphTermType::Sequence) {\n\t\t\tauto sequence = std::static_pointer_cast<GraphSequence>(a);\n\t\t\tauto terms = sequence->terms();\n\t\t\tterms.push_back(b);\n\t\t\treturn std::make_shared<GraphSequence>(terms);\n\t\t} else {\n\t\t\treturn std::make_shared<GraphSequence>(std::vector<std::shared_ptr<GraphTerm>>{a, b});\n\t\t}\n\t}\n\n\tstd::shared_ptr<GraphTerm> operator|(const std::shared_ptr<GraphTerm> &a, const std::shared_ptr<GraphTerm> &b) {\n\t\tif (a->termType() == GraphTermType::Union) {\n\t\t\tauto unionTerm = std::static_pointer_cast<GraphUnion>(a);\n\t\t\tauto terms = unionTerm->terms();\n\t\t\tterms.push_back(b);\n\t\t\treturn std::make_shared<GraphUnion>(terms);\n\t\t} else {\n\t\t\treturn std::make_shared<GraphUnion>(std::vector<std::shared_ptr<GraphTerm>>{a, b});\n\t\t}\n\t}\n}\n\nnamespace knowrob::py {\n\tstd::shared_ptr<GraphTerm> applyBindings_graph(const std::shared_ptr<GraphTerm> &term, const Bindings &bindings) {\n\t\treturn applyBindings(term, bindings);\n\t}\n\n\ttemplate<>\n\tvoid createType<GraphTerm>() {\n\t\tusing namespace boost::python;\n\n\t\tenum_<GraphTermType>(\"GraphTermType\")\n\t\t\t\t.value(\"Sequence\", GraphTermType::Sequence)\n\t\t\t\t.value(\"Union\", GraphTermType::Union)\n\t\t\t\t.value(\"Pattern\", GraphTermType::Pattern)\n\t\t\t\t.value(\"Builtin\", GraphTermType::Builtin)\n\t\t\t\t.export_values();\n\n\t\tclass_<GraphTerm, std::shared_ptr<GraphTerm>, boost::noncopyable>\n\t\t\t\t(\"GraphTerm\", no_init)\n\t\t\t\t.def(\"isPattern\", &GraphTerm::isPattern)\n\t\t\t\t.def(\"isBuiltin\", &GraphTerm::isBuiltin)\n\t\t\t\t.def(\"termType\", &GraphTerm::termType);\n\n\t\tclass_<GraphPattern, bases<GraphTerm>, std::shared_ptr<GraphPattern>, boost::noncopyable>\n\t\t\t\t(\"GraphPattern\", init<TriplePatternPtr>())\n\t\t\t\t.def(init<const TermPtr &, const TermPtr &, const TermPtr &>())\n\t\t\t\t.def(\"value\", &GraphPattern::value, return_value_policy<copy_const_reference>());\n\n\t\tcreateType<GraphUnion>();\n\t\tcreateType<GraphSequence>();\n\t\tcreateType<GraphBuiltin>();\n\n\t\tdef(\"applyBindings\", applyBindings_graph);\n\n\t\ttypedef std::vector<std::shared_ptr<GraphTerm>> GraphTermList;\n\t\tpy::custom_vector_from_seq<std::shared_ptr<GraphTerm>>();\n\t\tboost::python::class_<GraphTermList>(\"GraphTermList\").def(\n\t\t\t\tboost::python::vector_indexing_suite<GraphTermList, true>());\n\t}\n}\n\n'knowrob/include/knowrob/semweb/TriplePattern.h'\n:\n\n#ifndef KNOWROB_FRAMED_TRIPLE_PATTERN_H\n#define KNOWROB_FRAMED_TRIPLE_PATTERN_H\n\n#include \"knowrob/formulas/Predicate.h\"\n#include \"knowrob/semweb/Triple.h\"\n#include \"knowrob/semweb/TripleContainer.h\"\n#include \"knowrob/formulas/FirstOrderLiteral.h\"\n#include \"knowrob/queries/QueryContext.h\"\n#include \"knowrob/terms/groundable.h\"\n#include \"knowrob/terms/Numeric.h\"\n#include \"knowrob/terms/IRIAtom.h\"\n#include \"knowrob/terms/Blank.h\"\n\nnamespace knowrob {\n\n\tenum class FilterType {\n\t\tEQ = 0,\n\t\tNEQ,\n\t\tLT,\n\t\tGT,\n\t\tLEQ,\n\t\tGEQ\n\t};\n\n\n\tFilterType inverseFilterType(FilterType op);\n\n\n\tclass TriplePattern : public FirstOrderLiteral {\n\tpublic:\n\n\t\texplicit TriplePattern(const Triple &triple, bool isNegated = false);\n\n\n\t\texplicit TriplePattern(const PredicatePtr &predicate, bool isNegated = false);\n\n\n\t\tTriplePattern(const TermPtr &s, const TermPtr &p, const TermPtr &o, bool isNegated = false);\n\n\n\t\tvoid setTripleFrame(const GraphSelector &frame);\n\n\n\t\tvoid getTripleFrame(GraphSelector &frame) const;\n\n\n\t\tauto &subjectTerm() const { return subjectTerm_; }\n\n\n\t\tvoid setSubjectTerm(const TermPtr &subjectTerm) { subjectTerm_ = subjectTerm; }\n\n\n\t\tauto &propertyTerm() const { return propertyTerm_; }\n\n\n\t\tauto &objectTerm() const { return objectTerm_; }\n\n\n\t\tvoid setObjectTerm(const TermPtr &objectTerm) { objectTerm_ = objectTerm; }\n\n\n\t\tauto &objectVariable() const { return objectVariable_; }\n\n\n\t\tvoid setObjectVariable(const VariablePtr &objectVariable) { objectVariable_ = objectVariable; }\n\n\n\t\tauto &graphTerm() const { return graphTerm_; }\n\n\n\t\tvoid setGraphTerm(const groundable<Atom> &graphTerm) { graphTerm_ = graphTerm; }\n\n\n\t\tvoid setGraphName(const std::string_view &graphName) { graphTerm_ = getGraphTerm(graphName); }\n\n\n\t\tauto &perspectiveTerm() const { return perspectiveTerm_; }\n\n\n\t\tvoid setPerspectiveTerm(const groundable<Atom> &perspectiveTerm) { perspectiveTerm_ = perspectiveTerm; }\n\n\n\t\tauto &beginTerm() const { return beginTerm_; }\n\n\n\t\tvoid setBeginTerm(const groundable<Double> &beginTerm) { beginTerm_ = beginTerm; }\n\n\n\t\tauto &endTerm() const { return endTerm_; }\n\n\n\t\tvoid setEndTerm(const groundable<Double> &endTerm) { endTerm_ = endTerm; }\n\n\n\t\tauto &confidenceTerm() const { return confidenceTerm_; }\n\n\n\t\tvoid setConfidenceTerm(const groundable<Double> &confidenceTerm) { confidenceTerm_ = confidenceTerm; }\n\n\n\t\tauto objectOperator() const { return objectOperator_; }\n\n\n\t\tvoid setObjectOperator(FilterType objectOperator) { objectOperator_ = objectOperator; }\n\n\n\t\tauto &isOccasionalTerm() const { return isOccasional_; }\n\n\n\t\tvoid setIsOccasionalTerm(const groundable<Numeric> &isOccasional) { isOccasional_ = isOccasional; }\n\n\n\t\tauto &isUncertainTerm() const { return isUncertain_; }\n\n\n\t\tvoid setIsUncertainTerm(const groundable<Numeric> &isUncertain) { isUncertain_ = isUncertain; }\n\n\n\t\tbool isOptional() const { return isOptional_; }\n\n\n\t\tvoid setIsOptional(bool isOptional) { isOptional_ = isOptional; }\n\n\n\t\tuint32_t numVariables() const override;\n\n\n\t\tstd::vector<VariablePtr> getVariables(bool includeObjectVar = true) const;\n\n\n\t\tbool filter(const Triple &triple) const;\n\n\n\t\tbool instantiateInto(Triple &triple,\n\t\t\t\t\t\t\t const std::shared_ptr<const Bindings> &bindings = Bindings::emptyBindings()) const;\n\n\t\tstatic std::shared_ptr<Predicate> getRDFPredicate(const PredicatePtr &predicate);\n\n\tprotected:\n\t\tTermPtr subjectTerm_;\n\t\tTermPtr propertyTerm_;\n\t\tTermPtr objectTerm_;\n\t\tVariablePtr objectVariable_;\n\t\tFilterType objectOperator_;\n\t\tbool isOptional_;\n\n\n\t\tgroundable<Atom> graphTerm_;\n\t\tgroundable<Atom> perspectiveTerm_;\n\t\tgroundable<Double> beginTerm_;\n\t\tgroundable<Double> endTerm_;\n\t\tgroundable<Double> confidenceTerm_;\n\t\tgroundable<Numeric> isOccasional_;\n\t\tgroundable<Numeric> isUncertain_;\n\n\t\tstatic std::shared_ptr<Atom> getGraphTerm(const std::string_view &graphName);\n\n\t\tstatic std::shared_ptr<Predicate> getRDFPredicate(const TermPtr &s, const TermPtr &p, const TermPtr &o);\n\n\t\tstatic std::shared_ptr<Predicate> getRDFPredicate(const Triple &data);\n\t};\n\n\n\tusing TriplePatternPtr = std::shared_ptr<TriplePattern>;\n\n\n\tTriplePatternPtr applyBindings(const TriplePatternPtr &pat, const Bindings &bindings);\n\n\n\tclass TriplePatternContainer : public MutableTripleContainer {\n\tpublic:\n\t\tTriplePatternContainer() = default;\n\n\t\t~TriplePatternContainer();\n\n\t\tTriplePatternContainer(const TriplePatternContainer &other) = delete;\n\n\n\t\tvoid push_back(const TriplePatternPtr &q);\n\n\n\t\tConstGenerator cgenerator() const override;\n\n\n\t\tMutableGenerator generator() override;\n\n\tprotected:\n\t\tstd::vector<TriplePtr *> data_;\n\t\tstd::vector<TriplePatternPtr> statements_;\n\t};\n}\n\n#endif\n",
        "gt": [
            "'knowrob/include/knowrob/terms/groundable.h'",
            "'knowrob/include/knowrob/semweb/TriplePattern.h'",
            "'knowrob/include/knowrob/semweb/GraphUnion.h'",
            "'knowrob/src/semweb/GraphTerm.cpp'"
        ]
    },
    {
        "files": [
            "'GWToolboxpp/Dependencies/wolfssl/include/wolfssl/wolfcrypt/ed25519.h'",
            "'GWToolboxpp/Dependencies/wolfssl/include/wolfssl/wolfcrypt/random.h'",
            "'GWToolboxpp/Dependencies/wolfssl/include/wolfssl/wolfcrypt/port/nxp/ksdk_port.h'"
        ],
        "content": "'GWToolboxpp/Dependencies/wolfssl/include/wolfssl/wolfcrypt/ed25519.h'\n:\n\n\n\n\n#ifndef WOLF_CRYPT_ED25519_H\n#define WOLF_CRYPT_ED25519_H\n\n#include <wolfssl/wolfcrypt/types.h>\n\n#ifdef HAVE_ED25519\n\n#include <wolfssl/wolfcrypt/fe_operations.h>\n#include <wolfssl/wolfcrypt/ge_operations.h>\n#include <wolfssl/wolfcrypt/random.h>\n#ifndef WOLFSSL_SHA512\n#error ED25519 requires SHA512\n#endif\n#include <wolfssl/wolfcrypt/sha512.h>\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    #include <wolfssl/wolfcrypt/async.h>\n#endif\n\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\n\n\n\n\n#define ED25519_KEY_SIZE     32\n#define ED25519_SIG_SIZE     64\n\n#define ED25519_PUB_KEY_SIZE 32\n\n#define ED25519_PRV_KEY_SIZE (ED25519_PUB_KEY_SIZE+ED25519_KEY_SIZE)\n\n\nenum {\n    Ed25519    = -1,\n    Ed25519ctx = 0,\n    Ed25519ph  = 1,\n};\n\n#ifndef WC_ED25519KEY_TYPE_DEFINED\n    typedef struct ed25519_key ed25519_key;\n    #define WC_ED25519KEY_TYPE_DEFINED\n#endif\n\n\nenum {\n    WC_ED25519_FLAG_NONE     = 0x00,\n    WC_ED25519_FLAG_DEC_SIGN = 0x01,\n};\n\n\nstruct ed25519_key {\n    byte    p[ED25519_PUB_KEY_SIZE];\n    byte    k[ED25519_PRV_KEY_SIZE];\n#ifdef FREESCALE_LTC_ECC\n\n    byte pointX[ED25519_KEY_SIZE];\n    byte pointY[ED25519_KEY_SIZE];\n#endif\n#ifdef WOLFSSL_SE050\n    int keyId;\n    word32 flags;\n#endif\n    word16 privKeySet:1;\n    word16 pubKeySet:1;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    WC_ASYNC_DEV asyncDev;\n#endif\n#if defined(WOLF_CRYPTO_CB)\n    int devId;\n#endif\n    void *heap;\n#ifdef WOLFSSL_ED25519_PERSISTENT_SHA\n    wc_Sha512 sha;\n    int sha_clean_flag;\n#endif\n};\n\n\nWOLFSSL_API\nint wc_ed25519_make_public(ed25519_key* key, unsigned char* pubKey,\n                           word32 pubKeySz);\nWOLFSSL_API\nint wc_ed25519_make_key(WC_RNG* rng, int keysize, ed25519_key* key);\n#ifdef HAVE_ED25519_SIGN\nWOLFSSL_API\nint wc_ed25519_sign_msg(const byte* in, word32 inLen, byte* out,\n                        word32 *outLen, ed25519_key* key);\nWOLFSSL_API\nint wc_ed25519ctx_sign_msg(const byte* in, word32 inLen, byte* out,\n                           word32 *outLen, ed25519_key* key,\n                           const byte* context, byte contextLen);\nWOLFSSL_API\nint wc_ed25519ph_sign_hash(const byte* hash, word32 hashLen, byte* out,\n                           word32 *outLen, ed25519_key* key,\n                           const byte* context, byte contextLen);\nWOLFSSL_API\nint wc_ed25519ph_sign_msg(const byte* in, word32 inLen, byte* out,\n                          word32 *outLen, ed25519_key* key, const byte* context,\n                          byte contextLen);\nWOLFSSL_API\nint wc_ed25519_sign_msg_ex(const byte* in, word32 inLen, byte* out,\n                            word32 *outLen, ed25519_key* key, byte type,\n                            const byte* context, byte contextLen);\n#endif\n#ifdef HAVE_ED25519_VERIFY\nWOLFSSL_API\nint wc_ed25519_verify_msg(const byte* sig, word32 sigLen, const byte* msg,\n                          word32 msgLen, int* res, ed25519_key* key);\nWOLFSSL_API\nint wc_ed25519ctx_verify_msg(const byte* sig, word32 sigLen, const byte* msg,\n                             word32 msgLen, int* res, ed25519_key* key,\n                             const byte* context, byte contextLen);\nWOLFSSL_API\nint wc_ed25519ph_verify_hash(const byte* sig, word32 sigLen, const byte* hash,\n                             word32 hashLen, int* res, ed25519_key* key,\n                             const byte* context, byte contextLen);\nWOLFSSL_API\nint wc_ed25519ph_verify_msg(const byte* sig, word32 sigLen, const byte* msg,\n                            word32 msgLen, int* res, ed25519_key* key,\n                            const byte* context, byte contextLen);\nWOLFSSL_API\nint wc_ed25519_verify_msg_ex(const byte* sig, word32 sigLen, const byte* msg,\n                              word32 msgLen, int* res, ed25519_key* key,\n                              byte type, const byte* context, byte contextLen);\n#ifdef WOLFSSL_ED25519_STREAMING_VERIFY\nWOLFSSL_API\nint wc_ed25519_verify_msg_init(const byte* sig, word32 sigLen, ed25519_key* key,\n                               byte type, const byte* context, byte contextLen);\nWOLFSSL_API\nint wc_ed25519_verify_msg_update(const byte* msgSegment, word32 msgSegmentLen,\n                               ed25519_key* key);\nWOLFSSL_API\nint wc_ed25519_verify_msg_final(const byte* sig, word32 sigLen, int* res,\n                                ed25519_key* key);\n#endif\n#endif\n\n\nWOLFSSL_API\nint wc_ed25519_init(ed25519_key* key);\nWOLFSSL_API\nint wc_ed25519_init_ex(ed25519_key* key, void* heap, int devId);\nWOLFSSL_API\nvoid wc_ed25519_free(ed25519_key* key);\n#ifdef HAVE_ED25519_KEY_IMPORT\nWOLFSSL_API\nint wc_ed25519_import_public(const byte* in, word32 inLen, ed25519_key* key);\nWOLFSSL_API\nint wc_ed25519_import_public_ex(const byte* in, word32 inLen, ed25519_key* key,\n                                int trusted);\nWOLFSSL_API\nint wc_ed25519_import_private_only(const byte* priv, word32 privSz,\n                                                              ed25519_key* key);\nWOLFSSL_API\nint wc_ed25519_import_private_key(const byte* priv, word32 privSz,\n                               const byte* pub, word32 pubSz, ed25519_key* key);\nWOLFSSL_API\nint wc_ed25519_import_private_key_ex(const byte* priv, word32 privSz,\n    const byte* pub, word32 pubSz, ed25519_key* key, int trusted);\n#endif\n\n#ifdef HAVE_ED25519_KEY_EXPORT\nWOLFSSL_API\nint wc_ed25519_export_public(ed25519_key* key, byte* out, word32* outLen);\nWOLFSSL_API\nint wc_ed25519_export_private_only(ed25519_key* key, byte* out, word32* outLen);\nWOLFSSL_API\nint wc_ed25519_export_private(ed25519_key* key, byte* out, word32* outLen);\nWOLFSSL_API\nint wc_ed25519_export_key(ed25519_key* key,\n                          byte* priv, word32 *privSz,\n                          byte* pub, word32 *pubSz);\n#endif\n\nWOLFSSL_API\nint wc_ed25519_check_key(ed25519_key* key);\n\n\nWOLFSSL_API\nint wc_ed25519_size(ed25519_key* key);\nWOLFSSL_API\nint wc_ed25519_priv_size(ed25519_key* key);\nWOLFSSL_API\nint wc_ed25519_pub_size(ed25519_key* key);\nWOLFSSL_API\nint wc_ed25519_sig_size(ed25519_key* key);\n\n#ifdef __cplusplus\n    }\n#endif\n\n#endif\n#endif\n\n'GWToolboxpp/Dependencies/wolfssl/include/wolfssl/wolfcrypt/random.h'\n:\n\n\n\n\n\n#ifndef WOLF_CRYPT_RANDOM_H\n#define WOLF_CRYPT_RANDOM_H\n\n#include <wolfssl/wolfcrypt/types.h>\n\n#if defined(HAVE_FIPS) && \\\n    defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2)\n    #include <wolfssl/wolfcrypt/fips.h>\n#endif\n\n\n#if defined(HAVE_FIPS) && \\\n        (!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION < 2))\n#include <cyassl/ctaocrypt/random.h>\n#endif\n\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\n\n#ifndef RNG_MAX_BLOCK_LEN\n    #ifdef HAVE_INTEL_QA\n        #define RNG_MAX_BLOCK_LEN (0xFFFFl)\n    #else\n        #define RNG_MAX_BLOCK_LEN (0x10000l)\n    #endif\n#endif\n\n\n#ifndef DRBG_SEED_LEN\n    #define DRBG_SEED_LEN (440/8)\n#endif\n\n\n#if !defined(CUSTOM_RAND_TYPE)\n\n    #define CUSTOM_RAND_TYPE    byte\n#endif\n\n\n#if !defined(WC_NO_HASHDRBG) && !defined(CUSTOM_RAND_GENERATE_BLOCK)\n    #undef  HAVE_HASHDRBG\n    #define HAVE_HASHDRBG\n    #ifndef WC_RESEED_INTERVAL\n        #define WC_RESEED_INTERVAL (1000000)\n    #endif\n#endif\n\n\n\n#if !defined(HAVE_FIPS) || \\\n    (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2))\n\n\n\n\n\n\n#if defined(CUSTOM_RAND_GENERATE_BLOCK)\n\n    #if defined(CUSTOM_RAND_GENERATE_BLOCK) && defined(WOLFSSL_KCAPI)\n        #undef  CUSTOM_RAND_GENERATE_BLOCK\n        #define CUSTOM_RAND_GENERATE_BLOCK wc_hwrng_generate_block\n        WOLFSSL_LOCAL int wc_hwrng_generate_block(byte *output, word32 sz);\n    #endif\n#elif defined(HAVE_HASHDRBG)\n    #ifdef NO_SHA256\n        #error \"Hash DRBG requires SHA-256.\"\n    #endif\n    #include <wolfssl/wolfcrypt/sha256.h>\n#elif defined(HAVE_WNR)\n\n#elif defined(HAVE_INTEL_RDRAND)\n\n#elif !defined(WC_NO_RNG)\n    #error No RNG source defined!\n#endif\n\n#ifdef HAVE_WNR\n    #include <wnr.h>\n#endif\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    #include <wolfssl/wolfcrypt/async.h>\n#endif\n\n\n#if defined(USE_WINDOWS_API)\n    #if defined(_WIN64)\n        typedef unsigned __int64 ProviderHandle;\n\n    #else\n        typedef unsigned long ProviderHandle;\n    #endif\n#endif\n\n#ifndef WC_RNG_TYPE_DEFINED\n    typedef struct OS_Seed OS_Seed;\n    typedef struct WC_RNG WC_RNG;\n    #ifdef WC_RNG_SEED_CB\n        typedef int (*wc_RngSeed_Cb)(OS_Seed* os, byte* seed, word32 sz);\n    #endif\n    #define WC_RNG_TYPE_DEFINED\n#endif\n\n\nstruct OS_Seed {\n    #if defined(USE_WINDOWS_API)\n        ProviderHandle handle;\n    #else\n        int fd;\n    #endif\n    #if defined(WOLF_CRYPTO_CB)\n        int devId;\n    #endif\n};\n\n#ifdef HAVE_HASHDRBG\nstruct DRBG_internal {\n    word32 reseedCtr;\n    word32 lastBlock;\n    byte V[DRBG_SEED_LEN];\n    byte C[DRBG_SEED_LEN];\n#if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)\n    void* heap;\n    int devId;\n#endif\n    byte   matchCount;\n#ifdef WOLFSSL_SMALL_STACK_CACHE\n    wc_Sha256 sha256;\n#endif\n};\n#endif\n\n\nstruct WC_RNG {\n    struct OS_Seed seed;\n    void* heap;\n#ifdef HAVE_HASHDRBG\n\n    struct DRBG* drbg;\n#if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)\n    struct DRBG_internal drbg_data;\n#endif\n    byte status;\n#endif\n#ifdef WOLFSSL_ASYNC_CRYPT\n    WC_ASYNC_DEV asyncDev;\n#endif\n#if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)\n    int devId;\n#endif\n};\n\n#endif\n\n\n#if !defined(NO_OLD_RNGNAME) && !defined(HAVE_FIPS)\n    #define RNG WC_RNG\n#endif\n\nWOLFSSL_API int wc_GenerateSeed(OS_Seed* os, byte* seed, word32 sz);\n\n\n#ifdef HAVE_WNR\n\n    WOLFSSL_API int  wc_InitNetRandom(const char*, wnr_hmac_key, int);\n    WOLFSSL_API int  wc_FreeNetRandom(void);\n#endif\n\n\nWOLFSSL_ABI WOLFSSL_API WC_RNG* wc_rng_new(byte* nonce, word32 nonceSz, void* heap);\nWOLFSSL_ABI WOLFSSL_API void wc_rng_free(WC_RNG* rng);\n\n\n#ifndef WC_NO_RNG\nWOLFSSL_ABI WOLFSSL_API int  wc_InitRng(WC_RNG* rng);\nWOLFSSL_API int  wc_InitRng_ex(WC_RNG* rng, void* heap, int devId);\nWOLFSSL_API int  wc_InitRngNonce(WC_RNG* rng, byte* nonce, word32 nonceSz);\nWOLFSSL_API int  wc_InitRngNonce_ex(WC_RNG* rng, byte* nonce, word32 nonceSz,\n                                    void* heap, int devId);\nWOLFSSL_ABI WOLFSSL_API int wc_RNG_GenerateBlock(WC_RNG* rng, byte* b, word32 sz);\nWOLFSSL_API int  wc_RNG_GenerateByte(WC_RNG* rng, byte* b);\nWOLFSSL_API int  wc_FreeRng(WC_RNG* rng);\n#else\n#include <wolfssl/wolfcrypt/error-crypt.h>\n#define wc_InitRng(rng) NOT_COMPILED_IN\n#define wc_InitRng_ex(rng, h, d) NOT_COMPILED_IN\n#define wc_InitRngNonce(rng, n, s) NOT_COMPILED_IN\n#define wc_InitRngNonce_ex(rng, n, s, h, d) NOT_COMPILED_IN\n#if defined(__ghs__) || defined(WC_NO_RNG_SIMPLE)\n\n#define wc_RNG_GenerateBlock(rng, b, s) NOT_COMPILED_IN\n#else\n#define wc_RNG_GenerateBlock(rng, b, s) ({(void)rng; (void)b; (void)s; NOT_COMPILED_IN;})\n#endif\n#define wc_RNG_GenerateByte(rng, b) NOT_COMPILED_IN\n#define wc_FreeRng(rng) (void)NOT_COMPILED_IN\n#endif\n\n#ifdef WC_RNG_SEED_CB\n    WOLFSSL_API int wc_SetSeed_Cb(wc_RngSeed_Cb cb);\n#endif\n\n#ifdef HAVE_HASHDRBG\n    WOLFSSL_LOCAL int wc_RNG_DRBG_Reseed(WC_RNG* rng, const byte* entropy,\n                                        word32 entropySz);\n    WOLFSSL_API int wc_RNG_TestSeed(const byte* seed, word32 seedSz);\n    WOLFSSL_API int wc_RNG_HealthTest(int reseed,\n                                        const byte* entropyA, word32 entropyASz,\n                                        const byte* entropyB, word32 entropyBSz,\n                                        byte* output, word32 outputSz);\n    WOLFSSL_API int wc_RNG_HealthTest_ex(int reseed,\n                                        const byte* nonce, word32 nonceSz,\n                                        const byte* entropyA, word32 entropyASz,\n                                        const byte* entropyB, word32 entropyBSz,\n                                        byte* output, word32 outputSz,\n                                        void* heap, int devId);\n#endif\n\n#ifdef __cplusplus\n    }\n#endif\n\n#endif\n\n\n'GWToolboxpp/Dependencies/wolfssl/include/wolfssl/wolfcrypt/port/nxp/ksdk_port.h'\n:\n\n#ifndef _KSDK_PORT_H_\n#define _KSDK_PORT_H_\n\n#include <wolfssl/wolfcrypt/settings.h>\n#ifdef USE_FAST_MATH\n    #include <wolfssl/wolfcrypt/tfm.h>\n#elif defined WOLFSSL_SP_MATH\n    #include <wolfssl/wolfcrypt/sp_int.h>\n#else\n    #include <wolfssl/wolfcrypt/integer.h>\n#endif\n#include <wolfssl/wolfcrypt/ecc.h>\n#include <wolfssl/wolfcrypt/curve25519.h>\n#include <wolfssl/wolfcrypt/ed25519.h>\n\n\n\nint ksdk_port_init(void);\n\n\n#if defined(FREESCALE_LTC_TFM)\n\tint wolfcrypt_mp_mul(mp_int *A, mp_int *B, mp_int *C);\n\tint wolfcrypt_mp_mod(mp_int *a, mp_int *b, mp_int *c);\n\tint wolfcrypt_mp_mulmod(mp_int *a, mp_int *b, mp_int *c, mp_int *d);\n\tint wolfcrypt_mp_mod(mp_int *a, mp_int *b, mp_int *c);\n\tint wolfcrypt_mp_invmod(mp_int *a, mp_int *b, mp_int *c);\n\tint wolfcrypt_mp_exptmod(mp_int *G, mp_int *X, mp_int *P, mp_int *Y);\n\tint wolfcrypt_mp_prime_is_prime_ex(mp_int* a, int t, int* result, WC_RNG* rng);\n\n\n    int mp_mulmod(mp_int *a, mp_int *b, mp_int *c, mp_int *d);\n\n#endif\n\n#if defined(FREESCALE_LTC_ECC)\n\t#include \"fsl_ltc.h\"\n\n\ttypedef enum _fsl_ltc_ecc_coordinate_system\n\t{\n\t    kLTC_Weierstrass = 0U,\n\t    kLTC_Curve25519 = 1U,\n\t    kLTC_Ed25519 = 2U,\n\t} fsl_ltc_ecc_coordinate_system_t;\n\n\tint wc_ecc_point_add(ecc_point *mG, ecc_point *mQ, ecc_point *mR, mp_int *m);\n\n\t#ifdef HAVE_CURVE25519\n\t\tint nxp_ltc_curve25519(ECPoint *q, const byte *n, const ECPoint *p, fsl_ltc_ecc_coordinate_system_t type);\n\t\tconst ECPoint *nxp_ltc_curve25519_GetBasePoint(void);\n\t\tstatus_t LTC_PKHA_Curve25519ToWeierstrass(const ltc_pkha_ecc_point_t *ltcPointIn, ltc_pkha_ecc_point_t *ltcPointOut);\n\t\tstatus_t LTC_PKHA_WeierstrassToCurve25519(const ltc_pkha_ecc_point_t *ltcPointIn, ltc_pkha_ecc_point_t *ltcPointOut);\n\t\tstatus_t LTC_PKHA_Curve25519ComputeY(ltc_pkha_ecc_point_t *ltcPoint);\n\t#endif\n\n\t#ifdef HAVE_ED25519\n\t\tstatus_t LTC_PKHA_Ed25519ToWeierstrass(const ltc_pkha_ecc_point_t *ltcPointIn, ltc_pkha_ecc_point_t *ltcPointOut);\n\t\tstatus_t LTC_PKHA_WeierstrassToEd25519(const ltc_pkha_ecc_point_t *ltcPointIn, ltc_pkha_ecc_point_t *ltcPointOut);\n\t\tstatus_t LTC_PKHA_Ed25519_PointMul(const ltc_pkha_ecc_point_t *ltcPointIn,\n\t\t                                   const uint8_t *N,\n\t\t                                   size_t sizeN,\n\t\t                                   ltc_pkha_ecc_point_t *ltcPointOut,\n\t\t                                   fsl_ltc_ecc_coordinate_system_t typeOut);\n\t\tconst ltc_pkha_ecc_point_t *LTC_PKHA_Ed25519_BasePoint(void);\n\t\tstatus_t LTC_PKHA_Ed25519_PointDecompress(const uint8_t *pubkey, size_t pubKeySize, ltc_pkha_ecc_point_t *ltcPointOut);\n\t\tstatus_t LTC_PKHA_sc_reduce(uint8_t *a);\n\t\tstatus_t LTC_PKHA_sc_muladd(uint8_t *s, const uint8_t *a, const uint8_t *b, const uint8_t *c);\n\t\tstatus_t LTC_PKHA_SignatureForVerify(uint8_t *rcheck, const unsigned char *a, const unsigned char *b, ed25519_key *key);\n\t\tstatus_t LTC_PKHA_Ed25519_Compress(const ltc_pkha_ecc_point_t *ltcPointIn, uint8_t *p);\n\t#endif\n\n#endif\n\n#endif\n",
        "gt": [
            "'GWToolboxpp/Dependencies/wolfssl/include/wolfssl/wolfcrypt/random.h'",
            "'GWToolboxpp/Dependencies/wolfssl/include/wolfssl/wolfcrypt/ed25519.h'",
            "'GWToolboxpp/Dependencies/wolfssl/include/wolfssl/wolfcrypt/port/nxp/ksdk_port.h'"
        ]
    },
    {
        "files": [
            "'egoboo/egolib/library/src/egolib/game/Graphics/ParticleGraphics.cpp'",
            "'egoboo/egolib/library/src/egolib/Entities/_Include.hpp'",
            "'egoboo/egolib/library/src/egolib/Entities/ObjectHandler.hpp'"
        ],
        "content": "'egoboo/egolib/library/src/egolib/game/Graphics/ParticleGraphics.cpp'\n:#include \"egolib/game/Graphics/ParticleGraphics.hpp\"\n#include \"egolib/game/Graphics/Camera.hpp\"\n#include \"egolib/game/lighting.h\"\n#include \"egolib/game/graphic.h\"\n#include \"egolib/Entities/_Include.hpp\"\n\nnamespace Ego {\nnamespace Graphics {\n\nParticleGraphics::ParticleGraphics() :\n    valid(false),\n    indolist(false),\n\n\n    type(0),\n    image_ref(0),\n    alpha(0.0f),\n    light(0),\n\n\n    pos(idlib::zero<Vector3f>()),\n    size(0.0f),\n    scale(0.0f),\n\n\n    orientation(prt_ori_t::ORIENTATION_B),\n    up(idlib::zero<Vector3f>()),\n    right(idlib::zero<Vector3f>()),\n    nrm(idlib::zero<Vector3f>()),\n\n\n    famb(0.0f),\n    fdir(0.0f),\n\n    fintens(0.0f),\n    falpha(0.0f),\n\n\n    ref_valid(false),\n    ref_up(idlib::zero<Vector3f>()),\n    ref_right(idlib::zero<Vector3f>()),\n    ref_pos(idlib::zero<Vector3f>())\n{\n\n}\n\nvoid ParticleGraphics::reset()\n{\n    (*this) = ParticleGraphics();\n}\n\ngfx_rv ParticleGraphics::update_vertices(ParticleGraphics& inst, ::Camera& camera, Particle *pprt)\n{\n    inst.valid = false;\n    inst.ref_valid = false;\n\n    if (pprt->isTerminated())\n    {\n        Log::Entry e(Log::Level::Error, __FILE__, __LINE__);\n        e << \"invalid particle `\" << pprt->getParticleID() << \"`\" << Log::EndOfEntry;\n        Log::get() << e;\n        return gfx_error;\n    }\n\n    const auto& ppip = pprt->getProfile();\n\n    inst.type = pprt->type;\n\n    inst.image_ref = (pprt->_image._start / EGO_ANIMATION_MULTIPLIER + pprt->_image._offset / EGO_ANIMATION_MULTIPLIER);\n\n\n\n    inst.pos = pprt->getPosition();\n    inst.orientation = ppip->orientation;\n\n\n    inst.ref_pos = pprt->getPosition();\n    inst.ref_pos[kZ] = 2 * pprt->enviro.floor_level - inst.pos[kZ];\n\n\n    Vector3f vfwd = inst.pos - camera.getPosition();\n    vfwd = normalize(vfwd).get_vector();\n\n    Vector3f vfwd_ref = inst.ref_pos - camera.getPosition();\n    vfwd_ref = normalize(vfwd_ref).get_vector();\n\n\n    Vector3f vup = Vector3f(0.0f, 0.0f, 1.0f), vright;\n    Vector3f vup_ref = Vector3f(0.0f, 0.0f, 1.0f), vright_ref;\n    if (ppip->rotatetoface && !pprt->isAttached() && (idlib::manhattan_norm(pprt->getVelocity()) > 0))\n    {\n\n\n        vup = pprt->getVelocity();\n        vup = normalize(vup).get_vector();\n\n\n        vright = cross(vfwd, vup);\n        vright = normalize(vright).get_vector();\n\n        vup_ref = vup;\n        vright_ref = cross(vfwd_ref, vup);\n        vright_ref = normalize(vright_ref).get_vector();\n    }\n    else if (prt_ori_t::ORIENTATION_B == inst.orientation)\n    {\n\n        vup = camera.getUp();\n        vup = normalize(vup).get_vector();\n\n\n        vright = cross(vfwd, vup);\n        vright = normalize(vright).get_vector();\n\n        vup_ref = vup;\n        vright_ref = cross(vfwd_ref, vup);\n        vright_ref = normalize(vright_ref).get_vector();\n    }\n    else if (prt_ori_t::ORIENTATION_V == inst.orientation)\n    {\n\n\n\n\n\n\n        Vector3f vup_cam = camera.getUp();\n\n\n        vup = Vector3f(0.0f, 0.0f, 1.0f);\n\n\n\n        float weight = 1.0f - std::abs(vup_cam[kZ]);\n        if (vup_cam[kZ] < 0) weight *= -1;\n\n        vup += vup_cam * weight;\n        vup = normalize(vup).get_vector();\n\n\n        vright = cross(vfwd, vup);\n        vright = normalize(vright).get_vector();\n\n        vright_ref = cross(vfwd, vup_ref);\n        vright_ref = normalize(vright_ref).get_vector();\n\n        vup_ref = vup;\n        vright_ref = cross(vfwd_ref, vup);\n        vright_ref = normalize(vright_ref).get_vector();\n    }\n    else if (prt_ori_t::ORIENTATION_H == inst.orientation)\n    {\n        Vector3f vert = Vector3f(0.0f, 0.0f, 1.0f);\n\n\n        vright = cross(vfwd, vert);\n\n\n        vup = cross(vert, vright);\n\n\n\n        vright = normalize(vright).get_vector();\n        vup = normalize(vup).get_vector();\n\n        vright_ref = vright;\n        vup_ref = vup;\n    }\n    else if (pprt->isAttached())\n    {\n        auto& cinst = pprt->getAttachedObject()->inst;\n\n        if (chr_matrix_valid(pprt->getAttachedObject().get()))\n        {\n\n\n\n\n            switch (inst.orientation)\n            {\n                case prt_ori_t::ORIENTATION_X: vup = mat_getChrForward(cinst.getMatrix()); break;\n                case prt_ori_t::ORIENTATION_Y: vup = mat_getChrRight(cinst.getMatrix());   break;\n                default:\n                case prt_ori_t::ORIENTATION_Z: vup = mat_getChrUp(cinst.getMatrix());      break;\n            }\n\n            vup = normalize(vup).get_vector();\n        }\n        else\n        {\n\n            switch (inst.orientation)\n            {\n                case prt_ori_t::ORIENTATION_X: vup = camera.getForward(); break;\n                case prt_ori_t::ORIENTATION_Y: vup = camera.getRight(); break;\n\n                default:\n                case prt_ori_t::ORIENTATION_Z: vup = camera.getUp(); break;\n            }\n        }\n\n        vup = normalize(vup).get_vector();\n\n\n        vright = cross(vfwd, vup);\n        vright = normalize(vright).get_vector();\n\n        vup_ref = vup;\n        vright_ref = cross(vfwd_ref, vup);\n        vright_ref = normalize(vright_ref).get_vector();\n    }\n    else\n    {\n\n        vup = camera.getUp();\n        vup = normalize(vup).get_vector();\n\n\n        vright = cross(vfwd, vup);\n        vright = normalize(vright).get_vector();\n\n        vup_ref = vup;\n        vright_ref = cross(vfwd_ref, vup);\n        vright_ref = normalize(vright_ref).get_vector();\n    }\n\n\n\n\n\n\n\n    if (Facing(0) == pprt->rotate)\n    {\n        inst.up = vup;\n        inst.right = vright;\n\n        inst.ref_up = vup_ref;\n        inst.ref_right = vright_ref;\n    }\n    else\n    {\n        float cosval = std::cos(pprt->rotate);\n        float sinval = std::sin(pprt->rotate);\n\n        inst.up = vup * cosval - vright * sinval;\n\n        inst.right = vup * sinval + vright * cosval;\n\n        inst.ref_up = vup_ref * cosval - vright_ref * sinval;\n\n        inst.ref_right = vup_ref * sinval + vright_ref * cosval;\n    }\n\n\n    inst.nrm = cross(inst.right, inst.up);\n\n\n    if (dot(vfwd, inst.nrm) < 0)\n    {\n        inst.nrm *= -1;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    {\n\n        Vector3f world_up = Vector3f(0.0f, 0.0f, 1.0f);\n\n\n\n\n        float ndot = dot(inst.nrm, world_up);\n\n\n        if (ndot < 1.0f - 1e-6)\n        {\n\n            {\n\n\n\n                float zdot = dot(inst.ref_right, world_up);\n\n                if (std::abs(zdot) > 1e-6)\n                {\n                    float factor = zdot / (1.0f - ndot * ndot);\n                    inst.ref_right += ((inst.nrm * ndot) - world_up) * 2.0f * factor;\n                }\n            }\n\n\n            {\n\n\n\n                float zdot = dot(inst.ref_up, world_up);\n\n                if (std::abs(zdot) > 1e-6)\n                {\n                    float factor = zdot / (1.0f - ndot * ndot);\n                    inst.ref_up += (inst.nrm * ndot - world_up) * 2.0f * factor;\n                }\n            }\n        }\n    }\n\n\n    inst.scale = pprt->getScale();\n    inst.size = FP8_TO_FLOAT(pprt->size) * inst.scale;\n\n\n    inst.valid = true;\n    inst.ref_valid = true;\n\n    return gfx_success;\n}\n\nMatrix4f4f ParticleGraphics::make_matrix(ParticleGraphics& pinst)\n{\n    Matrix4f4f mat = idlib::identity<Matrix4f4f>();\n\n    mat(1, 0) = -pinst.up[kX];\n    mat(1, 1) = -pinst.up[kY];\n    mat(1, 2) = -pinst.up[kZ];\n\n    mat(0, 0) = pinst.right[kX];\n    mat(0, 1) = pinst.right[kY];\n    mat(0, 2) = pinst.right[kZ];\n\n    mat(2, 0) = pinst.nrm[kX];\n    mat(2, 1) = pinst.nrm[kY];\n    mat(2, 2) = pinst.nrm[kZ];\n\n    return mat;\n}\n\ngfx_rv ParticleGraphics::update_lighting(ParticleGraphics& pinst, Particle *pprt, Uint8 trans, bool do_lighting)\n{\n    if (!pprt)\n    {\n        Log::Entry e(Log::Level::Error, __FILE__, __LINE__);\n        e << \"nullptr == particle\" << Log::EndOfEntry;\n        Log::get() << e;\n        return gfx_error;\n    }\n\n\n    uint32_t alpha = trans;\n\n\n    auto mesh = _currentModule->getMeshPointer();\n    if (!mesh)\n    {\n        throw idlib::argument_null_error(__FILE__, __LINE__, \"mesh\");\n    }\n    lighting_cache_t global_light;\n    GridIllumination::grid_lighting_interpolate(*mesh, global_light, Vector2f(pinst.pos[kX], pinst.pos[kY]));\n\n\n    Matrix4f4f mat = ParticleGraphics::make_matrix(pinst);\n    lighting_cache_t loc_light;\n    lighting_cache_t::lighting_project_cache(loc_light, global_light, mat);\n\n\n    float amb, dir;\n    lighting_cache_t::lighting_evaluate_cache(loc_light, pinst.nrm, pinst.pos[kZ], _currentModule->getMeshPointer()->_tmem._bbox, &amb, &dir);\n\n\n\n\n    int16_t self_light = 0;\n    if (SPRITE_LIGHT != pinst.type)\n    {\n        self_light = (255 == pinst.light) ? 0 : pinst.light;\n    }\n\n\n    pinst.famb = 0.9f * pinst.famb + 0.1f * (self_light + amb);\n    pinst.fdir = 0.9f * pinst.fdir + 0.1f * dir;\n\n\n    pinst.fintens = pinst.fdir * idlib::fraction<float, 1, 255>();\n    if (do_lighting)\n    {\n        pinst.fintens += pinst.famb * idlib::fraction<float, 1, 255>();\n    }\n    pinst.fintens = Ego::Math::constrain(pinst.fintens, 0.0f, 1.0f);\n\n\n    pinst.falpha = (alpha * idlib::fraction<float, 1, 255>()) * (pinst.alpha * idlib::fraction<float, 1, 255>());\n    pinst.falpha = Ego::Math::constrain(pinst.falpha, 0.0f, 1.0f);\n\n    return gfx_success;\n}\n\ngfx_rv ParticleGraphics::update(::Camera& camera, const ParticleRef particle, uint8_t trans, bool do_lighting)\n{\n    const auto& pprt = ParticleHandler::get()[particle];\n    if (!pprt)\n    {\n        Log::Entry e(Log::Level::Error, __FILE__, __LINE__);\n        e << \"invalid particle `\" << particle << \"`\" << Log::EndOfEntry;\n        Log::get() << e;\n        return gfx_error;\n    }\n\n    auto& pinst = pprt->inst;\n\n\n    gfx_rv retval = gfx_success;\n\n\n    if (gfx_error == ParticleGraphics::update_vertices(pinst, camera, pprt.get()))\n    {\n        retval = gfx_error;\n    }\n\n\n    if (gfx_error == ParticleGraphics::update_lighting(pinst, pprt.get(), trans, do_lighting))\n    {\n        retval = gfx_error;\n    }\n\n    return retval;\n}\n\n}\n}\n\n'egoboo/egolib/library/src/egolib/Entities/_Include.hpp'\n:#pragma once\n\n#define GAME_ENTITIES_PRIVATE 1\n#include \"egolib/Entities/Enchant.hpp\"\n#include \"egolib/Entities/Particle.hpp\"\n#include \"egolib/Entities/ParticleHandler.hpp\"\n#include \"egolib/Entities/Object.hpp\"\n#include \"egolib/Entities/ObjectHandler.hpp\"\n#undef GAME_ENTITIES_PRIVATE\n'egoboo/egolib/library/src/egolib/Entities/ObjectHandler.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n#if !defined(GAME_ENTITIES_PRIVATE) || GAME_ENTITIES_PRIVATE != 1\n#error(do not include directly, include `game/Entities/_Include.hpp` instead)\n#endif\n\n#include \"egolib/game/egoboo.h\"\n#include \"egolib/Core/QuadTree.hpp\"\n\n\nclass Object;\n\n\nObjectRef GET_INDEX_PCHR(const Object *pobj);\nObjectRef GET_INDEX_PCHR(const std::shared_ptr<Object> pobj);\nbool INGAME_PCHR(const Object *pobj);\n\n\nclass ObjectHandler : private idlib::non_copyable\n{\npublic:\n\n\tclass ObjectIterator\n\t{\n\tpublic:\n\n\t\tinline std::vector<std::shared_ptr<Object>>::const_iterator cbegin() const\n\t\t{\n\t\t\treturn _handler._iteratorList.cbegin();\n\t\t}\n\n\t\tinline std::vector<std::shared_ptr<Object>>::const_iterator cend() const\n\t\t{\n\t\t\treturn _handler._iteratorList.cend();\n\t\t}\n\n\t\tinline std::vector<std::shared_ptr<Object>>::iterator begin()\n\t\t{\n\t\t\treturn _handler._iteratorList.begin();\n\t\t}\n\n\t\tinline std::vector<std::shared_ptr<Object>>::iterator end()\n\t\t{\n\t\t\treturn _handler._iteratorList.end();\n\t\t}\n\n\t\t~ObjectIterator()\n\t\t{\n\n\t\t\t_handler.unlock();\n\t\t}\n\n\n        ObjectIterator(const ObjectIterator &other) :\n            _handler(other._handler)\n        {\n            _handler.lock();\n        }\n\n\n\t    ObjectIterator& operator=(const ObjectIterator&) = delete;\n\n\tprivate:\n\t\tObjectIterator(ObjectHandler &handler) :\n\t\t\t_handler(handler)\n\t\t{\n\n\t\t\t_handler.lock();\n\t\t}\n\n\t\tObjectHandler &_handler;\n\n\t\tfriend class ObjectHandler;\n\t};\n\npublic:\n\n\tObjectHandler();\n\n\n\tObjectIterator iterator();\n\n\n\tbool remove(ObjectRef ref);\n\n\n\tbool exists(ObjectRef ref) const;\n\n\n\tstd::shared_ptr<Object> insert(ObjectProfileRef profileRef, ObjectRef overrideRef = ObjectRef::Invalid);\n\n\n\tconst std::shared_ptr<Object>& operator[] (ObjectRef ref);\n\n\n\tsize_t getObjectCount() const;\n\n\n\tvoid clear();\n\n\n\tObject *get(ObjectRef ref) const;\n\n\n\n\tstd::vector<std::shared_ptr<Object>> findObjects(const float x, const float y, const float distance, bool includeSceneryObjects = true) const;\n\n\n\tvoid findObjects(const Ego::AxisAlignedBox2f &searchArea, std::vector<std::shared_ptr<Object>> &result, bool includeSceneryObjects = true) const;\n\n\n\tvoid updateQuadTree(float minX, float minY, float maxX, float maxY);\n\n\n\tconst std::vector<std::shared_ptr<Object>>& getAllObjects() const {return _iteratorList; }\n\nprivate:\n\n\n\tvoid lock();\n\n\n\tvoid unlock();\n\n\n\tvoid maybeRunDeferred();\n\n#if defined(_DEBUG)\n\n\tvoid dumpAllocateList();\n#endif\n\nprivate:\n\tEgo::QuadTree<Object> _dynamicObjects;\n\tEgo::QuadTree<Object> _staticObjects;\n\tint _updateStaticTreeClock;\n\n\tstd::unordered_map<ObjectRef, std::shared_ptr<Object>> _internalCharacterList;\n\tstd::vector<std::shared_ptr<Object>> _iteratorList;\n\n\tstd::vector<std::shared_ptr<Object>> _allocateList;\n\n\tsize_t _semaphore;\n\tsize_t _deletedCharacters;\n\n\tsize_t _totalCharactersSpawned;\n\n\tfriend class ObjectIterator;\n};\n",
        "gt": [
            "'egoboo/egolib/library/src/egolib/Entities/ObjectHandler.hpp'",
            "'egoboo/egolib/library/src/egolib/Entities/_Include.hpp'",
            "'egoboo/egolib/library/src/egolib/game/Graphics/ParticleGraphics.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ViewService.h'",
            "'OpcUaStack/src/OpcUaStackClient/ValueBasedInterface/VBITransaction.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ServiceSetManager.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/ViewServiceTransaction.h'",
            "'OpcUaStack/src/OpcUaStackClient/ValueBasedInterface/VBITransaction.cpp'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ViewService.h'\n:\n\n#ifndef __OpcUaStackClient_ViewService_h__\n#define __OpcUaStackClient_ViewService_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Component/Component.h\"\n#include \"OpcUaStackCore/ServiceSet/ViewServiceTransaction.h\"\n#include \"OpcUaStackClient/ServiceSet/ViewServiceIf.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackClient\n{\n\n\tclass DLLEXPORT ViewService\n\t: public Component\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<ViewService> SPtr;\n\n\t\tViewService(IOThread* ioThread);\n\t\t~ViewService(void);\n\n\t\tvoid setConfiguration(\n\t\t\tComponent* componentSession,\n\t\t\tViewServiceIf* viewServiceIf\n\t\t);\n\t\tvoid componentSession(Component* componentSession);\n\t\tvoid viewServiceIf(ViewServiceIf* viewServiceIf);\n\n\t\tvoid syncSend(ServiceTransactionBrowse::SPtr serviceTransactionBrowse);\n\t\tvoid asyncSend(ServiceTransactionBrowse::SPtr serviceTransactionBrowse);\n\t\tvoid syncSend(ServiceTransactionBrowseNext::SPtr serviceTransactionBrowseNext);\n\t\tvoid asyncSend(ServiceTransactionBrowseNext::SPtr serviceTransactionBrowseNext);\n\t\tvoid syncSend(ServiceTransactionTranslateBrowsePathsToNodeIds::SPtr serviceTransactionTranslateBrowsePathsToNodeIds);\n\t\tvoid asyncSend(ServiceTransactionTranslateBrowsePathsToNodeIds::SPtr serviceTransactionTranslateBrowsePathsToNodeIds);\n\n\n\n\t\tvoid receive(Message::SPtr message);\n\n\n\t  private:\n\t\tComponent* componentSession_;\n\n\t\tViewServiceIf* viewServiceIf_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackClient/ValueBasedInterface/VBITransaction.h'\n:\n\n#ifndef __OpcUaStackClient_VBITransaction_h__\n#define __OpcUaStackClient_VBITransaction_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackClient/ServiceSet/ServiceSetManager.h\"\n\nusing namespace OpcUaStackCore;\nusing namespace OpcUaStackClient;\n\nnamespace OpcUaStackClient\n{\n\n\n\n\n\n\n\n\n\tclass DLLEXPORT VBITransactionRead\n\t: public ServiceTransactionRead\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<VBITransactionRead> SPtr;\n\n\t\tVBITransactionRead(void);\n\t\tvirtual ~VBITransactionRead(void);\n\n\t\tCallback callback_;\n\t};\n\n\tclass DLLEXPORT VBITransactionWrite\n\t: public ServiceTransactionWrite\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<VBITransactionWrite> SPtr;\n\n\t\tVBITransactionWrite(void);\n\t\tvirtual ~VBITransactionWrite(void);\n\n\t\tCallback callback_;\n\t};\n\n\n\n\n\n\n\n\n\tclass DLLEXPORT VBITransactionCreateSubscription\n\t: public ServiceTransactionCreateSubscription\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<VBITransactionCreateSubscription> SPtr;\n\n\t\tVBITransactionCreateSubscription(void);\n\t\tvirtual ~VBITransactionCreateSubscription(void);\n\n\t\tCallback callback_;\n\t};\n\n\tclass DLLEXPORT VBITransactionDeleteSubscription\n\t: public ServiceTransactionDeleteSubscriptions\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<VBITransactionDeleteSubscription> SPtr;\n\n\t\tVBITransactionDeleteSubscription(void);\n\t\tvirtual ~VBITransactionDeleteSubscription(void);\n\n\t\tCallback callback_;\n\t};\n\n\n\n\n\n\n\n\n\n\tclass DLLEXPORT VBITransactionCreateMonitoredItem\n\t: public ServiceTransactionCreateMonitoredItems\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<VBITransactionCreateMonitoredItem> SPtr;\n\n\t\tVBITransactionCreateMonitoredItem(void);\n\t\tvirtual ~VBITransactionCreateMonitoredItem(void);\n\n\t\tCallback callback_;\n\t};\n\n\tclass DLLEXPORT VBITransactionDeleteMonitoredItem\n\t: public ServiceTransactionDeleteMonitoredItems\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<VBITransactionDeleteMonitoredItem> SPtr;\n\n\t\tVBITransactionDeleteMonitoredItem(void);\n\t\tvirtual ~VBITransactionDeleteMonitoredItem(void);\n\n\t\tCallback callback_;\n\t};\n\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackClient/ServiceSet/ServiceSetManager.h'\n:\n#ifndef __OpcUaStackClient_ServiceSetManager_h__\n#define __OpcUaStackClient_ServiceSetManager_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Utility/IOThread.h\"\n#include \"OpcUaStackClient/ServiceSet/SessionService.h\"\n#include \"OpcUaStackClient/ServiceSet/SessionServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/DiscoveryService.h\"\n#include \"OpcUaStackClient/ServiceSet/DiscoveryServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/AttributeService.h\"\n#include \"OpcUaStackClient/ServiceSet/AttributeServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/SubscriptionService.h\"\n#include \"OpcUaStackClient/ServiceSet/SubscriptionServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/MonitoredItemService.h\"\n#include \"OpcUaStackClient/ServiceSet/MonitoredItemServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/MethodService.h\"\n#include \"OpcUaStackClient/ServiceSet/MethodServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/ViewService.h\"\n#include \"OpcUaStackClient/ServiceSet/ViewServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/QueryService.h\"\n#include \"OpcUaStackClient/ServiceSet/QueryServiceConfig.h\"\n#include \"OpcUaStackClient/ServiceSet/NodeManagementService.h\"\n#include \"OpcUaStackClient/ServiceSet/NodeManagementServiceConfig.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackClient\n{\n\n\tclass DLLEXPORT ServiceSetManager\n\t{\n\t  public:\n\t\tServiceSetManager(void);\n\t\t~ServiceSetManager(void);\n\n\t\tvoid start(void) {}\n\t\tvoid stop(void) {}\n\n\t\tvoid registerIOThread(const std::string ioThreadName, IOThread::SPtr ioThread);\n\t\tvoid deregisterIOThread(const std::string ioThreadName);\n\n\n\t\tSessionService::SPtr sessionService(\n\t\t\tSessionServiceConfig& sessionServiceConfig\n\t\t);\n\t\tvoid updateEndpointUrl(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tconst std::string& endpointUrl\n\t\t);\n\n\n\t\tDiscoveryService::SPtr discoveryService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tDiscoveryService::SPtr discoveryService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tDiscoveryServiceConfig& discoveryServiceConfig\n\t\t);\n\n\n\t\tAttributeService::SPtr attributeService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tAttributeService::SPtr attributeService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tAttributeServiceConfig& attributeServiceConfig\n\t\t);\n\n\n\t\tSubscriptionService::SPtr subscriptionService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tSubscriptionService::SPtr subscriptionService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tSubscriptionServiceConfig& subscriptionServiceConfig\n\t\t);\n\n\n\t\tMonitoredItemService::SPtr monitoredItemService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tMonitoredItemService::SPtr monitoredItemService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tMonitoredItemServiceConfig& monitoredItemServiceConfig\n\t\t);\n\n\n\t\tMethodService::SPtr methodService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tMethodService::SPtr methodService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tMethodServiceConfig& methodServiceConfig\n\t\t);\n\n\n\t\tViewService::SPtr viewService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tViewService::SPtr viewService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tViewServiceConfig& viewServiceConfig\n\t\t);\n\n\n\t\tQueryService::SPtr queryService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tQueryService::SPtr queryService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tQueryServiceConfig& queryServiceConfig\n\t\t);\n\n\n\t\tNodeManagementService::SPtr nodeManagementService(\n\t\t\tSessionService::SPtr& sessionService\n\t\t);\n\t\tNodeManagementService::SPtr nodeManagementService(\n\t\t\tSessionService::SPtr& sessionService,\n\t\t\tNodeManagementServiceConfig& nodeManagementServiceConfig\n\t\t);\n\n\t  private:\n\t\tIOThread::SPtr getIOThread(const std::string ioThreadName);\n\t\tvoid createIOThread(const std::string ioThreadName);\n\t\tvoid destroyIOThread(const std::string ioThreadName);\n\n\t\tIOThread::Map ioThreadMap_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/ViewServiceTransaction.h'\n:#ifndef __OpcUaStackCore_ViewServiceTransaction_h__\n#define __OpcUaStackCore_ViewServiceTransaction_h__\n\n#include \"OpcUaStackCore/BuildInTypes/OpcUaIdentifier.h\"\n#include \"OpcUaStackCore/ServiceSet/ServiceTransactionTemplate.h\"\n#include \"OpcUaStackCore/ServiceSet/BrowseRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/BrowseResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/BrowseNextRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/BrowseNextResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/TranslateBrowsePathsToNodeIdsRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/TranslateBrowsePathsToNodeIdsResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/RegisterNodesRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/RegisterNodesResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/UnregisterNodesRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/UnregisterNodesResponse.h\"\n\nnamespace OpcUaStackCore\n{\n\n\ttypedef ServiceTransactionTemplate<\n\t\tBrowseRequest,\n\t\tBrowseResponse,\n\t\tOpcUaId_BrowseRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_BrowseResponse_Encoding_DefaultBinary\n\t> ServiceTransactionBrowse;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tBrowseNextRequest,\n\t\tBrowseNextResponse,\n\t\tOpcUaId_BrowseNextRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_BrowseNextResponse_Encoding_DefaultBinary\n\t> ServiceTransactionBrowseNext;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tTranslateBrowsePathsToNodeIdsRequest,\n\t\tTranslateBrowsePathsToNodeIdsResponse,\n\t\tOpcUaId_TranslateBrowsePathsToNodeIdsRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_TranslateBrowsePathsToNodeIdsResponse_Encoding_DefaultBinary\n\t> ServiceTransactionTranslateBrowsePathsToNodeIds;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tRegisterNodesRequest,\n\t\tRegisterNodesResponse,\n\t\tOpcUaId_RegisterNodesRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_RegisterNodesResponse_Encoding_DefaultBinary\n\t> ServiceTransactionRegisterNodes;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tUnregisterNodesRequest,\n\t\tUnregisterNodesResponse,\n\t\tOpcUaId_UnregisterNodesRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_UnregisterNodesResponse_Encoding_DefaultBinary\n\t> ServiceTransactionUnregisterNodes;\n\n}\n\n#endif\n'OpcUaStack/src/OpcUaStackClient/ValueBasedInterface/VBITransaction.cpp'\n:\n\n#include \"OpcUaStackClient/ValueBasedInterface/VBITransaction.h\"\n\nnamespace OpcUaStackClient\n{\n\n\n\n\n\n\n\n\n\tVBITransactionRead::VBITransactionRead(void)\n\t: callback_()\n\t{\n\t}\n\n\tVBITransactionRead::~VBITransactionRead(void)\n\t{\n\t}\n\n\n\tVBITransactionWrite::VBITransactionWrite(void)\n\t: callback_()\n\t{\n\t}\n\n\tVBITransactionWrite::~VBITransactionWrite(void)\n\t{\n\t}\n\n\n\n\n\n\n\n\n\n\tVBITransactionCreateSubscription::VBITransactionCreateSubscription(void)\n\t: callback_()\n\t{\n\t}\n\n\tVBITransactionCreateSubscription::~VBITransactionCreateSubscription(void)\n\t{\n\t}\n\n\tVBITransactionDeleteSubscription::VBITransactionDeleteSubscription(void)\n\t: callback_()\n\t{\n\t}\n\n\tVBITransactionDeleteSubscription::~VBITransactionDeleteSubscription(void)\n\t{\n\t}\n\n\n\n\n\n\n\n\n\n\tVBITransactionCreateMonitoredItem::VBITransactionCreateMonitoredItem(void)\n\t: callback_()\n\t{\n\t}\n\n\tVBITransactionCreateMonitoredItem::~VBITransactionCreateMonitoredItem(void)\n\t{\n\t}\n\n\tVBITransactionDeleteMonitoredItem::VBITransactionDeleteMonitoredItem(void)\n\t: callback_()\n\t{\n\t}\n\n\tVBITransactionDeleteMonitoredItem::~VBITransactionDeleteMonitoredItem(void)\n\t{\n\t}\n\n}\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/ViewServiceTransaction.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ViewService.h'",
            "'OpcUaStack/src/OpcUaStackClient/ServiceSet/ServiceSetManager.h'",
            "'OpcUaStack/src/OpcUaStackClient/ValueBasedInterface/VBITransaction.h'",
            "'OpcUaStack/src/OpcUaStackClient/ValueBasedInterface/VBITransaction.cpp'"
        ]
    },
    {
        "files": [
            "'7-Zip-JBinding-4Android/sevenzipjbinding/src/main/cpp/p7zip/CPP/7zip/Compress/Lzham/lzhamcomp/lzham_pthreads_threading.cpp'",
            "'7-Zip-JBinding-4Android/sevenzipjbinding/src/main/cpp/p7zip/CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_core.h'",
            "'7-Zip-JBinding-4Android/sevenzipjbinding/src/main/cpp/p7zip/CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_config.h'"
        ],
        "content": "'7-Zip-JBinding-4Android/sevenzipjbinding/src/main/cpp/p7zip/CPP/7zip/Compress/Lzham/lzhamcomp/lzham_pthreads_threading.cpp'\n:\n\n#include \"lzham_core.h\"\n#include \"lzham_pthreads_threading.h\"\n#include \"lzham_timer.h\"\n\n#ifdef WIN32\n#include <process.h>\n#endif\n\n#if defined(__GNUC__) && !defined(__APPLE__) && !defined(__MINGW32__) && !defined(__FreeBSD__)\n#include <sys/sysinfo.h>\n#endif\n\n#if LZHAM_USE_PTHREADS_API\n\n#ifdef WIN32\n#pragma comment(lib, \"../ext/libpthread/lib/pthreadVC2.lib\")\n#endif\n\nnamespace lzham\n{\n   task_pool::task_pool(lzham_malloc_context malloc_context) :\n      m_task_stack(malloc_context),\n      m_num_threads(0),\n      m_tasks_available(0, 32767),\n      m_malloc_context(malloc_context),\n      m_num_outstanding_tasks(0),\n      m_exit_flag(false)\n   {\n      utils::zero_object(m_threads);\n   }\n\n   task_pool::task_pool(lzham_malloc_context malloc_context, uint num_threads) :\n      m_task_stack(malloc_context),\n      m_num_threads(0),\n      m_tasks_available(0, 32767),\n      m_malloc_context(malloc_context),\n      m_num_outstanding_tasks(0),\n      m_exit_flag(false)\n   {\n      utils::zero_object(m_threads);\n\n      bool status = init(num_threads);\n      LZHAM_VERIFY(status);\n   }\n\n   task_pool::~task_pool()\n   {\n      deinit();\n   }\n\n   bool task_pool::init(uint num_threads)\n   {\n      LZHAM_ASSERT(num_threads <= cMaxThreads);\n      num_threads = math::minimum<uint>(num_threads, cMaxThreads);\n\n      deinit();\n\n      bool succeeded = true;\n\n      m_num_threads = 0;\n      while (m_num_threads < num_threads)\n      {\n         int status = pthread_create(&m_threads[m_num_threads], NULL, thread_func, this);\n         if (status)\n         {\n            succeeded = false;\n            break;\n         }\n\n         m_num_threads++;\n      }\n\n      if (!succeeded)\n      {\n         deinit();\n         return false;\n      }\n\n      return true;\n   }\n\n   void task_pool::deinit()\n   {\n      if (m_num_threads)\n      {\n         join();\n\n         atomic_exchange32(&m_exit_flag, true);\n\n         m_tasks_available.release(m_num_threads);\n\n         for (uint i = 0; i < m_num_threads; i++)\n            pthread_join(m_threads[i], NULL);\n\n         m_num_threads = 0;\n\n         atomic_exchange32(&m_exit_flag, false);\n      }\n\n      m_task_stack.clear();\n      m_num_outstanding_tasks = 0;\n   }\n\n   bool task_pool::queue_task(task_callback_func pFunc, uint64 data, void* pData_ptr)\n   {\n      LZHAM_ASSERT(m_num_threads);\n      LZHAM_ASSERT(pFunc);\n\n      task tsk;\n      tsk.m_callback = pFunc;\n      tsk.m_data = data;\n      tsk.m_pData_ptr = pData_ptr;\n      tsk.m_flags = 0;\n\n      if (!m_task_stack.try_push(tsk))\n         return false;\n\n      atomic_increment32(&m_num_outstanding_tasks);\n\n      m_tasks_available.release(1);\n\n      return true;\n   }\n\n\n   bool task_pool::queue_task(executable_task* pObj, uint64 data, void* pData_ptr)\n   {\n      LZHAM_ASSERT(m_num_threads);\n      LZHAM_ASSERT(pObj);\n\n      task tsk;\n      tsk.m_pObj = pObj;\n      tsk.m_data = data;\n      tsk.m_pData_ptr = pData_ptr;\n      tsk.m_flags = cTaskFlagObject;\n\n      if (!m_task_stack.try_push(tsk))\n         return false;\n\n      atomic_increment32(&m_num_outstanding_tasks);\n\n      m_tasks_available.release(1);\n\n      return true;\n   }\n\n   void task_pool::process_task(task& tsk)\n   {\n      if (tsk.m_flags & cTaskFlagObject)\n         tsk.m_pObj->execute_task(tsk.m_data, tsk.m_pData_ptr);\n      else\n         tsk.m_callback(tsk.m_data, tsk.m_pData_ptr);\n\n      atomic_decrement32(&m_num_outstanding_tasks);\n   }\n\n   void task_pool::join()\n   {\n      task tsk;\n      while (atomic_add32(&m_num_outstanding_tasks, 0) > 0)\n      {\n         if (m_task_stack.pop(tsk))\n         {\n            process_task(tsk);\n         }\n         else\n         {\n            lzham_sleep(1);\n         }\n      }\n   }\n\n   void * task_pool::thread_func(void *pContext)\n   {\n      task_pool* pPool = static_cast<task_pool*>(pContext);\n      task tsk;\n\n      for ( ; ; )\n      {\n         if (!pPool->m_tasks_available.wait())\n            break;\n\n         if (pPool->m_exit_flag)\n            break;\n\n         if (pPool->m_task_stack.pop(tsk))\n         {\n            pPool->process_task(tsk);\n         }\n      }\n\n      return NULL;\n   }\n\n   uint lzham_get_max_helper_threads()\n   {\n#if defined(__APPLE__) || defined(__FreeBSD__)\n      int num_procs = static_cast<int>(sysconf(_SC_NPROCESSORS_ONLN));\n      return (num_procs >= 1) ? (num_procs - 1) : 0;\n#elif (1)\n      uint num_procs = get_nprocs();\n      return num_procs ? (num_procs - 1) : 0;\n#else\n      printf(\"TODO: lzham_get_max_helper_threads(): Implement system specific func to determine the max # of helper threads\\n\");\n\n      return 1;\n#endif\n   }\n\n}\n\n#endif\n\n'7-Zip-JBinding-4Android/sevenzipjbinding/src/main/cpp/p7zip/CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_core.h'\n:\n\n#pragma once\n\n#if defined(_MSC_VER)\n   #pragma warning (disable: 4127)\n#endif\n\n\n#ifndef LZHAM_ERROR_LOGGING\n    #define LZHAM_ERROR_LOGGING 0\n#endif\n\n\n#ifndef LZHAM_VERBOSE_ERROR_LOGGING\n    #define LZHAM_VERBOSE_ERROR_LOGGING 0\n#endif\n\n\n\n\n#if defined(__FreeBSD__) || defined(__NetBSD__)\n\n   #define LZHAM_ANSI_CPLUSPLUS 1\n#endif\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n   #include <TargetConditionals.h>\n#endif\n\n#if defined(_XBOX) && !defined(LZHAM_ANSI_CPLUSPLUS)\n\n   #include <xtl.h>\n   #define _HAS_EXCEPTIONS 0\n   #define NOMINMAX\n\n   #define LZHAM_PLATFORM_X360 1\n   #define LZHAM_USE_WIN32_API 1\n   #define LZHAM_USE_WIN32_ATOMIC_FUNCTIONS 1\n   #define LZHAM_64BIT_POINTERS 0\n   #define LZHAM_CPU_HAS_64BIT_REGISTERS 1\n   #define LZHAM_BIG_ENDIAN_CPU 1\n   #define LZHAM_USE_UNALIGNED_INT_LOADS 1\n   #define LZHAM_RESTRICT __restrict\n   #define LZHAM_FORCE_INLINE __forceinline\n   #define LZHAM_NOTE_UNUSED(x) (void)x\n\n   #define LZHAM_PRIi64 \"I64i\"\n   #define LZHAM_PRIu64 \"I64u\"\n\n#elif defined(WIN32) && !defined(LZHAM_ANSI_CPLUSPLUS)\n\n   #ifdef NDEBUG\n\n      #define _SECURE_SCL 0\n      #define _HAS_ITERATOR_DEBUGGING 0\n   #endif\n   #ifndef _DLL\n\n\n      #define _HAS_EXCEPTIONS 0\n   #endif\n   #define NOMINMAX\n\n    #ifndef _WIN32_WINNT\n      #define _WIN32_WINNT 0x500\n   #endif\n\n   #ifndef WIN32_LEAN_AND_MEAN\n      #define WIN32_LEAN_AND_MEAN\n   #endif\n\n   #include <windows.h>\n\n   #define LZHAM_USE_WIN32_API 1\n\n   #if defined(__MINGW32__) || defined(__MINGW64__)\n      #define LZHAM_USE_GCC_ATOMIC_BUILTINS 1\n   #else\n      #define LZHAM_USE_WIN32_ATOMIC_FUNCTIONS 1\n   #endif\n\n   #define LZHAM_PLATFORM_PC 1\n\n   #ifdef _WIN64\n      #define LZHAM_PLATFORM_PC_X64 1\n      #define LZHAM_64BIT_POINTERS 1\n      #define LZHAM_CPU_HAS_64BIT_REGISTERS 1\n      #define LZHAM_LITTLE_ENDIAN_CPU 1\n   #else\n      #define LZHAM_PLATFORM_PC_X86 1\n      #define LZHAM_64BIT_POINTERS 0\n      #define LZHAM_CPU_HAS_64BIT_REGISTERS 0\n      #define LZHAM_LITTLE_ENDIAN_CPU 1\n   #endif\n\n   #define LZHAM_USE_UNALIGNED_INT_LOADS 1\n   #define LZHAM_RESTRICT __restrict\n   #define LZHAM_FORCE_INLINE __forceinline\n\n   #if defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)\n      #define LZHAM_USE_MSVC_INTRINSICS 1\n   #endif\n\n   #define LZHAM_NOTE_UNUSED(x) (void)x\n\n   #define LZHAM_PRIi64 \"I64i\"\n   #define LZHAM_PRIu64 \"I64u\"\n\n#elif defined(__APPLE__) && !defined(LZHAM_ANSI_CPLUSPLUS)\n\n   #if (TARGET_IPHONE_SIMULATOR == 1) || (TARGET_OS_IPHONE == 1)\n      #define LZHAM_PLATFORM_PC 0\n\n      #if defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__)\n         #define LZHAM_PLATFORM_PC_X64 0\n         #define LZHAM_64BIT_POINTERS 1\n         #define LZHAM_CPU_HAS_64BIT_REGISTERS 1\n      #else\n         #define LZHAM_PLATFORM_PC_X86 0\n         #define LZHAM_64BIT_POINTERS 0\n         #define LZHAM_CPU_HAS_64BIT_REGISTERS 0\n      #endif\n\n      #define LZHAM_USE_UNALIGNED_INT_LOADS 0\n\n      #if __BIG_ENDIAN__\n         #define LZHAM_BIG_ENDIAN_CPU 1\n      #else\n         #define LZHAM_LITTLE_ENDIAN_CPU 1\n      #endif\n\n      #define LZHAM_USE_PTHREADS_API 1\n      #define LZHAM_USE_GCC_ATOMIC_BUILTINS 1\n\n      #define LZHAM_RESTRICT\n\n      #if defined(__clang__)\n         #define LZHAM_FORCE_INLINE inline\n      #else\n         #define LZHAM_FORCE_INLINE inline __attribute__((__always_inline__,__gnu_inline__))\n      #endif\n\n      #define LZHAM_NOTE_UNUSED(x) (void)x\n\n      #define LZHAM_PRIi64 PRIi64\n      #define LZHAM_PRIu64 PRIu64\n\n   #elif (TARGET_OS_MAC == 1)\n      #define LZHAM_PLATFORM_PC 1\n\n      #if defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__)\n         #define LZHAM_PLATFORM_PC_X64 1\n         #define LZHAM_64BIT_POINTERS 1\n         #define LZHAM_CPU_HAS_64BIT_REGISTERS 1\n      #else\n         #define LZHAM_PLATFORM_PC_X86 1\n         #define LZHAM_64BIT_POINTERS 0\n         #define LZHAM_CPU_HAS_64BIT_REGISTERS 0\n      #endif\n\n      #define LZHAM_USE_UNALIGNED_INT_LOADS 1\n\n      #if __BIG_ENDIAN__\n         #define LZHAM_BIG_ENDIAN_CPU 1\n      #else\n         #define LZHAM_LITTLE_ENDIAN_CPU 1\n      #endif\n\n      #define LZHAM_USE_PTHREADS_API 1\n      #define LZHAM_USE_GCC_ATOMIC_BUILTINS 1\n\n      #define LZHAM_RESTRICT\n\n      #if defined(__clang__)\n         #define LZHAM_FORCE_INLINE inline\n      #else\n         #define LZHAM_FORCE_INLINE inline __attribute__((__always_inline__,__gnu_inline__))\n      #endif\n\n      #define LZHAM_NOTE_UNUSED(x) (void)x\n\n      #define LZHAM_PRIi64 PRIi64\n      #define LZHAM_PRIu64 PRIu64\n   #elif\n      #error TODO: Unknown Apple target\n   #endif\n\n#elif (defined(__linux__) || defined(__CYGWIN__) ) && (defined(__i386__) || defined(__x86_64__)) && !defined(LZHAM_ANSI_CPLUSPLUS)\n\n   #define LZHAM_PLATFORM_PC 1\n\n   #if defined(_LP64) || defined(__LP64__) || defined(__x86_64__)\n\n      #define LZHAM_PLATFORM_PC_X64 1\n      #define LZHAM_64BIT_POINTERS 1\n      #define LZHAM_CPU_HAS_64BIT_REGISTERS 1\n   #else\n      #define LZHAM_PLATFORM_PC_X86 1\n      #define LZHAM_64BIT_POINTERS 0\n      #define LZHAM_CPU_HAS_64BIT_REGISTERS 0\n   #endif\n\n   #define LZHAM_USE_UNALIGNED_INT_LOADS 1\n\n   #if __BIG_ENDIAN__\n      #define LZHAM_BIG_ENDIAN_CPU 1\n   #else\n      #define LZHAM_LITTLE_ENDIAN_CPU 1\n   #endif\n\n   #define LZHAM_USE_PTHREADS_API 1\n   #define LZHAM_USE_GCC_ATOMIC_BUILTINS 1\n\n   #define LZHAM_RESTRICT\n\n   #if defined(__clang__)\n      #define LZHAM_FORCE_INLINE inline\n   #else\n      #define LZHAM_FORCE_INLINE inline __attribute__((__always_inline__,__gnu_inline__))\n   #endif\n\n   #define LZHAM_NOTE_UNUSED(x) (void)x\n\n   #define LZHAM_PRIi64 PRIi64\n   #define LZHAM_PRIu64 PRIu64\n#else\n\n#ifndef _MSC_VER\n   #warning Building as vanilla ANSI-C/C++, multi-threaded compression is disabled! Please configure lzhamdecomp/lzham_core.h.\n#endif\n\n\n\n   #if defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__)\n      #define LZHAM_64BIT_POINTERS 1\n      #define LZHAM_CPU_HAS_64BIT_REGISTERS 1\n   #else\n      #define LZHAM_64BIT_POINTERS 0\n      #define LZHAM_CPU_HAS_64BIT_REGISTERS 0\n   #endif\n\n   #define LZHAM_USE_UNALIGNED_INT_LOADS 0\n\n   #if __BIG_ENDIAN__\n      #define LZHAM_BIG_ENDIAN_CPU 1\n   #else\n      #define LZHAM_LITTLE_ENDIAN_CPU 1\n   #endif\n\n   #define LZHAM_USE_GCC_ATOMIC_BUILTINS 0\n   #define LZHAM_USE_WIN32_ATOMIC_FUNCTIONS 0\n\n   #define LZHAM_RESTRICT\n   #define LZHAM_FORCE_INLINE inline\n\n   #define LZHAM_NOTE_UNUSED(x) (void)x\n\n   #define LZHAM_PRIi64 PRIi64\n   #define LZHAM_PRIu64 PRIu64\n#endif\n\n#if LZHAM_LITTLE_ENDIAN_CPU\n   const bool c_lzham_little_endian_platform = true;\n#else\n   const bool c_lzham_little_endian_platform = false;\n#endif\n\nconst bool c_lzham_big_endian_platform = !c_lzham_little_endian_platform;\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#if !defined(__APPLE__) && !defined(__FreeBSD__)\n#include <malloc.h>\n#endif\n#include <stdarg.h>\n#include <memory.h>\n#include <limits.h>\n#include <algorithm>\n#include <errno.h>\n\n#ifndef _MSC_VER\n   #ifndef __STDC_FORMAT_MACROS\n      #define __STDC_FORMAT_MACROS\n   #endif\n\n   #include <inttypes.h>\n#endif\n\n#include \"lzham.h\"\n#include \"lzham_config.h\"\n#include \"lzham_types.h\"\n#include \"lzham_assert.h\"\n#include \"lzham_platform.h\"\n\n#include \"lzham_helpers.h\"\n#include \"lzham_traits.h\"\n#include \"lzham_mem.h\"\n#include \"lzham_math.h\"\n#include \"lzham_utils.h\"\n#include \"lzham_vector.h\"\n\n'7-Zip-JBinding-4Android/sevenzipjbinding/src/main/cpp/p7zip/CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_config.h'\n:\n\n#pragma once\n\n#if defined(_DEBUG) || defined(DEBUG)\n   #define LZHAM_BUILD_DEBUG\n\n   #ifndef DEBUG\n      #define DEBUG\n   #endif\n#else\n   #define LZHAM_BUILD_RELEASE\n\n   #ifndef NDEBUG\n      #define NDEBUG\n   #endif\n\n   #ifdef DEBUG\n      #error DEBUG cannot be defined in LZHAM_BUILD_RELEASE\n   #endif\n#endif\n\n\n#define LZHAM_BUFFERED_PRINTF 0\n#define LZHAM_PERF_SECTIONS 0",
        "gt": [
            "'7-Zip-JBinding-4Android/sevenzipjbinding/src/main/cpp/p7zip/CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_config.h'",
            "'7-Zip-JBinding-4Android/sevenzipjbinding/src/main/cpp/p7zip/CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_core.h'",
            "'7-Zip-JBinding-4Android/sevenzipjbinding/src/main/cpp/p7zip/CPP/7zip/Compress/Lzham/lzhamcomp/lzham_pthreads_threading.cpp'"
        ]
    },
    {
        "files": [
            "'LittleEngineVk/engine/include/le/graphics/renderer.hpp'",
            "'LittleEngineVk/engine/include/le/engine.hpp'",
            "'LittleEngineVk/engine/include/le/graphics/swapchain.hpp'",
            "'LittleEngineVk/scene/src/freecam_controller.cpp'"
        ],
        "content": "'LittleEngineVk/engine/include/le/graphics/renderer.hpp'\n:#pragma once\n#include <le/core/inclusive_range.hpp>\n#include <le/core/mono_instance.hpp>\n#include <le/graphics/cache/descriptor_cache.hpp>\n#include <le/graphics/cache/pipeline_cache.hpp>\n#include <le/graphics/cache/sampler_cache.hpp>\n#include <le/graphics/cache/scratch_buffer_cache.hpp>\n#include <le/graphics/cache/vertex_buffer_cache.hpp>\n#include <le/graphics/dear_imgui.hpp>\n#include <le/graphics/defer.hpp>\n#include <le/graphics/fallback.hpp>\n#include <le/graphics/render_frame.hpp>\n#include <le/graphics/swapchain.hpp>\n#include <optional>\n#include <span>\n\nnamespace le::graphics {\nstruct RenderTarget {\n\tImageView colour{};\n\tImageView depth{};\n};\n\nclass Renderer : public MonoInstance<Renderer> {\n  public:\n\tstatic constexpr auto to_vsync_string(vk::PresentModeKHR mode) -> std::string_view;\n\n\tRenderer(Renderer const&) = delete;\n\tRenderer(Renderer&&) = delete;\n\tauto operator=(Renderer const&) -> Renderer& = delete;\n\tauto operator=(Renderer&&) -> Renderer& = delete;\n\n\texplicit Renderer(glm::uvec2 framebuffer_extent);\n\t~Renderer();\n\n\t[[nodiscard]] static constexpr auto to_viewport(glm::vec2 extent) -> vk::Viewport { return vk::Viewport{0.0f, 0.0f, extent.x, extent.y}; }\n\t[[nodiscard]] static constexpr auto to_rect2d(vk::Viewport const& rect) -> vk::Rect2D;\n\n\t[[nodiscard]] auto get_frame_index() const -> FrameIndex { return m_frame.frame_index; }\n\t[[nodiscard]] auto get_colour_format() const -> vk::Format;\n\t[[nodiscard]] auto get_depth_format() const -> vk::Format;\n\n\t[[nodiscard]] auto get_pipeline_cache() const -> PipelineCache const& { return m_pipeline_cache; }\n\t[[nodiscard]] auto get_pipeline_cache() -> PipelineCache& { return m_pipeline_cache; }\n\t[[nodiscard]] auto get_pipeline_format() const -> PipelineFormat { return {get_colour_format(), get_depth_format()}; }\n\t[[nodiscard]] auto get_shader_layout() const -> ShaderLayout const& { return m_pipeline_cache.shader_layout(); }\n\t[[nodiscard]] auto get_dear_imgui() const -> DearImGui& { return *m_imgui; }\n\t[[nodiscard]] auto get_line_width_limit() const -> InclusiveRange<float> { return m_line_width_limit; }\n\n\t[[nodiscard]] auto wait_for_frame(glm::uvec2 framebuffer_extent) -> std::optional<std::uint32_t>;\n\tauto render(RenderFrame const& render_frame, std::uint32_t image_index) -> std::uint32_t;\n\tauto submit_frame(std::uint32_t image_index) -> bool;\n\n\t[[nodiscard]] auto get_supported_present_modes() const -> std::span<vk::PresentModeKHR const> { return m_swapchain.present_modes; }\n\t[[nodiscard]] auto get_present_mode() const -> vk::PresentModeKHR { return m_swapchain.create_info.presentMode; }\n\n\tauto recreate_swapchain(std::optional<glm::uvec2> extent, std::optional<vk::PresentModeKHR> mode) -> bool;\n\tauto recreate_swapchain(glm::uvec2 const extent) -> bool { return recreate_swapchain(extent, {}); }\n\tauto recreate_swapchain(vk::PresentModeKHR const mode) -> bool { return recreate_swapchain({}, mode); }\n\n\tauto set_imgui(std::unique_ptr<DearImGui> imgui) -> void { m_imgui = std::move(imgui); }\n\n\tauto bind_pipeline(vk::Pipeline pipeline) -> bool;\n\tauto set_viewport(vk::Viewport viewport = {}) -> bool;\n\tauto set_scissor(vk::Rect2D scissor) -> bool;\n\n\tstd::optional<glm::vec2> custom_world_frustum{};\n\tglm::vec3 shadow_frustum{100.0f};\n\tvk::Extent2D shadow_map_extent{2048, 2048};\n\tvk::PolygonMode polygon_mode{vk::PolygonMode::eFill};\n\n  private:\n\tstruct Frame {\n\t\tstruct Sync {\n\t\t\tvk::UniqueSemaphore draw{};\n\t\t\tvk::UniqueSemaphore present{};\n\t\t\tvk::UniqueFence drawn{};\n\t\t\tvk::UniqueCommandPool command_pool{};\n\t\t\tvk::CommandBuffer command_buffer{};\n\t\t};\n\n\t\tBuffered<std::unique_ptr<Image>> depth_images{};\n\t\tBuffered<std::unique_ptr<Image>> shadow_maps{};\n\t\tBuffered<Sync> syncs{};\n\t\tFrameIndex frame_index{};\n\n\t\tglm::uvec2 framebuffer_extent{};\n\t\tglm::uvec2 backbuffer_extent{};\n\t\tglm::mat4 primary_light_mat{1.0f};\n\t\tvk::Pipeline last_bound{};\n\n\t\tstatic auto make(vk::Device device, std::uint32_t queue_family, vk::Format depth_format) -> Frame;\n\t};\n\n\tstruct Std430Instance {\n\t\tglm::mat4 transform;\n\t\tglm::vec4 tint;\n\t};\n\n\t[[nodiscard]] auto acquire_next_image(glm::uvec2 framebuffer_extent) -> std::optional<std::uint32_t>;\n\tauto bake_objects(std::span<RenderObject const> objects, std::vector<RenderObject::Baked>& out) -> void;\n\tauto bake_objects(RenderFrame const& render_frame) -> void;\n\n\tstd::unique_ptr<DearImGui> m_imgui{};\n\tPipelineCache m_pipeline_cache{};\n\tSamplerCache m_sampler_cache{};\n\tDescriptorCache m_descriptor_cache{};\n\tScratchBufferCache m_scratch_buffer_cache{};\n\tVertexBufferCache m_vertex_buffer_cache{};\n\tSwapchain m_swapchain{};\n\tFrame m_frame{};\n\tDeferQueue m_defer{};\n\n\tFallback m_fallback{};\n\n\tstd::vector<Std430Instance> m_instances{};\n\tstd::vector<RenderObject::Baked> m_scene_objects{};\n\tstd::vector<RenderObject::Baked> m_ui_objects{};\n\tInclusiveRange<float> m_line_width_limit{};\n\n\tbool m_rendering{};\n};\n\nconstexpr auto Renderer::to_vsync_string(vk::PresentModeKHR const mode) -> std::string_view {\n\tswitch (mode) {\n\tcase vk::PresentModeKHR::eFifo: return \"classic\";\n\tcase vk::PresentModeKHR::eFifoRelaxed: return \"adaptive\";\n\tcase vk::PresentModeKHR::eMailbox: return \"mailbox\";\n\tcase vk::PresentModeKHR::eImmediate: return \"immediate\";\n\tdefault: return \"unsupported\";\n\t}\n}\n\nconstexpr auto Renderer::to_rect2d(vk::Viewport const& rect) -> vk::Rect2D {\n\tglm::ivec2 const offset = glm::vec2{rect.x, rect.y};\n\tglm::uvec2 const extent = glm::vec2{rect.width, rect.height};\n\treturn vk::Rect2D{{offset.x, offset.y}, {extent.x, extent.y}};\n}\n}\n\n'LittleEngineVk/engine/include/le/engine.hpp'\n:#pragma once\n#include <GLFW/glfw3.h>\n#include <glm/vec2.hpp>\n#include <glm/vec4.hpp>\n#include <le/audio/device.hpp>\n#include <le/core/time.hpp>\n#include <le/environment.hpp>\n#include <le/frame_profile.hpp>\n#include <le/graphics/device.hpp>\n#include <le/graphics/renderer.hpp>\n#include <le/input/state.hpp>\n#include <le/resources/resources.hpp>\n#include <le/stats.hpp>\n#include <le/vfs/vfs.hpp>\n#include <memory>\n#include <optional>\n#include <string>\n\nnamespace le {\nclass Engine : public MonoInstance<Engine> {\n\tstruct ConstructTag {};\n\n  public:\n\tclass Builder;\n\n\tEngine(Engine const&) = delete;\n\tEngine(Engine&&) = delete;\n\tauto operator=(Engine const&) -> Engine& = delete;\n\tauto operator=(Engine&&) -> Engine& = delete;\n\n\t~Engine();\n\n\t[[nodiscard]] auto get_window() const -> GLFWwindow const* { return m_window.get(); }\n\t[[nodiscard]] auto get_window() -> GLFWwindow* { return m_window.get(); }\n\n\t[[nodiscard]] auto framebuffer_extent() const -> glm::uvec2;\n\t[[nodiscard]] auto window_extent() const -> glm::uvec2;\n\n\t[[nodiscard]] auto delta_time() const -> Duration;\n\t[[nodiscard]] auto input_state() const -> input::State const&;\n\n\t[[nodiscard]] auto frame_profile() const -> FrameProfile const&;\n\n\t[[nodiscard]] auto is_running() const -> bool { return glfwWindowShouldClose(m_window.get()) != GLFW_TRUE; }\n\t[[nodiscard]] auto next_frame() -> bool;\n\tauto render(graphics::RenderFrame const& frame) -> void;\n\tauto shutdown() -> void;\n\n\t[[nodiscard]] auto get_stats() const -> Stats const& { return m_stats; }\n\n\tauto request_present_mode(vk::PresentModeKHR mode) -> bool;\n\n\tEngine([[maybe_unused]] ConstructTag tag) noexcept {}\n\n\tDuration min_frame_time{};\n\n  private:\n\tstatic auto get_engine(GLFWwindow* window) -> Engine&;\n\n\tauto setup_signals(GLFWwindow* window) -> void;\n\tauto update_stats() -> void;\n\tauto update_gamepads() -> void;\n\n\tstruct Deleter {\n\t\tvoid operator()(GLFWwindow* ptr) const;\n\t};\n\n\tstd::unique_ptr<Resources> m_resources{};\n\n\tstd::unique_ptr<GLFWwindow, Deleter> m_window{};\n\tstd::unique_ptr<graphics::Device> m_graphics_device{};\n\tstd::unique_ptr<graphics::Renderer> m_renderer{};\n\tstd::unique_ptr<audio::Device> m_audio_device{};\n\n\tinput::State m_input_state{};\n\n\tstd::optional<std::uint32_t> m_image_index{};\n\tDeltaTime m_delta_time{};\n\tStats m_stats{};\n\n\tstruct {\n\t\tDuration elapsed{};\n\t\tstd::uint32_t frames{};\n\t} m_fps{};\n\n\tstruct {\n\t\tstd::optional<vk::PresentModeKHR> present_mode{};\n\t} m_queued_ops{};\n};\n\nclass Engine::Builder {\n  public:\n\tstatic constexpr auto default_extent_v{glm::uvec2{1280, 720}};\n\n\texplicit Builder(std::string title) : m_title(std::move(title)) {}\n\n\tauto set_extent(glm::uvec2 value) -> Builder&;\n\tauto set_shader_layout(graphics::ShaderLayout shader_layout) -> Builder&;\n\n\t[[nodiscard]] auto build() -> std::unique_ptr<Engine>;\n\n  private:\n\tstd::optional<graphics::ShaderLayout> m_shader_layout{};\n\tstd::string m_title{};\n\tglm::uvec2 m_extent{default_extent_v};\n};\n}\n\n'LittleEngineVk/engine/include/le/graphics/swapchain.hpp'\n:#pragma once\n#include <glm/vec2.hpp>\n#include <le/graphics/image_view.hpp>\n#include <algorithm>\n#include <deque>\n#include <optional>\n#include <span>\n#include <vector>\n\nnamespace le::graphics {\nstruct Swapchain {\n\tstruct Formats {\n\t\tstd::vector<vk::SurfaceFormatKHR> srgb{};\n\t\tstd::vector<vk::SurfaceFormatKHR> linear{};\n\n\t\tstatic auto make(std::span<vk::SurfaceFormatKHR const> available) -> Formats;\n\t};\n\n\tstruct Storage {\n\t\tstd::vector<ImageView> images{};\n\t\tstd::vector<vk::UniqueImageView> views{};\n\t\tvk::UniqueSwapchainKHR swapchain{};\n\t\tglm::uvec2 extent{};\n\t\tstd::optional<std::size_t> image_index{};\n\t};\n\n\tstatic constexpr auto srgb_formats_v = std::array{vk::Format::eR8G8B8A8Srgb, vk::Format::eB8G8R8A8Srgb, vk::Format::eA8B8G8R8SrgbPack32};\n\n\tstatic constexpr auto is_srgb_format(vk::Format const format) { return std::ranges::find(srgb_formats_v, format) != srgb_formats_v.end(); }\n\n\t[[nodiscard]] auto make_create_info(vk::SurfaceKHR surface, std::uint32_t queue_family) const -> vk::SwapchainCreateInfoKHR;\n\n\tFormats formats{};\n\tstd::vector<vk::PresentModeKHR> present_modes{};\n\tvk::SwapchainCreateInfoKHR create_info{};\n\tStorage active{};\n\tstd::deque<Storage> retired{};\n};\n}\n\n'LittleEngineVk/scene/src/freecam_controller.cpp'\n:#include <imgui.h>\n#include <le/engine.hpp>\n#include <le/scene/entity.hpp>\n#include <le/scene/freecam_controller.hpp>\n#include <le/scene/scene.hpp>\n\n#include <le/core/logger.hpp>\n\nnamespace le {\nvoid FreecamController::tick(Duration dt) {\n\tauto data = get_scene().main_camera.transform.data();\n\tauto* window = Engine::self().get_window();\n\tauto const& input = Engine::self().input_state();\n\n\tif (input.mouse_buttons[GLFW_MOUSE_BUTTON_RIGHT] == input::Action::eHold) {\n\t\tglfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\t} else {\n\t\tglfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n\t}\n\n\tauto dxy = glm::vec2{};\n\tauto const input_mode = glfwGetInputMode(window, GLFW_CURSOR);\n\n\tif (input_mode != GLFW_CURSOR_DISABLED) {\n\t\tm_prev_cursor = input.cursor_position;\n\t} else {\n\t\tdxy = input.cursor_position - m_prev_cursor;\n\t\tdxy.y = -dxy.y;\n\t\tauto const d_pitch_yaw = look_speed * glm::vec2{glm::radians(dxy.y), glm::radians(dxy.x)};\n\t\tpitch.value -= d_pitch_yaw.x;\n\t\tyaw.value -= d_pitch_yaw.y;\n\n\t\tauto dxyz = glm::vec3{};\n\t\tauto front = data.orientation * front_v;\n\t\tauto right = data.orientation * right_v;\n\t\tauto up = data.orientation * up_v;\n\n\t\tif (input.keyboard[GLFW_KEY_W] == input::Action::eHold) { dxyz.z -= 1.0f; }\n\t\tif (input.keyboard[GLFW_KEY_S] == input::Action::eHold) { dxyz.z += 1.0f; }\n\t\tif (input.keyboard[GLFW_KEY_A] == input::Action::eHold) { dxyz.x -= 1.0f; }\n\t\tif (input.keyboard[GLFW_KEY_D] == input::Action::eHold) { dxyz.x += 1.0f; }\n\t\tif (input.keyboard[GLFW_KEY_Q] == input::Action::eHold) { dxyz.y -= 1.0f; }\n\t\tif (input.keyboard[GLFW_KEY_E] == input::Action::eHold) { dxyz.y += 1.0f; }\n\t\tif (std::abs(dxyz.x) > 0.0f || std::abs(dxyz.y) > 0.0f || std::abs(dxyz.z) > 0.0f) {\n\t\t\tdxyz = glm::normalize(dxyz);\n\t\t\tauto const factor = dt.count() * move_speed;\n\t\t\tdata.position += factor * front * dxyz.z;\n\t\t\tdata.position += factor * right * dxyz.x;\n\t\t\tdata.position += factor * up * dxyz.y;\n\t\t}\n\t}\n\n\tdata.orientation = glm::vec3{pitch, yaw, 0.0f};\n\tm_prev_cursor = input.cursor_position;\n\n\tget_scene().main_camera.transform.set_data(data);\n}\n}\n",
        "gt": [
            "'LittleEngineVk/engine/include/le/graphics/swapchain.hpp'",
            "'LittleEngineVk/engine/include/le/graphics/renderer.hpp'",
            "'LittleEngineVk/engine/include/le/engine.hpp'",
            "'LittleEngineVk/scene/src/freecam_controller.cpp'"
        ]
    },
    {
        "files": [
            "'LearnVulkan/source/base/VulkanBaseEngine.h'",
            "'LearnVulkan/examples/03_QtVulkan/21_QtVulkanSceneDemo/ShadowMapping.h'",
            "'LearnVulkan/Android/app/src/main/cpp/native-lib.cpp'",
            "'LearnVulkan/source/core/VulkanContext.h'",
            "'LearnVulkan/source/engines/ThirdPersonEngine.h'"
        ],
        "content": "'LearnVulkan/source/base/VulkanBaseEngine.h'\n:\n\n\n\n#ifndef LEARNVULKAN_VULKANBASEENGINE_H\n#define LEARNVULKAN_VULKANBASEENGINE_H\n\n#include \"VulkanBase.h\"\n\n#include \"VulkanContext.h\"\n#include \"VulkanDescriptorSet.h\"\n#include \"VulkanVertexDescriptions.h\"\n#include \"VulkanPipelines.h\"\n\n#ifdef __ANDROID__\nnamespace vks{\nclass UIOverlay;\n}\n#else\n#include \"VulkanUIOverlay.h\"\n#endif\n\nBEGIN_NAMESPACE(VulkanEngine)\n\nclass VULKANENGINE_EXPORT_API VulkanBaseEngine : public VulkanBase {\npublic:\n    VulkanBaseEngine() = default;\n\n    virtual ~VulkanBaseEngine();\n\n    virtual void initWindow();\n\n    virtual void prepare() override;\n\n    virtual void render() override;\n\n    virtual void updateOverlay() override;\n\n    virtual void drawUI(const VkCommandBuffer commandBuffer);\n\n    virtual void OnUpdateUIOverlay(vks::UIOverlay *overlay) {}\n\n    virtual void processPrepareCallback() {}\n\n    virtual void updateCommand();\n\n    void renderAsyncThread();\n\n    void renderJoin();\n\nprotected:\n    void prepareIMGUI();\n\n    void prepareDescriptorSets();\n\n    void prepareVertexDescriptions();\n\n    void prepareBasePipelines();\n\n    void prepareContext();\n\n    virtual void prepareMyObjects() {};\n\n    virtual void buildCommandBuffersBeforeMainRenderPass(VkCommandBuffer &cmd) {}\n\n    virtual void buildCommandBuffers() override;\n\n    virtual void buildCommandBuffersAfterMainRenderPass(VkCommandBuffer &cmd) {}\n\n    virtual void setViewPorts(VkCommandBuffer &cmd);\n\n    virtual void buildMyObjects(VkCommandBuffer &cmd) {};\n\n    template<class T>\n    void REGISTER_OBJECT(std::shared_ptr<T> &obj) {\n        obj = VkObject::New<T>(m_context);\n        m_objs.emplace_back(obj);\n    }\n\n    void destroyObjects() {\n        for (auto &obj : m_objs) {\n            obj = nullptr;\n        }\n    }\n\n    VkPipelineShaderStageCreateInfo\n    loadShader(const std::string &fileName, const VkShaderStageFlagBits &stage);\n\nprotected:\n    int m_maxSets = 1;\n\n    VulkanDescriptorSet *m_vulkanDescriptorSet = nullptr;\n    VulkanVertexDescriptions *m_vulkanVertexDescriptions = nullptr;\n    VulkanPipelines *m_pipelines = nullptr;\n    VulkanContext *m_context = nullptr;\n    VkPipelineLayout m_pipelineLayout = VK_NULL_HANDLE;\n\n#ifndef __ANDROID__\n    vks::UIOverlay m_UIOverlay;\n#endif\n\n    std::vector<std::shared_ptr<VkObject>> m_objs;\n\n    struct Settings {\n        bool overlay = true;\n    } m_settings;\n\n    bool m_rebuild = false;\n\n    std::thread *m_thread = nullptr;\n};\n\nEND_NAMESPACE(VulkanEngine)\n\n#endif\n\n'LearnVulkan/examples/03_QtVulkan/21_QtVulkanSceneDemo/ShadowMapping.h'\n:\n\n\n\n#ifndef LEARNVULKAN_SHADOWMAPPING_H\n#define LEARNVULKAN_SHADOWMAPPING_H\n\n#include \"ThirdPersonEngine.h\"\n\nBEGIN_NAMESPACE(VulkanEngine)\n\nclass VulkanCube;\n\nclass VulkanVertFragShader;\n\nclass UniformCamera;\n\nclass VulkanTexture2D;\n\nclass VulkanTextureCubeMap;\n\nclass VulkanPlane;\n\nclass VulkanFrameBuffer;\n\nclass ShadowCamera;\n\nclass ReflectParaBuffer;\n\nclass ShadowMapping : public ThirdPersonEngine {\npublic:\n    ShadowMapping() = default;\n\n    ~ShadowMapping() noexcept;\n\n    void prepareFunctions() override;\n\n    void prepareMyObjects() override;\n\n    void buildMyObjects(VkCommandBuffer &cmd) override;\n\n    void render() override;\n\n    void setDescriptorSet();\n\n    void createPipelines();\n\n    void createCube();\n\n    void createSkybox();\n\n    void createPlane();\n\n    void createShadowFrameBuffer();\n\n    void createDebugQuad();\n\n    void createReflectParaBuffer();\n\n    void buildCommandBuffersBeforeMainRenderPass(VkCommandBuffer &cmd) override;\n\n    void seeDebugQuad();\n\n    void OnUpdateUIOverlay(vks::UIOverlay *overlay) override;\n\n    void setReflect(float value);\n\nprotected:\n    std::shared_ptr<VulkanCube> m_cube = nullptr;\n    std::shared_ptr<VulkanVertFragShader> m_cubeShader = nullptr;\n    std::shared_ptr<UniformCamera> m_cubeUniform = nullptr;\n    std::shared_ptr<VulkanTexture2D> m_cubeTextureA = nullptr;\n    std::shared_ptr<VulkanTexture2D> m_cubeTextureB = nullptr;\n\n    std::shared_ptr<VulkanCube> m_sky = nullptr;\n    std::shared_ptr<VulkanVertFragShader> m_skyShader = nullptr;\n    std::shared_ptr<VulkanTextureCubeMap> m_skyTexture = nullptr;\n\n    std::shared_ptr<VulkanPlane> m_plane = nullptr;\n    std::shared_ptr<VulkanVertFragShader> m_planeShader = nullptr;\n    std::shared_ptr<VulkanTexture2D> m_planeTexture = nullptr;\n\n    std::shared_ptr<VulkanFrameBuffer> m_frameBuffer = nullptr;\n    std::shared_ptr<VulkanVertFragShader> m_shadowShader = nullptr;\n    std::shared_ptr<ShadowCamera> m_shadowCamera = nullptr;\n\n    std::shared_ptr<VulkanPlane> m_dubugPlane = nullptr;\n    std::shared_ptr<VulkanVertFragShader> m_debugShader = nullptr;\n\n    std::shared_ptr<ReflectParaBuffer> m_reflectParaBuffer = nullptr;\n\n    bool m_seeDebug = false;\n};\n\nEND_NAMESPACE(VulkanEngine)\n\n#endif\n\n'LearnVulkan/Android/app/src/main/cpp/native-lib.cpp'\n:#include <jni.h>\n#include <string>\n\n#include \"VulkanBase.h\"\n#include \"StaticTriangle.h\"\n#include \"StaticCube.h\"\n#include \"Texture2dCube.h\"\n#include \"SkyboxCube.h\"\n#include \"PhongLighting.h\"\n#include \"InstanceDraw.h\"\n#include \"ShadowMapping.h\"\n#include \"ShadowMappingOnmi.h\"\n#include \"AssimpModelSample.h\"\n\nenum VulkanExampleNames {\n    Example_StaticTriangle = 0,\n    Example_StaticCube,\n    Example_Texture2dCube,\n    Example_SkyboxCube,\n    Example_PhongLighting,\n    Example_InstanceDraw,\n    Example_ShadowMapping,\n    Example_ShadowMappingOnmi,\n    Example_AssimpModelSample,\n};\n\nextern \"C\"\nJNIEXPORT jlong JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_createInstance(JNIEnv *env, jobject thiz,\n                                                                   jint id) {\n    if(id == Example_StaticTriangle){\n        auto *engine = new VulkanEngine::StaticTriangle();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_StaticCube){\n        auto *engine = new VulkanEngine::StaticCube();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_Texture2dCube){\n        auto *engine = new VulkanEngine::Texture2dCube();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_SkyboxCube){\n        auto *engine = new VulkanEngine::SkyboxCube();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_PhongLighting){\n        auto *engine = new VulkanEngine::PhongLighting();\n        return (jlong) engine;\n    }\n    else if(id == Example_InstanceDraw){\n        auto *engine = new VulkanEngine::InstanceDraw();\n        return (jlong) engine;\n    }\n    else if(id == Example_ShadowMapping){\n        auto *engine = new VulkanEngine::ShadowMapping();\n        return (jlong) engine;\n    }\n    else if(id == Example_ShadowMappingOnmi){\n        auto *engine = new VulkanEngine::ShadowMappingOnmi();\n        return (jlong) engine;\n    }\n    else if(id == Example_AssimpModelSample) {\n        auto *engine = new VulkanEngine::AssimpModelSample();\n        return (jlong) engine;\n    }\n    else{\n        auto *engine = new VulkanEngine::StaticTriangle();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_initVulkan(JNIEnv *env, jobject thiz,\n                                                               jlong instance) {\n\n    if (instance){\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase*>(instance);\n        engine->initVulkan();\n        engine->prepare();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_renderFrame(JNIEnv *env, jobject thiz,\n                                                                jlong instance) {\n\n    if (instance){\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase*>(instance);\n        engine->renderFrame();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setSurface(JNIEnv *env, jobject thiz,\n                                                               jlong instance, jobject surface) {\n\n    auto window = ANativeWindow_fromSurface(env, surface);\n\n    assert(window);\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = (VulkanEngine::VulkanBase *) instance;\n        LOGI(\"New Surface %ld\", window);\n        engine->setWindow(window);\n        uint32_t width = static_cast<uint32_t >(ANativeWindow_getWidth(window));\n        uint32_t height = static_cast<uint32_t >(ANativeWindow_getHeight(window));\n        engine->setWidth(width);\n        engine->setHeight(height);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setAssetManager(JNIEnv *env, jobject thiz,\n                                                                    jlong instance,\n                                                                    jobject asset_manager) {\n\n    auto asset = AAssetManager_fromJava(env, asset_manager);\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setAssetManager(asset);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setTouchPos(JNIEnv *env, jobject thiz,\n                                                                jlong instance, jfloat x,\n                                                                jfloat y) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setTouchPos(x, y);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setTouchPosSecond(JNIEnv *env, jobject thiz,\n                                                                      jlong instance, jfloat x,\n                                                                      jfloat y) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setTouchPosSecond(x, y);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setTouchMode(JNIEnv *env, jobject thiz,\n                                                                 jlong instance, jint mode) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setTouchMode(VulkanEngine::VulkanBase::TouchMode(mode));\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_resetTouch(JNIEnv *env, jobject thiz,\n                                                               jlong instance) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->resetTouch();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_deleteVulkan(JNIEnv *env, jobject thiz,\n                                                                 jlong instance, jint id) {\n\n    if (instance) {\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine*>(instance);\n        delete (engine);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_destroySurface(JNIEnv *env, jobject thiz,\n                                                                   jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->destroySurface();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_rebuildSurface(JNIEnv *env, jobject thiz,\n                                                                   jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->rebuildSurface();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_pause(JNIEnv *env, jobject thiz,\n                                                          jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->pause();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_resume(JNIEnv *env, jobject thiz,\n                                                           jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->resume();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_waitCurrentFrameComplete(JNIEnv *env,\n                                                                             jobject thiz,\n                                                                             jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->waitForCurrentFrameComplete();\n        LOGI(\"waitForCurrentFrameComplete\");\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_destroyANativeWindow(JNIEnv *env, jobject thiz,\n                                                                         jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->destroyANativeWindow();\n        LOGI(\"destroyANativeWindow\");\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_runFunction(JNIEnv *env, jobject thiz,\n                                                            jlong instance, jint i) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->runFunction(i);\n    }\n}\n'LearnVulkan/source/core/VulkanContext.h'\n:\n\n\n\n#ifndef LEARNVULKAN_VULKANCONTEXT_H\n#define LEARNVULKAN_VULKANCONTEXT_H\n\n#include \"render_common.h\"\n\nBEGIN_NAMESPACE(VulkanEngine)\n\nstruct VULKANENGINE_EXPORT_API VulkanContext {\n    vks::VulkanDevice *vulkanDevice = nullptr;\n    VkCommandBuffer copyCmd = VK_NULL_HANDLE;\n    VkCommandPool cmdPool = VK_NULL_HANDLE;\n    VkPipelineLayout *pPipelineLayout = nullptr;\n    VkPipelineCache pipelineCache = VK_NULL_HANDLE;\n    VkRenderPass renderPass = VK_NULL_HANDLE;\n    VkQueue queue = VK_NULL_HANDLE;\n    uint32_t *pScreenWidth = nullptr;\n    uint32_t *pScreenHeight = nullptr;\n\n#ifdef __ANDROID__\n    AAssetManager *m_asset = nullptr;\n#endif\n\n    VkDevice &getDevice(){\n        return vulkanDevice->logicalDevice;\n    }\n\n    VkPhysicalDevice &getPhysicalDevice(){\n        return vulkanDevice->physicalDevice;\n    }\n};\n\nEND_NAMESPACE(VulkanEngine)\n\n#endif\n\n'LearnVulkan/source/engines/ThirdPersonEngine.h'\n:\n\n\n\n#ifndef LEARNVULKAN_THIRDPERSONENGINE_H\n#define LEARNVULKAN_THIRDPERSONENGINE_H\n\n#include \"VulkanBaseEngine.h\"\n#include \"ThirdPersonCamera.h\"\n\nBEGIN_NAMESPACE(VulkanEngine)\n\nclass VULKANENGINE_EXPORT_API ThirdPersonEngine : public VulkanBaseEngine , public ThirdPersonCamera {\npublic:\n    ThirdPersonEngine() = default;\n    virtual ~ThirdPersonEngine() {}\n\n    void updateCamera();\n};\n\nEND_NAMESPACE(VulkanEngine)\n\n#endif\n",
        "gt": [
            "'LearnVulkan/source/core/VulkanContext.h'",
            "'LearnVulkan/source/base/VulkanBaseEngine.h'",
            "'LearnVulkan/source/engines/ThirdPersonEngine.h'",
            "'LearnVulkan/examples/03_QtVulkan/21_QtVulkanSceneDemo/ShadowMapping.h'",
            "'LearnVulkan/Android/app/src/main/cpp/native-lib.cpp'"
        ]
    },
    {
        "files": [
            "'OpenSPH/gui/windows/ParticleProbe.cpp'",
            "'OpenSPH/core/quantities/Particle.h'",
            "'OpenSPH/gui/windows/ParticleProbe.h'"
        ],
        "content": "'OpenSPH/gui/windows/ParticleProbe.cpp'\n:#include \"gui/windows/ParticleProbe.h\"\n#include \"quantities/QuantityIds.h\"\n\nNAMESPACE_SPH_BEGIN\n\ninline String toName(const String& s) {\n    String name = s;\n    name.replaceAll(\"_\", \" \");\n    return capitalize(name);\n}\n\ninline String toKey(const String& s) {\n    return split(s, '.').back();\n}\n\nvoid ParticleProbe::onMenu(wxCommandEvent& UNUSED(evt)) {\n    if (!particle) {\n        return;\n    }\n\n    if (!wxTheClipboard->Open()) {\n        return;\n    }\n    wxTheClipboard->Clear();\n\n    for (Particle::QuantityData data : particle->getQuantities()) {\n        std::stringstream ss;\n        if (data.id == QuantityId::POSITION) {\n            if (!data.dt.empty()) {\n                ss << data.dt;\n                wxTheClipboard->SetData(new wxTextDataObject(ss.str()));\n            }\n            continue;\n        }\n        if (!data.value.empty()) {\n            std::stringstream ss;\n            ss << data.value;\n            wxTheClipboard->SetData(new wxTextDataObject(ss.str()));\n        }\n    }\n\n    wxTheClipboard->Flush();\n    wxTheClipboard->Close();\n}\n\nvoid ParticleProbe::onPaint(wxPaintEvent& UNUSED(evt)) {\n    wxAutoBufferedPaintDC dc(this);\n    wxSize canvasSize = this->GetClientSize();\n\n\n    Rgba backgroundColor = Rgba(this->GetParent()->GetBackgroundColour());\n    wxBrush brush;\n    brush.SetColour(wxColour(backgroundColor.darken(0.3f)));\n    dc.SetBrush(brush);\n    dc.DrawRectangle(wxPoint(0, 0), canvasSize);\n\n    if (!particle) {\n        return;\n    }\n\n\n    brush.SetColour(wxColour(color));\n    dc.SetBrush(brush);\n    wxPoint offset(config.leftSkip, config.topSkip);\n    dc.DrawRectangle(offset, wxSize(15, 15));\n\n\n    const bool isLightTheme = backgroundColor.intensity() > 0.5_f;\n    if (isLightTheme) {\n        dc.SetTextForeground(wxColour(Rgba(0.2f, 0.2f, 0.2f)));\n    } else {\n        dc.SetTextForeground(wxColour(Rgba(0.8f, 0.8f, 0.8f)));\n    }\n    dc.DrawText(\"Particle \" + std::to_string(particle->getIndex()), wxPoint(24, 4));\n\n\n    const Vector position = particle->getValue(QuantityId::POSITION);\n    drawTextWithSubscripts(\n        dc, L\"x = \" + toPrintableString(position[X]), offset + wxSize(0, 1 * config.lineSkip));\n    drawTextWithSubscripts(\n        dc, L\"y = \" + toPrintableString(position[Y]), offset + wxSize(0, 2 * config.lineSkip));\n    drawTextWithSubscripts(\n        dc, L\"z = \" + toPrintableString(position[Z]), offset + wxSize(0, 3 * config.lineSkip));\n\n    Dynamic velocityValue = particle->getDt(QuantityId::POSITION);\n    Dynamic accelerationValue = particle->getD2t(QuantityId::POSITION);\n    if (velocityValue) {\n        const Vector velocity = velocityValue;\n        const Size x = canvasSize.x / 2;\n        drawTextWithSubscripts(\n            dc, L\"v_x = \" + toPrintableString(velocity[X]), offset + wxSize(x, 1 * config.lineSkip));\n        drawTextWithSubscripts(\n            dc, L\"v_y = \" + toPrintableString(velocity[Y]), offset + wxSize(x, 2 * config.lineSkip));\n        drawTextWithSubscripts(\n            dc, L\"v_z = \" + toPrintableString(velocity[Z]), offset + wxSize(x, 3 * config.lineSkip));\n    } else if (accelerationValue) {\n        const Vector acceleration = accelerationValue;\n        const Size x = canvasSize.x / 2;\n        drawTextWithSubscripts(\n            dc, L\"dv_x = \" + toPrintableString(acceleration[X]), offset + wxSize(x, 1 * config.lineSkip));\n        drawTextWithSubscripts(\n            dc, L\"dv_y = \" + toPrintableString(acceleration[Y]), offset + wxSize(x, 2 * config.lineSkip));\n        drawTextWithSubscripts(\n            dc, L\"dv_z = \" + toPrintableString(acceleration[Z]), offset + wxSize(x, 3 * config.lineSkip));\n    }\n\n    offset.y += 4 * config.lineSkip;\n\n\n    for (Particle::QuantityData data : particle->getQuantities()) {\n        if (data.id == QuantityId::POSITION) {\n\n            continue;\n        }\n\n\n\n\n        SPH_ASSERT(!data.value.empty());\n        const DynamicId id = data.value.getType();\n        const String label = getMetadata(data.id).label;\n        switch (id) {\n        case DynamicId::FLOAT:\n\n\n            drawTextWithSubscripts(dc, label + L\" = \" + toPrintableString(data.value.get<Float>()), offset);\n            offset.y += config.lineSkip;\n            break;\n        case DynamicId::SIZE:\n            drawTextWithSubscripts(dc, label + L\" = \" + toString(data.value.get<Size>()), offset);\n            offset.y += config.lineSkip;\n            break;\n        case DynamicId::VECTOR: {\n            const Vector vector = data.value;\n            this->printVector(dc, vector, label, offset);\n            offset.y += 3 * config.lineSkip;\n            break;\n        }\n        case DynamicId::TRACELESS_TENSOR: {\n            const TracelessTensor tensor = data.value;\n            this->printTensor(dc, tensor, label, offset);\n            offset.y += 6 * config.lineSkip;\n            break;\n        }\n        case DynamicId::SYMMETRIC_TENSOR: {\n            const SymmetricTensor tensor = data.value;\n            this->printTensor(dc, tensor, label, offset);\n            offset.y += 6 * config.lineSkip;\n            break;\n        }\n        case DynamicId::STRING: {\n            drawTextWithSubscripts(dc, toKey(label) + \" = \" + toName(data.value.get<String>()), offset);\n            offset.y += config.lineSkip;\n            break;\n        }\n\n        default:\n\n            break;\n        }\n    }\n\n    for (const Particle::ParamData& data : particle->getParameters()) {\n        String label = BodySettings::getEntryName(data.id).value();\n        const DynamicId id = data.value.getType();\n        switch (id) {\n        case DynamicId::STRING:\n            drawTextWithSubscripts(dc, toKey(label) + \" = \" + toName(data.value.get<String>()), offset);\n            offset.y += config.lineSkip;\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nvoid ParticleProbe::printVector(wxDC& dc, const Vector& v, const String& label, const wxPoint offset) const {\n    drawTextWithSubscripts(\n        dc, label + L\"_x = \" + toPrintableString(v[X]), offset + wxSize(0, 0 * config.lineSkip));\n    drawTextWithSubscripts(\n        dc, label + L\"_y = \" + toPrintableString(v[Y]), offset + wxSize(0, 1 * config.lineSkip));\n    drawTextWithSubscripts(\n        dc, label + L\"_z = \" + toPrintableString(v[Z]), offset + wxSize(0, 2 * config.lineSkip));\n}\n\ntemplate <typename Type>\nvoid ParticleProbe::printTensor(wxDC& dc,\n    const Type& tensor,\n    const String& label,\n    const wxPoint offset) const {\n    const Size x = dc.GetSize().x / 2;\n    drawTextWithSubscripts(\n        dc, label + L\"_xx = \" + toPrintableString(tensor(X, X)), offset + wxSize(0, 0 * config.lineSkip));\n    drawTextWithSubscripts(\n        dc, label + L\"_yy = \" + toPrintableString(tensor(Y, Y)), offset + wxSize(0, 1 * config.lineSkip));\n    drawTextWithSubscripts(\n        dc, label + L\"_zz = \" + toPrintableString(tensor(Z, Z)), offset + wxSize(0, 2 * config.lineSkip));\n    drawTextWithSubscripts(\n        dc, label + L\"_xy = \" + toPrintableString(tensor(X, Y)), offset + wxSize(x, 0 * config.lineSkip));\n    drawTextWithSubscripts(\n        dc, label + L\"_xz = \" + toPrintableString(tensor(X, Z)), offset + wxSize(x, 1 * config.lineSkip));\n    drawTextWithSubscripts(\n        dc, label + L\"_yz = \" + toPrintableString(tensor(Y, Z)), offset + wxSize(x, 2 * config.lineSkip));\n}\n\nNAMESPACE_SPH_END\n\n'OpenSPH/core/quantities/Particle.h'\n:#pragma once\n\n#include \"objects/containers/FlatMap.h\"\n#include \"objects/utility/Dynamic.h\"\n#include \"system/Settings.h\"\n\nNAMESPACE_SPH_BEGIN\n\nclass Storage;\nenum class QuantityId;\n\n\n\n\n\n\nclass Particle {\n    friend struct ParticleVisitor;\n\nprivate:\n    Size idx;\n\n    struct InternalQuantityData {\n        Dynamic value;\n        Dynamic dt;\n        Dynamic d2t;\n    };\n\n    FlatMap<QuantityId, InternalQuantityData> quantities;\n\n    FlatMap<BodySettingsId, Dynamic> material;\n\npublic:\n\n\n\n    Particle() = default;\n\n\n\n\n    explicit Particle(const Size idx)\n        : idx(idx) {}\n\n\n\n\n\n    Particle(const Storage& storage, const Size idx);\n\n\n\n\n\n\n\n\n    Particle(const QuantityId id, const Dynamic& value, const Size idx);\n\n    Particle(const Particle& other);\n\n    Particle(Particle&& other);\n\n    Particle& operator=(const Particle& other);\n\n    Particle& operator=(Particle&& other);\n\n\n\n\n\n\n    Particle& addValue(const QuantityId id, const Dynamic& value);\n\n\n\n\n\n\n    Particle& addDt(const QuantityId id, const Dynamic& value);\n\n\n\n\n\n\n\n    Particle& addD2t(const QuantityId id, const Dynamic& value);\n\n\n\n\n\n    Particle& addParameter(const BodySettingsId id, const Dynamic& value);\n\n\n    INLINE Size getIndex() const {\n        return idx;\n    }\n\n\n\n\n    Dynamic getValue(const QuantityId id) const;\n\n\n\n\n    Dynamic getDt(const QuantityId id) const;\n\n\n\n\n\n    Dynamic getD2t(const QuantityId id) const;\n\n\n\n\n    Dynamic getParameter(const BodySettingsId id) const;\n\n\n\n\n    struct QuantityData {\n\n\n        QuantityId id;\n\n\n        DynamicId type;\n\n\n        Dynamic value;\n\n\n        Dynamic dt;\n\n\n        Dynamic d2t;\n    };\n\n\n    class QuantityIterator {\n    private:\n        using ActIterator = Iterator<const FlatMap<QuantityId, InternalQuantityData>::Element>;\n\n        ActIterator iter;\n\n    public:\n\n\n\n        QuantityIterator(const ActIterator iterator, Badge<Particle>);\n\n\n        QuantityIterator& operator++();\n\n\n        QuantityData operator*() const;\n\n\n        bool operator!=(const QuantityIterator& other) const;\n    };\n\n\n    class QuantitySequence {\n    private:\n        QuantityIterator first;\n        QuantityIterator last;\n\n    public:\n\n        QuantitySequence(const Particle& particle);\n\n\n        QuantityIterator begin() const;\n\n\n        QuantityIterator end() const;\n    };\n\n\n    QuantitySequence getQuantities() const;\n\n\n    struct ParamData {\n\n\n        BodySettingsId id;\n\n\n        Dynamic value;\n    };\n\n    class ParamIterator {\n    private:\n        using ActIterator = Iterator<const FlatMap<BodySettingsId, Dynamic>::Element>;\n\n        ActIterator iter;\n\n    public:\n\n\n\n        ParamIterator(const ActIterator iterator, Badge<Particle>);\n\n\n        ParamIterator& operator++();\n\n\n        ParamData operator*() const;\n\n\n        bool operator!=(const ParamIterator& other) const;\n    };\n\n\n    class ParamSequence {\n    private:\n        ParamIterator first;\n        ParamIterator last;\n\n    public:\n\n        ParamSequence(const Particle& particle);\n\n\n        ParamIterator begin() const;\n\n\n        ParamIterator end() const;\n    };\n\n\n    ParamSequence getParameters() const;\n};\n\nNAMESPACE_SPH_END\n\n'OpenSPH/gui/windows/ParticleProbe.h'\n:#pragma once\n\n\n\n\n\n\n#include \"gui/Utils.h\"\n#include \"gui/objects/Color.h\"\n#include \"quantities/Particle.h\"\n#include <wx/clipbrd.h>\n#include <wx/dcbuffer.h>\n#include <wx/menu.h>\n#include <wx/panel.h>\n#include <wx/textctrl.h>\n\nNAMESPACE_SPH_BEGIN\n\nclass ParticleProbe : public wxPanel {\nprivate:\n\n    Optional<Particle> particle;\n\n\n    Rgba color;\n\n    struct {\n\n\n        Size topSkip = 5;\n\n\n        Size leftSkip = 5;\n\n\n        Size lineSkip = 19;\n\n    } config;\n\npublic:\n    ParticleProbe(wxWindow* parent, const wxSize size)\n        : wxPanel(parent, wxID_ANY) {\n        this->SetMinSize(size);\n        this->SetBackgroundStyle(wxBG_STYLE_PAINT);\n\n\n        Connect(wxEVT_PAINT, wxPaintEventHandler(ParticleProbe::onPaint));\n        Connect(wxEVT_RIGHT_UP, wxMouseEventHandler(ParticleProbe::onRightUp));\n    }\n\n    void update(const Particle& selectedParticle, const Rgba colorizerColor) {\n        particle = selectedParticle;\n        color = colorizerColor;\n        this->Refresh();\n    }\n\n    void clear() {\n        particle = NOTHING;\n        this->Refresh();\n    }\n\nprivate:\n    void onRightUp(wxMouseEvent& UNUSED(evt)) {\n        wxMenu menu;\n        menu.Append(0, \"Copy to clipboard\");\n        menu.Connect(\n            wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(ParticleProbe::onMenu), nullptr, this);\n        this->PopupMenu(&menu);\n    }\n\n    void onMenu(wxCommandEvent& evt);\n\n    void onPaint(wxPaintEvent& evt);\n\n    void printVector(wxDC& dc, const Vector& v, const String& label, const wxPoint offset) const;\n\n    template <typename Type>\n    void printTensor(wxDC& dc, const Type& tensor, const String& label, const wxPoint offset) const;\n};\n\nNAMESPACE_SPH_END\n",
        "gt": [
            "'OpenSPH/core/quantities/Particle.h'",
            "'OpenSPH/gui/windows/ParticleProbe.h'",
            "'OpenSPH/gui/windows/ParticleProbe.cpp'"
        ]
    },
    {
        "files": [
            "'dynamodb-shell/ddbsh/expressions/logical_attribute_type.hpp'",
            "'dynamodb-shell/ddbsh/parser/keywords.cpp'",
            "'dynamodb-shell/ddbsh/parser/parser-defs.hpp'",
            "'dynamodb-shell/ddbsh/parser/keywords.hpp'"
        ],
        "content": "'dynamodb-shell/ddbsh/expressions/logical_attribute_type.hpp'\n:\n\n\n\n\n#ifndef __LOGICAL_ATTRIBUTE_TYPE_HPP_DEFINED__\n#define __LOGICAL_ATTRIBUTE_TYPE_HPP_DEFINED__\n\n#include <aws/dynamodb/model/ScalarAttributeType.h>\n\nnamespace ddbsh\n{\n    class CLogicalAttributeType : public CLogicalExpression\n    {\n    public:\n        CLogicalAttributeType(std::string * lhs, Aws::DynamoDB::Model::ScalarAttributeType attr_type) {\n            m_lhs = *lhs;\n            m_type = attr_type;\n            m_node_type = \"CLogicalAttributeType\";\n        };\n\n        int count(std::string lhs) {\n            return m_lhs == lhs ? 1 : 0;\n        };\n\n        ~CLogicalAttributeType() {\n            logdebug(\"[%s, %d] In %s\\n\", __FILENAME__, __LINE__, __FUNCTION__);\n        };\n\n    private:\n        std::string m_lhs;\n        Aws::DynamoDB::Model::ScalarAttributeType m_type;\n\n        std::string __serialize(CSymbolTable * st) {\n            std::string lhs = st ? st->new_attribute(m_lhs) : m_lhs;\n            std::string attype;\n\n            if (st)\n            {\n                Aws::DynamoDB::Model::AttributeValue av;\n                av.SetS(Aws::DynamoDB::Model::ScalarAttributeTypeMapper::GetNameForScalarAttributeType(m_type));\n                attype = st->new_value(av);\n            }\n            else\n                attype = Aws::DynamoDB::Model::ScalarAttributeTypeMapper::GetNameForScalarAttributeType(m_type);\n\n            return \"attribute_type(\" + lhs + \", \" + attype + \")\";\n        };\n\n        Aws::String __query_key_condition_expression(std::string pk, std::string rk, CSymbolTable * st) {\n            assert(this->__query_safe(pk, rk));\n            return \"\";\n        };\n\n        Aws::String __query_filter_expression(std::string pk, std::string rk, CSymbolTable * st) {\n            assert(this->__query_safe(pk, rk));\n            return this->__serialize(st);\n        };\n\n        Aws::String __update_delete_condition_check(std::string pk, std::string rk, CSymbolTable * st, bool top) {\n            return this->__serialize(st);\n        };\n\n        virtual bool __query_safe(std::string pk, std::string rk) {\n            if (m_lhs != pk && m_lhs != rk)\n                return true;\n\n            return false;\n        };\n    };\n};\n#endif\n\n'dynamodb-shell/ddbsh/parser/keywords.cpp'\n:\n\n\n\n\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include \"keywords.hpp\"\n#include \"logging.hpp\"\n\n\n\nstatic keywords_t keywords_table[] = {\n    { \"access\", K_ACCESS, \"K_ACCESS\" },\n    { \"add\", K_ADD, \"K_ADD\" },\n    { \"aes256\", K_AES256, \"K_AES256\" },\n    { \"all\", K_ALL, \"K_ALL\" },\n    { \"alter\", K_ALTER, \"K_ALTER\" },\n    { \"and\", K_AND, \"K_AND\" },\n    { \"as\", K_AS, \"K_AS\" },\n    { \"attribute_exists\", K_ATTRIBUTE_EXISTS, \"K_ATTRIBUTE_EXISTS\" },\n    { \"attribute_not_exists\", K_ATTRIBUTE_NOT_EXISTS, \"K_ATTRIBUTE_NOT_EXISTS\" },\n    { \"attribute_type\", K_ATTRIBUTE_TYPE, \"K_ATTRIBUTE_TYPE\" },\n    { \"backup\", K_BACKUP, \"K_BACKUP\" },\n    { \"backups\", K_BACKUPS, \"K_BACKUPS\" },\n    { \"begin\", K_BEGIN, \"K_BEGIN\" },\n    { \"begins_with\", K_BEGINS_WITH, \"K_BEGINS_WITH\" },\n    { \"between\", K_BETWEEN, \"K_BETWEEN\" },\n    { \"billing\", K_BILLING, \"K_BILLING\" },\n    { \"binary\", K_ATTRIBUTE_TYPE_BINARY, \"K_ATTRIBUTE_TYPE_BINARY\" },\n    { \"both\", K_BOTH, \"K_BOTH\" },\n    { \"brief\", K_BRIEF, \"K_BRIEF\" },\n    { \"called\", K_CALLED, \"K_CALLED\" },\n    { \"capacity\", K_CAPACITY, \"K_CAPACITY\" },\n    { \"check\", K_CHECK, \"K_CHECK\" },\n    { \"class\", K_CLASS, \"K_CLASS\" },\n    { \"commit\", K_COMMIT, \"K_COMMIT\" },\n    { \"connect\", K_CONNECT, \"K_CONNECT\" },\n    { \"consistent\", K_CONSISTENT, \"K_CONSISTENT\" },\n    { \"consumed\", K_CONSUMED, \"K_CONSUMED\" },\n    { \"contains\", K_CONTAINS, \"K_CONTAINS\" },\n    { \"create\", K_CREATE, \"K_CREATE\" },\n    { \"delete\", K_DELETE, \"K_DELETE\" },\n    { \"deletion\", K_DELETION, \"K_DELETION\" },\n    { \"demand\", K_DEMAND, \"K_DEMAND\" },\n    { \"describe\", K_DESCRIBE, \"K_DESCRIBE\" },\n    { \"disabled\", K_DISABLED, \"K_DISABLED\" },\n    { \"drop\", K_DROP, \"K_DROP\" },\n    { \"enabled\", K_ENABLED, \"K_ENABLED\" },\n    { \"end\", K_COMMIT, \"K_COMMIT\" },\n    { \"endpoint\", K_ENDPOINT, \"K_ENDPOINT\" },\n    { \"exists\", K_EXISTS, \"K_EXISTS\" },\n    { \"explain\", K_EXPLAIN, \"K_EXPLAIN\" },\n    { \"false\", K_FALSE, \"K_FALSE\" },\n    { \"from\", K_FROM, \"K_FROM\" },\n    { \"global\", K_GLOBAL, \"K_GLOBAL\" },\n    { \"gsi\", K_GSI, \"K_GSI\" },\n    { \"hash\", K_HASH, \"K_HASH\" },\n    { \"help\", K_HELP, \"K_HELP\" },\n    { \"if\", K_IF, \"K_IF\" },\n    { \"image\", K_IMAGE, \"K_IMAGE\" },\n    { \"images\", K_IMAGES, \"K_IMAGES\" },\n    { \"in\", K_IN, \"K_IN\" },\n    { \"include\", K_INCLUDE, \"K_INCLUDE\" },\n    { \"index\", K_INDEX, \"K_INDEX\" },\n    { \"indexes\", K_INDEXES, \"K_INDEXES\" },\n    { \"infrequent\", K_INFREQUENT, \"K_INFREQUENT\" },\n    { \"insert\", K_INSERT, \"K_INSERT\" },\n    { \"into\", K_INTO, \"K_INTO\" },\n    { \"is\", K_IS, \"K_IS\" },\n    { \"key\", K_KEY, \"K_KEY\" },\n    { \"keyid\", K_KEYID, \"K_KEYID\" },\n    { \"keys\", K_KEYS, \"K_KEYS\" },\n    { \"kms\", K_KMS, \"K_KMS\" },\n    { \"like\", K_LIKE, \"K_LIKE\" },\n    { \"limit\", K_LIMIT, \"K_LIMIT\" },\n    { \"limits\", K_LIMITS, \"K_LIMITS\" },\n    { \"lsi\", K_LSI, \"K_LSI\" },\n    { \"mode\", K_MODE, \"K_MODE\" },\n    { \"new\", K_NEW, \"K_NEW\" },\n    { \"not\", K_NOT, \"K_NOT\" },\n    { \"nowait\", K_NOWAIT, \"K_NOWAIT\" },\n    { \"null\", K_NULL, \"K_NULL\" },\n    { \"number\", K_ATTRIBUTE_TYPE_NUMBER, \"K_ATTRIBUTE_TYPE_NUMBER\" },\n    { \"numeric\", K_NUMBER, \"K_NUMBER\" },\n    { \"old\", K_OLD, \"K_OLD\" },\n    { \"on\", K_ON, \"K_ON\" },\n    { \"only\", K_ONLY, \"K_ONLY\" },\n    { \"or\", K_OR, \"K_OR\" },\n    { \"pitr\", K_PITR, \"K_PITR\" },\n    { \"prewarm\", K_PREWARM, \"K_PREWARM\" },\n    { \"primary\", K_PRIMARY, \"K_PRIMARY\" },\n    { \"projecting\", K_PROJECTING, \"K_PROJECTING\" },\n    { \"protection\", K_PROTECTION, \"K_PROTECTION\" },\n    { \"provisioned\", K_PROVISIONED, \"K_PROVISIONED\" },\n    { \"quit\", K_QUIT, \"K_QUIT\" },\n    { \"range\", K_RANGE, \"K_RANGE\" },\n    { \"ratelimit\", K_RATELIMIT, \"K_RATELIMIT\" },\n    { \"rcu\", K_RCU, \"K_RCU\" },\n    { \"remove\", K_REMOVE, \"K_REMOVE\"},\n    { \"replace\", K_REPLACE, \"K_REPLACE\" },\n    { \"replica\", K_REPLICA, \"K_REPLICA\" },\n    { \"restore\", K_RESTORE, \"K_RESTORE\" },\n    { \"return\", K_RETURN, \"K_RETURN\" },\n    { \"rollback\", K_ROLLBACK, \"K_ROLLBACK\" },\n    { \"select\", K_SELECT, \"K_SELECT\" },\n    { \"set\", K_SET, \"K_SET\" },\n    { \"show\", K_SHOW, \"K_SHOW\" },\n    { \"size\", K_SIZE, \"K_SIZE\" },\n    { \"sse\", K_SSE, \"K_SSE\" },\n    { \"standard\", K_STANDARD, \"K_STANDARD\" },\n    { \"stream\", K_STREAM, \"K_STREAM\" },\n    { \"string\", K_ATTRIBUTE_TYPE_STRING, \"K_ATTRIBUTE_TYPE_STRING\" },\n    { \"table\", K_TABLE, \"K_TABLE\" },\n    { \"tables\", K_TABLES, \"K_TABLES\" },\n    { \"tags\", K_TAGS, \"K_TAGS\" },\n    { \"throughput\", K_THROUGHPUT, \"K_THROUGHPUT\" },\n    { \"to\", K_TO, \"K_TO\" },\n    { \"total\", K_TOTAL, \"K_TOTAL\" },\n    { \"true\", K_TRUE, \"K_TRUE\" },\n    { \"ttl\", K_TTL, \"K_TTL\" },\n    { \"unlimited\", K_UNLIMITED, \"K_UNLIMITED\" },\n    { \"update\", K_UPDATE, \"K_UPDATE\" },\n    { \"updateD\", K_UPDATED, \"K_UPDATED\" },\n    { \"upsert\", K_UPSERT, \"K_UPSERT\" },\n    { \"values\", K_VALUES, \"K_VALUES\" },\n    { \"version\", K_VERSION, \"K_VERSION\" },\n    { \"wcu\", K_WCU, \"K_WCU\" },\n    { \"where\", K_WHERE, \"K_WHERE\" },\n    { \"with\", K_WITH, \"K_WITH\" },\n};\n\n\n\n\nint lookup_keyword (char * text, int * ptoken)\n{\n    int low, mid, high, cc;\n\n    logdebug(\"[%s, %d] Looking up %s\\n\", __FILENAME__, __LINE__, text);\n\n    low = 0;\n    high = sizeof(keywords_table)/sizeof(keywords_t) - 1;\n\n#define CHECK(ix) if (!(cc = strcasecmp(keywords_table[(ix)].keyword, text))) \\\n    {\\\n        *ptoken = keywords_table[(ix)].token;\\\n        logdebug(\"[%s, %d] Returning %s (%d) for keyword %s\\n\", \\\n                 __FILENAME__, __LINE__, keywords_table[(ix)].keyword,  \\\n                 ix, keywords_table[(ix)].token_string); \\\n        return 0; \\\n    }\n\n    CHECK(low);\n\n    CHECK(high);\n\n    if (strcasecmp(keywords_table[low].keyword, text) < 0 &&\n        strcasecmp(text, keywords_table[high].keyword) < 0)\n    {\n        while (low < high)\n        {\n            mid = (low + high)/2;\n\n            CHECK(mid);\n\n\n            if (cc < 0)\n            {\n                if (low == mid)\n                {\n                    logdebug(\"[%s, %d] Returning -1 for keyword %s\\n\",\n                             __FILENAME__, __LINE__, text);\n                    return -1;\n                }\n\n                low = mid;\n                continue;\n            }\n            else\n            {\n                if (high == mid)\n                {\n                    logdebug(\"[%s, %d] Returning -1 for keyword %s\\n\",\n                             __FILENAME__, __LINE__, text);\n                    return -1;\n                }\n\n                high = mid;\n                continue;\n            }\n        }\n    }\n\n    logdebug(\"[%s, %d] Returning -1 for keyword %s\\n\",\n             __FILENAME__, __LINE__, text);\n    return -1;\n}\n\n\n'dynamodb-shell/ddbsh/parser/parser-defs.hpp'\n:\n\n\n#ifndef __PARSER_H_DEFINED__\n#define __PARSER_H_DEFINED__\n\n#include \"aws-includes.hpp\"\n#include \"logical_expression.hpp\"\n#include \"logical_comparison.hpp\"\n#include \"logical_and.hpp\"\n#include \"logical_or.hpp\"\n#include \"logical_attribute_exists.hpp\"\n#include \"logical_attribute_type.hpp\"\n#include \"logical_begins_with.hpp\"\n#include \"logical_between.hpp\"\n#include \"logical_comparison.hpp\"\n#include \"logical_contains.hpp\"\n#include \"logical_in.hpp\"\n#include \"ratelimit.hpp\"\n#include \"where.hpp\"\n#include \"symbol_table.hpp\"\n#include \"update_set_element.hpp\"\n\ntypedef struct\n{\n    Aws::DynamoDB::Model::BillingMode mode;\n    Aws::DynamoDB::Model::ProvisionedThroughput throughput;\n    Aws::DynamoDB::Model::OnDemandThroughput od_throughput;\n} billing_mode_and_throughput_t;\n\n#endif\n\n'dynamodb-shell/ddbsh/parser/keywords.hpp'\n:\n\n\n\n\n#ifndef __KEYWORDS_HPP_DEFINED__\n#define __KEYWORDS_HPP_DEFINED__\n\n#include \"parser-defs.hpp\"\n#include \"command.hpp\"\n\nusing namespace ddbsh;\n#include \"parser.hpp\"\n\ntypedef struct\n{\n    const char * keyword;\n    int token;\n    const char * token_string;\n} keywords_t;\n\nint lookup_keyword (char * text, int * ptoken);\n\n#endif\n\n",
        "gt": [
            "'dynamodb-shell/ddbsh/expressions/logical_attribute_type.hpp'",
            "'dynamodb-shell/ddbsh/parser/parser-defs.hpp'",
            "'dynamodb-shell/ddbsh/parser/keywords.hpp'",
            "'dynamodb-shell/ddbsh/parser/keywords.cpp'"
        ]
    },
    {
        "files": [
            "'porla/src/main.cpp'",
            "'porla/src/methods/torrentspause_reqres.hpp'",
            "'porla/src/methods/torrentspause.hpp'"
        ],
        "content": "'porla/src/main.cpp'\n:#include <boost/asio.hpp>\n#include <boost/log/expressions.hpp>\n#include <boost/log/trivial.hpp>\n#include <curl/curl.h>\n#include <git2.h>\n#include <sodium.h>\n\n#include \"cmdargs.hpp\"\n#include \"config.hpp\"\n#include \"logger.hpp\"\n#include \"lua/pluginengine.hpp\"\n#include \"sessions.hpp\"\n#include \"tools/authtoken.hpp\"\n#include \"tools/generatesecretkey.hpp\"\n#include \"tools/versionjson.hpp\"\n#include \"utils/secretkey.hpp\"\n\n#include \"http/authinithandler.hpp\"\n#include \"http/authloginhandler.hpp\"\n#include \"http/eventshandler.hpp\"\n#include \"http/jsonrpchandler.hpp\"\n#include \"http/jwthandler.hpp\"\n#include \"http/metricshandler.hpp\"\n#include \"http/systemhandler.hpp\"\n#include \"http/webuihandler.hpp\"\n\n#include \"methods/fsspace.hpp\"\n#include \"methods/plugins/pluginsconfigure.hpp\"\n#include \"methods/plugins/pluginsget.hpp\"\n#include \"methods/plugins/pluginsinstall.hpp\"\n#include \"methods/plugins/pluginslist.hpp\"\n#include \"methods/plugins/pluginsreload.hpp\"\n#include \"methods/plugins/pluginsuninstall.hpp\"\n#include \"methods/plugins/pluginsupdate.hpp\"\n#include \"methods/presetslist.hpp\"\n#include \"methods/sessions/sessionslist.hpp\"\n#include \"methods/sessions/sessionspause.hpp\"\n#include \"methods/sessions/sessionsresume.hpp\"\n#include \"methods/sessions/sessionssettingslist.hpp\"\n#include \"methods/sysversions.hpp\"\n#include \"methods/torrentsadd.hpp\"\n#include \"methods/torrentsfileslist.hpp\"\n#include \"methods/torrentslist.hpp\"\n#include \"methods/torrentsmetadatalist.hpp\"\n#include \"methods/torrentsmove.hpp\"\n#include \"methods/torrentspause.hpp\"\n#include \"methods/torrentspeersadd.hpp\"\n#include \"methods/torrentspeerslist.hpp\"\n#include \"methods/torrentsrecheck.hpp\"\n#include \"methods/torrentsremove.hpp\"\n#include \"methods/torrentsresume.hpp\"\n#include \"methods/torrentspropertiesget.hpp\"\n#include \"methods/torrentspropertiesset.hpp\"\n#include \"methods/torrentstrackerslist.hpp\"\n\nint main(int argc, char* argv[])\n{\n    static std::map<std::string, std::function<int(int, char**, std::unique_ptr<porla::Config>)>> subcommands =\n    {\n        {\"auth:token\", &porla::Tools::AuthToken},\n        {\"key:generate\", &porla::Tools::GenerateSecretKey},\n        {\"version:json\", &porla::Tools::VersionJson}\n    };\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    git_libgit2_init();\n\n    const boost::program_options::variables_map cmd = porla::CmdArgs::Parse(argc, argv);\n\n    if (cmd.count(\"help\"))\n    {\n        return porla::CmdArgs::Help();\n    }\n\n    porla::Logger::Setup(cmd);\n\n    std::unique_ptr<porla::Config> cfg;\n\n    try\n    {\n        cfg = porla::Config::Load(cmd);\n    }\n    catch (const std::exception& ex)\n    {\n        BOOST_LOG_TRIVIAL(fatal) << \"Failed to load configuration\";\n        return -1;\n    }\n\n\n    if (argc >= 2 && subcommands.contains(argv[1]))\n    {\n        return subcommands.at(argv[1])(argc, argv, std::move(cfg));\n    }\n\n    boost::asio::io_context io;\n    boost::asio::signal_set signals(io, SIGINT, SIGTERM);\n\n    signals.async_wait(\n        [&io](boost::system::error_code const& ec, int signal)\n        {\n            BOOST_LOG_TRIVIAL(info) << \"Interrupt received (\" << signal << \") - stopping...\";\n            io.stop();\n        });\n\n    {\n        porla::Sessions sessions(porla::SessionsOptions{\n            .db = cfg->db,\n            .io = io\n        });\n\n        for (const auto& [name, settings] : cfg->sessions)\n        {\n            BOOST_LOG_TRIVIAL(info) << \"Loading session \" << name;\n\n            const auto state_dir = cfg->state_dir.value_or(fs::current_path());\n\n            const auto session_params_file_name = name == \"default\" ? \"session.dat\" : \"session.\" + name + \".dat\";\n            const auto session_params_file      = state_dir / session_params_file_name;\n\n            try\n            {\n                sessions.Load(porla::SessionsLoadOptions{\n                    .name                = name,\n                    .session_params_file = session_params_file,\n                    .settings            = settings\n                });\n            }\n            catch (const std::exception &ex)\n            {\n                BOOST_LOG_TRIVIAL(error) << \"Failed to load session \" << name << \": \" << ex.what();\n\n                if (name == \"default\")\n                {\n                    return -1;\n                }\n            }\n        }\n\n\n        porla::Lua::PluginEngine plugin_engine{porla::Lua::PluginEngineOptions{\n            .config   = *cfg,\n            .db       = cfg->db,\n            .io       = io,\n            .sessions = sessions\n        }};\n\n        const fs::path default_plugin_install_dir = cfg->state_dir.value_or(fs::path()) / \"installed_plugins\";\n\n        const porla::Methods::PluginsInstallOptions plugins_install_options{\n            .allow_git     = cfg->plugins_allow_git.value_or(false),\n            .install_dir   = cfg->plugins_install_dir.value_or(default_plugin_install_dir),\n            .io            = io,\n            .plugin_engine = plugin_engine\n        };\n\n        const porla::Methods::PluginsUpdateOptions plugins_update_options{\n            .io            = io,\n            .plugin_engine = plugin_engine\n        };\n\n        porla::Http::JsonRpcHandler rpc({\n            {\"fs.space\", porla::Methods::FsSpace()},\n            {\"plugins.configure\", porla::Methods::PluginsConfigure(plugin_engine)},\n            {\"plugins.get\", porla::Methods::PluginsGet(plugin_engine)},\n            {\"plugins.install\", porla::Methods::PluginsInstall(plugins_install_options)},\n            {\"plugins.list\", porla::Methods::PluginsList(plugin_engine)},\n            {\"plugins.reload\", porla::Methods::PluginsReload(plugin_engine)},\n            {\"plugins.uninstall\", porla::Methods::PluginsUninstall(plugin_engine)},\n            {\"plugins.update\", porla::Methods::PluginsUpdate(plugins_update_options)},\n            {\"presets.list\", porla::Methods::PresetsList(cfg->presets)},\n            {\"sessions.list\", porla::Methods::SessionsList(sessions)},\n            {\"sessions.pause\", porla::Methods::SessionsPause(sessions)},\n            {\"sessions.resume\", porla::Methods::SessionsResume(sessions)},\n            {\"sessions.settings.list\", porla::Methods::SessionsSettingsList(sessions)},\n            {\"sys.versions\", porla::Methods::SysVersions()},\n            {\"torrents.add\", porla::Methods::TorrentsAdd(sessions, cfg->presets)},\n            {\"torrents.files.list\", porla::Methods::TorrentsFilesList(sessions)},\n            {\"torrents.list\", porla::Methods::TorrentsList(sessions)},\n            {\"torrents.metadata.list\", porla::Methods::TorrentsMetadataList(cfg->db, sessions)},\n            {\"torrents.move\", porla::Methods::TorrentsMove(sessions)},\n            {\"torrents.pause\", porla::Methods::TorrentsPause(sessions)},\n            {\"torrents.peers.add\", porla::Methods::TorrentsPeersAdd(sessions)},\n            {\"torrents.peers.list\", porla::Methods::TorrentsPeersList(sessions)},\n            {\"torrents.properties.get\", porla::Methods::TorrentsPropertiesGet(sessions)},\n            {\"torrents.properties.set\", porla::Methods::TorrentsPropertiesSet(sessions)},\n            {\"torrents.recheck\", porla::Methods::TorrentsRecheck(sessions)},\n            {\"torrents.remove\", porla::Methods::TorrentsRemove(sessions)},\n            {\"torrents.resume\", porla::Methods::TorrentsResume(sessions)},\n            {\"torrents.trackers.list\", porla::Methods::TorrentsTrackersList(sessions)}\n        });\n\n        std::string http_base_path = cfg->http_base_path.value_or(\"/\");\n        if (http_base_path.empty())        http_base_path = \"/\";\n        if (http_base_path[0] != '/')      http_base_path = \"/\" + http_base_path;\n        if (http_base_path.ends_with(\"/\")) http_base_path = http_base_path.substr(0, http_base_path.size() - 1);\n\n        uWS::Loop::get(&io);\n\n        uWS::App http_server;\n        http_server.post(http_base_path + \"/api/v1/auth/init\", porla::Http::AuthInitHandler(io, cfg->db, cfg->sodium_memlimit.value_or(crypto_pwhash_MEMLIMIT_MIN)));\n        http_server.post(http_base_path + \"/api/v1/auth/login\", porla::Http::AuthLoginHandler(porla::Http::AuthLoginHandlerOptions{\n            .db         = cfg->db,\n            .io         = io,\n            .secret_key = cfg->secret_key\n        }));\n\n        http_server.get(http_base_path + \"/api/v1/events\",\n            cfg->http_auth_enabled.value_or(true)\n                ? static_cast<porla::Http::Handler>(porla::Http::JwtHandler(cfg->secret_key, porla::Http::EventsHandler(sessions)))\n                : static_cast<porla::Http::Handler>(porla::Http::EventsHandler(sessions)));\n\n        http_server.post(http_base_path + \"/api/v1/jsonrpc\",\n            cfg->http_auth_enabled.value_or(true)\n                ? static_cast<porla::Http::Handler>(porla::Http::JwtHandler(cfg->secret_key, rpc))\n                : static_cast<porla::Http::Handler>(rpc));\n\n        http_server.get(http_base_path + \"/api/v1/system\", porla::Http::SystemHandler(cfg->db));\n\n        if (cfg->http_metrics_enabled.value_or(true))\n        {\n            BOOST_LOG_TRIVIAL(info) << \"Enabling HTTP metrics endpoint\";\n            http_server.get(http_base_path + \"/metrics\", porla::Http::MetricsHandler(sessions));\n        }\n\n        if (cfg->http_webui_enabled.value_or(true))\n        {\n            BOOST_LOG_TRIVIAL(info) << \"Enabling HTTP web UI\";\n            http_server.get(http_base_path + \"/*\", porla::Http::WebUIHandler(http_base_path));\n        }\n\n        http_server.listen(\n            cfg->http_host.value_or(\"127.0.0.1\"),\n            cfg->http_port.value_or(1337),\n            [](const auto* t)\n            {\n                BOOST_LOG_TRIVIAL(info) << \"HTTP server listening\";\n            });\n\n        io.run();\n\n        plugin_engine.UnloadAll();\n    }\n\n    git_libgit2_shutdown();\n    curl_global_cleanup();\n\n    return 0;\n}\n\n'porla/src/methods/torrentspause_reqres.hpp'\n:#pragma once\n\n#include <libtorrent/info_hash.hpp>\n\nnamespace porla::Methods\n{\n    struct TorrentsPauseReq\n    {\n        libtorrent::info_hash_t info_hash;\n    };\n\n    struct TorrentsPauseRes {};\n}\n\n'porla/src/methods/torrentspause.hpp'\n:#pragma once\n\n#include \"method.hpp\"\n#include \"torrentspause_reqres.hpp\"\n\nnamespace porla\n{\n    class Sessions;\n}\n\nnamespace porla::Methods\n{\n    class TorrentsPause : public Method<TorrentsPauseReq, TorrentsPauseRes>\n    {\n    public:\n        explicit TorrentsPause(Sessions& session);\n\n    protected:\n        void Invoke(const TorrentsPauseReq& req, WriteCb<TorrentsPauseRes> cb) override;\n\n    private:\n        Sessions& m_sessions;\n    };\n}\n",
        "gt": [
            "'porla/src/methods/torrentspause_reqres.hpp'",
            "'porla/src/methods/torrentspause.hpp'",
            "'porla/src/main.cpp'"
        ]
    },
    {
        "files": [
            "'sigviewer/src/gui/application_context.h'",
            "'sigviewer/src/gui_impl/commands/adapt_channel_view_gui_command.h'",
            "'sigviewer/src/gui_impl/commands/adapt_channel_view_gui_command.cpp'",
            "'sigviewer/src/gui/gui_action_command.h'"
        ],
        "content": "'sigviewer/src/gui/application_context.h'\n:\n\n\n\n\n#ifndef APPLICATION_CONTEXT_H\n#define APPLICATION_CONTEXT_H\n\n#include \"color_manager.h\"\n#include \"main_window_model.h\"\n#include \"tab_context.h\"\n\n#include <QSharedPointer>\n\nnamespace sigviewer\n{\n\nenum ApplicationMode\n{\n    APPLICATION_TEST_MODE,\n    APPLICATION_NON_GUI_MODE\n};\n\n\n\nclass ApplicationContext\n{\npublic:\n\n    virtual ~ApplicationContext () {}\n\n\n    virtual bool modeActivated (ApplicationMode mode) const = 0;\n\n\n    virtual QSharedPointer<FileContext> getCurrentFileContext () = 0;\n\n\n    virtual void removeCurrentFileContext () = 0;\n\n\n    virtual void addFileContext (QSharedPointer<FileContext>file_context) = 0;\n\n\n    virtual void setCurrentTabContext (QSharedPointer<TabContext> tab_context) = 0;\n\n\n    virtual QSharedPointer<CommandExecuter> getCurrentCommandExecuter () = 0;\n\n\n    virtual QSharedPointer<MainWindowModel> getMainWindowModel () = 0;\n\n\n    virtual QSharedPointer<ColorManager> getEventColorManager () = 0;\n};\n\n}\n\n#endif\n\n'sigviewer/src/gui_impl/commands/adapt_channel_view_gui_command.h'\n:\n\n\n\n\n#ifndef VIEW_OPTIONS_GUI_COMMAND_H\n#define VIEW_OPTIONS_GUI_COMMAND_H\n\n#include \"gui/gui_action_command.h\"\n#include \"gui/gui_action_factory_registrator.h\"\n\nnamespace sigviewer\n{\n\n\nclass AdaptChannelViewGuiCommand : public GuiActionCommand\n{\n    Q_OBJECT\npublic:\n\n    AdaptChannelViewGuiCommand ();\n\n\n    virtual ~AdaptChannelViewGuiCommand () {}\n\n\n    virtual void init ();\n\nprotected:\n\n    virtual void evaluateEnabledness ();\n\nprivate slots:\n\n    void selectShownChannels ();\n\n\n    void changeColor ();\n\n\n    void scale ();\n\n\n    void applyScaleToOtherChannels ();\n\n\n    void hide ();\n\n\n    void scaleAll ();\n\n\n    void setScaleModeZeroCentered ();\n\n\n    void setScaleModeZeroFitted ();\n\n\n    void toggleAnimations ();\n\n\n    void setAnimationDuration ();\n\nprivate:\n    static QString const CHANNELS_();\n    static QString const CHANGE_COLOR_();\n    static QString const SCALE_();\n    static QString const APPLY_SCALE_TO_OTHER_CHANNELS_();\n    static QString const HIDE_();\n    static QString const SCALE_ALL_();\n    static QString const SET_AUTO_SCALE_MAX_TO_MAX_();\n    static QString const SET_AUTO_SCALE_MIN_TO_MAX_();\n    static QString const ANIMATIONS_();\n    static QString const SET_ANIMATION_DURATION_();\n    static QStringList const ACTIONS_();\n\n    static GuiActionFactoryRegistrator registrator_;\n};\n\n}\n\n#endif\n\n'sigviewer/src/gui_impl/commands/adapt_channel_view_gui_command.cpp'\n:\n\n\n\n\n#include \"adapt_channel_view_gui_command.h\"\n#include \"gui_impl/gui_helper_functions.h\"\n#include \"gui_impl/dialogs/scale_channel_dialog.h\"\n\n#include <QColorDialog>\n#include <QSettings>\n#include <QInputDialog>\n\nnamespace sigviewer\n{\n\n\n\nnamespace {\n\nclass AdaptChannelViewGuiCommandFactory: public GuiActionCommandFactory\n{\npublic:\n    QSharedPointer<GuiActionCommand> createCommand() override\n    {\n        return QSharedPointer<AdaptChannelViewGuiCommand> (new AdaptChannelViewGuiCommand);\n    }\n};\n\n}\n\nQString const AdaptChannelViewGuiCommand::CHANNELS_()\n{\n    static QString value = tr(\"Channels...\");\n\n    return value;\n}\n\nQString const AdaptChannelViewGuiCommand::CHANGE_COLOR_()\n{\n    static QString value = tr(\"Change Color...\");\n\n    return value;\n}\n\nQString const AdaptChannelViewGuiCommand::SCALE_()\n{\n    static QString value = tr(\"Scale...\");\n\n    return value;\n}\n\nQString const AdaptChannelViewGuiCommand::APPLY_SCALE_TO_OTHER_CHANNELS_()\n{\n    static QString value = tr(\"Apply Scale to Other Channels\");\n\n    return value;\n}\n\nQString const AdaptChannelViewGuiCommand::HIDE_()\n{\n    static QString value = tr(\"Hide Channel\");\n\n    return value;\n}\n\nQString const AdaptChannelViewGuiCommand::SCALE_ALL_()\n{\n    static QString value = tr(\"Scale All...\");\n\n    return value;\n}\n\nQString const AdaptChannelViewGuiCommand::SET_AUTO_SCALE_MAX_TO_MAX_()\n{\n    static QString value = tr(\"Zero Line Centered\");\n\n    return value;\n}\n\nQString const AdaptChannelViewGuiCommand::SET_AUTO_SCALE_MIN_TO_MAX_()\n{\n    static QString value = tr(\"Zero Line Fitted\");\n\n    return value;\n}\n\nQString const AdaptChannelViewGuiCommand::ANIMATIONS_()\n{\n    static QString value = tr(\"Animations\");\n\n    return value;\n}\n\nQString const AdaptChannelViewGuiCommand::SET_ANIMATION_DURATION_()\n{\n    static QString value = tr(\"Set Animation Duration\");\n\n    return value;\n}\n\nQStringList const AdaptChannelViewGuiCommand::ACTIONS_()\n{\n    static QStringList result = {\n        AdaptChannelViewGuiCommand::CHANNELS_(),\n        AdaptChannelViewGuiCommand::SCALE_ALL_(),\n        AdaptChannelViewGuiCommand::SET_AUTO_SCALE_MAX_TO_MAX_(),\n        AdaptChannelViewGuiCommand::SET_AUTO_SCALE_MIN_TO_MAX_(),\n        AdaptChannelViewGuiCommand::CHANGE_COLOR_(),\n        AdaptChannelViewGuiCommand::SCALE_(),\n        AdaptChannelViewGuiCommand::HIDE_(),\n        AdaptChannelViewGuiCommand::ANIMATIONS_(),\n        AdaptChannelViewGuiCommand::SET_ANIMATION_DURATION_(),\n    };\n\n    return result;\n}\n\n\nGuiActionFactoryRegistrator registrator_ (\"Adapt Channel View\",\n                                          QSharedPointer<AdaptChannelViewGuiCommandFactory> (new AdaptChannelViewGuiCommandFactory));\n\n\nAdaptChannelViewGuiCommand::AdaptChannelViewGuiCommand ()\n    : GuiActionCommand (ACTIONS_())\n{\n\n}\n\n\nvoid AdaptChannelViewGuiCommand::init ()\n{\n    setIcon (CHANNELS_(), QIcon(\":/images/ic_reorder_black_24dp.png\"));\n    setIcon (SCALE_ALL_(), QIcon(\":/images/ic_autoscale_black_24dp.png\"));\n    resetActionTriggerSlot (CHANNELS_(), SLOT(selectShownChannels()));\n    resetActionTriggerSlot (SCALE_ALL_(), SLOT(scaleAll()));\n    resetActionTriggerSlot (CHANGE_COLOR_(), SLOT(changeColor()));\n    resetActionTriggerSlot (SCALE_(), SLOT(scale()));\n    resetActionTriggerSlot (HIDE_(), SLOT(hide()));\n    setShortcut (CHANNELS_(), tr(\"Ctrl+C\"));\n\n\n    QActionGroup* scale_mode_action_group = new QActionGroup (this);\n    scale_mode_action_group->setExclusive(true);\n    scale_mode_action_group->addAction (getQAction(SET_AUTO_SCALE_MAX_TO_MAX_()));\n    scale_mode_action_group->addAction (getQAction(SET_AUTO_SCALE_MIN_TO_MAX_()));\n    getQAction(SET_AUTO_SCALE_MAX_TO_MAX_())->setCheckable(true);\n    getQAction(SET_AUTO_SCALE_MIN_TO_MAX_())->setCheckable(true);\n    getQAction(ANIMATIONS_())->setCheckable(true);\n    QSettings settings;\n    settings.beginGroup(\"Animations\");\n    getQAction(ANIMATIONS_())->setChecked (settings.value(\"activated\", false).toBool());\n    settings.endGroup();\n\n    resetActionTriggerSlot (SET_AUTO_SCALE_MAX_TO_MAX_(), SLOT(setScaleModeZeroCentered()));\n    resetActionTriggerSlot (SET_AUTO_SCALE_MIN_TO_MAX_(), SLOT(setScaleModeZeroFitted()));\n    resetActionTriggerSlot (ANIMATIONS_(), SLOT(toggleAnimations()));\n    resetActionTriggerSlot (SET_ANIMATION_DURATION_(), SLOT(setAnimationDuration()));\n}\n\n\nvoid AdaptChannelViewGuiCommand::selectShownChannels ()\n{\n    QSharedPointer<SignalVisualisationModel> sv_model = currentVisModel ();\n    std::set<ChannelID> previous_shown_channels = sv_model->getShownChannels ();\n    std::set<ChannelID> new_shown_channels = GuiHelper::selectChannels (sv_model->getChannelManager(),\n                                                                        applicationContext()->getEventColorManager(),\n                                                                        QSharedPointer<BasicHeader>(0),\n                                                                        sv_model);\n    if (previous_shown_channels != new_shown_channels)\n        sv_model->setShownChannels (new_shown_channels);\n    sv_model->update ();\n}\n\n\n\nvoid AdaptChannelViewGuiCommand::evaluateEnabledness ()\n{\n    QStringList disabled_actions_if_no_file = ACTIONS_();\n    disabled_actions_if_no_file.removeAll(ANIMATIONS_());\n    disabled_actions_if_no_file.removeAll(SET_ANIMATION_DURATION_());\n    disableIfNoFileIsOpened (disabled_actions_if_no_file);\n    disableIfNoSignalIsVisualised (disabled_actions_if_no_file);\n\n    if (!currentVisModel().isNull())\n    {\n        getQAction (SET_AUTO_SCALE_MAX_TO_MAX_())->setChecked (currentVisModel()->getAutoScaleMode()\n                                                             == MAX_TO_MAX);\n        getQAction (SET_AUTO_SCALE_MIN_TO_MAX_())->setChecked (currentVisModel()->getAutoScaleMode()\n                                                             == MIN_TO_MAX);\n    }\n}\n\n\nvoid AdaptChannelViewGuiCommand::changeColor ()\n{\n    if (currentVisModel().isNull())\n        return;\n    ChannelID channel = currentVisModel()->getSelectedChannel();\n    if (channel == UNDEFINED_CHANNEL)\n        return;\n    QSharedPointer<ColorManager> color_manager = applicationContext()->getEventColorManager();\n    QColor old_color = color_manager->getChannelColor(channel);\n    QColorDialog color_dialog (old_color);\n    color_dialog.setOption(QColorDialog::ShowAlphaChannel);\n\n    if (color_dialog.exec() == QDialog::Accepted)\n    {\n        color_manager->setChannelColor (channel, color_dialog.selectedColor());\n        color_manager->saveSettings ();\n        currentVisModel()->update();\n    }\n}\n\n\nvoid AdaptChannelViewGuiCommand::scale ()\n{\n    ChannelID channel = currentVisModel()->getSelectedChannel();\n    if (channel == UNDEFINED_CHANNEL)\n        return;\n    ScaleChannelDialog scale_dialog (channel, currentVisModel()->getShownChannels(),\n                                     currentVisModel()->getChannelManager());\n    if (scale_dialog.exec() == QDialog::Accepted)\n    {\n        currentVisModel()->scaleChannel (channel,\n                                         scale_dialog.lowerValue(),\n                                         scale_dialog.upperValue());\n    }\n}\n\n\nvoid AdaptChannelViewGuiCommand::applyScaleToOtherChannels ()\n{\n    ChannelID channel = currentVisModel()->getSelectedChannel();\n    if (channel == UNDEFINED_CHANNEL)\n        return;\n\n\n}\n\n\nvoid AdaptChannelViewGuiCommand::hide ()\n{\n    ChannelID channel = currentVisModel()->getSelectedChannel();\n    if (channel == UNDEFINED_CHANNEL)\n        return;\n\n    std::set<ChannelID> shown_channels = currentVisModel()->getShownChannels();\n    shown_channels.erase (channel);\n    currentVisModel()->setShownChannels (shown_channels);\n    currentVisModel()->update();\n}\n\n\nvoid AdaptChannelViewGuiCommand::scaleAll ()\n{\n    ScaleChannelDialog scale_dialog (UNDEFINED_CHANNEL, currentVisModel()->getShownChannels(),\n                                     currentVisModel()->getChannelManager());\n    if (scale_dialog.exec() == QDialog::Accepted)\n    {\n        if (scale_dialog.autoScaling())\n        {\n            currentVisModel()->setAutoScaleMode (MIN_TO_MAX);\n            currentVisModel()->scaleChannel(UNDEFINED_CHANNEL);\n        }\n        else\n        {\n            currentVisModel()->scaleChannel\n                    (UNDEFINED_CHANNEL, scale_dialog.lowerValue(), scale_dialog.upperValue());\n        }\n    }\n}\n\n\nvoid AdaptChannelViewGuiCommand::setScaleModeZeroCentered ()\n{\n    currentVisModel()->setAutoScaleMode (MAX_TO_MAX);\n    currentVisModel()->scaleChannel(UNDEFINED_CHANNEL);\n}\n\n\nvoid AdaptChannelViewGuiCommand::setScaleModeZeroFitted ()\n{\n    currentVisModel()->setAutoScaleMode (MIN_TO_MAX);\n    currentVisModel()->scaleChannel(UNDEFINED_CHANNEL);\n}\n\n\nvoid AdaptChannelViewGuiCommand::toggleAnimations ()\n{\n    QSettings settings;\n    settings.beginGroup (\"Animations\");\n    settings.setValue (\"activated\", getQAction(ANIMATIONS_())->isChecked ());\n    settings.endGroup ();\n}\n\n\nvoid AdaptChannelViewGuiCommand::setAnimationDuration ()\n{\n    QSettings settings;\n    settings.beginGroup (\"Animations\");\n\n    bool ok = false;\n    int new_duration = QInputDialog::getInt\n            (0, tr(\"Set Animation Duration\"), tr(\"Milliseconds:\"),\n             settings.value(\"duration\", 200).toInt(), 0, 1000, 100, &ok);\n    if (ok)\n        settings.setValue (\"duration\", new_duration);\n    settings.endGroup ();\n}\n\n}\n\n'sigviewer/src/gui/gui_action_command.h'\n:\n\n\n\n\n#ifndef GUI_ACTION_COMMAND_H\n#define GUI_ACTION_COMMAND_H\n\n#include \"application_context.h\"\n\n#include \"base/application_states.h\"\n#include \"base/tab_states.h\"\n#include \"base/file_states.h\"\n#include \"base/exception.h\"\n\n#include \"signal_visualisation_model.h\"\n#include \"event_view.h\"\n#include \"signal_view_settings.h\"\n\n#include <QObject>\n#include <QAction>\n#include <QStringList>\n\nnamespace sigviewer\n{\n\nclass ActionConnector;\n\nclass GuiActionCommand : public QObject\n{\n    Q_OBJECT\npublic:\n\n    virtual ~GuiActionCommand () {}\n\n\n    QList<QAction*> getQActions ();\n\n\n    QList<QString> getActionIDs () const;\n\n\n\tvoid initConnections();\n\n\n    virtual void init () = 0;\n\npublic slots:\n\n    virtual void trigger (QString const&) {}\n\n\n    void updateEnablednessToApplicationState (ApplicationState state);\n\n\n    void updateEnablednessToFileState (FileState state);\n\n\n    void updateEnablednessToTabSelectionState (TabSelectionState state);\n\n\n    void updateEnablednessToTabEditState (TabEditState state);\n\n\n    QAction* getQAction (QString const& id);\n\nprotected:\n\n    GuiActionCommand (QStringList const& action_ids);\n\n\n    void resetActionTriggerSlot (QString const& action_id, const char* slot);\n\n\n    void setShortcut (QString const& action_id, QKeySequence const& key_sequence);\n\n\n    void setIcon (QString const& action_id, QIcon const& icon);\n\n\n    virtual void applicationStateChanged () {}\n\n\n    virtual void evaluateEnabledness ();\n\n\n    QSharedPointer<EventView> currentEventView ();\n\n\n    QSharedPointer<SignalVisualisationModel> currentVisModel ();\n\n\n    QSharedPointer<SignalViewSettings> currentSignalViewSettings ();\n\n\n    QSharedPointer<FileContext> currentFileContext ();\n\n\n    QSharedPointer<ApplicationContext> applicationContext ();\n\n\n    ApplicationState getApplicationState () const {return app_state_;}\n\n\n    FileState getFileState () const {return file_state_;}\n\n\n    TabSelectionState getTabSelectionState () const {return tab_selection_state_;}\n\n\n    TabEditState getTabEditState () const {return tab_edit_state_;}\n\n\n    bool disableIfNoSignalIsVisualised (QStringList const &actions);\n\n\n    bool disableIfNoEventsPossible (QStringList const &actions);\n\n\n    void disableIfNoEventSelected (QStringList const &actions);\n\n\n    bool disableIfNoFileIsOpened (QStringList const &actions);\n\nprivate:\n    QMap<QString, QAction*> action_map_;\n    QList<ActionConnector*> connectors_;\n\n    ApplicationState app_state_;\n    FileState file_state_;\n    TabSelectionState tab_selection_state_;\n    TabEditState tab_edit_state_;\n};\n\nclass ActionConnector : public QObject\n{\n    Q_OBJECT\npublic:\n    ActionConnector (QObject* parent, QString const& name) : QObject (parent), name_ (name) {}\n\n\tQString const& getName() const {return name_; }\n\npublic slots:\n    void trigger () {emit triggered (name_);}\nsignals:\n    void triggered (QString const& name);\nprivate:\n    QString name_;\n};\n\n}\n\n#endif\n",
        "gt": [
            "'sigviewer/src/gui/application_context.h'",
            "'sigviewer/src/gui/gui_action_command.h'",
            "'sigviewer/src/gui_impl/commands/adapt_channel_view_gui_command.h'",
            "'sigviewer/src/gui_impl/commands/adapt_channel_view_gui_command.cpp'"
        ]
    },
    {
        "files": [
            "'HIP-CPU/include/hip/hip_math.h'",
            "'HIP-CPU/include/hip/hip_runtime.h'",
            "'HIP-CPU/tests/hip_host_math_float_double.cpp'"
        ],
        "content": "'HIP-CPU/include/hip/hip_math.h'\n:\n#pragma once\n\n#include <version>\n#if !defined(__cpp_lib_parallel_algorithm)\n    #error The HIP-CPU RT requires a C++17 compliant standard library which exposes parallel algorithms support; see https:\n#endif\n\n#define __HIP_CPU_RT__\n\n#include \"../../src/include/hip/detail/math.hpp\"\n\n\ninline\nfloat __log2f(float x) noexcept\n{\n    return hip::detail::log2(x);\n}\n\ninline\nfloat __powf(float x, float y) noexcept\n{\n    return hip::detail::pow(x, y);\n}\n\n\n\ninline\nfloat erfcinvf(float x) noexcept\n{\n    return hip::detail::erfcinv(x);\n}\n\ninline\nfloat erfinvf(float x) noexcept\n{\n    return hip::detail::erfinv(x);\n}\n\ninline\nfloat erfcxf(float x) noexcept\n{\n    return hip::detail::erfcx(x);\n}\n\ninline\nfloat fdividef(float x, float y) noexcept\n{\n    return hip::detail::fdivide(x, y);\n}\n\ninline\nfloat normf(std::int32_t dim, const float* p) noexcept\n{\n    return hip::detail::norm(dim, p);\n}\n\ninline\nfloat normcdff(float x) noexcept\n{\n    return hip::detail::normcdf(x);\n}\n\ninline\nfloat normcdfinvf(float x) noexcept\n{\n    return hip::detail::normcdfinv(x);\n}\n\ninline\nfloat norm3df(float x, float y, float z) noexcept\n{\n    return hip::detail::norm3d(x, y, z);\n}\n\ninline\nfloat norm4df(float x, float y, float z, float w) noexcept\n{\n    return hip::detail::norm4d(x, y, z, w);\n}\n\ninline\nfloat rcbrtf(float x) noexcept\n{\n    return hip::detail::rcbrt(x);\n}\n\ninline\nfloat rhypotf(float x, float y) noexcept\n{\n    return hip::detail::rhypot(x, y);\n}\n\ninline\nfloat rnormf(std::int32_t dim, const float* p) noexcept\n{\n    return hip::detail::rnorm(dim, p);\n}\n\ninline\nfloat rnorm3df(float x, float y, float z) noexcept\n{\n    return hip::detail::rnorm3d(x, y, z);\n}\n\ninline\nfloat rnorm4df(float x, float y, float z, float w) noexcept\n{\n    return hip::detail::rnorm4d(x, y, z, w);\n}\n\ninline\nvoid sincosf(float x, float* psin, float* pcos) noexcept\n{\n    return hip::detail::sincos(x, psin, pcos);\n}\n\ninline\nvoid sincospif(float x, float* psin, float* pcos) noexcept\n{\n    return hip::detail::sincospi(x, psin, pcos);\n}\n\n\n\ninline\ndouble erfcinv(double x) noexcept\n{\n    return hip::detail::erfcinv(x);\n}\n\ninline\ndouble erfinv(double x) noexcept\n{\n    return hip::detail::erfinv(x);\n}\n\ninline\ndouble erfcx(double x) noexcept\n{\n    return hip::detail::erfcx(x);\n}\n\ninline\ndouble fdivide(double x, double y) noexcept\n{\n    return hip::detail::fdivide(x, y);\n}\n\ninline\ndouble normcdf(double x) noexcept\n{\n    return hip::detail::normcdf(x);\n}\n\ninline\ndouble normcdfinv(double x) noexcept\n{\n    return hip::detail::normcdfinv(x);\n}\n\ninline\ndouble norm3d(double x, double y, double z) noexcept\n{\n    return hip::detail::norm3d(x, y, z);\n}\n\ninline\ndouble norm4d(double x, double y, double z, double w) noexcept\n{\n    return hip::detail::norm4d(x, y, z, w);\n}\n\ninline\ndouble rcbrt(double x) noexcept\n{\n    return hip::detail::rcbrt(x);\n}\n\ninline\ndouble rhypot(double x, double y) noexcept\n{\n    return hip::detail::rhypot(x, y);\n}\n\ninline\ndouble rnorm(std::int32_t dim, const double* p) noexcept\n{\n    return hip::detail::rnorm(dim, p);\n}\n\ninline\ndouble rnorm3d(double x, double y, double z) noexcept\n{\n    return hip::detail::rnorm3d(x, y, z);\n}\n\ninline\ndouble rnorm4d(double x, double y, double z, double w) noexcept\n{\n    return hip::detail::rnorm4d(x, y, z, w);\n}\n\ninline\nvoid sincos(double x, double* psin, double* pcos) noexcept\n{\n    return hip::detail::sincos(x, psin, pcos);\n}\n\ninline\nvoid sincospi(double x, double* psin, double* pcos) noexcept\n{\n    return hip::detail::sincospi(x, psin, pcos);\n}\n\n\n\ninline\nstd::int32_t __mul24(std::int32_t x, std::int32_t y) noexcept\n{\n    return hip::detail::mul24(x, y);\n}\n\n'HIP-CPU/include/hip/hip_runtime.h'\n:\n#pragma once\n\n#include <version>\n#if !defined(__cpp_lib_parallel_algorithm)\n    #error The HIP-CPU RT requires a C++17 compliant standard library which exposes parallel algorithms support; see https:\n#endif\n\n#define __HIP_CPU_RT__\n\n#include \"hip_api.h\"\n#include \"hip_atomic.h\"\n#include \"hip_complex.h\"\n#include \"hip_constants.h\"\n#include \"hip_defines.h\"\n#include \"hip_device_launch_parameters.h\"\n#include \"hip_enums.h\"\n#include \"hip_fp16.h\"\n#include \"hip_ldg.h\"\n#include \"hip_math.h\"\n#include \"hip_types.h\"\n#include \"hip_vector_types.h\"\n\n'HIP-CPU/tests/hip_host_math_float_double.cpp'\n:\n#include <hip/hip_runtime.h>\n\n#include \"../external/catch2/catch.hpp\"\n\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\nTEST_CASE(\"(host) erfcinvf(float)\", \"[host][math][erfcinvf]\")\n{\n    float Val[]{0.1f, 1.2f, 1.f, 0.9f};\n    float Out[]{1.16309f, -0.179144f, 0.f, 0.088856f};\n\n    REQUIRE(equal(cbegin(Val), cend(Val), cbegin(Out), [](auto&& x, auto&& y) {\n        return erfcinvf(x) == Approx{y}.epsilon(0.0009);\n    }));\n}\n\nTEST_CASE(\"(host) erfcxf(float)\", \"[host][math][erfcxf]\")\n{\n    float Val[]{-0.5f, 9.f, 3.2f, 1.f};\n    float Out[]{1.95236f, 0.06231f, 0.16873f, 0.427584f};\n\n    REQUIRE(equal(cbegin(Val), cend(Val), cbegin(Out), [](auto&& x, auto&& y) {\n        return erfcxf(x) == Approx{y}.scale(1.0);\n    }));\n}\n\nTEST_CASE(\"(host) erfinvf(float)\", \"[host][math][erfinvf]\")\n{\n    float Val[]{0.f, -0.5f, 0.9f, -0.2f};\n    float Out[]{0.f, -0.476936f, 1.1631f, -0.179143f};\n\n    REQUIRE(equal(cbegin(Val), cend(Val), cbegin(Out), [](auto&& x, auto&& y) {\n        return erfinvf(x) == Approx{y}.epsilon(0.0009);\n    }));\n}\n\nTEST_CASE(\"(host) fdividef(float)\", \"[host][math][fdividef]\")\n{\n    float Val[]{0.f, -0.5f, 0.9f, -0.2f};\n    float Out[]{1.f, -0.4769f, 1.1631f, -0.1791f};\n\n    REQUIRE(equal(cbegin(Val), cend(Val), cbegin(Out), [](auto&& x, auto&& y) {\n        return fdividef(x, y) == Approx{x / y};\n    }));\n}\n\nTEST_CASE(\"(host) erfcinv(double)\", \"[host][math][erfcinv]\")\n{\n    double Val[]{0.1, 1.2, 1, 0.9};\n    double Out[]{1.16309, -0.179144, 0, 0.0888559889};\n\n    REQUIRE(equal(cbegin(Val), cend(Val), cbegin(Out), [](auto&& x, auto&& y) {\n        return erfcinv(x) == Approx{y}.epsilon(0.0009);\n    }));\n}\n\nTEST_CASE(\"(host) erfcx(double)\", \"[host][math][erfcx]\")\n{\n    double Val[]{-0.5, 15, 3.2, 1};\n    double Out[]{1.9523604892, 0.0375296064, 0.1687280968, 0.4275835762};\n\n    REQUIRE(equal(cbegin(Val), cend(Val), cbegin(Out), [](auto&& x, auto&& y) {\n        return erfcx(x) == Approx{y};\n    }));\n}\n\nTEST_CASE(\"(host) erfinv(double)\", \"[host][math][erfinv]\")\n{\n    double Val[]{0, -0.5, 0.9, -0.2};\n    double Out[]{0, -0.476936287, 1.1631, -0.1791434596};\n\n    REQUIRE(equal(cbegin(Val), cend(Val), cbegin(Out), [](auto&& x, auto&& y) {\n        return erfinv(x) == Approx{y}.epsilon(0.0009);\n    }));\n}\n\nTEST_CASE(\"(host) fdivide(double)\", \"[host][math][fdivide]\")\n{\n    double Val[]{0, -0.5, 0.9, -0.2};\n    double Out[]{1, -0.4769, 1.1631, -0.1791};\n\n    REQUIRE(equal(cbegin(Val), cend(Val), cbegin(Out), [](auto&& x, auto&& y) {\n        return fdivide(x, y) == Approx{x / y};\n    }));\n}\n\nTEST_CASE(\"(host) modff(float)\", \"[host][math][modff]\")\n{\n    float Val[]{0.f, -0.5f, 0.9f, -0.2f};\n    float iPtr[]{0, 0, 0, 0};\n    float frac[]{0, -0.5f, 0.9f, -0.2f};\n    float Out[]{1, 1, 1, 1};\n\n    for (auto i = 0u; i != size(Val); ++i) {\n        REQUIRE(frac[i] == Approx{modff(Val[i], Out + i)});\n        REQUIRE(iPtr[i] == Approx{Out[i]});\n    }\n}\n\nTEST_CASE(\"(host) modf(double)\", \"[host][math][modf]\")\n{\n    double Val[]{0, -0.5, 0.9, -0.2};\n    double iPtr[]{0, 0, 0, 0};\n    double frac[]{0, -0.5, 0.9, -0.2};\n    double Out[]{1, 1, 1, 1};\n\n    for (auto i = 0u; i != size(Val); ++i) {\n        REQUIRE(frac[i] == Approx{modf(Val[i], Out + i)});\n        REQUIRE(iPtr[i] == Approx{Out[i]});\n    }\n}\n\nTEST_CASE(\"(host) nextafterf(float)\", \"[host][math][nextafterf]\")\n{\n    float Val[]{0, -0.5f, 0.9f, -0.2f};\n\n    REQUIRE(all_of(cbegin(Val), cend(Val), [](auto&& x) {\n        return nextafterf(x, 1) == Approx{x}.scale(1.0);\n    }));\n}\n\nTEST_CASE(\"(host) nextafter(double)\", \"[host][math][nextafter]\")\n{\n    double Val[]{0, -0.5, 0.9, -0.2};\n\n    REQUIRE(all_of(cbegin(Val), cend(Val), [](auto&& x) {\n        return nextafter(x, 1) == Approx{x}.scale(1.0);\n    }));\n}\nTEST_CASE(\"(host) norm3df(float)\", \"[host][math][norm3df]\")\n{\n    REQUIRE(\n        norm3df(0.f, 1.f, 2.f) ==\n        Approx{std::sqrt(0.f * 0.f + 1.f * 1.f + 2.f * 2.f)});\n}\n\nTEST_CASE(\"(host) norm3d(double)\", \"[host][math][norm3d]\")\n{\n    REQUIRE(\n        norm3d(0., 1., 2.) == Approx{std::sqrt(0. * 0. + 1. * 1. + 2. * 2.)});\n}\n\nTEST_CASE(\"(host) norm4df(float)\", \"[host][math][norm4df]\")\n{\n    REQUIRE(\n        norm4df(0.f, 1.f, 2.f, 3.f) ==\n        Approx{std::sqrt(0.f * 0.f + 1.f * 1.f + 2.f * 2.f + 3.f * 3.f)});\n}\n\nTEST_CASE(\"(host) norm4d(double)\", \"[host][math][norm4d]\")\n{\n    REQUIRE(\n        norm4d(0., 1., 2., 3.) ==\n        Approx{std::sqrt(0. * 0. + 1. * 1. + 2. * 2. + 3. * 3.)});\n}\n\nTEST_CASE(\"(host) normcdff(float)\", \"[host][math][normcdff]\")\n{\n    float Val[]{0, 1};\n    float Out[]{0.5f, 0.841345f};\n\n    REQUIRE(equal(cbegin(Val), cend(Val), cbegin(Out), [](auto&& x, auto&& y) {\n        return normcdff(x) == Approx{y};\n    }));\n}\n\nTEST_CASE(\"(host) normcdf(double)\", \"[host][math][normcdf]\")\n{\n    double Val[]{0, 1};\n    double Out[]{0.5, 0.841345};\n\n    REQUIRE(equal(cbegin(Val), cend(Val), cbegin(Out), [](auto&& x, auto&& y) {\n        return normcdf(x) == Approx{y};\n    }));\n}\n\nTEST_CASE(\"(host) normcdfinvf(float)\", \"[host][math][normcdfinvf]\")\n{\n    float Val[]{0.5f, 0.8413f};\n\n    REQUIRE(all_of(cbegin(Val), cend(Val), [](auto&& x) {\n        return normcdfinvf(normcdff(x)) == Approx{x}.epsilon(0.0009);\n    }));\n}\n\nTEST_CASE(\"(host) normcdfinv(double)\", \"[host][math][normcdfinv]\")\n{\n    double Val[]{0.5, 0.8413};\n\n    REQUIRE(all_of(cbegin(Val), cend(Val), [](auto&& x) {\n        return normcdfinv(normcdf(x)) == Approx{x}.epsilon(0.0009);\n    }));\n}\n\nTEST_CASE(\"(host) rcbrtf(float)\", \"[host][math][rcbrtf]\")\n{\n    REQUIRE(rcbrtf(1.f) == Approx{1.f});\n}\n\nTEST_CASE(\"(host) rcbrt(double)\", \"[host][math][rcbrt]\")\n{\n    REQUIRE(rcbrt(1.) == Approx{1.});\n}\n\nTEST_CASE(\"(host) rhypotf(float)\", \"[host][math][rhypotf]\")\n{\n    REQUIRE(\n        rhypotf(1.f, 2.f) == Approx{1.f / std::sqrt(1.f * 1.f + 2.f * 2.f)});\n}\n\nTEST_CASE(\"(host) rhypot(double)\", \"[host][math][rhypot]\")\n{\n    REQUIRE(rhypotf(1., 2.) == Approx{1. / std::sqrt(1. * 1. + 2. * 2.)});\n}\n\nTEST_CASE(\"(host) rnorm3df(float)\", \"[host][math][rnorm3df]\")\n{\n    REQUIRE(\n        rnorm3df(0.f, 1.f, 2.f) ==\n        Approx{1.f / std::sqrt(0.f * 0.f + 1.f * 1.f + 2.f * 2.f)});\n}\n\nTEST_CASE(\"(host) rnorm3d(double)\", \"[host][math][rnorm3d]\")\n{\n    REQUIRE(\n        rnorm3df(0., 1., 2.) ==\n        Approx{1. / std::sqrt(0. * 0. + 1. * 1. + 2. * 2.)});\n}\n\nTEST_CASE(\"(host) rnorm4df(float)\", \"[host][math][rnorm4d]\")\n{\n    REQUIRE(\n        rnorm4df(0.f, 1.f, 2.f, 3.f) ==\n        Approx{1.f / std::sqrt(0.f * 0.f + 1.f * 1.f + 2.f * 2.f + 3.f * 3.f)});\n}\n\nTEST_CASE(\"(host) rnorm4d(double)\", \"[host][math][rnorm4d]\")\n{\n    REQUIRE(\n        rnorm4d(0., 1., 2., 3.) ==\n        Approx{1. / std::sqrt(0. * 0. + 1. * 1. + 2. * 2. + 3. * 3.)});\n}\n\nTEST_CASE(\"(host) rnormf(float)\", \"[host][math][rnormf]\")\n{\n    float A[]{0, 1, 2, 3};\n\n    REQUIRE(rnormf(3, A) == Approx{rnorm3df(A[0], A[1], A[2])});\n    REQUIRE(rnormf(4, A) == Approx{rnorm4df(A[0], A[1], A[2], A[3])});\n}\n\nTEST_CASE(\"(host) rnorm(double)\", \"[host][math][rnorm]\")\n{\n    double A[]{0, 1, 2, 3};\n\n    REQUIRE(rnorm(3, A) == Approx{rnorm3d(A[0], A[1], A[2])});\n    REQUIRE(rnorm(4, A) == Approx{rnorm4d(A[0], A[1], A[2], A[3])});\n}\n\nTEST_CASE(\"(host) sincospif(float)\", \"[host][math][sincospif]\")\n{\n    float s1, c1, s2, c2;\n    float in1 = 1, in2 = 0.5;\n    sincospif(in1, &s1, &c1);\n    sincospif(in2, &s2, &c2);\n\n    REQUIRE(s1 == Approx{0}.scale(1.0));\n    REQUIRE(s2 == Approx{1});\n    REQUIRE(c1 == Approx{-1});\n    REQUIRE(c2 == Approx{0}.scale(1.0));\n}\n\nTEST_CASE(\"(host) sincospi(double)\", \"[host][math][sincospi]\")\n{\n    double s1, c1, s2, c2;\n    double in1 = 1, in2 = 0.5;\n    sincospi(in1, &s1, &c1);\n    sincospi(in2, &s2, &c2);\n\n    CHECK(s1 == Approx{0.}.scale(1.0));\n    CHECK(s2 == Approx{1.});\n    CHECK(c1 == Approx{-1.});\n    CHECK(c2 == Approx{0.}.scale(1.0));\n}",
        "gt": [
            "'HIP-CPU/include/hip/hip_math.h'",
            "'HIP-CPU/include/hip/hip_runtime.h'",
            "'HIP-CPU/tests/hip_host_math_float_double.cpp'"
        ]
    },
    {
        "files": [
            "'jarkViewer/jarkViewer/include/opencv2/gapi/gstreaming.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/util/optional.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/oak/oak.hpp'"
        ],
        "content": "'jarkViewer/jarkViewer/include/opencv2/gapi/gstreaming.hpp'\n:\n\n\n\n\n\n\n#ifndef OPENCV_GAPI_GSTREAMING_COMPILED_HPP\n#define OPENCV_GAPI_GSTREAMING_COMPILED_HPP\n\n#include <memory>\n#include <vector>\n\n#include <opencv2/gapi/opencv_includes.hpp>\n#include <opencv2/gapi/own/assert.hpp>\n#include <opencv2/gapi/util/optional.hpp>\n#include <opencv2/gapi/garg.hpp>\n#include <opencv2/gapi/streaming/source.hpp>\n\nnamespace cv {\n\ntemplate<class T> using optional = cv::util::optional<T>;\n\nnamespace detail {\ntemplate<typename T> struct wref_spec {\n    using type = T;\n};\ntemplate<typename T> struct wref_spec<std::vector<T> > {\n    using type = T;\n};\n\ntemplate<typename RefHolder>\nstruct OptRef {\n    struct OptHolder {\n        virtual void mov(RefHolder &h) = 0;\n        virtual void reset() = 0;\n        virtual ~OptHolder() = default;\n        using Ptr = std::shared_ptr<OptHolder>;\n    };\n    template<class T> struct Holder final: OptHolder {\n        std::reference_wrapper<cv::optional<T> > m_opt_ref;\n\n        explicit Holder(cv::optional<T>& opt) : m_opt_ref(std::ref(opt)) {\n        }\n        virtual void mov(RefHolder &h) override {\n            using U = typename wref_spec<T>::type;\n            m_opt_ref.get() = cv::util::make_optional(std::move(h.template wref<U>()));\n        }\n        virtual void reset() override {\n            m_opt_ref.get().reset();\n        }\n    };\n    template<class T>\n    explicit OptRef(cv::optional<T>& t) : m_opt{new Holder<T>(t)} {}\n    void mov(RefHolder &h) { m_opt->mov(h); }\n    void reset()           { m_opt->reset();}\nprivate:\n    typename OptHolder::Ptr m_opt;\n};\nusing OptionalVectorRef = OptRef<cv::detail::VectorRef>;\nusing OptionalOpaqueRef = OptRef<cv::detail::OpaqueRef>;\n}\n\n\nusing GOptRunArgP = util::variant<\n    optional<cv::Mat>*,\n    optional<cv::RMat>*,\n    optional<cv::MediaFrame>*,\n    optional<cv::Scalar>*,\n    cv::detail::OptionalVectorRef,\n    cv::detail::OptionalOpaqueRef\n>;\nusing GOptRunArgsP = std::vector<GOptRunArgP>;\n\nusing GOptRunArg = util::variant<\n    optional<cv::Mat>,\n    optional<cv::RMat>,\n    optional<cv::MediaFrame>,\n    optional<cv::Scalar>,\n    optional<cv::detail::VectorRef>,\n    optional<cv::detail::OpaqueRef>\n>;\nusing GOptRunArgs = std::vector<GOptRunArg>;\n\nnamespace detail {\n\ntemplate<typename T> inline GOptRunArgP wrap_opt_arg(optional<T>& arg) {\n\n    return GOptRunArgP{OptionalOpaqueRef(arg)};\n}\n\ntemplate<typename T> inline GOptRunArgP wrap_opt_arg(optional<std::vector<T> >& arg) {\n    return GOptRunArgP{OptionalVectorRef(arg)};\n}\n\ntemplate<> inline GOptRunArgP wrap_opt_arg(optional<cv::Mat> &m) {\n    return GOptRunArgP{&m};\n}\n\ntemplate<> inline GOptRunArgP wrap_opt_arg(optional<cv::RMat> &m) {\n    return GOptRunArgP{&m};\n}\n\ntemplate<> inline GOptRunArgP wrap_opt_arg(optional<cv::MediaFrame> &f) {\n    return GOptRunArgP{&f};\n}\n\ntemplate<> inline GOptRunArgP wrap_opt_arg(optional<cv::Scalar> &s) {\n    return GOptRunArgP{&s};\n}\n\n}\n\n\n\n\ntemplate<typename T, typename... Ts>\ninline GOptRunArgsP gout(optional<T>&arg, optional<Ts>&... args)\n{\n    return GOptRunArgsP{ detail::wrap_opt_arg(arg), detail::wrap_opt_arg(args)... };\n}\n\n\n\nclass GAPI_EXPORTS_W_SIMPLE GStreamingCompiled\n{\npublic:\n    class GAPI_EXPORTS Priv;\n    GAPI_WRAP GStreamingCompiled();\n\n\n\n    void setSource(GRunArgs &&ins);\n\n\n    GAPI_WRAP void setSource(const cv::detail::ExtractArgsCallback& callback);\n\n\n    void setSource(const gapi::wip::IStreamSource::Ptr& s);\n\n\n    template<typename T, typename... Args>\n    void setSource(Args&&... args) {\n        setSource(cv::gapi::wip::make_src<T>(std::forward<Args>(args)...));\n    }\n\n\n    GAPI_WRAP void start();\n\n\n    bool pull(cv::GRunArgsP &&outs);\n\n\n\n    GAPI_WRAP std::tuple<bool, cv::util::variant<cv::GRunArgs, cv::GOptRunArgs>> pull();\n\n\n    bool pull(cv::GOptRunArgsP &&outs);\n\n\n    bool try_pull(cv::GRunArgsP &&outs);\n\n\n    GAPI_WRAP void stop();\n\n\n    GAPI_WRAP bool running() const;\n\n\n    Priv& priv();\n\n\n    explicit operator bool () const;\n\n\n    const GMetaArgs& metas() const;\n\n\n    const GMetaArgs& outMetas() const;\n\nprotected:\n\n    std::shared_ptr<Priv> m_priv;\n};\n\nnamespace gapi {\n\n\nnamespace streaming {\n\nstruct GAPI_EXPORTS_W_SIMPLE queue_capacity\n{\n    GAPI_WRAP\n    explicit queue_capacity(size_t cap = 1) : capacity(cap) { }\n    GAPI_PROP_RW\n    size_t capacity;\n};\n}\n}\n\nnamespace detail\n{\ntemplate<> struct CompileArgTag<cv::gapi::streaming::queue_capacity>\n{\n    static const char* tag() { return \"gapi.queue_capacity\"; }\n};\n}\n\n\n\n}\n\n#endif\n\n'jarkViewer/jarkViewer/include/opencv2/gapi/util/optional.hpp'\n:\n\n\n\n\n\n\n#ifndef OPENCV_GAPI_UTIL_OPTIONAL_HPP\n#define OPENCV_GAPI_UTIL_OPTIONAL_HPP\n\n#include <opencv2/gapi/util/variant.hpp>\n\n\nnamespace cv\n{\nnamespace util\n{\n    class bad_optional_access: public std::exception\n    {\n    public:\n        virtual const char *what() const noexcept override\n        {\n            return \"Bad optional access\";\n        }\n    };\n\n\n\n\n    template<typename T> class optional\n    {\n    public:\n\n\n\n        optional() {}\n        optional(const optional&) = default;\n        explicit optional(T&&) noexcept;\n        explicit optional(const T&) noexcept;\n        optional(optional&&) noexcept;\n\n\n\n\n\n\n\n\n        optional& operator=(const optional&) = default;\n        optional& operator=(optional&&);\n\n\n        T* operator-> ();\n        const T* operator-> () const;\n        T& operator* ();\n        const T& operator* () const;\n\n\n        operator bool() const noexcept;\n        bool has_value() const noexcept;\n\n        T& value();\n        const T& value() const;\n\n\n        template<class U>\n        T value_or(U &&default_value) const;\n\n        void swap(optional &other) noexcept;\n        void reset() noexcept;\n\n\n\n\n    private:\n        struct nothing {};\n        util::variant<nothing, T> m_holder;\n    };\n\n    template<class T>\n    optional<typename std::decay<T>::type> make_optional(T&& value);\n\n\n\n\n    template<class T> optional<T>::optional(T &&v) noexcept\n        : m_holder(std::move(v))\n    {\n    }\n\n    template<class T> optional<T>::optional(const T &v) noexcept\n        : m_holder(v)\n    {\n    }\n\n    template<class T> optional<T>::optional(optional&& rhs) noexcept\n        : m_holder(std::move(rhs.m_holder))\n    {\n        rhs.reset();\n    }\n\n    template<class T> optional<T>& optional<T>::operator=(optional&& rhs)\n    {\n        m_holder = std::move(rhs.m_holder);\n        rhs.reset();\n        return *this;\n    }\n\n    template<class T> T* optional<T>::operator-> ()\n    {\n        return & *(*this);\n    }\n\n    template<class T> const T* optional<T>::operator-> () const\n    {\n        return & *(*this);\n    }\n\n    template<class T> T& optional<T>::operator* ()\n    {\n        return this->value();\n    }\n\n    template<class T> const T& optional<T>::operator* () const\n    {\n        return this->value();\n    }\n\n    template<class T> optional<T>::operator bool() const noexcept\n    {\n        return this->has_value();\n    }\n\n    template<class T> bool optional<T>::has_value() const noexcept\n    {\n        return util::holds_alternative<T>(m_holder);\n    }\n\n    template<class T> T& optional<T>::value()\n    {\n        if (!this->has_value())\n            throw_error(bad_optional_access());\n        return util::get<T>(m_holder);\n    }\n\n    template<class T> const T& optional<T>::value() const\n    {\n        if (!this->has_value())\n            throw_error(bad_optional_access());\n        return util::get<T>(m_holder);\n    }\n\n    template<class T>\n    template<class U> T optional<T>::value_or(U &&default_value) const\n    {\n        return (this->has_value() ? this->value() : T(default_value));\n    }\n\n    template<class T> void optional<T>::swap(optional<T> &other) noexcept\n    {\n        m_holder.swap(other.m_holder);\n    }\n\n    template<class T> void optional<T>::reset() noexcept\n    {\n        if (this->has_value())\n            m_holder = nothing{};\n    }\n\n    template<class T>\n    optional<typename std::decay<T>::type> make_optional(T&& value)\n    {\n        return optional<typename std::decay<T>::type>(std::forward<T>(value));\n    }\n}\n}\n\n#endif\n\n'jarkViewer/jarkViewer/include/opencv2/gapi/oak/oak.hpp'\n:\n\n\n\n\n\n#ifndef OPENCV_GAPI_OAK_HPP\n#define OPENCV_GAPI_OAK_HPP\n\n#include <opencv2/gapi/garg.hpp>\n#include <opencv2/gapi/gkernel.hpp>\n#include <opencv2/gapi/gstreaming.hpp>\n\nnamespace cv {\nnamespace gapi {\nnamespace oak {\n\n\nstruct EncoderConfig {\n\n    enum class RateControlMode: int { CBR, VBR };\n\n\n    enum class Profile: int { H264_BASELINE, H264_HIGH, H264_MAIN, H265_MAIN, MJPEG };\n\n    std::int32_t bitrate = 8000;\n\n    std::int32_t keyframeFrequency = 30;\n\n    std::int32_t maxBitrate = 8000;\n\n    std::int32_t numBFrames = 0;\n\n    std::uint32_t numFramesPool = 4;\n\n    Profile profile = Profile::H265_MAIN;\n\n    std::int32_t quality = 80;\n\n    bool lossless = false;\n\n    RateControlMode rateCtrlMode = RateControlMode::CBR;\n\n    std::int32_t width = 1920;\n\n    std::int32_t height = 1080;\n\n    float frameRate = 30.0f;\n};\n\nG_API_OP(GEncFrame, <GArray<uint8_t>(GFrame, EncoderConfig)>, \"org.opencv.oak.enc_frame\") {\n    static GArrayDesc outMeta(const GFrameDesc&, const EncoderConfig&) {\n        return cv::empty_array_desc();\n    }\n};\n\nG_API_OP(GSobelXY, <GFrame(GFrame, const cv::Mat&, const cv::Mat&)>, \"org.opencv.oak.sobelxy\") {\n    static GFrameDesc outMeta(const GFrameDesc& in, const cv::Mat&, const cv::Mat&) {\n        return in;\n    }\n};\n\nG_API_OP(GCopy, <GFrame(GFrame)>, \"org.opencv.oak.copy\") {\n    static GFrameDesc outMeta(const GFrameDesc& in) {\n        return in;\n    }\n};\n\n\n\nGAPI_EXPORTS GArray<uint8_t> encode(const GFrame& in, const EncoderConfig&);\n\nGAPI_EXPORTS GFrame sobelXY(const GFrame& in,\n                            const cv::Mat& hk,\n                            const cv::Mat& vk);\n\nGAPI_EXPORTS GFrame copy(const GFrame& in);\n\n\nGAPI_EXPORTS cv::gapi::GBackend backend();\nGAPI_EXPORTS cv::gapi::GKernelPackage kernels();\n\n\n\nstruct GAPI_EXPORTS ColorCameraParams {\n\n    bool interleaved = false;\n\n\n    enum class BoardSocket: int { RGB, BGR };\n\n    BoardSocket board_socket = BoardSocket::RGB;\n\n\n    enum class Resolution: int { THE_1080_P };\n\n    Resolution resolution = Resolution::THE_1080_P;\n};\n\nclass GAPI_EXPORTS ColorCamera: public cv::gapi::wip::IStreamSource {\n    cv::MediaFrame m_dummy;\n    ColorCameraParams m_params;\n\n    virtual bool pull(cv::gapi::wip::Data &data) override;\n    virtual GMetaArg descr_of() const override;\n\npublic:\n    ColorCamera();\n    explicit ColorCamera(const ColorCameraParams& params);\n};\n\n}\n}\n\nnamespace detail {\ntemplate<> struct CompileArgTag<gapi::oak::ColorCameraParams> {\n    static const char* tag() { return \"gapi.oak.colorCameraParams\"; }\n};\n\ntemplate<> struct CompileArgTag<gapi::oak::EncoderConfig> {\n    static const char* tag() { return \"gapi.oak.encoderConfig\"; }\n};\n}\n\n}\n\n#endif\n",
        "gt": [
            "'jarkViewer/jarkViewer/include/opencv2/gapi/util/optional.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/gstreaming.hpp'",
            "'jarkViewer/jarkViewer/include/opencv2/gapi/oak/oak.hpp'"
        ]
    },
    {
        "files": [
            "'nymea/libnymea-core/hardware/network/networkdevicediscoveryreplyimpl.h'",
            "'nymea/libnymea/network/networkdevicediscoveryreply.h'",
            "'nymea/libnymea-core/hardware/network/networkdevicediscoveryreplyimpl.cpp'"
        ],
        "content": "'nymea/libnymea-core/hardware/network/networkdevicediscoveryreplyimpl.h'\n:\n\n#ifndef NETWORKDEVICEDISCOVERYREPLYIMPL_H\n#define NETWORKDEVICEDISCOVERYREPLYIMPL_H\n\n#include <QHash>\n#include <QObject>\n\n#include \"network/networkdeviceinfo.h\"\n#include \"network/networkdevicediscoveryreply.h\"\n\nnamespace nymeaserver {\n\nclass NetworkDeviceDiscoveryReplyImpl : public NetworkDeviceDiscoveryReply\n{\n    Q_OBJECT\n\npublic:\n    explicit NetworkDeviceDiscoveryReplyImpl(QObject *parent = nullptr);\n    ~NetworkDeviceDiscoveryReplyImpl() override = default;\n\n    NetworkDeviceInfos networkDeviceInfos() const override;\n    NetworkDeviceInfos virtualNetworkDeviceInfos() const override;\n\n    bool isFinished() const override;\n    void setFinished(bool finished);\n\n\n    void processPingResponse(const QHostAddress &address, const QString &hostName);\n    void processArpResponse(const QNetworkInterface &interface, const QHostAddress &address, const MacAddress &macAddress);\n    void processMacManufacturer(const MacAddress &macAddress, const QString &manufacturer);\n\n    void processDiscoveryFinished();\n\npublic slots:\n    void addCompleteNetworkDeviceInfo(const NetworkDeviceInfo &networkDeviceInfo);\n    void addVirtualNetworkDeviceInfo(const NetworkDeviceInfo &networkDeviceInfo);\n\nprivate:\n    NetworkDeviceInfos m_networkDeviceInfos;\n    NetworkDeviceInfos m_virtualNetworkDeviceInfos;\n\n    QHash<MacAddress, NetworkDeviceInfo> m_networkDeviceCache;\n    qint64 m_startTimestamp;\n\n    bool m_isFinished = false;\n\n\n    QHash<QHostAddress, NetworkDeviceInfo> m_pingCache;\n\n    QString macAddressFromHostAddress(const QHostAddress &address);\n    bool hasHostAddress(const QHostAddress &address);\n\n    void verifyComplete(const MacAddress &macAddress);\n\n\n};\n\n}\n\n#endif\n\n'nymea/libnymea/network/networkdevicediscoveryreply.h'\n:\n\n#ifndef NETWORKDEVICEDISCOVERYREPLY_H\n#define NETWORKDEVICEDISCOVERYREPLY_H\n\n#include <QObject>\n\n#include \"libnymea.h\"\n#include \"networkdeviceinfos.h\"\n\nclass LIBNYMEA_EXPORT NetworkDeviceDiscoveryReply : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit NetworkDeviceDiscoveryReply(QObject *parent = nullptr) : QObject(parent) { };\n    virtual ~NetworkDeviceDiscoveryReply() = default;\n\n    virtual NetworkDeviceInfos networkDeviceInfos() const = 0;\n    virtual NetworkDeviceInfos virtualNetworkDeviceInfos() const = 0;\n\n    virtual bool isFinished() const = 0;\n\nsignals:\n\n    void hostAddressDiscovered(const QHostAddress &address);\n\n\n    void networkDeviceInfoAdded(const NetworkDeviceInfo &networkDeviceInfo);\n\n    void finished();\n\n};\n\n#endif\n\n'nymea/libnymea-core/hardware/network/networkdevicediscoveryreplyimpl.cpp'\n:\n\n#include \"networkdevicediscoveryreplyimpl.h\"\n#include \"loggingcategories.h\"\n\n#include <QDateTime>\n\nQ_DECLARE_LOGGING_CATEGORY(dcNetworkDeviceDiscovery)\n\nnamespace nymeaserver {\n\nNetworkDeviceDiscoveryReplyImpl::NetworkDeviceDiscoveryReplyImpl(QObject *parent) :\n    NetworkDeviceDiscoveryReply(parent)\n{\n    m_startTimestamp = QDateTime::currentMSecsSinceEpoch();\n}\n\nNetworkDeviceInfos NetworkDeviceDiscoveryReplyImpl::networkDeviceInfos() const\n{\n    return m_networkDeviceInfos;\n}\n\nNetworkDeviceInfos NetworkDeviceDiscoveryReplyImpl::virtualNetworkDeviceInfos() const\n{\n    return m_virtualNetworkDeviceInfos;\n}\n\nbool NetworkDeviceDiscoveryReplyImpl::isFinished() const\n{\n    return m_isFinished;\n}\n\nvoid NetworkDeviceDiscoveryReplyImpl::setFinished(bool finished)\n{\n    m_isFinished = finished;\n}\n\nvoid NetworkDeviceDiscoveryReplyImpl::processPingResponse(const QHostAddress &address, const QString &hostName)\n{\n    foreach (const NetworkDeviceInfo &info, m_networkDeviceCache) {\n        if (info.address() == address) {\n\n            MacAddress macAddress(info.macAddress());\n            m_networkDeviceCache[macAddress].setHostName(hostName);\n            verifyComplete(macAddress);\n            return;\n        }\n    }\n\n\n    NetworkDeviceInfo info;\n    info.setAddress(address);\n    info.setHostName(hostName);\n    m_pingCache.insert(address, info);\n\n    emit hostAddressDiscovered(address);\n}\n\nvoid NetworkDeviceDiscoveryReplyImpl::processArpResponse(const QNetworkInterface &interface, const QHostAddress &address, const MacAddress &macAddress)\n{\n    if (m_pingCache.contains(address)) {\n\n        NetworkDeviceInfo info = m_pingCache.take(address);\n        info.setAddress(address);\n        info.setNetworkInterface(interface);\n        info.setMacAddress(macAddress.toString());\n        m_networkDeviceCache[macAddress] = info;\n    } else {\n        if (m_networkDeviceCache.contains(macAddress)) {\n            m_networkDeviceCache[macAddress].setAddress(address);\n            m_networkDeviceCache[macAddress].setNetworkInterface(interface);\n        } else {\n            NetworkDeviceInfo info(macAddress.toString());\n            info.setAddress(address);\n            info.setNetworkInterface(interface);\n            m_networkDeviceCache[macAddress] = info;\n\n            emit hostAddressDiscovered(address);\n        }\n    }\n\n    verifyComplete(macAddress);\n}\n\nvoid NetworkDeviceDiscoveryReplyImpl::processMacManufacturer(const MacAddress &macAddress, const QString &manufacturer)\n{\n    if (macAddress.isNull())\n        return;\n\n    if (m_networkDeviceCache.contains(macAddress)) {\n        m_networkDeviceCache[macAddress].setMacAddressManufacturer(manufacturer);\n    } else {\n        NetworkDeviceInfo info(macAddress.toString());\n        info.setMacAddressManufacturer(manufacturer);\n        m_networkDeviceCache[macAddress] = info;\n    }\n\n    verifyComplete(macAddress);\n}\n\nvoid NetworkDeviceDiscoveryReplyImpl::processDiscoveryFinished()\n{\n\n    foreach (const MacAddress &macAddress, m_networkDeviceCache.keys()) {\n\n        if (m_networkDeviceInfos.hasMacAddress(macAddress))\n            continue;\n\n        NetworkDeviceInfo info = m_networkDeviceCache.value(macAddress);\n        MacAddress infoMacAddress(info.macAddress());\n        qCDebug(dcNetworkDeviceDiscovery()) << \"--> \" << info\n                                            << \"Valid:\" << info.isValid()\n                                            << \"Complete:\" << info.isComplete()\n                                            << info.incompleteProperties();\n\n\n        if (infoMacAddress == macAddress && !infoMacAddress.isNull() && !info.address().isNull()) {\n            qCDebug(dcNetworkDeviceDiscovery()) << \"Adding incomplete\" << info << \"to the final result:\" << info.incompleteProperties();\n\n            m_networkDeviceCache[macAddress].setAddress(info.address());\n            m_networkDeviceCache[macAddress].setHostName(info.hostName());\n            m_networkDeviceCache[macAddress].setMacAddress(info.macAddress());\n            m_networkDeviceCache[macAddress].setMacAddressManufacturer(info.macAddressManufacturer());\n            m_networkDeviceCache[macAddress].setNetworkInterface(info.networkInterface());\n            verifyComplete(macAddress);\n        }\n    }\n\n\n    m_networkDeviceInfos.sortNetworkDevices();\n\n    qint64 durationMilliSeconds = QDateTime::currentMSecsSinceEpoch() - m_startTimestamp;\n    qCInfo(dcNetworkDeviceDiscovery()) << \"Discovery finished. Found\" << networkDeviceInfos().count() << \"network devices in\" << QTime::fromMSecsSinceStartOfDay(durationMilliSeconds).toString(\"mm:ss.zzz\");\n\n\n    foreach (const NetworkDeviceInfo &info, m_networkDeviceInfos) {\n        qCDebug(dcNetworkDeviceDiscovery()) << \"--> \" << info;\n    }\n\n\n    foreach (const NetworkDeviceInfo &info, m_pingCache) {\n        NetworkDeviceInfo finalInfo = info;\n        finalInfo.setAddress(finalInfo.address());\n        finalInfo.setHostName(finalInfo.hostName());\n        finalInfo.setMacAddress(finalInfo.macAddress());\n        finalInfo.setNetworkInterface(finalInfo.networkInterface());\n        finalInfo.setMacAddressManufacturer(finalInfo.macAddressManufacturer());\n        m_virtualNetworkDeviceInfos.append(info);\n    }\n\n    m_virtualNetworkDeviceInfos.sortNetworkDevices();\n\n    qCDebug(dcNetworkDeviceDiscovery()) << \"Virtual hosts (\" << m_virtualNetworkDeviceInfos.count() << \")\";\n    foreach (const NetworkDeviceInfo &info, m_virtualNetworkDeviceInfos) {\n        qCDebug(dcNetworkDeviceDiscovery()) << \"--> \" << info;\n    }\n\n    foreach (const MacAddress &macAddress, m_networkDeviceCache.keys()) {\n        if (m_networkDeviceInfos.hasMacAddress(macAddress))\n            continue;\n\n        NetworkDeviceInfo info = m_networkDeviceCache.value(macAddress);\n        qCDebug(dcNetworkDeviceDiscovery()) << \"Unhandled information:\" << info << \"Valid:\" << info.isValid() << \"Complete:\" << info.isComplete() << info.incompleteProperties();\n    }\n\n    m_isFinished = true;\n    emit finished();\n}\n\nvoid NetworkDeviceDiscoveryReplyImpl::addCompleteNetworkDeviceInfo(const NetworkDeviceInfo &networkDeviceInfo)\n{\n\n    if (!m_networkDeviceInfos.hasMacAddress(networkDeviceInfo.macAddress())) {\n        m_networkDeviceInfos.append(networkDeviceInfo);\n\n        emit hostAddressDiscovered(networkDeviceInfo.address());\n\n        emit networkDeviceInfoAdded(networkDeviceInfo);\n    }\n}\n\nvoid NetworkDeviceDiscoveryReplyImpl::addVirtualNetworkDeviceInfo(const NetworkDeviceInfo &networkDeviceInfo)\n{\n\n    if (!m_networkDeviceInfos.hasHostAddress(networkDeviceInfo.address())) {\n        m_virtualNetworkDeviceInfos.append(networkDeviceInfo);\n    }\n}\n\nQString NetworkDeviceDiscoveryReplyImpl::macAddressFromHostAddress(const QHostAddress &address)\n{\n    foreach (const NetworkDeviceInfo &info, m_networkDeviceCache) {\n        if (info.address() == address) {\n            return info.macAddress();\n        }\n    }\n\n    return QString();\n}\n\nbool NetworkDeviceDiscoveryReplyImpl::hasHostAddress(const QHostAddress &address)\n{\n    return ! macAddressFromHostAddress(address).isEmpty();\n}\n\nvoid NetworkDeviceDiscoveryReplyImpl::verifyComplete(const MacAddress &macAddress)\n{\n    if (!m_networkDeviceCache.contains(macAddress))\n        return;\n\n    if (m_networkDeviceCache[macAddress].isComplete() && m_networkDeviceCache[macAddress].isValid()) {\n        if (m_networkDeviceInfos.hasMacAddress(macAddress)) {\n            if (m_networkDeviceInfos.get(macAddress) != m_networkDeviceCache.value(macAddress)) {\n                qCDebug(dcNetworkDeviceDiscovery()) << \"One MAC address seem to be reachable using 2 IP addresses, which is OK. Not updating the network device info and keeping the current information.\";\n                qCDebug(dcNetworkDeviceDiscovery()) << \"--> Keeping \" << m_networkDeviceInfos.get(macAddress);\n                qCDebug(dcNetworkDeviceDiscovery()) << \"--> Ignoring\" << m_networkDeviceCache.value(macAddress);\n            }\n        } else {\n            m_networkDeviceInfos.append(m_networkDeviceCache.value(macAddress));\n            emit networkDeviceInfoAdded(m_networkDeviceCache[macAddress]);\n        }\n    }\n}\n\n}\n",
        "gt": [
            "'nymea/libnymea/network/networkdevicediscoveryreply.h'",
            "'nymea/libnymea-core/hardware/network/networkdevicediscoveryreplyimpl.h'",
            "'nymea/libnymea-core/hardware/network/networkdevicediscoveryreplyimpl.cpp'"
        ]
    },
    {
        "files": [
            "'gamma/third_party/scann-1.2.1/scann/data_format/dataset.h'",
            "'gamma/third_party/scann-1.2.1/scann/utils/scalar_quantization_helpers.h'",
            "'gamma/third_party/scann-1.2.1/scann/data_format/sparse_low_level.h'"
        ],
        "content": "'gamma/third_party/scann-1.2.1/scann/data_format/dataset.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SCANN_DATA_FORMAT_DATASET_H_\n#define SCANN_DATA_FORMAT_DATASET_H_\n\n#include <memory>\n#include <type_traits>\n\n#include \"absl/memory/memory.h\"\n#include \"absl/strings/str_cat.h\"\n#include \"scann/data_format/datapoint.h\"\n#include \"scann/data_format/docid_collection.h\"\n#include \"scann/data_format/features.pb.h\"\n#include \"scann/data_format/sparse_low_level.h\"\n#include \"scann/distance_measures/distance_measure_base.h\"\n#include \"scann/proto/hashed.pb.h\"\n#include \"scann/utils/common.h\"\n#include \"scann/utils/iterators.h\"\n#include \"scann/utils/types.h\"\n#include \"scann/utils/util_functions.h\"\n#include \"tensorflow/core/platform/prefetch.h\"\n\nnamespace research_scann {\n\ntemplate <typename T>\nclass TypedDataset;\ntemplate <typename T>\nclass DenseDataset;\ntemplate <typename T>\nclass SparseDataset;\n\nclass Dataset : public VirtualDestructor {\n public:\n  SCANN_DECLARE_MOVE_ONLY_CLASS(Dataset);\n\n  Dataset() : docids_(make_shared<VariableLengthDocidCollection>()) {}\n\n  explicit Dataset(unique_ptr<DocidCollectionInterface> docids)\n      : docids_(std::move(docids)) {\n    DCHECK(docids_);\n  }\n\n  DatapointIndex size() const { return docids_->size(); }\n\n  bool empty() const { return size() == 0; }\n\n  DimensionIndex dimensionality() const { return dimensionality_; }\n\n  virtual DimensionIndex NumActiveDimensions() const = 0;\n\n  virtual bool IsDense() const = 0;\n\n  bool IsSparse() const { return !IsDense(); }\n\n  virtual void Reserve(size_t n_points) {}\n\n  void ReserveDocids(size_t n_docids) { docids_->Reserve(n_docids); }\n\n  string_view GetDocid(size_t index) const { return docids_->Get(index); }\n\n  const shared_ptr<DocidCollectionInterface>& docids() const { return docids_; }\n\n  virtual shared_ptr<DocidCollectionInterface> ReleaseDocids();\n\n  virtual void clear() = 0;\n\n  virtual research_scann::TypeTag TypeTag() const = 0;\n\n  virtual void GetDatapoint(size_t index, Datapoint<double>* result) const = 0;\n\n  virtual void GetDenseDatapoint(size_t index,\n                                 Datapoint<double>* result) const = 0;\n\n  virtual void Prefetch(size_t index) const = 0;\n\n  virtual double GetDistance(const DistanceMeasure& dist, size_t vec1_index,\n                             size_t vec2_index) const = 0;\n\n  virtual Status MeanByDimension(Datapoint<double>* result) const = 0;\n\n  virtual Status MeanByDimension(ConstSpan<DatapointIndex> subset,\n                                 Datapoint<double>* result) const = 0;\n\n  virtual void MeanVarianceByDimension(Datapoint<double>* means,\n                                       Datapoint<double>* variances) const = 0;\n\n  virtual void MeanVarianceByDimension(ConstSpan<DatapointIndex> subset,\n                                       Datapoint<double>* means,\n                                       Datapoint<double>* variances) const = 0;\n\n  virtual Status NormalizeUnitL2() = 0;\n\n  virtual Status NormalizeZeroMeanUnitVariance() = 0;\n\n  Normalization normalization() const { return normalization_; }\n\n  Status NormalizeByTag(Normalization tag);\n\n  void set_normalization_tag(Normalization tag) { normalization_ = tag; }\n\n  HashedItem::PackingStrategy packing_strategy() const {\n    return packing_strategy_;\n  }\n\n  virtual void set_packing_strategy(\n      HashedItem::PackingStrategy packing_strategy) {\n    packing_strategy_ = packing_strategy;\n  }\n\n  virtual bool is_float() const = 0;\n\n  bool is_binary() const { return packing_strategy_ == HashedItem::BINARY; }\n\n  virtual void set_is_binary(bool val) {\n    packing_strategy_ = val ? HashedItem::BINARY : HashedItem::NONE;\n  }\n\n  virtual void ShrinkToFit() {}\n\n  size_t DocidArrayCapacity() const { return docids_->capacity(); }\n\n  virtual size_t MemoryUsageExcludingDocids() const = 0;\n\n  size_t DocidMemoryUsage() const { return docids_->MemoryUsage(); }\n\n protected:\n  void set_dimensionality_no_checks(DimensionIndex dim) {\n    dimensionality_ = dim;\n  }\n\n  void set_docids_no_checks(shared_ptr<DocidCollectionInterface> docids) {\n    docids_ = std::move(docids);\n  }\n\n  void set_normalization(Normalization norm) { normalization_ = norm; }\n\n  Status AppendDocid(string_view docid) { return docids_->Append(docid); }\n\n private:\n  shared_ptr<DocidCollectionInterface> docids_;\n\n  DimensionIndex dimensionality_ = 0;\n\n  Normalization normalization_ = NONE;\n\n  HashedItem::PackingStrategy packing_strategy_ = HashedItem::NONE;\n\n  virtual void UnusedKeyMethod();\n};\n\ntemplate <typename T>\nclass TypedDataset : public Dataset {\n public:\n  SCANN_DECLARE_MOVE_ONLY_CLASS(TypedDataset);\n\n  TypedDataset() {}\n\n  explicit TypedDataset(unique_ptr<DocidCollectionInterface> docids)\n      : Dataset(std::move(docids)) {}\n\n  research_scann::TypeTag TypeTag() const final { return TagForType<T>(); }\n\n  bool is_float() const final { return std::is_floating_point<T>::value; }\n\n  using const_iterator = RandomAccessIterator<const TypedDataset<T>>;\n  const_iterator begin() const { return const_iterator(this, 0); }\n  const_iterator end() const { return const_iterator(this, this->size()); }\n\n  virtual DatapointPtr<T> operator[](size_t datapoint_index) const = 0;\n\n  DatapointPtr<T> at(size_t datapoint_index) const {\n    CHECK_LT(datapoint_index, size());\n    return operator[](datapoint_index);\n  }\n\n  virtual void set_dimensionality(DimensionIndex dimensionality) = 0;\n\n  virtual Status Append(const DatapointPtr<T>& dptr, string_view docid) = 0;\n  Status Append(const DatapointPtr<T>& dptr);\n\n  virtual Status Append(const GenericFeatureVector& gfv, string_view docid) = 0;\n  Status Append(const GenericFeatureVector& gfv);\n\n  void AppendOrDie(const DatapointPtr<T>& dptr, string_view docid);\n  void AppendOrDie(const GenericFeatureVector& gfv, string_view docid);\n  void AppendOrDie(const DatapointPtr<T>& dptr);\n  void AppendOrDie(const GenericFeatureVector& gfv);\n\n  void GetDatapoint(size_t index, Datapoint<double>* result) const final;\n  Status MeanByDimension(Datapoint<double>* result) const final;\n  Status MeanByDimension(ConstSpan<DatapointIndex> subset,\n                         Datapoint<double>* result) const final;\n  void MeanVarianceByDimension(Datapoint<double>* means,\n                               Datapoint<double>* variances) const final;\n  void MeanVarianceByDimension(ConstSpan<DatapointIndex> subset,\n                               Datapoint<double>* means,\n                               Datapoint<double>* variances) const final;\n  Status NormalizeUnitL2() final;\n  Status NormalizeZeroMeanUnitVariance() final;\n\n  class Mutator;\n  virtual StatusOr<typename TypedDataset::Mutator*> GetMutator() const = 0;\n};\n\ntemplate <typename T>\nclass TypedDataset<T>::Mutator : public VirtualDestructor {\n public:\n  virtual Status AddDatapoint(const DatapointPtr<T>& dptr,\n                              string_view docid) = 0;\n\n  virtual Status RemoveDatapoint(string_view docid) = 0;\n\n  virtual Status UpdateDatapoint(const DatapointPtr<T>& dptr,\n                                 string_view docid) = 0;\n\n  virtual bool LookupDatapointIndex(string_view docid,\n                                    DatapointIndex* index) const = 0;\n\n  virtual void Reserve(size_t size) = 0;\n\n  virtual Status RemoveDatapoint(DatapointIndex index) = 0;\n  virtual Status UpdateDatapoint(const DatapointPtr<T>& dptr,\n                                 DatapointIndex index) = 0;\n};\n\ntemplate <typename T>\nclass DenseDataset final : public TypedDataset<T> {\n public:\n  SCANN_DECLARE_MOVE_ONLY_CLASS(DenseDataset);\n\n  DenseDataset() {}\n\n  explicit DenseDataset(unique_ptr<DocidCollectionInterface> docids)\n      : TypedDataset<T>(std::move(docids)) {}\n\n  DenseDataset(std::vector<T> datapoint_vec,\n               unique_ptr<DocidCollectionInterface> docids);\n\n  DenseDataset(std::vector<T> datapoint_vec, size_t num_dp);\n\n  DenseDataset<T> Copy() const {\n    auto result = DenseDataset<T>(data_, this->docids()->Copy());\n    result.set_normalization_tag(this->normalization());\n\n    result.set_dimensionality(this->dimensionality());\n    return result;\n  }\n\n  bool IsDense() const final { return true; }\n\n  using const_iterator = RandomAccessIterator<const DenseDataset<T>>;\n  const_iterator begin() const { return const_iterator(this, 0); }\n  const_iterator end() const { return const_iterator(this, this->size()); }\n\n  size_t n_elements() const {\n    return static_cast<size_t>(this->size()) *\n           static_cast<size_t>(this->dimensionality());\n  }\n\n  void Reserve(size_t n) final;\n  void ReserveImpl(size_t n);\n  uint32_t Capacity() {\n    size_t cap = data_.capacity() / stride_;\n    return (uint32_t)cap;\n  }\n\n  void Resize(size_t n);\n\n  template <typename Real>\n  void ConvertType(DenseDataset<Real>* target) const;\n\n  ConstSpan<T> data() const { return data_; }\n  std::vector<T> &Data() { return data_; }\n  ConstSpan<T> data(size_t index) const {\n    return MakeConstSpan(data_.data() + index * stride_, stride_);\n  }\n  MutableSpan<T> mutable_data() { return MakeMutableSpan(data_); }\n  MutableSpan<T> mutable_data(size_t index) {\n    return MakeMutableSpan(data_.data() + index * stride_, stride_);\n  }\n\n  vector<T> ClearRecyclingDataVector() {\n    vector<T> result = std::move(data_);\n    this->clear();\n    return result;\n  }\n\n  void clear() final;\n  DimensionIndex NumActiveDimensions() const final;\n  void ShrinkToFit() final;\n  size_t MemoryUsageExcludingDocids() const final;\n  inline DatapointPtr<T> operator[](size_t i) const final;\n  void set_dimensionality(DimensionIndex dimensionality) final;\n  void set_is_binary(bool val) final;\n  void GetDenseDatapoint(size_t index, Datapoint<double>* result) const final;\n  inline void Prefetch(size_t index) const final;\n  double GetDistance(const DistanceMeasure& dist, size_t vec1_index,\n                     size_t vec2_index) const final;\n  using TypedDataset<T>::Append;\n  Status Append(const DatapointPtr<T>& dptr, string_view docid) final;\n  Status Append(const GenericFeatureVector& gfv, string_view docid) final;\n  shared_ptr<DocidCollectionInterface> ReleaseDocids() final;\n\n  using TypedDataset<T>::AppendOrDie;\n\n  void AppendOrDie(ConstSpan<T> values, string_view docid) {\n    AppendOrDie(MakeDatapointPtr<T>(values), docid);\n  }\n  void AppendOrDie(ConstSpan<T> values) {\n    AppendOrDie(MakeDatapointPtr<T>(values), absl::StrCat(this->size()));\n  }\n\n  StatusOr<typename TypedDataset<T>::Mutator*> GetMutator() const final;\n\n  DimensionIndex Dimen() { return stride_;};\n\n  int AddDocid(string_view docid) {\n    this->AppendDocid(docid);\n    return 0;\n  }\n\n private:\n  void SetStride();\n\n  std::vector<T> data_;\n\n  DimensionIndex stride_ = 0;\n\n  mutable unique_ptr<typename DenseDataset<T>::Mutator> mutator_;\n\n  template <typename U>\n  friend class DenseDataset;\n};\n\ntemplate <typename T>\nclass DenseDatasetSubView;\n\ntemplate <typename T>\nclass DenseDatasetView : VirtualDestructor {\n public:\n  DenseDatasetView() {}\n\n  virtual const T* GetPtr(size_t i) const = 0;\n\n  virtual size_t dimensionality() const = 0;\n\n  virtual size_t size() const = 0;\n\n  virtual std::unique_ptr<DenseDatasetView<T>> subview(size_t offset,\n                                                       size_t size) const {\n    return absl::make_unique<DenseDatasetSubView<T>>(this, offset, size);\n  }\n};\n\ntemplate <typename T>\nclass DefaultDenseDatasetView : public DenseDatasetView<T> {\n public:\n  DefaultDenseDatasetView() {}\n\n  explicit DefaultDenseDatasetView(const DenseDataset<T>& ds)\n      : ptr_(ds.data().data()), size_(ds.size()) {\n    if (ds.packing_strategy() == HashedItem::BINARY) {\n      dims_ = ds.dimensionality() / 8 + (ds.dimensionality() % 8 > 0);\n    } else if (ds.packing_strategy() == HashedItem::NIBBLE) {\n      dims_ = ds.dimensionality() / 2 + (ds.dimensionality() % 2 > 0);\n    } else {\n      dims_ = ds.dimensionality();\n    }\n  }\n\n  explicit DefaultDenseDatasetView(ConstSpan<T> span, size_t dimensionality)\n      : ptr_(span.data()),\n        dims_(dimensionality),\n        size_(span.size() / dimensionality) {}\n\n  SCANN_INLINE const T* GetPtr(size_t i) const final {\n    return ptr_ + i * dims_;\n  }\n\n  SCANN_INLINE size_t dimensionality() const final { return dims_; }\n\n  SCANN_INLINE size_t size() const final { return size_; }\n\n  std::unique_ptr<DenseDatasetView<T>> subview(size_t offset,\n                                               size_t size) const final {\n    return absl::WrapUnique(\n        new DefaultDenseDatasetView<T>(ptr_ + offset * dims_, dims_, size));\n  }\n\n private:\n  DefaultDenseDatasetView(const T* ptr, size_t dim, size_t size)\n      : ptr_(ptr), dims_(dim), size_(size) {}\n\n  const T* __restrict__ ptr_ = nullptr;\n  size_t dims_ = 0;\n  size_t size_ = 0;\n};\n\ntemplate <typename T>\nclass DenseDatasetSubView : public DenseDatasetView<T> {\n public:\n  DenseDatasetSubView(const DenseDatasetView<T>* parent, size_t offset,\n                      size_t size)\n      : parent_view_(parent), offset_(offset), size_(size) {}\n\n  SCANN_INLINE const T* GetPtr(size_t i) const final {\n    return parent_view_->GetPtr(offset_ + i);\n  }\n\n  SCANN_INLINE size_t dimensionality() const final {\n    return parent_view_->dimensionality();\n  };\n\n  SCANN_INLINE size_t size() const final { return size_; }\n\n  std::unique_ptr<DenseDatasetView<T>> subview(size_t offset,\n                                               size_t size) const final {\n    return absl::make_unique<DenseDatasetSubView<T>>(parent_view_,\n                                                     offset + offset_, size);\n  }\n\n private:\n  const DenseDatasetView<T>* __restrict__ parent_view_ = nullptr;\n  const size_t offset_ = 0;\n  const size_t size_ = 0;\n};\n\ntemplate <typename T>\nclass SparseDataset final : public TypedDataset<T> {\n public:\n  SCANN_DECLARE_MOVE_ONLY_CLASS(SparseDataset);\n\n  SparseDataset() {}\n\n  explicit SparseDataset(unique_ptr<DocidCollectionInterface> docids)\n      : TypedDataset<T>(std::move(docids)) {}\n\n  explicit SparseDataset(DimensionIndex dimensionality) : SparseDataset() {\n    this->set_dimensionality(dimensionality);\n  }\n\n  bool IsDense() const final { return false; }\n\n  using const_iterator = RandomAccessIterator<const SparseDataset<T>>;\n  const_iterator begin() const { return const_iterator(this, 0); }\n  const_iterator end() const { return const_iterator(this, this->size()); }\n\n  using TypedDataset<T>::Append;\n\n  Status Append(const GenericFeatureVector& gfv, string_view docid) final;\n  Status Append(const DatapointPtr<T>& dptr, string_view docid) final;\n\n  using TypedDataset<T>::AppendOrDie;\n\n  void AppendOrDie(ConstSpan<DimensionIndex> indices, ConstSpan<T> values,\n                   string_view docid = \"\") {\n    AppendOrDie(MakeDatapointPtr<T>(indices, values, this->dimensionality()),\n                docid);\n  }\n\n  void Reserve(size_t n_points) final;\n\n  void Reserve(size_t n_points, size_t n_entries);\n\n  DimensionIndex NonzeroEntriesForDatapoint(DatapointIndex i) const {\n    return repr_.NonzeroEntriesForDatapoint(i);\n  }\n\n  size_t num_entries() const { return repr_.indices().size(); }\n\n  bool AllValuesNonNegative() const {\n    return std::is_unsigned<T>::value || repr_.values().empty() ||\n           *std::min_element(repr_.values().begin(), repr_.values().end()) >= 0;\n  }\n\n  void clear() final;\n\n  void ConvertType(SparseDataset<double>* target);\n\n  inline DatapointPtr<T> operator[](size_t i) const final;\n  void set_dimensionality(DimensionIndex dimensionality) final;\n  DimensionIndex NumActiveDimensions() const final;\n  void GetDenseDatapoint(size_t index, Datapoint<double>* result) const final;\n  inline void Prefetch(size_t index) const final;\n  double GetDistance(const DistanceMeasure& dist, size_t vec1_index,\n                     size_t vec2_index) const final;\n  size_t MemoryUsageExcludingDocids() const final;\n  void ShrinkToFit() final;\n\n  StatusOr<typename TypedDataset<T>::Mutator*> GetMutator() const final {\n    return UnimplementedError(\"Sparse dataset does not support mutation.\");\n  }\n\n private:\n  Status AppendImpl(const GenericFeatureVector& gfv, string_view docid);\n  Status AppendImpl(const DatapointPtr<T>& dptr, string_view docid);\n\n  mutable SparseDatasetLowLevel<DimensionIndex, T> repr_;\n\n  template <typename U>\n  friend class SparseDataset;\n};\n\ntemplate <typename T>\nDatapointPtr<T> DenseDataset<T>::operator[](size_t i) const {\n  DCHECK_LT(i, this->size());\n  return MakeDatapointPtr(nullptr, data_.data() + i * stride_, stride_,\n                          this->dimensionality());\n}\n\ntemplate <typename T>\nvoid DenseDataset<T>::Prefetch(size_t i) const {\n  DCHECK_LT(i, this->size());\n  ::tensorflow::port::prefetch<::tensorflow::port::PREFETCH_HINT_NTA>(\n      reinterpret_cast<const char*>(data_.data() + i * stride_));\n}\n\ntemplate <typename T>\ntemplate <typename Real>\nvoid DenseDataset<T>::ConvertType(DenseDataset<Real>* target) const {\n  static_assert(std::is_floating_point<Real>(),\n                \"Real template parameter must be either float or double for \"\n                \"DenseDataset::ConvertType.\");\n  CHECK(!this->is_binary()) << \"Not implemented for binary datasets.\";\n  DCHECK(target);\n  target->clear();\n  target->set_dimensionality_no_checks(this->dimensionality());\n  target->stride_ = stride_;\n  target->set_docids_no_checks(this->docids()->Copy());\n  target->data_.insert(target->data_.begin(), data_.begin(), data_.end());\n}\n\ntemplate <typename T>\nDatapointPtr<T> SparseDataset<T>::operator[](size_t i) const {\n  DCHECK_LT(i, this->size());\n  auto low_level_result = repr_.Get(i);\n  return MakeDatapointPtr(low_level_result.indices, low_level_result.values,\n                          low_level_result.nonzero_entries,\n                          this->dimensionality());\n}\n\ntemplate <typename T>\nvoid SparseDataset<T>::Prefetch(size_t i) const {\n  DCHECK_LT(i, this->size());\n  repr_.Prefetch(i);\n}\n\nSCANN_INSTANTIATE_TYPED_CLASS(extern, TypedDataset);\nSCANN_INSTANTIATE_TYPED_CLASS(extern, SparseDataset);\nSCANN_INSTANTIATE_TYPED_CLASS(extern, DenseDataset);\n\n}\n\n#endif\n\n'gamma/third_party/scann-1.2.1/scann/utils/scalar_quantization_helpers.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SCANN_UTILS_SCALAR_QUANTIZATION_HELPERS_H_\n#define SCANN_UTILS_SCALAR_QUANTIZATION_HELPERS_H_\n\n#include <cstdint>\n\n#include \"scann/data_format/datapoint.h\"\n#include \"scann/data_format/dataset.h\"\n#include \"scann/utils/common.h\"\n#include \"scann/utils/types.h\"\n\nnamespace research_scann {\n\nstruct ScalarQuantizationResults {\n  DenseDataset<int8_t> quantized_dataset;\n\n  vector<float> multiplier_by_dimension;\n\n  vector<float> inverse_multiplier_by_dimension;\n};\n\nSCANN_INLINE int8_t Int8Quantize(float value) {\n  const float fp_val = std::round(value);\n  if (ABSL_PREDICT_FALSE(fp_val > numeric_limits<int8_t>::max())) {\n    return numeric_limits<int8_t>::max();\n  }\n  if (ABSL_PREDICT_FALSE(fp_val < numeric_limits<int8_t>::min())) {\n    return numeric_limits<int8_t>::min();\n  }\n  return fp_val;\n}\n\nstd::vector<float> ComputeMaxQuantizationMultipliers(\n    const DenseDataset<float>& dataset);\n\nstd::vector<float> ComputeQuantiledQuantizationMultipliers(\n    const DenseDataset<float>& dataset, float multiplier_quantile);\n\nScalarQuantizationResults ScalarQuantizeFloatDataset(\n    const DenseDataset<float>& dataset, float multiplier_quantile = 1.0f,\n    double noise_shaping_threshold = NAN);\n\nScalarQuantizationResults ScalarQuantizeFloatDatasetWithMultipliers(\n    const DenseDataset<float>& dataset, std::vector<float> multipliers,\n    double noise_shaping_threshold = NAN);\n\nDatapointPtr<int8_t> ScalarQuantizeFloatDatapoint(\n    const DatapointPtr<float>& dptr, absl::Span<const float> multipliers,\n    std::vector<int8_t>* quantized_storage);\n\nDatapointPtr<int8_t> ScalarQuantizeFloatDatapointWithNoiseShaping(\n    const DatapointPtr<float>& dptr, absl::Span<const float> multipliers,\n    const double noise_shaping_threshold, vector<int8_t>* quantized_storage,\n    int* num_changes = nullptr, double* residual_ptr = nullptr,\n    double* parallel_residual_ptr = nullptr);\n\nDatapointPtr<int8_t> ScalarQuantizeFloatDatapointWithNoiseShaping(\n    const DatapointPtr<float>& dptr, absl::Span<const float> multipliers,\n    const double noise_shaping_threshold, MutableSpan<int8_t> quantized,\n    int* num_changes = nullptr, double* residual_ptr = nullptr,\n    double* parallel_residual_ptr = nullptr);\n\nDatapointPtr<int8_t> ScalarQuantizeFloatDatapoint(\n    const DatapointPtr<float>& dptr, float multiplier,\n    vector<int8_t>* quantized_storage);\n\nunique_ptr<float[]> PrepareForAsymmetricScalarQuantizedDotProduct(\n    const DatapointPtr<float>& dptr,\n    ConstSpan<float> inverse_multiplier_by_dimension);\n\n}\n\n#endif\n\n'gamma/third_party/scann-1.2.1/scann/data_format/sparse_low_level.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef SCANN_DATA_FORMAT_SPARSE_LOW_LEVEL_H_\n#define SCANN_DATA_FORMAT_SPARSE_LOW_LEVEL_H_\n\n#include \"scann/utils/types.h\"\n\nnamespace research_scann {\n\ntemplate <typename IndexT, typename ValueT>\nstruct SparseLowLevelDatapoint {\n  SparseLowLevelDatapoint(IndexT* indices, ValueT* values,\n                          DimensionIndex nonzero_entries)\n      : indices(indices), values(values), nonzero_entries(nonzero_entries) {}\n\n  IndexT* indices = nullptr;\n\n  ValueT* values = nullptr;\n\n  DimensionIndex nonzero_entries = 0;\n};\n\ntemplate <typename IndexT, typename ValueT, typename StartOffsetT = size_t>\nclass SparseDatasetLowLevel {\n public:\n  SparseDatasetLowLevel() {}\n\n  SparseDatasetLowLevel(std::vector<IndexT> indices, std::vector<ValueT> values,\n                        std::vector<StartOffsetT> start_offsets)\n      : indices_(std::move(indices)),\n        values_(std::move(values)),\n        start_offsets_(std::move(start_offsets)) {\n    if (!values_.empty()) {\n      CHECK_EQ(values_.size(), indices_.size());\n    }\n    if (!indices_.empty()) {\n      CHECK_GE(start_offsets_.size(), 2);\n    }\n  }\n\n  void Append(ConstSpan<IndexT> indices, ConstSpan<ValueT> values) {\n    if (!values.empty() || !values_.empty()) {\n      DCHECK_EQ(indices.size(), values.size());\n    }\n    indices_.insert(indices_.end(), indices.begin(), indices.end());\n    values_.insert(values_.end(), values.begin(), values.end());\n\n    CHECK_LE(indices_.size(), numeric_limits<StartOffsetT>::max());\n    start_offsets_.push_back(indices_.size());\n  }\n\n  void PopBack() {\n    DCHECK_GT(start_offsets_.size(), 1);\n    start_offsets_.pop_back();\n    indices_.resize(start_offsets_.back());\n    if (!values_.empty()) values_.resize(indices_.size());\n  }\n\n  SparseLowLevelDatapoint<IndexT, ValueT> Get(size_t i) {\n    DCHECK_LT(i + 1, start_offsets_.size());\n    const size_t end_offset = start_offsets_[i + 1];\n    const size_t start_offset = start_offsets_[i];\n    const DimensionIndex nonzero_entries = end_offset - start_offset;\n    ValueT* values_ptr =\n        (values_.empty()) ? nullptr : (values_.data() + start_offset);\n    return SparseLowLevelDatapoint<IndexT, ValueT>(\n        indices_.data() + start_offset, values_ptr, nonzero_entries);\n  }\n\n  DimensionIndex NonzeroEntriesForDatapoint(size_t i) const {\n    DCHECK_LT(i + 1, start_offsets_.size());\n    return start_offsets_[i + 1] - start_offsets_[i];\n  }\n\n  ConstSpan<IndexT> indices() const { return indices_; }\n  ConstSpan<ValueT> values() const { return values_; }\n  ConstSpan<StartOffsetT> start_offsets() const { return start_offsets_; }\n\n  void Reserve(size_t n_points) { start_offsets_.reserve(n_points + 1); }\n\n  void Reserve(size_t n_points, size_t n_entries) {\n    ReserveForBinaryData(n_points, n_entries);\n    values_.reserve(n_entries);\n  }\n\n  void ReserveForBinaryData(size_t n_points, size_t n_entries) {\n    Reserve(n_points);\n    indices_.reserve(n_entries);\n  }\n\n  void Clear() {\n    FreeBackingStorage(&indices_);\n    FreeBackingStorage(&values_);\n    FreeBackingStorage(&start_offsets_);\n    start_offsets_ = {0};\n  }\n\n  void ShrinkToFit() {\n    start_offsets_.shrink_to_fit();\n\n    if (indices_.size() * sizeof(indices_[0]) <\n        values_.size() * sizeof(values_[0])) {\n      indices_.shrink_to_fit();\n      values_.shrink_to_fit();\n    } else {\n      values_.shrink_to_fit();\n      indices_.shrink_to_fit();\n    }\n  }\n\n  size_t MemoryUsage() const {\n    return sizeof(ValueT) * values_.capacity() +\n           sizeof(IndexT) * indices_.capacity() +\n           sizeof(StartOffsetT) * start_offsets_.capacity();\n  }\n\n  void Prefetch(size_t i) const {\n    const StartOffsetT start_offset = start_offsets_[i];\n    ::tensorflow::port::prefetch<::tensorflow::port::PREFETCH_HINT_NTA>(\n        reinterpret_cast<const char*>(indices_.data() + start_offset));\n    ::tensorflow::port::prefetch<::tensorflow::port::PREFETCH_HINT_NTA>(\n        reinterpret_cast<const char*>(values_.data() + start_offset));\n  }\n\n  size_t size() const { return start_offsets_.size() - 1; }\n\n private:\n  std::vector<IndexT> indices_;\n  std::vector<ValueT> values_;\n  std::vector<StartOffsetT> start_offsets_ = {0};\n};\n\n}\n\n#endif\n",
        "gt": [
            "'gamma/third_party/scann-1.2.1/scann/data_format/sparse_low_level.h'",
            "'gamma/third_party/scann-1.2.1/scann/data_format/dataset.h'",
            "'gamma/third_party/scann-1.2.1/scann/utils/scalar_quantization_helpers.h'"
        ]
    },
    {
        "files": [
            "'LearnVulkan/Android/app/src/main/cpp/native-lib.cpp'",
            "'LearnVulkan/third_party/glm/glm/vec2.hpp'",
            "'LearnVulkan/source/base/VulkanBase.h'",
            "'LearnVulkan/third_party/glm/glm/glm.hpp'"
        ],
        "content": "'LearnVulkan/Android/app/src/main/cpp/native-lib.cpp'\n:#include <jni.h>\n#include <string>\n\n#include \"VulkanBase.h\"\n#include \"StaticTriangle.h\"\n#include \"StaticCube.h\"\n#include \"Texture2dCube.h\"\n#include \"SkyboxCube.h\"\n#include \"PhongLighting.h\"\n#include \"InstanceDraw.h\"\n#include \"ShadowMapping.h\"\n#include \"ShadowMappingOnmi.h\"\n#include \"AssimpModelSample.h\"\n\nenum VulkanExampleNames {\n    Example_StaticTriangle = 0,\n    Example_StaticCube,\n    Example_Texture2dCube,\n    Example_SkyboxCube,\n    Example_PhongLighting,\n    Example_InstanceDraw,\n    Example_ShadowMapping,\n    Example_ShadowMappingOnmi,\n    Example_AssimpModelSample,\n};\n\nextern \"C\"\nJNIEXPORT jlong JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_createInstance(JNIEnv *env, jobject thiz,\n                                                                   jint id) {\n    if(id == Example_StaticTriangle){\n        auto *engine = new VulkanEngine::StaticTriangle();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_StaticCube){\n        auto *engine = new VulkanEngine::StaticCube();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_Texture2dCube){\n        auto *engine = new VulkanEngine::Texture2dCube();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_SkyboxCube){\n        auto *engine = new VulkanEngine::SkyboxCube();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n    else if(id == Example_PhongLighting){\n        auto *engine = new VulkanEngine::PhongLighting();\n        return (jlong) engine;\n    }\n    else if(id == Example_InstanceDraw){\n        auto *engine = new VulkanEngine::InstanceDraw();\n        return (jlong) engine;\n    }\n    else if(id == Example_ShadowMapping){\n        auto *engine = new VulkanEngine::ShadowMapping();\n        return (jlong) engine;\n    }\n    else if(id == Example_ShadowMappingOnmi){\n        auto *engine = new VulkanEngine::ShadowMappingOnmi();\n        return (jlong) engine;\n    }\n    else if(id == Example_AssimpModelSample) {\n        auto *engine = new VulkanEngine::AssimpModelSample();\n        return (jlong) engine;\n    }\n    else{\n        auto *engine = new VulkanEngine::StaticTriangle();\n        LOGI(\"CreateInstance %ld\", engine);\n        return (jlong) engine;\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_initVulkan(JNIEnv *env, jobject thiz,\n                                                               jlong instance) {\n\n    if (instance){\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase*>(instance);\n        engine->initVulkan();\n        engine->prepare();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_renderFrame(JNIEnv *env, jobject thiz,\n                                                                jlong instance) {\n\n    if (instance){\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase*>(instance);\n        engine->renderFrame();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setSurface(JNIEnv *env, jobject thiz,\n                                                               jlong instance, jobject surface) {\n\n    auto window = ANativeWindow_fromSurface(env, surface);\n\n    assert(window);\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = (VulkanEngine::VulkanBase *) instance;\n        LOGI(\"New Surface %ld\", window);\n        engine->setWindow(window);\n        uint32_t width = static_cast<uint32_t >(ANativeWindow_getWidth(window));\n        uint32_t height = static_cast<uint32_t >(ANativeWindow_getHeight(window));\n        engine->setWidth(width);\n        engine->setHeight(height);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setAssetManager(JNIEnv *env, jobject thiz,\n                                                                    jlong instance,\n                                                                    jobject asset_manager) {\n\n    auto asset = AAssetManager_fromJava(env, asset_manager);\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setAssetManager(asset);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setTouchPos(JNIEnv *env, jobject thiz,\n                                                                jlong instance, jfloat x,\n                                                                jfloat y) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setTouchPos(x, y);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setTouchPosSecond(JNIEnv *env, jobject thiz,\n                                                                      jlong instance, jfloat x,\n                                                                      jfloat y) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setTouchPosSecond(x, y);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_setTouchMode(JNIEnv *env, jobject thiz,\n                                                                 jlong instance, jint mode) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->setTouchMode(VulkanEngine::VulkanBase::TouchMode(mode));\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_resetTouch(JNIEnv *env, jobject thiz,\n                                                               jlong instance) {\n\n    if (instance) {\n        VulkanEngine::VulkanBase *engine = reinterpret_cast<VulkanEngine::VulkanBase *>(instance);\n        engine->resetTouch();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_deleteVulkan(JNIEnv *env, jobject thiz,\n                                                                 jlong instance, jint id) {\n\n    if (instance) {\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine*>(instance);\n        delete (engine);\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_destroySurface(JNIEnv *env, jobject thiz,\n                                                                   jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->destroySurface();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_rebuildSurface(JNIEnv *env, jobject thiz,\n                                                                   jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->rebuildSurface();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_pause(JNIEnv *env, jobject thiz,\n                                                          jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->pause();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_resume(JNIEnv *env, jobject thiz,\n                                                           jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->resume();\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_waitCurrentFrameComplete(JNIEnv *env,\n                                                                             jobject thiz,\n                                                                             jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->waitForCurrentFrameComplete();\n        LOGI(\"waitForCurrentFrameComplete\");\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_destroyANativeWindow(JNIEnv *env, jobject thiz,\n                                                                         jlong instance) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->destroyANativeWindow();\n        LOGI(\"destroyANativeWindow\");\n    }\n}\n\nextern \"C\"\nJNIEXPORT void JNICALL\nJava_com_engineer1109_learnvulkan_render_BaseRender_runFunction(JNIEnv *env, jobject thiz,\n                                                            jlong instance, jint i) {\n\n    if(instance){\n        auto *engine = reinterpret_cast<VulkanEngine::VulkanBaseEngine *>(instance);\n        engine->runFunction(i);\n    }\n}\n'LearnVulkan/third_party/glm/glm/vec2.hpp'\n:\n\n\n#pragma once\n#include \"./ext/vector_bool2.hpp\"\n#include \"./ext/vector_bool2_precision.hpp\"\n#include \"./ext/vector_float2.hpp\"\n#include \"./ext/vector_float2_precision.hpp\"\n#include \"./ext/vector_double2.hpp\"\n#include \"./ext/vector_double2_precision.hpp\"\n#include \"./ext/vector_int2.hpp\"\n#include \"./ext/vector_int2_precision.hpp\"\n#include \"./ext/vector_uint2.hpp\"\n#include \"./ext/vector_uint2_precision.hpp\"\n\n'LearnVulkan/source/base/VulkanBase.h'\n:\n\n\n\n#ifndef LEARNVULKAN_VULKANBASE_H\n#define LEARNVULKAN_VULKANBASE_H\n\n#include \"render_common.h\"\n#include \"base_template.h\"\n#include \"filesystem_utils.h\"\n#include \"vulkan_macro.h\"\n#include \"vulkan_template.h\"\n\n#include \"VulkanTools.h\"\n#include \"VulkanDevice.hpp\"\n#include \"VulkanSwapChain.hpp\"\n#include \"keycodes.hpp\"\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n\nclass CommandLineParser;\n\nBEGIN_NAMESPACE(VulkanEngine)\n\nclass VULKANENGINE_EXPORT_API VulkanBase {\npublic:\n    VulkanBase() = default;\n\n    virtual ~VulkanBase();\n\n    void setWidth(const uint32_t &width) { m_width = width; }\n\n    void setHeight(const uint32_t &height) { m_height = height; }\n\n    void parseArgs(int argc, char** argv);\n\n    void initVulkan();\n\n    virtual void prepare();\n\n    virtual void prepareBase();\n\n    virtual void renderLoop();\n\n    virtual void renderFrame();\n\n    virtual void updateOverlay() {}\n\n    virtual void render();\n\n    virtual void draw();\n\n    virtual void updateCommand() {}\n\n    void waitForCurrentFrameComplete();\n\n    void pause() { m_pause = true; }\n\n    void resume() { m_pause = false; }\n\n    void quit() { m_quit = true; }\n\n    bool getPrepared() const { return m_prepared; }\n\nprotected:\n    void createInstance();\n\n    void pickPhysicalDevice();\n\n    virtual void getDeviceFeatures() {}\n\n    void createLogicalDevice();\n\n    void initSwapchain();\n\n    void createCommandPool();\n\n    void setupSwapChain();\n\n    void createCommandBuffers();\n\n    void createSynchronizationPrimitives();\n\n    void setupDepthStencil();\n\n    void setupRenderPass();\n\n    void createPipelineCache();\n\n    void setupFrameBuffer();\n\n    virtual void buildCommandBuffers() {};\n\n    void prepareFrame();\n\n    void submitFrame();\n\npublic:\n\n    void destroySurface();\n\n    void destroyCommandBuffers();\n\n    void windowResize();\n\n    void handleMouseMove(float x, float y);\n\n    virtual void keyPressed(uint32_t) {}\n\n    virtual void prepareFunctions() {}\n\n    virtual void runFunction(int i);\n\n#if defined(_WIN32)\n    HWND setupWindow();\n    void handleMessages(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\n    bool m_resizing = false;\n#elif defined(VK_USE_PLATFORM_XCB_KHR)\n\n    void initxcbConnection();\n\n    xcb_window_t setupWindow();\n\n    void handleEvent(const xcb_generic_event_t *event);\n\n#endif\n\n    void setMouseButtonLeft(bool value) { m_mouseButtons.left = value; }\n\n    void setMouseButtonRight(bool value) { m_mouseButtons.right = value; }\n\n    void setMouseButtonMiddle(bool value) { m_mouseButtons.middle = value; }\n\n#if defined(_WIN32)\n    void setWindow(HWND window) {\n#elif defined(VK_USE_PLATFORM_XCB_KHR)\n    void setWindow(xcb_window_t window) {\n#endif\n    m_window = window;\n    }\n\n\nprotected:\n#if defined(_WIN32)\n    HWND m_window = NULL;\n    HINSTANCE m_windowInstance = NULL;\n#elif defined(VK_USE_PLATFORM_XCB_KHR)\n    xcb_connection_t *m_connection = nullptr;\n    xcb_screen_t *m_screen = nullptr;\n    xcb_window_t m_window = NULL;\n    xcb_intern_atom_reply_t *m_atom_wm_delete_window = nullptr;\n#endif\n    uint32_t m_width = 1280;\n    uint32_t m_height = 720;\n    uint32_t m_destWidth = 1280;\n    uint32_t m_destHeight = 720;\n\n    bool m_debug = false;\n\n    VkResult m_result = VK_SUCCESS;\n    VkInstance m_instance = VK_NULL_HANDLE;\n    VkPhysicalDevice m_physicalDevice = VK_NULL_HANDLE;\n    VkDevice m_device = VK_NULL_HANDLE;\n    VkQueue m_queue = VK_NULL_HANDLE;\n    VkCommandPool m_cmdPool = VK_NULL_HANDLE;\n    uint32_t m_selectGPUIndex = 0;\n\n    std::vector<const char *> m_enabledDeviceExtensions;\n    std::vector<const char *> m_enabledInstanceExtensions;\n    VkPhysicalDeviceFeatures m_enabledFeatures;\n    void *m_deviceCreatepNextChain = nullptr;\n\n    VkPhysicalDeviceProperties m_deviceProperties;\n    VkPhysicalDeviceFeatures m_deviceFeatures;\n    VkPhysicalDeviceMemoryProperties m_deviceMemoryProperties;\n\n    vks::VulkanDevice *m_vulkanDevice = nullptr;\n    VulkanSwapChain m_swapChain;\n    struct RenderSemaphores {\n\n        VkSemaphore presentComplete = VK_NULL_HANDLE;\n\n        VkSemaphore renderComplete = VK_NULL_HANDLE;\n    } m_semaphores;\n\n    struct {\n        VkImage image = VK_NULL_HANDLE;\n        VkDeviceMemory mem = VK_NULL_HANDLE;\n        VkImageView view = VK_NULL_HANDLE;\n    } m_depthStencil;\n\n    std::vector<VkFence> m_waitFences;\n\n    VkFormat m_depthFormat = VK_FORMAT_D16_UNORM_S8_UINT;\n    VkSubmitInfo m_submitInfo;\n    VkPipelineStageFlags m_submitPipelineStages = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;\n\n\n    std::vector<VkCommandBuffer> m_drawCmdBuffers;\n    VkRenderPass m_renderPass;\n    std::vector<VkFramebuffer> m_frameBuffers;\n    uint32_t m_currentBuffer = 0;\n    VkDescriptorPool m_descriptorPool = VK_NULL_HANDLE;\n    std::vector<VkShaderModule> m_shaderModules;\n    VkPipelineCache m_pipelineCache;\n\n    bool m_stop = false;\n    bool m_quit = false;\n    bool m_pause = false;\n    bool m_prepared = false;\n    bool m_signalFrame = true;\n\n    glm::vec2 m_mousePos;\n    glm::vec2 m_mousePosOld;\n\n    float m_distance = 0.f;\n    float m_oldDistance = 0.f;\n    float m_frameTimer = 0.f;\n\n    struct Settings {\n        bool fullScreen = false;\n    } m_settings;\n\n    struct MouseButton {\n        bool left = false;\n        bool right = false;\n        bool middle = false;\n    } m_mouseButtons;\n\n    struct Scroll {\n        bool up = false;\n        bool down = false;\n    } m_scroll;\n\n    std::string m_title = \"Vulkan\";\n\n    std::vector<std::function<void()>> m_functions;\n\n    std::shared_ptr<CommandLineParser> m_commandParser{};\n};\n\nEND_NAMESPACE(VulkanEngine)\n\n\n#endif\n\n'LearnVulkan/third_party/glm/glm/glm.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"detail/_fixes.hpp\"\n\n#include \"detail/setup.hpp\"\n\n#pragma once\n\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <limits>\n#include <cassert>\n#include \"fwd.hpp\"\n\n#include \"vec2.hpp\"\n#include \"vec3.hpp\"\n#include \"vec4.hpp\"\n#include \"mat2x2.hpp\"\n#include \"mat2x3.hpp\"\n#include \"mat2x4.hpp\"\n#include \"mat3x2.hpp\"\n#include \"mat3x3.hpp\"\n#include \"mat3x4.hpp\"\n#include \"mat4x2.hpp\"\n#include \"mat4x3.hpp\"\n#include \"mat4x4.hpp\"\n\n#include \"trigonometric.hpp\"\n#include \"exponential.hpp\"\n#include \"common.hpp\"\n#include \"packing.hpp\"\n#include \"geometric.hpp\"\n#include \"matrix.hpp\"\n#include \"vector_relational.hpp\"\n#include \"integer.hpp\"\n",
        "gt": [
            "'LearnVulkan/third_party/glm/glm/vec2.hpp'",
            "'LearnVulkan/third_party/glm/glm/glm.hpp'",
            "'LearnVulkan/source/base/VulkanBase.h'",
            "'LearnVulkan/Android/app/src/main/cpp/native-lib.cpp'"
        ]
    },
    {
        "files": [
            "'kv_engine/executor/cb3_executorpool.h'",
            "'kv_engine/engines/ep/tests/module_tests/executorpool_test.h'",
            "'kv_engine/executor/fake_executorpool.h'"
        ],
        "content": "'kv_engine/executor/cb3_executorpool.h'\n:\n\n#pragma once\n\n\n\n#include \"executorpool.h\"\n#include \"task_type.h\"\n#include \"taskable.h\"\n#include <memcached/thread_pool_config.h>\n#include <platform/syncobject.h>\n#include <map>\n#include <set>\n#include <vector>\n\n\nclass CookieIface;\nclass TaskQueue;\nclass CB3ExecutorThread;\n\nusing ThreadQ = std::vector<std::unique_ptr<CB3ExecutorThread>>;\nusing TaskQpair = std::pair<ExTask, TaskQueue*>;\nusing TaskQ = std::vector<TaskQueue*>;\n\nclass CB3ExecutorPool : public ExecutorPool {\npublic:\n\n    CB3ExecutorPool(size_t maxThreads,\n                    ThreadPoolConfig::ThreadCount maxReaders,\n                    ThreadPoolConfig::ThreadCount maxWriters,\n                    ThreadPoolConfig::AuxIoThreadCount maxAuxIO,\n                    ThreadPoolConfig::NonIoThreadCount maxNonIO,\n                    ThreadPoolConfig::IOThreadsPerCore ioThreadsPerCore);\n\n    ~CB3ExecutorPool() override;\n\n    void addWork(size_t newWork, TaskType qType);\n\n    void lessWork(TaskType qType);\n\n    void startWork(TaskType taskType);\n\n    void doneWork(TaskType taskType);\n\n    bool trySleep(TaskType task_type) {\n        if (!numReadyTasks[static_cast<size_t>(task_type)]) {\n            numSleepers++;\n            return true;\n        }\n        return false;\n    }\n\n    void woke() {\n        numSleepers--;\n    }\n\n    TaskQueue* nextTask(CB3ExecutorThread& t, uint8_t tick);\n\n    TaskQueue* getSleepQ(TaskType curTaskType) {\n        return isHiPrioQset ? hpTaskQ[static_cast<size_t>(curTaskType)]\n                            : lpTaskQ[static_cast<size_t>(curTaskType)];\n    }\n\n    bool cancel(size_t taskId, bool remove = false) override;\n\n    bool wakeAndWait(size_t taskId) override;\n\n\n    void adjustWorkers(TaskType type, size_t newCount);\n\n    bool snoozeAndWait(size_t taskId, double tosleep) override;\n\n    void registerTaskable(Taskable& taskable) override;\n\n    void unregisterTaskable(Taskable& taskable, bool force) override;\n\n    size_t getNumTaskables() const override {\n        return numTaskables;\n    }\n\n    void doWorkerStat(Taskable& taskable,\n                      CookieIface& cookie,\n                      const AddStatFn& add_stat) override;\n\n\n    void doTasksStat(Taskable& taskable,\n                     CookieIface& cookie,\n                     const AddStatFn& add_stat) override;\n\n    void doTaskQStat(Taskable& taskable,\n                     CookieIface& cookie,\n                     const AddStatFn& add_stat) override;\n\n    size_t getNumWorkersStat() const override {\n        std::lock_guard<std::mutex> lh(tMutex);\n        return threadQ.size();\n    }\n\n    size_t getNumReaders() const override;\n\n    size_t getNumWriters() const override;\n\n    size_t getNumAuxIO() const override;\n\n    size_t getNumNonIO() const override;\n\n    std::string_view getName() const override {\n        return \"CB3\";\n    }\n\n    void setNumReaders(ThreadPoolConfig::ThreadCount v) override {\n        adjustWorkers(TaskType::Reader, calcNumReaders(v));\n    }\n\n    void setNumReadersExactly(uint16_t v) override {\n        adjustWorkers(TaskType::Reader, v);\n    }\n\n    size_t getNumReadersExactly() const override {\n        return numWorkers[static_cast<size_t>(TaskType::Reader)].load();\n    }\n\n    void setNumWriters(ThreadPoolConfig::ThreadCount v) override {\n        adjustWorkers(TaskType::Writer, calcNumWriters(v));\n    }\n\n    void setNumAuxIO(ThreadPoolConfig::AuxIoThreadCount v) override {\n        adjustWorkers(TaskType::AuxIO, calcNumAuxIO(v));\n    }\n\n    void setNumNonIO(ThreadPoolConfig::NonIoThreadCount v) override {\n        adjustWorkers(TaskType::NonIO, calcNumNonIO(v));\n    }\n\n    size_t getNumReadyTasks() const override {\n        return totReadyTasks;\n    }\n\n    size_t getNumSleepers() const override {\n        return numSleepers;\n    }\n\n    size_t schedule(ExTask task) override;\n\nprotected:\n    TaskQueue* _nextTask(CB3ExecutorThread& t, uint8_t tick);\n\n\n    ExTask _cancel(size_t taskId, bool remove = false);\n\n    bool _wake(size_t taskId);\n    virtual bool _startWorkers();\n\n\n    void _adjustWorkers(TaskType type, size_t desiredNumItems);\n\n    bool _snooze(size_t taskId, double tosleep);\n    size_t _schedule(ExTask task);\n    void _registerTaskable(Taskable& taskable);\n    void _unregisterTaskable(Taskable& taskable, bool force);\n    std::vector<ExTask> _stopTaskGroup(task_gid_t taskGID,\n                                       std::unique_lock<std::mutex>& lh,\n                                       bool force);\n    TaskQueue* _getTaskQueue(const Taskable& t, TaskType qType);\n    void _stopAndJoinThreads();\n\n    const size_t numTaskSets{static_cast<size_t>(TaskType::Count)};\n\n    std::atomic<size_t> totReadyTasks;\n    SyncObject mutex;\n\n\n    std::map<size_t, TaskQpair> taskLocator;\n\n\n    ThreadQ threadQ;\n\n\n    TaskQ hpTaskQ;\n    std::atomic_bool isHiPrioQset;\n\n    TaskQ lpTaskQ;\n    std::atomic_bool isLowPrioQset;\n\n\n    size_t numTaskables;\n\n\n    mutable SyncObject tMutex;\n\n    std::atomic<uint16_t> numSleepers;\n    std::vector<std::atomic<uint16_t>>\n            curWorkers;\n\n    std::vector<std::atomic<int>> numWorkers;\n    std::vector<std::atomic<size_t>>\n            numReadyTasks;\n\n\n    std::set<void*> taskOwners;\n\n\n    friend class ExecutorPool;\n};\n\n'kv_engine/engines/ep/tests/module_tests/executorpool_test.h'\n:\n\n\n\n\n#pragma once\n\n#include \"../mock/mock_synchronous_ep_engine.h\"\n#include \"../mock/mock_taskable.h\"\n#include \"thread_gate.h\"\n#include <executor/executorpool.h>\n#include <executor/fake_executorpool.h>\n#include <folly/portability/GTest.h>\n#include <platform/cb_arena_malloc.h>\n#include <thread>\n\nclass TestExecutorPool : public CB3ExecutorPool {\npublic:\n    TestExecutorPool(size_t maxThreads,\n                     ThreadPoolConfig::ThreadCount maxReaders,\n                     ThreadPoolConfig::ThreadCount maxWriters,\n                     ThreadPoolConfig::AuxIoThreadCount maxAuxIO,\n                     ThreadPoolConfig::NonIoThreadCount maxNonIO,\n                     ThreadPoolConfig::IOThreadsPerCore ioThreadsPerCore)\n        : CB3ExecutorPool(maxThreads,\n                          maxReaders,\n                          maxWriters,\n                          maxAuxIO,\n                          maxNonIO,\n                          ioThreadsPerCore) {\n    }\n\n    ~TestExecutorPool() override = default;\n};\n\ntemplate <typename T>\nclass ExecutorPoolTest : public ::testing::Test {\nprotected:\n\n\n\n\n\n\n    void makePool(int maxThreads,\n                  int numReaders = 2,\n                  int numWriters = 2,\n                  int numAuxIO = 2,\n                  int numNonIO = 2,\n                  int ioThreadsPerCore = 1);\n\n    std::unique_ptr<T> pool;\n\n    void testUnregisterClearsUpTasks(bool force, bool completeBeforeShutdown);\n    void testTaskRunningDuringShutdownResetsOnSchedulerThread();\n};\n\n\ntemplate <typename T>\nclass ExecutorPoolDeathTest : public ExecutorPoolTest<T> {};\n\n\ntemplate <typename T>\nclass ExecutorPoolEpEngineTest : public ExecutorPoolTest<T> {\nprotected:\n    ExecutorPoolEpEngineTest();\n\n    void SetUp() override;\n    void TearDown() override;\n\n\n    std::string config;\n    SynchronousEPEngineUniquePtr engine;\n};\n\nclass SingleThreadedExecutorPoolTest : public ::testing::Test {\npublic:\n    void SetUp() override {\n        {\n            cb::NoArenaGuard guard;\n            ExecutorPool::create(ExecutorPool::Backend::Fake);\n        }\n        pool = ExecutorPool::get();\n        pool->registerTaskable(taskable);\n    }\n\n    void TearDown() override {\n        pool->unregisterTaskable(taskable, false);\n        pool->shutdown();\n    }\n\n    ExecutorPool* pool;\n    ::testing::NiceMock<MockTaskable> taskable;\n};\n\ntemplate <typename T>\nclass ExecutorPoolDynamicWorkerTest : public ExecutorPoolTest<T> {\nprotected:\n\n\n    const size_t MaxThreads{18};\n\n    void SetUp() override {\n        ExecutorPoolTest<T>::SetUp();\n        this->makePool(MaxThreads, 2, 2, 2, 2);\n        this->pool->registerTaskable(taskable);\n    }\n\n    void TearDown() override {\n        this->pool->unregisterTaskable(taskable, false);\n        this->pool->shutdown();\n        ExecutorPoolTest<T>::TearDown();\n    }\n\n\n    std::unique_ptr<ThreadGate> tg;\n    ::testing::NiceMock<MockTaskable> taskable;\n};\n\nstruct ThreadCountsParams {\n\n    ThreadPoolConfig::ThreadCount in_reader_writer;\n    size_t maxThreads;\n\n\n    size_t reader;\n    size_t writer;\n    size_t auxIO;\n    size_t nonIO;\n};\n\n::std::ostream& operator<<(::std::ostream& os,\n                           const ThreadCountsParams& expected);\n\nclass ExecutorPoolTestWithParam\n    : public ExecutorPoolTest<TestExecutorPool>,\n      public ::testing::WithParamInterface<ThreadCountsParams> {};\n\n'kv_engine/executor/fake_executorpool.h'\n:\n\n\n\n\n#pragma once\n\n#include \"cb3_executorpool.h\"\n#include \"cb3_executorthread.h\"\n#include \"cb3_taskqueue.h\"\n#include <platform/cb_arena_malloc.h>\n#include <memory>\n\nclass SingleThreadedExecutorPool : public CB3ExecutorPool {\npublic:\n    explicit SingleThreadedExecutorPool()\n        : CB3ExecutorPool( 0,\n                          ThreadPoolConfig::ThreadCount::Default,\n                          ThreadPoolConfig::ThreadCount::Default,\n                          ThreadPoolConfig::AuxIoThreadCount::Default,\n                          ThreadPoolConfig::NonIoThreadCount::Default,\n                          ThreadPoolConfig::IOThreadsPerCore::Default) {\n    }\n\n    bool _startWorkers() override {\n\n\n        return true;\n    }\n\n\n\n    TaskQ& getLpTaskQ() {\n        return lpTaskQ;\n    }\n\n    TaskQueue* getLpTaskQ(TaskType t) const {\n        Expects(t != TaskType::None);\n        return lpTaskQ[static_cast<size_t>(t)];\n    }\n\n\n    void cancelAndClearAll() {\n        std::lock_guard<std::mutex> lh(tMutex);\n        cancelAll_UNLOCKED();\n\n\n\n        cb::NoArenaGuard guard;\n        taskLocator.clear();\n    }\n\n\n    void cancelAll() {\n        std::lock_guard<std::mutex> lh(tMutex);\n        cancelAll_UNLOCKED();\n    }\n\n\n    void cancelByName(std::string_view name) {\n        std::lock_guard<std::mutex> lh(tMutex);\n        for (auto& it : taskLocator) {\n            if (name == it.second.first->getDescription().c_str()) {\n                it.second.first->cancel();\n\n                it.second.second->wake(it.second.first);\n            }\n        }\n    }\n\n\n    bool isTaskScheduled(TaskType queueType, std::string_view name) {\n        std::lock_guard<std::mutex> lh(tMutex);\n        for (auto& it : taskLocator) {\n            auto description = it.second.first->getDescription();\n            if (name != std::string_view(description.c_str())) {\n                continue;\n            }\n            if (it.second.second->getQueueType() != queueType) {\n                continue;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    size_t getTotReadyTasks() {\n        return totReadyTasks;\n    }\n\n    size_t getNumReadyTasksOfType(TaskType qType) {\n        return numReadyTasks[static_cast<size_t>(qType)];\n    }\n\n    std::map<size_t, TaskQpair> getTaskLocator() {\n        return taskLocator;\n    };\n\n\n    void runNextTask(TaskType taskType, std::string expectedTask);\n\nprivate:\n    void cancelAll_UNLOCKED() {\n        for (auto& it : taskLocator) {\n            it.second.first->cancel();\n\n            it.second.second->wake(it.second.first);\n        }\n    }\n};\n\n\nclass CheckedExecutor : public CB3ExecutorThread {\npublic:\n    CheckedExecutor(ExecutorPool* manager_,\n                    TaskQueue& q,\n                    std::chrono::steady_clock::duration timeAdvance =\n                            std::chrono::steady_clock::duration::zero())\n\n\n        : CB3ExecutorThread(dynamic_cast<CB3ExecutorPool*>(manager_),\n                            q.getQueueType(),\n                            \"checked_executor\"),\n          nowAdjustment(timeAdvance),\n          queue(q),\n          preFutureQueueSize(queue.getFutureQueueSize()),\n          preReadyQueueSize(queue.getReadyQueueSize()) {\n        if (!queue.fetchNextTask(*this)) {\n            throw std::logic_error(\"CheckedExecutor failed fetchNextTask\");\n        }\n\n\n        if (getTaskName() == \"Snapshotting vbucket states\" ||\n            getTaskName() == \"Adjusting hash table sizes.\") {\n            checker = [this](bool taskRescheduled) {\n\n                this->oneExecutes(taskRescheduled, 1);\n            };\n        } else if (getTaskName() == \"CheckpointMemRecoveryTask:0\") {\n            checker = [this](bool taskRescheduled) {\n\n\n                this->oneExecutes(taskRescheduled,  0,  2);\n            };\n        } else if (getTaskName() == \"Paging out items.\" ||\n                   getTaskName() == \"Paging out items (quota sharing).\" ||\n                   getTaskName() == \"Paging expired items.\" ||\n                   getTaskName() == \"Generating access log\") {\n            checker = [this](bool taskRescheduled) {\n\n\n\n                this->oneExecutes(taskRescheduled,  0,  10);\n            };\n        } else {\n            checker = [this](bool taskRescheduled) {\n                this->oneExecutes(taskRescheduled, 0);\n            };\n        }\n    }\n\n    void runCurrentTask(std::string_view expectedTask) {\n        if (expectedTask != getTaskName()) {\n            std::string message =\n                    \"CheckedExecutor::runCurrentTask(): Expected task: \\\"\";\n            message.append(expectedTask);\n            message.append(\"\\\" got \\\"\");\n            message.append(getTaskName());\n            message.append(\"\\\"\");\n            throw std::runtime_error(message);\n        }\n        run();\n    }\n\n    void runCurrentTask() {\n        run();\n    }\n\n    std::chrono::steady_clock::time_point completeCurrentTask() {\n        auto min_waketime = std::chrono::steady_clock::time_point::min();\n        manager->doneWork(taskType);\n        if (rescheduled && !currentTask->isdead()) {\n            min_waketime = queue.reschedule(currentTask);\n        } else {\n            manager->cancel(currentTask->getId(), true);\n        }\n\n        if (!currentTask->isdead()) {\n            checker(rescheduled);\n        }\n        return min_waketime;\n    }\n\n    ExTask& getCurrentTask() {\n        return currentTask;\n    }\n\n    std::chrono::steady_clock::time_point getCurTime() const override {\n        return CB3ExecutorThread::getCurTime() + nowAdjustment;\n    }\n\n\n\n\n    std::chrono::steady_clock::duration nowAdjustment{0};\n\nprivate:\n\n    void oneExecutes(bool rescheduled,\n                     int minExpectedToBeScheduled,\n                     int maxExpectedToBeScheduled) {\n        auto expected = preFutureQueueSize + preReadyQueueSize;\n        auto actual = queue.getFutureQueueSize() + queue.getReadyQueueSize();\n\n        if (!rescheduled) {\n\n            expected--;\n        }\n\n\n\n        if (actual < expected + minExpectedToBeScheduled ||\n            actual > expected + maxExpectedToBeScheduled) {\n            throw std::runtime_error(fmt::format(\n                    \"CheckedExecutor::oneExecutes(): Unexpected number of \"\n                    \"queued tasks after running '{}': Expected between {} and \"\n                    \"{} tasks to be scheduled, but found {} tasks were \"\n                    \"scheduled.\",\n                    getTaskName(),\n                    minExpectedToBeScheduled,\n                    maxExpectedToBeScheduled,\n                    expected - actual));\n        }\n    }\n\n    void oneExecutes(bool rescheduled, int expectedToBeScheduled) {\n\n        oneExecutes(rescheduled,\n                     expectedToBeScheduled,\n                     expectedToBeScheduled);\n    }\n\n\n    void run() {\n        if (currentTask->isdead()) {\n            rescheduled = false;\n            return;\n        }\n        rescheduled = currentTask->execute(getName());\n    }\n\n    TaskQueue& queue;\n    size_t preFutureQueueSize;\n    size_t preReadyQueueSize;\n    bool rescheduled = false;\n\n\n    std::function<void(bool)> checker;\n};\n\ninline void SingleThreadedExecutorPool::runNextTask(TaskType taskType,\n                                                    std::string expectedTask) {\n    CheckedExecutor executor(this,\n                             *getLpTaskQ()[static_cast<size_t>(taskType)]);\n    executor.runCurrentTask(expectedTask);\n    executor.completeCurrentTask();\n}\n",
        "gt": [
            "'kv_engine/executor/cb3_executorpool.h'",
            "'kv_engine/executor/fake_executorpool.h'",
            "'kv_engine/engines/ep/tests/module_tests/executorpool_test.h'"
        ]
    },
    {
        "files": [
            "'elaphureLink/thirdparty/asio/include/asio.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/traits/require_concept_free.hpp'",
            "'elaphureLink/test/misc/asio_1/asio_1.cpp'",
            "'elaphureLink/thirdparty/asio/include/asio/require_concept.hpp'"
        ],
        "content": "'elaphureLink/thirdparty/asio/include/asio.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_HPP\n#define ASIO_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/associated_allocator.hpp\"\n#include \"asio/associated_executor.hpp\"\n#include \"asio/associated_cancellation_slot.hpp\"\n#include \"asio/associator.hpp\"\n#include \"asio/async_result.hpp\"\n#include \"asio/awaitable.hpp\"\n#include \"asio/basic_datagram_socket.hpp\"\n#include \"asio/basic_deadline_timer.hpp\"\n#include \"asio/basic_file.hpp\"\n#include \"asio/basic_io_object.hpp\"\n#include \"asio/basic_random_access_file.hpp\"\n#include \"asio/basic_raw_socket.hpp\"\n#include \"asio/basic_readable_pipe.hpp\"\n#include \"asio/basic_seq_packet_socket.hpp\"\n#include \"asio/basic_serial_port.hpp\"\n#include \"asio/basic_signal_set.hpp\"\n#include \"asio/basic_socket.hpp\"\n#include \"asio/basic_socket_acceptor.hpp\"\n#include \"asio/basic_socket_iostream.hpp\"\n#include \"asio/basic_socket_streambuf.hpp\"\n#include \"asio/basic_stream_file.hpp\"\n#include \"asio/basic_stream_socket.hpp\"\n#include \"asio/basic_streambuf.hpp\"\n#include \"asio/basic_waitable_timer.hpp\"\n#include \"asio/basic_writable_pipe.hpp\"\n#include \"asio/bind_allocator.hpp\"\n#include \"asio/bind_cancellation_slot.hpp\"\n#include \"asio/bind_executor.hpp\"\n#include \"asio/buffer.hpp\"\n#include \"asio/buffer_registration.hpp\"\n#include \"asio/buffered_read_stream_fwd.hpp\"\n#include \"asio/buffered_read_stream.hpp\"\n#include \"asio/buffered_stream_fwd.hpp\"\n#include \"asio/buffered_stream.hpp\"\n#include \"asio/buffered_write_stream_fwd.hpp\"\n#include \"asio/buffered_write_stream.hpp\"\n#include \"asio/buffers_iterator.hpp\"\n#include \"asio/cancellation_signal.hpp\"\n#include \"asio/cancellation_state.hpp\"\n#include \"asio/cancellation_type.hpp\"\n#include \"asio/co_spawn.hpp\"\n#include \"asio/completion_condition.hpp\"\n#include \"asio/compose.hpp\"\n#include \"asio/connect.hpp\"\n#include \"asio/connect_pipe.hpp\"\n#include \"asio/coroutine.hpp\"\n#include \"asio/deadline_timer.hpp\"\n#include \"asio/defer.hpp\"\n#include \"asio/detached.hpp\"\n#include \"asio/dispatch.hpp\"\n#include \"asio/error.hpp\"\n#include \"asio/error_code.hpp\"\n#include \"asio/execution.hpp\"\n#include \"asio/execution/allocator.hpp\"\n#include \"asio/execution/any_executor.hpp\"\n#include \"asio/execution/blocking.hpp\"\n#include \"asio/execution/blocking_adaptation.hpp\"\n#include \"asio/execution/bulk_execute.hpp\"\n#include \"asio/execution/bulk_guarantee.hpp\"\n#include \"asio/execution/connect.hpp\"\n#include \"asio/execution/context.hpp\"\n#include \"asio/execution/context_as.hpp\"\n#include \"asio/execution/execute.hpp\"\n#include \"asio/execution/executor.hpp\"\n#include \"asio/execution/invocable_archetype.hpp\"\n#include \"asio/execution/mapping.hpp\"\n#include \"asio/execution/occupancy.hpp\"\n#include \"asio/execution/operation_state.hpp\"\n#include \"asio/execution/outstanding_work.hpp\"\n#include \"asio/execution/prefer_only.hpp\"\n#include \"asio/execution/receiver.hpp\"\n#include \"asio/execution/receiver_invocation_error.hpp\"\n#include \"asio/execution/relationship.hpp\"\n#include \"asio/execution/schedule.hpp\"\n#include \"asio/execution/scheduler.hpp\"\n#include \"asio/execution/sender.hpp\"\n#include \"asio/execution/set_done.hpp\"\n#include \"asio/execution/set_error.hpp\"\n#include \"asio/execution/set_value.hpp\"\n#include \"asio/execution/start.hpp\"\n#include \"asio/execution_context.hpp\"\n#include \"asio/executor.hpp\"\n#include \"asio/executor_work_guard.hpp\"\n#include \"asio/file_base.hpp\"\n#include \"asio/generic/basic_endpoint.hpp\"\n#include \"asio/generic/datagram_protocol.hpp\"\n#include \"asio/generic/raw_protocol.hpp\"\n#include \"asio/generic/seq_packet_protocol.hpp\"\n#include \"asio/generic/stream_protocol.hpp\"\n#include \"asio/handler_alloc_hook.hpp\"\n#include \"asio/handler_continuation_hook.hpp\"\n#include \"asio/handler_invoke_hook.hpp\"\n#include \"asio/high_resolution_timer.hpp\"\n#include \"asio/io_context.hpp\"\n#include \"asio/io_context_strand.hpp\"\n#include \"asio/io_service.hpp\"\n#include \"asio/io_service_strand.hpp\"\n#include \"asio/ip/address.hpp\"\n#include \"asio/ip/address_v4.hpp\"\n#include \"asio/ip/address_v4_iterator.hpp\"\n#include \"asio/ip/address_v4_range.hpp\"\n#include \"asio/ip/address_v6.hpp\"\n#include \"asio/ip/address_v6_iterator.hpp\"\n#include \"asio/ip/address_v6_range.hpp\"\n#include \"asio/ip/network_v4.hpp\"\n#include \"asio/ip/network_v6.hpp\"\n#include \"asio/ip/bad_address_cast.hpp\"\n#include \"asio/ip/basic_endpoint.hpp\"\n#include \"asio/ip/basic_resolver.hpp\"\n#include \"asio/ip/basic_resolver_entry.hpp\"\n#include \"asio/ip/basic_resolver_iterator.hpp\"\n#include \"asio/ip/basic_resolver_query.hpp\"\n#include \"asio/ip/host_name.hpp\"\n#include \"asio/ip/icmp.hpp\"\n#include \"asio/ip/multicast.hpp\"\n#include \"asio/ip/resolver_base.hpp\"\n#include \"asio/ip/resolver_query_base.hpp\"\n#include \"asio/ip/tcp.hpp\"\n#include \"asio/ip/udp.hpp\"\n#include \"asio/ip/unicast.hpp\"\n#include \"asio/ip/v6_only.hpp\"\n#include \"asio/is_applicable_property.hpp\"\n#include \"asio/is_executor.hpp\"\n#include \"asio/is_read_buffered.hpp\"\n#include \"asio/is_write_buffered.hpp\"\n#include \"asio/local/basic_endpoint.hpp\"\n#include \"asio/local/connect_pair.hpp\"\n#include \"asio/local/datagram_protocol.hpp\"\n#include \"asio/local/stream_protocol.hpp\"\n#include \"asio/multiple_exceptions.hpp\"\n#include \"asio/packaged_task.hpp\"\n#include \"asio/placeholders.hpp\"\n#include \"asio/posix/basic_descriptor.hpp\"\n#include \"asio/posix/basic_stream_descriptor.hpp\"\n#include \"asio/posix/descriptor.hpp\"\n#include \"asio/posix/descriptor_base.hpp\"\n#include \"asio/posix/stream_descriptor.hpp\"\n#include \"asio/post.hpp\"\n#include \"asio/prefer.hpp\"\n#include \"asio/query.hpp\"\n#include \"asio/random_access_file.hpp\"\n#include \"asio/read.hpp\"\n#include \"asio/read_at.hpp\"\n#include \"asio/read_until.hpp\"\n#include \"asio/readable_pipe.hpp\"\n#include \"asio/recycling_allocator.hpp\"\n#include \"asio/redirect_error.hpp\"\n#include \"asio/registered_buffer.hpp\"\n#include \"asio/require.hpp\"\n#include \"asio/require_concept.hpp\"\n#include \"asio/serial_port.hpp\"\n#include \"asio/serial_port_base.hpp\"\n#include \"asio/signal_set.hpp\"\n#include \"asio/socket_base.hpp\"\n#include \"asio/static_thread_pool.hpp\"\n#include \"asio/steady_timer.hpp\"\n#include \"asio/strand.hpp\"\n#include \"asio/stream_file.hpp\"\n#include \"asio/streambuf.hpp\"\n#include \"asio/system_context.hpp\"\n#include \"asio/system_error.hpp\"\n#include \"asio/system_executor.hpp\"\n#include \"asio/system_timer.hpp\"\n#include \"asio/this_coro.hpp\"\n#include \"asio/thread.hpp\"\n#include \"asio/thread_pool.hpp\"\n#include \"asio/time_traits.hpp\"\n#include \"asio/use_awaitable.hpp\"\n#include \"asio/use_future.hpp\"\n#include \"asio/uses_executor.hpp\"\n#include \"asio/version.hpp\"\n#include \"asio/wait_traits.hpp\"\n#include \"asio/windows/basic_object_handle.hpp\"\n#include \"asio/windows/basic_overlapped_handle.hpp\"\n#include \"asio/windows/basic_random_access_handle.hpp\"\n#include \"asio/windows/basic_stream_handle.hpp\"\n#include \"asio/windows/object_handle.hpp\"\n#include \"asio/windows/overlapped_handle.hpp\"\n#include \"asio/windows/overlapped_ptr.hpp\"\n#include \"asio/windows/random_access_handle.hpp\"\n#include \"asio/windows/stream_handle.hpp\"\n#include \"asio/writable_pipe.hpp\"\n#include \"asio/write.hpp\"\n#include \"asio/write_at.hpp\"\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/traits/require_concept_free.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_TRAITS_REQUIRE_CONCEPT_FREE_HPP\n#define ASIO_TRAITS_REQUIRE_CONCEPT_FREE_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include \"asio/detail/type_traits.hpp\"\n\n#if defined(ASIO_HAS_DECLTYPE) \\\n  && defined(ASIO_HAS_NOEXCEPT) \\\n  && defined(ASIO_HAS_WORKING_EXPRESSION_SFINAE)\n# define ASIO_HAS_DEDUCED_REQUIRE_CONCEPT_FREE_TRAIT 1\n#endif\n\n\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace traits {\n\ntemplate <typename T, typename Property, typename = void>\nstruct require_concept_free_default;\n\ntemplate <typename T, typename Property, typename = void>\nstruct require_concept_free;\n\n}\nnamespace detail {\n\nstruct no_require_concept_free\n{\n  ASIO_STATIC_CONSTEXPR(bool, is_valid = false);\n  ASIO_STATIC_CONSTEXPR(bool, is_noexcept = false);\n};\n\n#if defined(ASIO_HAS_DEDUCED_REQUIRE_CONCEPT_FREE_TRAIT)\n\ntemplate <typename T, typename Property, typename = void>\nstruct require_concept_free_trait : no_require_concept_free\n{\n};\n\ntemplate <typename T, typename Property>\nstruct require_concept_free_trait<T, Property,\n  typename void_type<\n    decltype(require_concept(declval<T>(), declval<Property>()))\n  >::type>\n{\n  ASIO_STATIC_CONSTEXPR(bool, is_valid = true);\n\n  using result_type = decltype(\n    require_concept(declval<T>(), declval<Property>()));\n\n  ASIO_STATIC_CONSTEXPR(bool, is_noexcept = noexcept(\n    require_concept(declval<T>(), declval<Property>())));\n};\n\n#else\n\ntemplate <typename T, typename Property, typename = void>\nstruct require_concept_free_trait :\n  conditional<\n    is_same<T, typename decay<T>::type>::value\n      && is_same<Property, typename decay<Property>::type>::value,\n    no_require_concept_free,\n    traits::require_concept_free<\n      typename decay<T>::type,\n      typename decay<Property>::type>\n  >::type\n{\n};\n\n#endif\n\n}\nnamespace traits {\n\ntemplate <typename T, typename Property, typename>\nstruct require_concept_free_default :\n  detail::require_concept_free_trait<T, Property>\n{\n};\n\ntemplate <typename T, typename Property, typename>\nstruct require_concept_free :\n  require_concept_free_default<T, Property>\n{\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n\n'elaphureLink/test/misc/asio_1/asio_1.cpp'\n:﻿#include <iostream>\n#include <mutex>\n#include <condition_variable>\n\n#include <sdkddkver.h>\n#include \"thirdparty/asio/include/asio.hpp\"\n#include <windows.h>\n\nusing asio::ip::tcp;\n\nusing onSocketConnectCallbackType    = void (*)(const char *);\nusing onSocketDisconnectCallbackType = void (*)(const char *);\n\nclass SocketClient\n{\n    public:\n    SocketClient()\n        : is_running_(false),\n          connect_callback_(nullptr),\n          disconnect_callback_(nullptr)\n    {\n    }\n\n    ~SocketClient()\n    {\n\n        if (main_thread_.joinable()) {\n            main_thread_.detach();\n        }\n    }\n\n\n    void send_something(void *buffer, size_t length)\n    {\n        asio::write(get_socket(), asio::buffer(buffer, length));\n    }\n\n\n    int init_socket(std::string address, std::string port = \"3240\")\n    {\n        socket_.reset(nullptr);\n\n        io_context_ = std::make_unique<asio::io_context>();\n        tcp::resolver resolver(get_io_context());\n\n        socket_ = std::make_unique<asio::ip::tcp::socket>(get_io_context());\n\n        try {\n            endpoint_ = resolver.resolve(address, port);\n        } catch (std::exception &e) {\n            return -1;\n        }\n\n        return 0;\n    }\n\n\n    void kill()\n    {\n        socket_.get()->close();\n        io_context_.get()->stop();\n\n        Sleep(100);\n    }\n\n    int start()\n    {\n        using namespace std::chrono_literals;\n\n        std::unique_lock<std::mutex> lk(running_status_mutex_);\n        if (is_running_) {\n            return 0;\n        }\n\n        is_running_post_done_ = false;\n        is_running_           = true;\n\n        do_connect(endpoint_);\n\n        main_thread_ = std::thread([&]() {\n            try {\n                get_io_context().run();\n            } catch (std::exception &e) {\n                set_running_status(false, e.what());\n            }\n\n        });\n\n        running_cv_.wait(lk, [this]() { return is_running_post_done_; });\n\n        return !is_running_;\n    }\n\n    void wait_main_thread()\n    {\n        main_thread_.join();\n    }\n\n\n\n\n\n    public:\n    asio::io_context &get_io_context()\n    {\n        return *(io_context_.get());\n    }\n\n    asio::ip::tcp::socket &get_socket()\n    {\n        return *(socket_.get());\n    }\n\n    bool is_socket_running()\n    {\n        return is_running_;\n    }\n\n    void set_running_status(bool status, const std::string msg)\n    {\n        is_running_ = status;\n        if (status) {\n            if (connect_callback_) {\n                connect_callback_(msg.c_str());\n            }\n        } else {\n            if (disconnect_callback_) {\n                disconnect_callback_(msg.c_str());\n            }\n        }\n    }\n\n    void set_connect_callback(onSocketConnectCallbackType callback)\n    {\n        connect_callback_ = callback;\n    }\n\n    void set_disconnect_callback(onSocketDisconnectCallbackType callback)\n    {\n        disconnect_callback_ = callback;\n    }\n\n    private:\n    void close()\n    {\n        is_running_ = false;\n        asio::post(get_io_context(),\n                   [this]() {\n                       get_socket().close();\n                   });\n    }\n\n    void do_connect(const tcp::resolver::results_type &endpoints)\n    {\n        asio::async_connect(get_socket(), endpoints,\n                            [&](std::error_code ec, tcp::endpoint) {\n                                is_running_post_done_ = true;\n\n                                if (!ec) {\n\n\n                                    asio::ip::tcp::no_delay option(true);\n                                    get_socket().set_option(option);\n\n                                    set_running_status(true, \"Proxy started.\");\n                                    running_cv_.notify_all();\n                                    do_read_header();\n                                } else {\n                                    set_running_status(false, ec.message());\n                                    running_cv_.notify_all();\n                                    close();\n                                }\n                            });\n    }\n\n    void do_read_header()\n    {\n        asio::ip::tcp::no_delay option;\n        get_socket().get_option(option);\n        bool is_set = option.value();\n        assert(is_set == true);\n\n        try {\n            char data[10000];\n\n            asio::error_code error;\n            for (;;) {\n\n\n\n\n                size_t length = get_socket().read_some(asio::buffer(data), error);\n                if (error == asio::error::eof) {\n                    auto e = asio::system_error(error);\n                    set_running_status(false, e.what());\n                    break;\n                } else if (error) {\n                    throw asio::system_error(error);\n                }\n\n\n                asio::write(get_socket(), asio::buffer(data, length));\n\n                std::cout.write(data, length);\n            }\n        } catch (std::exception &e) {\n            set_running_status(false, e.what());\n        }\n    }\n\n\n    private:\n    bool                    is_running_;\n    bool                    is_running_post_done_;\n    std::mutex              running_status_mutex_;\n    std::condition_variable running_cv_;\n\n    std::unique_ptr<asio::io_context> io_context_;\n    std::unique_ptr<tcp::socket>      socket_;\n\n    tcp::resolver::results_type endpoint_;\n\n    std::thread main_thread_;\n\n    onSocketConnectCallbackType    connect_callback_;\n    onSocketDisconnectCallbackType disconnect_callback_;\n};\n\nclass ProxyManager\n{\n    public:\n    bool is_proxy_running()\n    {\n        if (client_.get()) {\n            return client_.get()->is_socket_running();\n        }\n\n        return false;\n    }\n\n    void set_on_proxy_connect_callback(onSocketConnectCallbackType callback)\n    {\n        if (client_.get()) {\n            client_.get()->set_connect_callback(callback);\n        }\n    }\n\n    void set_on_proxy_disconnect_callback(onSocketDisconnectCallbackType callback)\n    {\n        if (client_.get()) {\n            client_.get()->set_disconnect_callback(callback);\n        }\n    }\n\n    int start_with_address(std::string address)\n    {\n        stop();\n        client_ = std::make_unique<SocketClient>();\n\n\n        int ret = client_.get()->init_socket(address, \"3240\");\n        if (ret != 0) {\n            return ret;\n        }\n\n        return client_.get()->start();\n    }\n\n    void stop()\n    {\n        if (client_.get()) {\n            client_.get()->kill();\n        }\n        client_.reset(nullptr);\n    }\n\n    private:\n    std::unique_ptr<SocketClient> client_;\n};\n\nProxyManager kManager;\n\n\nextern \"C\" __declspec(dllexport) int start_proxy_with_address(char *address)\n{\n    return kManager.start_with_address(address);\n}\n\nextern \"C\" __declspec(dllexport) void stop_proxy()\n{\n    kManager.stop();\n}\n\n\nextern \"C\" __declspec(dllexport) void memory_leak_test()\n{\n    SocketClient c;\n\n    int i = 0;\n    while (i++ < 50) {\n        c.init_socket(\"127.0.0.1\", \"88\");\n        c.start();\n        c.wait_main_thread();\n    }\n}\n\nextern \"C\" __declspec(dllexport) int invalid_url_test(char *address, char *port)\n{\n    SocketClient c;\n\n    int ret = c.init_socket(address, port);\n    if (ret != 0) {\n        return ret;\n    }\n\n    ret = c.start();\n    Sleep(5 * 1000);\n    c.kill();\n    return ret;\n}\n\nvoid internal_invalid_url_test()\n{\n    char address[] = \"www.bing.com\";\n    char port[]    = \"80\";\n\n    invalid_url_test(const_cast<char *>(\"127.0.0.1\"), const_cast<char *>(\"3240\"));\n    invalid_url_test(const_cast<char *>(\"www.bing.com\"), const_cast<char *>(\"80\"));\n    invalid_url_test(const_cast<char *>(\"127.0.0.1\"), const_cast<char *>(\"3240\"));\n    invalid_url_test(const_cast<char *>(\"127.0.0.1\"), const_cast<char *>(\"80\"));\n    invalid_url_test(const_cast<char *>(\"1111111\"), const_cast<char *>(\"3240\"));\n    invalid_url_test(const_cast<char *>(\"1.01.1.1\"), const_cast<char *>(\"3240\"));\n    invalid_url_test(const_cast<char *>(\"1.0x01.1.1\"), const_cast<char *>(\"3240\"));\n\n    Sleep(INFINITE);\n}\n\nextern \"C\" __declspec(dllexport) void tcp_no_delay_test()\n{\n    SocketClient c;\n\n    char address[] = \"127.0.0.1\";\n    char port[]    = \"3240\";\n\n    int ret = c.init_socket(address, port);\n    if (ret != 0) {\n        throw \"connect failed\";\n    }\n\n    ret = c.start();\n    if (ret != 0) {\n        throw \"connect failed\";\n    }\n\n    char buffer[] = \"123\";\n    try {\n        c.send_something(buffer, 3);\n        c.send_something(buffer, 3);\n    } catch (std::exception &e) {\n        std::string msg = e.what();\n        throw msg;\n    }\n\n    Sleep(3000);\n    return;\n}\n\n\nint main()\n{\n    return 0;\n}\n'elaphureLink/thirdparty/asio/include/asio/require_concept.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_REQUIRE_CONCEPT_HPP\n#define ASIO_REQUIRE_CONCEPT_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include \"asio/detail/type_traits.hpp\"\n#include \"asio/is_applicable_property.hpp\"\n#include \"asio/traits/require_concept_member.hpp\"\n#include \"asio/traits/require_concept_free.hpp\"\n#include \"asio/traits/static_require_concept.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\n#if defined(GENERATING_DOCUMENTATION)\n\nnamespace asio {\n\n\n\n\ninline constexpr unspecified require_concept = unspecified;\n\n\n\n\ntemplate <typename T, typename Property>\nstruct can_require_concept :\n  integral_constant<bool, automatically_determined>\n{\n};\n\n\n\n\ntemplate <typename T, typename Property>\nstruct is_nothrow_require_concept :\n  integral_constant<bool, automatically_determined>\n{\n};\n\n\n\n\ntemplate <typename T, typename Property>\nstruct require_concept_result\n{\n\n  typedef automatically_determined type;\n};\n\n}\n\n#else\n\nnamespace asio_require_concept_fn {\n\nusing asio::conditional;\nusing asio::decay;\nusing asio::declval;\nusing asio::enable_if;\nusing asio::is_applicable_property;\nusing asio::traits::require_concept_free;\nusing asio::traits::require_concept_member;\nusing asio::traits::static_require_concept;\n\nvoid require_concept();\n\nenum overload_type\n{\n  identity,\n  call_member,\n  call_free,\n  ill_formed\n};\n\ntemplate <typename Impl, typename T, typename Properties, typename = void,\n    typename = void, typename = void, typename = void, typename = void>\nstruct call_traits\n{\n  ASIO_STATIC_CONSTEXPR(overload_type, overload = ill_formed);\n  ASIO_STATIC_CONSTEXPR(bool, is_noexcept = false);\n  typedef void result_type;\n};\n\ntemplate <typename Impl, typename T, typename Property>\nstruct call_traits<Impl, T, void(Property),\n  typename enable_if<\n    is_applicable_property<\n      typename decay<T>::type,\n      typename decay<Property>::type\n    >::value\n  >::type,\n  typename enable_if<\n    decay<Property>::type::is_requirable_concept\n  >::type,\n  typename enable_if<\n    static_require_concept<T, Property>::is_valid\n  >::type>\n{\n  ASIO_STATIC_CONSTEXPR(overload_type, overload = identity);\n  ASIO_STATIC_CONSTEXPR(bool, is_noexcept = true);\n  typedef ASIO_MOVE_ARG(T) result_type;\n};\n\ntemplate <typename Impl, typename T, typename Property>\nstruct call_traits<Impl, T, void(Property),\n  typename enable_if<\n    is_applicable_property<\n      typename decay<T>::type,\n      typename decay<Property>::type\n    >::value\n  >::type,\n  typename enable_if<\n    decay<Property>::type::is_requirable_concept\n  >::type,\n  typename enable_if<\n    !static_require_concept<T, Property>::is_valid\n  >::type,\n  typename enable_if<\n    require_concept_member<\n      typename Impl::template proxy<T>::type,\n      Property\n    >::is_valid\n  >::type> :\n  require_concept_member<\n    typename Impl::template proxy<T>::type,\n    Property\n  >\n{\n  ASIO_STATIC_CONSTEXPR(overload_type, overload = call_member);\n};\n\ntemplate <typename Impl, typename T, typename Property>\nstruct call_traits<Impl, T, void(Property),\n  typename enable_if<\n    is_applicable_property<\n      typename decay<T>::type,\n      typename decay<Property>::type\n    >::value\n  >::type,\n  typename enable_if<\n    decay<Property>::type::is_requirable_concept\n  >::type,\n  typename enable_if<\n    !static_require_concept<T, Property>::is_valid\n  >::type,\n  typename enable_if<\n    !require_concept_member<\n      typename Impl::template proxy<T>::type,\n      Property\n    >::is_valid\n  >::type,\n  typename enable_if<\n    require_concept_free<T, Property>::is_valid\n  >::type> :\n  require_concept_free<T, Property>\n{\n  ASIO_STATIC_CONSTEXPR(overload_type, overload = call_free);\n};\n\nstruct impl\n{\n  template <typename T>\n  struct proxy\n  {\n#if defined(ASIO_HAS_DEDUCED_REQUIRE_CONCEPT_MEMBER_TRAIT)\n    struct type\n    {\n      template <typename P>\n      auto require_concept(ASIO_MOVE_ARG(P) p)\n        noexcept(\n          noexcept(\n            declval<typename conditional<true, T, P>::type>().require_concept(\n              ASIO_MOVE_CAST(P)(p))\n          )\n        )\n        -> decltype(\n          declval<typename conditional<true, T, P>::type>().require_concept(\n            ASIO_MOVE_CAST(P)(p))\n        );\n    };\n#else\n    typedef T type;\n#endif\n  };\n\n  template <typename T, typename Property>\n  ASIO_NODISCARD ASIO_CONSTEXPR typename enable_if<\n    call_traits<impl, T, void(Property)>::overload == identity,\n    typename call_traits<impl, T, void(Property)>::result_type\n  >::type\n  operator()(\n      ASIO_MOVE_ARG(T) t,\n      ASIO_MOVE_ARG(Property)) const\n    ASIO_NOEXCEPT_IF((\n      call_traits<impl, T, void(Property)>::is_noexcept))\n  {\n    return ASIO_MOVE_CAST(T)(t);\n  }\n\n  template <typename T, typename Property>\n  ASIO_NODISCARD ASIO_CONSTEXPR typename enable_if<\n    call_traits<impl, T, void(Property)>::overload == call_member,\n    typename call_traits<impl, T, void(Property)>::result_type\n  >::type\n  operator()(\n      ASIO_MOVE_ARG(T) t,\n      ASIO_MOVE_ARG(Property) p) const\n    ASIO_NOEXCEPT_IF((\n      call_traits<impl, T, void(Property)>::is_noexcept))\n  {\n    return ASIO_MOVE_CAST(T)(t).require_concept(\n        ASIO_MOVE_CAST(Property)(p));\n  }\n\n  template <typename T, typename Property>\n  ASIO_NODISCARD ASIO_CONSTEXPR typename enable_if<\n    call_traits<impl, T, void(Property)>::overload == call_free,\n    typename call_traits<impl, T, void(Property)>::result_type\n  >::type\n  operator()(\n      ASIO_MOVE_ARG(T) t,\n      ASIO_MOVE_ARG(Property) p) const\n    ASIO_NOEXCEPT_IF((\n      call_traits<impl, T, void(Property)>::is_noexcept))\n  {\n    return require_concept(\n        ASIO_MOVE_CAST(T)(t),\n        ASIO_MOVE_CAST(Property)(p));\n  }\n};\n\ntemplate <typename T = impl>\nstruct static_instance\n{\n  static const T instance;\n};\n\ntemplate <typename T>\nconst T static_instance<T>::instance = {};\n\n}\nnamespace asio {\nnamespace {\n\nstatic ASIO_CONSTEXPR const asio_require_concept_fn::impl&\n  require_concept = asio_require_concept_fn::static_instance<>::instance;\n\n}\n\ntypedef asio_require_concept_fn::impl require_concept_t;\n\ntemplate <typename T, typename Property>\nstruct can_require_concept :\n  integral_constant<bool,\n    asio_require_concept_fn::call_traits<\n      require_concept_t, T, void(Property)>::overload !=\n        asio_require_concept_fn::ill_formed>\n{\n};\n\n#if defined(ASIO_HAS_VARIABLE_TEMPLATES)\n\ntemplate <typename T, typename Property>\nconstexpr bool can_require_concept_v\n  = can_require_concept<T, Property>::value;\n\n#endif\n\ntemplate <typename T, typename Property>\nstruct is_nothrow_require_concept :\n  integral_constant<bool,\n    asio_require_concept_fn::call_traits<\n      require_concept_t, T, void(Property)>::is_noexcept>\n{\n};\n\n#if defined(ASIO_HAS_VARIABLE_TEMPLATES)\n\ntemplate <typename T, typename Property>\nconstexpr bool is_nothrow_require_concept_v\n  = is_nothrow_require_concept<T, Property>::value;\n\n#endif\n\ntemplate <typename T, typename Property>\nstruct require_concept_result\n{\n  typedef typename asio_require_concept_fn::call_traits<\n      require_concept_t, T, void(Property)>::result_type type;\n};\n\n}\n\n#endif\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n",
        "gt": [
            "'elaphureLink/thirdparty/asio/include/asio/traits/require_concept_free.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/require_concept.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio.hpp'",
            "'elaphureLink/test/misc/asio_1/asio_1.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/tst/OpcUaStackCore/ServiceSet/QueryFirst_t.cpp'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/NodeTypeDescription.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/QueryFirstRequest.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/QueryDataDescription.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/RelativePath.h'"
        ],
        "content": "'OpcUaStack/tst/OpcUaStackCore/ServiceSet/QueryFirst_t.cpp'\n:#include \"unittest.h\"\n#include \"boost/asio.hpp\"\n#include \"OpcUaStackCore/ServiceSet/QueryFirstRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/QueryFirstResponse.h\"\n#include \"OpcUaStackCore/SecureChannel/MessageHeader.h\"\n#include \"OpcUaStackCore/SecureChannel/SequenceHeader.h\"\n#include \"OpcUaStackCore/Base/Utility.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaIdentifier.h\"\n\n#include <streambuf>\n#include <iostream>\n\nusing namespace OpcUaStackCore;\n\nBOOST_AUTO_TEST_SUITE(QueryFirst_)\n\nBOOST_AUTO_TEST_CASE(QueryFirst_Title)\n{\n\tstd::cout << \"QueryFirst_t\" << std::endl;\n}\n\nBOOST_AUTO_TEST_CASE(QueryFirst_Request)\n{\n\tRequestHeader::SPtr requestHeader = constructSPtr<RequestHeader>();\n\tstd::string str;\n\tuint32_t pos;\n\tOpcUaNodeId typeId;\n\tOpcUaGuid::SPtr opcUaGuidSPtr;\n\tContentFilter emptyContentFilter;\n\tRelativePath emptyRelativePath;\n\tQueryDataDescription::SPtr queryDataDescriptionSPtr;\n\tNodeTypeDescription::SPtr nodeTypeDescriptionSPtr;\n\tQueryFirstRequest::SPtr queryFirstRequestSPtr;\n\tMessageHeader::SPtr messageHeaderSPtr;\n\tSequenceHeader::SPtr sequenceHeaderSPtr;\n\tboost::posix_time::ptime ptime = boost::posix_time::from_iso_string(\"16010101T000000.000000000\");\n\n\n\tboost::asio::streambuf sb1;\n\tstd::iostream ios1(&sb1);\n\tboost::asio::streambuf sb2;\n\tstd::iostream ios2(&sb2);\n\tboost::asio::streambuf sb;\n\tstd::iostream ios(&sb);\n\n\n\tOpcUaInt32 secureChannelId;\n\tOpcUaInt32 secureTokenId;\n\n\tsecureChannelId = 153451225;\n\tsecureTokenId = 1;\n\n\tOpcUaNumber::opcUaBinaryEncode(ios1, secureChannelId);\n\tOpcUaNumber::opcUaBinaryEncode(ios1, secureTokenId);\n\n\n\tsequenceHeaderSPtr = constructSPtr<SequenceHeader>();\n\tsequenceHeaderSPtr->sequenceNumber(54);\n\tsequenceHeaderSPtr->requestId(4);\n\tsequenceHeaderSPtr->opcUaBinaryEncode(ios1);\n\n\n\ttypeId.nodeId(OpcUaId_QueryFirstRequest_Encoding_DefaultBinary);\n\ttypeId.opcUaBinaryEncode(ios1);\n\n\n\tqueryFirstRequestSPtr = constructSPtr<QueryFirstRequest>();\n\n\n\topcUaGuidSPtr = constructSPtr<OpcUaGuid>();\n\t*opcUaGuidSPtr = \"0D4455B2-8D2F-B74F-864F-0AF5945DD833\";\n\n\trequestHeader->sessionAuthenticationToken().namespaceIndex(1);\n\trequestHeader->sessionAuthenticationToken().nodeId(opcUaGuidSPtr);\n\trequestHeader->time(ptime);\n\trequestHeader->requestHandle(0);\n\trequestHeader->returnDisagnostics(0);\n\trequestHeader->timeoutHint(300000);\n\n\n\tqueryDataDescriptionSPtr = constructSPtr<QueryDataDescription>();\n\tqueryDataDescriptionSPtr->relativePath(emptyRelativePath);\n\tqueryDataDescriptionSPtr->attributeId(123);\n\tqueryDataDescriptionSPtr->indexRange(\"1:3\");\n\n\n\tnodeTypeDescriptionSPtr = constructSPtr<NodeTypeDescription>();\n\tnodeTypeDescriptionSPtr->typeDefinitionNode()->namespaceIndex(2);\n\tnodeTypeDescriptionSPtr->typeDefinitionNode()->nodeId<OpcUaUInt32>(123);\n\tnodeTypeDescriptionSPtr->includeSubtypes(true);\n\tnodeTypeDescriptionSPtr->dataToReturn()->set(queryDataDescriptionSPtr);\n\n\n\tqueryFirstRequestSPtr->view().viewId()->namespaceIndex(2);\n\tqueryFirstRequestSPtr->view().viewId()->nodeId<OpcUaUInt32>(123);\n\tqueryFirstRequestSPtr->view().timestamp(ptime);\n\tqueryFirstRequestSPtr->view().viewVersion(2);\n\n\n\tqueryFirstRequestSPtr->nodeTypes()->set(nodeTypeDescriptionSPtr);\n\tqueryFirstRequestSPtr->filter(emptyContentFilter);\n\tqueryFirstRequestSPtr->maxDataSetsToReturn(2);\n\tqueryFirstRequestSPtr->maxReferencesToReturn(2);\n\n\n\trequestHeader->opcUaBinaryEncode(ios1);\n\tqueryFirstRequestSPtr->opcUaBinaryEncode(ios1);\n\n\n\tmessageHeaderSPtr = constructSPtr<MessageHeader>();\n\tmessageHeaderSPtr->messageType(MessageType_Message);\n\tmessageHeaderSPtr->messageSize(OpcUaStackCore::count(sb1)+8);\n\tmessageHeaderSPtr->opcUaBinaryEncode(ios2);\n\n\n\tios << ios2.rdbuf() << ios1.rdbuf();\n\tOpcUaStackCore::dumpHex(ios);\n\n\tstd::stringstream ss;\n\tss << \"4d 53 47 46 82 00 00 00  d9 7a 25 09 01 00 00 00\"\n\t   << \"36 00 00 00 04 00 00 00  01 00 67 02 04 01 00 0d\"\n\t   << \"44 55 b2 8d 2f b7 4f 86  4f 0a f5 94 5d d8 33 00\"\n\t   << \"00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 ff\"\n       << \"ff ff ff e0 93 04 00 00  00 00 01 02 7b 00 00 00\"\n       << \"00 00 00 00 00 00 02 00  00 00 01 00 00 00 01 02\"\n       << \"7b 00 01 01 00 00 00 00  00 00 00 7b 00 00 00 03\"\n       << \"00 00 00 31 3a 33 00 00  00 00 02 00 00 00 02 00\"\n\t   << \"00 00\";\n\n\tBOOST_REQUIRE(OpcUaStackCore::compare(ios, ss.str(), pos) == true);\n\n\n\tmessageHeaderSPtr = constructSPtr<MessageHeader>();\n\tmessageHeaderSPtr->opcUaBinaryDecode(ios);\n\tBOOST_REQUIRE(messageHeaderSPtr->messageType() == MessageType_Message);\n\n\n\tOpcUaNumber::opcUaBinaryDecode(ios, secureChannelId);\n\tBOOST_REQUIRE(secureChannelId == 153451225);\n\tOpcUaNumber::opcUaBinaryDecode(ios, secureTokenId);\n\tBOOST_REQUIRE(secureTokenId == 1);\n\n\n\tsequenceHeaderSPtr = constructSPtr<SequenceHeader>();\n\tsequenceHeaderSPtr->opcUaBinaryDecode(ios);\n\tBOOST_REQUIRE(sequenceHeaderSPtr->sequenceNumber() == 54);\n\tBOOST_REQUIRE(sequenceHeaderSPtr->requestId() == 4);\n\n\n\ttypeId.opcUaBinaryDecode(ios);\n\tBOOST_REQUIRE(typeId.namespaceIndex() == 0);\n\tBOOST_REQUIRE(typeId.nodeId<OpcUaUInt32>() == OpcUaId_QueryFirstRequest_Encoding_DefaultBinary);\n\n\n\tqueryFirstRequestSPtr = constructSPtr<QueryFirstRequest>();\n\trequestHeader->opcUaBinaryDecode(ios);\n\tqueryFirstRequestSPtr->opcUaBinaryDecode(ios);\n\n\tstr = *requestHeader->sessionAuthenticationToken().nodeId<OpcUaGuid::SPtr>();\n\tBOOST_REQUIRE(requestHeader->sessionAuthenticationToken().namespaceIndex() == 1);\n\tBOOST_REQUIRE(str == \"0D4455B2-8D2F-B74F-864F-0AF5945DD833\");\n\tBOOST_REQUIRE(requestHeader->time().dateTime() == ptime);\n\tBOOST_REQUIRE(requestHeader->requestHandle() == 0);\n\tBOOST_REQUIRE(requestHeader->returnDisagnostics() == 0);\n\tBOOST_REQUIRE(requestHeader->timeoutHint() == 300000);\n\n\tBOOST_REQUIRE(queryFirstRequestSPtr->view().viewId()->namespaceIndex() == 2);\n\tBOOST_REQUIRE(queryFirstRequestSPtr->view().viewId()->nodeId<OpcUaUInt32>() == 123);\n\tBOOST_REQUIRE(queryFirstRequestSPtr->view().timestamp().dateTime() == ptime);\n\tBOOST_REQUIRE(queryFirstRequestSPtr->view().viewVersion() == 2);\n\n\tBOOST_REQUIRE(queryFirstRequestSPtr->nodeTypes()->size() == 1);\n\tnodeTypeDescriptionSPtr = constructSPtr<NodeTypeDescription>();\n\tqueryFirstRequestSPtr->nodeTypes()->get(nodeTypeDescriptionSPtr);\n\tBOOST_REQUIRE(nodeTypeDescriptionSPtr->typeDefinitionNode()->namespaceIndex() == 2);\n\tBOOST_REQUIRE(nodeTypeDescriptionSPtr->typeDefinitionNode()->nodeId<OpcUaUInt32>() == 123);\n\tBOOST_REQUIRE(nodeTypeDescriptionSPtr->includeSubtypes() == true);\n\n\tBOOST_REQUIRE(nodeTypeDescriptionSPtr->dataToReturn()->size() == 1);\n\tqueryDataDescriptionSPtr = constructSPtr<QueryDataDescription>();\n\tnodeTypeDescriptionSPtr->dataToReturn()->get(queryDataDescriptionSPtr);\n\tBOOST_REQUIRE(queryDataDescriptionSPtr->relativePath().elements()->size() == 0);\n\tBOOST_REQUIRE(queryDataDescriptionSPtr->attributeId() == 123);\n\tBOOST_REQUIRE(queryDataDescriptionSPtr->indexRange().value() == \"1:3\");\n\n\tBOOST_REQUIRE(queryFirstRequestSPtr->filter().elements()->size() == 0);\n\tBOOST_REQUIRE(queryFirstRequestSPtr->maxDataSetsToReturn() == 2);\n\tBOOST_REQUIRE(queryFirstRequestSPtr->maxReferencesToReturn() == 2);\n}\n\n\nBOOST_AUTO_TEST_CASE(QueryFirst_Response)\n{\n\tResponseHeader::SPtr responseHeader = constructSPtr<ResponseHeader>();\n\tuint32_t pos;\n\tstd::string str;\n\tOpcUaNodeId typeId;\n\tOpcUaQualifiedName browseName;\n\tOpcUaLocalizedText displayName;\n\tOpcUaStatusCode statusCode;\n\tContentFilterResult emptyContentFilterResult;\n\tQueryDataSet::SPtr queryDataSetSPtr;\n\tParsingResult::SPtr parsingResultSPtr;\n\tQueryFirstResponse::SPtr queryFirstResponseSPtr;\n\tMessageHeader::SPtr messageHeaderSPtr;\n\tSequenceHeader::SPtr sequenceHeaderSPtr;\n\tboost::posix_time::ptime ptime;\n\n\n\tptime = boost::posix_time::from_iso_string(\"16010101T000000.000000000\");\n\n\n\tboost::asio::streambuf sb1;\n\tstd::iostream ios1(&sb1);\n\tboost::asio::streambuf sb2;\n\tstd::iostream ios2(&sb2);\n\tboost::asio::streambuf sb;\n\tstd::iostream ios(&sb);\n\n\n\tOpcUaInt32 secureChannelId;\n\tOpcUaInt32 secureTokenId;\n\n\tsecureChannelId = 153451225;\n\tsecureTokenId = 1;\n\n\tOpcUaNumber::opcUaBinaryEncode(ios1, secureChannelId);\n\tOpcUaNumber::opcUaBinaryEncode(ios1, secureTokenId);\n\n\n\tsequenceHeaderSPtr = constructSPtr<SequenceHeader>();\n\tsequenceHeaderSPtr->sequenceNumber(54);\n\tsequenceHeaderSPtr->requestId(4);\n\tsequenceHeaderSPtr->opcUaBinaryEncode(ios1);\n\n\n\ttypeId.nodeId(OpcUaId_QueryFirstResponse_Encoding_DefaultBinary);\n\ttypeId.opcUaBinaryEncode(ios1);\n\n\n\tqueryFirstResponseSPtr = constructSPtr<QueryFirstResponse>();\n\n\n\tstatusCode = Success;\n\tresponseHeader->time(ptime);\n\tresponseHeader->requestHandle(0);\n\tresponseHeader->serviceResult(statusCode);\n\n\n\tqueryDataSetSPtr = constructSPtr<QueryDataSet>();\n\tqueryDataSetSPtr->nodeId()->namespaceIndex(2);\n\tqueryDataSetSPtr->nodeId()->nodeId<OpcUaUInt32>(123);\n\tqueryDataSetSPtr->typeDefinitionNode()->namespaceIndex(2);\n\tqueryDataSetSPtr->typeDefinitionNode()->nodeId<OpcUaUInt32>(123);\n\n\n\tparsingResultSPtr = constructSPtr<ParsingResult>();\n\tparsingResultSPtr->statusCode(Success);\n\n\n\tqueryFirstResponseSPtr->queryDataSets()->set(queryDataSetSPtr);\n\tqueryFirstResponseSPtr->continuationPoint().value(\"\", 0);\n\tqueryFirstResponseSPtr->parsingResults()->set(parsingResultSPtr);;\n\tqueryFirstResponseSPtr->filterResult(emptyContentFilterResult);\n\n\n\tresponseHeader->opcUaBinaryEncode(ios1);\n\tqueryFirstResponseSPtr->opcUaBinaryEncode(ios1);\n\n\n\tmessageHeaderSPtr = constructSPtr<MessageHeader>();\n\tmessageHeaderSPtr->messageType(MessageType_Message);\n\tmessageHeaderSPtr->messageSize(OpcUaStackCore::count(sb1)+8);\n\tmessageHeaderSPtr->opcUaBinaryEncode(ios2);\n\n\n\tios << ios2.rdbuf() << ios1.rdbuf();\n\tOpcUaStackCore::dumpHex(ios);\n\n\tstd::stringstream ss;\n\tss << \"4d 53 47 46 60 00 00 00  d9 7a 25 09 01 00 00 00\"\n\t   << \"36 00 00 00 04 00 00 00  01 00 6a 02 00 00 00 00\"\n\t   << \"00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\"\n\t   << \"00 00 00 00 01 00 00 00  01 02 7b 00 01 02 7b 00\"\n\t   << \"00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00\"\n\t   << \"00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\";\n\n\tBOOST_REQUIRE(OpcUaStackCore::compare(ios, ss.str(), pos) == true);\n\n\n\tmessageHeaderSPtr = constructSPtr<MessageHeader>();\n\tmessageHeaderSPtr->opcUaBinaryDecode(ios);\n\tBOOST_REQUIRE(messageHeaderSPtr->messageType() == MessageType_Message);\n\n\n\tOpcUaNumber::opcUaBinaryDecode(ios, secureChannelId);\n\tBOOST_REQUIRE(secureChannelId == 153451225);\n\tOpcUaNumber::opcUaBinaryDecode(ios, secureTokenId);\n\tBOOST_REQUIRE(secureTokenId == 1);\n\n\n\tsequenceHeaderSPtr = constructSPtr<SequenceHeader>();\n\tsequenceHeaderSPtr->opcUaBinaryDecode(ios);\n\tBOOST_REQUIRE(sequenceHeaderSPtr->sequenceNumber() == 54);\n\tBOOST_REQUIRE(sequenceHeaderSPtr->requestId() == 4);\n\n\n\ttypeId.opcUaBinaryDecode(ios);\n\tBOOST_REQUIRE(typeId.namespaceIndex() == 0);\n\tBOOST_REQUIRE(typeId.nodeId<OpcUaUInt32>() == OpcUaId_QueryFirstResponse_Encoding_DefaultBinary);\n\n\n\tqueryFirstResponseSPtr = constructSPtr<QueryFirstResponse>();\n\tresponseHeader->opcUaBinaryDecode(ios);\n\tqueryFirstResponseSPtr->opcUaBinaryDecode(ios);\n\n\tBOOST_REQUIRE(responseHeader->time().dateTime() == ptime);\n\tBOOST_REQUIRE(responseHeader->requestHandle() == 0);\n\tBOOST_REQUIRE(responseHeader->serviceResult() == Success);\n\n\tBOOST_REQUIRE(queryFirstResponseSPtr->queryDataSets()->size() == 1);\n\tqueryDataSetSPtr = constructSPtr<QueryDataSet>();\n\tqueryFirstResponseSPtr->queryDataSets()->get(queryDataSetSPtr);\n\tBOOST_REQUIRE(queryDataSetSPtr->nodeId()->namespaceIndex() == 2);\n\tBOOST_REQUIRE(queryDataSetSPtr->nodeId()->nodeId<OpcUaUInt32>() == 123);\n\tBOOST_REQUIRE(queryDataSetSPtr->typeDefinitionNode()->namespaceIndex() == 2);\n\tBOOST_REQUIRE(queryDataSetSPtr->typeDefinitionNode()->nodeId<OpcUaUInt32>() == 123);\n\tBOOST_REQUIRE(queryDataSetSPtr->values()->size() == 0);\n\n\tBOOST_REQUIRE(queryFirstResponseSPtr->continuationPoint().size() == 0);\n\n\tBOOST_REQUIRE(queryFirstResponseSPtr->parsingResults()->size() == 1);\n\tparsingResultSPtr = constructSPtr<ParsingResult>();\n\tqueryFirstResponseSPtr->parsingResults()->get(parsingResultSPtr);\n\tBOOST_REQUIRE(parsingResultSPtr->statusCode() == Success);\n\tBOOST_REQUIRE(parsingResultSPtr->dataStatusCodes()->size() == 0);\n\tBOOST_REQUIRE(parsingResultSPtr->dataDiagnosticInfos()->size() == 0);\n\n\tBOOST_REQUIRE(queryFirstResponseSPtr->filterResult().elementResults()->size() == 0);\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/NodeTypeDescription.h'\n:\n\n#ifndef __OpcUaStackCore_NodeTypeDescription_h__\n#define __OpcUaStackCore_NodeTypeDescription_h__\n\n#include <stdint.h>\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaArray.h\"\n#include \"OpcUaStackCore/ServiceSet/QueryDataDescription.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT NodeTypeDescription\n\t: public  Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<NodeTypeDescription> SPtr;\n\n\t\tNodeTypeDescription(void);\n\t\tvirtual ~NodeTypeDescription(void);\n\n\t\tvoid typeDefinitionNode(const OpcUaExpandedNodeId::SPtr typeDefinitionNode);\n\t\tOpcUaExpandedNodeId::SPtr typeDefinitionNode(void) const;\n\t\tvoid includeSubtypes(const OpcUaBoolean& includeSubtypes);\n\t\tOpcUaBoolean includeSubtypes(void);\n\t\tvoid dataToReturn(const QueryDataDescriptionArray::SPtr dataToReturn);\n\t\tQueryDataDescriptionArray::SPtr dataToReturn(void) const;\n\n\t\tvoid opcUaBinaryEncode(std::ostream& os) const;\n\t\tvoid opcUaBinaryDecode(std::istream& is);\n\n\t  private:\n\t\tOpcUaExpandedNodeId::SPtr typeDefinitionNodeSPtr_;\n\t\tOpcUaBoolean includeSubtypes_;\n\t\tQueryDataDescriptionArray::SPtr dataToReturnArraySPtr_;\n\t};\n\n\tclass NodeTypeDescriptionArray\n\t: public OpcUaArray<NodeTypeDescription::SPtr, SPtrTypeCoder<NodeTypeDescription> >\n\t, public Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<NodeTypeDescriptionArray> SPtr;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/QueryFirstRequest.h'\n:\n\n#ifndef __OpcUaStackCore_QueryFirstRequest_h__\n#define __OpcUaStackCore_QueryFirstRequest_h__\n\n#include <stdint.h>\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n#include \"OpcUaStackCore/SecureChannel/RequestHeader.h\"\n#include \"OpcUaStackCore/ServiceSet/NodeTypeDescription.h\"\n#include \"OpcUaStackCore/ServiceSet/ViewDescription.h\"\n#include \"OpcUaStackCore/ServiceSet/ContentFilter.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT QueryFirstRequest\n\t: public  Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<QueryFirstRequest> SPtr;\n\n\t\tQueryFirstRequest(void);\n\t\tvirtual ~QueryFirstRequest(void);\n\n\t\tvoid view(const ViewDescription& view);\n\t\tViewDescription& view(void);\n\t\tvoid nodeTypes(const NodeTypeDescriptionArray::SPtr nodeTypes);\n\t\tNodeTypeDescriptionArray::SPtr nodeTypes(void) const;\n\t\tvoid filter(const ContentFilter& filter);\n\t\tContentFilter& filter(void);\n\t\tvoid maxDataSetsToReturn(const OpcUaUInt32& maxDataSetsToReturn);\n\t\tOpcUaUInt32 maxDataSetsToReturn(void);\n\t\tvoid maxReferencesToReturn(const OpcUaUInt32& maxReferencesToReturn);\n\t\tOpcUaUInt32 maxReferencesToReturn(void);\n\n\t\tvoid opcUaBinaryEncode(std::ostream& os) const;\n\t\tvoid opcUaBinaryDecode(std::istream& is);\n\n\t  private:\n\t\tViewDescription view_;\n\t\tNodeTypeDescriptionArray::SPtr nodeTypeArraySPtr_;\n\t\tContentFilter filter_;\n\t\tOpcUaUInt32 maxDataSetsToReturn_;\n\t\tOpcUaUInt32 maxReferencesToReturn_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/QueryDataDescription.h'\n:\n\n#ifndef __OpcUaStackCore_QueryDataDescription_h__\n#define __OpcUaStackCore_QueryDataDescription_h__\n\n#include <stdint.h>\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaArray.h\"\n#include \"OpcUaStackCore/ServiceSet/RelativePath.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT QueryDataDescription\n\t: public  Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<QueryDataDescription> SPtr;\n\n\t\tQueryDataDescription(void);\n\t\tvirtual ~QueryDataDescription(void);\n\n\t\tvoid relativePath(const RelativePath& relativePath);\n\t\tRelativePath& relativePath(void);\n\t\tvoid attributeId(const OpcUaUInt32& attributeId);\n\t\tOpcUaUInt32 attributeId(void);\n\t\tvoid indexRange(const OpcUaString& indexRange);\n\t\tvoid indexRange(const std::string& indexRange);\n\t\tOpcUaString& indexRange(void);\n\n\t\tvoid opcUaBinaryEncode(std::ostream& os) const;\n\t\tvoid opcUaBinaryDecode(std::istream& is);\n\n\t  private:\n\t\tRelativePath relativePath_;\n\t\tOpcUaUInt32 attributeId_;\n\t\tOpcUaString indexRange_;\n\t};\n\n\tclass QueryDataDescriptionArray\n\t: public OpcUaArray<QueryDataDescription::SPtr, SPtrTypeCoder<QueryDataDescription> >\n\t, public Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<QueryDataDescriptionArray> SPtr;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/RelativePath.h'\n:\n\n#ifndef __OpcUaStackCore_RelativePath_h__\n#define __OpcUaStackCore_RelativePath_h__\n\n#include <stdint.h>\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n#include \"OpcUaStackCore/ServiceSet/RelativePathElement.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT RelativePath\n\t: public  Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<RelativePath> SPtr;\n\n\t\tRelativePath(void);\n\t\tvirtual ~RelativePath(void);\n\n\t\tvoid elements(const RelativePathElementArray::SPtr elements);\n\t\tRelativePathElementArray::SPtr elements(void) const;\n\n\t\tvoid opcUaBinaryEncode(std::ostream& os) const;\n\t\tvoid opcUaBinaryDecode(std::istream& is);\n\n\t  private:\n\t\tRelativePathElementArray::SPtr elementsArraySPtr_;\n\t};\n\n}\n\n#endif\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/RelativePath.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/QueryDataDescription.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/NodeTypeDescription.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/QueryFirstRequest.h'",
            "'OpcUaStack/tst/OpcUaStackCore/ServiceSet/QueryFirst_t.cpp'"
        ]
    },
    {
        "files": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/integrate.cpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/stepper_categories.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/integrate_const.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp'"
        ],
        "content": "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/integrate.cpp'\n:\n\n\n#define BOOST_TEST_MODULE odeint_integrate_functions\n\n#include <vector>\n#include <cmath>\n#include <iostream>\n\n#include <boost/numeric/odeint/config.hpp>\n\n#include <boost/array.hpp>\n#include <boost/ref.hpp>\n#include <boost/iterator/counting_iterator.hpp>\n\n#include <boost/test/unit_test.hpp>\n\n#include <boost/mpl/vector.hpp>\n\n\n#include <boost/numeric/odeint/integrate/integrate_const.hpp>\n#include <boost/numeric/odeint/integrate/integrate_adaptive.hpp>\n#include <boost/numeric/odeint/integrate/integrate_times.hpp>\n#include <boost/numeric/odeint/integrate/integrate_n_steps.hpp>\n#include <boost/numeric/odeint/stepper/euler.hpp>\n#include <boost/numeric/odeint/stepper/modified_midpoint.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta4.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta_cash_karp54.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta_dopri5.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta_fehlberg78.hpp>\n#include <boost/numeric/odeint/stepper/controlled_runge_kutta.hpp>\n#include <boost/numeric/odeint/stepper/bulirsch_stoer.hpp>\n#include <boost/numeric/odeint/stepper/dense_output_runge_kutta.hpp>\n#include <boost/numeric/odeint/stepper/bulirsch_stoer_dense_out.hpp>\n\n#include <boost/numeric/odeint/util/detail/less_with_sign.hpp>\n\nusing namespace boost::unit_test;\nusing namespace boost::numeric::odeint;\nnamespace mpl = boost::mpl;\n\n\ntypedef double value_type;\ntypedef std::vector< value_type > state_type;\n\nvoid lorenz( const state_type &x , state_type &dxdt , const value_type t )\n{\n\n    const value_type R( 28.0 );\n    const value_type b( value_type( 8.0 ) / value_type( 3.0 ) );\n\n\n    dxdt[0] = 1.0;\n    dxdt[1] = R * x[0] - x[1] - x[0] * x[2];\n    dxdt[2] = -b * x[2] + x[0] * x[1];\n}\n\nstruct push_back_time\n{\n    std::vector< double >& m_times;\n\n    state_type& m_x;\n\n    push_back_time( std::vector< double > &times , state_type &x )\n    :  m_times( times ) , m_x( x ) { }\n\n    void operator()( const state_type &x , double t )\n    {\n        m_times.push_back( t );\n        boost::numeric::odeint::copy( x , m_x );\n    }\n};\n\ntemplate< class Stepper >\nstruct perform_integrate_const_test\n{\n    void operator()( const value_type t_end , const value_type dt )\n    {\n        std::cout << \"Testing integrate_const with \" << typeid( Stepper ).name() << std::endl;\n\n        state_type x( 3 , 10.0 ) , x_end( 3 );\n\n        std::vector< value_type > times;\n\n        integrate_const( Stepper() , lorenz , x , 0.0 , t_end ,\n                                        dt , push_back_time( times , x_end ) );\n\n\n\n\n\n        BOOST_CHECK_EQUAL( static_cast<int>(times.size()) , static_cast<int>(floor(t_end/dt))+1 );\n\n        for( size_t i=0 ; i<times.size() ; ++i )\n        {\n\n\n            BOOST_CHECK_SMALL( times[i] - static_cast< value_type >(i)*dt , (i+1) * 2E-16 );\n        }\n\n\n        BOOST_CHECK_SMALL( (10.0 + times[times.size()-1]) - x_end[0] , 1E-6 );\n\n\n    }\n};\n\ntemplate< class Stepper >\nstruct perform_integrate_adaptive_test\n{\n    void operator()( const value_type t_end = 10.0 , const value_type dt = 0.03 )\n    {\n        std::cout << \"Testing integrate_adaptive with \" << typeid( Stepper ).name() << std::endl;\n\n        state_type x( 3 , 10.0 ) , x_end( 3 );\n\n        std::vector< value_type > times;\n\n        size_t steps = integrate_adaptive( Stepper() , *lorenz , x , 0.0 , t_end ,\n                                        dt , push_back_time( times , x_end ) );\n\n\n\n        BOOST_CHECK_EQUAL( times.size() , steps+1 );\n\n        BOOST_CHECK_SMALL( times[0] - 0.0 , 2E-16 );\n        BOOST_CHECK_SMALL( times[times.size()-1] - t_end , times.size() * 2E-16 );\n\n\n        BOOST_CHECK_SMALL( (10.0 + t_end) - x_end[0] , 1E-6 );\n\n\n    }\n};\n\n\ntemplate< class Stepper >\nstruct perform_integrate_times_test\n{\n    void operator()( const int n = 10 , const int dn=1 , const value_type dt = 0.03 )\n    {\n        std::cout << \"Testing integrate_times with \" << typeid( Stepper ).name() << std::endl;\n\n        state_type x( 3 ) , x_end( 3 );\n        x[0] = x[1] = x[2] = 10.0;\n\n        std::vector< double > times;\n\n        std::vector< double > obs_times( abs(n) );\n        for( int i=0 ; boost::numeric::odeint::detail::less_with_sign( i ,\n                       static_cast<int>(obs_times.size()) ,\n                       dt ) ; i+=dn )\n        {\n            obs_times[i] = i;\n        }\n\n        integrate_times( Stepper() , lorenz , x , obs_times.begin() , obs_times.end() ,\n                    dt , push_back_time( times , x_end ) );\n\n        BOOST_CHECK_EQUAL( static_cast<int>(times.size()) , abs(n) );\n\n        for( size_t i=0 ; i<times.size() ; ++i )\n\n            BOOST_CHECK_EQUAL( times[i] , static_cast<double>(i) );\n\n\n        BOOST_CHECK_SMALL( (10.0 + 1.0*times[times.size()-1]) - x_end[0] , 1E-6 );\n\n\n    }\n};\n\ntemplate< class Stepper >\nstruct perform_integrate_n_steps_test\n{\n    void operator()( const int n = 200 , const value_type dt = 0.01 )\n    {\n        std::cout << \"Testing integrate_n_steps with \" << typeid( Stepper ).name() << std::endl;\n\n        state_type x( 3 ) , x_end( 3 );\n        x[0] = x[1] = x[2] = 10.0;\n\n        std::vector< double > times;\n\n\n        value_type end_time = integrate_n_steps( Stepper() , lorenz , x , 0.0 , dt , n , push_back_time( times , x_end ) );\n\n        BOOST_CHECK_SMALL( end_time - n*dt , 2E-16 );\n        BOOST_CHECK_EQUAL( static_cast<int>(times.size()) , n+1 );\n\n        for( size_t i=0 ; i<times.size() ; ++i )\n\n            BOOST_CHECK_SMALL( times[i] - static_cast< value_type >(i)*dt , 2E-16 );\n\n\n        BOOST_CHECK_SMALL( (10.0 + end_time) - x_end[0] , 1E-6 );\n\n\n\n    }\n};\n\n\n\nclass stepper_methods : public mpl::vector<\n    euler< state_type > ,\n    modified_midpoint< state_type > ,\n    runge_kutta4< state_type > ,\n    runge_kutta_cash_karp54< state_type > ,\n    runge_kutta_dopri5< state_type > ,\n    runge_kutta_fehlberg78< state_type > ,\n    controlled_runge_kutta< runge_kutta_cash_karp54< state_type > > ,\n    controlled_runge_kutta< runge_kutta_dopri5< state_type > > ,\n    controlled_runge_kutta< runge_kutta_fehlberg78< state_type > > ,\n    bulirsch_stoer< state_type > ,\n    dense_output_runge_kutta< controlled_runge_kutta< runge_kutta_dopri5< state_type > > >\n\n> { };\n\n\n\nBOOST_AUTO_TEST_SUITE( integrate_test )\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_const_test_case , Stepper, stepper_methods )\n{\n    perform_integrate_const_test< Stepper > tester;\n    tester( 1.005 , 0.01 );\n    tester( 1.0 , 0.01 );\n    tester( 1.1 , 0.01 );\n    tester( -1.005 , -0.01 );\n}\n\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_adaptive_test_case , Stepper, stepper_methods )\n{\n    perform_integrate_adaptive_test< Stepper > tester;\n    tester( 1.005 , 0.01 );\n    tester( 1.0 , 0.01 );\n    tester( 1.1 , 0.01 );\n    tester( -1.005 , -0.01 );\n}\n\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_times_test_case , Stepper, stepper_methods )\n{\n    perform_integrate_times_test< Stepper > tester;\n    tester();\n\n}\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_n_steps_test_case , Stepper, stepper_methods )\n{\n    perform_integrate_n_steps_test< Stepper > tester;\n    tester();\n    tester( 200 , 0.01 );\n    tester( 200 , 0.01 );\n    tester( 200 , 0.01 );\n    tester( 200 , -0.01 );\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/stepper_categories.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_STEPPER_STEPPER_CATEGORIES_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_STEPPER_STEPPER_CATEGORIES_HPP_INCLUDED\n\n#include <boost/type_traits/integral_constant.hpp>\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\n\n\n\nstruct stepper_tag {};\n\n\n\n\nstruct error_stepper_tag : stepper_tag {};\nstruct explicit_error_stepper_tag : error_stepper_tag {};\nstruct explicit_error_stepper_fsal_tag : error_stepper_tag {};\n\nstruct controlled_stepper_tag {};\nstruct explicit_controlled_stepper_tag : controlled_stepper_tag {};\nstruct explicit_controlled_stepper_fsal_tag : controlled_stepper_tag {};\n\nstruct dense_output_stepper_tag {};\n\n\ntemplate< class tag > struct base_tag ;\ntemplate< > struct base_tag< stepper_tag > { typedef stepper_tag type; };\ntemplate< > struct base_tag< error_stepper_tag > { typedef stepper_tag type; };\ntemplate< > struct base_tag< explicit_error_stepper_tag > { typedef stepper_tag type; };\ntemplate< > struct base_tag< explicit_error_stepper_fsal_tag > { typedef stepper_tag type; };\n\ntemplate< > struct base_tag< controlled_stepper_tag > { typedef controlled_stepper_tag type; };\ntemplate< > struct base_tag< explicit_controlled_stepper_tag > { typedef controlled_stepper_tag type; };\ntemplate< > struct base_tag< explicit_controlled_stepper_fsal_tag > { typedef controlled_stepper_tag type; };\n\ntemplate< > struct base_tag< dense_output_stepper_tag > { typedef dense_output_stepper_tag type; };\n\n\n}\n}\n}\n\n\n#endif\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/integrate_const.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_INTEGRATE_INTEGRATE_CONST_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_INTEGRATE_INTEGRATE_CONST_HPP_INCLUDED\n\n#include <boost/type_traits/is_same.hpp>\n\n#include <boost/numeric/odeint/stepper/stepper_categories.hpp>\n#include <boost/numeric/odeint/integrate/null_observer.hpp>\n#include <boost/numeric/odeint/integrate/detail/integrate_const.hpp>\n#include <boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp>\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\n\n\n\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer >\nsize_t integrate_const(\n        Stepper stepper , System system , State &start_state ,\n        Time start_time , Time end_time , Time dt ,\n        Observer observer\n)\n{\n\n    if( boost::is_same< null_observer , Observer >::value )\n    {\n        return detail::integrate_adaptive(\n                stepper , system , start_state ,\n                start_time , end_time  , dt ,\n                observer , typename Stepper::stepper_category() );\n    }\n    else\n    {\n        return detail::integrate_const( stepper , system , start_state ,\n                                        start_time , end_time , dt ,\n                                        observer , typename Stepper::stepper_category() );\n      }\n}\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer >\nsize_t integrate_const(\n        Stepper stepper , System system , const State &start_state ,\n        Time start_time , Time end_time , Time dt ,\n        Observer observer\n)\n{\n\n    if( boost::is_same< null_observer , Observer >::value )\n    {\n        return detail::integrate_adaptive(\n                stepper , system , start_state ,\n                start_time , end_time  , dt ,\n                observer , typename Stepper::stepper_category() );\n    }\n    else\n    {\n        return detail::integrate_const( stepper , system , start_state ,\n                                        start_time , end_time , dt ,\n                                        observer , typename Stepper::stepper_category() );\n    }\n}\n\n\n\n\n\n\ntemplate< class Stepper , class System , class State , class Time >\nsize_t integrate_const(\n        Stepper stepper , System system , State &start_state ,\n        Time start_time , Time end_time , Time dt\n)\n{\n    return integrate_const( stepper , system , start_state , start_time , end_time , dt , null_observer() );\n}\n\n\ntemplate< class Stepper , class System , class State , class Time >\nsize_t integrate_const(\n        Stepper stepper , System system , const State &start_state ,\n        Time start_time , Time end_time , Time dt\n)\n{\n    return integrate_const( stepper , system , start_state , start_time , end_time , dt , null_observer() );\n}\n\n\n\n\n\n\n\n\n\n}\n}\n}\n\n\n\n#endif\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_INTEGRATE_DETAIL_INTEGRATE_ADAPTIVE_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_INTEGRATE_DETAIL_INTEGRATE_ADAPTIVE_HPP_INCLUDED\n\n#include <stdexcept>\n\n#include <boost/numeric/odeint/stepper/stepper_categories.hpp>\n#include <boost/numeric/odeint/stepper/controlled_step_result.hpp>\n#include <boost/numeric/odeint/integrate/detail/integrate_const.hpp>\n#include <boost/numeric/odeint/util/bind.hpp>\n#include <boost/numeric/odeint/util/unwrap_reference.hpp>\n#include <boost/numeric/odeint/util/copy.hpp>\n\n#include <boost/numeric/odeint/util/detail/less_with_sign.hpp>\n\n\n#include <iostream>\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\nnamespace detail {\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer>\nsize_t integrate_const(\n        Stepper stepper , System system , State &start_state ,\n        Time start_time , Time end_time , Time dt ,\n        Observer observer , stepper_tag );\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer >\nsize_t integrate_adaptive(\n        Stepper stepper , System system , State &start_state ,\n        Time start_time , Time end_time , Time dt ,\n        Observer observer , stepper_tag\n)\n{\n    size_t steps = detail::integrate_const( stepper , system , start_state , start_time ,\n                                            end_time , dt , observer , stepper_tag() );\n    Time end = start_time + dt*steps;\n    if( less_with_sign( end , end_time , dt ) )\n    {\n        stepper.do_step( system , start_state , end , end_time - end );\n        steps++;\n        typename odeint::unwrap_reference< Observer >::type &obs = observer;\n        obs( start_state , end_time );\n    }\n    return steps;\n}\n\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer >\nsize_t integrate_adaptive(\n        Stepper stepper , System system , State &start_state ,\n        Time &start_time , Time end_time , Time &dt ,\n        Observer observer , controlled_stepper_tag\n)\n{\n    typename odeint::unwrap_reference< Observer >::type &obs = observer;\n\n    const size_t max_attempts = 1000;\n    const char *error_string = \"Integrate adaptive : Maximal number of iterations reached. A step size could not be found.\";\n    size_t count = 0;\n    while( less_with_sign( start_time , end_time , dt ) )\n    {\n        obs( start_state , start_time );\n        if( less_with_sign( end_time , start_time + dt , dt ) )\n        {\n            dt = end_time - start_time;\n        }\n\n        size_t trials = 0;\n        controlled_step_result res = success;\n        do\n        {\n            res = stepper.try_step( system , start_state , start_time , dt );\n            ++trials;\n        }\n        while( ( res == fail ) && ( trials < max_attempts ) );\n        if( trials == max_attempts ) throw std::overflow_error( error_string );\n\n        ++count;\n    }\n    obs( start_state , start_time );\n    return count;\n}\n\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer >\nsize_t integrate_adaptive(\n        Stepper stepper , System system , State &start_state ,\n        Time start_time , Time end_time , Time dt ,\n        Observer observer , dense_output_stepper_tag )\n{\n    typename odeint::unwrap_reference< Observer >::type &obs = observer;\n\n    size_t count = 0;\n    stepper.initialize( start_state , start_time , dt );\n\n    while( less_with_sign( stepper.current_time() , end_time , stepper.current_time_step() ) )\n    {\n        while( less_eq_with_sign( stepper.current_time() + stepper.current_time_step() ,\n               end_time ,\n               stepper.current_time_step() ) )\n        {\n            obs( stepper.current_state() , stepper.current_time() );\n            stepper.do_step( system );\n            ++count;\n        }\n        stepper.initialize( stepper.current_state() , stepper.current_time() , end_time - stepper.current_time() );\n    }\n    obs( stepper.current_state() , stepper.current_time() );\n\n    boost::numeric::odeint::copy( stepper.current_state() , start_state );\n    return count;\n}\n\n\n\n\n}\n}\n}\n}\n\n\n#endif\n",
        "gt": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/stepper_categories.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/integrate_const.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/integrate.cpp'"
        ]
    },
    {
        "files": [
            "'elaphureLink/thirdparty/asio/include/asio.hpp'",
            "'elaphureLink/elaphureLinkProxy/SocketClient.hpp'",
            "'elaphureLink/elaphureLinkProxy/protocol.cpp'",
            "'elaphureLink/thirdparty/asio/include/asio/thread.hpp'"
        ],
        "content": "'elaphureLink/thirdparty/asio/include/asio.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_HPP\n#define ASIO_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/associated_allocator.hpp\"\n#include \"asio/associated_executor.hpp\"\n#include \"asio/associated_cancellation_slot.hpp\"\n#include \"asio/associator.hpp\"\n#include \"asio/async_result.hpp\"\n#include \"asio/awaitable.hpp\"\n#include \"asio/basic_datagram_socket.hpp\"\n#include \"asio/basic_deadline_timer.hpp\"\n#include \"asio/basic_file.hpp\"\n#include \"asio/basic_io_object.hpp\"\n#include \"asio/basic_random_access_file.hpp\"\n#include \"asio/basic_raw_socket.hpp\"\n#include \"asio/basic_readable_pipe.hpp\"\n#include \"asio/basic_seq_packet_socket.hpp\"\n#include \"asio/basic_serial_port.hpp\"\n#include \"asio/basic_signal_set.hpp\"\n#include \"asio/basic_socket.hpp\"\n#include \"asio/basic_socket_acceptor.hpp\"\n#include \"asio/basic_socket_iostream.hpp\"\n#include \"asio/basic_socket_streambuf.hpp\"\n#include \"asio/basic_stream_file.hpp\"\n#include \"asio/basic_stream_socket.hpp\"\n#include \"asio/basic_streambuf.hpp\"\n#include \"asio/basic_waitable_timer.hpp\"\n#include \"asio/basic_writable_pipe.hpp\"\n#include \"asio/bind_allocator.hpp\"\n#include \"asio/bind_cancellation_slot.hpp\"\n#include \"asio/bind_executor.hpp\"\n#include \"asio/buffer.hpp\"\n#include \"asio/buffer_registration.hpp\"\n#include \"asio/buffered_read_stream_fwd.hpp\"\n#include \"asio/buffered_read_stream.hpp\"\n#include \"asio/buffered_stream_fwd.hpp\"\n#include \"asio/buffered_stream.hpp\"\n#include \"asio/buffered_write_stream_fwd.hpp\"\n#include \"asio/buffered_write_stream.hpp\"\n#include \"asio/buffers_iterator.hpp\"\n#include \"asio/cancellation_signal.hpp\"\n#include \"asio/cancellation_state.hpp\"\n#include \"asio/cancellation_type.hpp\"\n#include \"asio/co_spawn.hpp\"\n#include \"asio/completion_condition.hpp\"\n#include \"asio/compose.hpp\"\n#include \"asio/connect.hpp\"\n#include \"asio/connect_pipe.hpp\"\n#include \"asio/coroutine.hpp\"\n#include \"asio/deadline_timer.hpp\"\n#include \"asio/defer.hpp\"\n#include \"asio/detached.hpp\"\n#include \"asio/dispatch.hpp\"\n#include \"asio/error.hpp\"\n#include \"asio/error_code.hpp\"\n#include \"asio/execution.hpp\"\n#include \"asio/execution/allocator.hpp\"\n#include \"asio/execution/any_executor.hpp\"\n#include \"asio/execution/blocking.hpp\"\n#include \"asio/execution/blocking_adaptation.hpp\"\n#include \"asio/execution/bulk_execute.hpp\"\n#include \"asio/execution/bulk_guarantee.hpp\"\n#include \"asio/execution/connect.hpp\"\n#include \"asio/execution/context.hpp\"\n#include \"asio/execution/context_as.hpp\"\n#include \"asio/execution/execute.hpp\"\n#include \"asio/execution/executor.hpp\"\n#include \"asio/execution/invocable_archetype.hpp\"\n#include \"asio/execution/mapping.hpp\"\n#include \"asio/execution/occupancy.hpp\"\n#include \"asio/execution/operation_state.hpp\"\n#include \"asio/execution/outstanding_work.hpp\"\n#include \"asio/execution/prefer_only.hpp\"\n#include \"asio/execution/receiver.hpp\"\n#include \"asio/execution/receiver_invocation_error.hpp\"\n#include \"asio/execution/relationship.hpp\"\n#include \"asio/execution/schedule.hpp\"\n#include \"asio/execution/scheduler.hpp\"\n#include \"asio/execution/sender.hpp\"\n#include \"asio/execution/set_done.hpp\"\n#include \"asio/execution/set_error.hpp\"\n#include \"asio/execution/set_value.hpp\"\n#include \"asio/execution/start.hpp\"\n#include \"asio/execution_context.hpp\"\n#include \"asio/executor.hpp\"\n#include \"asio/executor_work_guard.hpp\"\n#include \"asio/file_base.hpp\"\n#include \"asio/generic/basic_endpoint.hpp\"\n#include \"asio/generic/datagram_protocol.hpp\"\n#include \"asio/generic/raw_protocol.hpp\"\n#include \"asio/generic/seq_packet_protocol.hpp\"\n#include \"asio/generic/stream_protocol.hpp\"\n#include \"asio/handler_alloc_hook.hpp\"\n#include \"asio/handler_continuation_hook.hpp\"\n#include \"asio/handler_invoke_hook.hpp\"\n#include \"asio/high_resolution_timer.hpp\"\n#include \"asio/io_context.hpp\"\n#include \"asio/io_context_strand.hpp\"\n#include \"asio/io_service.hpp\"\n#include \"asio/io_service_strand.hpp\"\n#include \"asio/ip/address.hpp\"\n#include \"asio/ip/address_v4.hpp\"\n#include \"asio/ip/address_v4_iterator.hpp\"\n#include \"asio/ip/address_v4_range.hpp\"\n#include \"asio/ip/address_v6.hpp\"\n#include \"asio/ip/address_v6_iterator.hpp\"\n#include \"asio/ip/address_v6_range.hpp\"\n#include \"asio/ip/network_v4.hpp\"\n#include \"asio/ip/network_v6.hpp\"\n#include \"asio/ip/bad_address_cast.hpp\"\n#include \"asio/ip/basic_endpoint.hpp\"\n#include \"asio/ip/basic_resolver.hpp\"\n#include \"asio/ip/basic_resolver_entry.hpp\"\n#include \"asio/ip/basic_resolver_iterator.hpp\"\n#include \"asio/ip/basic_resolver_query.hpp\"\n#include \"asio/ip/host_name.hpp\"\n#include \"asio/ip/icmp.hpp\"\n#include \"asio/ip/multicast.hpp\"\n#include \"asio/ip/resolver_base.hpp\"\n#include \"asio/ip/resolver_query_base.hpp\"\n#include \"asio/ip/tcp.hpp\"\n#include \"asio/ip/udp.hpp\"\n#include \"asio/ip/unicast.hpp\"\n#include \"asio/ip/v6_only.hpp\"\n#include \"asio/is_applicable_property.hpp\"\n#include \"asio/is_executor.hpp\"\n#include \"asio/is_read_buffered.hpp\"\n#include \"asio/is_write_buffered.hpp\"\n#include \"asio/local/basic_endpoint.hpp\"\n#include \"asio/local/connect_pair.hpp\"\n#include \"asio/local/datagram_protocol.hpp\"\n#include \"asio/local/stream_protocol.hpp\"\n#include \"asio/multiple_exceptions.hpp\"\n#include \"asio/packaged_task.hpp\"\n#include \"asio/placeholders.hpp\"\n#include \"asio/posix/basic_descriptor.hpp\"\n#include \"asio/posix/basic_stream_descriptor.hpp\"\n#include \"asio/posix/descriptor.hpp\"\n#include \"asio/posix/descriptor_base.hpp\"\n#include \"asio/posix/stream_descriptor.hpp\"\n#include \"asio/post.hpp\"\n#include \"asio/prefer.hpp\"\n#include \"asio/query.hpp\"\n#include \"asio/random_access_file.hpp\"\n#include \"asio/read.hpp\"\n#include \"asio/read_at.hpp\"\n#include \"asio/read_until.hpp\"\n#include \"asio/readable_pipe.hpp\"\n#include \"asio/recycling_allocator.hpp\"\n#include \"asio/redirect_error.hpp\"\n#include \"asio/registered_buffer.hpp\"\n#include \"asio/require.hpp\"\n#include \"asio/require_concept.hpp\"\n#include \"asio/serial_port.hpp\"\n#include \"asio/serial_port_base.hpp\"\n#include \"asio/signal_set.hpp\"\n#include \"asio/socket_base.hpp\"\n#include \"asio/static_thread_pool.hpp\"\n#include \"asio/steady_timer.hpp\"\n#include \"asio/strand.hpp\"\n#include \"asio/stream_file.hpp\"\n#include \"asio/streambuf.hpp\"\n#include \"asio/system_context.hpp\"\n#include \"asio/system_error.hpp\"\n#include \"asio/system_executor.hpp\"\n#include \"asio/system_timer.hpp\"\n#include \"asio/this_coro.hpp\"\n#include \"asio/thread.hpp\"\n#include \"asio/thread_pool.hpp\"\n#include \"asio/time_traits.hpp\"\n#include \"asio/use_awaitable.hpp\"\n#include \"asio/use_future.hpp\"\n#include \"asio/uses_executor.hpp\"\n#include \"asio/version.hpp\"\n#include \"asio/wait_traits.hpp\"\n#include \"asio/windows/basic_object_handle.hpp\"\n#include \"asio/windows/basic_overlapped_handle.hpp\"\n#include \"asio/windows/basic_random_access_handle.hpp\"\n#include \"asio/windows/basic_stream_handle.hpp\"\n#include \"asio/windows/object_handle.hpp\"\n#include \"asio/windows/overlapped_handle.hpp\"\n#include \"asio/windows/overlapped_ptr.hpp\"\n#include \"asio/windows/random_access_handle.hpp\"\n#include \"asio/windows/stream_handle.hpp\"\n#include \"asio/writable_pipe.hpp\"\n#include \"asio/write.hpp\"\n#include \"asio/write_at.hpp\"\n\n#endif\n\n'elaphureLink/elaphureLinkProxy/SocketClient.hpp'\n:﻿#pragma once\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n\n#include <sdkddkver.h>\n#include \"thirdparty/asio/include/asio.hpp\"\n\n#include \"pch.h\"\n\nusing asio::ip::tcp;\n\nclass SocketClient\n{\n    public:\n    SocketClient()\n        : is_running_(false),\n          connect_callback_(nullptr),\n          disconnect_callback_(nullptr)\n    {\n    }\n\n    void do_something();\n\n    ~SocketClient()\n    {\n\n\n\n        if (main_thread_.joinable()) {\n            main_thread_.join();\n        }\n    }\n\n    int init_socket(std::string address, std::string port = \"3240\")\n    {\n        socket_.reset(nullptr);\n\n        io_context_ = std::make_unique<asio::io_context>();\n        tcp::resolver resolver(get_io_context());\n\n        socket_ = std::make_unique<asio::ip::tcp::socket>(get_io_context());\n\n        try {\n            endpoint_ = resolver.resolve(address, port);\n        } catch (std::exception &e) {\n            return -1;\n        }\n\n        return 0;\n    }\n\n\n    void kill()\n    {\n        is_running_ = false;\n        if (k_is_proxy_init) {\n            k_shared_memory_ptr->info_page.is_proxy_ready       = 0;\n            k_shared_memory_ptr->consumer_page.command_response = 0xFFFFFFFF;\n            SetEvent(k_producer_event);\n            SetEvent(k_consumer_event);\n        }\n\n        socket_.get()->close();\n        io_context_.get()->stop();\n\n        Sleep(100);\n    }\n\n    int start()\n    {\n        using namespace std::chrono_literals;\n\n        std::unique_lock<std::mutex> lk(running_status_mutex_);\n        if (is_running_) {\n            return 0;\n        }\n\n        is_running_post_done_ = false;\n        is_running_           = true;\n\n        do_connect(endpoint_);\n\n        main_thread_ = std::thread([&]() {\n            try {\n                get_io_context().run();\n            } catch (std::exception &e) {\n                set_running_status(false, e.what());\n            }\n\n        });\n\n        running_cv_.wait(lk, [this]() { return is_running_post_done_; });\n\n        return !is_running_;\n    }\n\n    void wait_main_thread()\n    {\n        main_thread_.join();\n    }\n\n\n\n\n\n    public:\n    asio::io_context &get_io_context()\n    {\n        return *(io_context_.get());\n    }\n\n    asio::ip::tcp::socket &get_socket()\n    {\n        return *(socket_.get());\n    }\n\n    bool is_socket_running()\n    {\n        return is_running_;\n    }\n\n    void set_running_status(bool status, const std::string msg)\n    {\n        is_running_ = status;\n        if (status) {\n            if (connect_callback_) {\n                connect_callback_(msg.c_str());\n            }\n        } else {\n            if (disconnect_callback_) {\n                disconnect_callback_(msg.c_str());\n            }\n        }\n    }\n\n    void set_connect_callback(onSocketConnectCallbackType callback)\n    {\n        connect_callback_ = callback;\n    }\n\n    void set_disconnect_callback(onSocketDisconnectCallbackType callback)\n    {\n        disconnect_callback_ = callback;\n    }\n\n    private:\n    void close()\n    {\n        is_running_ = false;\n        if (k_is_proxy_init) {\n            k_shared_memory_ptr->info_page.is_proxy_ready       = 0;\n            k_shared_memory_ptr->consumer_page.command_response = 0xFFFFFFFF;\n            SetEvent(k_producer_event);\n            SetEvent(k_consumer_event);\n        }\n\n        asio::post(get_io_context(),\n                   [this]() {\n                       get_socket().close();\n                   });\n    }\n\n    void do_connect(const tcp::resolver::results_type &endpoints)\n    {\n        asio::async_connect(get_socket(), endpoints,\n                            [&](std::error_code ec, tcp::endpoint) {\n\n                                if (!ec) {\n                                    asio::ip::tcp::no_delay option(true);\n                                    get_socket().set_option(option);\n\n                                    set_keep_alive();\n\n                                    do_handshake();\n                                } else {\n                                    notify_connection_status(false, ec.message());\n                                    close();\n                                }\n                            });\n    }\n    void set_keep_alive();\n\n\n    void do_handshake();\n\n\n    void get_device_info();\n    void do_data_process();\n\n    void notify_connection_status(bool status, const std::string msg)\n    {\n        is_running_post_done_ = true;\n        set_running_status(status, msg);\n        running_cv_.notify_all();\n    }\n\n\n    private:\n    bool                    is_running_;\n    bool                    is_running_post_done_;\n    std::mutex              running_status_mutex_;\n    std::condition_variable running_cv_;\n\n    std::unique_ptr<asio::io_context> io_context_;\n    std::unique_ptr<tcp::socket>      socket_;\n\n    tcp::resolver::results_type endpoint_;\n\n    std::thread main_thread_;\n\n    onSocketConnectCallbackType    connect_callback_;\n    onSocketDisconnectCallbackType disconnect_callback_;\n};\n\n'elaphureLink/elaphureLinkProxy/protocol.cpp'\n:﻿\n#include \"pch.h\"\n\n#include \"SocketClient.hpp\"\n#include \"protocol.hpp\"\n\n\nvoid SocketClient::set_keep_alive()\n{\n    if (k_windows_version_number.major_version < 10) {\n        return;\n    } else if (k_windows_version_number.major_version == 10 && k_windows_version_number.build_number < 16299) {\n\n        return;\n    }\n\n\n\n    int enable_keepalive = 1;\n\n    int keepalive_idle_time_secs       = 20;\n    int keepalive_strobe_interval_secs = 5;\n    int num_keepalive_strobes          = 5;\n\n\n    setsockopt(socket_.get()->native_handle(), SOL_SOCKET, SO_KEEPALIVE, (char *)&enable_keepalive, sizeof(enable_keepalive));\n    setsockopt(socket_.get()->native_handle(), IPPROTO_TCP, TCP_KEEPCNT, (char *)&num_keepalive_strobes, sizeof(num_keepalive_strobes));\n    setsockopt(socket_.get()->native_handle(), IPPROTO_TCP, TCP_KEEPIDLE, (char *)&keepalive_idle_time_secs, sizeof(keepalive_idle_time_secs));\n    setsockopt(socket_.get()->native_handle(), IPPROTO_TCP, TCP_KEEPINTVL, (char *)&keepalive_strobe_interval_secs, sizeof(keepalive_strobe_interval_secs));\n}\n\nvoid SocketClient::do_handshake()\n{\n    el_request_handshake_t req;\n    req.el_link_identifier = htonl(EL_LINK_IDENTIFIER);\n    req.command            = htonl(EL_COMMAND_HANDSHAKE);\n    req.el_proxy_version   = htonl(EL_DAP_VERSION);\n\n    asio::error_code ec;\n    asio::write(get_socket(), asio::buffer(&req, sizeof(req)), ec);\n    if (ec) {\n        notify_connection_status(false, ec.message());\n        close();\n        return;\n    }\n\n\n    el_response_handshake_t res;\n\n    size_t n = asio::read(get_socket(),\n                          asio::buffer(&res, sizeof(res)),\n                          asio::transfer_exactly(sizeof(res)),\n                          ec);\n    if (ec) {\n        notify_connection_status(false, ec.message());\n        close();\n        return;\n    }\n\n    if (ntohl(res.el_link_identifier) != EL_LINK_IDENTIFIER) {\n        notify_connection_status(false, \"connect failed: unexpected identifier\");\n        close();\n        return;\n    }\n\n    if (ntohl(req.command) != EL_COMMAND_HANDSHAKE) {\n        notify_connection_status(false, \"connect failed: unexpected command\");\n        close();\n        return;\n    }\n\n    return get_device_info();\n}\n\nvoid SocketClient::get_device_info()\n{\n\n    std::array<char, 1500> info_res_buffer;\n\n\n    auto get_dap_info = [&](std::array<uint8_t, 2> buf) {\n        asio::error_code ec;\n        asio::write(get_socket(), asio::buffer(buf), asio::transfer_exactly(2), ec);\n        if (ec) {\n            notify_connection_status(false, ec.message());\n            close();\n            return false;\n        }\n\n        get_socket().read_some(asio::buffer(info_res_buffer), ec);\n\n        if (ec) {\n            notify_connection_status(false, ec.message());\n            close();\n            return false;\n        }\n\n        assert(info_res_buffer[0] == 0x00);\n        assert(info_res_buffer[1] >= 1);\n\n        return true;\n    };\n\n    if (!get_dap_info({ 0x00, 0x02 })) {\n        return;\n    }\n    int len = info_res_buffer[1];\n    memcpy(&(k_shared_memory_ptr->info_page.product_name), &info_res_buffer[2], len);\n\n\n\n    if (!get_dap_info({ 0x00, 0x03 })) {\n        return;\n    }\n    len = info_res_buffer[1];\n    memcpy(&(k_shared_memory_ptr->info_page.serial_number), &info_res_buffer[2], len);\n\n    if (!get_dap_info({ 0x00, 0x04 })) {\n        return;\n    }\n    len = info_res_buffer[1];\n    memcpy(&(k_shared_memory_ptr->info_page.firmware_version), &info_res_buffer[2], len);\n\n    if (!get_dap_info({ 0x00, 0xF0 })) {\n        return;\n    }\n    len = info_res_buffer[1];\n    assert(len == 1 || len == 2);\n    memcpy(&(k_shared_memory_ptr->info_page.capabilities), &info_res_buffer[2], len);\n\n\n\n    k_shared_memory_ptr->info_page.is_proxy_ready = 1;\n    notify_connection_status(true, \"connect succeeded\");\n    return do_data_process();\n}\n\nvoid SocketClient::do_data_process()\n{\n    asio::error_code          ec;\n    std::array<uint8_t, 1500> res_buffer;\n    int                       data_len;\n\n    for (;;) {\n\n        WaitForSingleObject(k_producer_event, INFINITE);\n        if (!is_running_) {\n            return;\n        }\n\n        asio::write(get_socket(),\n                    asio::buffer(&(k_shared_memory_ptr->producer_page.data), k_shared_memory_ptr->producer_page.data_len),\n                    ec);\n        if (ec) {\n            set_running_status(false, ec.message());\n            close();\n            return;\n        }\n\n\n        data_len = get_socket().read_some(asio::buffer(res_buffer), ec);\n        if (ec) {\n            set_running_status(false, ec.message());\n            close();\n            return;\n        }\n\n\n\n\n        uint8_t *p        = res_buffer.data();\n        int      count    = *p == ID_DAP_ExecuteCommands ? *(p + 1) : 1;\n        bool     out_flag = false;\n\n        if (*p == ID_DAP_ExecuteCommands) {\n            p += 2;\n        }\n\n        for (; count > 0; count--) {\n            switch (*p) {\n                case ID_DAP_Connect: {\n                    p += 2;\n                    break;\n                }\n                case ID_DAP_Disconnect: {\n                    p += 2;\n                    break;\n                }\n\n                case ID_DAP_TransferConfigure: {\n                    p += 2;\n                    set_consumer_status(DAP_RES_OK);\n                    break;\n                }\n                case ID_DAP_Transfer: {\n                    int transfer_count = (int)*++p;\n                    int status         = (int)*++p;\n                    p++;\n\n                    if (transfer_count != k_shared_memory_ptr->producer_page.command_count) {\n                        out_flag = true;\n\n                        set_consumer_status(DAP_RES_FAULT);\n                        break;\n                    }\n\n                    set_consumer_status(status);\n                    if (status != DAP_RES_OK) {\n\n                        out_flag = true;\n                        break;\n                    }\n\n                    int remain_data_len = data_len - (p - res_buffer.data());\n                    assert(remain_data_len % 4 == 0);\n                    k_shared_memory_ptr->consumer_page.data_len = remain_data_len;\n                    memcpy(k_shared_memory_ptr->consumer_page.data, p, remain_data_len);\n\n                    break;\n                }\n\n                case ID_DAP_TransferBlock: {\n                    p++;\n                    const int transfer_count = ((*(p + 1)) << 8) | (*p);\n                    p += 2;\n\n                    const int status = *p++;\n\n\n                    if (transfer_count != k_shared_memory_ptr->producer_page.command_count) {\n\n                        out_flag = true;\n\n                        set_consumer_status(DAP_RES_FAULT);\n                        break;\n                    }\n\n                    set_consumer_status(status);\n                    if (status != DAP_RES_OK && status != DAP_RES_FAULT) {\n\n                        out_flag = true;\n                        break;\n                    }\n\n                    const int remain_data_len = data_len - (p - res_buffer.data());\n                    assert(remain_data_len % 4 == 0);\n                    k_shared_memory_ptr->consumer_page.data_len = remain_data_len;\n                    memcpy(k_shared_memory_ptr->consumer_page.data, p, remain_data_len);\n\n                    break;\n                }\n\n                case ID_DAP_WriteABORT: {\n                    if (*(p + 1) != 0) {\n                        set_consumer_status(DAP_RES_FAULT);\n                        out_flag = true;\n                    } else {\n                        set_consumer_status(DAP_RES_OK);\n                    }\n\n                    break;\n                }\n\n                case ID_DAP_ResetTarget: {\n                    p += 3;\n                    break;\n                }\n                case ID_DAP_SWJ_Pins: {\n                    k_shared_memory_ptr->consumer_page.data_len = 1;\n                    k_shared_memory_ptr->consumer_page.data[0]  = *(p + 1);\n                    set_consumer_status(DAP_RES_OK);\n                    p += 2;\n                    break;\n                }\n                case ID_DAP_JTAG_Sequence: {\n                    if (*(p + 1) != 0) {\n                        set_consumer_status(DAP_RES_FAULT);\n                        out_flag = true;\n                        break;\n                    }\n\n                    p += 2;\n\n                    const int remain_data_len = data_len - (p - res_buffer.data());\n                    if (remain_data_len != k_shared_memory_ptr->producer_page.command_count) {\n                        out_flag = true;\n                        set_consumer_status(DAP_RES_FAULT);\n                        break;\n                    }\n                    k_shared_memory_ptr->consumer_page.data_len = remain_data_len;\n                    memcpy(k_shared_memory_ptr->consumer_page.data, p, remain_data_len);\n\n                    set_consumer_status(DAP_RES_OK);\n                    break;\n                }\n\n                case ID_DAP_JTAG_Configure: {\n                    int status = *(p + 1);\n                    p += 2;\n\n                    set_consumer_status(status == 0 ? DAP_RES_OK : DAP_RES_ERROR);\n                    break;\n                }\n\n                case ID_DAP_SWJ_Clock: {\n                    p += 2;\n                    break;\n                }\n                case ID_DAP_SWJ_Sequence: {\n                    int status = *(p + 1);\n                    p += 2;\n\n                    set_consumer_status(status == 0 ? DAP_RES_OK : DAP_RES_ERROR);\n                    break;\n                }\n                case ID_DAP_SWD_Configure: {\n                    p += 2;\n                    break;\n                }\n                default:\n                    close();\n                    return;\n            }\n\n            if (out_flag)\n                break;\n        }\n\n        if (out_flag) {\n\n        }\n\n\n\n\n\n        SetEvent(k_consumer_event);\n    }\n}\n\n'elaphureLink/thirdparty/asio/include/asio/thread.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_THREAD_HPP\n#define ASIO_THREAD_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include \"asio/detail/noncopyable.hpp\"\n#include \"asio/detail/thread.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\n\n\n\nclass thread\n  : private noncopyable\n{\npublic:\n\n\n  template <typename Function>\n  explicit thread(Function f)\n    : impl_(f)\n  {\n  }\n\n\n  ~thread()\n  {\n  }\n\n\n\n  void join()\n  {\n    impl_.join();\n  }\n\nprivate:\n  detail::thread impl_;\n};\n\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n",
        "gt": [
            "'elaphureLink/thirdparty/asio/include/asio/thread.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio.hpp'",
            "'elaphureLink/elaphureLinkProxy/SocketClient.hpp'",
            "'elaphureLink/elaphureLinkProxy/protocol.cpp'"
        ]
    },
    {
        "files": [
            "'obproxy/src/obproxy/omt/ob_vip_tenant_cpu.h'",
            "'obproxy/src/obproxy/omt/ob_cpu_table_processor.cpp'",
            "'obproxy/src/obproxy/omt/ob_cpu_table_processor.h'"
        ],
        "content": "'obproxy/src/obproxy/omt/ob_vip_tenant_cpu.h'\n:\n\n#ifndef OB_VIP_TENANT_CPU_H\n#define OB_VIP_TENANT_CPU_H\n\n#include \"lib/hash/ob_build_in_hashmap.h\"\n#include \"utils/ob_proxy_lib.h\"\n#include \"iocore/eventsystem/ob_buf_allocator.h\"\n#include \"iocore/eventsystem/ob_ethread.h\"\n#include \"lib/container/ob_se_array.h\"\n#include \"lib/lock/ob_drw_lock.h\"\n#include \"ob_cgroup_ctrl.h\"\n\nnamespace oceanbase\n{\nnamespace obproxy\n{\nnamespace omt\n{\n\nenum ObTenantCpuStatus {\n  INSTANCE_CREATE_STATUS = 0,\n  INSTANCE_UPDATE_STATUS,\n  INSTANCE_COMMIT_STATUS\n};\n\nclass ObTenantCpu : public common::ObSharedRefCount {\npublic:\n  ObTenantCpu(\n    common::ObString& cluster_name,\n    common::ObString& tenant_name,\n    common::ObString& vip_name,\n    common::ObString& full_name,\n    double max_cpu_usage,\n    ObCgroupCtrl &cgroup_ctrl);\n  virtual ~ObTenantCpu() { reset(); };\n  virtual void free() { destroy(); }\n  int init();\n  void destroy();\n  void remove_tenant_cgroup();\n  void reset();\n  event::ObEThread* get_tenant_schedule_ethread() {\n    return thread_array_[index_++ % thread_array_.count()];\n  }\n\n  int set_unit_max_cpu(double cpu);\n  int acquire_more_worker(const int64_t tid);\n\n  TO_STRING_KV(K_(tenant_name), K_(cluster_name), K_(vip_name), K_(full_name),\n      K_(max_thread_num), K_(backup_max_thread_num), K_(max_cpu_usage), K_(backup_max_cpu_usage),\n      K_(index), K_(is_inited), K_(instance_status));\n\npublic:\n  common::ObString tenant_name_;\n  common::ObString cluster_name_;\n  common::ObString vip_name_;\n  common::ObString full_name_;\n  int64_t max_thread_num_;\n  int64_t backup_max_thread_num_;\n  double max_cpu_usage_;\n  double backup_max_cpu_usage_;\n  ObCgroupCtrl &cgroup_ctrl_;\n  int64_t index_;\n  bool is_inited_;\n  ObTenantCpuStatus instance_status_;\n  common::ObSEArray<event::ObEThread*, 16> thread_array_;\n\n  LINK(ObTenantCpu, cpu_link_);\n\nprivate:\n  char tenant_name_str_[common::OB_MAX_TENANT_NAME_LENGTH];\n  char cluster_name_str_[OB_PROXY_MAX_CLUSTER_NAME_LENGTH];\n  char vip_name_str_[common::MAX_IP_ADDR_LENGTH];\n  char full_name_str_[OB_PROXY_MAX_TENANT_CLUSTER_NAME_LENGTH + common::MAX_IP_ADDR_LENGTH];\n  DISALLOW_COPY_AND_ASSIGN(ObTenantCpu);\n};\n\nclass ObTenantCpuCache\n{\npublic:\n  ObTenantCpuCache() : vt_cpu_map_() { }\n  virtual ~ObTenantCpuCache() { }\n\n  void destroy();\n\npublic:\n  static const int64_t HASH_BUCKET_SIZE = 64;\n\n  struct VTCacheHashing\n  {\n    typedef const common::ObString &Key;\n    typedef ObTenantCpu Value;\n    typedef ObDLList(ObTenantCpu, cpu_link_) ListHead;\n\n    static uint64_t hash(Key key) { return key.hash(); }\n    static Key key(Value *value) { return value->full_name_; }\n    static bool equal(Key lhs, Key rhs) { return lhs == rhs; }\n  };\n  typedef common::hash::ObBuildInHashMap<VTCacheHashing, HASH_BUCKET_SIZE> VTCpuHashMap;\n\npublic:\n  int set(ObTenantCpu* vt);\n  int get(common::ObString& key_name, ObTenantCpu*& vt_conn);\n  int erase(common::ObString& cluster_name, common::ObString& tenant_name);\n  void backup();\n  int recover();\n  int check();\n  int update();\n  void commit();\n  int64_t get_cpu_map_count();\n  void clear_cpu_map(VTCpuHashMap &cache_map);\n  void dump_cpu_map(VTCpuHashMap &cache_map);\n\nprivate:\n  VTCpuHashMap vt_cpu_map_;\n  DISALLOW_COPY_AND_ASSIGN(ObTenantCpuCache);\n};\n\n}\n}\n}\n\n#endif\n\n'obproxy/src/obproxy/omt/ob_cpu_table_processor.cpp'\n:\n\n#define USING_LOG_PREFIX PROXY\n\n#include \"ob_cpu_table_processor.h\"\n#include \"obutils/ob_proxy_json_config_info.h\"\n#include \"obproxy/utils/ob_proxy_utils.h\"\n\nnamespace oceanbase\n{\nnamespace obproxy\n{\nnamespace omt\n{\n\nstatic const char* JSON_OBPROXY_VIP       = \"vip\";\nstatic const char* JSON_OBPROXY_VALUE     = \"value\";\nstatic const uint32_t column_num          = 4;\n\nusing namespace oceanbase::common;\nusing namespace oceanbase::obproxy::event;\nusing namespace oceanbase::obproxy::obutils;\nusing namespace oceanbase::json;\n\nextern int build_tenant_cluster_vip_name(const ObString &tenant_name, const ObString &cluster_name, const ObString &vip_name,\n    ObFixedLengthString<OB_PROXY_MAX_TENANT_CLUSTER_NAME_LENGTH + MAX_IP_ADDR_LENGTH> &key_string);\n\nvoid ObCpuTableProcessor::commit(bool is_success)\n{\n  if (!is_success) {\n    cpu_rollback();\n  } else {\n    cpu_commit();\n  }\n  is_cpu_backup_succ_ = false;\n}\n\nint ObCpuTableProcessor::init()\n{\n  int ret = OB_SUCCESS;\n  int tmp_ret = OB_SUCCESS;\n  if (OB_SUCCESS != (tmp_ret = cgroup_ctrl_.init())) {\n\n    LOG_DEBUG(\"fail to init tenant cgroup ctrl\", K(tmp_ret));\n  }\n  return ret;\n}\n\nvoid ObCpuTableProcessor::destroy()\n{\n  DRWLock::WRLockGuard guard(tenant_cpu_rwlock_);\n  tenant_cpu_cache_.destroy();\n}\n\nint ObCpuTableProcessor::cpu_handle_replace_config(\n    ObString& cluster_name, ObString& tenant_name, ObString& name_str, ObString& value_str, const bool need_to_backup)\n{\n  UNUSED(name_str);\n  int ret = OB_SUCCESS;\n\n  if (OB_UNLIKELY(cluster_name.empty()) || OB_UNLIKELY(tenant_name.empty())) {\n    ret = OB_INVALID_ARGUMENT;\n    LOG_WDIAG(\"tenant or cluster is null\", K(ret), K(cluster_name), K(tenant_name));\n  } else if (need_to_backup && FALSE_IT(backup_local_cpu_cache())) {\n  } else if (OB_FAIL(fill_local_cpu_cache(cluster_name, tenant_name, value_str))) {\n    LOG_WDIAG(\"update vip tenant cpu cache failed\", K(ret));\n  } else {\n    LOG_INFO(\"update vip tenant cpu cache succ\", \"count\", get_cpu_map_count(), K(cluster_name), K(tenant_name), K(value_str));\n  }\n\n  return ret;\n}\n\nint ObCpuTableProcessor::cpu_handle_delete_config(ObString& cluster_name, ObString& tenant_name, const bool need_to_backup)\n{\n  int ret = OB_SUCCESS;\n\n  if (OB_UNLIKELY(cluster_name.empty()) || OB_UNLIKELY(tenant_name.empty())) {\n    ret = OB_INVALID_ARGUMENT;\n    LOG_WDIAG(\"tenant_name or cluster_name is null\", K(ret), K(cluster_name), K(tenant_name));\n  } else {\n    if (need_to_backup) {\n      backup_local_cpu_cache();\n    }\n    DRWLock::WRLockGuard guard(tenant_cpu_rwlock_);\n    tenant_cpu_cache_.erase(cluster_name, tenant_name);\n    LOG_INFO(\"erase vip tenant cpu cache succ\", \"count\", get_cpu_map_count(), K(cluster_name), K(tenant_name));\n  }\n\n  return ret;\n}\n\nvoid ObCpuTableProcessor::backup_local_cpu_cache()\n{\n  DRWLock::WRLockGuard guard(tenant_cpu_rwlock_);\n  tenant_cpu_cache_.backup();\n  is_cpu_backup_succ_ = true;\n}\n\nint ObCpuTableProcessor::check_json_value(bool has_set_vip, ObString vip_list_str,\n    bool has_set_value, ObString value)\n{\n  int ret = OB_SUCCESS;\n  if (has_set_vip && vip_list_str.empty()) {\n    ret = OB_ERR_UNEXPECTED;\n    LOG_WDIAG(\"check json value failed\", K(ret), K(has_set_vip), K(vip_list_str));\n  }\n  if (OB_SUCC(ret)) {\n    if (!has_set_value || value.empty()) {\n      ret = OB_ERR_UNEXPECTED;\n      LOG_WDIAG(\"check json value failed\", K(ret), K(has_set_value), K(value));\n    }\n  }\n  return ret;\n}\n\nint ObCpuTableProcessor::fill_local_cpu_cache(\n    ObString& cluster_name, ObString& tenant_name, ObString& vip_name)\n{\n  int ret = OB_SUCCESS;\n  Parser parser;\n  json::Value *info_config = NULL;\n  ObArenaAllocator json_allocator(ObModIds::OB_JSON_PARSER);\n\n  ObString max_cpu_usage = 0;\n  double double_max_cpu_usage = 0.0;\n  ObString vip_list_str;\n  bool has_set_vip = false;\n  bool has_set_value = false;\n  if (OB_UNLIKELY(cluster_name.empty()) || OB_UNLIKELY(tenant_name.empty()) || OB_UNLIKELY(vip_name.empty())) {\n    ret = OB_INVALID_ARGUMENT;\n    LOG_WDIAG(\"name is empty\", K(cluster_name), K(tenant_name), K(vip_name), K(ret));\n  } else if (OB_FAIL(parser.init(&json_allocator))) {\n    LOG_WDIAG(\"json parser init failed\", K(ret));\n  } else if (OB_FAIL(parser.parse(vip_name.ptr(), vip_name.length(), info_config))) {\n    LOG_WDIAG(\"parse json failed\", K(ret), \"vip_json_str\", get_print_json(vip_name));\n  } else if (OB_FAIL(ObProxyJsonUtils::check_config_info_type(info_config, json::JT_ARRAY))) {\n    LOG_WDIAG(\"check config info type failed\", K(ret));\n  } else {\n    DLIST_FOREACH(it, info_config->get_array()) {\n      if (OB_FAIL(ObProxyJsonUtils::check_config_info_type(it, json::JT_OBJECT))) {\n        LOG_WDIAG(\"check config info type failed\", K(ret));\n      } else {\n        DLIST_FOREACH(p, it->get_object()) {\n          if (p->name_ == JSON_OBPROXY_VIP) {\n            if (OB_FAIL(ObProxyJsonUtils::check_config_info_type(p->value_, json::JT_STRING))) {\n              LOG_WDIAG(\"check config info type failed\", K(ret));\n            } else {\n              vip_list_str = p->value_->get_string();\n              has_set_vip = true;\n            }\n          } else if (p->name_ == JSON_OBPROXY_VALUE) {\n\n            if (OB_FAIL(ObProxyJsonUtils::check_config_info_type(p->value_, json::JT_STRING))) {\n              LOG_WDIAG(\"check config info type failed\", K(ret));\n            } else {\n              max_cpu_usage = p->value_->get_string();\n              has_set_value = true;\n            }\n          }\n        }\n      }\n      if (OB_SUCC(ret)) {\n        if (OB_FAIL(check_json_value(has_set_vip, vip_list_str, has_set_value, max_cpu_usage))) {\n          LOG_WDIAG(\"check json value failed\", K(cluster_name), K(tenant_name), K(vip_list_str), K(max_cpu_usage), K(ret));\n        } else if (OB_FAIL(get_double_value(max_cpu_usage, double_max_cpu_usage))) {\n          LOG_WDIAG(\"fail to get double\", K(max_cpu_usage), K(double_max_cpu_usage), K(ret));\n        } else if (OB_FAIL(handle_cpu_config(cluster_name, tenant_name, vip_list_str, double_max_cpu_usage))) {\n          LOG_WDIAG(\"update config faild\", K(cluster_name), K(tenant_name), K(vip_list_str), K(double_max_cpu_usage), K(ret));\n        }\n      }\n    }\n    if (OB_SUCC(ret)) {\n      if (OB_FAIL(check_cpu_config())) {\n        LOG_WDIAG(\"check config faild\", K(ret));\n      } else if (OB_FAIL(update_cpu_config())) {\n        LOG_WDIAG(\"update cpu config faild\", K(ret));\n      }\n    }\n  }\n\n  return ret;\n}\n\nint ObCpuTableProcessor::handle_cpu_config(\n    ObString& cluster_name, ObString& tenant_name, ObString& vip_name, double max_cpu_usage)\n{\n  int ret = OB_SUCCESS;\n  ObString key_name;\n  ObTenantCpu* tenant_cpu = NULL;\n  common::ObFixedLengthString<OB_PROXY_MAX_TENANT_CLUSTER_NAME_LENGTH + common::MAX_IP_ADDR_LENGTH> key_string;\n  if (max_cpu_usage <= 0) {\n    ret = OB_ERR_UNEXPECTED;\n    LOG_WDIAG(\"max cpu usage error\", K(max_cpu_usage), K(ret));\n  } else if (OB_FAIL(build_tenant_cluster_vip_name(tenant_name, cluster_name, vip_name, key_string))) {\n    LOG_WDIAG(\"build tenant cluser vip name failed\", K(tenant_name), K(cluster_name), K(vip_name), K(ret));\n  } else {\n    key_name = ObString::make_string(key_string.ptr());\n    if (OB_FAIL(get_or_create_tenant_cpu(cluster_name, tenant_name, vip_name, key_name, max_cpu_usage, tenant_cpu))) {\n      LOG_WDIAG(\"create tenant cpu failed\", K(key_name), K(ret));\n    } else {\n      tenant_cpu->max_cpu_usage_ = max_cpu_usage;\n      tenant_cpu->max_thread_num_ = (int64_t)ceil(tenant_cpu->max_cpu_usage_);\n      if (INSTANCE_CREATE_STATUS != tenant_cpu->instance_status_) {\n        tenant_cpu->instance_status_ = INSTANCE_UPDATE_STATUS;\n      }\n      tenant_cpu->dec_ref();\n    }\n  }\n  return ret;\n}\n\nint ObCpuTableProcessor::check_cpu_config()\n{\n  int ret = OB_SUCCESS;\n  DRWLock::RDLockGuard guard(tenant_cpu_rwlock_);\n  if (OB_FAIL(tenant_cpu_cache_.check())) {\n    LOG_WDIAG(\"check cpu config failed\", K(ret));\n  }\n  return ret;\n}\n\nint ObCpuTableProcessor::update_cpu_config()\n{\n  int ret = OB_SUCCESS;\n  DRWLock::WRLockGuard guard(tenant_cpu_rwlock_);\n  if (OB_FAIL(tenant_cpu_cache_.update())) {\n    LOG_WDIAG(\"update cpu config failed\", K(ret));\n  }\n  return ret;\n}\n\nint ObCpuTableProcessor::create_tenant_cpu(ObString& cluster_name, ObString& tenant_name,\n    ObString& vip_name, ObString& key_name, double max_cpu_usage, ObTenantCpu*& tenant_cpu)\n{\n  int ret = OB_SUCCESS;\n  DRWLock::WRLockGuard guard(tenant_cpu_rwlock_);\n  ObTenantCpu* tmp_tenant_cpu = NULL;\n  if (OB_FAIL(tenant_cpu_cache_.get(key_name, tmp_tenant_cpu))) {\n    if (OB_HASH_NOT_EXIST == ret) {\n      char *buf = NULL;\n      int64_t alloc_size = sizeof(ObTenantCpu);\n      if (OB_ISNULL(buf = static_cast<char *>(op_fixed_mem_alloc(alloc_size)))) {\n        ret = OB_ALLOCATE_MEMORY_FAILED;\n        LOG_WDIAG(\"fail to alloc memory for tenant cpu\", K(alloc_size), K(ret));\n      } else {\n        tenant_cpu = new (buf) ObTenantCpu(cluster_name, tenant_name, vip_name, key_name, max_cpu_usage, cgroup_ctrl_);\n        tenant_cpu->inc_ref();\n        if (OB_FAIL(tenant_cpu_cache_.set(tenant_cpu))) {\n          LOG_WDIAG(\"fail to set tenant cpu map\", K(key_name), KPC(tenant_cpu), K(ret));\n        }\n      }\n      if (OB_SUCC(ret)) {\n        tenant_cpu->inc_ref();\n      } else if (OB_NOT_NULL(tenant_cpu)) {\n        tenant_cpu->dec_ref();\n        tenant_cpu = NULL;\n      }\n    }\n  } else {\n    tenant_cpu = tmp_tenant_cpu;\n    tenant_cpu->inc_ref();\n  }\n\n  return ret;\n}\n\nint ObCpuTableProcessor::get_tenant_cpu(ObString& key_name, ObTenantCpu*& tenant_cpu)\n{\n  int ret = OB_SUCCESS;\n  DRWLock::RDLockGuard guard(tenant_cpu_rwlock_);\n  ObTenantCpu* tmp_tenant_cpu = NULL;\n  if (OB_FAIL(tenant_cpu_cache_.get(key_name, tmp_tenant_cpu))) {\n  } else {\n    tenant_cpu = tmp_tenant_cpu;\n    tenant_cpu->inc_ref();\n    LOG_DEBUG(\"succ to get tenant cpu from map\", K(key_name), KPC(tenant_cpu));\n  }\n\n  return ret;\n}\n\nint ObCpuTableProcessor::get_or_create_tenant_cpu(ObString& cluster_name, ObString& tenant_name,\n    ObString& vip_name, ObString& key_name, double max_cpu_usage, ObTenantCpu*& tenant_cpu)\n{\n  int ret = OB_SUCCESS;\n  if (OB_FAIL(get_tenant_cpu(key_name, tenant_cpu))) {\n    if (OB_HASH_NOT_EXIST == ret) {\n      if (OB_FAIL(create_tenant_cpu(cluster_name, tenant_name, vip_name, key_name, max_cpu_usage, tenant_cpu))) {\n        LOG_WDIAG(\"fail to create tenant cpu\", K(key_name), K(ret));\n      } else {\n        LOG_DEBUG(\"succ to create tenant cpu\", K(key_name), K(max_cpu_usage), KPC(tenant_cpu));\n      }\n    } else {\n      LOG_WDIAG(\"fail to get tenant cpu\", K(key_name), K(ret));\n    }\n  }\n  return ret;\n}\n\nvoid ObCpuTableProcessor::cpu_rollback()\n{\n  LOG_INFO(\"cpu rollback\");\n  DRWLock::WRLockGuard guard(tenant_cpu_rwlock_);\n  if (OB_LIKELY(is_cpu_backup_succ_)) {\n    tenant_cpu_cache_.recover();\n  }\n}\n\nvoid ObCpuTableProcessor::cpu_commit()\n{\n  LOG_INFO(\"cpu commit\");\n  DRWLock::WRLockGuard guard(tenant_cpu_rwlock_);\n  tenant_cpu_cache_.commit();\n}\n\nObCpuTableProcessor &get_global_cpu_table_processor()\n{\n  static ObCpuTableProcessor cpu_table_processor;\n  return cpu_table_processor;\n}\n\n}\n}\n}\n\n'obproxy/src/obproxy/omt/ob_cpu_table_processor.h'\n:\n\n#ifndef OBPROXY_CPU_TABLE_PROCESSOR_H\n#define OBPROXY_CPU_TABLE_PROCESSOR_H\n\n#include \"obutils/ob_config_processor.h\"\n#include \"lib/lock/ob_drw_lock.h\"\n#include \"ob_vip_tenant_cpu.h\"\n\nnamespace oceanbase\n{\nnamespace obproxy\n{\nnamespace omt\n{\n\nclass ObCpuTableProcessor\n{\npublic:\n  ObCpuTableProcessor() : is_cpu_backup_succ_(false), tenant_cpu_rwlock_() {}\n  virtual ~ObCpuTableProcessor() { destroy(); }\n  int init();\n  void destroy();\n  void commit(bool is_success);\n  int check_json_value(bool has_set_vip, common::ObString vip_list_str, bool has_set_value, common::ObString value);\n  int cpu_handle_replace_config(common::ObString& cluster_name, common::ObString& tenant_name, common::ObString& name_str, common::ObString& value_str, const bool need_to_backup);\n  int cpu_handle_delete_config(common::ObString& cluster_name, common::ObString& tenant_name, const bool need_to_backup);\n  void backup_local_cpu_cache();\n  int fill_local_cpu_cache(common::ObString& cluster_name, common::ObString& tenant_name, common::ObString& vip_name);\n  int create_tenant_cpu(common::ObString& cluster_name, common::ObString& tenant_name, common::ObString& vip_name, common::ObString& key_name, double max_cpu_usage, ObTenantCpu*& tenant_cpu);\n  int get_tenant_cpu(common::ObString& key_name, ObTenantCpu*& tenant_cpu);\n  int get_or_create_tenant_cpu(common::ObString& cluster_name, common::ObString& tenant_name, common::ObString& vip_name, common::ObString& key_name, double max_cpu_usage, ObTenantCpu*& tenant_cpu);\n  void cpu_rollback();\n  void cpu_commit();\n  int64_t get_cpu_map_count() { return tenant_cpu_cache_.get_cpu_map_count(); }\n  int handle_cpu_config(common::ObString& cluster_name, common::ObString& tenant_name, common::ObString& vip_name, double max_cpu_usage);\n  int check_cpu_config();\n  int update_cpu_config();\n\n  TO_STRING_KV(K_(is_cpu_backup_succ));\n\nprivate:\n  bool is_cpu_backup_succ_;\n  ObCgroupCtrl cgroup_ctrl_;\n  common::DRWLock tenant_cpu_rwlock_;\n  ObTenantCpuCache tenant_cpu_cache_;\n\n  DISALLOW_COPY_AND_ASSIGN(ObCpuTableProcessor);\n};\n\nObCpuTableProcessor &get_global_cpu_table_processor();\n\n}\n}\n}\n\n#endif\n",
        "gt": [
            "'obproxy/src/obproxy/omt/ob_vip_tenant_cpu.h'",
            "'obproxy/src/obproxy/omt/ob_cpu_table_processor.h'",
            "'obproxy/src/obproxy/omt/ob_cpu_table_processor.cpp'"
        ]
    },
    {
        "files": [
            "'LuaSTGPlus/include/lstg/Core/Subsystem/Asset/BasicTexture2DAsset.hpp'",
            "'LuaSTGPlus/src/v2/Bridge/AssetManagerModule.cpp'",
            "'LuaSTGPlus/include/lstg/v2/Asset/TextureAsset.hpp'"
        ],
        "content": "'LuaSTGPlus/include/lstg/Core/Subsystem/Asset/BasicTexture2DAsset.hpp'\n:\n#pragma once\n#include <optional>\n#include \"Asset.hpp\"\n#include \"../Render/Texture.hpp\"\n\nnamespace lstg::Subsystem::Asset\n{\n    class BasicTexture2DAssetLoader;\n\n\n    class BasicTexture2DAsset :\n        public Asset\n    {\n        friend class BasicTexture2DAssetLoader;\n\n    public:\n        [[nodiscard]] static AssetTypeId GetAssetTypeIdStatic() noexcept;\n\n    public:\n        BasicTexture2DAsset(std::string name, std::string path);\n\n    public:\n\n        [[nodiscard]] const std::string& GetPath() const noexcept { return m_stPath; }\n\n\n        [[nodiscard]] const Render::TexturePtr& GetTexture() const noexcept { return m_pTexture; }\n\n\n        [[nodiscard]] uint32_t GetWidth() const noexcept;\n\n\n        [[nodiscard]] uint32_t GetHeight() const noexcept;\n\n    protected:\n        [[nodiscard]] AssetTypeId GetAssetTypeId() const noexcept override;\n\n    private:\n        void InitTextureInfo() noexcept;\n        void ReceiveLoadedAsset(Render::TexturePtr tex) noexcept;\n\n    private:\n        struct TextureInfo\n        {\n            uint32_t Width;\n            uint32_t Height;\n        };\n\n\n        const std::string m_stPath;\n\n\n        std::optional<TextureInfo> m_stTextureInfo;\n        Render::TexturePtr m_pTexture;\n    };\n\n    using BasicTexture2DAssetPtr = std::shared_ptr<BasicTexture2DAsset>;\n}\n\n'LuaSTGPlus/src/v2/Bridge/AssetManagerModule.cpp'\n:\n#include <lstg/v2/Bridge/AssetManagerModule.hpp>\n\n#include <lstg/Core/Logging.hpp>\n#include <lstg/Core/Subsystem/AssetSystem.hpp>\n#include <lstg/v2/Asset/TextureAsset.hpp>\n#include <lstg/v2/Asset/SpriteAsset.hpp>\n#include <lstg/v2/Asset/SpriteSequenceAsset.hpp>\n#include <lstg/v2/Asset/TrueTypeFontAsset.hpp>\n#include <lstg/v2/Asset/HgeFontAsset.hpp>\n#include <lstg/v2/Asset/EffectAsset.hpp>\n#include <lstg/v2/Asset/HgeParticleAsset.hpp>\n#include <lstg/v2/Asset/SoundAsset.hpp>\n#include <lstg/v2/Asset/MusicAsset.hpp>\n#include \"detail/Helper.hpp\"\n\nusing namespace std;\nusing namespace lstg;\nusing namespace lstg::v2::Bridge;\nusing namespace lstg::Subsystem;\nusing namespace lstg::Subsystem::Asset;\n\nLSTG_DEF_LOG_CATEGORY(AssetManagerModule);\n\n#define GET_CURRENT_POOL \\\n    auto assetPools = detail::GetGlobalApp().GetAssetPools(); \\\n    auto [_, currentAssetPool] = assetPools->GetCurrentAssetPool(); \\\n    if (!currentAssetPool) \\\n        stack.Error(\"can't load resource at this time.\"); \\\n    assert(currentAssetPool)\n\nvoid AssetManagerModule::SetResourceStatus(LuaStack& stack, const char* pool)\n{\n    auto assetPools = detail::GetGlobalApp().GetAssetPools();\n\n    if (::strcmp(pool, \"global\") == 0)\n        assetPools->SetCurrentAssetPool(AssetPoolTypes::Global);\n    else if (::strcmp(pool, \"stage\") == 0)\n        assetPools->SetCurrentAssetPool(AssetPoolTypes::Stage);\n    else if (::strcmp(pool, \"none\") == 0)\n        assetPools->SetCurrentAssetPool(AssetPoolTypes::None);\n    else\n        stack.Error(\"invalid argument #1 for 'SetResourceStatus', requires 'stage', 'global' or 'none'.\");\n}\n\nvoid AssetManagerModule::RemoveResource(LuaStack& stack, const char* pool, std::optional<AssetTypes> type, std::optional<const char*> name)\n{\n    auto assetPools = detail::GetGlobalApp().GetAssetPools();\n\n    auto p = AssetPoolTypes::None;\n    if (::strcmp(pool, \"global\") == 0)\n        p = AssetPoolTypes::Global;\n    else if (::strcmp(pool, \"stage\") == 0)\n        p = AssetPoolTypes::Stage;\n    else if (::strcmp(pool, \"none\") == 0)\n        p = AssetPoolTypes::None;\n    else\n        stack.Error(\"invalid argument #1 for 'RemoveResource', requires 'stage', 'global' or 'none'.\");\n\n    if (type)\n    {\n        if (!name)\n            stack.Error(\"argument #3 must be specified\");\n        assetPools->RemoveAsset(p, *type, *name);\n    }\n    else\n    {\n        assetPools->ClearAssetPool(p);\n        if (p == AssetPoolTypes::Global)\n            LSTG_LOG_INFO_CAT(AssetManagerModule, \"Global asset pool is clear\");\n        else if (p == AssetPoolTypes::Stage)\n            LSTG_LOG_INFO_CAT(AssetManagerModule, \"Stage asset pool is clear\");\n    }\n}\n\nstd::optional<const char*> AssetManagerModule::CheckRes(AssetTypes type, const char* name)\n{\n    auto assetPools = detail::GetGlobalApp().GetAssetPools();\n\n\n\n    auto p = assetPools->LocateAsset(type, name);\n    switch (std::get<0>(p))\n    {\n        case AssetPoolTypes::Global:\n            return \"global\";\n        case AssetPoolTypes::Stage:\n            return \"stage\";\n        default:\n            return nullopt;\n    }\n}\n\nAssetManagerModule::Unpack<AssetManagerModule::AbsIndex, AssetManagerModule::AbsIndex> AssetManagerModule::EnumRes(LuaStack& stack,\n    AssetTypes type)\n{\n    auto assetPools = detail::GetGlobalApp().GetAssetPools();\n\n    AssetPool* pools[] = {\n        assetPools->GetGlobalAssetPool().get(),\n        assetPools->GetStageAssetPool().get()\n    };\n\n    auto base = stack.GetTop();\n    for (auto assetPool : pools)\n    {\n        size_t idx = 1;\n        lua_newtable(stack);\n        assetPool->Visit([&](const AssetPtr& asset) -> std::tuple<bool, monostate> {\n            if (IsAssetNameMatchType(asset->GetName(), type))\n                stack.RawSet(-1, static_cast<int>(idx++), ExtractAssetName(asset->GetName()).c_str());\n            return { false, {} };\n        });\n    }\n    assert(stack.GetTop() == base + 2);\n    assert(stack.TypeOf(base + 1) == LUA_TTABLE);\n    assert(stack.TypeOf(base + 2) == LUA_TTABLE);\n    return { AbsIndex(base + 1u), AbsIndex(base + 2u) };\n}\n\nAssetManagerModule::Unpack<double, double> AssetManagerModule::GetTextureSize(LuaStack& stack, const char* name)\n{\n    auto assetPools = detail::GetGlobalApp().GetAssetPools();\n\n    auto asset = assetPools->FindAsset(AssetTypes::Texture, name);\n    if (!asset)\n        stack.Error(\"texture '%s' not found.\", name);\n    assert(asset);\n    assert(asset->GetAssetTypeId() == Asset::TextureAsset::GetAssetTypeIdStatic());\n\n    auto texAsset = static_pointer_cast<Asset::TextureAsset>(asset);\n    return {texAsset->GetWidth(), texAsset->GetHeight()};\n}\n\nvoid AssetManagerModule::LoadTexture(LuaStack& stack, const char* name, const char* path, std::optional<bool> mipmap )\n{\n    GET_CURRENT_POOL;\n\n    auto assetSystem = detail::GetGlobalApp().GetSubsystem<AssetSystem>();\n    assert(assetSystem);\n\n\n    auto fullName = MakeFullAssetName(AssetTypes::Texture, name);\n    if (currentAssetPool->ContainsAsset(fullName))\n    {\n        LSTG_LOG_WARN_CAT(AssetManagerModule, \"Texture \\\"{}\\\" is already loaded\", name);\n        return;\n    }\n\n\n    auto ret = assetSystem->CreateAsset<Asset::TextureAsset>(currentAssetPool, fullName, nlohmann::json {\n        {\"rt\", false},\n        {\"path\", detail::ResolveAbsoluteOrRelativePath(stack, path)},\n        {\"mipmaps\", mipmap ? *mipmap : false},\n    });\n    if (!ret)\n        stack.Error(\"load texture from file '%s' fail: %s\", path, ret.GetError().message().c_str());\n}\n\nvoid AssetManagerModule::LoadImage(LuaStack& stack, const char* name, const char* textureName, double x, double y, double w, double h,\n    std::optional<double> a, std::optional<double> b, std::optional<bool> rect)\n{\n    GET_CURRENT_POOL;\n\n    auto assetSystem = detail::GetGlobalApp().GetSubsystem<AssetSystem>();\n    assert(assetSystem);\n\n\n    auto fullName = MakeFullAssetName(AssetTypes::Image, name);\n    if (currentAssetPool->ContainsAsset(fullName))\n    {\n        LSTG_LOG_WARN_CAT(AssetManagerModule, \"Sprite \\\"{}\\\" is already loaded\", name);\n        return;\n    }\n\n\n    nlohmann::json args {\n        {\"texture\", MakeFullAssetName(AssetTypes::Texture, textureName)},\n        {\"left\", x},\n        {\"top\", y},\n        {\"width\", w},\n        {\"height\", h},\n        {\"colliderHalfSizeX\", a ? *a : 0.},\n        {\"colliderHalfSizeY\", b ? *b : (a ? *a : 0.)},\n        {\"colliderIsRect\", rect && *rect},\n    };\n\n\n    auto ret = assetSystem->CreateAsset<Asset::SpriteAsset>(currentAssetPool, fullName, args);\n    if (!ret)\n        stack.Error(\"load image \\\"%s\\\" fail: %s\", name, ret.GetError().message().c_str());\n}\n\nvoid AssetManagerModule::SetImageState(LuaStack& stack, const char* name, const char* blend, std::optional<LSTGColor*> vertexColor1,\n    std::optional<LSTGColor*> vertexColor2, std::optional<LSTGColor*> vertexColor3, std::optional<LSTGColor*> vertexColor4)\n{\n    auto assetPools = detail::GetGlobalApp().GetAssetPools();\n\n    auto asset = assetPools->FindAsset(AssetTypes::Image, name);\n    if (!asset)\n        stack.Error(\"image '%s' not found.\", name);\n    assert(asset);\n    assert(asset->GetAssetTypeId() == Asset::SpriteAsset::GetAssetTypeIdStatic());\n\n    if (!((vertexColor1 && vertexColor2 && vertexColor3 && vertexColor4) ||\n        (!vertexColor1 && !vertexColor2 && !vertexColor3 && !vertexColor4) ||\n        (vertexColor1 && !vertexColor2 && !vertexColor3 && !vertexColor4)))\n    {\n        stack.Error(\"number of vertex color components must be 0, 1 or 4\");\n    }\n\n    auto spriteAsset = static_pointer_cast<Asset::SpriteAsset>(asset);\n\n\n    BlendMode m(blend);\n    spriteAsset->SetDefaultBlendMode(m);\n\n\n    array<Render::ColorRGBA32, 4> vertexColor;\n    if (vertexColor1 && vertexColor2 && vertexColor3 && vertexColor4)\n    {\n        assert(*vertexColor1 && *vertexColor2 && *vertexColor3 && *vertexColor4);\n        vertexColor[0] = *(*vertexColor1);\n        vertexColor[1] = *(*vertexColor2);\n        vertexColor[2] = *(*vertexColor3);\n        vertexColor[3] = *(*vertexColor4);\n        spriteAsset->SetDefaultBlendColor(vertexColor);\n    }\n    else if (vertexColor1)\n    {\n        assert(*vertexColor1);\n        vertexColor[0] = *(*vertexColor1);\n        vertexColor[1] = *(*vertexColor1);\n        vertexColor[2] = *(*vertexColor1);\n        vertexColor[3] = *(*vertexColor1);\n        spriteAsset->SetDefaultBlendColor(vertexColor);\n    }\n}\n\nvoid AssetManagerModule::SetImageCenter(LuaStack& stack, const char* name, double x, double y)\n{\n    auto assetPools = detail::GetGlobalApp().GetAssetPools();\n\n    auto asset = assetPools->FindAsset(AssetTypes::Image, name);\n    if (!asset)\n        stack.Error(\"image '%s' not found.\", name);\n    assert(asset);\n    assert(asset->GetAssetTypeId() == Asset::SpriteAsset::GetAssetTypeIdStatic());\n\n    auto spriteAsset = static_pointer_cast<Asset::SpriteAsset>(asset);\n    spriteAsset->SetAnchor({x, y});\n}\n\nvoid AssetManagerModule::SetImageScale(double factor)\n{\n    LSTG_LOG_DEPRECATED(AssetManagerModule, SetImageScale);\n}\n\nvoid AssetManagerModule::LoadAnimation(LuaStack& stack, const char* name, const char* textureName, double x, double y, double w, double h,\n    int32_t n, int32_t m, int32_t interval, std::optional<double> a, std::optional<double> b, std::optional<bool> rect)\n{\n    GET_CURRENT_POOL;\n\n    auto assetSystem = detail::GetGlobalApp().GetSubsystem<AssetSystem>();\n    assert(assetSystem);\n\n\n    auto fullName = MakeFullAssetName(AssetTypes::Animation, name);\n    if (currentAssetPool->ContainsAsset(fullName))\n    {\n        LSTG_LOG_WARN_CAT(AssetManagerModule, \"animation \\\"{}\\\" is already loaded\", name);\n        return;\n    }\n\n\n    nlohmann::json args {\n        {\"texture\", MakeFullAssetName(AssetTypes::Texture, textureName)},\n        {\"left\", x},\n        {\"top\", y},\n        {\"frameWidth\", w},\n        {\"frameHeight\", h},\n        {\"row\", m},\n        {\"column\", n},\n        {\"interval\", interval},\n        {\"colliderHalfSizeX\", a ? *a : 0.},\n        {\"colliderHalfSizeY\", b ? *b : (a ? *a : 0.)},\n        {\"colliderIsRect\", rect && *rect},\n    };\n\n\n    auto ret = assetSystem->CreateAsset<Asset::SpriteSequenceAsset>(currentAssetPool, fullName, args);\n    if (!ret)\n        stack.Error(\"load animation \\\"%s\\\" fail: %s\", name, ret.GetError().message().c_str());\n}\n\nvoid AssetManagerModule::SetAnimationState(LuaStack& stack, const char* name, const char* blend, std::optional<LSTGColor*> vertexColor1,\n    std::optional<LSTGColor*> vertexColor2, std::optional<LSTGColor*> vertexColor3, std::optional<LSTGColor*> vertexColor4)\n{\n    auto assetPools = detail::GetGlobalApp().GetAssetPools();\n\n    auto asset = assetPools->FindAsset(AssetTypes::Animation, name);\n    if (!asset)\n        stack.Error(\"animation '%s' not found.\", name);\n    assert(asset);\n    assert(asset->GetAssetTypeId() == Asset::SpriteSequenceAsset::GetAssetTypeIdStatic());\n\n    if (!((vertexColor1 && vertexColor2 && vertexColor3 && vertexColor4) ||\n        (!vertexColor1 && !vertexColor2 && !vertexColor3 && !vertexColor4) ||\n        (vertexColor1 && !vertexColor2 && !vertexColor3 && !vertexColor4)))\n    {\n        stack.Error(\"number of vertex color components must be 0, 1 or 4\");\n    }\n\n    auto spriteSequenceAsset = static_pointer_cast<Asset::SpriteSequenceAsset>(asset);\n\n\n    BlendMode m(blend);\n    spriteSequenceAsset->SetDefaultBlendMode(m);\n\n\n    array<Render::ColorRGBA32, 4> vertexColor;\n    if (vertexColor1 && vertexColor2 && vertexColor3 && vertexColor4)\n    {\n        assert(*vertexColor1 && *vertexColor2 && *vertexColor3 && *vertexColor4);\n        vertexColor[0] = *(*vertexColor1);\n        vertexColor[1] = *(*vertexColor2);\n        vertexColor[2] = *(*vertexColor3);\n        vertexColor[3] = *(*vertexColor4);\n        spriteSequenceAsset->SetDefaultBlendColor(vertexColor);\n    }\n    else if (vertexColor1)\n    {\n        assert(*vertexColor1);\n        vertexColor[0] = *(*vertexColor1);\n        vertexColor[1] = *(*vertexColor1);\n        vertexColor[2] = *(*vertexColor1);\n        vertexColor[3] = *(*vertexColor1);\n        spriteSequenceAsset->SetDefaultBlendColor(vertexColor);\n    }\n}\n\nvoid AssetManagerModule::SetAnimationCenter(LuaStack& stack, const char* name, double x, double y)\n{\n    auto assetPools = detail::GetGlobalApp().GetAssetPools();\n\n    auto asset = assetPools->FindAsset(AssetTypes::Animation, name);\n    if (!asset)\n        stack.Error(\"animation '%s' not found.\", name);\n    assert(asset);\n    assert(asset->GetAssetTypeId() == Asset::SpriteSequenceAsset::GetAssetTypeIdStatic());\n\n    auto spriteSequenceAsset = static_pointer_cast<Asset::SpriteSequenceAsset>(asset);\n    spriteSequenceAsset->SetAnchor({x, y});\n}\n\nvoid AssetManagerModule::LoadParticle(LuaStack& stack, const char* name, const char* path, const char* imgName, std::optional<double> a,\n    std::optional<double> b, std::optional<bool> rect)\n{\n    GET_CURRENT_POOL;\n\n    auto assetSystem = detail::GetGlobalApp().GetSubsystem<AssetSystem>();\n    assert(assetSystem);\n\n\n    auto fullName = MakeFullAssetName(AssetTypes::Particle, name);\n    if (currentAssetPool->ContainsAsset(fullName))\n    {\n        LSTG_LOG_WARN_CAT(AssetManagerModule, \"Particle \\\"{}\\\" is already loaded\", name);\n        return;\n    }\n\n\n    nlohmann::json args {\n        {\"path\", detail::ResolveAbsoluteOrRelativePath(stack, path)},\n        {\"sprite\", MakeFullAssetName(AssetTypes::Image, imgName)},\n        {\"colliderHalfSizeX\", a ? *a : 0.},\n        {\"colliderHalfSizeY\", b ? *b : (a ? *a : 0.)},\n        {\"colliderIsRect\", rect && *rect},\n        {\"emitDirectionOverride\", static_cast<int32_t>(Subsystem::Render::Drawing2D::ParticleEmitDirection::OppositeToEmitter)},\n    };\n\n\n    auto ret = assetSystem->CreateAsset<Asset::HgeParticleAsset>(currentAssetPool, fullName, args);\n    if (!ret)\n        stack.Error(\"load particle \\\"%s\\\" fail: %s\", name, ret.GetError().message().c_str());\n}\n\nvoid AssetManagerModule::LoadTexturedFont(LuaStack& stack, const char* name, const char* path, std::optional<bool> mipmap )\n{\n    GET_CURRENT_POOL;\n\n    auto assetSystem = detail::GetGlobalApp().GetSubsystem<AssetSystem>();\n    assert(assetSystem);\n\n\n    auto fullName = MakeFullAssetName(AssetTypes::TexturedFont, name);\n    if (currentAssetPool->ContainsAsset(fullName))\n    {\n        LSTG_LOG_WARN_CAT(AssetManagerModule, \"Textured font \\\"{}\\\" is already loaded\", name);\n        return;\n    }\n\n\n    nlohmann::json args {\n        {\"path\", detail::ResolveAbsoluteOrRelativePath(stack, path)},\n        {\"mipmaps\", mipmap ? *mipmap : true},\n    };\n\n\n    auto ret = assetSystem->CreateAsset<Asset::HgeFontAsset>(currentAssetPool, fullName, args);\n    if (!ret)\n        stack.Error(\"load textured font \\\"%s\\\" fail: %s\", name, ret.GetError().message().c_str());\n}\n\nvoid AssetManagerModule::SetTexturedFontState(LuaStack& stack, const char* name, const char* blend, std::optional<LSTGColor*> color)\n{\n    auto assetPools = detail::GetGlobalApp().GetAssetPools();\n\n    auto asset = assetPools->FindAsset(AssetTypes::TexturedFont, name);\n    if (!asset)\n        stack.Error(\"textured font '%s' not found.\", name);\n    assert(asset);\n    assert(asset->GetAssetTypeId() == Asset::HgeFontAsset::GetAssetTypeIdStatic());\n\n    auto hgeFontAsset = static_pointer_cast<Asset::HgeFontAsset>(asset);\n\n\n    BlendMode m(blend);\n    hgeFontAsset->SetDefaultBlendMode(m);\n\n\n    if (color)\n        hgeFontAsset->SetDefaultBlendColor(**color);\n}\n\nvoid AssetManagerModule::SetTexturedFontState2()\n{\n    LSTG_LOG_DEPRECATED(AssetManagerModule, SetFontState2);\n}\n\nvoid AssetManagerModule::LoadTrueTypeFont(LuaStack& stack, const char* name, const char* path, double width, std::optional<double> height)\n{\n    GET_CURRENT_POOL;\n\n    auto assetSystem = detail::GetGlobalApp().GetSubsystem<AssetSystem>();\n    assert(assetSystem);\n\n\n    auto fullName = MakeFullAssetName(AssetTypes::TrueTypeFont, name);\n    if (currentAssetPool->ContainsAsset(fullName))\n    {\n        LSTG_LOG_WARN_CAT(AssetManagerModule, \"TrueType font \\\"{}\\\" is already loaded\", name);\n        return;\n    }\n\n\n    auto fontSize = static_cast<uint32_t>(width);\n    if (height)\n    {\n        if (width == 0)\n            fontSize = static_cast<uint32_t>(*height);\n        else if (static_cast<uint32_t>(*height) != width)\n            LSTG_LOG_WARN_CAT(AssetManagerModule, \"Create ttf font with height is deprecated\", name);\n    }\n    fontSize = clamp(fontSize, 1u, 100u);\n\n    nlohmann::json args {\n        {\"path\", detail::ResolveAbsoluteOrRelativePath(stack, path)},\n        {\"size\", fontSize},\n    };\n\n\n    auto ret = assetSystem->CreateAsset<Asset::TrueTypeFontAsset>(currentAssetPool, fullName, args);\n    if (!ret)\n        stack.Error(\"load ttf font \\\"%s\\\" fail: %s\", name, ret.GetError().message().c_str());\n}\n\nvoid AssetManagerModule::RegTTF()\n{\n    LSTG_LOG_DEPRECATED(AssetManagerModule, RegTTF);\n}\n\nvoid AssetManagerModule::LoadSound(LuaStack& stack, const char* name, const char* path)\n{\n    GET_CURRENT_POOL;\n\n    auto assetSystem = detail::GetGlobalApp().GetSubsystem<AssetSystem>();\n    assert(assetSystem);\n\n\n    auto fullName = MakeFullAssetName(AssetTypes::Sound, name);\n    if (currentAssetPool->ContainsAsset(fullName))\n    {\n        LSTG_LOG_WARN_CAT(AssetManagerModule, \"Sound \\\"{}\\\" is already loaded\", name);\n        return;\n    }\n\n\n    nlohmann::json args {\n        {\"path\", detail::ResolveAbsoluteOrRelativePath(stack, path)},\n    };\n\n\n    auto ret = assetSystem->CreateAsset<Asset::SoundAsset>(currentAssetPool, fullName, args);\n    if (!ret)\n        stack.Error(\"load sound \\\"%s\\\" from \\\"%s\\\" fail: %s\", name, path, ret.GetError().message().c_str());\n}\n\nvoid AssetManagerModule::LoadMusic(LuaStack& stack, const char* name, const char* path, double end, double loop)\n{\n    GET_CURRENT_POOL;\n\n    auto assetSystem = detail::GetGlobalApp().GetSubsystem<AssetSystem>();\n    assert(assetSystem);\n\n\n    auto fullName = MakeFullAssetName(AssetTypes::Music, name);\n    if (currentAssetPool->ContainsAsset(fullName))\n    {\n        LSTG_LOG_WARN_CAT(AssetManagerModule, \"Music \\\"{}\\\" is already loaded\", name);\n        return;\n    }\n\n\n    double loopStart = std::max(0., end - loop);\n    nlohmann::json args {\n        {\"path\", detail::ResolveAbsoluteOrRelativePath(stack, path)},\n        {\"loopBeginMs\", static_cast<uint32_t>(loopStart * 1000)},\n        {\"loopEndMs\", static_cast<uint32_t>(end * 1000)},\n    };\n\n\n    auto ret = assetSystem->CreateAsset<Asset::MusicAsset>(currentAssetPool, fullName, args);\n    if (!ret)\n        stack.Error(\"load music \\\"%s\\\" from \\\"%s\\\" fail: %s\", name, path, ret.GetError().message().c_str());\n}\n\nvoid AssetManagerModule::LoadFX(LuaStack& stack, const char* name, const char* path)\n{\n    GET_CURRENT_POOL;\n\n    auto assetSystem = detail::GetGlobalApp().GetSubsystem<AssetSystem>();\n    assert(assetSystem);\n\n\n    auto fullName = MakeFullAssetName(AssetTypes::Effect, name);\n    if (currentAssetPool->ContainsAsset(fullName))\n    {\n        LSTG_LOG_WARN_CAT(AssetManagerModule, \"Effect \\\"{}\\\" is already loaded\", name);\n        return;\n    }\n\n\n    nlohmann::json args {\n        {\"path\", detail::ResolveAbsoluteOrRelativePath(stack, path)},\n    };\n\n\n    auto ret = assetSystem->CreateAsset<Asset::EffectAsset>(currentAssetPool, fullName, args);\n    if (!ret)\n        stack.Error(\"load fx \\\"%s\\\" fail: %s\", name, ret.GetError().message().c_str());\n}\n\nvoid AssetManagerModule::CreateRenderTarget(LuaStack& stack, const char* name)\n{\n    GET_CURRENT_POOL;\n\n    auto assetSystem = detail::GetGlobalApp().GetSubsystem<AssetSystem>();\n    assert(assetSystem);\n\n\n    auto fullName = MakeFullAssetName(AssetTypes::Texture, name);\n    if (currentAssetPool->ContainsAsset(fullName))\n    {\n        LSTG_LOG_WARN_CAT(AssetManagerModule, \"Texture \\\"{}\\\" is already loaded\", name);\n        return;\n    }\n\n\n    auto ret = assetSystem->CreateAsset<Asset::TextureAsset>(currentAssetPool, fullName, nlohmann::json {\n        {\"rt\", true},\n    });\n    if (!ret)\n        stack.Error(\"create render target fail: %s\", ret.GetError().message().c_str());\n}\n\nbool AssetManagerModule::IsRenderTarget(LuaStack& stack, const char* name)\n{\n    auto assetPools = detail::GetGlobalApp().GetAssetPools();\n\n    auto asset = assetPools->FindAsset(AssetTypes::Texture, name);\n    if (!asset)\n        stack.Error(\"render target '%s' not found.\", name);\n    assert(asset);\n    assert(asset->GetAssetTypeId() == Asset::TextureAsset::GetAssetTypeIdStatic());\n\n    auto tex = static_pointer_cast<Asset::TextureAsset>(asset);\n    return tex->IsRenderTarget();\n}\n\n'LuaSTGPlus/include/lstg/v2/Asset/TextureAsset.hpp'\n:\n#pragma once\n#include <optional>\n#include <lstg/Core/Subsystem/Asset/BasicTexture2DAsset.hpp>\n#include <lstg/Core/Subsystem/Render/Camera.hpp>\n#include <lstg/Core/Subsystem/Render/Drawing2D/Texture2D.hpp>\n\nnamespace lstg::v2::Asset\n{\n    class TextureAssetLoader;\n\n\n    class TextureAsset :\n        public Subsystem::Asset::Asset\n    {\n        friend class TextureAssetLoader;\n\n    public:\n        [[nodiscard]] static Subsystem::Asset::AssetTypeId GetAssetTypeIdStatic() noexcept;\n\n    public:\n        TextureAsset(std::string name, Subsystem::Asset::BasicTexture2DAssetPtr textureAsset, float pixelPerUnit);\n        TextureAsset(std::string name, Subsystem::Render::Camera::OutputViews view, float pixelPerUnit);\n        ~TextureAsset();\n\n    public:\n\n        [[nodiscard]] bool IsRenderTarget() const noexcept;\n\n\n        [[nodiscard]] const Subsystem::Asset::BasicTexture2DAssetPtr& GetBasicTextureAsset() const noexcept;\n\n\n        [[nodiscard]] Subsystem::Render::Camera::OutputViews& GetOutputViews() noexcept;\n\n\n        [[nodiscard]] const Subsystem::Render::Drawing2D::Texture2D& GetDrawingTexture() const noexcept { return m_stDrawingTexture; }\n\n\n        [[nodiscard]] float GetPixelPerUnit() const noexcept { return m_stDrawingTexture.GetPixelPerUnit(); }\n\n\n        [[nodiscard]] double GetWidth() const noexcept;\n\n\n        [[nodiscard]] double GetHeight() const noexcept;\n\n    protected:\n        [[nodiscard]] Subsystem::Asset::AssetTypeId GetAssetTypeId() const noexcept override;\n        void OnRemove() noexcept override;\n\n    private:\n        void FreeResource() noexcept;\n        void UpdateResource() noexcept;\n\n    private:\n\n        std::variant<Subsystem::Asset::BasicTexture2DAssetPtr, Subsystem::Render::Camera::OutputViews> m_stUnderlay;\n        Subsystem::Render::Drawing2D::Texture2D m_stDrawingTexture;\n    };\n\n    using TextureAssetPtr = std::shared_ptr<TextureAsset>;\n}\n",
        "gt": [
            "'LuaSTGPlus/include/lstg/Core/Subsystem/Asset/BasicTexture2DAsset.hpp'",
            "'LuaSTGPlus/include/lstg/v2/Asset/TextureAsset.hpp'",
            "'LuaSTGPlus/src/v2/Bridge/AssetManagerModule.cpp'"
        ]
    },
    {
        "files": [
            "'dynamic_task_allocation/src/task_allocation/include/subtargets.h'",
            "'dynamic_task_allocation/src/task_allocation/include/task_allocation.h'",
            "'dynamic_task_allocation/src/task_allocation/src/main.cpp'",
            "'dynamic_task_allocation/src/allocation_common/include/Common.hpp'",
            "'dynamic_task_allocation/src/task_allocation/include/behaviour.h'"
        ],
        "content": "'dynamic_task_allocation/src/task_allocation/include/subtargets.h'\n:#ifndef SUBTARGETS_H\n#define SUBTARGETS_H\n\n#include \"Common.hpp\"\n\nclass Subtargets\n{\npublic:\n        Subtargets();\n        int\n        Min_num(int n,double *q);\n        double\n        Min(int n,double *q);\n        int\n        Max_num(int n,double *q);\n        double\n        Max(int n,double *q);\n        void\n        subtarget(DPoint target, DPoint robot_pos_);\n\npublic:\n        std::vector<DPoint> *Obstacles_;\n        DPoint subtargets_pos_;\n        DPoint robot_pos_;\n        DPoint ball_pos_;\n};\n#endif\n\n\n'dynamic_task_allocation/src/task_allocation/include/task_allocation.h'\n:#ifndef TASK_ALLOCATION_H\n#define TASK_ALLOCATION_H\n\n#include <ros/ros.h>\n#include <Core.hpp>\n#include <behaviour.h>\n#include <allocation_common/gazebo2world_info.h>\n#include <allocation_common/robot2gazebo_info.h>\n#include <allocation_common/terminal2robot_info.h>\n#include <allocation_common/allocation2terminal_info.h>\n#include <allocation_common/GetAction.h>\n#include <allocation_common/ReturnReward.h>\n#include <geometry_msgs/Point.h>\n#include <dynamic_reconfigure/server.h>\n#include <dqn_ros/reward_cfgConfig.h>\n\nclass Task_Allocation\n{\npublic:\n    Task_Allocation(int argc, char **argv);\n    ~Task_Allocation();\n    void update_gazebo_world(const allocation_common::gazebo2world_info::ConstPtr & _msg);\n    void update_terminal_info(const allocation_common::terminal2robot_info::ConstPtr & _msg);\n    void loopControl(const ros::TimerEvent& event);\n    void setVelCommond();\n    void pubAllocation_info();\n    void pubDrawing_info();\n    void pauseAllocation();\n    void stopAllocation();\n    void ParamChanged(dqn_ros::reward_cfgConfig &config, uint32_t level);\n\n\n    bool try2explore_();\n    bool try2hit_();\n    bool choose2hitOrexplore_();\n\n    bool which2hit_();\n    bool which2explore_();\n\n    bool choose_task_();\n    bool return_rewrad_(char causes, DPoint task_pos=DPoint(0,0));\npublic:\n    Robot_info my_robot_;\n    std::vector<Robot_info> all_robots_;\n    std::vector<Task_info>  all_tasks_;\n    std::vector<DPoint>     obstacles_;\n\n    Behaviour* my_behaviour_;\n    Terminal2Robots_info terminal_info_;\n\n    int num_task_valid_;\n    int num_target_valid_;\n    int num_task_unallocated_;\n    int num_target_unallocated_;\n\n    bool is_world_update_;\n    bool bid_new_task_;\n    bool bid_new_target_;\n    bool is_target_completed;\n    bool is_task_explored;\n    bool is_target_dropped;\n    bool is_task_dropped;\n    bool is_all_completed;\n    DPoint start_point_;\n\n    float Reward_I;\n    float Reward_D;\n    float Reward_C;\n    float Reward_E;\n    float Reward_R;\n\nprivate:\n    dynamic_reconfigure::Server<dqn_ros::reward_cfgConfig> server;\n    dynamic_reconfigure::Server<dqn_ros::reward_cfgConfig>::CallbackType f;\n\n    ros::ServiceClient get_action_client_;\n    ros::ServiceClient return_reward_client_;\n    ros::Subscriber    gazebo2world_sub_;\n    ros::Subscriber    terminal2robot_sub_;\n    ros::Publisher     robot2gazebo_pub_;\n    ros::Publisher     allocation2terminal_pub_;\n    ros::Publisher     robot2task_pub_;\n    ros::Publisher     drawing_pub_;\n    ros::Timer         allocation_timer_;\n    ros::NodeHandle*   nh_;\n};\n\n#endif\n\n'dynamic_task_allocation/src/task_allocation/src/main.cpp'\n:#include \"task_allocation.h\"\n\nint main(int argc, char **argv)\n{\n    ros::init(argc,argv,\"task_allocation_node\");\n    ros::Time::init();\n    Task_Allocation Task_Allocation(argc,argv);\n    ros::spin();\n    return 0;\n}\n\n\n'dynamic_task_allocation/src/allocation_common/include/Common.hpp'\n:#ifndef COMMON_H\n#define COMMON_H\n\n#include <Core.hpp>\n\nusing namespace std;\n\ninline float\nangularnorm(float _x)\n{\nwhile (_x > SINGLEPI_CONSTANT)\n    _x -= DOUBLEPI_CONSTANT;\nwhile (_x < -SINGLEPI_CONSTANT)\n    _x += DOUBLEPI_CONSTANT;\nreturn _x;\n}\n\ninline DPoint\npglobal2rel(DPoint _gpos, float _ori, DPoint _tar_gpos)\n{\n\n  DPoint pos = _tar_gpos - _gpos;\n\n  return DPoint(pos.x_*cos(_ori)+pos.y_*sin(_ori),\n                  -pos.x_*sin(_ori)+pos.y_*cos(_ori));\n\n}\n\ninline DPoint\nprel2global(DPoint _gpos, float _ori, DPoint _rel_pos)\n{\n\n    return  DPoint(_gpos.x_+_rel_pos.x_*cos(_ori)-_rel_pos.y_*sin(_ori),\n                                        _gpos.y_+_rel_pos.x_*sin(_ori)+_rel_pos.y_*cos(_ori));\n\n}\n\ninline float\nthetaof2p(DPoint begin, DPoint end)\n{\n   return  atan2(end.y_ - begin.y_, end.x_ - begin.x_);\n}\n\ninline float\nthetaof2p2(DPoint begin, DPoint end)\n{\n    return atan2(end.x_ -  begin.x_, end.y_ - begin.y_);\n}\n\ninline float\nthetaofpo(DPoint _pos)\n{\n   return atan2(_pos.y_,_pos.x_);\n}\n\n\ninline DPoint\nvglobal2rel(DPoint _v, float _ori)\n{\n\n    return  DPoint(_v.x_*cos(_ori)+_v.y_*sin(_ori),\n                                        -_v.x_*sin(_ori)+_v.y_*cos(_ori));\n\n}\n\n\ninline DPoint\nvrel2global(DPoint _v, float _ori)\n{\n    return  DPoint(_v.x_*cos(_ori)-_v.y_*sin(_ori),\n                                        _v.x_*sin(_ori)+_v.y_*cos(_ori));\n}\n\ninline float\nsign(float _x)\n{\n    if(_x >= 0.00)\n        return  1.0;\n    else\n        return -1.0;\n\n}\n\ninline DPoint\nPointOfLine(DPoint P1, DPoint P2, double D)\n{\n    double theta = atan2(P2.y_-P1.y_,P2.x_-P1.x_);\n    return DPoint(P1.x_+cos(theta)*D,P1.y_+sin(theta)*D);\n}\n\ninline DPoint\nRotOfPoint(DPoint P1,DPoint P2,double Ang,bool Clockwise)\n{\n    double theta = atan2(P1.y_-P2.y_,P1.x_-P2.x_);\n    double dis= P1.distance(P2);\n    if(Clockwise)\n        theta=theta-Ang;\n    else\n        theta=theta+Ang;\n    return DPoint(P2.x_+cos(theta)*dis,P2.y_+sin(theta)*dis);\n}\n\n\ninline double\nDis_2P(DPoint P1, DPoint P2)\n{\n    return sqrt((P1.x_-P2.x_)*(P1.x_-P2.x_)+(P1.y_-P2.y_)*(P1.y_-P2.y_));\n}\n\n\n\ninline DPoint\nVector_2P(DPoint P1,DPoint P2)\n{\n    return DPoint((P2.x_-P1.x_),(P2.y_-P1.y_));\n}\n\n\n\ninline double\nDis_P2Line(DPoint P1, DPoint P2, DPoint P)\n{\n    return ((P2.y_-P1.y_)*P.x_-(P2.x_-P1.x_)*P.y_+P2.x_*P1.y_-P1.x_*P2.y_)/Dis_2P(P1,P2);\n}\n\n\ninline double\nDis_P2Line(double A, double B, double C, DPoint P)\n{\n    return (A*P.x_+B*P.y_+C)/sqrt(A*A+B*B);\n}\n\n\ninline double\nDis_P2O(DPoint P)\n{\n    return sqrt(P.x_*P.x_+P.y_*P.y_);\n}\n\ninline DPoint\nTangentPoint(DPoint Center, double radius, bool Left)\n{\n    double theta=atan2(Center.y_,Center.x_);\n    double dis=sqrt(Center.x_*Center.x_+Center.y_*Center.y_);\n    double theta_e;\n    if(dis>radius)\n    {\n        theta_e=asin(radius/dis);\n        dis=dis*cos(theta_e);\n    }\n    else\n    {\n        theta_e=SINGLEPI_CONSTANT/2;\n        dis=50;\n    }\n    if(Left) theta=theta+theta_e;\n    else     theta=theta-theta_e;\n    return DPoint(dis*cos(theta),dis*sin(theta));\n}\n\n\ninline DPoint\nTangentPoint(DPoint Point,DPoint Center, double radius, bool Left)\n{\n\n    double theta=atan2(Center.y_-Point.y_,Center.x_-Point.x_);\n    double dis=Dis_2P(Center,Point);\n    double theta_e;\n    if(dis>radius)\n    {\n        theta_e=asin(radius/dis);\n        dis=dis*cos(theta_e);\n    }\n    else\n    {\n        theta_e=SINGLEPI_CONSTANT/2;\n        dis=50;\n    }\n    if(Left) theta=theta+theta_e;\n    else     theta=theta-theta_e;\n    return DPoint(Point.x_+dis*cos(theta),Point.y_+dis*sin(theta));\n\n\n}\n\ninline double\nTangentAngle(DPoint Center, double radius, bool Left)\n{\n    double theta=atan2(Center.y_,Center.x_);\n    double dis=sqrt(Center.x_*Center.x_+Center.y_*Center.y_);\n    double theta_e;\n    if(dis>radius)\n        theta_e=asin(radius/dis);\n    else\n        theta_e=SINGLEPI_CONSTANT/2;\n    if(Left) theta=theta+theta_e;\n    else     theta=theta-theta_e;\n    if(theta>SINGLEPI_CONSTANT)   theta=theta-2*SINGLEPI_CONSTANT;\n    if(theta<-SINGLEPI_CONSTANT)  theta=theta+2*SINGLEPI_CONSTANT;\n    return theta;\n}\n\n\ninline double\nTangentAngle(DPoint Point,DPoint Center, double radius, bool Left)\n{\n    double theta=atan2(Center.y_-Point.y_,Center.x_-Point.x_);\n    double dis=Dis_2P(Center,Point);\n    double theta_e;\n    if(dis>radius)\n        theta_e=asin(radius/dis);\n    else\n        theta_e=SINGLEPI_CONSTANT/2;\n    if(Left) theta=theta+theta_e;\n    else     theta=theta-theta_e;\n    if(theta>SINGLEPI_CONSTANT)   theta=theta-2*SINGLEPI_CONSTANT;\n    if(theta<-SINGLEPI_CONSTANT)  theta=theta+2*SINGLEPI_CONSTANT;\n    return theta;\n}\n\n\n\ninline DPoint\nMidPointOf2Point(DPoint PointA,DPoint PointB)\n{\n\n    DPoint midpoint=DPoint((PointA.x_+PointB.x_)/2,(PointA.y_+PointB.y_)/2);\n    return midpoint;\n}\n\n\ninline bool\nVerticalPointOf2Point(DPoint &vertical, DPoint p, DPoint p1,DPoint p2)\n{\n    bool  flg = true;\n    double k =0;\n    double b = 0;\n\n    if(p2.x_ - p1.x_ != 0)\n    {\n        k =  (p2.y_ - p1.y_)/(p2.x_ - p1.x_);\n        b =  p2.y_ -  k*p2.x_;\n        double   p2p1x = p2.x_-p1.x_;\n        double   p2p1y = p2.y_-p1.y_;\n\n        vertical.x_ =(p.x_*p2p1x+(p.y_-b)*p2p1y)/(p2p1x+k*p2p1y);\n        vertical.y_ =  k*vertical.x_ + b;\n        double  s1 = Dis_2P(p1,vertical);\n        double  s2 = Dis_2P(p2,vertical);\n        double  s = Dis_2P(p1,p2);\n        if(   abs(s1+s2-s) <=1.0 )\n        {\n            flg = true;\n        }\n        else\n        {\n            flg = false;\n        }\n    }\n    else\n    {\n        vertical.x_ = p2.x_;\n        vertical.y_ =  p.y_;\n        if( (vertical.y_-p2.y_)*(vertical.y_-p1.y_) <= 0 )\n        {\n            flg = true;\n        }\n        else\n            flg =  false;\n    }\n\n    return flg;\n}\n\ninline int\nFactorial(int n)\n{\n    int rtvl =  1;\n    while(n != 0 )\n    {\n        rtvl = rtvl*n;\n        n -=1;\n    }\n    return rtvl;\n\n}\n\ninline bool\nMatrixInverse(double * M)\n{\n     double m11=*M;\n     double m12=*(M+1);\n     double m21=*(M+2);\n     double m22=*(M+3);\n     double value=m11*m22-m21*m12;\n     if(value!=0)\n     {\n         *M    = m22/value;\n         *(M+1)=-m12/value;\n         *(M+2)=-m21/value;\n         *(M+2)= m11/value;\n         return true;\n     }\n     else\n         return false;\n}\n\ninline void\nMatrixMultify(double A[4][4], double B[4][4], double *C)\n{\n    for(int i=0;i<4;i++)\n    {\n        for(int j=0;j<4;j++)\n        {\n            *(C+4*i+j)=0;\n            for(int l=0;l<4;l++)\n                *(C+4*i+j)+=A[i][l]*B[l][j];\n        }\n    }\n\n}\n\ninline void\nMatrixAdd(double A[4][4], double B[4][4], double *C)\n{\n    for(int i=0;i<4;i++)\n    {\n        for(int j=0;j<4;j++)\n        {\n            *(C+4*i+j)=A[i][j]+B[i][j];\n        }\n    }\n}\n\n\ninline void\nMatrixTrans(double A[4][4], double *B)\n{\n    for(int i=0;i<4;i++)\n    {\n        for(int j=0;j<4;j++)\n        {\n            *(B+4*j+i)=A[i][j];\n        }\n    }\n\n}\n\ninline double\nThetaOf2Vector(DPoint V1, DPoint V2)\n{\n\n    if(sqrt(V1.x_*V1.x_+V1.y_*V1.y_)*sqrt(V2.x_*V2.x_+V2.y_*V2.y_)==0)\n        return SINGLEPI_CONSTANT;\n    else\n        return acos((V1.x_*V2.x_+V1.y_*V2.y_)/(sqrt(V1.x_*V1.x_+V1.y_*V1.y_)*sqrt(V2.x_*V2.x_+V2.y_*V2.y_)));\n}\n\ninline int\nDirOfPoint2Line(DPoint P, DPoint P1, DPoint P2)\n{\n    double theta=atan2(P.y_-P1.y_,P.x_-P1.x_)-atan2(P2.y_-P1.y_,P2.x_-P1.x_);\n    if(theta>SINGLEPI_CONSTANT) theta=theta-2*SINGLEPI_CONSTANT;\n    if(theta<=-SINGLEPI_CONSTANT) theta=theta+2*SINGLEPI_CONSTANT;\n    if(theta>=0)\n        return -1;\n    else\n        return 1;\n\n}\n\ninline double\nAngleOf2Vector(DPoint P1, DPoint P2)\n{\n    double theta=atan2(P2.y_,P2.x_)-atan2(P1.y_,P1.x_);\n    if(theta>SINGLEPI_CONSTANT) theta=theta-2*SINGLEPI_CONSTANT;\n    if(theta<=-SINGLEPI_CONSTANT) theta=theta+2*SINGLEPI_CONSTANT;\n    return theta;\n}\n\ninline DPoint\nPointOfVertical(DPoint p1, DPoint p2, double x, double y)\n{\n    double len=sqrt(x*x+y*y);\n    double t1=atan2(p2.y_-p1.y_,p2.x_-p1.x_);\n    double t2=atan2(y,x);\n    double t=t1+t2;\n    return DPoint(len*cos(t)+p1.x_,len*sin(t)+p1.y_);\n\n}\n\n\n\ninline bool\nCheckInAngle(double la, double ra, double ta, bool left)\n{\n    if(left)\n    {\n        if(la>ra)\n        {\n            if(la>ta && ta>ra )\n                return false;\n            else\n                return true;\n        }\n        else\n        {\n            if(ta<=ra)\n            {\n                if(la>ta)\n                    return false;\n                else\n                    return true;\n            }\n            else\n                return false;\n        }\n    }\n    else\n    {\n        if(la>ra)\n        {\n            if(la>ta && ta>ra )\n                return false;\n            else\n                return true;\n        }\n        else\n        {\n            if(ta<=ra)\n            {\n                if(la>ta)\n                    return false;\n                else\n                    return true;\n            }\n            else\n                return true;\n        }\n    }\n}\n\ninline void\nClearUpAngle(double &angle)\n{\n    if(angle>SINGLEPI_CONSTANT)\n        angle-=2*SINGLEPI_CONSTANT;\n    if(angle<=-SINGLEPI_CONSTANT)\n        angle+=2*SINGLEPI_CONSTANT;\n}\n\ninline DPoint\nCoorInARef(DPoint P1, DPoint P2, DPoint O, DPoint P)\n{\n    DPoint temp=P-O;\n    double theta=atan2(P2.y_-P1.y_,P2.x_-P1.x_);\n    return DPoint(temp.x_*cos(theta)+temp.y_*sin(theta),temp.y_*cos(theta)-temp.x_*sin(theta));\n}\n\ninline DPoint\nConCoorInARef(DPoint P1, DPoint P2, DPoint O, DPoint P)\n{\n    double theta=atan2(P2.y_-P1.y_,P2.x_-P1.x_);\n    DPoint temp=DPoint(P.x_*cos(theta)-P.y_*sin(theta),P.x_*sin(theta)+P.y_*cos(theta));\n    return (temp+O);\n\n}\ninline bool\nRelCorIsValid(DPoint P)\n{\n    if(P.x_!=0 || P.y_!=0)\n        return true;\n    else\n        return false;\n}\n\n\ninline DPoint\nP2RotateWithP1(DPoint P1, DPoint P2, double theta)\n{\n  DPoint P3;\n  double dx=P2.x_-P1.x_;\n  double dy=P2.y_-P1.y_;\n    P3.x_=P1.x_+(dx*cos(theta)-dy*sin(theta));\n    P3.y_=P1.y_+(dx*sin(theta)+dy*cos(theta));\n    return P3;\n}\n\ninline bool\nVectorEqu(DPoint P1, DPoint P2)\n{\n    double e=LOCATION_ERROR*4;\n    double dis=(P1.x_-P2.x_)*(P1.x_-P2.x_)+(P1.y_-P2.y_)*(P1.y_-P2.y_);\n    if(dis>e*e)\n        return 0;\n    else\n        return 1;\n}\n\ninline bool VectorEqu(DPoint P1, DPoint P2,double e)\n{\n    double dis=(P1.x_-P2.x_)*(P1.x_-P2.x_)+(P1.y_-P2.y_)*(P1.y_-P2.y_);\n    if(dis>e*e)\n        return 0;\n    else\n        return 1;\n}\n\ninline void ExchangeSort(float* pData,char Count,char order[])\n{\n    int iTemp,otemp;\n    for(int i=0;i<Count-1;i++)\n    {\n        for(int j=i+1;j<Count;j++)\n        {\n            if(pData[j]>pData[i])\n            {\n                iTemp = pData[i];\n                pData[i] = pData[j];\n                pData[j] = iTemp;\n\n                otemp=order[i];\n                order[i]=order[j];\n                order[j]=otemp;\n            }\n        }\n    }\n}\n\ninline DPoint\nDIsPointInAB2C(DPoint PointA,DPoint PointB,DPoint PointC,double dis,double e,int Maxtime)\n{\n  DPoint MidPoint=MidPointOf2Point(PointA,PointB);\n  double disc2mid=Dis_2P(PointC,MidPoint);\n  int time=0;\n  while (dis<e||time>Maxtime)\n  {\n       time++;\n       if(disc2mid>dis)\n       {\n           PointB=MidPoint;\n\n       }\n       else\n       {\n          PointA=MidPoint;\n       }\n       MidPoint=MidPointOf2Point(PointA,PointB);\n       disc2mid=Dis_2P(PointC,MidPoint);\n  }\n  return MidPoint;\n\n}\n\ninline double\nProduct(DPoint P1,DPoint P2,DPoint P3)\n{\n    return(P2.x_-P1.x_)*(P3.y_-P1.y_)-(P3.x_-P1.x_)*(P2.y_-P1.y_);\n}\ninline bool\nIsInTriangle(DPoint P1,DPoint P2,DPoint P3,DPoint P4)\n{\n    if(Product(P1,P2,P4)>=0&&Product(P2,P3,P4)>=0&&Product(P3,P1,P4)>=0)\n    {\n        return true;\n    }\n    return false;\n}\n\n\ninline bool\nIsInRectangle(DPoint P1,DPoint P2,DPoint P3,DPoint P4,DPoint P5)\n{\n    if(Product(P1,P2,P5)>=0&&Product(P2,P3,P5)>=0&&Product(P3,P4,P5)>=0&&Product(P4,P1,P5)>=0)\n    {\n        return true;\n    }\n    return false;\n}\n\ninline float\nuf(float x,float a,float  b,float c)\n{\nif(x<=a)\nreturn 0;\nelse if((a<x)&&(x<=b))\nreturn  (x-a)/(b-a);\nelse if((b<x)&&(x<=c))\nreturn (c-x)/(c-b);\nelse if(x>c)\nreturn 0;\n}\n\ninline float\ncuf(float x,float a,float b,float c)\n{   float y,z;\n    z=(b-a)*x+a;\n    y=c-(c-b)*x;\n    return (y+z)/2;\n}\n\ninline float\nufl(float x,float a,float b)\n{\n    if(x<=a)\n    return 1;\n    else if((a<x)&&(x<=b))\n    return (b-x)/(b-a);\n    else if(x>b)\n    return 0;\n}\n\ninline float\ncufl(float x,float a,float b)\n{\n\n    return b-(b-a)*x;\n}\n\ninline float\nufr(float x,float a,float b)\n{\nif(x<=a)\nreturn 0;\nif((a<x)&&(x<b))\nreturn (x-a)/(b-a);\nif(x>=b)\nreturn 1;\n}\n\ninline float\ncufr(float x,float a,float b)\n{\nreturn (b-a)*x+a;\n}\n\ninline float\nfand(float a,float b)\n{\n    return (a<b)?a:b;\n}\n\ninline float\nforr(float a,float b)\n{\n    return (a<b)?b:a;\n}\n\n#endif\n\n\n'dynamic_task_allocation/src/task_allocation/include/behaviour.h'\n:#ifndef _BEHAVIOUR_H\n#define _BEHAVIOUR_H\n\n#include <subtargets.h>\n\nclass Behaviour\n{\n\npublic:\n    Behaviour(std::vector<DPoint> &obstacles);\n    ~ Behaviour();\n\n    float basicPDControl(float pgain,float dgain, float err,float err1, float maxval);\n    void move2Position(float pval, float dval, DPoint target, float maxvel,\n                       const DPoint  & _robot_pos,const Angle  & _robot_ori,bool avoid_obs, DPoint realtarvel=DPoint(0,0));\n    void move2Positionwithobs(float pval, float dval, DPoint target, float maxvel,\n                              const DPoint & _robot_pos, const Angle & _robot_ori);\n    void rotate2AbsOrienation(float pval, float dval, float orientation,float maxw,const Angle & _robot_ori);\n    void clearBehaviorState();\n    void setAppvx(double vx);\n    void setAppvy(double vy);\n    void setAppw(double w);\n    void accelerateLimit(const double &_acc_thresh = 25, const bool & use_convected_acc = true);\n    void clear();\npublic:\n    float app_vx_;\n    float app_vy_;\n    float app_w_;\n    float last_app_vx_;\n    float last_app_vy_;\n    float last_app_w_;\n    float last_speed;\n\n    Subtargets m_subtargets_;\n };\n\n#endif\n",
        "gt": [
            "'dynamic_task_allocation/src/allocation_common/include/Common.hpp'",
            "'dynamic_task_allocation/src/task_allocation/include/subtargets.h'",
            "'dynamic_task_allocation/src/task_allocation/include/behaviour.h'",
            "'dynamic_task_allocation/src/task_allocation/include/task_allocation.h'",
            "'dynamic_task_allocation/src/task_allocation/src/main.cpp'"
        ]
    },
    {
        "files": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/Binary.h'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE.h'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/enums.h'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/undef.h'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/Import.h'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.h'"
        ],
        "content": "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/Binary.h'\n:\n#ifndef C_LIEF_PE_BINARY_H_\n#define C_LIEF_PE_BINARY_H_\n\n\n\n#include <stddef.h>\n\n#include \"LIEF/visibility.h\"\n\n#include \"LIEF/PE/enums.h\"\n\n#include \"LIEF/PE/DosHeader.h\"\n#include \"LIEF/PE/Header.h\"\n#include \"LIEF/PE/OptionalHeader.h\"\n#include \"LIEF/PE/DataDirectory.h\"\n#include \"LIEF/PE/Section.h\"\n#include \"LIEF/PE/Import.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nstruct Pe_Binary_t {\n  void*                handler;\n  const char*          name;\n  Pe_DosHeader_t       dos_header;\n  Pe_Header_t          header;\n  Pe_OptionalHeader_t  optional_header;\n  Pe_DataDirectory_t** data_directories;\n  Pe_Section_t**       sections;\n  Pe_Import_t**        imports;\n};\n\ntypedef struct Pe_Binary_t Pe_Binary_t;\n\n\nLIEF_API Pe_Binary_t* pe_parse(const char *file);\n\nLIEF_API void pe_binary_destroy(Pe_Binary_t* binary);\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE.h'\n:\n#ifndef C_LIEF_PE_H_\n#define C_LIEF_PE_H_\n\n\n\n#include \"LIEF/PE/Binary.h\"\n#include \"LIEF/PE/EnumToString.h\"\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/enums.h'\n:#ifndef LIEF_PE_C_ENUMS_H_\n#define LIEF_PE_C_ENUMS_H_\n#include \"LIEF/PE/undef.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define _LIEF_EN(N) LIEF_PE_##N\n#define _LIEF_EN_2(N, TYPE) LIEF_PE_##N\n#define _LIEF_EI(X) LIEF_PE_##X\n\n#include \"LIEF/PE/enums.inc\"\n\n#undef _LIEF_EN\n#undef _LIEF_EN_2\n#undef _LIEF_EI\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/undef.h'\n:\n#if !defined(LIEF_PE_UNDEF_H) || defined(LIEF_PE_FORCE_UNDEF)\n#define LIEF_PE_UNDEF_H\n\n#ifdef IMAGE_FILE_MACHINE_UNKNOWN\n#pragma message(\"LIEF will disable #define enums. Please use LIEF_PE_XXXX or LIEF::PE::XXXX instead!\")\n#endif\n\n#undef IMAGE_FILE_MACHINE_UNKNOWN\n#undef IMAGE_FILE_MACHINE_AM33\n#undef IMAGE_FILE_MACHINE_AMD64\n#undef IMAGE_FILE_MACHINE_ARM\n#undef IMAGE_FILE_MACHINE_ARMNT\n#undef IMAGE_FILE_MACHINE_ARM64\n#undef IMAGE_FILE_MACHINE_EBC\n#undef IMAGE_FILE_MACHINE_I386\n#undef IMAGE_FILE_MACHINE_IA64\n#undef IMAGE_FILE_MACHINE_M32R\n#undef IMAGE_FILE_MACHINE_MIPS16\n#undef IMAGE_FILE_MACHINE_MIPSFPU\n#undef IMAGE_FILE_MACHINE_MIPSFPU16\n#undef IMAGE_FILE_MACHINE_POWERPC\n#undef IMAGE_FILE_MACHINE_POWERPCFP\n#undef IMAGE_FILE_MACHINE_R4000\n#undef IMAGE_FILE_MACHINE_RISCV32\n#undef IMAGE_FILE_MACHINE_RISCV64\n#undef IMAGE_FILE_MACHINE_RISCV128\n#undef IMAGE_FILE_MACHINE_SH3\n#undef IMAGE_FILE_MACHINE_SH3DSP\n#undef IMAGE_FILE_MACHINE_SH4\n#undef IMAGE_FILE_MACHINE_SH5\n#undef IMAGE_FILE_MACHINE_THUMB\n#undef IMAGE_FILE_MACHINE_WCEMIPSV2\n\n#undef IMAGE_SYM_DEBUG\n#undef IMAGE_SYM_ABSOLUTE\n#undef IMAGE_SYM_UNDEFINED\n\n\n#undef IMAGE_FILE_INVALID\n#undef IMAGE_FILE_RELOCS_STRIPPED\n#undef IMAGE_FILE_EXECUTABLE_IMAGE\n#undef IMAGE_FILE_LINE_NUMS_STRIPPED\n#undef IMAGE_FILE_LOCAL_SYMS_STRIPPED\n#undef IMAGE_FILE_AGGRESSIVE_WS_TRIM\n#undef IMAGE_FILE_LARGE_ADDRESS_AWARE\n#undef IMAGE_FILE_BYTES_REVERSED_LO\n#undef IMAGE_FILE_32BIT_MACHINE\n#undef IMAGE_FILE_DEBUG_STRIPPED\n#undef IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP\n#undef IMAGE_FILE_NET_RUN_FROM_SWAP\n#undef IMAGE_FILE_SYSTEM\n#undef IMAGE_FILE_DLL\n#undef IMAGE_FILE_UP_SYSTEM_ONLY\n#undef IMAGE_FILE_BYTES_REVERSED_HI\n\n#undef IMAGE_SYM_CLASS_END_OF_FUNCTION\n#undef IMAGE_SYM_CLASS_NULL\n#undef IMAGE_SYM_CLASS_AUTOMATIC\n#undef IMAGE_SYM_CLASS_EXTERNAL\n#undef IMAGE_SYM_CLASS_STATIC\n#undef IMAGE_SYM_CLASS_REGISTER\n#undef IMAGE_SYM_CLASS_EXTERNAL_DEF\n#undef IMAGE_SYM_CLASS_LABEL\n#undef IMAGE_SYM_CLASS_UNDEFINED_LABEL\n#undef IMAGE_SYM_CLASS_MEMBER_OF_STRUCT\n#undef IMAGE_SYM_CLASS_ARGUMENT\n#undef IMAGE_SYM_CLASS_STRUCT_TAG\n#undef IMAGE_SYM_CLASS_MEMBER_OF_UNION\n#undef IMAGE_SYM_CLASS_UNION_TAG\n#undef IMAGE_SYM_CLASS_TYPE_DEFINITION\n#undef IMAGE_SYM_CLASS_UNDEFINED_STATIC\n#undef IMAGE_SYM_CLASS_ENUM_TAG\n#undef IMAGE_SYM_CLASS_MEMBER_OF_ENUM\n#undef IMAGE_SYM_CLASS_REGISTER_PARAM\n#undef IMAGE_SYM_CLASS_BIT_FIELD\n#undef IMAGE_SYM_CLASS_BLOCK\n#undef IMAGE_SYM_CLASS_FUNCTION\n#undef IMAGE_SYM_CLASS_END_OF_STRUCT\n#undef IMAGE_SYM_CLASS_FILE\n#undef IMAGE_SYM_CLASS_SECTION\n#undef IMAGE_SYM_CLASS_WEAK_EXTERNAL\n#undef IMAGE_SYM_CLASS_CLR_TOKEN\n\n#undef IMAGE_SYM_TYPE_NULL\n#undef IMAGE_SYM_TYPE_VOID\n#undef IMAGE_SYM_TYPE_CHAR\n#undef IMAGE_SYM_TYPE_SHORT\n#undef IMAGE_SYM_TYPE_INT\n#undef IMAGE_SYM_TYPE_LONG\n#undef IMAGE_SYM_TYPE_FLOAT\n#undef IMAGE_SYM_TYPE_DOUBLE\n#undef IMAGE_SYM_TYPE_STRUCT\n#undef IMAGE_SYM_TYPE_UNION\n#undef IMAGE_SYM_TYPE_ENUM\n#undef IMAGE_SYM_TYPE_MOE\n#undef IMAGE_SYM_TYPE_BYTE\n#undef IMAGE_SYM_TYPE_WORD\n#undef IMAGE_SYM_TYPE_UINT\n#undef IMAGE_SYM_TYPE_DWORD\n\n\n\n#undef IMAGE_SYM_DTYPE_NULL\n#undef IMAGE_SYM_DTYPE_POINTER\n#undef IMAGE_SYM_DTYPE_FUNCTION\n#undef IMAGE_SYM_DTYPE_ARRAY\n#undef SCT_COMPLEX_TYPE_SHIFT\n\n#undef IMAGE_REL_BASED_ABSOLUTE\n#undef IMAGE_REL_BASED_HIGH\n#undef IMAGE_REL_BASED_LOW\n#undef IMAGE_REL_BASED_HIGHLOW\n#undef IMAGE_REL_BASED_HIGHADJ\n#undef IMAGE_REL_BASED_MIPS_JMPADDR\n#undef IMAGE_REL_BASED_SECTION\n#undef IMAGE_REL_BASED_REL\n#undef IMAGE_REL_BASED_MIPS_JMPADDR16\n#undef IMAGE_REL_BASED_IA64_IMM64\n#undef IMAGE_REL_BASED_DIR64\n#undef IMAGE_REL_BASED_HIGH3ADJ\n\n#undef IMAGE_REL_I386_ABSOLUTE\n#undef IMAGE_REL_I386_DIR16\n#undef IMAGE_REL_I386_REL16\n#undef IMAGE_REL_I386_DIR32\n#undef IMAGE_REL_I386_DIR32NB\n#undef IMAGE_REL_I386_SEG12\n#undef IMAGE_REL_I386_SECTION\n#undef IMAGE_REL_I386_SECREL\n#undef IMAGE_REL_I386_TOKEN\n#undef IMAGE_REL_I386_SECREL7\n#undef IMAGE_REL_I386_REL32\n#undef IMAGE_REL_BASED_ARM_MOV32A\n#undef IMAGE_REL_BASED_ARM_MOV32\n#undef IMAGE_REL_BASED_RISCV_HI20\n#undef IMAGE_REL_BASED_ARM_MOV32T\n#undef IMAGE_REL_BASED_THUMB_MOV32\n#undef IMAGE_REL_BASED_RISCV_LOW12I\n#undef IMAGE_REL_BASED_RISCV_LOW12S\n\n#undef IMAGE_REL_AMD64_ABSOLUTE\n#undef IMAGE_REL_AMD64_ADDR64\n#undef IMAGE_REL_AMD64_ADDR32\n#undef IMAGE_REL_AMD64_ADDR32NB\n#undef IMAGE_REL_AMD64_REL32\n#undef IMAGE_REL_AMD64_REL32_1\n#undef IMAGE_REL_AMD64_REL32_2\n#undef IMAGE_REL_AMD64_REL32_3\n#undef IMAGE_REL_AMD64_REL32_4\n#undef IMAGE_REL_AMD64_REL32_5\n#undef IMAGE_REL_AMD64_SECTION\n#undef IMAGE_REL_AMD64_SECREL\n#undef IMAGE_REL_AMD64_SECREL7\n#undef IMAGE_REL_AMD64_TOKEN\n#undef IMAGE_REL_AMD64_SREL32\n#undef IMAGE_REL_AMD64_PAIR\n#undef IMAGE_REL_AMD64_SSPAN32\n\n#undef IMAGE_REL_ARM_ABSOLUTE\n#undef IMAGE_REL_ARM_ADDR32\n#undef IMAGE_REL_ARM_ADDR32NB\n#undef IMAGE_REL_ARM_BRANCH24\n#undef IMAGE_REL_ARM_BRANCH11\n#undef IMAGE_REL_ARM_TOKEN\n#undef IMAGE_REL_ARM_BLX24\n#undef IMAGE_REL_ARM_BLX11\n#undef IMAGE_REL_ARM_SECTION\n#undef IMAGE_REL_ARM_SECREL\n#undef IMAGE_REL_ARM_MOV32A\n#undef IMAGE_REL_ARM_MOV32T\n#undef IMAGE_REL_ARM_BRANCH20T\n#undef IMAGE_REL_ARM_BRANCH24T\n#undef IMAGE_REL_ARM_BLX23T\n\n\n#undef IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY\n#undef IMAGE_WEAK_EXTERN_SEARCH_LIBRARY\n#undef IMAGE_WEAK_EXTERN_SEARCH_ALIAS\n\n\n#undef EXPORT_TABLE\n#undef IMPORT_TABLE\n#undef RESOURCE_TABLE\n#undef EXCEPTION_TABLE\n#undef CERTIFICATE_TABLE\n#undef BASE_RELOCATION_TABLE\n#undef DEBUG\n#undef ARCHITECTURE\n#undef GLOBAL_PTR\n#undef TLS_TABLE\n#undef LOAD_CONFIG_TABLE\n#undef BOUND_IMPORT\n#undef IAT\n#undef DELAY_IMPORT_DESCRIPTOR\n#undef CLR_RUNTIME_HEADER\n#undef NUM_DATA_DIRECTORIES\n\n#undef IMAGE_SUBSYSTEM_UNKNOWN\n#undef IMAGE_SUBSYSTEM_NATIVE\n#undef IMAGE_SUBSYSTEM_WINDOWS_GUI\n#undef IMAGE_SUBSYSTEM_WINDOWS_CUI\n#undef IMAGE_SUBSYSTEM_OS2_CUI\n#undef IMAGE_SUBSYSTEM_POSIX_CUI\n#undef IMAGE_SUBSYSTEM_NATIVE_WINDOWS\n#undef IMAGE_SUBSYSTEM_WINDOWS_CE_GUI\n#undef IMAGE_SUBSYSTEM_EFI_APPLICATION\n#undef IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER\n#undef IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER\n#undef IMAGE_SUBSYSTEM_EFI_ROM\n#undef IMAGE_SUBSYSTEM_XBOX\n#undef IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION\n\n\n\n#undef IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA\n#undef IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE\n#undef IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY\n#undef IMAGE_DLL_CHARACTERISTICS_NX_COMPAT\n#undef IMAGE_DLL_CHARACTERISTICS_NO_ISOLATION\n#undef IMAGE_DLL_CHARACTERISTICS_NO_SEH\n#undef IMAGE_DLL_CHARACTERISTICS_NO_BIND\n#undef IMAGE_DLL_CHARACTERISTICS_APPCONTAINER\n#undef IMAGE_DLL_CHARACTERISTICS_WDM_DRIVER\n#undef IMAGE_DLL_CHARACTERISTICS_GUARD_CF\n#undef IMAGE_DLL_CHARACTERISTICS_TERMINAL_SERVER_AWARE\n\n#undef IMAGE_DEBUG_TYPE_UNKNOWN\n#undef IMAGE_DEBUG_TYPE_COFF\n#undef IMAGE_DEBUG_TYPE_CODEVIEW\n#undef IMAGE_DEBUG_TYPE_FPO\n#undef IMAGE_DEBUG_TYPE_MISC\n#undef IMAGE_DEBUG_TYPE_EXCEPTION\n#undef IMAGE_DEBUG_TYPE_FIXUP\n#undef IMAGE_DEBUG_TYPE_OMAP_TO_SRC\n#undef IMAGE_DEBUG_TYPE_OMAP_FROM_SRC\n#undef IMAGE_DEBUG_TYPE_BORLAND\n#undef IMAGE_DEBUG_TYPE_RESERVED10\n#undef IMAGE_DEBUG_TYPE_CLSID\n#undef IMAGE_DEBUG_TYPE_VC_FEATURE\n#undef IMAGE_DEBUG_TYPE_POGO\n#undef IMAGE_DEBUG_TYPE_ILTCG\n#undef IMAGE_DEBUG_TYPE_MPX\n#undef IMAGE_DEBUG_TYPE_REPRO\n#undef IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS\n\n#undef IMAGE_SCN_TYPE_NO_PAD\n#undef IMAGE_SCN_CNT_CODE\n#undef IMAGE_SCN_CNT_INITIALIZED_DATA\n#undef IMAGE_SCN_CNT_UNINITIALIZED_DATA\n#undef IMAGE_SCN_LNK_OTHER\n#undef IMAGE_SCN_LNK_INFO\n#undef IMAGE_SCN_LNK_REMOVE\n#undef IMAGE_SCN_LNK_COMDAT\n#undef IMAGE_SCN_GPREL\n#undef IMAGE_SCN_MEM_PURGEABLE\n#undef IMAGE_SCN_MEM_16BIT\n#undef IMAGE_SCN_MEM_LOCKED\n#undef IMAGE_SCN_MEM_PRELOAD\n#undef IMAGE_SCN_ALIGN_1BYTES\n#undef IMAGE_SCN_ALIGN_2BYTES\n#undef IMAGE_SCN_ALIGN_4BYTES\n#undef IMAGE_SCN_ALIGN_8BYTES\n#undef IMAGE_SCN_ALIGN_16BYTES\n#undef IMAGE_SCN_ALIGN_32BYTES\n#undef IMAGE_SCN_ALIGN_64BYTES\n#undef IMAGE_SCN_ALIGN_128BYTES\n#undef IMAGE_SCN_ALIGN_256BYTES\n#undef IMAGE_SCN_ALIGN_512BYTES\n#undef IMAGE_SCN_ALIGN_1024BYTES\n#undef IMAGE_SCN_ALIGN_2048BYTES\n#undef IMAGE_SCN_ALIGN_4096BYTES\n#undef IMAGE_SCN_ALIGN_8192BYTES\n#undef IMAGE_SCN_LNK_NRELOC_OVFL\n#undef IMAGE_SCN_MEM_DISCARDABLE\n#undef IMAGE_SCN_MEM_NOT_CACHED\n#undef IMAGE_SCN_MEM_NOT_PAGED\n#undef IMAGE_SCN_MEM_SHARED\n#undef IMAGE_SCN_MEM_EXECUTE\n#undef IMAGE_SCN_MEM_READ\n#undef IMAGE_SCN_MEM_WRITE\n\n#undef RESOURCE_TYPES\n#undef RESOURCE_LANGS\n\n\n#undef LANG_NEUTRAL\n#undef LANG_INVARIANT\n#undef LANG_AFRIKAANS\n#undef LANG_ALBANIAN\n#undef LANG_ARABIC\n#undef LANG_ARMENIAN\n#undef LANG_ASSAMESE\n#undef LANG_AZERI\n#undef LANG_BASQUE\n#undef LANG_BELARUSIAN\n#undef LANG_BENGALI\n#undef LANG_BANGLA\n#undef LANG_BULGARIAN\n#undef LANG_CATALAN\n#undef LANG_CHINESE\n#undef LANG_CROATIAN\n#undef LANG_BOSNIAN\n#undef LANG_CZECH\n#undef LANG_DANISH\n#undef LANG_DIVEHI\n#undef LANG_DUTCH\n#undef LANG_ENGLISH\n#undef LANG_ESTONIAN\n#undef LANG_FAEROESE\n#undef LANG_FARSI\n#undef LANG_FINNISH\n#undef LANG_FRENCH\n#undef LANG_GALICIAN\n#undef LANG_GEORGIAN\n#undef LANG_GERMAN\n#undef LANG_GREEK\n#undef LANG_GUJARATI\n#undef LANG_HEBREW\n#undef LANG_HINDI\n#undef LANG_HUNGARIAN\n#undef LANG_ICELANDIC\n#undef LANG_INDONESIAN\n#undef LANG_ITALIAN\n#undef LANG_JAPANESE\n#undef LANG_KANNADA\n#undef LANG_KASHMIRI\n#undef LANG_KAZAK\n#undef LANG_KONKANI\n#undef LANG_KOREAN\n#undef LANG_KYRGYZ\n#undef LANG_LATVIAN\n#undef LANG_LITHUANIAN\n#undef LANG_MACEDONIAN\n#undef LANG_MALAY\n#undef LANG_MALAYALAM\n#undef LANG_MANIPURI\n#undef LANG_MARATHI\n#undef LANG_MONGOLIAN\n#undef LANG_NEPALI\n#undef LANG_NORWEGIAN\n#undef LANG_ORIYA\n#undef LANG_POLISH\n#undef LANG_PORTUGUESE\n#undef LANG_PUNJABI\n#undef LANG_ROMANIAN\n#undef LANG_RUSSIAN\n#undef LANG_SANSKRIT\n#undef LANG_SERBIAN\n#undef LANG_SINDHI\n#undef LANG_SLOVAK\n#undef LANG_SLOVENIAN\n#undef LANG_SPANISH\n#undef LANG_SWAHILI\n#undef LANG_SWEDISH\n#undef LANG_SYRIAC\n#undef LANG_TAMIL\n#undef LANG_TATAR\n#undef LANG_TELUGU\n#undef LANG_THAI\n#undef LANG_TURKISH\n#undef LANG_UKRAINIAN\n#undef LANG_URDU\n#undef LANG_UZBEK\n#undef LANG_VIETNAMESE\n#undef LANG_GAELIC\n#undef LANG_MALTESE\n#undef LANG_MAORI\n#undef LANG_RHAETO_ROMANCE\n#undef LANG_SAMI\n#undef LANG_SORBIAN\n#undef LANG_SUTU\n#undef LANG_TSONGA\n#undef LANG_TSWANA\n#undef LANG_VENDA\n#undef LANG_XHOSA\n#undef LANG_ZULU\n#undef LANG_ESPERANTO\n#undef LANG_WALON\n#undef LANG_CORNISH\n#undef LANG_WELSH\n#undef LANG_BRETON\n#undef LANG_INUKTITUT\n#undef LANG_IRISH\n#undef LANG_LOWER_SORBIAN\n#undef LANG_PULAR\n#undef LANG_QUECHUA\n#undef LANG_TAMAZIGHT\n#undef LANG_TIGRINYA\n#undef LANG_VALENCIAN\n\n\n\n#undef SUBLANG_AFRIKAANS_SOUTH_AFRICA\n#undef SUBLANG_ALBANIAN_ALBANIA\n#undef SUBLANG_ALSATIAN_FRANCE\n#undef SUBLANG_AMHARIC_ETHIOPIA\n#undef SUBLANG_ARABIC_ALGERIA\n#undef SUBLANG_ARABIC_BAHRAIN\n#undef SUBLANG_ARABIC_EGYPT\n#undef SUBLANG_ARABIC_IRAQ\n#undef SUBLANG_ARABIC_JORDAN\n#undef SUBLANG_ARABIC_KUWAIT\n#undef SUBLANG_ARABIC_LEBANON\n#undef SUBLANG_ARABIC_LIBYA\n#undef SUBLANG_ARABIC_MOROCCO\n#undef SUBLANG_ARABIC_OMAN\n#undef SUBLANG_ARABIC_QATAR\n#undef SUBLANG_ARABIC_SAUDI_ARABIA\n#undef SUBLANG_ARABIC_SYRIA\n#undef SUBLANG_ARABIC_TUNISIA\n#undef SUBLANG_ARABIC_UAE\n#undef SUBLANG_ARABIC_YEMEN\n#undef SUBLANG_ARMENIAN_ARMENIA\n#undef SUBLANG_ASSAMESE_INDIA\n#undef SUBLANG_AZERI_CYRILLIC\n#undef SUBLANG_AZERI_LATIN\n#undef SUBLANG_BASHKIR_RUSSIA\n#undef SUBLANG_BASQUE_BASQUE\n#undef SUBLANG_BELARUSIAN_BELARUS\n#undef SUBLANG_BANGLA_BANGLADESH\n#undef SUBLANG_BANGLA_INDIA\n#undef SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC\n#undef SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN\n#undef SUBLANG_BRETON_FRANCE\n#undef SUBLANG_BULGARIAN_BULGARIA\n#undef SUBLANG_CATALAN_CATALAN\n#undef SUBLANG_CHINESE_HONGKONG\n#undef SUBLANG_CHINESE_MACAU\n#undef SUBLANG_CHINESE_SIMPLIFIED\n#undef SUBLANG_CHINESE_SINGAPORE\n#undef SUBLANG_CHINESE_TRADITIONAL\n#undef SUBLANG_CORSICAN_FRANCE\n#undef SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN\n#undef SUBLANG_CROATIAN_CROATIA\n#undef SUBLANG_CUSTOM_DEFAULT\n#undef SUBLANG_CUSTOM_UNSPECIFIED\n#undef SUBLANG_CZECH_CZECH_REPUBLIC\n#undef SUBLANG_DANISH_DENMARK\n#undef SUBLANG_DARI_AFGHANISTAN\n#undef SUBLANG_DEFAULT\n#undef SUBLANG_DIVEHI_MALDIVES\n#undef SUBLANG_DUTCH_BELGIAN\n#undef SUBLANG_DUTCH\n#undef SUBLANG_ENGLISH_AUS\n#undef SUBLANG_ENGLISH_BELIZE\n#undef SUBLANG_ENGLISH_CAN\n#undef SUBLANG_ENGLISH_CARIBBEAN\n#undef SUBLANG_ENGLISH_EIRE\n#undef SUBLANG_ENGLISH_INDIA\n#undef SUBLANG_ENGLISH_JAMAICA\n#undef SUBLANG_ENGLISH_MALAYSIA\n#undef SUBLANG_ENGLISH_NZ\n#undef SUBLANG_ENGLISH_PHILIPPINES\n#undef SUBLANG_ENGLISH_SINGAPORE\n#undef SUBLANG_ENGLISH_SOUTH_AFRICA\n#undef SUBLANG_ENGLISH_TRINIDAD\n#undef SUBLANG_ENGLISH_UK\n#undef SUBLANG_ENGLISH_US\n#undef SUBLANG_ENGLISH_ZIMBABWE\n#undef SUBLANG_ENGLISH_IRELAND\n#undef SUBLANG_ESTONIAN_ESTONIA\n#undef SUBLANG_FAEROESE_FAROE_ISLANDS\n#undef SUBLANG_FILIPINO_PHILIPPINES\n#undef SUBLANG_FINNISH_FINLAND\n#undef SUBLANG_FRENCH_BELGIAN\n#undef SUBLANG_FRENCH_CANADIAN\n#undef SUBLANG_FRENCH_LUXEMBOURG\n#undef SUBLANG_FRENCH_MONACO\n#undef SUBLANG_FRENCH_SWISS\n#undef SUBLANG_FRENCH\n#undef SUBLANG_FRISIAN_NETHERLANDS\n#undef SUBLANG_GALICIAN_GALICIAN\n#undef SUBLANG_GEORGIAN_GEORGIA\n#undef SUBLANG_GERMAN_AUSTRIAN\n#undef SUBLANG_GERMAN_LIECHTENSTEIN\n#undef SUBLANG_GERMAN_LUXEMBOURG\n#undef SUBLANG_GERMAN_SWISS\n#undef SUBLANG_GERMAN\n#undef SUBLANG_GREEK_GREECE\n#undef SUBLANG_GREENLANDIC_GREENLAND\n#undef SUBLANG_GUJARATI_INDIA\n#undef SUBLANG_HAUSA_NIGERIA_LATIN\n#undef SUBLANG_HEBREW_ISRAEL\n#undef SUBLANG_HINDI_INDIA\n#undef SUBLANG_HUNGARIAN_HUNGARY\n#undef SUBLANG_ICELANDIC_ICELAND\n#undef SUBLANG_IGBO_NIGERIA\n#undef SUBLANG_INDONESIAN_INDONESIA\n#undef SUBLANG_INUKTITUT_CANADA_LATIN\n#undef SUBLANG_INUKTITUT_CANADA\n#undef SUBLANG_IRISH_IRELAND\n#undef SUBLANG_ITALIAN_SWISS\n#undef SUBLANG_ITALIAN\n#undef SUBLANG_JAPANESE_JAPAN\n#undef SUBLANG_KANNADA_INDIA\n#undef SUBLANG_KASHMIRI_INDIA\n#undef SUBLANG_KASHMIRI_SASIA\n#undef SUBLANG_KAZAK_KAZAKHSTAN\n#undef SUBLANG_KHMER_CAMBODIA\n#undef SUBLANG_KICHE_GUATEMALA\n#undef SUBLANG_KINYARWANDA_RWANDA\n#undef SUBLANG_KONKANI_INDIA\n#undef SUBLANG_KOREAN\n#undef SUBLANG_KYRGYZ_KYRGYZSTAN\n#undef SUBLANG_LAO_LAO\n#undef SUBLANG_LATVIAN_LATVIA\n#undef SUBLANG_LITHUANIAN_CLASSIC\n#undef SUBLANG_LITHUANIAN\n#undef SUBLANG_LOWER_SORBIAN_GERMANY\n#undef SUBLANG_LUXEMBOURGISH_LUXEMBOURG\n#undef SUBLANG_MACEDONIAN_MACEDONIA\n#undef SUBLANG_MALAY_BRUNEI_DARUSSALAM\n#undef SUBLANG_MALAY_MALAYSIA\n#undef SUBLANG_MALAYALAM_INDIA\n#undef SUBLANG_MALTESE_MALTA\n#undef SUBLANG_MAORI_NEW_ZEALAND\n#undef SUBLANG_MAPUDUNGUN_CHILE\n#undef SUBLANG_MARATHI_INDIA\n#undef SUBLANG_MOHAWK_MOHAWK\n#undef SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA\n#undef SUBLANG_MONGOLIAN_PRC\n#undef SUBLANG_NEPALI_INDIA\n#undef SUBLANG_NEPALI_NEPAL\n#undef SUBLANG_NEUTRAL\n#undef SUBLANG_NORWEGIAN_BOKMAL\n#undef SUBLANG_NORWEGIAN_NYNORSK\n#undef SUBLANG_OCCITAN_FRANCE\n#undef SUBLANG_ORIYA_INDIA\n#undef SUBLANG_PASHTO_AFGHANISTAN\n#undef SUBLANG_PERSIAN_IRAN\n#undef SUBLANG_POLISH_POLAND\n#undef SUBLANG_PORTUGUESE_BRAZILIAN\n#undef SUBLANG_PORTUGUESE\n#undef SUBLANG_PUNJABI_INDIA\n#undef SUBLANG_QUECHUA_BOLIVIA\n#undef SUBLANG_QUECHUA_ECUADOR\n#undef SUBLANG_QUECHUA_PERU\n#undef SUBLANG_ROMANIAN_ROMANIA\n#undef SUBLANG_ROMANSH_SWITZERLAND\n#undef SUBLANG_RUSSIAN_RUSSIA\n#undef SUBLANG_SAMI_INARI_FINLAND\n#undef SUBLANG_SAMI_LULE_NORWAY\n#undef SUBLANG_SAMI_LULE_SWEDEN\n#undef SUBLANG_SAMI_NORTHERN_FINLAND\n#undef SUBLANG_SAMI_NORTHERN_NORWAY\n#undef SUBLANG_SAMI_NORTHERN_SWEDEN\n#undef SUBLANG_SAMI_SKOLT_FINLAND\n#undef SUBLANG_SAMI_SOUTHERN_NORWAY\n#undef SUBLANG_SAMI_SOUTHERN_SWEDEN\n#undef SUBLANG_SANSKRIT_INDIA\n#undef SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC\n#undef SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN\n#undef SUBLANG_SERBIAN_CROATIA\n#undef SUBLANG_SERBIAN_CYRILLIC\n#undef SUBLANG_SERBIAN_LATIN\n#undef SUBLANG_SINDHI_AFGHANISTAN\n#undef SUBLANG_SINDHI_INDIA\n#undef SUBLANG_SINDHI_PAKISTAN\n#undef SUBLANG_SINHALESE_SRI_LANKA\n#undef SUBLANG_SLOVAK_SLOVAKIA\n#undef SUBLANG_SLOVENIAN_SLOVENIA\n#undef SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA\n#undef SUBLANG_SPANISH_ARGENTINA\n#undef SUBLANG_SPANISH_BOLIVIA\n#undef SUBLANG_SPANISH_CHILE\n#undef SUBLANG_SPANISH_COLOMBIA\n#undef SUBLANG_SPANISH_COSTA_RICA\n#undef SUBLANG_SPANISH_DOMINICAN_REPUBLIC\n#undef SUBLANG_SPANISH_ECUADOR\n#undef SUBLANG_SPANISH_EL_SALVADOR\n#undef SUBLANG_SPANISH_GUATEMALA\n#undef SUBLANG_SPANISH_HONDURAS\n#undef SUBLANG_SPANISH_MEXICAN\n#undef SUBLANG_SPANISH_MODERN\n#undef SUBLANG_SPANISH_NICARAGUA\n#undef SUBLANG_SPANISH_PANAMA\n#undef SUBLANG_SPANISH_PARAGUAY\n#undef SUBLANG_SPANISH_PERU\n#undef SUBLANG_SPANISH_PUERTO_RICO\n#undef SUBLANG_SPANISH_URUGUAY\n#undef SUBLANG_SPANISH_US\n#undef SUBLANG_SPANISH_VENEZUELA\n#undef SUBLANG_SPANISH\n#undef SUBLANG_SWAHILI_KENYA\n#undef SUBLANG_SWEDISH_FINLAND\n#undef SUBLANG_SWEDISH\n#undef SUBLANG_SYRIAC_SYRIA\n#undef SUBLANG_SYS_DEFAULT\n#undef SUBLANG_TAJIK_TAJIKISTAN\n#undef SUBLANG_TAMAZIGHT_ALGERIA_LATIN\n#undef SUBLANG_TAMIL_INDIA\n#undef SUBLANG_TATAR_RUSSIA\n#undef SUBLANG_TELUGU_INDIA\n#undef SUBLANG_THAI_THAILAND\n#undef SUBLANG_TIBETAN_PRC\n#undef SUBLANG_TIGRIGNA_ERITREA\n#undef SUBLANG_TSWANA_SOUTH_AFRICA\n#undef SUBLANG_TURKISH_TURKEY\n#undef SUBLANG_TURKMEN_TURKMENISTAN\n#undef SUBLANG_UI_CUSTOM_DEFAULT\n#undef SUBLANG_UIGHUR_PRC\n#undef SUBLANG_UKRAINIAN_UKRAINE\n#undef SUBLANG_UPPER_SORBIAN_GERMANY\n#undef SUBLANG_URDU_INDIA\n#undef SUBLANG_URDU_PAKISTAN\n#undef SUBLANG_UZBEK_CYRILLIC\n#undef SUBLANG_UZBEK_LATIN\n#undef SUBLANG_VIETNAMESE_VIETNAM\n#undef SUBLANG_WELSH_UNITED_KINGDOM\n#undef SUBLANG_WOLOF_SENEGAL\n#undef SUBLANG_XHOSA_SOUTH_AFRICA\n#undef SUBLANG_YAKUT_RUSSIA\n#undef SUBLANG_YI_PRC\n#undef SUBLANG_YORUBA_NIGERIA\n#undef SUBLANG_ZULU_SOUTH_AFRICA\n#undef SUBLANG_PULAR_SENEGAL\n#undef SUBLANG_PUNJABI_PAKISTAN\n#undef SUBLANG_TSWANA_BOTSWANA\n#undef SUBLANG_TAMIL_SRI_LANKA\n#undef SUBLANG_TIGRINYA_ETHIOPIA\n#undef SUBLANG_TIGRINYA_ERITREA\n#undef SUBLANG_VALENCIAN_VALENCIA\n\n#undef WS_EX_DLGMODALFRAME\n#undef WS_EX_NOPARENTNOTIFY\n#undef WS_EX_TOPMOST\n#undef WS_EX_ACCEPTFILES\n#undef WS_EX_TRANSPARENT\n#undef WS_EX_MDICHILD\n#undef WS_EX_TOOLWINDOW\n#undef WS_EX_WINDOWEDGE\n#undef WS_EX_CLIENTEDGE\n#undef WS_EX_CONTEXTHELP\n#undef WS_EX_RIGHT\n#undef WS_EX_LEFT\n#undef WS_EX_RTLREADING\n#undef WS_EX_LTRREADING\n#undef WS_EX_LEFTSCROLLBAR\n#undef WS_EX_RIGHTSCROLLBAR\n#undef WS_EX_CONTROLPARENT\n#undef WS_EX_STATICEDGE\n#undef WS_EX_APPWINDOW\n\n\n#undef WS_OVERLAPPED\n#undef WS_POPUP\n#undef WS_CHILD\n#undef WS_MINIMIZE\n#undef WS_VISIBLE\n#undef WS_DISABLED\n#undef WS_CLIPSIBLINGS\n#undef WS_CLIPCHILDREN\n#undef WS_MAXIMIZE\n#undef WS_CAPTION\n#undef WS_BORDER\n#undef WS_DLGFRAME\n#undef WS_VSCROLL\n#undef WS_HSCROLL\n#undef WS_SYSMENU\n#undef WS_THICKFRAME\n#undef WS_GROUP\n#undef WS_TABSTOP\n#undef WS_MINIMIZEBOX\n#undef WS_MAXIMIZEBOX\n\n#undef DS_ABSALIGN\n#undef DS_SYSMODAL\n#undef DS_LOCALEDIT\n#undef DS_SETFONT\n#undef DS_MODALFRAME\n#undef DS_NOIDLEMSG\n#undef DS_SETFOREGROUND\n#undef DS_3DLOOK\n#undef DS_FIXEDSYS\n#undef DS_NOFAILCREATE\n#undef DS_CONTROL\n#undef DS_CENTER\n#undef DS_CENTERMOUSE\n#undef DS_CONTEXTHELP\n#undef DS_SHELLFONT\n\n#undef VOS_UNKNOWN\n#undef VOS_DOS\n#undef VOS_NT\n#undef VOS__WINDOWS16\n#undef VOS__WINDOWS32\n#undef VOS_OS216\n#undef VOS_OS232\n#undef VOS__PM16\n#undef VOS__PM32\n#undef VOS_DOS_WINDOWS16\n#undef VOS_DOS_WINDOWS32\n#undef VOS_NT_WINDOWS32\n#undef VOS_OS216_PM16\n#undef VOS_OS232_PM32\n\n#undef VS_FF_DEBUG\n#undef VS_FF_INFOINFERRED\n#undef VS_FF_PATCHED\n#undef VS_FF_PRERELEASE\n#undef VS_FF_PRIVATEBUILD\n#undef VS_FF_SPECIALBUILD\n\n#undef VFT_APP\n#undef VFT_DLL\n#undef VFT_DRV\n#undef VFT_FONT\n#undef VFT_STATIC_LIB\n#undef VFT_UNKNOWN\n#undef VFT_VXD\n\n#undef VFT2_DRV_COMM\n#undef VFT2_DRV_DISPLAY\n#undef VFT2_DRV_INSTALLABLE\n#undef VFT2_DRV_KEYBOARD\n#undef VFT2_DRV_LANGUAGE\n#undef VFT2_DRV_MOUSE\n#undef VFT2_DRV_NETWORK\n#undef VFT2_DRV_PRINTER\n#undef VFT2_DRV_SOUND\n#undef VFT2_DRV_SYSTEM\n#undef VFT2_DRV_VERSIONED_PRINTER\n#undef VFT2_FONT_RASTER\n#undef VFT2_FONT_TRUETYPE\n#undef VFT2_FONT_VECTOR\n#undef VFT2_UNKNOWN\n\n#undef FVIRTKEY\n#undef FNOINVERT\n#undef FSHIFT\n#undef FCONTROL\n#undef FALT\n#undef END\n\n#undef VK_LBUTTON\n#undef VK_RBUTTON\n#undef VK_CANCEL\n#undef VK_MBUTTON\n#undef VK_XBUTTON1\n#undef VK_XBUTTON2\n#undef VK_BACK\n#undef VK_TAB\n#undef VK_CLEAR\n#undef VK_RETURN\n#undef VK_SHIFT\n#undef VK_CONTROL\n#undef VK_MENU\n#undef VK_PAUSE\n#undef VK_CAPITAL\n#undef VK_KANA\n#undef VK_HANGUEL\n#undef VK_HANGUL\n#undef VK_IME_ON\n#undef VK_JUNJA\n#undef VK_FINAL\n#undef VK_HANJA\n#undef VK_KANJI\n#undef VK_IME_OFF\n#undef VK_ESCAPE\n#undef VK_CONVERT\n#undef VK_NONCONVERT\n#undef VK_ACCEPT\n#undef VK_MODECHANGE\n#undef VK_SPACE\n#undef VK_PRIOR\n#undef VK_NEXT\n#undef VK_END\n#undef VK_HOME\n#undef VK_LEFT\n#undef VK_UP\n#undef VK_RIGHT\n#undef VK_DOWN\n#undef VK_SELECT\n#undef VK_PRINT\n#undef VK_EXECUTE\n#undef VK_SNAPSHOT\n#undef VK_INSERT\n#undef VK_DELETE\n#undef VK_HELP\n#undef VK_0\n#undef VK_1\n#undef VK_2\n#undef VK_3\n#undef VK_4\n#undef VK_5\n#undef VK_6\n#undef VK_7\n#undef VK_8\n#undef VK_9\n#undef VK_A\n#undef VK_B\n#undef VK_C\n#undef VK_D\n#undef VK_E\n#undef VK_F\n#undef VK_G\n#undef VK_H\n#undef VK_I\n#undef VK_J\n#undef VK_K\n#undef VK_L\n#undef VK_M\n#undef VK_N\n#undef VK_O\n#undef VK_P\n#undef VK_Q\n#undef VK_R\n#undef VK_S\n#undef VK_T\n#undef VK_U\n#undef VK_V\n#undef VK_W\n#undef VK_X\n#undef VK_Y\n#undef VK_Z\n#undef VK_LWIN\n#undef VK_RWIN\n#undef VK_APPS\n#undef VK_SLEEP\n#undef VK_NUMPAD0\n#undef VK_NUMPAD1\n#undef VK_NUMPAD2\n#undef VK_NUMPAD3\n#undef VK_NUMPAD4\n#undef VK_NUMPAD5\n#undef VK_NUMPAD6\n#undef VK_NUMPAD7\n#undef VK_NUMPAD8\n#undef VK_NUMPAD9\n#undef VK_MULTIPLY\n#undef VK_ADD\n#undef VK_SEPARATOR\n#undef VK_SUBTRACT\n#undef VK_DECIMAL\n#undef VK_DIVIDE\n#undef VK_F1\n#undef VK_F2\n#undef VK_F3\n#undef VK_F4\n#undef VK_F5\n#undef VK_F6\n#undef VK_F7\n#undef VK_F8\n#undef VK_F9\n#undef VK_F10\n#undef VK_F11\n#undef VK_F12\n#undef VK_F13\n#undef VK_F14\n#undef VK_F15\n#undef VK_F16\n#undef VK_F17\n#undef VK_F18\n#undef VK_F19\n#undef VK_F20\n#undef VK_F21\n#undef VK_F22\n#undef VK_F23\n#undef VK_F24\n#undef VK_NUMLOCK\n#undef VK_SCROLL\n#undef VK_LSHIFT\n#undef VK_RSHIFT\n#undef VK_LCONTROL\n#undef VK_RCONTROL\n#undef VK_LMENU\n#undef VK_RMENU\n#undef VK_BROWSER_BACK\n#undef VK_BROWSER_FORWARD\n#undef VK_BROWSER_REFRESH\n#undef VK_BROWSER_STOP\n#undef VK_BROWSER_SEARCH\n#undef VK_BROWSER_FAVORITES\n#undef VK_BROWSER_HOME\n#undef VK_VOLUME_MUTE\n#undef VK_VOLUME_DOWN\n#undef VK_VOLUME_UP\n#undef VK_MEDIA_NEXT_TRACK\n#undef VK_MEDIA_PREV_TRACK\n#undef VK_MEDIA_STOP\n#undef VK_MEDIA_PLAY_PAUSE\n#undef VK_LAUNCH_MAIL\n#undef VK_LAUNCH_MEDIA_SELECT\n#undef VK_LAUNCH_APP1\n#undef VK_LAUNCH_APP2\n#undef VK_OEM_1\n#undef VK_OEM_PLUS\n#undef VK_OEM_COMMA\n#undef VK_OEM_MINUS\n#undef VK_OEM_PERIOD\n#undef VK_OEM_2\n#undef VK_OEM_4\n#undef VK_OEM_5\n#undef VK_OEM_6\n#undef VK_OEM_7\n#undef VK_OEM_8\n#undef VK_OEM_102\n#undef VK_PROCESSKEY\n#undef VK_PACKET\n#undef VK_ATTN\n#undef VK_CRSEL\n#undef VK_EXSEL\n#undef VK_EREOF\n#undef VK_PLAY\n#undef VK_ZOOM\n#undef VK_NONAME\n#undef VK_PA1\n#undef VK_OEM_CLEAR\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/Import.h'\n:\n#ifndef C_LIEF_PE_IMPORT_H_\n#define C_LIEF_PE_IMPORT_H_\n\n#include <inttypes.h>\n\n#include \"LIEF/PE/enums.h\"\n#include \"LIEF/PE/ImportEntry.h\"\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct Pe_Import_t {\n  const char*        name;\n  uint32_t           forwarder_chain;\n  uint32_t           timedatestamp;\n  Pe_ImportEntry_t** entries;\n  uint32_t           import_address_table_rva;\n  uint32_t           import_lookup_table_rva;\n};\n\ntypedef struct Pe_Import_t Pe_Import_t;\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif\n\n'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.h'\n:\n#ifndef C_LIEF_H_\n#define C_LIEF_H_\n\n#include <LIEF/MachO.h>\n#include <LIEF/PE.h>\n#include <LIEF/ELF.h>\n#include <LIEF/logging.h>\n\n#endif\n",
        "gt": [
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/undef.h'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/enums.h'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/Import.h'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE/Binary.h'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/PE.h'",
            "'iNote/LIEFIntegration/LIEFIntegration/LIEF/include/LIEF/LIEF.h'"
        ]
    },
    {
        "files": [
            "'pyeos/libraries/wasm-jit/Source/Programs/Test.cpp'",
            "'pyeos/libraries/wasm-jit/Include/IR/Validate.h'",
            "'pyeos/libraries/wasm-jit/Source/Programs/CLI.h'",
            "'pyeos/libraries/wasm-jit/Include/IR/IR.h'"
        ],
        "content": "'pyeos/libraries/wasm-jit/Source/Programs/Test.cpp'\n:#include \"Inline/BasicTypes.h\"\n#include \"Inline/Serialization.h\"\n#include \"Platform/Platform.h\"\n#include \"WAST/WAST.h\"\n#include \"WAST/TestScript.h\"\n#include \"WASM/WASM.h\"\n#include \"Runtime/Runtime.h\"\n#include \"Runtime/Linker.h\"\n#include \"Runtime/Intrinsics.h\"\n\n#include \"CLI.h\"\n\n#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstdarg>\n\nusing namespace WAST;\nusing namespace IR;\nusing namespace Runtime;\n\nstruct TestScriptState\n{\n\tbool hasInstantiatedModule;\n\tModuleInstance* lastModuleInstance;\n\n\tstd::map<std::string,ModuleInstance*> moduleInternalNameToInstanceMap;\n\tstd::map<std::string,ModuleInstance*> moduleNameToInstanceMap;\n\n\tstd::vector<WAST::Error> errors;\n\n\tTestScriptState() : hasInstantiatedModule(false), lastModuleInstance(nullptr) {}\n};\n\nstruct TestScriptResolver : Resolver\n{\n\tTestScriptResolver(const TestScriptState& inState): state(inState) {}\n\tbool resolve(const std::string& moduleName,const std::string& exportName,ObjectType type,ObjectInstance*& outObject) override\n\t{\n\n\t\tif(IntrinsicResolver::singleton.resolve(moduleName,exportName,type,outObject)) { return true; }\n\n\n\t\tauto mapIt = state.moduleNameToInstanceMap.find(moduleName);\n\t\tif(mapIt != state.moduleNameToInstanceMap.end())\n\t\t{\n\t\t\toutObject = getInstanceExport(mapIt->second,exportName);\n\t\t\treturn outObject != nullptr && isA(outObject,type);\n\t\t}\n\n\t\treturn false;\n\t}\nprivate:\n\tconst TestScriptState& state;\n};\n\nvoid testErrorf(TestScriptState& state,const TextFileLocus& locus,const char* messageFormat,...)\n{\n\tva_list messageArguments;\n\tva_start(messageArguments,messageFormat);\n\tchar messageBuffer[1024];\n\tint numPrintedChars = std::vsnprintf(messageBuffer,sizeof(messageBuffer),messageFormat,messageArguments);\n\tif(numPrintedChars >= 1023 || numPrintedChars < 0) { Errors::unreachable(); }\n\tmessageBuffer[numPrintedChars] = 0;\n\tva_end(messageArguments);\n\n\tstate.errors.push_back({locus,messageBuffer});\n}\n\nvoid collectGarbage(TestScriptState& state)\n{\n\tstd::vector<ObjectInstance*> rootObjects;\n\trootObjects.push_back(asObject(state.lastModuleInstance));\n\tfor(auto& mapIt : state.moduleInternalNameToInstanceMap) { rootObjects.push_back(asObject(mapIt.second)); }\n\tfor(auto& mapIt : state.moduleNameToInstanceMap) { rootObjects.push_back(asObject(mapIt.second)); }\n\tfreeUnreferencedObjects(std::move(rootObjects));\n}\n\nModuleInstance* getModuleContextByInternalName(TestScriptState& state,const TextFileLocus& locus,const char* context,const std::string& internalName)\n{\n\n\tif(!state.hasInstantiatedModule) { testErrorf(state,locus,\"no module to use in %s\",context); return nullptr; }\n\tModuleInstance* moduleInstance = state.lastModuleInstance;\n\tif(internalName.size())\n\t{\n\t\tauto mapIt = state.moduleInternalNameToInstanceMap.find(internalName);\n\t\tif(mapIt == state.moduleInternalNameToInstanceMap.end())\n\t\t{\n\t\t\ttestErrorf(state,locus,\"unknown %s module name: %s\",context,internalName.c_str());\n\t\t\treturn nullptr;\n\t\t}\n\t\tmoduleInstance = mapIt->second;\n\t}\n\treturn moduleInstance;\n}\n\nbool processAction(TestScriptState& state,Action* action,Result& outResult)\n{\n\toutResult = Result();\n\n\tswitch(action->type)\n\t{\n\tcase ActionType::_module:\n\t{\n\t\tauto moduleAction = (ModuleAction*)action;\n\n\n\t\tstate.lastModuleInstance = nullptr;\n\t\tcollectGarbage(state);\n\n\n\t\tTestScriptResolver resolver(state);\n\t\tLinkResult linkResult = linkModule(*moduleAction->module,resolver);\n\t\tif(linkResult.success)\n\t\t{\n\t\t\tstate.hasInstantiatedModule = true;\n\t\t\tstate.lastModuleInstance = instantiateModule(*moduleAction->module,std::move(linkResult.resolvedImports));\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t\t{\n\t\t\t\ttestErrorf(\n\t\t\t\t\tstate,\n\t\t\t\t\tmoduleAction->locus,\n\t\t\t\t\t\"missing import module=\\\"%s\\\" export=\\\"%s\\\" type=\\\"%s\\\"\",\n\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\tasString(missingImport.type).c_str()\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\t\tif(moduleAction->internalModuleName.size())\n\t\t{\n\t\t\tstate.moduleInternalNameToInstanceMap[moduleAction->internalModuleName] = state.lastModuleInstance;\n\t\t}\n\n\t\treturn true;\n\t}\n\tcase ActionType::invoke:\n\t{\n\t\tauto invokeAction = (InvokeAction*)action;\n\n\n\t\tModuleInstance* moduleInstance = getModuleContextByInternalName(state,invokeAction->locus,\"invoke\",invokeAction->internalModuleName);\n\n\n\t\tif(!moduleInstance) { return false; }\n\n\n\t\tauto functionInstance = asFunctionNullable(getInstanceExport(moduleInstance,invokeAction->exportName));\n\t\tif(!functionInstance) { testErrorf(state,invokeAction->locus,\"couldn't find exported function with name: %s\",invokeAction->exportName.c_str()); return false; }\n\n\n\t\toutResult = invokeFunction(functionInstance,invokeAction->arguments);\n\n\t\treturn true;\n\t}\n\tcase ActionType::get:\n\t{\n\t\tauto getAction = (GetAction*)action;\n\n\n\t\tModuleInstance* moduleInstance = getModuleContextByInternalName(state,getAction->locus,\"get\",getAction->internalModuleName);\n\n\n\t\tif(!moduleInstance) { return false; }\n\n\n\t\tauto globalInstance = asGlobalNullable(getInstanceExport(moduleInstance,getAction->exportName));\n\t\tif(!globalInstance) { testErrorf(state,getAction->locus,\"couldn't find exported global with name: %s\",getAction->exportName.c_str()); return false; }\n\n\n\t\toutResult = getGlobalValue(globalInstance);\n\n\t\treturn true;\n\t}\n\tdefault:\n\t\tErrors::unreachable();\n\t}\n}\n\n\ntemplate<typename Float> bool isCanonicalOrArithmeticNaN(Float value,bool requireCanonical)\n{\n\tFloats::FloatComponents<Float> components;\n\tcomponents.value = value;\n\treturn components.bits.exponent == Floats::FloatComponents<Float>::maxExponentBits\n\t&& (!requireCanonical || components.bits.significand == Floats::FloatComponents<Float>::canonicalSignificand);\n}\n\nvoid processCommand(TestScriptState& state,const Command* command)\n{\n\ttry\n\t{\n\t\tswitch(command->type)\n\t\t{\n\t\tcase Command::_register:\n\t\t{\n\t\t\tauto registerCommand = (RegisterCommand*)command;\n\n\n\t\t\tModuleInstance* moduleInstance = getModuleContextByInternalName(state,registerCommand->locus,\"register\",registerCommand->internalModuleName);\n\t\t\tstate.moduleNameToInstanceMap[registerCommand->moduleName] = moduleInstance;\n\t\t\tbreak;\n\t\t}\n\t\tcase Command::action:\n\t\t{\n\t\t\tResult result;\n\t\t\tprocessAction(state,((ActionCommand*)command)->action.get(),result);\n\t\t\tbreak;\n\t\t}\n\t\tcase Command::assert_return:\n\t\t{\n\t\t\tauto assertCommand = (AssertReturnCommand*)command;\n\n\t\t\tResult actionResult;\n\t\t\tif(processAction(state,assertCommand->action.get(),actionResult)\n\t\t\t&& !areBitsEqual(actionResult,assertCommand->expectedReturn))\n\t\t\t{\n\t\t\t\ttestErrorf(state,assertCommand->locus,\"expected %s but got %s\",\n\t\t\t\t\tasString(assertCommand->expectedReturn).c_str(),\n\t\t\t\t\tasString(actionResult).c_str());\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase Command::assert_return_canonical_nan: case Command::assert_return_arithmetic_nan:\n\t\t{\n\t\t\tauto assertCommand = (AssertReturnNaNCommand*)command;\n\n\t\t\tResult actionResult;\n\t\t\tif(processAction(state,assertCommand->action.get(),actionResult))\n\t\t\t{\n\t\t\t\tconst bool requireCanonicalNaN = assertCommand->type == Command::assert_return_canonical_nan;\n\t\t\t\tconst bool isError =\n\t\t\t\t\t\tactionResult.type == ResultType::f32 ? !isCanonicalOrArithmeticNaN(actionResult.f32,requireCanonicalNaN)\n\t\t\t\t\t:\tactionResult.type == ResultType::f64 ? !isCanonicalOrArithmeticNaN(actionResult.f64,requireCanonicalNaN)\n\t\t\t\t\t:\ttrue;\n\t\t\t\tif(isError)\n\t\t\t\t{\n\t\t\t\t\ttestErrorf(state,assertCommand->locus,\n\t\t\t\t\t\trequireCanonicalNaN ? \"expected canonical float NaN but got %s\" : \"expected float NaN but got %s\",\n\t\t\t\t\t\tasString(actionResult).c_str());\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase Command::assert_trap:\n\t\t{\n\t\t\tauto assertCommand = (AssertTrapCommand*)command;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tResult actionResult;\n\t\t\t\tif(processAction(state,assertCommand->action.get(),actionResult))\n\t\t\t\t{\n\t\t\t\t\ttestErrorf(state,assertCommand->locus,\"expected trap but got %s\",asString(actionResult).c_str());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Runtime::Exception exception)\n\t\t\t{\n\t\t\t\tif(exception.cause != assertCommand->expectedCause)\n\t\t\t\t{\n\t\t\t\t\ttestErrorf(state,assertCommand->action->locus,\"expected %s trap but got %s trap\",\n\t\t\t\t\t\tdescribeExceptionCause(assertCommand->expectedCause),\n\t\t\t\t\t\tdescribeExceptionCause(exception.cause));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase Command::assert_invalid: case Command::assert_malformed:\n\t\t{\n\t\t\tauto assertCommand = (AssertInvalidOrMalformedCommand*)command;\n\t\t\tif(!assertCommand->wasInvalidOrMalformed)\n\t\t\t{\n\t\t\t\ttestErrorf(state,assertCommand->locus,\"module was %s\",\n\t\t\t\t\tassertCommand->type == Command::assert_invalid ? \"valid\" : \"well formed\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase Command::assert_unlinkable:\n\t\t{\n\t\t\tauto assertCommand = (AssertUnlinkableCommand*)command;\n\t\t\tResult result;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tTestScriptResolver resolver(state);\n\t\t\t\tLinkResult linkResult = linkModule(*assertCommand->moduleAction->module,resolver);\n\t\t\t\tif(linkResult.success)\n\t\t\t\t{\n\t\t\t\t\tinstantiateModule(*assertCommand->moduleAction->module,std::move(linkResult.resolvedImports));\n\t\t\t\t\ttestErrorf(state,assertCommand->locus,\"module was linkable\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Runtime::Exception)\n\t\t\t{\n\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t};\n\t}\n\tcatch(Runtime::Exception exception)\n\t{\n\t\ttestErrorf(state,command->locus,\"unexpected trap: %s\",describeExceptionCause(exception.cause));\n\t}\n}\n\nDEFINE_INTRINSIC_FUNCTION0(spectest,spectest_print,print,none) {}\nDEFINE_INTRINSIC_FUNCTION1(spectest,spectest_print,print,none,i32,a) { std::cout << a << \" : i32\" << std::endl; }\nDEFINE_INTRINSIC_FUNCTION1(spectest,spectest_print,print,none,i64,a) { std::cout << a << \" : i64\" << std::endl; }\nDEFINE_INTRINSIC_FUNCTION1(spectest,spectest_print,print,none,f32,a) { std::cout << a << \" : f32\" << std::endl; }\nDEFINE_INTRINSIC_FUNCTION1(spectest,spectest_print,print,none,f64,a) { std::cout << a << \" : f64\" << std::endl; }\nDEFINE_INTRINSIC_FUNCTION2(spectest,spectest_print,print,none,f64,a,f64,b) { std::cout << a << \" : f64\" << std::endl << b << \" : f64\" << std::endl; }\nDEFINE_INTRINSIC_FUNCTION2(spectest,spectest_print,print,none,i32,a,f32,b) { std::cout << a << \" : i32\" << std::endl << b << \" : f32\" << std::endl; }\nDEFINE_INTRINSIC_FUNCTION2(spectest,spectest_print,print,none,i64,a,f64,b) { std::cout << a << \" : i64\" << std::endl << b << \" : f64\" << std::endl; }\n\nDEFINE_INTRINSIC_GLOBAL(spectest,spectest_globalI32,global,i32,false,666)\nDEFINE_INTRINSIC_GLOBAL(spectest,spectest_globalI64,global,i64,false,0)\nDEFINE_INTRINSIC_GLOBAL(spectest,spectest_globalF32,global,f32,false,0.0f)\nDEFINE_INTRINSIC_GLOBAL(spectest,spectest_globalF64,global,f64,false,0.0)\n\nDEFINE_INTRINSIC_TABLE(spectest,spectest_table,table,TableType(TableElementType::anyfunc,false,SizeConstraints {10,20}))\nDEFINE_INTRINSIC_MEMORY(spectest,spectest_memory,memory,MemoryType(false,SizeConstraints {1,2}))\n\nint commandMain(int argc,char** argv)\n{\n\tif(argc != 2)\n\t{\n\t\tstd::cerr <<  \"Usage: Test in.wast\" << std::endl;\n\t\treturn EXIT_FAILURE;\n\t}\n\tconst char* filename = argv[1];\n\n\n\tLog::setCategoryEnabled(Log::Category::debug,true);\n\n\tRuntime::init();\n\n\n\tconst std::string testScriptString = loadFile(filename);\n\tif(!testScriptString.size()) { return EXIT_FAILURE; }\n\n\n\tTestScriptState testScriptState;\n\tstd::vector<std::unique_ptr<Command>> testCommands;\n\n\n\tWAST::parseTestCommands(testScriptString.c_str(),testScriptString.size(),testCommands,testScriptState.errors);\n\tif(!testScriptState.errors.size())\n\t{\n\n\t\tfor(auto& command : testCommands)\n\t\t{\n\t\t\tprocessCommand(testScriptState,command.get());\n\t\t}\n\t}\n\n\tif(testScriptState.errors.size())\n\t{\n\n\t\tfor(auto& error : testScriptState.errors)\n\t\t{\n\t\t\tstd::cerr << filename << \":\" << error.locus.describe() << \": \" << error.message.c_str() << std::endl;\n\t\t\tstd::cerr << error.locus.sourceLine << std::endl;\n\t\t\tstd::cerr << std::setw(error.locus.column(8)) << \"^\" << std::endl;\n\t\t}\n\n\t\tstd::cerr << filename << \": testing failed!\" << std::endl;\n\t\treturn EXIT_FAILURE;\n\t}\n\telse\n\t{\n\t\tstd::cout << filename << \": all tests passed.\" << std::endl;\n\t\treturn EXIT_SUCCESS;\n\t}\n}\n\n'pyeos/libraries/wasm-jit/Include/IR/Validate.h'\n:#pragma once\n\n#include \"IR.h\"\n#include \"IR/Operators.h\"\n\n#include <string>\n\nnamespace IR\n{\n\tstruct Module;\n\tstruct FunctionDef;\n\n\tstruct ValidationException\n\t{\n\t\tstd::string message;\n\t\tValidationException(std::string&& inMessage): message(inMessage) {}\n\t};\n\n\tstruct CodeValidationStreamImpl;\n\n\tstruct CodeValidationStream\n\t{\n\t\tIR_API CodeValidationStream(const Module& module,const FunctionDef& function);\n\t\tIR_API ~CodeValidationStream();\n\n\t\tIR_API void finish();\n\n\t\t#define VISIT_OPCODE(_,name,nameString,Imm,...) IR_API void name(Imm imm = {});\n\t\tENUM_OPERATORS(VISIT_OPCODE)\n\t\t#undef VISIT_OPCODE\n\n\tprivate:\n\t\tCodeValidationStreamImpl* impl;\n\t};\n\n\ttemplate<typename InnerStream>\n\tstruct CodeValidationProxyStream\n\t{\n\t\tCodeValidationProxyStream(const Module& module,const FunctionDef& function,InnerStream& inInnerStream)\n\t\t: codeValidationStream(module,function)\n\t\t, innerStream(inInnerStream)\n\t\t{}\n\n\t\tvoid finishValidation() { codeValidationStream.finish(); }\n\n\t\t#define VISIT_OPCODE(_,name,nameString,Imm,...) \\\n\t\t\tvoid name(Imm imm = {}) \\\n\t\t\t{ \\\n\t\t\t\tcodeValidationStream.name(imm); \\\n\t\t\t\tinnerStream.name(imm); \\\n\t\t\t}\n\t\tENUM_OPERATORS(VISIT_OPCODE)\n\t\t#undef VISIT_OPCODE\n\n\tprivate:\n\n\t\tCodeValidationStream codeValidationStream;\n\t\tInnerStream& innerStream;\n\t};\n\n\tIR_API void validateDefinitions(const IR::Module& module);\n}\n\n'pyeos/libraries/wasm-jit/Source/Programs/CLI.h'\n:#pragma once\n\n#include \"Inline/BasicTypes.h\"\n#include \"Inline/Floats.h\"\n#include \"Inline/Timing.h\"\n#include \"WAST/WAST.h\"\n#include \"WASM/WASM.h\"\n#include \"IR/Module.h\"\n#include \"IR/Validate.h\"\n#include \"Runtime/Runtime.h\"\n\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <cstring>\n\ninline std::string loadFile(const char* filename)\n{\n\tTiming::Timer timer;\n\tstd::ifstream stream(filename,std::ios::binary | std::ios::ate);\n\tif(!stream.is_open())\n\t{\n\t\tstd::cerr << \"Failed to open \" << filename << \": \" << std::strerror(errno) << std::endl;\n\t\treturn std::string();\n\t}\n\tstd::string data;\n\tdata.resize((unsigned int)stream.tellg());\n\tstream.seekg(0);\n\tstream.read(const_cast<char*>(data.data()),data.size());\n\tstream.close();\n\tTiming::logRatePerSecond(\"loaded file\",timer,data.size() / 1024.0 / 1024.0,\"MB\");\n\treturn data;\n}\n\ninline bool loadTextModule(const char* filename,const std::string& wastString,IR::Module& outModule)\n{\n\tstd::vector<WAST::Error> parseErrors;\n\tWAST::parseModule(wastString.c_str(),wastString.size(),outModule,parseErrors);\n\tif(!parseErrors.size()) { return true; }\n\telse\n\t{\n\n\t\tstd::cerr << \"Error parsing WebAssembly text file:\" << std::endl;\n\t\tfor(auto& error : parseErrors)\n\t\t{\n\t\t\tstd::cerr << filename << \":\" << error.locus.describe() << \": \" << error.message.c_str() << std::endl;\n\t\t\tstd::cerr << error.locus.sourceLine << std::endl;\n\t\t\tstd::cerr << std::setw(error.locus.column(8)) << \"^\" << std::endl;\n\t\t}\n\t\treturn false;\n\t}\n}\n\ninline bool loadTextModule(const char* filename,IR::Module& outModule)\n{\n\n\tauto wastBytes = loadFile(filename);\n\tif(!wastBytes.size()) { return false; }\n\tconst std::string wastString = std::move(wastBytes);\n\n\treturn loadTextModule(filename,wastString,outModule);\n}\n\ninline bool loadBinaryModule(const std::string& wasmBytes,IR::Module& outModule)\n{\n\tTiming::Timer loadTimer;\n\n\n\ttry\n\t{\n\t\tSerialization::MemoryInputStream stream((const U8*)wasmBytes.data(),wasmBytes.size());\n\t\tWASM::serialize(stream,outModule);\n\t}\n\tcatch(Serialization::FatalSerializationException exception)\n\t{\n\t\tstd::cerr << \"Error deserializing WebAssembly binary file:\" << std::endl;\n\t\tstd::cerr << exception.message << std::endl;\n\t\treturn false;\n\t}\n\tcatch(IR::ValidationException exception)\n\t{\n\t\tstd::cerr << \"Error validating WebAssembly binary file:\" << std::endl;\n\t\tstd::cerr << exception.message << std::endl;\n\t\treturn false;\n\t}\n\tcatch(std::bad_alloc)\n\t{\n\t\tstd::cerr << \"Memory allocation failed: input is likely malformed\" << std::endl;\n\t\treturn false;\n\t}\n\n\tTiming::logRatePerSecond(\"Loaded WASM\",loadTimer,wasmBytes.size()/1024.0/1024.0,\"MB\");\n\treturn true;\n}\n\ninline bool loadBinaryModule(const char* wasmFilename,IR::Module& outModule)\n{\n\n\tauto wasmBytes = loadFile(wasmFilename);\n\tif(!wasmBytes.size()) { return false; }\n\n\treturn loadBinaryModule(wasmBytes,outModule);\n}\n\ninline bool loadModule(const char* filename,IR::Module& outModule)\n{\n\n\tauto fileBytes = loadFile(filename);\n\tif(!fileBytes.size()) { return false; }\n\n\n\tif(*(U32*)fileBytes.data() == 0x6d736100) { return loadBinaryModule(fileBytes,outModule); }\n\telse\n\t{\n\n\t\tauto wastString = std::move(fileBytes);\n\t\treturn loadTextModule(filename,wastString,outModule);\n\t}\n}\n\ninline bool saveBinaryModule(const char* wasmFilename,const IR::Module& module)\n{\n\tTiming::Timer saveTimer;\n\n\tstd::vector<U8> wasmBytes;\n\ttry\n\t{\n\n\t\tSerialization::ArrayOutputStream stream;\n\t\tWASM::serialize(stream,module);\n\t\twasmBytes = stream.getBytes();\n\t}\n\tcatch(Serialization::FatalSerializationException exception)\n\t{\n\t\tstd::cerr << \"Error serializing WebAssembly binary file:\" << std::endl;\n\t\tstd::cerr << exception.message << std::endl;\n\t\treturn false;\n\t}\n\n\tTiming::logRatePerSecond(\"Saved WASM\",saveTimer,wasmBytes.size()/1024.0/1024.0,\"MB\");\n\n\n\tstd::ofstream outputStream(wasmFilename,std::ios::binary);\n\toutputStream.write((char*)wasmBytes.data(),wasmBytes.size());\n\toutputStream.close();\n\n\treturn true;\n}\n\ninline bool endsWith(const char *str, const char *suffix)\n{\n\tif(!str || !suffix) { return false; }\n\tUptr lenstr = strlen(str);\n\tUptr lensuffix = strlen(suffix);\n\tif(lenstr < lensuffix) { return false; }\n\treturn (strncmp(str+lenstr-lensuffix, suffix, lensuffix) == 0);\n}\n\nint commandMain(int argc,char** argv);\n\nint main(int argc,char** argv)\n{\n\ttry\n\t{\n\t\treturn commandMain(argc,argv);\n\t}\n\tcatch(IR::ValidationException exception)\n\t{\n\t\tstd::cerr << \"Failed to validate module: \" << exception.message << std::endl;\n\t\treturn EXIT_FAILURE;\n\t}\n\tcatch(Runtime::Exception exception)\n\t{\n\t\tstd::cerr << \"Runtime exception: \" << describeExceptionCause(exception.cause) << std::endl;\n\t\tfor(auto calledFunction : exception.callStack) { std::cerr << \"  \" << calledFunction << std::endl; }\n\t\treturn EXIT_FAILURE;\n\t}\n\tcatch(Serialization::FatalSerializationException exception)\n\t{\n\t\tstd::cerr << \"Fatal serialization exception: \" << exception.message << std::endl;\n\t\treturn EXIT_FAILURE;\n\t}\n}\n'pyeos/libraries/wasm-jit/Include/IR/IR.h'\n:#pragma once\n\n#include \"Platform/Platform.h\"\n\n#ifndef IR_API\n\t#define IR_API DLL_IMPORT\n#endif\n\nnamespace IR\n{\n\tenum { maxMemoryPages = (Uptr)65536 };\n\tenum { numBytesPerPage = (Uptr)65536 };\n\tenum { numBytesPerPageLog2 = (Uptr)16 };\n\n\tenum { requireSharedFlagForAtomicOperators = false };\n}\n",
        "gt": [
            "'pyeos/libraries/wasm-jit/Include/IR/IR.h'",
            "'pyeos/libraries/wasm-jit/Include/IR/Validate.h'",
            "'pyeos/libraries/wasm-jit/Source/Programs/CLI.h'",
            "'pyeos/libraries/wasm-jit/Source/Programs/Test.cpp'"
        ]
    },
    {
        "files": [
            "'LittleEngineVk/engine/include/le/graphics/mesh.hpp'",
            "'LittleEngineVk/tools/importer/src/lib/src/importer.cpp'",
            "'LittleEngineVk/engine/include/le/resources/skeleton_asset.hpp'",
            "'LittleEngineVk/engine/include/le/graphics/animation/animation.hpp'"
        ],
        "content": "'LittleEngineVk/engine/include/le/graphics/mesh.hpp'\n:#pragma once\n#include <le/core/not_null.hpp>\n#include <le/graphics/animation/animation.hpp>\n#include <le/graphics/material.hpp>\n#include <le/graphics/primitive.hpp>\n#include <le/node/node_tree.hpp>\n\nnamespace le::graphics {\nstruct MeshPrimitive {\n\tNotNull<Primitive const*> primitive;\n\tPtr<Material const> material{};\n};\n\nstruct Skeleton {\n\tNodeTree joint_tree{};\n\tstd::vector<glm::mat4> inverse_bind_matrices{};\n\tstd::vector<Id<Node>> ordered_joint_ids{};\n\tstd::vector<Ptr<Animation const>> animations{};\n};\n\nstruct Mesh {\n\tstd::vector<MeshPrimitive> primitives{};\n\tPtr<Skeleton const> skeleton{};\n};\n}\n\n'LittleEngineVk/tools/importer/src/lib/src/importer.cpp'\n:#include <le/core/enumerate.hpp>\n#include <le/core/ptr.hpp>\n#include <le/core/visitor.hpp>\n#include <le/core/zip_ranges.hpp>\n#include <le/error.hpp>\n#include <le/importer/importer.hpp>\n#include <le/node/node_tree_serializer.hpp>\n#include <le/resources/animation_asset.hpp>\n#include <le/resources/bin_data.hpp>\n#include <le/resources/material_asset.hpp>\n#include <le/resources/mesh_asset.hpp>\n#include <le/resources/primitive_asset.hpp>\n#include <le/resources/skeleton_asset.hpp>\n#include <le/resources/texture_asset.hpp>\n#include <algorithm>\n#include <format>\n#include <fstream>\n#include <iostream>\n\nnamespace le::importer {\nnamespace {\ntemplate <typename T>\nauto print_asset_list(std::vector<T> const& list, std::string_view const type) {\n\tif (!list.empty()) {\n\t\tstd::cout << std::format(\"{}:\\n\", type);\n\t\tfor (auto const [asset, index] : enumerate(list)) {\n\t\t\tauto const name = asset.name.empty() ? std::string_view{\"(unnamed)\"} : asset.name;\n\t\t\tstd::cout << std::format(\"[{}] {}\\n\", index, name);\n\t\t}\n\t\tstd::cout << \"\\n\";\n\t}\n}\n}\n\nnamespace {\ntemplate <glm::length_t Dim, typename T>\nconstexpr auto to_glm_vec(std::span<T const, Dim> in) {\n\tauto ret = glm::vec<static_cast<glm::length_t>(Dim), T>{};\n\tret.x = in[0];\n\tif constexpr (Dim > 1) { ret.y = Dim > 1 ? in[1] : T{}; }\n\tif constexpr (Dim > 2) { ret.z = Dim > 2 ? in[2] : T{}; }\n\tif constexpr (Dim > 3) { ret.w = Dim > 3 ? in[3] : T{}; }\n\treturn ret;\n}\n\n[[nodiscard]] auto to_geometry(gltf2cpp::Geometry const& in) -> graphics::Geometry {\n\tauto ret = graphics::Geometry{};\n\tauto const has_colour = !in.colors.empty() && in.colors.front().size() == in.positions.size();\n\tauto const has_uv = !in.tex_coords.empty() && in.tex_coords.front().size() == in.positions.size();\n\tauto const has_normal = in.normals.size() == in.positions.size();\n\tfor (std::size_t i = 0; i < in.positions.size(); ++i) {\n\t\tauto vertex = graphics::Vertex{.position = to_glm_vec<3, float>(in.positions[i])};\n\t\tif (has_colour) { vertex.rgba = glm::vec4{to_glm_vec<3, float>(in.colors[0][i]), 1.0f}; }\n\t\tif (has_uv) { vertex.uv = to_glm_vec<2, float>(in.tex_coords[0][i]); }\n\t\tif (has_normal) { vertex.normal = to_glm_vec<3, float>(in.normals[i]); }\n\t\tret.vertices.push_back(vertex);\n\t}\n\tret.indices = in.indices;\n\tif (!in.joints.empty() && !in.weights.empty()) {\n\t\tfor (auto const [joint, weight] : zip_ranges(in.joints[0], in.weights[0])) {\n\t\t\tret.bones.push_back(graphics::Bone{\n\t\t\t\t.joint = to_glm_vec<4, std::uint32_t>(joint),\n\t\t\t\t.weight = to_glm_vec<4, float>(weight),\n\t\t\t});\n\t\t}\n\t}\n\treturn ret;\n}\n\n[[nodiscard]] auto to_mat4(gltf2cpp::Mat4x4 const& in) -> glm::mat4 {\n\tauto ret = glm::mat4{};\n\n\tstd::memcpy(&ret[0], &in[0], sizeof(ret[0]));\n\tstd::memcpy(&ret[1], &in[1], sizeof(ret[1]));\n\tstd::memcpy(&ret[2], &in[2], sizeof(ret[2]));\n\tstd::memcpy(&ret[3], &in[3], sizeof(ret[3]));\n\treturn ret;\n}\n\n[[nodiscard]] auto to_transform(gltf2cpp::Transform const& transform) -> Transform {\n\tauto ret = Transform{};\n\tauto visitor = Visitor{\n\t\t[&ret](gltf2cpp::Trs const& trs) {\n\t\t\tret.set_position({trs.translation[0], trs.translation[1], trs.translation[2]});\n\t\t\tret.set_orientation({trs.rotation[3], trs.rotation[0], trs.rotation[1], trs.rotation[2]});\n\t\t\tret.set_scale({trs.scale[0], trs.scale[1], trs.scale[2]});\n\t\t},\n\t\t[&ret](gltf2cpp::Mat4x4 const& mat) { ret.decompose(to_mat4(mat)); },\n\t};\n\tstd::visit(visitor, transform);\n\treturn ret;\n}\n\nstruct NestedIndex {\n\tstd::size_t index{};\n\tNestedIndex const* next{};\n};\n\nstruct Traverse {\n\tstd::span<gltf2cpp::Node const> nodes{};\n\n\ttemplate <typename FuncT>\n\tauto operator()(std::span<std::size_t const> roots, FuncT func) const {\n\t\tfor (auto const index : roots) {\n\t\t\tif (!traverse(index, func)) { return; }\n\t\t}\n\t}\n\n\ttemplate <typename FuncT>\n\t[[nodiscard]] auto traverse(std::size_t index, FuncT func) const -> bool {\n\t\tif (!keep_traversing(index, func)) { return false; }\n\t\tauto const& node = nodes[index];\n\t\treturn std::ranges::all_of(node.children, [&](std::size_t index) { return traverse(index, func); });\n\t}\n\n\ttemplate <typename FuncT>\n\t[[nodiscard]] auto keep_traversing(std::size_t index, FuncT func) const -> bool {\n\t\tauto const& node = nodes[index];\n\t\tif constexpr (std::same_as<std::invoke_result_t<FuncT, gltf2cpp::Node, std::size_t>, bool>) {\n\t\t\treturn std::invoke(func, node, index);\n\t\t} else {\n\t\t\tstd::invoke(func, node, index);\n\t\t\treturn true;\n\t\t}\n\t}\n};\n\n[[nodiscard]] auto make_node_tree(std::span<gltf2cpp::Node const> nodes, std::span<std::size_t const> roots) -> NodeTree {\n\tauto map = NodeTree::DataMap{};\n\tauto const func = [&](gltf2cpp::Node const& in_node, [[maybe_unused]] std::size_t index) {\n\t\tauto parent = std::optional<Id<Node>>{};\n\t\tif (in_node.parent) { parent = *in_node.parent; }\n\t\tauto node = NodeTree::Data{};\n\t\tnode.id = index;\n\t\tif (in_node.parent) { node.parent = *in_node.parent; }\n\t\tnode.name = in_node.name;\n\t\tnode.transform = to_transform(in_node.transform);\n\t\tnode.children = {in_node.children.begin(), in_node.children.end()};\n\t\tmap.insert_or_assign(index, std::move(node));\n\t};\n\tTraverse{nodes}(roots, func);\n\tauto ret = NodeTree{};\n\tret.import_tree(std::move(map), {roots.begin(), roots.end()});\n\treturn ret;\n}\n\n[[nodiscard]] constexpr auto to_interpolation(gltf2cpp::Interpolation in) -> graphics::Interpolation {\n\tswitch (in) {\n\tcase gltf2cpp::Interpolation::eCubicSpline: std::cout << \"CubicSpline interpolation not supported\\n\"; return graphics::Interpolation::eLinear;\n\tdefault:\n\tcase gltf2cpp::Interpolation::eLinear: return graphics::Interpolation::eLinear;\n\tcase gltf2cpp::Interpolation::eStep: return graphics::Interpolation::eStep;\n\t}\n}\n\ntemplate <typename T>\n[[nodiscard]] auto to_interpolator(std::span<float const> times, std::span<T const> values, gltf2cpp::Interpolation interpolation)\n\t-> graphics::Interpolator<T> {\n\tassert(times.size() == values.size());\n\tauto ret = graphics::Interpolator<T>{};\n\tfor (auto [t, v] : zip_ranges(times, values)) { ret.keyframes.push_back({v, Duration{t}}); }\n\tret.interpolation = to_interpolation(interpolation);\n\treturn ret;\n}\n\nstruct Exporter {\n\n\tfs::path const& data_root;\n\n\tfs::path const& prefix;\n\n\tfs::path const& gltf_dir;\n\n\tgltf2cpp::Root const& root;\n\tbool force{};\n\n\t[[nodiscard]] static auto make_filename(std::string_view name, std::string_view fallback, NestedIndex index, std::string_view suffix = {}) -> std::string {\n\t\tif (name.empty() || name == \"(Unnamed)\") { name = fallback; }\n\t\tauto ret = std::format(\"{}_{}\", name, index.index);\n\t\tfor (auto const* next = index.next; next != nullptr; next = next->next) { std::format_to(std::back_inserter(ret), \"_{}\", next->index); }\n\t\tret += suffix;\n\t\treturn ret;\n\t}\n\n\t[[nodiscard]] static auto write_file(std::span<std::byte const> bytes, fs::path const& path) -> bool {\n\t\tfs::create_directories(path.parent_path());\n\t\tauto file = std::ofstream{path, std::ios::binary};\n\t\tif (!file) { return false; }\n\n\t\treturn static_cast<bool>(file.write(reinterpret_cast<char const*>(bytes.data()), static_cast<std::streamsize>(bytes.size_bytes())));\n\t}\n\n\t[[nodiscard]] static auto export_failed(std::string_view asset_type, fs::path const& uri, std::size_t index) -> Error {\n\t\treturn Error{std::format(\"failed to export {} [{}] at [{}]\", asset_type, uri.generic_string(), index)};\n\t}\n\n\t[[nodiscard]] static auto exported(fs::path const& uri, char prefix = '-') -> std::string {\n\t\treturn std::format(\"{} [{}] exported\\n\", prefix, uri.generic_string());\n\t}\n\n\t[[nodiscard]] static constexpr auto to_str(gltf2cpp::Wrap const wrap) {\n\t\tswitch (wrap) {\n\t\tcase gltf2cpp::Wrap::eClampEdge: return \"clamp_edge\";\n\t\tdefault: return \"repeat\";\n\t\t}\n\t}\n\n\t[[nodiscard]] static auto to_sampler(gltf2cpp::Sampler const& sampler) -> dj::Json {\n\t\tstatic constexpr auto from_wrap = [](gltf2cpp::Wrap const wrap) { return wrap == gltf2cpp::Wrap::eClampEdge ? \"clamp_edge\" : \"repeat\"; };\n\t\tstatic constexpr auto from_filter = [](gltf2cpp::Filter const filter) {\n\t\t\tswitch (filter) {\n\t\t\tcase gltf2cpp::Filter::eNearestMipmapLinear:\n\t\t\tcase gltf2cpp::Filter::eNearestMipmapNearest:\n\t\t\tcase gltf2cpp::Filter::eNearest: return \"nearest\";\n\t\t\tdefault: return \"linear\";\n\t\t\t}\n\t\t};\n\n\t\tauto ret = dj::Json{};\n\t\tret[\"wrap_s\"] = from_wrap(sampler.wrap_s);\n\t\tret[\"wrap_t\"] = from_wrap(sampler.wrap_t);\n\t\tif (sampler.min_filter) { ret[\"min\"] = from_filter(*sampler.min_filter); }\n\t\tif (sampler.mag_filter) { ret[\"mag\"] = from_filter(*sampler.mag_filter); }\n\n\t\treturn ret;\n\t}\n\n\t[[nodiscard]] auto should_skip(fs::path const& uri, fs::path& out_dst) const -> bool {\n\t\tout_dst = data_root / uri;\n\t\tif (fs::exists(out_dst)) {\n\t\t\tif (force) {\n\t\t\t\tif (!fs::remove(out_dst)) { throw Error{std::format(\"failed to remove existing asset: '{}'\", uri.generic_string())}; }\n\t\t\t\tstd::cout << std::format(\"- removed: [{}]\\n\", uri.generic_string());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstd::cout << std::format(\"- skipped: [{}]\\n\", uri.generic_string());\n\t\t\treturn true;\n\t\t}\n\t\tfs::create_directories(out_dst.parent_path());\n\t\treturn false;\n\t}\n\n\t[[nodiscard]] auto write_image_bytes(std::span<std::byte const> bytes, fs::path const& uri) const -> bool {\n\t\tauto dst = fs::path{};\n\t\tif (should_skip(uri, dst)) { return true; }\n\t\treturn write_file(bytes, dst);\n\t}\n\n\t[[nodiscard]] auto copy_image_file(fs::path const& src, fs::path const& uri) const -> bool {\n\t\tauto dst = fs::path{};\n\t\tif (should_skip(uri, dst)) { return true; }\n\t\treturn fs::copy_file(src, dst);\n\t}\n\n\t[[nodiscard]] auto export_image(std::size_t index) const -> fs::path {\n\t\tauto const& asset = root.images[index];\n\t\tif (asset.source_filename.empty()) {\n\t\t\tauto image_uri = prefix / \"textures\" / make_filename(asset.name, \"texture\", {index});\n\t\t\tif (!write_image_bytes(asset.bytes.span(), image_uri)) { throw export_failed(\"image\", image_uri, index); }\n\t\t\treturn image_uri;\n\t\t}\n\t\tauto src_filename = fs::path{asset.source_filename}.filename();\n\t\tauto filename = make_filename(src_filename.stem().string(), {}, {index}, src_filename.extension().string());\n\t\tauto uri = prefix / \"textures\" / filename;\n\t\tif (!copy_image_file(gltf_dir / asset.source_filename, uri)) { throw export_failed(\"image\", uri, index); }\n\t\tstd::cout << exported(uri);\n\t\treturn uri;\n\t}\n\n\t[[nodiscard]] auto export_texture(std::size_t index) const -> fs::path {\n\t\tauto const& asset = root.textures[index];\n\t\tauto const& image_asset = root.images[asset.source];\n\t\tauto uri = prefix / \"textures\" / make_filename(asset.name, fs::path{image_asset.source_filename}.stem().string(), {index}, \".json\");\n\t\tauto dst = fs::path{};\n\t\tif (should_skip(uri, dst)) { return uri; }\n\n\t\tauto const image_uri = export_image(asset.source);\n\t\tauto json = dj::Json{};\n\t\tjson[\"asset_type\"] = TextureAsset::type_name_v;\n\t\tjson[\"image\"] = image_uri.generic_string();\n\t\tjson[\"colour_space\"] = asset.linear ? \"linear\" : \"sRGB\";\n\n\t\tif (asset.sampler) {\n\t\t\tauto const& sampler = root.samplers[*asset.sampler];\n\t\t\tjson[\"sampler\"] = to_sampler(sampler);\n\t\t}\n\t\tif (!json.to_file(dst.string().c_str())) { throw export_failed(\"texture\", uri, index); }\n\t\tstd::cout << exported(uri);\n\t\treturn uri;\n\t}\n\n\t[[nodiscard]] auto export_material(std::size_t index, bool skinned) const -> fs::path {\n\t\tauto const& asset = root.materials[index];\n\t\tauto uri = prefix / \"materials\" / make_filename(asset.name, \"material\", {index}, \".json\");\n\t\tauto dst = fs::path{};\n\t\tif (should_skip(uri, dst)) { return uri; }\n\n\t\tauto json = dj::Json{};\n\t\tjson[\"asset_type\"] = MaterialAsset::type_name_v;\n\t\tjson[\"material_type\"] = skinned ? graphics::SkinnedMaterial::material_type_v : graphics::LitMaterial::material_type_v;\n\t\tif (asset.pbr.base_color_texture) { json[\"base_colour\"] = export_texture(asset.pbr.base_color_texture->texture).generic_string(); }\n\t\tif (asset.pbr.metallic_roughness_texture) {\n\t\t\tjson[\"metallic_roughness\"] = export_texture(asset.pbr.metallic_roughness_texture->texture).generic_string();\n\t\t}\n\t\tif (asset.emissive_texture) { json[\"emissive\"] = export_texture(asset.emissive_texture->texture).generic_string(); }\n\t\tfor (auto const i : asset.pbr.base_color_factor) { json[\"albedo\"].push_back(i); }\n\t\tfor (auto const i : asset.emissive_factor) { json[\"emissive_factor\"].push_back(i); }\n\t\tjson[\"metallic\"] = asset.pbr.metallic_factor;\n\t\tjson[\"roughness\"] = asset.pbr.roughness_factor;\n\t\tjson[\"alpha_cutoff\"] = asset.alpha_cutoff;\n\t\tswitch (asset.alpha_mode) {\n\t\tcase gltf2cpp::AlphaMode::eBlend: json[\"alpha_mode\"] = \"blend\"; break;\n\t\tcase gltf2cpp::AlphaMode::eMask: json[\"blend_mode\"] = \"mask\"; break;\n\t\tcase gltf2cpp::AlphaMode::eOpaque: json[\"blend_mode\"] = \"opaque\"; break;\n\t\tdefault: break;\n\t\t}\n\t\tif (!json.to_file(dst.string().c_str())) { throw export_failed(\"material\", uri, index); }\n\t\tstd::cout << exported(uri);\n\t\treturn uri;\n\t}\n\n\t[[nodiscard]] auto export_geometry(gltf2cpp::Geometry const& in, std::size_t imesh, std::size_t igeometry) const -> fs::path {\n\t\tauto const index_geometry = NestedIndex{.index = igeometry};\n\t\tauto uri = prefix / \"geometries\" / make_filename(\"geometry\", {}, {.index = imesh, .next = &index_geometry}, \".bin\");\n\t\tauto dst = fs::path{};\n\t\tif (should_skip(uri, dst)) { return uri; }\n\n\t\tauto const geometry = to_geometry(in);\n\t\tauto bytes = std::vector<std::byte>{};\n\t\tPrimitiveAsset::bin_pack_to(bytes, geometry);\n\t\tif (!write_file(bytes, dst.string())) { throw export_failed(\"geometry\", uri, igeometry); }\n\t\tstd::cout << exported(uri);\n\t\treturn uri;\n\t}\n\n\t[[nodiscard]] auto make_animation_channel(gltf2cpp::Animation::Channel const& in, Id<Node> node, gltf2cpp::Animation const& animation) const\n\t\t-> std::optional<graphics::Animation::Channel> {\n\t\tauto const& sampler = animation.samplers[in.sampler];\n\t\tauto ret = graphics::Animation::Channel{node};\n\t\tauto const& input = root.accessors[sampler.input];\n\t\tassert(input.type == gltf2cpp::Accessor::Type::eScalar && input.component_type == gltf2cpp::ComponentType::eFloat);\n\t\tauto times = std::get<gltf2cpp::Accessor::Float>(input.data).span();\n\t\tauto const& output = root.accessors[sampler.output];\n\t\tassert(output.component_type == gltf2cpp::ComponentType::eFloat);\n\t\tauto const values = std::get<gltf2cpp::Accessor::Float>(output.data).span();\n\t\tauto const translation_or_scale = [&]() {\n\t\t\tassert(output.type == gltf2cpp::Accessor::Type::eVec3);\n\t\t\tauto vec = std::vector<glm::vec3>(values.size() / 3);\n\t\t\tstd::memcpy(vec.data(), values.data(), values.size_bytes());\n\t\t\treturn vec;\n\t\t};\n\t\tswitch (in.target.path) {\n\t\tcase gltf2cpp::Animation::Path::eTranslation: {\n\t\t\tauto vec = translation_or_scale();\n\t\t\tret.storage = graphics::Animation::Translate{to_interpolator<glm::vec3>(times, vec, sampler.interpolation)};\n\t\t\tbreak;\n\t\t}\n\t\tcase gltf2cpp::Animation::Path::eScale: {\n\t\t\tauto const vec = translation_or_scale();\n\t\t\tret.storage = graphics::Animation::Scale{to_interpolator<glm::vec3>(times, vec, sampler.interpolation)};\n\t\t\tbreak;\n\t\t}\n\t\tcase gltf2cpp::Animation::Path::eRotation: {\n\t\t\tassert(output.type == gltf2cpp::Accessor::Type::eVec4);\n\t\t\tauto vec = std::vector<glm::quat>(values.size() / 4);\n\t\t\tstd::memcpy(vec.data(), values.data(), values.size_bytes());\n\t\t\tret.storage = graphics::Animation::Rotate{to_interpolator<glm::quat>(times, vec, sampler.interpolation)};\n\t\t\tbreak;\n\t\t}\n\t\tdefault: std::cout << \" - unsupported animation path\\n\"; return {};\n\t\t}\n\t\treturn ret;\n\t}\n\n\t[[nodiscard]] auto export_animation(NodeLocator node_locator, std::size_t index) const -> fs::path {\n\t\tauto const& asset = root.animations[index];\n\t\tauto out_animation = graphics::Animation{};\n\t\tfor (auto const [in_channel, channel_index] : enumerate(asset.channels)) {\n\t\t\tif (!in_channel.target.node) { continue; }\n\t\t\tauto const* node = node_locator.find(*in_channel.target.node);\n\t\t\tif (node == nullptr) {\n\t\t\t\tthrow Error{std::format(\"dangling joint [{}] on animation [{}] channel [{}]\", *in_channel.target.node, index, channel_index)};\n\t\t\t}\n\t\t\tauto out_channel = make_animation_channel(in_channel, node->id(), asset);\n\t\t\tif (!out_channel) { continue; }\n\t\t\tout_animation.channels.push_back(std::move(*out_channel));\n\t\t}\n\t\tif (out_animation.channels.empty()) {\n\t\t\tstd::cout << std::format(\"- no channels in animation [{}]\\n\", index);\n\t\t\treturn {};\n\t\t}\n\n\t\tauto uri = prefix / \"animations\" / make_filename(asset.name, \"animation\", {index}, \".bin\");\n\t\tauto dst = fs::path{};\n\t\tif (should_skip(uri, dst)) { return uri; }\n\t\tauto bytes = std::vector<std::byte>{};\n\t\tAnimationAsset::bin_pack_to(bytes, out_animation);\n\t\tif (!write_file(bytes, dst)) { throw Error{std::format(\"failed to export animation [{}]\", index)}; }\n\n\t\tstd::cout << exported(uri);\n\t\treturn uri;\n\t}\n\n\t[[nodiscard]] auto is_node_in_hierarchy(gltf2cpp::Node const& node, std::size_t index) const -> bool {\n\t\treturn std::ranges::any_of(node.children, [&](std::size_t child_index) {\n\t\t\tif (child_index == index) { return true; }\n\t\t\treturn is_node_in_hierarchy(root.nodes[child_index], index);\n\t\t});\n\t}\n\n\t[[nodiscard]] auto find_scene_with_node(std::size_t const index) const -> Ptr<gltf2cpp::Scene const> {\n\t\tfor (auto const& scene : root.scenes) {\n\t\t\tfor (auto const root_node : scene.root_nodes) {\n\t\t\t\tif (is_node_in_hierarchy(root.nodes[root_node], index)) { return &scene; }\n\t\t\t}\n\t\t}\n\t\treturn {};\n\t}\n\n\t[[nodiscard]] auto get_root_node_indices(std::size_t skin_index) const -> std::span<std::size_t const> {\n\t\tauto const& skin = root.skins[skin_index];\n\t\tif (root.scenes.empty()) {\n\t\t\tthrow Error{std::format(\"cannot export skeleton [{}]: GLTF skin missing skeleton property, and GLTF data has no scenes\", skin_index)};\n\t\t}\n\n\t\tauto ret = std::span<std::size_t const>{};\n\t\tif (skin.skeleton) {\n\t\t\tauto const* scene = find_scene_with_node(*skin.skeleton);\n\t\t\tif (scene == nullptr) { throw Error{std::format(\"failed to locate scene with skeleton node [{}]\", *skin.skeleton)}; }\n\t\t\tret = scene->root_nodes;\n\t\t} else {\n\t\t\tret = root.scenes.front().root_nodes;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t[[nodiscard]] auto export_skeleton(std::size_t skin_index) const -> fs::path {\n\t\tauto const& skin = root.skins[skin_index];\n\t\tauto uri = prefix / \"skeletons\" / make_filename(skin.name, \"skeleton\", {skin_index}, \".json\");\n\t\tauto dst = fs::path{};\n\t\tif (should_skip(uri, dst)) { return uri; }\n\n\t\tauto const root_node_indices = get_root_node_indices(skin_index);\n\t\tauto skeleton = graphics::Skeleton{.joint_tree = make_node_tree(root.nodes, root_node_indices)};\n\n\t\tfor (auto const in_joint_id : skin.joints) {\n\t\t\tauto const* node = skeleton.joint_tree.find(in_joint_id);\n\t\t\tif (node == nullptr) {\n\n\t\t\t\tthrow Error{std::format(\"dangling joint index: [{}]\", in_joint_id)};\n\t\t\t}\n\t\t\tassert(in_joint_id == node->id());\n\t\t\tskeleton.ordered_joint_ids.push_back(node->id());\n\t\t}\n\t\tif (skin.inverse_bind_matrices) {\n\t\t\tauto const ibm = root.accessors[*skin.inverse_bind_matrices].to_mat4();\n\t\t\tassert(ibm.size() >= skin.joints.size());\n\t\t\tskeleton.inverse_bind_matrices.reserve(ibm.size());\n\t\t\tfor (auto const& mat : ibm) {\n\t\t\t\tskeleton.inverse_bind_matrices.push_back(to_mat4(mat));\n\t\t\t\tif (skeleton.inverse_bind_matrices.size() == skin.joints.size()) { break; }\n\t\t\t}\n\t\t} else {\n\t\t\tskeleton.inverse_bind_matrices = std::vector<glm::mat4>(skin.joints.size(), glm::identity<glm::mat4x4>());\n\t\t}\n\t\tauto json = dj::Json{};\n\t\tjson[\"asset_type\"] = SkeletonAsset::type_name_v;\n\t\tNodeTree::Serializer::serialize(json[\"joint_tree\"], skeleton.joint_tree);\n\t\tfor (auto const joint_id : skeleton.ordered_joint_ids) { json[\"ordered_joint_ids\"].push_back(joint_id.value()); }\n\t\tfor (auto const& ibm : skeleton.inverse_bind_matrices) { io::to_json(json[\"inverse_bind_matrices\"].push_back({}), ibm); }\n\t\tauto node_locator = NodeLocator{skeleton.joint_tree};\n\t\tfor (std::size_t index = 0; index < root.animations.size(); ++index) {\n\t\t\tjson[\"animations\"].push_back(export_animation(node_locator, index).generic_string());\n\t\t}\n\n\t\tif (!json.to_file(dst.string().c_str())) { throw Error{std::format(\"failed to save skeleton (skin) [{}]\", skin_index)}; }\n\n\t\tstd::cout << exported(uri);\n\t\treturn uri;\n\t}\n\n\t[[nodiscard]] auto make_mesh(bool skinned, std::size_t index) const -> dj::Json {\n\t\tauto const& asset = root.meshes[index];\n\t\tauto ret = dj::Json{};\n\t\tret[\"asset_type\"] = MeshAsset::type_name_v;\n\t\tret[\"mesh_type\"] = skinned ? \"skinned\" : \"static\";\n\t\tfor (auto const [primitive, iprim] : enumerate(asset.primitives)) {\n\t\t\tauto& out_primitive = ret[\"primitives\"].push_back({});\n\t\t\tout_primitive[\"geometry\"] = export_geometry(primitive.geometry, index, iprim).generic_string();\n\t\t\tif (primitive.material) { out_primitive[\"material\"] = export_material(*primitive.material, skinned).generic_string(); }\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t[[nodiscard]] auto export_mesh(std::size_t index, Ptr<gltf2cpp::Node const> node) const -> fs::path {\n\t\tauto const& asset = root.meshes[index];\n\t\tauto uri = prefix / make_filename(asset.name, \"mesh\", {index}, \".json\");\n\t\tauto dst = fs::path{};\n\t\tif (should_skip(uri, dst)) { return uri; }\n\n\t\tauto json = make_mesh(node != nullptr && node->skin.has_value(), index);\n\t\tif (node != nullptr && node->skin) { json[\"skeleton\"] = export_skeleton(*node->skin).generic_string(); }\n\n\t\tif (!json.to_file(dst.string().c_str())) { throw export_failed(\"mesh\", uri, index); }\n\n\t\tstd::cout << exported(uri, '=');\n\t\treturn uri;\n\t}\n};\n\n[[nodiscard]] auto build_mesh_list(gltf2cpp::Root const& root) -> MeshList {\n\tauto ret = MeshList{};\n\tfor (auto const [mesh, index] : enumerate(root.meshes)) {\n\t\tif (mesh.primitives.empty()) { continue; }\n\t\tif (mesh.primitives.front().geometry.joints.empty()) {\n\t\t\tret.static_meshes.push_back(index);\n\t\t} else {\n\t\t\tret.skinned_meshes.push_back(index);\n\t\t}\n\t}\n\treturn ret;\n}\n}\n\nauto Importer::setup(Input input) -> bool {\n\tm_input = std::move(input);\n\tm_input.data_root = fs::absolute(m_input.data_root);\n\tm_gltf_dir = m_input.gltf_path.parent_path();\n\tm_export_prefix = m_input.uri_prefix / m_input.gltf_path.stem();\n\n\tauto mesh_id = std::size_t{};\n\n\tif (m_input.verbose) {\n\t\tstd::cout << std::format(\" - data root: '{}'\\n - gltf path: '{}'\\n - export prefix: '{}'\\n - force: '{}'\\n - mesh: [{}]\\n\",\n\t\t\t\t\t\t\t\t m_input.data_root.generic_string(), m_input.gltf_path.generic_string(), m_export_prefix.string(), m_input.force, mesh_id);\n\t}\n\n\tm_root = gltf2cpp::parse(m_input.gltf_path.string().c_str());\n\tif (!m_root) {\n\t\tstd::cerr << std::format(\"failed to parse '{}'\\n\", m_input.gltf_path.generic_string());\n\t\treturn false;\n\t}\n\n\tif (m_root.meshes.empty()) {\n\t\tstd::cout << std::format(\"'{}' has no meshes\\n\", m_input.gltf_path.generic_string());\n\t\treturn true;\n\t}\n\n\tm_mesh_list = build_mesh_list(m_root);\n\n\treturn true;\n}\n\nauto Importer::import_mesh(std::size_t mesh_id) -> std::optional<Uri> {\n\tif (mesh_id >= m_root.meshes.size()) {\n\t\tstd::cerr << std::format(\"invalid mesh - '{}'\\n\", mesh_id);\n\t\treturn {};\n\t}\n\n\tfs::create_directories(m_input.data_root / m_export_prefix);\n\tauto const exporter = Exporter{m_input.data_root, m_export_prefix, m_gltf_dir, m_root, m_input.force};\n\tauto const* node = Ptr<gltf2cpp::Node const>{};\n\tif (std::ranges::find(m_mesh_list.skinned_meshes, mesh_id) != m_mesh_list.skinned_meshes.end()) {\n\t\tfor (auto const& in_node : m_root.nodes) {\n\t\t\tif (!in_node.mesh || *in_node.mesh != mesh_id) { continue; }\n\t\t\tassert(in_node.skin);\n\t\t\tnode = &in_node;\n\t\t\tbreak;\n\t\t}\n\t\tif (node == nullptr) { throw Error{std::format(\"failed to find skin for skinned mesh [{}]\", mesh_id)}; }\n\t}\n\tstd::cout << std::format(\"\\nexporting mesh: [{}] {}...\\n\", mesh_id, m_root.meshes[mesh_id].name);\n\treturn exporter.export_mesh(mesh_id, node).generic_string();\n}\n\nauto Importer::print_assets() const -> void {\n\tauto const print_meshes = [this](std::span<std::size_t const> indices, std::string_view const type) {\n\t\tif (!indices.empty()) {\n\t\t\tstd::cout << std::format(\"{}:\\n\", type);\n\t\t\tfor (auto const index : indices) {\n\t\t\t\tauto const& mesh = m_root.meshes[index];\n\t\t\t\tauto const name = mesh.name.empty() ? std::string_view{\"(unnamed)\"} : mesh.name;\n\t\t\t\tstd::cout << std::format(\"[{}] {}\\n\", index, name);\n\t\t\t}\n\t\t\tstd::cout << \"\\n\";\n\t\t}\n\t};\n\n\tprint_meshes(m_mesh_list.static_meshes, \"static meshes\");\n\tprint_meshes(m_mesh_list.skinned_meshes, \"skinned meshes\");\n\tprint_asset_list(m_root.skins, \"skeletons\");\n\tprint_asset_list(m_root.materials, \"materials\");\n\tprint_asset_list(m_root.textures, \"textures\");\n\tprint_asset_list(m_root.animations, \"skeletal animations\");\n}\n}\n\n'LittleEngineVk/engine/include/le/resources/skeleton_asset.hpp'\n:#pragma once\n#include <le/graphics/mesh.hpp>\n#include <le/resources/asset.hpp>\n\nnamespace le {\nclass SkeletonAsset : public Asset {\n  public:\n\tstatic constexpr std::string_view type_name_v{\"SkeletonAsset\"};\n\n\t[[nodiscard]] auto type_name() const -> std::string_view final { return type_name_v; }\n\t[[nodiscard]] auto try_load(Uri const& uri) -> bool final;\n\n\tgraphics::Skeleton skeleton{};\n};\n}\n\n'LittleEngineVk/engine/include/le/graphics/animation/animation.hpp'\n:#pragma once\n#include <le/core/transform.hpp>\n#include <le/graphics/animation/interpolator.hpp>\n#include <le/node/node_tree.hpp>\n#include <variant>\n\nnamespace le::graphics {\nstruct Animation {\n\tstruct Translate : Interpolator<glm::vec3> {};\n\tstruct Rotate : Interpolator<glm::quat> {};\n\tstruct Scale : Interpolator<glm::vec3> {};\n\n\tstruct Channel {\n\t\tId<Node> joint_id;\n\t\tstd::variant<Translate, Rotate, Scale> storage{};\n\n\t\tauto update(NodeLocator node_locator, Duration time) const -> void;\n\t\t[[nodiscard]] auto duration() const -> Duration;\n\t};\n\n\tstd::vector<Channel> channels{};\n\n\t[[nodiscard]] auto duration() const -> Duration;\n\tauto update(NodeLocator node_locator, Duration time) const -> void;\n};\n}\n",
        "gt": [
            "'LittleEngineVk/engine/include/le/graphics/animation/animation.hpp'",
            "'LittleEngineVk/engine/include/le/graphics/mesh.hpp'",
            "'LittleEngineVk/engine/include/le/resources/skeleton_asset.hpp'",
            "'LittleEngineVk/tools/importer/src/lib/src/importer.cpp'"
        ]
    },
    {
        "files": [
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/WireBase.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/SocketWire.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/SocketWire.cpp'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IWire.h'"
        ],
        "content": "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/WireBase.h'\n:#ifndef RD_CPP_WIREBASE_H\n#define RD_CPP_WIREBASE_H\n\n#include \"reactive/Property.h\"\n#include \"base/IWire.h\"\n#include \"protocol/MessageBroker.h\"\n\n#include <rd_framework_export.h>\n\nnamespace rd\n{\nclass RD_FRAMEWORK_API WireBase : public IWire\n{\nprotected:\n\tIScheduler* scheduler = nullptr;\n\n\tMessageBroker message_broker;\n\npublic:\n\n\texplicit WireBase(IScheduler* scheduler) : scheduler(scheduler), message_broker(scheduler)\n\t{\n\t}\n\n\tvirtual ~WireBase() = default;\n\n\n\tvirtual void advise(Lifetime lifetime, RdReactiveBase const* entity) const override;\n};\n}\n\n#endif\n\n'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/SocketWire.h'\n:#ifndef RD_CPP_SOCKETWIRE_H\n#define RD_CPP_SOCKETWIRE_H\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable:4251)\n#endif\n\n#include \"scheduler/base/IScheduler.h\"\n#include \"base/WireBase.h\"\n#include \"ByteBufferAsyncProcessor.h\"\n#include \"PkgInputStream.h\"\n\n#include <string>\n#include <array>\n#include <condition_variable>\n\n#include <rd_framework_export.h>\n\nclass CSimpleSocket;\nclass CActiveSocket;\nclass CPassiveSocket;\n\nnamespace rd\n{\nclass RD_FRAMEWORK_API SocketWire\n{\n\tstatic std::chrono::milliseconds timeout;\n\npublic:\n\tclass RD_FRAMEWORK_API Base : public WireBase\n\t{\n\tprotected:\n\t\tstatic std::shared_ptr<spdlog::logger> logger;\n\n\t\tstd::timed_mutex lock;\n\t\tmutable std::mutex socket_send_lock;\n\t\tmutable std::mutex wire_send_lock;\n\n\t\tstd::thread thread{};\n\n\t\tstd::string id;\n\t\tIScheduler* scheduler = nullptr;\n\t\tstd::shared_ptr<CSimpleSocket> socket_provider;\n\n\t\tstd::shared_ptr<CActiveSocket> socket;\n\n\t\tmutable std::condition_variable socket_send_var;\n\t\tmutable ByteBufferAsyncProcessor async_send_buffer{id + \"-AsyncSendProcessor\",\n\t\t\t[this](Buffer::ByteArray const& it, sequence_number_t seqn) -> bool { return this->send0(it, seqn); }};\n\n\t\tstatic constexpr size_t RECEIVE_BUFFER_SIZE = 1u << 16;\n\t\tmutable std::array<Buffer::word_t, RECEIVE_BUFFER_SIZE> receiver_buffer{};\n\t\tmutable decltype(receiver_buffer)::iterator lo = receiver_buffer.begin(), hi = receiver_buffer.begin();\n\n\t\tstatic constexpr int32_t ACK_MESSAGE_LENGTH = -1;\n\t\tstatic constexpr int32_t PING_MESSAGE_LENGTH = -2;\n\t\tstatic constexpr int32_t PACKAGE_HEADER_LENGTH = sizeof(ACK_MESSAGE_LENGTH) + sizeof(sequence_number_t);\n\t\tmutable Buffer ack_buffer{PACKAGE_HEADER_LENGTH};\n\n\n\t\tmutable int32_t current_timestamp = 0;\n\n\n\t\tmutable int32_t counterpart_timestamp = 0;\n\n\n\t\tmutable int32_t counterpart_acknowledge_timestamp = 0;\n\n\t\tmutable Buffer ping_pkg_header{PACKAGE_HEADER_LENGTH};\n\n\t\tmutable sequence_number_t max_received_seqn = 0;\n\t\tmutable Buffer send_package_header{PACKAGE_HEADER_LENGTH};\n\n\t\tstatic constexpr int32_t CHUNK_SIZE = 16370;\n\t\tmutable int32_t sz = -1;\n\t\tmutable RdId::hash_t id_ = -1;\n\t\tmutable PkgInputStream receive_pkg{[this]() -> int32_t { return this->read_package(); }};\n\n\t\tmutable Buffer message{CHUNK_SIZE};\n\n\t\tbool read_from_socket(Buffer::word_t* res, int32_t msglen) const;\n\n\t\ttemplate <typename T>\n\t\tbool read_integral_from_socket(T& x) const\n\t\t{\n\t\t\treturn read_from_socket(reinterpret_cast<Buffer::word_t*>(&x), sizeof(T));\n\t\t}\n\n\t\tbool read_data_from_socket(Buffer::word_t* data, size_t len) const\n\t\t{\n\t\t\treturn read_from_socket(reinterpret_cast<Buffer::word_t*>(data), static_cast<int32_t>(len));\n\t\t}\n\n\t\tvoid set_socket_provider(std::shared_ptr<CActiveSocket> new_socket);\n\n\t\tCSimpleSocket* get_socket_provider() const;\n\n\tpublic:\n\t\tstatic constexpr int32_t MaximumHeartbeatDelay = 3;\n\t\tstd::chrono::milliseconds heartBeatInterval = std::chrono::milliseconds(500);\n\n\n\n\t\tBase(std::string id, Lifetime lifetime, IScheduler* scheduler);\n\n\t\tvirtual ~Base() override;\n\n\n\n\t\tstd::pair<int, sequence_number_t> read_header() const;\n\n\t\tint32_t read_package() const;\n\n\t\tbool read_and_dispatch_message() const;\n\n\t\tvoid receiverProc() const;\n\n\t\tbool send0(Buffer::ByteArray const& msg, sequence_number_t seqn) const;\n\n\t\tvoid send(RdId const& rd_id, std::function<void(Buffer& buffer)> writer) const override;\n\n\t\tstatic bool connection_established(int32_t timestamp, int32_t acknowledged_timestamp);\n\n\t\tstd::future<void> start_heartbeat(Lifetime lifetime);\n\n\t\tvoid ping() const;\n\n\t\tbool send_ack(sequence_number_t seqn) const;\n\n\t\tbool try_shutdown_connection() const;\n\n\tprivate:\n\t\tLifetimeDefinition lifetimeDef;\n\t};\n\n\tclass RD_FRAMEWORK_API Client : public Base\n\t{\n\tpublic:\n\t\tuint16_t port = 0;\n\n\n\n\t\tClient(Lifetime parentLifetime, IScheduler* scheduler, uint16_t port = 0, const std::string& id = \"ClientSocket\");\n\n\t\tvirtual ~Client() override;\n\n\n\t\tstd::condition_variable_any cv;\n\tprivate:\n\t\tLifetimeDefinition clientLifetimeDefinition;\n\t};\n\n\tclass RD_FRAMEWORK_API Server : public Base\n\t{\n\tpublic:\n\t\tuint16_t port = 0;\n\n\t\tstd::unique_ptr<CPassiveSocket> ss;\n\n\n\n\t\tServer(Lifetime lifetime, IScheduler* scheduler, uint16_t port = 0, const std::string& id = \"ServerSocket\");\n\n\t\tvirtual ~Server() override;\n\n\tprivate:\n\t\tLifetimeDefinition serverLifetimeDefinition;\n\t};\n};\n}\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\n#endif\n\n'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/SocketWire.cpp'\n:#include \"wire/SocketWire.h\"\n\n#include <util/thread_util.h>\n\n#include \"spdlog/sinks/stdout_color_sinks.h\"\n\n#include <SimpleSocket.h>\n#include <ActiveSocket.h>\n#include <PassiveSocket.h>\n\n#include <utility>\n#include <thread>\n#include <csignal>\n\nnamespace rd\n{\nstd::shared_ptr<spdlog::logger> SocketWire::Base::logger =\n\tspdlog::stderr_color_mt<spdlog::synchronous_factory>(\"wireLog\", spdlog::color_mode::automatic);\n\nstd::chrono::milliseconds SocketWire::timeout = std::chrono::milliseconds(500);\n\nconstexpr int32_t SocketWire::Base::ACK_MESSAGE_LENGTH;\nconstexpr int32_t SocketWire::Base::PING_MESSAGE_LENGTH;\nconstexpr int32_t SocketWire::Base::PACKAGE_HEADER_LENGTH;\n\nSocketWire::Base::Base(std::string id, Lifetime parentLifetime, IScheduler* scheduler)\n\t: WireBase(scheduler), id(std::move(id)), scheduler(scheduler), lifetimeDef(parentLifetime)\n{\n\tasync_send_buffer.pause(\"initial\");\n\tasync_send_buffer.start();\n\tping_pkg_header.write_integral(PING_MESSAGE_LENGTH);\n}\n\nSocketWire::Base::~Base()\n{\n\tif (!lifetimeDef.is_terminated())\n\t{\n\t\tlifetimeDef.terminate();\n\t}\n}\n\nvoid SocketWire::Base::receiverProc() const\n{\n\twhile (!lifetimeDef.lifetime->is_terminated())\n\t{\n\t\ttry\n\t\t{\n\t\t\tif (!socket_provider->IsSocketValid())\n\t\t\t{\n\t\t\t\tlogger->debug(\"{}: stop receive messages because socket disconnected\", this->id);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!read_and_dispatch_message())\n\t\t\t{\n\t\t\t\tlogger->debug(\"{}: connection was gracefully shutdown\", id);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcatch (std::exception const& ex)\n\t\t{\n\t\t\tlogger->error(\"{} caught processing | {}\", this->id, ex.what());\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nbool SocketWire::Base::send0(Buffer::ByteArray const& msg, sequence_number_t seqn) const\n{\n\ttry\n\t{\n\t\tstd::lock_guard<decltype(socket_send_lock)> guard(socket_send_lock);\n\n\t\tint32_t msglen = static_cast<int32_t>(msg.size());\n\n\t\tsend_package_header.rewind();\n\t\tsend_package_header.write_integral(msglen);\n\t\tsend_package_header.write_integral(seqn);\n\n\t\tRD_ASSERT_THROW_MSG(\n\t\t\tsocket_provider->Send(send_package_header.data(), send_package_header.get_position()) == PACKAGE_HEADER_LENGTH,\n\t\t\tthis->id +\n\t\t\t\t\": failed to send header over the network\"\n\t\t\t\t\", reason: \" +\n\t\t\t\tsocket_provider->DescribeError())\n\n\t\tRD_ASSERT_THROW_MSG(socket_provider->Send(msg.data(), msglen) == msglen, this->id +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \": failed to send package over the network\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \", reason: \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t socket_provider->DescribeError());\n\t\tlogger->info(\"{}: were sent {} bytes\", this->id, msglen);\n\n\t\treturn true;\n\t}\n\tcatch (std::exception const& e)\n\t{\n\n\t\tlogger->warn(\"Send0 failed due to: | {}\", e.what());\n\t\treturn false;\n\t}\n}\n\nvoid SocketWire::Base::send(RdId const& rd_id, std::function<void(Buffer& buffer)> writer) const\n{\n\tRD_ASSERT_MSG(!rd_id.isNull(), \"{}: id mustn't be null\");\n\n\tBuffer local_send_buffer;\n\tlocal_send_buffer.write_integral<int32_t>(0);\n\trd_id.write(local_send_buffer);\n\tlocal_send_buffer.write_integral<int16_t>(0);\n\twriter(local_send_buffer);\n\n\tint32_t len = static_cast<int32_t>(local_send_buffer.get_position());\n\n\tlocal_send_buffer.rewind();\n\tlocal_send_buffer.write_integral<int32_t>(len - 4);\n\tlocal_send_buffer.set_position(len);\n\tasync_send_buffer.put(std::move(local_send_buffer).getRealArray());\n}\n\nvoid SocketWire::Base::set_socket_provider(std::shared_ptr<CActiveSocket> new_socket)\n{\n\t{\n\t\tstd::lock_guard<decltype(socket_send_lock)> guard(socket_send_lock);\n\t\tsocket_provider = std::move(new_socket);\n\t\tsocket_send_var.notify_all();\n\t}\n\t{\n\t\tstd::lock_guard<decltype(lock)> guard(lock);\n\t\tif (lifetimeDef.lifetime->is_terminated())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\n\tauto heartbeat = LifetimeDefinition::use([this](Lifetime heartbeatLifetime) {\n\t\tconst auto heartbeat = start_heartbeat(heartbeatLifetime).share();\n\n\t\tasync_send_buffer.resume();\n\n\t\tconnected.set(true);\n\n\t\treceiverProc();\n\n\t\tconnected.set(false);\n\n\t\tasync_send_buffer.pause(\"Disconnected\");\n\n\t\treturn heartbeat;\n\t});\n\tconst auto status = heartbeat.wait_for(timeout);\n\n\tlogger->debug(\"{}: waited for heartbeat to stop with status: {}\", this->id, static_cast<uint32_t>(status));\n\n\tif (!socket_provider->IsSocketValid())\n\t{\n\t\tlogger->debug(\"{}: socket was already shut down\", this->id);\n\t}\n\telse if (!socket_provider->Shutdown(CSimpleSocket::Both))\n\t{\n\n\t\tlogger->warn(\"{}: possibly double close after disconnect\", this->id);\n\t}\n}\n\nbool SocketWire::Base::connection_established(int32_t timestamp, int32_t notion_timestamp)\n{\n\treturn timestamp - notion_timestamp <= MaximumHeartbeatDelay;\n}\n\nstd::future<void> SocketWire::Base::start_heartbeat(Lifetime lifetime)\n{\n\treturn std::async([this, lifetime] {\n\t\twhile (!lifetime->is_terminated())\n\t\t{\n\t\t\tstd::this_thread::sleep_for(heartBeatInterval);\n\t\t\tping();\n\t\t}\n\t});\n}\n\nbool SocketWire::Base::read_from_socket(Buffer::word_t* res, int32_t msglen) const\n{\n\tint32_t ptr = 0;\n\twhile (ptr < msglen)\n\t{\n\t\tRD_ASSERT_MSG(hi >= lo, \"hi >= lo\")\n\n\t\tint32_t rest = msglen - ptr;\n\t\tint32_t available = static_cast<int32_t>(hi - lo);\n\n\t\tif (available > 0)\n\t\t{\n\t\t\tint32_t copylen = (std::min)(rest, available);\n\t\t\tstd::copy(lo, lo + copylen, res + ptr);\n\t\t\tlo += copylen;\n\t\t\tptr += copylen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (hi == receiver_buffer.end())\n\t\t\t{\n\t\t\t\thi = lo = receiver_buffer.begin();\n\t\t\t}\n\t\t\tlogger->info(\"{}: receive started\", this->id);\n\t\t\tint32_t read = socket_provider->Receive(static_cast<int32_t>(receiver_buffer.end() - hi), &*hi);\n\t\t\tif (read == -1)\n\t\t\t{\n\t\t\t\tauto err = socket_provider->GetSocketError();\n\t\t\t\tif (err == CSimpleSocket::SocketInvalidSocket)\n\t\t\t\t{\n\t\t\t\t\tlogger->info(\"{}: socket was shut down for receiving\", this->id);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tlogger->error(\"{}: error has occurred while receiving\", this->id);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (read == 0)\n\t\t\t{\n\t\t\t\tlogger->info(\"{}: socket was shut down for receiving\", this->id);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\thi += read;\n\t\t\tif (read > 0)\n\t\t\t{\n\t\t\t\tlogger->info(\"{}: receive finished: {} bytes read\", this->id, read);\n\t\t\t}\n\t\t}\n\t}\n\tif (ptr != msglen)\n\t{\n\t\tlogger->error(\"read invalid number of bytes from socket, expected: {}, actual: {}\", msglen, ptr);\n\t\tassert(false);\n\t}\n\treturn true;\n}\n\nstatic constexpr std::pair<int, sequence_number_t> INVALID_HEADER = std::make_pair(-1, -1);\n\nstd::pair<int, sequence_number_t> SocketWire::Base::read_header() const\n{\n\tint32_t len = 0;\n\tsequence_number_t seqn = 0;\n\twhile (true)\n\t{\n\t\tif (!read_integral_from_socket(len))\n\t\t{\n\t\t\treturn INVALID_HEADER;\n\t\t}\n\t\tif (len == PING_MESSAGE_LENGTH)\n\t\t{\n\t\t\tint32_t received_timestamp = 0;\n\t\t\tint32_t received_counterpart_timestamp = 0;\n\t\t\tif (!read_integral_from_socket(received_timestamp))\n\t\t\t{\n\t\t\t\treturn INVALID_HEADER;\n\t\t\t}\n\t\t\tif (!read_integral_from_socket(received_counterpart_timestamp))\n\t\t\t{\n\t\t\t\treturn INVALID_HEADER;\n\t\t\t}\n\n\t\t\tcounterpart_timestamp = received_timestamp;\n\t\t\tcounterpart_acknowledge_timestamp = received_counterpart_timestamp;\n\n\t\t\tif ((connection_established(current_timestamp, counterpart_acknowledge_timestamp)))\n\t\t\t{\n\t\t\t\tif (!heartbeatAlive.get())\n\t\t\t\t{\n\t\t\t\t\tlogger->trace(\n\t\t\t\t\t\t\"Connection is alive after receiving PING {}: \"\n\t\t\t\t\t\t\"received_timestamp: {}, \"\n\t\t\t\t\t\t\"received_counterpart_timestamp: {}, \"\n\t\t\t\t\t\t\"current_timestamp: {}, \"\n\t\t\t\t\t\t\"counterpart_timestamp: {}, \"\n\t\t\t\t\t\t\"counterpart_acknowledge_timestamp: {}, \",\n\t\t\t\t\t\tid, received_timestamp, received_counterpart_timestamp, current_timestamp, counterpart_timestamp,\n\t\t\t\t\t\tcounterpart_acknowledge_timestamp);\n\t\t\t\t}\n\t\t\t\theartbeatAlive.set(true);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!read_integral_from_socket(seqn))\n\t\t{\n\t\t\treturn INVALID_HEADER;\n\t\t}\n\n\t\tif (len == ACK_MESSAGE_LENGTH)\n\t\t{\n\t\t\tasync_send_buffer.acknowledge(seqn);\n\t\t\tcontinue;\n\t\t}\n\t\treturn std::make_pair(len, seqn);\n\t}\n}\n\nint32_t SocketWire::Base::read_package() const\n{\n\treceive_pkg.rewind();\n\n\tconst auto pair = read_header();\n\tif (pair == INVALID_HEADER)\n\t{\n\t\tlogger->debug(\"{}: failed to read header\", this->id);\n\t\treturn -1;\n\t}\n\tconst auto len = pair.first;\n\tconst auto seqn = pair.second;\n\n\tlogger->debug(\"{}: read len={}, seqn={}, max_received_seqn={}\", this->id, len, seqn, max_received_seqn);\n\n\treceive_pkg.require_available(len);\n\tif (!read_data_from_socket(receive_pkg.data(), len))\n\t{\n\t\tlogger->debug(\"{}: failed to read package\", this->id);\n\t\treturn -1;\n\t}\n\tsend_ack(seqn);\n\tif (seqn <= max_received_seqn && seqn != 1)\n\t{\n\t\treturn true;\n\t}\n\tmax_received_seqn = seqn;\n\n\tlogger->info(\"{}: was received package, bytes={}, seqn={}\", this->id, len, seqn);\n\treturn len;\n}\n\nbool SocketWire::Base::read_and_dispatch_message() const\n{\n\tsz = (sz == -1 ? receive_pkg.read_integral<int32_t>() : sz);\n\tif (sz == -1)\n\t{\n\t\tlogger->debug(\"{}: sz == -1\", this->id);\n\t\treturn false;\n\t}\n\tid_ = (id_ == -1 ? receive_pkg.read_integral<RdId::hash_t>() : id_);\n\tif (id_ == -1)\n\t{\n\t\tlogger->error(\"id == -1\");\n\t\treturn false;\n\t}\n\tlogger->trace(\"{}: message info: sz={}, id={}\", this->id, sz, id_);\n\tconst RdId rd_id{id_};\n\tsz -= 8;\n\tmessage.require_available(sz);\n\n\tif (!receive_pkg.read(message.data() + message.get_position(), sz - message.get_position()))\n\t{\n\t\tlogger->error(\"{}: constructing message failed\", this->id);\n\t\treturn false;\n\t}\n\n\tlogger->debug(\"{}: message received\", this->id);\n\tmessage_broker.dispatch(rd_id, std::move(message));\n\tlogger->debug(\"{}: message dispatched\", this->id);\n\n\tsz = -1;\n\tid_ = -1;\n\tmessage.rewind();\n\treturn true;\n\n}\n\nCSimpleSocket* SocketWire::Base::get_socket_provider() const\n{\n\treturn socket_provider.get();\n}\n\nvoid SocketWire::Base::ping() const\n{\n\tif (!connection_established(current_timestamp, counterpart_acknowledge_timestamp))\n\t{\n\t\tif (heartbeatAlive.get())\n\t\t{\n\t\t\tlogger->trace(\n\t\t\t\t\"Disconnect detected while sending PING {}: \"\n\t\t\t\t\"current_timestamp: {}, \"\n\t\t\t\t\"counterpart_timestamp: {}, \"\n\t\t\t\t\"counterpart_acknowledge_timestamp: {}\",\n\t\t\t\tthis->id, current_timestamp, counterpart_timestamp, counterpart_acknowledge_timestamp);\n\t\t}\n\t\theartbeatAlive.set(false);\n\t}\n\ttry\n\t{\n\t\tping_pkg_header.set_position(sizeof(PING_MESSAGE_LENGTH));\n\t\tping_pkg_header.write_integral(current_timestamp);\n\t\tping_pkg_header.write_integral(counterpart_timestamp);\n\t\t{\n\t\t\tstd::lock_guard<decltype(socket_send_lock)> guard(socket_send_lock);\n\t\t\tint32_t sent = socket_provider->Send(ping_pkg_header.data(), ping_pkg_header.get_position());\n\t\t\tif (sent == 0 && !socket_provider->IsSocketValid())\n\t\t\t{\n\t\t\t\tlogger->debug(\"{}: failed to send ping over the network, reason: socket was shut down for sending\", this->id);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tRD_ASSERT_THROW_MSG(sent == PACKAGE_HEADER_LENGTH,\n\t\t\t\tfmt::format(\"{}: failed to send ping over the network, reason: {}\", this->id, socket_provider->DescribeError()))\n\t\t}\n\n\t\t++current_timestamp;\n\t}\n\tcatch (std::exception const& e)\n\t{\n\t\tlogger->debug(\"{}: exception raised during PING | {}\", this->id, e.what());\n\t}\n}\n\nbool SocketWire::Base::send_ack(sequence_number_t seqn) const\n{\n\tlogger->trace(\"{} send ack {}\", id, seqn);\n\ttry\n\t{\n\t\tack_buffer.rewind();\n\t\tack_buffer.write_integral(ACK_MESSAGE_LENGTH);\n\t\tack_buffer.write_integral(seqn);\n\t\t{\n\t\t\tstd::lock_guard<decltype(socket_send_lock)> guard(socket_send_lock);\n\t\t\tRD_ASSERT_THROW_MSG(socket_provider->Send(ack_buffer.data(), ack_buffer.get_position()) == PACKAGE_HEADER_LENGTH,\n\t\t\t\tthis->id +\n\t\t\t\t\t\": failed to send ack over the network\"\n\t\t\t\t\t\", reason: \" +\n\t\t\t\t\tsocket_provider->DescribeError())\n\t\t}\n\t\treturn true;\n\t}\n\tcatch (std::exception const& e)\n\t{\n\t\tlogger->warn(\"{}: exception raised during ACK, seqn = {} | {}\", id, seqn, e.what());\n\t\treturn false;\n\t}\n}\n\nbool SocketWire::Base::try_shutdown_connection() const\n{\n\tauto s = get_socket_provider();\n\tif (s == nullptr)\n\t\treturn false;\n\n\treturn s->Shutdown(CSimpleSocket::Both);\n}\n\nSocketWire::Client::Client(Lifetime parentLifetime, IScheduler* scheduler, uint16_t port, const std::string& id)\n\t: Base(id, parentLifetime, scheduler), port(port), clientLifetimeDefinition(parentLifetime)\n{\n\tLifetime lifetime = clientLifetimeDefinition.lifetime;\n\tthread = std::thread([this, lifetime]() mutable {\n\t\trd::util::set_thread_name(this->id.empty() ? \"SocketWire::Client Thread\" : this->id.c_str());\n\n\t\ttry\n\t\t{\n\t\t\tlogger->info(\"{}: started, port: {}.\", this->id, this->port);\n\n\t\t\twhile (!lifetime->is_terminated())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tsocket = std::make_shared<CActiveSocket>();\n\t\t\t\t\tRD_ASSERT_THROW_MSG(socket->Initialize(),\n\t\t\t\t\t\tfmt::format(\"{}: failed to init ActiveSocket, reason: {}\", this->id, socket->DescribeError()));\n\t\t\t\t\tRD_ASSERT_THROW_MSG(socket->DisableNagleAlgoritm(),\n\t\t\t\t\t\tfmt::format(\"{}: failed to DisableNagleAlgoritm, reason: {}\", this->id, socket->DescribeError()));\n\n\n\n\n\n\n\n\t\t\t\t\tlogger->info(\"{}: connecting 127.0.0.1: {}\", this->id, this->port);\n\t\t\t\t\tRD_ASSERT_THROW_MSG(socket->Open(\"127.0.0.1\", this->port),\n\t\t\t\t\t\tfmt::format(\"{}: failed to open ActiveSocket, reason: {}\", this->id, socket->DescribeError()));\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::lock_guard<decltype(lock)> guard(lock);\n\t\t\t\t\t\tif (lifetime->is_terminated())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!socket->Close())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlogger->error(\"{} failed to close socket, reason: {}\", this->id, socket->DescribeError());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tset_socket_provider(socket);\n\t\t\t\t}\n\t\t\t\tcatch (std::exception const& e)\n\t\t\t\t{\n\t\t\t\t\tlogger->debug(\"{}: connection error for port {} ({}).\", this->id, this->port, e.what());\n\n\t\t\t\t\tstd::lock_guard<decltype(lock)> guard(lock);\n\t\t\t\t\tbool should_reconnect = false;\n\t\t\t\t\tif (!lifetime->is_terminated())\n\t\t\t\t\t{\n\t\t\t\t\t\tcv.wait_for(lock, timeout);\n\t\t\t\t\t\tshould_reconnect = !lifetime->is_terminated();\n\t\t\t\t\t}\n\t\t\t\t\tif (should_reconnect)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (std::exception const& e)\n\t\t{\n\t\t\tlogger->info(\"{}: closed with exception: {}\", this->id, e.what());\n\t\t}\n\t\tlogger->info(\"{}: terminated, port: {}.\", this->id, this->port);\n\t});\n\n\tlifetime->add_action([this]() {\n\t\tlogger->info(\"{}: starts terminating lifetime\", this->id);\n\n\t\tconst bool send_buffer_stopped = async_send_buffer.stop(timeout);\n\t\tlogger->debug(\"{}: send buffer stopped, success: {}\", this->id, send_buffer_stopped);\n\n\t\t{\n\t\t\tstd::lock_guard<decltype(lock)> guard(lock);\n\t\t\tlogger->debug(\"{}: closing socket\", this->id);\n\n\t\t\tif (socket != nullptr)\n\t\t\t{\n\t\t\t\tif (!socket->Close())\n\t\t\t\t{\n\t\t\t\t\tlogger->error(\"{}: failed to close socket\", this->id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcv.notify_all();\n\n\t\tlogger->debug(\"{}: waiting for receiver thread\", this->id);\n\t\tlogger->debug(\"{}: is thread joinable? {}\", this->id, thread.joinable());\n\t\tthread.join();\n\t\tlogger->info(\"{}: termination finished\", this->id);\n\t});\n}\n\nSocketWire::Client::~Client()\n{\n\tif (!clientLifetimeDefinition.is_terminated())\n\t{\n\t\tclientLifetimeDefinition.terminate();\n\t}\n}\n\nSocketWire::Server::Server(Lifetime parentLifetime, IScheduler* scheduler, uint16_t port, const std::string& id)\n\t: Base(id, parentLifetime, scheduler), ss(std::make_unique<CPassiveSocket>()), serverLifetimeDefinition(parentLifetime)\n{\n#ifdef SIGPIPE\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tRD_ASSERT_MSG(ss->Initialize(), fmt::format(\"{}: failed to initialize socket, reason: {}\", this->id, socket->DescribeError()));\n\tRD_ASSERT_MSG(ss->Listen(\"127.0.0.1\", port),\n\t\tfmt::format(\"{}: failed to listen socket on port: {}, reason: {}\", this->id, std::to_string(port), ss->DescribeError()));\n\n\tthis->port = ss->GetServerPort();\n\tRD_ASSERT_MSG(this->port != 0, fmt::format(\"{}: port wasn't chosen\", this->id));\n\n\tlogger->info(\"{}: listening 127.0.0.1/{}\", this->id, this->port);\n\tLifetime lifetime = serverLifetimeDefinition.lifetime;\n\n\tthread = std::thread([this, lifetime]() mutable {\n\t\trd::util::set_thread_name(this->id.empty() ? \"SocketWire::Server Thread\" : this->id.c_str());\n\n\t\tlogger->info(\"{}: started, port: {}.\", this->id, this->port);\n\n\t\ttry\n\t\t{\n\t\t\twhile (!lifetime->is_terminated())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tlogger->info(\"{}: accepting started\", this->id);\n\n\n\n\n\n\t\t\t\t\twhile(ss->IsSocketValid() && !ss->Select(0, 300)){}\n\n\t\t\t\t\tCActiveSocket* accepted = ss->Accept();\n\t\t\t\t\tRD_ASSERT_THROW_MSG(\n\t\t\t\t\t\taccepted != nullptr, fmt::format(\"{}: accepting failed, reason: {}\", this->id, ss->DescribeError()));\n\t\t\t\t\tsocket.reset(accepted);\n\t\t\t\t\tlogger->info(\"{}: accepted passive socket {}/{}\", this->id, socket->GetClientAddr(), socket->GetClientPort());\n\t\t\t\t\tRD_ASSERT_THROW_MSG(socket->DisableNagleAlgoritm(),\n\t\t\t\t\t\tfmt::format(\"{}: tcpNoDelay failed, reason: {}\", this->id, socket->DescribeError()));\n\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::lock_guard<decltype(lock)> guard(lock);\n\t\t\t\t\t\tif (lifetime->is_terminated())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger->debug(\"{}: closing passive socket\", this->id);\n\t\t\t\t\t\t\tif (!socket->Close())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlogger->error(\"{}: failed to close socket\", this->id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlogger->info(\"{}: close passive socket\", this->id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger->debug(\"{}: setting socket provider\", this->id);\n\t\t\t\t\tset_socket_provider(socket);\n\t\t\t\t}\n\t\t\t\tcatch (std::exception const& e)\n\t\t\t\t{\n\t\t\t\t\tlogger->info(\"{}: closed with exception: {}\", this->id, e.what());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (std::exception const& e)\n\t\t{\n\t\t\tlogger->error(\"{}: terminal socket error ({}).\", this->id, e.what());\n\t\t}\n\n\t\tlogger->info(\"{}: terminated, port: {}.\", this->id, this->port);\n\t});\n\n\tlifetime->add_action([this] {\n\t\tlogger->info(\"{}: start terminating lifetime\", this->id);\n\n\t\tconst bool send_buffer_stopped = async_send_buffer.stop(timeout);\n\t\tlogger->debug(\"{}: send buffer stopped, success: {}\", this->id, send_buffer_stopped);\n\n\t\tlogger->debug(\"{}: closing server socket\", this->id);\n\t\tif (!ss->Close())\n\t\t{\n\t\t\tlogger->error(\"{}: failed to close server socket\", this->id);\n\t\t}\n\n\t\t{\n\t\t\tstd::lock_guard<decltype(lock)> guard(lock);\n\t\t\tlogger->debug(\"{}: closing socket\", this->id);\n\t\t\tif (socket != nullptr)\n\t\t\t{\n\t\t\t\tif (!socket->Close())\n\t\t\t\t{\n\t\t\t\t\tlogger->error(\"{}: failed to close socket\", this->id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogger->debug(\"{}: waiting for receiver thread\", this->id);\n\t\tlogger->debug(\"{}: is thread joinable? {}\", this->id, thread.joinable());\n\t\tthread.join();\n\t\tlogger->info(\"{}: termination finished\", this->id);\n\t});\n}\n\nSocketWire::Server::~Server()\n{\n\tif (!serverLifetimeDefinition.is_terminated())\n\t{\n\t\tserverLifetimeDefinition.terminate();\n\t}\n}\n\n}\n\n'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IWire.h'\n:#ifndef RD_CPP_IWIRE_H\n#define RD_CPP_IWIRE_H\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable:4251)\n#endif\n\n#include \"reactive/base/interfaces.h\"\n#include \"base/IRdReactive.h\"\n#include \"reactive/Property.h\"\n\n#include <rd_framework_export.h>\n\nnamespace rd\n{\nclass RdReactiveBase;\n\nclass RD_FRAMEWORK_API IWire\n{\npublic:\n\tProperty<bool> connected{false};\n\tProperty<bool> heartbeatAlive{false};\n\n\n\n\tIWire() = default;\n\n\tIWire(IWire&&) = default;\n\n\tvirtual ~IWire() = default;\n\n\n\n\tvirtual void send(RdId const& id, std::function<void(Buffer& buffer)> writer) const = 0;\n\n\n\tvirtual void advise(Lifetime lifetime, RdReactiveBase const* entity) const = 0;\n};\n}\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\n#endif\n",
        "gt": [
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IWire.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/WireBase.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/SocketWire.h'",
            "'UnrealLink/src/cpp/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/SocketWire.cpp'"
        ]
    },
    {
        "files": [
            "'Tempest/Engine/gapi/metal/mtdevice.h'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLComputePass.hpp'",
            "'Tempest/Engine/gapi/metal/mtshader.cpp'"
        ],
        "content": "'Tempest/Engine/gapi/metal/mtdevice.h'\n:#pragma once\n\n#include <Tempest/AbstractGraphicsApi>\n#include <Tempest/AccelerationStructure>\n#include <Tempest/RenderState>\n#include <Tempest/Except>\n\n#include <Metal/Metal.hpp>\n#include <Foundation/Foundation.hpp>\n\n#include \"../utility/compiller_hints.h\"\n#include \"gapi/shaderreflection.h\"\n#include \"mtsamplercache.h\"\n#include \"nsptr.h\"\n\nclass MTLDevice;\n\nnamespace Tempest {\nnamespace Detail {\n\ninline MTL::PixelFormat nativeFormat(TextureFormat frm) {\n  switch(frm) {\n    case Undefined:\n    case Last:\n      return MTL::PixelFormatInvalid;\n    case R8:\n      return MTL::PixelFormatR8Unorm;\n    case RG8:\n      return MTL::PixelFormatRG8Unorm;\n    case RGB8:\n      return MTL::PixelFormatInvalid;\n    case RGBA8:\n      return MTL::PixelFormatRGBA8Unorm;\n    case R16:\n      return MTL::PixelFormatR16Unorm;\n    case RG16:\n      return MTL::PixelFormatRG16Unorm;\n    case RGB16:\n      return MTL::PixelFormatInvalid;\n    case RGBA16:\n      return MTL::PixelFormatRGBA16Unorm;\n    case R32F:\n      return MTL::PixelFormatR32Float;\n    case RG32F:\n      return MTL::PixelFormatRG32Float;\n    case RGB32F:\n      return MTL::PixelFormatInvalid;\n    case RGBA32F:\n      return MTL::PixelFormatRGBA32Float;\n    case R32U:\n      return MTL::PixelFormatR32Uint;\n    case RG32U:\n      return MTL::PixelFormatRG32Uint;\n    case RGB32U:\n      return MTL::PixelFormatInvalid;\n    case RGBA32U:\n      return MTL::PixelFormatRGBA32Uint;\n    case Depth16:\n      return MTL::PixelFormatDepth16Unorm;\n    case Depth24x8:\n      return MTL::PixelFormatInvalid;\n    case Depth24S8:\n      return MTL::PixelFormatDepth24Unorm_Stencil8;\n    case Depth32F:\n      return MTL::PixelFormatDepth32Float;\n    case DXT1:\n      return MTL::PixelFormatBC1_RGBA;\n    case DXT3:\n      return MTL::PixelFormatBC2_RGBA;\n    case DXT5:\n      return MTL::PixelFormatBC3_RGBA;\n    case R11G11B10UF:\n      return MTL::PixelFormatRG11B10Float;\n    case RGBA16F:\n      return MTL::PixelFormatRGBA16Float;\n    }\n  return MTL::PixelFormatInvalid;\n  }\n\ninline MTL::VertexFormat nativeFormat(Decl::ComponentType t) {\n  switch(t) {\n    case Decl::ComponentType::count:\n    case Decl::ComponentType::float0:\n      return MTL::VertexFormatInvalid;\n    case Decl::ComponentType::float1:\n      return MTL::VertexFormatFloat;\n    case Decl::ComponentType::float2:\n      return MTL::VertexFormatFloat2;\n    case Decl::ComponentType::float3:\n      return MTL::VertexFormatFloat3;\n    case Decl::ComponentType::float4:\n      return MTL::VertexFormatFloat4;\n\n    case Decl::ComponentType::int1:\n      return MTL::VertexFormatInt;\n    case Decl::ComponentType::int2:\n      return MTL::VertexFormatInt2;\n    case Decl::ComponentType::int3:\n      return MTL::VertexFormatInt3;\n    case Decl::ComponentType::int4:\n      return MTL::VertexFormatInt4;\n\n    case Decl::ComponentType::uint1:\n      return MTL::VertexFormatUInt;\n    case Decl::ComponentType::uint2:\n      return MTL::VertexFormatUInt2;\n    case Decl::ComponentType::uint3:\n      return MTL::VertexFormatUInt3;\n    case Decl::ComponentType::uint4:\n      return MTL::VertexFormatUInt4;\n    }\n  return MTL::VertexFormatInvalid;\n  }\n\ninline MTL::CompareFunction nativeFormat(RenderState::ZTestMode m) {\n  switch(m) {\n    case RenderState::ZTestMode::Always:\n      return MTL::CompareFunctionAlways;\n    case RenderState::ZTestMode::Never:\n      return MTL::CompareFunctionNever;\n    case RenderState::ZTestMode::Greater:\n      return MTL::CompareFunctionGreater;\n    case RenderState::ZTestMode::Less:\n      return MTL::CompareFunctionLess;\n    case RenderState::ZTestMode::GEqual:\n      return MTL::CompareFunctionGreaterEqual;\n    case RenderState::ZTestMode::LEqual:\n      return MTL::CompareFunctionLessEqual;\n    case RenderState::ZTestMode::NoEqual:\n      return MTL::CompareFunctionNotEqual;\n    case RenderState::ZTestMode::Equal:\n      return MTL::CompareFunctionEqual;\n    }\n  return MTL::CompareFunctionAlways;\n  }\n\ninline MTL::BlendFactor nativeFormat(RenderState::BlendMode m) {\n  switch(m) {\n    case RenderState::BlendMode::Zero:\n      return MTL::BlendFactorZero;\n    case RenderState::BlendMode::One:\n      return MTL::BlendFactorOne;\n    case RenderState::BlendMode::SrcColor:\n      return MTL::BlendFactorSourceColor;\n    case RenderState::BlendMode::OneMinusSrcColor:\n      return MTL::BlendFactorOneMinusSourceColor;\n    case RenderState::BlendMode::SrcAlpha:\n      return MTL::BlendFactorSourceAlpha;\n    case RenderState::BlendMode::SrcAlphaSaturate:\n      return MTL::BlendFactorSourceAlphaSaturated;\n    case RenderState::BlendMode::OneMinusSrcAlpha:\n      return MTL::BlendFactorOneMinusSourceAlpha;\n    case RenderState::BlendMode::DstColor:\n      return MTL::BlendFactorDestinationColor;\n    case RenderState::BlendMode::OneMinusDstColor:\n      return MTL::BlendFactorOneMinusDestinationColor;\n    case RenderState::BlendMode::DstAlpha:\n      return MTL::BlendFactorDestinationAlpha;\n    case RenderState::BlendMode::OneMinusDstAlpha:\n      return MTL::BlendFactorOneMinusDestinationAlpha;\n    }\n  return MTL::BlendFactorZero;\n  }\n\ninline MTL::BlendOperation nativeFormat(RenderState::BlendOp op) {\n  switch(op) {\n    case RenderState::BlendOp::Add:\n      return MTL::BlendOperationAdd;\n    case RenderState::BlendOp::Max:\n      return MTL::BlendOperationMax;\n    case RenderState::BlendOp::Min:\n      return MTL::BlendOperationMin;\n    case RenderState::BlendOp::ReverseSubtract:\n      return MTL::BlendOperationReverseSubtract;\n    case RenderState::BlendOp::Subtract:\n      return MTL::BlendOperationSubtract;\n    }\n  return MTL::BlendOperationAdd;\n  }\n\ninline MTL::CullMode nativeFormat(RenderState::CullMode m) {\n  switch(m) {\n    case RenderState::CullMode::NoCull:\n      return MTL::CullModeNone;\n    case RenderState::CullMode::Back:\n      return MTL::CullModeBack;\n    case RenderState::CullMode::Front:\n      return MTL::CullModeFront;\n    }\n  return MTL::CullModeNone;\n  }\n\ninline MTL::PrimitiveType nativeFormat(Topology t) {\n  switch(t) {\n    case Topology::Points:    return MTL::PrimitiveTypePoint;\n    case Topology::Lines:     return MTL::PrimitiveTypeLine;\n    case Topology::Triangles: return MTL::PrimitiveTypeTriangle;\n    }\n  return MTL::PrimitiveTypePoint;\n  }\n\ninline MTL::IndexType nativeFormat(IndexClass icls) {\n  switch(icls) {\n    case IndexClass::i16: return MTL::IndexTypeUInt16;\n    case IndexClass::i32: return MTL::IndexTypeUInt32;\n    }\n  return MTL::IndexTypeUInt16;\n  }\n\ninline MTL::AccelerationStructureInstanceOptions nativeFormat(RtInstanceFlags f) {\n  MTL::AccelerationStructureInstanceOptions ret = 0;\n  if((f & RtInstanceFlags::NonOpaque)==RtInstanceFlags::NonOpaque)\n    ret |= MTL::AccelerationStructureInstanceOptionNonOpaque; else\n    ret |= MTL::AccelerationStructureInstanceOptionOpaque;\n  if((f & RtInstanceFlags::CullDisable)==RtInstanceFlags::CullDisable)\n    ret |= MTL::AccelerationStructureInstanceOptionDisableTriangleCulling;\n  if((f & RtInstanceFlags::CullFlip)==RtInstanceFlags::CullFlip)\n    ret |= MTL::AccelerationStructureInstanceOptionTriangleFrontFacingWindingCounterClockwise;\n  return ret;\n  }\n\ninline MTL::RenderStages nativeFormat(ShaderReflection::Stage st) {\n  uint32_t stageFlags = 0;\n  if(st&ShaderReflection::Compute)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Vertex)\n    stageFlags |= MTL::RenderStageVertex;\n  if(st&ShaderReflection::Control)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Evaluate)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Geometry)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Fragment)\n    stageFlags |= MTL::RenderStageFragment;\n  if(st&ShaderReflection::Task)\n    stageFlags |=  MTL::RenderStageObject;\n  if(st&ShaderReflection::Mesh)\n    stageFlags |=  MTL::RenderStageMesh;\n  return MTL::RenderStages(stageFlags);\n  }\n\nclass MtDevice : public AbstractGraphicsApi::Device {\n  public:\n    MtDevice(std::string_view name, bool validation);\n    ~MtDevice();\n\n    void onSubmit();\n    void onFinish();\n    void waitIdle() override;\n\n    bool     useNativeImageAtomic() const;\n    uint32_t linearImageAlignment() const;\n\n    static void handleError(NS::Error* err);\n\n    NsPtr<MTL::Device>         impl;\n    NsPtr<MTL::CommandQueue>   queue;\n\n    std::condition_variable    devIdleCv;\n    std::mutex                 devIdleSync;\n    std::atomic_uint32_t       devCmdBuf{0};\n\n    AbstractGraphicsApi::Props prop;\n    MtSamplerCache             samplers;\n    bool                       validation = false;\n    MTL::LanguageVersion       mslVersion = MTL::LanguageVersion2_0;\n    uint32_t                   ui32align  = 0;\n\n    static void deductProps(AbstractGraphicsApi::Props& prop, MTL::Device& dev);\n  };\n\ninline void mtAssert(void* obj, NS::Error* err) {\n  if(T_LIKELY(obj!=nullptr))\n    return;\n  MtDevice::handleError(err);\n  }\n\n}\n}\n\n'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n\n\n#include \"MTLAccelerationStructure.hpp\"\n#include \"MTLAccelerationStructureCommandEncoder.hpp\"\n#include \"MTLAccelerationStructureTypes.hpp\"\n#include \"MTLArgument.hpp\"\n#include \"MTLArgumentEncoder.hpp\"\n#include \"MTLBinaryArchive.hpp\"\n#include \"MTLBlitCommandEncoder.hpp\"\n#include \"MTLBlitPass.hpp\"\n#include \"MTLBuffer.hpp\"\n#include \"MTLCaptureManager.hpp\"\n#include \"MTLCaptureScope.hpp\"\n#include \"MTLCommandBuffer.hpp\"\n#include \"MTLCommandEncoder.hpp\"\n#include \"MTLCommandQueue.hpp\"\n#include \"MTLComputeCommandEncoder.hpp\"\n#include \"MTLComputePass.hpp\"\n#include \"MTLComputePipeline.hpp\"\n#include \"MTLCounters.hpp\"\n#include \"MTLDefines.hpp\"\n#include \"MTLDepthStencil.hpp\"\n#include \"MTLDevice.hpp\"\n#include \"MTLDrawable.hpp\"\n#include \"MTLDynamicLibrary.hpp\"\n#include \"MTLEvent.hpp\"\n#include \"MTLFence.hpp\"\n#include \"MTLFunctionConstantValues.hpp\"\n#include \"MTLFunctionDescriptor.hpp\"\n#include \"MTLFunctionHandle.hpp\"\n#include \"MTLFunctionLog.hpp\"\n#include \"MTLFunctionStitching.hpp\"\n#include \"MTLHeaderBridge.hpp\"\n#include \"MTLHeap.hpp\"\n#include \"MTLIndirectCommandBuffer.hpp\"\n#include \"MTLIndirectCommandEncoder.hpp\"\n#include \"MTLIntersectionFunctionTable.hpp\"\n#include \"MTLIOCommandBuffer.hpp\"\n#include \"MTLIOCommandQueue.hpp\"\n#include \"MTLIOCompressor.hpp\"\n#include \"MTLLibrary.hpp\"\n#include \"MTLLinkedFunctions.hpp\"\n#include \"MTLParallelRenderCommandEncoder.hpp\"\n#include \"MTLPipeline.hpp\"\n#include \"MTLPixelFormat.hpp\"\n#include \"MTLPrivate.hpp\"\n#include \"MTLRasterizationRate.hpp\"\n#include \"MTLRenderCommandEncoder.hpp\"\n#include \"MTLRenderPass.hpp\"\n#include \"MTLRenderPipeline.hpp\"\n#include \"MTLResource.hpp\"\n#include \"MTLResourceStateCommandEncoder.hpp\"\n#include \"MTLResourceStatePass.hpp\"\n#include \"MTLSampler.hpp\"\n#include \"MTLStageInputOutputDescriptor.hpp\"\n#include \"MTLTexture.hpp\"\n#include \"MTLTypes.hpp\"\n#include \"MTLVertexDescriptor.hpp\"\n#include \"MTLVisibleFunctionTable.hpp\"\n#include \"MTLVersion.hpp\"\n\n\n\n'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLComputePass.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n#include \"MTLDefines.hpp\"\n#include \"MTLHeaderBridge.hpp\"\n#include \"MTLPrivate.hpp\"\n\n#include <Foundation/Foundation.hpp>\n\n#include \"MTLCommandBuffer.hpp\"\n\nnamespace MTL\n{\nclass ComputePassSampleBufferAttachmentDescriptor : public NS::Copying<ComputePassSampleBufferAttachmentDescriptor>\n{\npublic:\n    static class ComputePassSampleBufferAttachmentDescriptor* alloc();\n\n    class ComputePassSampleBufferAttachmentDescriptor*        init();\n\n    class CounterSampleBuffer*                                sampleBuffer() const;\n    void                                                      setSampleBuffer(const class CounterSampleBuffer* sampleBuffer);\n\n    NS::UInteger                                              startOfEncoderSampleIndex() const;\n    void                                                      setStartOfEncoderSampleIndex(NS::UInteger startOfEncoderSampleIndex);\n\n    NS::UInteger                                              endOfEncoderSampleIndex() const;\n    void                                                      setEndOfEncoderSampleIndex(NS::UInteger endOfEncoderSampleIndex);\n};\n\nclass ComputePassSampleBufferAttachmentDescriptorArray : public NS::Referencing<ComputePassSampleBufferAttachmentDescriptorArray>\n{\npublic:\n    static class ComputePassSampleBufferAttachmentDescriptorArray* alloc();\n\n    class ComputePassSampleBufferAttachmentDescriptorArray*        init();\n\n    class ComputePassSampleBufferAttachmentDescriptor*             object(NS::UInteger attachmentIndex);\n\n    void                                                           setObject(const class ComputePassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex);\n};\n\nclass ComputePassDescriptor : public NS::Copying<ComputePassDescriptor>\n{\npublic:\n    static class ComputePassDescriptor*                     alloc();\n\n    class ComputePassDescriptor*                            init();\n\n    static class ComputePassDescriptor*                     computePassDescriptor();\n\n    MTL::DispatchType                                       dispatchType() const;\n    void                                                    setDispatchType(MTL::DispatchType dispatchType);\n\n    class ComputePassSampleBufferAttachmentDescriptorArray* sampleBufferAttachments() const;\n};\n\n}\n\n\n_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptor* MTL::ComputePassSampleBufferAttachmentDescriptor::alloc()\n{\n    return NS::Object::alloc<MTL::ComputePassSampleBufferAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLComputePassSampleBufferAttachmentDescriptor));\n}\n\n\n_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptor* MTL::ComputePassSampleBufferAttachmentDescriptor::init()\n{\n    return NS::Object::init<MTL::ComputePassSampleBufferAttachmentDescriptor>();\n}\n\n\n_MTL_INLINE MTL::CounterSampleBuffer* MTL::ComputePassSampleBufferAttachmentDescriptor::sampleBuffer() const\n{\n    return Object::sendMessage<MTL::CounterSampleBuffer*>(this, _MTL_PRIVATE_SEL(sampleBuffer));\n}\n\n_MTL_INLINE void MTL::ComputePassSampleBufferAttachmentDescriptor::setSampleBuffer(const MTL::CounterSampleBuffer* sampleBuffer)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSampleBuffer_), sampleBuffer);\n}\n\n\n_MTL_INLINE NS::UInteger MTL::ComputePassSampleBufferAttachmentDescriptor::startOfEncoderSampleIndex() const\n{\n    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(startOfEncoderSampleIndex));\n}\n\n_MTL_INLINE void MTL::ComputePassSampleBufferAttachmentDescriptor::setStartOfEncoderSampleIndex(NS::UInteger startOfEncoderSampleIndex)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStartOfEncoderSampleIndex_), startOfEncoderSampleIndex);\n}\n\n\n_MTL_INLINE NS::UInteger MTL::ComputePassSampleBufferAttachmentDescriptor::endOfEncoderSampleIndex() const\n{\n    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(endOfEncoderSampleIndex));\n}\n\n_MTL_INLINE void MTL::ComputePassSampleBufferAttachmentDescriptor::setEndOfEncoderSampleIndex(NS::UInteger endOfEncoderSampleIndex)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setEndOfEncoderSampleIndex_), endOfEncoderSampleIndex);\n}\n\n\n_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptorArray* MTL::ComputePassSampleBufferAttachmentDescriptorArray::alloc()\n{\n    return NS::Object::alloc<MTL::ComputePassSampleBufferAttachmentDescriptorArray>(_MTL_PRIVATE_CLS(MTLComputePassSampleBufferAttachmentDescriptorArray));\n}\n\n\n_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptorArray* MTL::ComputePassSampleBufferAttachmentDescriptorArray::init()\n{\n    return NS::Object::init<MTL::ComputePassSampleBufferAttachmentDescriptorArray>();\n}\n\n\n_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptor* MTL::ComputePassSampleBufferAttachmentDescriptorArray::object(NS::UInteger attachmentIndex)\n{\n    return Object::sendMessage<MTL::ComputePassSampleBufferAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), attachmentIndex);\n}\n\n\n_MTL_INLINE void MTL::ComputePassSampleBufferAttachmentDescriptorArray::setObject(const MTL::ComputePassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attachment, attachmentIndex);\n}\n\n\n_MTL_INLINE MTL::ComputePassDescriptor* MTL::ComputePassDescriptor::alloc()\n{\n    return NS::Object::alloc<MTL::ComputePassDescriptor>(_MTL_PRIVATE_CLS(MTLComputePassDescriptor));\n}\n\n\n_MTL_INLINE MTL::ComputePassDescriptor* MTL::ComputePassDescriptor::init()\n{\n    return NS::Object::init<MTL::ComputePassDescriptor>();\n}\n\n\n_MTL_INLINE MTL::ComputePassDescriptor* MTL::ComputePassDescriptor::computePassDescriptor()\n{\n    return Object::sendMessage<MTL::ComputePassDescriptor*>(_MTL_PRIVATE_CLS(MTLComputePassDescriptor), _MTL_PRIVATE_SEL(computePassDescriptor));\n}\n\n\n_MTL_INLINE MTL::DispatchType MTL::ComputePassDescriptor::dispatchType() const\n{\n    return Object::sendMessage<MTL::DispatchType>(this, _MTL_PRIVATE_SEL(dispatchType));\n}\n\n_MTL_INLINE void MTL::ComputePassDescriptor::setDispatchType(MTL::DispatchType dispatchType)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDispatchType_), dispatchType);\n}\n\n\n_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptorArray* MTL::ComputePassDescriptor::sampleBufferAttachments() const\n{\n    return Object::sendMessage<MTL::ComputePassSampleBufferAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(sampleBufferAttachments));\n}\n\n'Tempest/Engine/gapi/metal/mtshader.cpp'\n:#if defined(TEMPEST_BUILD_METAL)\n\n#include \"mtshader.h\"\n\n#include <Tempest/Log>\n#include <Tempest/Except>\n\n#include \"mtdevice.h\"\n#include \"gapi/shaderreflection.h\"\n#include \"thirdparty/spirv_cross/spirv_msl.hpp\"\n\n#include \"libspirv/libspirv.h\"\n\nusing namespace Tempest;\nusing namespace Tempest::Detail;\n\nstatic uint32_t spvVersion(MTL::LanguageVersion v) {\n  const uint32_t major = v >> 16u;\n  const uint32_t minor = v & 0xFFFF;\n  return spirv_cross::CompilerMSL::Options::make_msl_version(major,minor,0);\n  }\n\nMtShader::MtShader(MtDevice& dev, const void* source, size_t srcSize) {\n  if(srcSize%4!=0)\n    throw std::system_error(Tempest::GraphicsErrc::InvalidShaderModule);\n\n  auto pool = NsPtr<NS::AutoreleasePool>::init();\n  spirv_cross::CompilerMSL::Options optMSL;\n#if defined(__OSX__)\n  optMSL.platform = spirv_cross::CompilerMSL::Options::macOS;\n#else\n  optMSL.platform = spirv_cross::CompilerMSL::Options::iOS;\n#endif\n  optMSL.buffer_size_buffer_index = MSL_BUFFER_LENGTH;\n\n  spirv_cross::CompilerGLSL::Options optGLSL;\n  optGLSL.vertex.flip_vert_y = true;\n\n  std::string msl;\n  try {\n    fetchBindings(reinterpret_cast<const uint32_t*>(source),srcSize/4);\n\n    spirv_cross::CompilerMSL comp(reinterpret_cast<const uint32_t*>(source),srcSize/4);\n    optMSL.msl_version = spvVersion(dev.mslVersion);\n    if(dev.prop.descriptors.nonUniformIndexing) {\n      optMSL.argument_buffers_tier = spirv_cross::CompilerMSL::Options::ArgumentBuffersTier::Tier2;\n      optMSL.runtime_array_rich_descriptor = true;\n      }\n\n    if(!dev.useNativeImageAtomic()) {\n      const uint32_t align = dev.linearImageAlignment();\n      optMSL.r32ui_linear_texture_alignment = align;\n      optMSL.r32ui_alignment_constant_id    = 0;\n      }\n\n    for(auto& cap:comp.get_declared_capabilities()) {\n      switch(cap) {\n        case spv::CapabilityRayQueryKHR: {\n          auto ver = spirv_cross::CompilerMSL::Options::make_msl_version(2,3);\n          optMSL.msl_version = std::max(optMSL.msl_version, ver);\n          break;\n          }\n        case spv::CapabilityMeshShadingEXT: {\n          auto ver = spirv_cross::CompilerMSL::Options::make_msl_version(3,0);\n          optMSL.msl_version = std::max(optMSL.msl_version, ver);\n          break;\n          }\n        default:\n          break;\n        }\n      }\n    comp.set_msl_options   (optMSL );\n    comp.set_common_options(optGLSL);\n\n    msl = comp.compile();\n\n    bufferSizeBuffer = comp.needs_buffer_size_buffer();\n\n    for(auto& i:lay) {\n      i.mslBinding = comp.get_automatic_msl_resource_binding(i.spvId);\n      if(i.cls==ShaderReflection::Texture)\n        i.mslBinding2 = comp.get_automatic_msl_resource_binding_secondary(i.spvId);\n      if(i.cls==ShaderReflection::ImgR || i.cls==ShaderReflection::ImgRW)\n        i.mslBinding2 = comp.get_automatic_msl_resource_binding_secondary(i.spvId);\n      if(i.cls==ShaderReflection::Push)\n        i.mslSize = ShaderReflection::mslSizeOf(i.spvId,comp);\n      }\n\n    size_t nsize = 0;\n    for(size_t i=0; i<lay.size(); ++i) {\n      bool uniq = true;\n      if(lay[i].cls!=ShaderReflection::Push) {\n        for(size_t r=0; r<i; ++r) {\n          if(lay[r].cls==ShaderReflection::Push)\n            continue;\n          if(lay[i].layout!=lay[r].layout)\n            continue;\n          uniq = false;\n          lay[r].mslBinding  = std::min(lay[r].mslBinding,  lay[i].mslBinding);\n          lay[r].mslBinding2 = std::min(lay[r].mslBinding2, lay[i].mslBinding2);\n          }\n        }\n      if(uniq) {\n        lay[nsize] = lay[i];\n        nsize++;\n        }\n      }\n    lay.resize(nsize);\n\n    if(comp.get_execution_model()==spv::ExecutionModelTessellationEvaluation) {\n      auto& exec = comp.get_execution_mode_bitset();\n      if(exec.get(spv::ExecutionModeTriangles)) {\n\n        }\n\n      if(exec.get(spv::ExecutionModeVertexOrderCw))\n        tese.winding = MTL::WindingClockwise;\n      else if(exec.get(spv::ExecutionModeVertexOrderCcw))\n        tese.winding = MTL::WindingCounterClockwise;\n\n      if(exec.get(spv::ExecutionModeSpacingEqual))\n        tese.partition = MTL::TessellationPartitionModeInteger;\n      else if(exec.get(spv::ExecutionModeSpacingFractionalEven))\n        tese.partition = MTL::TessellationPartitionModeFractionalEven;\n      else if(exec.get(spv::ExecutionModeSpacingFractionalOdd))\n        tese.partition = MTL::TessellationPartitionModeFractionalOdd;\n      }\n    }\n  catch(const std::bad_alloc&) {\n    throw;\n    }\n  catch(const spirv_cross::CompilerError& err) {\n#if !defined(NDEBUG)\n    Log::d(\"cross-compile error: \\\"\",err.what(),\"\\\"\");\n#else\n    (void)err;\n#endif\n    throw std::system_error(Tempest::GraphicsErrc::InvalidShaderModule);\n    }\n  catch(...) {\n    throw std::system_error(Tempest::GraphicsErrc::InvalidShaderModule);\n    }\n\n\n\n  auto       opt = NsPtr<MTL::CompileOptions>::init();\n  NS::Error* err = nullptr;\n  auto       str = NsPtr<NS::String>(NS::String::string(msl.c_str(),NS::UTF8StringEncoding));\n  str->retain();\n  library = NsPtr<MTL::Library>(dev.impl->newLibrary(str.get(), opt.get(), &err));\n\n  if(err!=nullptr) {\n    const char* e = err->localizedDescription()->utf8String();\n#if !defined(NDEBUG)\n    Log::d(\"cros-compile error: \\\"\",e,\"\\\"\\n\");\n    Log::d(msl);\n#endif\n    throw std::system_error(Tempest::GraphicsErrc::InvalidShaderModule, e);\n    }\n\n  if(stage==ShaderReflection::Stage::Vertex) {\n\n    }\n\n  auto main = NsPtr<NS::String>(NS::String::string(\"main0\",NS::UTF8StringEncoding));\n  main->retain();\n\n  auto cvar = NsPtr<MTL::FunctionConstantValues>::init();\n\n  impl = NsPtr<MTL::Function>(library->newFunction(main.get(), cvar.get(), &err));\n  }\n\nMtShader::~MtShader() {\n  }\n\nvoid MtShader::fetchBindings(const uint32_t *source, size_t size) {\n\n  spirv_cross::Compiler comp(source, size);\n  ShaderReflection::getVertexDecl(vdecl,comp);\n  ShaderReflection::getBindings(lay,comp);\n\n  libspirv::Bytecode code(source, size);\n  stage = ShaderReflection::getExecutionModel(code);\n  if(stage==ShaderReflection::Compute || stage==ShaderReflection::Task || stage==ShaderReflection::Mesh) {\n    for(auto& i:code) {\n      if(i.op()!=spv::OpExecutionMode)\n        continue;\n      if(i[2]==spv::ExecutionModeLocalSize) {\n        this->comp.localSize.width  = i[3];\n        this->comp.localSize.height = i[4];\n        this->comp.localSize.depth  = i[5];\n        }\n      }\n    }\n  }\n\n#endif\n",
        "gt": [
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLComputePass.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'",
            "'Tempest/Engine/gapi/metal/mtdevice.h'",
            "'Tempest/Engine/gapi/metal/mtshader.cpp'"
        ]
    },
    {
        "files": [
            "'Tempest/Engine/gapi/vulkan/vulkan_sdk.h'",
            "'Tempest/Engine/gapi/vulkan/vpipelinelay.h'",
            "'Tempest/Engine/gapi/vulkan/vmeshlethelper.cpp'"
        ],
        "content": "'Tempest/Engine/gapi/vulkan/vulkan_sdk.h'\n:#pragma once\n\n#define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;\n#include <vulkan/vulkan.h>\n\n'Tempest/Engine/gapi/vulkan/vpipelinelay.h'\n:#pragma once\n\n#include <Tempest/AbstractGraphicsApi>\n#include <Tempest/PipelineLayout>\n\n#include \"vulkan_sdk.h\"\n#include <mutex>\n#include <list>\n#include <vector>\n\n#include \"gapi/shaderreflection.h\"\n#include \"utility/spinlock.h\"\n\nnamespace Tempest {\n\nclass PipelineLayout;\n\nnamespace Detail {\n\nclass VDescriptorArray;\nclass VDevice;\nclass VShader;\n\nclass VPipelineLay : public AbstractGraphicsApi::PipelineLay {\n  public:\n    VPipelineLay(VDevice& dev, const std::vector<ShaderReflection::Binding>* sh);\n    VPipelineLay(VDevice& dev, const std::vector<ShaderReflection::Binding>* sh[], size_t cnt);\n    ~VPipelineLay();\n\n    using Binding = ShaderReflection::Binding;\n\n    struct DedicatedLay {\n      VkDescriptorSetLayout dLay = VK_NULL_HANDLE;\n      VkPipelineLayout      pLay = VK_NULL_HANDLE;\n      };\n\n    size_t                descriptorsCount() override;\n    size_t                sizeOfBuffer(size_t layoutBind, size_t arraylen) const override;\n\n    DedicatedLay          create(const std::vector<uint32_t>& runtimeArrays);\n\n    VDevice&                    dev;\n    VkDescriptorSetLayout       impl     = VK_NULL_HANDLE;\n    VkDescriptorSetLayout       msHelper = VK_NULL_HANDLE;\n\n    std::vector<Binding>        lay;\n    ShaderReflection::PushBlock pb;\n    bool                        runtimeSized = false;\n\n  private:\n    enum {\n      POOL_SIZE    = 512,\n\n      };\n\n    struct Pool {\n      VkDescriptorPool impl      = VK_NULL_HANDLE;\n      uint16_t         freeCount = POOL_SIZE;\n      };\n\n    struct DLay : DedicatedLay {\n      std::vector<uint32_t> runtimeArrays;\n      };\n\n    Detail::SpinLock sync;\n    std::list<Pool>  pool;\n\n    Detail::SpinLock  syncLay;\n    std::vector<DLay> dedicatedLay;\n\n    VkDescriptorSetLayout createDescLayout(const std::vector<uint32_t>& runtimeArrays) const;\n    VkDescriptorSetLayout createMsHelper() const;\n\n    void                  adjustSsboBindings();\n\n  friend class VDescriptorArray;\n  };\n\n}\n}\n\n'Tempest/Engine/gapi/vulkan/vmeshlethelper.cpp'\n:#if defined(TEMPEST_BUILD_VULKAN)\n\n#include \"vmeshlethelper.h\"\n\n#include \"builtin_shader.h\"\n\n#include \"vdevice.h\"\n#include \"vcommandbuffer.h\"\n#include \"vbuffer.h\"\n#include \"vshader.h\"\n#include \"vpipelinelay.h\"\n#include \"vpipeline.h\"\n\nusing namespace Tempest::Detail;\n\nVMeshletHelper::VMeshletHelper(VDevice& dev) : dev(dev) {\n  const auto ind = MemUsage::StorageBuffer | MemUsage::Indirect    | MemUsage::TransferDst | MemUsage::TransferSrc;\n  const auto ms  = MemUsage::StorageBuffer | MemUsage::Indirect    | MemUsage::TransferDst | MemUsage::TransferSrc;\n  const auto geo = MemUsage::StorageBuffer | MemUsage::IndexBuffer | MemUsage::TransferDst | MemUsage::TransferSrc;\n\n  indirect    = dev.allocator.alloc(nullptr, IndirectMemorySize, ind, BufferHeap::Device);\n  meshlets    = dev.allocator.alloc(nullptr, MeshletsMemorySize, ms,  BufferHeap::Device);\n  scratch     = dev.allocator.alloc(nullptr, PipelineMemorySize, geo, BufferHeap::Device);\n\n  static_assert(sizeof(DrawIndexedIndirectCommand)==32);\n  if(dev.props.ssbo.offsetAlign > sizeof(DrawIndexedIndirectCommand)) {\n    indirectRate   = uint32_t(dev.props.ssbo.offsetAlign/sizeof(DrawIndexedIndirectCommand));\n    indirectOffset = uint32_t(dev.props.ssbo.offsetAlign);\n    } else {\n    indirectOffset = sizeof(DrawIndexedIndirectCommand);\n    }\n\n  maxPersistentTask = 256;\n  maxPersistentMesh = 1024;\n\n  try {\n    initShaders(dev);\n\n    engLay   = initLayout(dev);\n    engPool  = initPool(dev,3);\n    engSet   = initDescriptors(dev,engPool,engLay);\n    initEngSet(engSet,3,true);\n\n    compPool = initPool(dev,3);\n    compSet  = initDescriptors(dev,compPool,compactageLay.handler->impl);\n    initEngSet(compSet,3,false);\n\n    drawLay  = initDrawLayout(dev);\n    drawPool = initPool(dev,1);\n    drawSet  = initDescriptors(dev,drawPool,drawLay);\n    initDrawSet(drawSet);\n    }\n  catch(...) {\n    cleanup();\n    }\n\n  {\n    struct Push {\n      uint32_t indirectRate;\n      uint32_t indirectCmdCount;\n      } push;\n    push.indirectRate     = indirectRate;\n    push.indirectCmdCount = 0;\n\n    auto c = dev.dataMgr().get();\n    auto& cmd = reinterpret_cast<VMeshCommandBuffer&>(*c.get());\n    cmd.begin();\n    vkCmdBindPipeline(cmd.impl,VK_PIPELINE_BIND_POINT_COMPUTE,init.handler->impl);\n    vkCmdBindDescriptorSets(cmd.impl,VK_PIPELINE_BIND_POINT_COMPUTE, init.handler->pipelineLayout,\n                            0, 1,&compSet, 0,nullptr);\n    vkCmdPushConstants(cmd.impl,init.handler->pipelineLayout,VK_SHADER_STAGE_COMPUTE_BIT,0,sizeof(push),&push);\n\n    const uint32_t sz = init.handler->workGroupSize().x;\n    vkCmdDispatch(cmd.impl, (IndirectCmdCount+sz-1)/sz,1,1);\n\n    barrier(cmd.impl,\n            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,\n            VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,\n            VK_ACCESS_TRANSFER_WRITE_BIT,\n            VK_ACCESS_MEMORY_READ_BIT | VK_ACCESS_MEMORY_WRITE_BIT);\n    cmd.end();\n    dev.dataMgr().submit(std::move(c));\n  }\n  }\n\nVMeshletHelper::~VMeshletHelper() {\n  cleanup();\n  }\n\nvoid VMeshletHelper::cleanup() {\n  if(compSet!=VK_NULL_HANDLE)\n    vkFreeDescriptorSets(dev.device.impl, compPool, 1, &compSet);\n  if(compPool!=VK_NULL_HANDLE)\n    vkDestroyDescriptorPool(dev.device.impl, compPool, nullptr);\n\n  if(engLay!=VK_NULL_HANDLE)\n    vkDestroyDescriptorSetLayout(dev.device.impl, engLay, nullptr);\n  if(engSet!=VK_NULL_HANDLE)\n    vkFreeDescriptorSets(dev.device.impl, engPool, 1, &engSet);\n  if(engPool!=VK_NULL_HANDLE)\n    vkDestroyDescriptorPool(dev.device.impl, engPool, nullptr);\n\n  if(drawLay!=VK_NULL_HANDLE)\n    vkDestroyDescriptorSetLayout(dev.device.impl, drawLay, nullptr);\n  if(drawSet!=VK_NULL_HANDLE)\n    vkFreeDescriptorSets(dev.device.impl, drawPool, 1, &drawSet);\n  if(drawPool!=VK_NULL_HANDLE)\n    vkDestroyDescriptorPool(dev.device.impl, drawPool, nullptr);\n  }\n\nvoid VMeshletHelper::bindCS(VkPipelineLayout task, VkPipelineLayout mesh) {\n  currentTaskLayout = task;\n  currentMeshLayout = mesh;\n  }\n\nvoid VMeshletHelper::bindVS(VkCommandBuffer impl, VkPipelineLayout lay) {\n  vkCmdBindIndexBuffer   (impl, scratch.impl, 1*sizeof(uint32_t), VK_INDEX_TYPE_UINT32);\n  vkCmdBindDescriptorSets(impl, VK_PIPELINE_BIND_POINT_GRAPHICS,\n                          lay, 1,\n                          1,&drawSet,\n                          0,nullptr);\n  }\n\nvoid VMeshletHelper::drawIndirect(VkCommandBuffer impl, uint32_t drawId) {\n  assert(drawId*indirectRate < IndirectCmdCount);\n  uint32_t off = drawId*indirectOffset + 2*sizeof(uint32_t);\n  vkCmdDrawIndexedIndirect(impl, indirect.impl, off, 1, 0);\n  }\n\nvoid VMeshletHelper::initRP(VkCommandBuffer impl) {\n  if(false) {\n    VkDrawIndexedIndirectCommand cmd[3] = {};\n    indirect.read(&cmd,0,sizeof(cmd));\n\n    IVec3 cmdSz = {};\n    meshlets.read(&cmdSz,2*4,sizeof(cmdSz));\n\n    IVec3 desc[3] = {};\n    meshlets.read(&desc,5*4,sizeof(desc));\n\n    uint32_t indSize   = (desc[0].z       ) & 0x3FF;\n\n\n\n\n\n\n\n\n\n    float sc[12*3+3] = {};\n    scratch.read(sc,0,sizeof(sc));\n\n    Log::i(\"\");\n\n    uint32_t zero = 0;\n    scratch.update(&zero, 0, 4);\n    }\n  }\n\nvoid VMeshletHelper::taskEpiloguePass(VkCommandBuffer impl, uint32_t meshCallsCount) {\n  if(meshCallsCount==0)\n    return;\n  currentTaskLayout = VK_NULL_HANDLE;\n\n  struct Push {\n    uint32_t indirectRate;\n    uint32_t indirectCmdCount;\n    } push;\n  push.indirectRate     = indirectRate;\n  push.indirectCmdCount = meshCallsCount;\n\n\n  barrier(impl, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT);\n  vkCmdBindPipeline(impl, VK_PIPELINE_BIND_POINT_COMPUTE, taskPostPass.handler->impl);\n  vkCmdBindDescriptorSets(impl, VK_PIPELINE_BIND_POINT_COMPUTE, taskPostPass.handler->pipelineLayout,\n                          0, 1,&compSet, 0,nullptr);\n  vkCmdPushConstants(impl,taskPostPass.handler->pipelineLayout,VK_SHADER_STAGE_COMPUTE_BIT,0,sizeof(push),&push);\n  vkCmdDispatch(impl, 1,1,1);\n\n\n  barrier(impl,\n          VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT);\n  vkCmdBindPipeline(impl, VK_PIPELINE_BIND_POINT_COMPUTE, taskLutPass.handler->impl);\n  vkCmdBindDescriptorSets(impl, VK_PIPELINE_BIND_POINT_COMPUTE, taskLutPass.handler->pipelineLayout,\n                          0, 1,&compSet, 0,nullptr);\n  vkCmdDispatch(impl, maxPersistentTask,1,1);\n\n\n  barrier(impl,\n          VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT | VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,\n          VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT | VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT | VK_ACCESS_INDIRECT_COMMAND_READ_BIT);\n  }\n\nvoid VMeshletHelper::sortPass(VkCommandBuffer impl, uint32_t meshCallsCount) {\n  if(meshCallsCount==0)\n    return;\n  currentMeshLayout = VK_NULL_HANDLE;\n\n  struct Push {\n    uint32_t indirectRate;\n    uint32_t indirectCmdCount;\n    } push;\n  push.indirectRate     = indirectRate;\n  push.indirectCmdCount = meshCallsCount;\n\n\n  barrier(impl, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT);\n  vkCmdBindPipeline(impl,VK_PIPELINE_BIND_POINT_COMPUTE,prefixSum.handler->impl);\n  vkCmdBindDescriptorSets(impl,VK_PIPELINE_BIND_POINT_COMPUTE, prefixSum.handler->pipelineLayout,\n                          0, 1,&compSet, 0,nullptr);\n  vkCmdPushConstants(impl,prefixSum.handler->pipelineLayout,VK_SHADER_STAGE_COMPUTE_BIT,0,sizeof(push),&push);\n  vkCmdDispatch(impl, 1,1,1);\n\n\n  barrier(impl,\n          VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT | VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,\n          VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT | VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT | VK_ACCESS_INDIRECT_COMMAND_READ_BIT);\n  vkCmdBindPipeline(impl,VK_PIPELINE_BIND_POINT_COMPUTE,compactage.handler->impl);\n  vkCmdBindDescriptorSets(impl,VK_PIPELINE_BIND_POINT_COMPUTE, compactage.handler->pipelineLayout,\n                          0, 1,&compSet, 0,nullptr);\n  vkCmdDispatch(impl, maxPersistentMesh,1,1);\n\n\n  barrier(impl,\n          VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,\n          VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_VERTEX_INPUT_BIT | VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT,\n          VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_INDEX_READ_BIT | VK_ACCESS_INDIRECT_COMMAND_READ_BIT);\n  }\n\nvoid VMeshletHelper::drawCompute(VkCommandBuffer task, VkCommandBuffer mesh, uint32_t taskId, uint32_t drawId, size_t x, size_t y, size_t z) {\n  if(taskId==0 && currentTaskLayout!=VK_NULL_HANDLE) {\n\n    barrier(task,\n            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_VERTEX_INPUT_BIT | VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,\n            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,\n            VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_INDEX_READ_BIT | VK_ACCESS_INDIRECT_COMMAND_READ_BIT,\n            VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT);\n    }\n  if(drawId==0) {\n\n    barrier(mesh,\n            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_VERTEX_INPUT_BIT | VK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,\n            VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,\n            VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_INDEX_READ_BIT | VK_ACCESS_INDIRECT_COMMAND_READ_BIT,\n            VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT | VK_ACCESS_INDIRECT_COMMAND_READ_BIT);\n    }\n\n  assert(drawId<IndirectCmdCount);\n  const uint32_t dynOffset = drawId*indirectOffset;\n  if(currentTaskLayout!=VK_NULL_HANDLE) {\n    vkCmdBindDescriptorSets(task, VK_PIPELINE_BIND_POINT_COMPUTE,\n                            currentTaskLayout, 1,\n                            1,&engSet,\n                            1,&dynOffset);\n    vkCmdDispatch(task, uint32_t(x), uint32_t(y), uint32_t(z));\n\n    vkCmdBindDescriptorSets(mesh, VK_PIPELINE_BIND_POINT_COMPUTE,\n                            currentMeshLayout, 1,\n                            1,&engSet,\n                            1,&dynOffset);\n\n    uint32_t off = dynOffset + 2*sizeof(uint32_t);\n    vkCmdDispatchIndirect(mesh, indirect.impl, off);\n\n    } else {\n    vkCmdBindDescriptorSets(mesh, VK_PIPELINE_BIND_POINT_COMPUTE,\n                            currentMeshLayout, 1,\n                            1,&engSet,\n                            1,&dynOffset);\n    vkCmdDispatch(mesh, uint32_t(x), uint32_t(y), uint32_t(z));\n    }\n  }\n\nvoid VMeshletHelper::barrier(VkCommandBuffer      impl,\n                             VkPipelineStageFlags srcStageMask,\n                             VkPipelineStageFlags dstStageMask,\n                             VkAccessFlags        srcAccessMask,\n                             VkAccessFlags        dstAccessMask) {\n  VkMemoryBarrier barrier{VK_STRUCTURE_TYPE_MEMORY_BARRIER};\n  barrier.srcAccessMask = srcAccessMask;\n  barrier.dstAccessMask = dstAccessMask;\n\n  vkCmdPipelineBarrier(impl,\n                       srcStageMask,\n                       dstStageMask,\n                       0,\n                       1, &barrier,\n                       0, nullptr,\n                       0, nullptr);\n  }\n\nVkDescriptorSetLayout VMeshletHelper::initLayout(VDevice& device) {\n  VkDescriptorSetLayoutBinding bind[3] = {};\n\n  for(int i=0; i<3; ++i) {\n    bind[i].binding         = i;\n    bind[i].descriptorCount = 1;\n    bind[i].descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;\n    bind[i].stageFlags      = VK_SHADER_STAGE_COMPUTE_BIT;\n    }\n  bind[0].descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC;\n\n  VkDescriptorSetLayoutCreateInfo info={};\n  info.sType        = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;\n  info.pNext        = nullptr;\n  info.flags        = 0;\n  info.bindingCount = 3;\n  info.pBindings    = bind;\n\n  VkDescriptorSetLayout ret = VK_NULL_HANDLE;\n  vkAssert(vkCreateDescriptorSetLayout(dev.device.impl,&info,nullptr,&ret));\n  return ret;\n  }\n\nVkDescriptorSetLayout VMeshletHelper::initDrawLayout(VDevice& device) {\n  VkDescriptorSetLayoutBinding bind[1] = {};\n  bind[0].binding         = 0;\n  bind[0].descriptorCount = 1;\n  bind[0].descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;\n  bind[0].stageFlags      = VK_SHADER_STAGE_VERTEX_BIT;\n\n  VkDescriptorSetLayoutCreateInfo info={};\n  info.sType        = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;\n  info.pNext        = nullptr;\n  info.flags        = 0;\n  info.bindingCount = 1;\n  info.pBindings    = bind;\n\n  VkDescriptorSetLayout ret = VK_NULL_HANDLE;\n  vkAssert(vkCreateDescriptorSetLayout(dev.device.impl,&info,nullptr,&ret));\n  return ret;\n  }\n\nVkDescriptorPool VMeshletHelper::initPool(VDevice& device, uint32_t cnt) {\n  VkDescriptorPoolSize poolSize[1] = {};\n  poolSize[0].type            = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;\n  poolSize[0].descriptorCount = cnt;\n\n  VkDescriptorPoolCreateInfo poolInfo = {};\n  poolInfo.sType         = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;\n  poolInfo.maxSets       = 1;\n  poolInfo.flags         = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;\n  poolInfo.poolSizeCount = uint32_t(1);\n  poolInfo.pPoolSizes    = poolSize;\n\n  VkDevice dev = device.device.impl;\n  VkDescriptorPool ret = VK_NULL_HANDLE;\n  vkAssert(vkCreateDescriptorPool(dev,&poolInfo,nullptr,&ret));\n  return ret;\n  }\n\nVkDescriptorSet VMeshletHelper::initDescriptors(VDevice& device,\n                                                VkDescriptorPool pool,\n                                                VkDescriptorSetLayout lay) {\n  VkDescriptorSetAllocateInfo allocInfo = {};\n  allocInfo.sType              = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;\n  allocInfo.descriptorPool     = pool;\n  allocInfo.descriptorSetCount = 1;\n  allocInfo.pSetLayouts        = &lay;\n\n  VkDevice        dev  = device.device.impl;\n  VkDescriptorSet desc = VK_NULL_HANDLE;\n  vkAssert(vkAllocateDescriptorSets(dev,&allocInfo,&desc));\n  return desc;\n  }\n\nvoid VMeshletHelper::initEngSet(VkDescriptorSet set, uint32_t cnt, bool dynamic) {\n  VkDescriptorBufferInfo buf[4] = {};\n  buf[0].buffer = indirect.impl;\n  buf[0].offset = 0;\n  buf[0].range  = dynamic ? sizeof(DrawIndexedIndirectCommand) : VK_WHOLE_SIZE;\n\n  buf[1].buffer = meshlets.impl;\n  buf[1].offset = 0;\n  buf[1].range  = VK_WHOLE_SIZE;\n\n  buf[2].buffer = scratch.impl;\n  buf[2].offset = 0;\n  buf[2].range  = VK_WHOLE_SIZE;\n\n  VkWriteDescriptorSet write[4] = {};\n  for(uint32_t i=0; i<cnt; ++i) {\n    write[i].sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;\n    write[i].dstSet          = set;\n    write[i].dstBinding      = uint32_t(i);\n    write[i].dstArrayElement = 0;\n    write[i].descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;\n    write[i].descriptorCount = 1;\n    write[i].pBufferInfo     = &buf[i];\n    }\n\n  if(dynamic) {\n    write[0].descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC;\n    }\n\n  vkUpdateDescriptorSets(dev.device.impl, cnt, write, 0, nullptr);\n  }\n\nvoid VMeshletHelper::initDrawSet(VkDescriptorSet set) {\n  VkDescriptorBufferInfo buf[1] = {};\n  buf[0].buffer = scratch.impl;\n  buf[0].offset = 0;\n  buf[0].range  = VK_WHOLE_SIZE;\n\n  VkWriteDescriptorSet write = {};\n  write.sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;\n  write.dstSet          = set;\n  write.dstBinding      = 0;\n  write.dstArrayElement = 0;\n  write.descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;\n  write.descriptorCount = 1;\n  write.pBufferInfo     = &buf[0];\n  vkUpdateDescriptorSets(dev.device.impl, 1, &write, 0, nullptr);\n  }\n\nvoid VMeshletHelper::initShaders(VDevice& device) {\n  auto initCs = DSharedPtr<VShader*>(new VShader(device,mesh_init_comp_sprv,sizeof(mesh_init_comp_sprv)));\n  initLay = DSharedPtr<VPipelineLay*> (new VPipelineLay (device,&initCs.handler->lay));\n  init    = DSharedPtr<VCompPipeline*>(new VCompPipeline(device,*initLay.handler,*initCs.handler));\n\n  auto taskPostPassCs = DSharedPtr<VShader*>(new VShader(device,task_post_pass_comp_sprv,sizeof(task_post_pass_comp_sprv)));\n  taskPostPassLay  = DSharedPtr<VPipelineLay*> (new VPipelineLay (device,&taskPostPassCs.handler->lay));\n  taskPostPass     = DSharedPtr<VCompPipeline*>(new VCompPipeline(device,*taskPostPassLay.handler,*taskPostPassCs.handler));\n\n  auto taskLutPassCs = DSharedPtr<VShader*>(new VShader(device,task_lut_pass_comp_sprv,sizeof(task_lut_pass_comp_sprv)));\n  taskLutPassLay  = DSharedPtr<VPipelineLay*> (new VPipelineLay (device,&taskLutPassCs.handler->lay));\n  taskLutPass     = DSharedPtr<VCompPipeline*>(new VCompPipeline(device,*taskLutPassLay.handler,*taskLutPassCs.handler));\n\n  auto prefixSumCs = DSharedPtr<VShader*>(new VShader(device,mesh_prefix_pass_comp_sprv,sizeof(mesh_prefix_pass_comp_sprv)));\n  prefixSumLay  = DSharedPtr<VPipelineLay*> (new VPipelineLay (device,&prefixSumCs.handler->lay));\n  prefixSum     = DSharedPtr<VCompPipeline*>(new VCompPipeline(device,*prefixSumLay.handler,*prefixSumCs.handler));\n\n  auto compactageCs = DSharedPtr<VShader*>(new VShader(device,mesh_compactage_comp_sprv,sizeof(mesh_compactage_comp_sprv)));\n  compactageLay = DSharedPtr<VPipelineLay*> (new VPipelineLay (device,&compactageCs.handler->lay));\n  compactage    = DSharedPtr<VCompPipeline*>(new VCompPipeline(device,*compactageLay.handler,*compactageCs.handler));\n  }\n\n#endif\n",
        "gt": [
            "'Tempest/Engine/gapi/vulkan/vulkan_sdk.h'",
            "'Tempest/Engine/gapi/vulkan/vpipelinelay.h'",
            "'Tempest/Engine/gapi/vulkan/vmeshlethelper.cpp'"
        ]
    },
    {
        "files": [
            "'elaphureLink/thirdparty/asio/include/asio/execution/receiver_invocation_error.hpp'",
            "'elaphureLink/elaphureLinkProxy/SocketClient.hpp'",
            "'elaphureLink/elaphureLinkProxy/protocol.cpp'",
            "'elaphureLink/thirdparty/asio/include/asio.hpp'"
        ],
        "content": "'elaphureLink/thirdparty/asio/include/asio/execution/receiver_invocation_error.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_EXECUTION_RECEIVER_INVOCATION_ERROR_HPP\n#define ASIO_EXECUTION_RECEIVER_INVOCATION_ERROR_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include <stdexcept>\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace execution {\n\n\n\nclass receiver_invocation_error\n  : public std::runtime_error\n#if defined(ASIO_HAS_STD_NESTED_EXCEPTION)\n  , public std::nested_exception\n#endif\n{\npublic:\n\n  ASIO_DECL receiver_invocation_error();\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#if defined(ASIO_HEADER_ONLY)\n# include \"asio/execution/impl/receiver_invocation_error.ipp\"\n#endif\n\n#endif\n\n'elaphureLink/elaphureLinkProxy/SocketClient.hpp'\n:﻿#pragma once\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n\n#include <sdkddkver.h>\n#include \"thirdparty/asio/include/asio.hpp\"\n\n#include \"pch.h\"\n\nusing asio::ip::tcp;\n\nclass SocketClient\n{\n    public:\n    SocketClient()\n        : is_running_(false),\n          connect_callback_(nullptr),\n          disconnect_callback_(nullptr)\n    {\n    }\n\n    void do_something();\n\n    ~SocketClient()\n    {\n\n\n\n        if (main_thread_.joinable()) {\n            main_thread_.join();\n        }\n    }\n\n    int init_socket(std::string address, std::string port = \"3240\")\n    {\n        socket_.reset(nullptr);\n\n        io_context_ = std::make_unique<asio::io_context>();\n        tcp::resolver resolver(get_io_context());\n\n        socket_ = std::make_unique<asio::ip::tcp::socket>(get_io_context());\n\n        try {\n            endpoint_ = resolver.resolve(address, port);\n        } catch (std::exception &e) {\n            return -1;\n        }\n\n        return 0;\n    }\n\n\n    void kill()\n    {\n        is_running_ = false;\n        if (k_is_proxy_init) {\n            k_shared_memory_ptr->info_page.is_proxy_ready       = 0;\n            k_shared_memory_ptr->consumer_page.command_response = 0xFFFFFFFF;\n            SetEvent(k_producer_event);\n            SetEvent(k_consumer_event);\n        }\n\n        socket_.get()->close();\n        io_context_.get()->stop();\n\n        Sleep(100);\n    }\n\n    int start()\n    {\n        using namespace std::chrono_literals;\n\n        std::unique_lock<std::mutex> lk(running_status_mutex_);\n        if (is_running_) {\n            return 0;\n        }\n\n        is_running_post_done_ = false;\n        is_running_           = true;\n\n        do_connect(endpoint_);\n\n        main_thread_ = std::thread([&]() {\n            try {\n                get_io_context().run();\n            } catch (std::exception &e) {\n                set_running_status(false, e.what());\n            }\n\n        });\n\n        running_cv_.wait(lk, [this]() { return is_running_post_done_; });\n\n        return !is_running_;\n    }\n\n    void wait_main_thread()\n    {\n        main_thread_.join();\n    }\n\n\n\n\n\n    public:\n    asio::io_context &get_io_context()\n    {\n        return *(io_context_.get());\n    }\n\n    asio::ip::tcp::socket &get_socket()\n    {\n        return *(socket_.get());\n    }\n\n    bool is_socket_running()\n    {\n        return is_running_;\n    }\n\n    void set_running_status(bool status, const std::string msg)\n    {\n        is_running_ = status;\n        if (status) {\n            if (connect_callback_) {\n                connect_callback_(msg.c_str());\n            }\n        } else {\n            if (disconnect_callback_) {\n                disconnect_callback_(msg.c_str());\n            }\n        }\n    }\n\n    void set_connect_callback(onSocketConnectCallbackType callback)\n    {\n        connect_callback_ = callback;\n    }\n\n    void set_disconnect_callback(onSocketDisconnectCallbackType callback)\n    {\n        disconnect_callback_ = callback;\n    }\n\n    private:\n    void close()\n    {\n        is_running_ = false;\n        if (k_is_proxy_init) {\n            k_shared_memory_ptr->info_page.is_proxy_ready       = 0;\n            k_shared_memory_ptr->consumer_page.command_response = 0xFFFFFFFF;\n            SetEvent(k_producer_event);\n            SetEvent(k_consumer_event);\n        }\n\n        asio::post(get_io_context(),\n                   [this]() {\n                       get_socket().close();\n                   });\n    }\n\n    void do_connect(const tcp::resolver::results_type &endpoints)\n    {\n        asio::async_connect(get_socket(), endpoints,\n                            [&](std::error_code ec, tcp::endpoint) {\n\n                                if (!ec) {\n                                    asio::ip::tcp::no_delay option(true);\n                                    get_socket().set_option(option);\n\n                                    set_keep_alive();\n\n                                    do_handshake();\n                                } else {\n                                    notify_connection_status(false, ec.message());\n                                    close();\n                                }\n                            });\n    }\n    void set_keep_alive();\n\n\n    void do_handshake();\n\n\n    void get_device_info();\n    void do_data_process();\n\n    void notify_connection_status(bool status, const std::string msg)\n    {\n        is_running_post_done_ = true;\n        set_running_status(status, msg);\n        running_cv_.notify_all();\n    }\n\n\n    private:\n    bool                    is_running_;\n    bool                    is_running_post_done_;\n    std::mutex              running_status_mutex_;\n    std::condition_variable running_cv_;\n\n    std::unique_ptr<asio::io_context> io_context_;\n    std::unique_ptr<tcp::socket>      socket_;\n\n    tcp::resolver::results_type endpoint_;\n\n    std::thread main_thread_;\n\n    onSocketConnectCallbackType    connect_callback_;\n    onSocketDisconnectCallbackType disconnect_callback_;\n};\n\n'elaphureLink/elaphureLinkProxy/protocol.cpp'\n:﻿\n#include \"pch.h\"\n\n#include \"SocketClient.hpp\"\n#include \"protocol.hpp\"\n\n\nvoid SocketClient::set_keep_alive()\n{\n    if (k_windows_version_number.major_version < 10) {\n        return;\n    } else if (k_windows_version_number.major_version == 10 && k_windows_version_number.build_number < 16299) {\n\n        return;\n    }\n\n\n\n    int enable_keepalive = 1;\n\n    int keepalive_idle_time_secs       = 20;\n    int keepalive_strobe_interval_secs = 5;\n    int num_keepalive_strobes          = 5;\n\n\n    setsockopt(socket_.get()->native_handle(), SOL_SOCKET, SO_KEEPALIVE, (char *)&enable_keepalive, sizeof(enable_keepalive));\n    setsockopt(socket_.get()->native_handle(), IPPROTO_TCP, TCP_KEEPCNT, (char *)&num_keepalive_strobes, sizeof(num_keepalive_strobes));\n    setsockopt(socket_.get()->native_handle(), IPPROTO_TCP, TCP_KEEPIDLE, (char *)&keepalive_idle_time_secs, sizeof(keepalive_idle_time_secs));\n    setsockopt(socket_.get()->native_handle(), IPPROTO_TCP, TCP_KEEPINTVL, (char *)&keepalive_strobe_interval_secs, sizeof(keepalive_strobe_interval_secs));\n}\n\nvoid SocketClient::do_handshake()\n{\n    el_request_handshake_t req;\n    req.el_link_identifier = htonl(EL_LINK_IDENTIFIER);\n    req.command            = htonl(EL_COMMAND_HANDSHAKE);\n    req.el_proxy_version   = htonl(EL_DAP_VERSION);\n\n    asio::error_code ec;\n    asio::write(get_socket(), asio::buffer(&req, sizeof(req)), ec);\n    if (ec) {\n        notify_connection_status(false, ec.message());\n        close();\n        return;\n    }\n\n\n    el_response_handshake_t res;\n\n    size_t n = asio::read(get_socket(),\n                          asio::buffer(&res, sizeof(res)),\n                          asio::transfer_exactly(sizeof(res)),\n                          ec);\n    if (ec) {\n        notify_connection_status(false, ec.message());\n        close();\n        return;\n    }\n\n    if (ntohl(res.el_link_identifier) != EL_LINK_IDENTIFIER) {\n        notify_connection_status(false, \"connect failed: unexpected identifier\");\n        close();\n        return;\n    }\n\n    if (ntohl(req.command) != EL_COMMAND_HANDSHAKE) {\n        notify_connection_status(false, \"connect failed: unexpected command\");\n        close();\n        return;\n    }\n\n    return get_device_info();\n}\n\nvoid SocketClient::get_device_info()\n{\n\n    std::array<char, 1500> info_res_buffer;\n\n\n    auto get_dap_info = [&](std::array<uint8_t, 2> buf) {\n        asio::error_code ec;\n        asio::write(get_socket(), asio::buffer(buf), asio::transfer_exactly(2), ec);\n        if (ec) {\n            notify_connection_status(false, ec.message());\n            close();\n            return false;\n        }\n\n        get_socket().read_some(asio::buffer(info_res_buffer), ec);\n\n        if (ec) {\n            notify_connection_status(false, ec.message());\n            close();\n            return false;\n        }\n\n        assert(info_res_buffer[0] == 0x00);\n        assert(info_res_buffer[1] >= 1);\n\n        return true;\n    };\n\n    if (!get_dap_info({ 0x00, 0x02 })) {\n        return;\n    }\n    int len = info_res_buffer[1];\n    memcpy(&(k_shared_memory_ptr->info_page.product_name), &info_res_buffer[2], len);\n\n\n\n    if (!get_dap_info({ 0x00, 0x03 })) {\n        return;\n    }\n    len = info_res_buffer[1];\n    memcpy(&(k_shared_memory_ptr->info_page.serial_number), &info_res_buffer[2], len);\n\n    if (!get_dap_info({ 0x00, 0x04 })) {\n        return;\n    }\n    len = info_res_buffer[1];\n    memcpy(&(k_shared_memory_ptr->info_page.firmware_version), &info_res_buffer[2], len);\n\n    if (!get_dap_info({ 0x00, 0xF0 })) {\n        return;\n    }\n    len = info_res_buffer[1];\n    assert(len == 1 || len == 2);\n    memcpy(&(k_shared_memory_ptr->info_page.capabilities), &info_res_buffer[2], len);\n\n\n\n    k_shared_memory_ptr->info_page.is_proxy_ready = 1;\n    notify_connection_status(true, \"connect succeeded\");\n    return do_data_process();\n}\n\nvoid SocketClient::do_data_process()\n{\n    asio::error_code          ec;\n    std::array<uint8_t, 1500> res_buffer;\n    int                       data_len;\n\n    for (;;) {\n\n        WaitForSingleObject(k_producer_event, INFINITE);\n        if (!is_running_) {\n            return;\n        }\n\n        asio::write(get_socket(),\n                    asio::buffer(&(k_shared_memory_ptr->producer_page.data), k_shared_memory_ptr->producer_page.data_len),\n                    ec);\n        if (ec) {\n            set_running_status(false, ec.message());\n            close();\n            return;\n        }\n\n\n        data_len = get_socket().read_some(asio::buffer(res_buffer), ec);\n        if (ec) {\n            set_running_status(false, ec.message());\n            close();\n            return;\n        }\n\n\n\n\n        uint8_t *p        = res_buffer.data();\n        int      count    = *p == ID_DAP_ExecuteCommands ? *(p + 1) : 1;\n        bool     out_flag = false;\n\n        if (*p == ID_DAP_ExecuteCommands) {\n            p += 2;\n        }\n\n        for (; count > 0; count--) {\n            switch (*p) {\n                case ID_DAP_Connect: {\n                    p += 2;\n                    break;\n                }\n                case ID_DAP_Disconnect: {\n                    p += 2;\n                    break;\n                }\n\n                case ID_DAP_TransferConfigure: {\n                    p += 2;\n                    set_consumer_status(DAP_RES_OK);\n                    break;\n                }\n                case ID_DAP_Transfer: {\n                    int transfer_count = (int)*++p;\n                    int status         = (int)*++p;\n                    p++;\n\n                    if (transfer_count != k_shared_memory_ptr->producer_page.command_count) {\n                        out_flag = true;\n\n                        set_consumer_status(DAP_RES_FAULT);\n                        break;\n                    }\n\n                    set_consumer_status(status);\n                    if (status != DAP_RES_OK) {\n\n                        out_flag = true;\n                        break;\n                    }\n\n                    int remain_data_len = data_len - (p - res_buffer.data());\n                    assert(remain_data_len % 4 == 0);\n                    k_shared_memory_ptr->consumer_page.data_len = remain_data_len;\n                    memcpy(k_shared_memory_ptr->consumer_page.data, p, remain_data_len);\n\n                    break;\n                }\n\n                case ID_DAP_TransferBlock: {\n                    p++;\n                    const int transfer_count = ((*(p + 1)) << 8) | (*p);\n                    p += 2;\n\n                    const int status = *p++;\n\n\n                    if (transfer_count != k_shared_memory_ptr->producer_page.command_count) {\n\n                        out_flag = true;\n\n                        set_consumer_status(DAP_RES_FAULT);\n                        break;\n                    }\n\n                    set_consumer_status(status);\n                    if (status != DAP_RES_OK && status != DAP_RES_FAULT) {\n\n                        out_flag = true;\n                        break;\n                    }\n\n                    const int remain_data_len = data_len - (p - res_buffer.data());\n                    assert(remain_data_len % 4 == 0);\n                    k_shared_memory_ptr->consumer_page.data_len = remain_data_len;\n                    memcpy(k_shared_memory_ptr->consumer_page.data, p, remain_data_len);\n\n                    break;\n                }\n\n                case ID_DAP_WriteABORT: {\n                    if (*(p + 1) != 0) {\n                        set_consumer_status(DAP_RES_FAULT);\n                        out_flag = true;\n                    } else {\n                        set_consumer_status(DAP_RES_OK);\n                    }\n\n                    break;\n                }\n\n                case ID_DAP_ResetTarget: {\n                    p += 3;\n                    break;\n                }\n                case ID_DAP_SWJ_Pins: {\n                    k_shared_memory_ptr->consumer_page.data_len = 1;\n                    k_shared_memory_ptr->consumer_page.data[0]  = *(p + 1);\n                    set_consumer_status(DAP_RES_OK);\n                    p += 2;\n                    break;\n                }\n                case ID_DAP_JTAG_Sequence: {\n                    if (*(p + 1) != 0) {\n                        set_consumer_status(DAP_RES_FAULT);\n                        out_flag = true;\n                        break;\n                    }\n\n                    p += 2;\n\n                    const int remain_data_len = data_len - (p - res_buffer.data());\n                    if (remain_data_len != k_shared_memory_ptr->producer_page.command_count) {\n                        out_flag = true;\n                        set_consumer_status(DAP_RES_FAULT);\n                        break;\n                    }\n                    k_shared_memory_ptr->consumer_page.data_len = remain_data_len;\n                    memcpy(k_shared_memory_ptr->consumer_page.data, p, remain_data_len);\n\n                    set_consumer_status(DAP_RES_OK);\n                    break;\n                }\n\n                case ID_DAP_JTAG_Configure: {\n                    int status = *(p + 1);\n                    p += 2;\n\n                    set_consumer_status(status == 0 ? DAP_RES_OK : DAP_RES_ERROR);\n                    break;\n                }\n\n                case ID_DAP_SWJ_Clock: {\n                    p += 2;\n                    break;\n                }\n                case ID_DAP_SWJ_Sequence: {\n                    int status = *(p + 1);\n                    p += 2;\n\n                    set_consumer_status(status == 0 ? DAP_RES_OK : DAP_RES_ERROR);\n                    break;\n                }\n                case ID_DAP_SWD_Configure: {\n                    p += 2;\n                    break;\n                }\n                default:\n                    close();\n                    return;\n            }\n\n            if (out_flag)\n                break;\n        }\n\n        if (out_flag) {\n\n        }\n\n\n\n\n\n        SetEvent(k_consumer_event);\n    }\n}\n\n'elaphureLink/thirdparty/asio/include/asio.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_HPP\n#define ASIO_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/associated_allocator.hpp\"\n#include \"asio/associated_executor.hpp\"\n#include \"asio/associated_cancellation_slot.hpp\"\n#include \"asio/associator.hpp\"\n#include \"asio/async_result.hpp\"\n#include \"asio/awaitable.hpp\"\n#include \"asio/basic_datagram_socket.hpp\"\n#include \"asio/basic_deadline_timer.hpp\"\n#include \"asio/basic_file.hpp\"\n#include \"asio/basic_io_object.hpp\"\n#include \"asio/basic_random_access_file.hpp\"\n#include \"asio/basic_raw_socket.hpp\"\n#include \"asio/basic_readable_pipe.hpp\"\n#include \"asio/basic_seq_packet_socket.hpp\"\n#include \"asio/basic_serial_port.hpp\"\n#include \"asio/basic_signal_set.hpp\"\n#include \"asio/basic_socket.hpp\"\n#include \"asio/basic_socket_acceptor.hpp\"\n#include \"asio/basic_socket_iostream.hpp\"\n#include \"asio/basic_socket_streambuf.hpp\"\n#include \"asio/basic_stream_file.hpp\"\n#include \"asio/basic_stream_socket.hpp\"\n#include \"asio/basic_streambuf.hpp\"\n#include \"asio/basic_waitable_timer.hpp\"\n#include \"asio/basic_writable_pipe.hpp\"\n#include \"asio/bind_allocator.hpp\"\n#include \"asio/bind_cancellation_slot.hpp\"\n#include \"asio/bind_executor.hpp\"\n#include \"asio/buffer.hpp\"\n#include \"asio/buffer_registration.hpp\"\n#include \"asio/buffered_read_stream_fwd.hpp\"\n#include \"asio/buffered_read_stream.hpp\"\n#include \"asio/buffered_stream_fwd.hpp\"\n#include \"asio/buffered_stream.hpp\"\n#include \"asio/buffered_write_stream_fwd.hpp\"\n#include \"asio/buffered_write_stream.hpp\"\n#include \"asio/buffers_iterator.hpp\"\n#include \"asio/cancellation_signal.hpp\"\n#include \"asio/cancellation_state.hpp\"\n#include \"asio/cancellation_type.hpp\"\n#include \"asio/co_spawn.hpp\"\n#include \"asio/completion_condition.hpp\"\n#include \"asio/compose.hpp\"\n#include \"asio/connect.hpp\"\n#include \"asio/connect_pipe.hpp\"\n#include \"asio/coroutine.hpp\"\n#include \"asio/deadline_timer.hpp\"\n#include \"asio/defer.hpp\"\n#include \"asio/detached.hpp\"\n#include \"asio/dispatch.hpp\"\n#include \"asio/error.hpp\"\n#include \"asio/error_code.hpp\"\n#include \"asio/execution.hpp\"\n#include \"asio/execution/allocator.hpp\"\n#include \"asio/execution/any_executor.hpp\"\n#include \"asio/execution/blocking.hpp\"\n#include \"asio/execution/blocking_adaptation.hpp\"\n#include \"asio/execution/bulk_execute.hpp\"\n#include \"asio/execution/bulk_guarantee.hpp\"\n#include \"asio/execution/connect.hpp\"\n#include \"asio/execution/context.hpp\"\n#include \"asio/execution/context_as.hpp\"\n#include \"asio/execution/execute.hpp\"\n#include \"asio/execution/executor.hpp\"\n#include \"asio/execution/invocable_archetype.hpp\"\n#include \"asio/execution/mapping.hpp\"\n#include \"asio/execution/occupancy.hpp\"\n#include \"asio/execution/operation_state.hpp\"\n#include \"asio/execution/outstanding_work.hpp\"\n#include \"asio/execution/prefer_only.hpp\"\n#include \"asio/execution/receiver.hpp\"\n#include \"asio/execution/receiver_invocation_error.hpp\"\n#include \"asio/execution/relationship.hpp\"\n#include \"asio/execution/schedule.hpp\"\n#include \"asio/execution/scheduler.hpp\"\n#include \"asio/execution/sender.hpp\"\n#include \"asio/execution/set_done.hpp\"\n#include \"asio/execution/set_error.hpp\"\n#include \"asio/execution/set_value.hpp\"\n#include \"asio/execution/start.hpp\"\n#include \"asio/execution_context.hpp\"\n#include \"asio/executor.hpp\"\n#include \"asio/executor_work_guard.hpp\"\n#include \"asio/file_base.hpp\"\n#include \"asio/generic/basic_endpoint.hpp\"\n#include \"asio/generic/datagram_protocol.hpp\"\n#include \"asio/generic/raw_protocol.hpp\"\n#include \"asio/generic/seq_packet_protocol.hpp\"\n#include \"asio/generic/stream_protocol.hpp\"\n#include \"asio/handler_alloc_hook.hpp\"\n#include \"asio/handler_continuation_hook.hpp\"\n#include \"asio/handler_invoke_hook.hpp\"\n#include \"asio/high_resolution_timer.hpp\"\n#include \"asio/io_context.hpp\"\n#include \"asio/io_context_strand.hpp\"\n#include \"asio/io_service.hpp\"\n#include \"asio/io_service_strand.hpp\"\n#include \"asio/ip/address.hpp\"\n#include \"asio/ip/address_v4.hpp\"\n#include \"asio/ip/address_v4_iterator.hpp\"\n#include \"asio/ip/address_v4_range.hpp\"\n#include \"asio/ip/address_v6.hpp\"\n#include \"asio/ip/address_v6_iterator.hpp\"\n#include \"asio/ip/address_v6_range.hpp\"\n#include \"asio/ip/network_v4.hpp\"\n#include \"asio/ip/network_v6.hpp\"\n#include \"asio/ip/bad_address_cast.hpp\"\n#include \"asio/ip/basic_endpoint.hpp\"\n#include \"asio/ip/basic_resolver.hpp\"\n#include \"asio/ip/basic_resolver_entry.hpp\"\n#include \"asio/ip/basic_resolver_iterator.hpp\"\n#include \"asio/ip/basic_resolver_query.hpp\"\n#include \"asio/ip/host_name.hpp\"\n#include \"asio/ip/icmp.hpp\"\n#include \"asio/ip/multicast.hpp\"\n#include \"asio/ip/resolver_base.hpp\"\n#include \"asio/ip/resolver_query_base.hpp\"\n#include \"asio/ip/tcp.hpp\"\n#include \"asio/ip/udp.hpp\"\n#include \"asio/ip/unicast.hpp\"\n#include \"asio/ip/v6_only.hpp\"\n#include \"asio/is_applicable_property.hpp\"\n#include \"asio/is_executor.hpp\"\n#include \"asio/is_read_buffered.hpp\"\n#include \"asio/is_write_buffered.hpp\"\n#include \"asio/local/basic_endpoint.hpp\"\n#include \"asio/local/connect_pair.hpp\"\n#include \"asio/local/datagram_protocol.hpp\"\n#include \"asio/local/stream_protocol.hpp\"\n#include \"asio/multiple_exceptions.hpp\"\n#include \"asio/packaged_task.hpp\"\n#include \"asio/placeholders.hpp\"\n#include \"asio/posix/basic_descriptor.hpp\"\n#include \"asio/posix/basic_stream_descriptor.hpp\"\n#include \"asio/posix/descriptor.hpp\"\n#include \"asio/posix/descriptor_base.hpp\"\n#include \"asio/posix/stream_descriptor.hpp\"\n#include \"asio/post.hpp\"\n#include \"asio/prefer.hpp\"\n#include \"asio/query.hpp\"\n#include \"asio/random_access_file.hpp\"\n#include \"asio/read.hpp\"\n#include \"asio/read_at.hpp\"\n#include \"asio/read_until.hpp\"\n#include \"asio/readable_pipe.hpp\"\n#include \"asio/recycling_allocator.hpp\"\n#include \"asio/redirect_error.hpp\"\n#include \"asio/registered_buffer.hpp\"\n#include \"asio/require.hpp\"\n#include \"asio/require_concept.hpp\"\n#include \"asio/serial_port.hpp\"\n#include \"asio/serial_port_base.hpp\"\n#include \"asio/signal_set.hpp\"\n#include \"asio/socket_base.hpp\"\n#include \"asio/static_thread_pool.hpp\"\n#include \"asio/steady_timer.hpp\"\n#include \"asio/strand.hpp\"\n#include \"asio/stream_file.hpp\"\n#include \"asio/streambuf.hpp\"\n#include \"asio/system_context.hpp\"\n#include \"asio/system_error.hpp\"\n#include \"asio/system_executor.hpp\"\n#include \"asio/system_timer.hpp\"\n#include \"asio/this_coro.hpp\"\n#include \"asio/thread.hpp\"\n#include \"asio/thread_pool.hpp\"\n#include \"asio/time_traits.hpp\"\n#include \"asio/use_awaitable.hpp\"\n#include \"asio/use_future.hpp\"\n#include \"asio/uses_executor.hpp\"\n#include \"asio/version.hpp\"\n#include \"asio/wait_traits.hpp\"\n#include \"asio/windows/basic_object_handle.hpp\"\n#include \"asio/windows/basic_overlapped_handle.hpp\"\n#include \"asio/windows/basic_random_access_handle.hpp\"\n#include \"asio/windows/basic_stream_handle.hpp\"\n#include \"asio/windows/object_handle.hpp\"\n#include \"asio/windows/overlapped_handle.hpp\"\n#include \"asio/windows/overlapped_ptr.hpp\"\n#include \"asio/windows/random_access_handle.hpp\"\n#include \"asio/windows/stream_handle.hpp\"\n#include \"asio/writable_pipe.hpp\"\n#include \"asio/write.hpp\"\n#include \"asio/write_at.hpp\"\n\n#endif\n",
        "gt": [
            "'elaphureLink/thirdparty/asio/include/asio/execution/receiver_invocation_error.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio.hpp'",
            "'elaphureLink/elaphureLinkProxy/SocketClient.hpp'",
            "'elaphureLink/elaphureLinkProxy/protocol.cpp'"
        ]
    },
    {
        "files": [
            "'xictools/xt_base/include/qtinterf/qtfont.h'",
            "'xictools/xic/src/qtxic/qtmain.h'",
            "'xictools/xic/src/qtxic/qttech.h'"
        ],
        "content": "'xictools/xt_base/include/qtinterf/qtfont.h'\n:\n\n\n#ifndef QTFONT_H\n#define QTFONT_H\n\n#include \"ginterf/graphics.h\"\n#include \"ginterf/grfont.h\"\n\n#include <QVariant>\n#include <QDialog>\n#include <QKeyEvent>\n\n\n\n\n\n\nclass QFont;\nclass QListWidget;\nclass QListWidgetItem;\nclass QTextEdit;\nclass QFontDatabase;\nclass QTextButton;\nclass QToolButton;\nclass QComboBox;\n\nnamespace qtinterf {\n    class QTbag;\n    class QTfont;\n    class QTfontDlg;\n}\n\nclass qtinterf::QTfont : public QObject, public GRfont\n{\n    Q_OBJECT\n\npublic:\n    QTfont();\n    ~QTfont();\n\n    void initFonts();\n    GRfontType getType();\n    void setName(const char*, int);\n    const char *getName(int);\n    char *getFamilyName(int);\n    bool getFont(void*, int);\n    void registerCallback(void*, int);\n    void unregisterCallback(void*, int);\n    QFont *new_font(const char*, bool);\n\n    static bool stringBounds(const char*, int, int*, int*);\n    static bool stringBounds(const char*, const QWidget*, int*, int*);\n    static int stringWidth(const char*, int);\n    static int stringWidth(const char*, const QWidget*);\n    static int lineHeight(int);\n    static int lineHeight(const QWidget*);\n\n    static QTfont *self()\n        {\n            if (!instancePtr)\n                on_null_ptr();\n            return (instancePtr);\n        }\n\nsignals:\n    void fontChanged(int);\n\nprivate:\n    void refresh(int);\n    static void on_null_ptr();\n\n    struct FcbRec\n    {\n        FcbRec(QWidget *w, FcbRec *n) { widget = w; next = n; }\n\n        QWidget *widget;\n        FcbRec *next;\n    };\n\n    struct sFrec\n    {\n        sFrec() { name = 0; font = 0; cbs = 0; }\n\n        const char *name;\n        QFont *font;\n        FcbRec *cbs;\n    } fonts[MAX_NUM_APP_FONTS];\n\n    static QTfont *instancePtr;\n};\n\nclass qtinterf::QTfontDlg : public QDialog, public GRfontPopup\n{\n    Q_OBJECT\n\npublic:\n    QTfontDlg(QTbag*, int, void*);\n    ~QTfontDlg();\n\n#ifdef Q_OS_MACOS\n    bool event(QEvent*);\n#endif\n\n    void set_transient_for(QWidget *prnt)\n        {\n            Qt::WindowFlags f = windowFlags();\n            setParent(prnt);\n#ifdef Q_OS_MACOS\n            f |= Qt::Tool;\n#endif\n            setWindowFlags(f);\n        }\n\n\n    void keyPressEvent(QKeyEvent *ev)\n        {\n            if (ev->key() != Qt::Key_Escape)\n                QDialog::keyPressEvent(ev);\n        }\n\n\n    void set_visible(bool visib)\n        {\n            if (visib) {\n                show();\n                raise();\n                activateWindow();\n            }\n            else\n                hide();\n        }\n    void register_caller(GRobject, bool=false, bool=false);\n    void popdown();\n\n\n    void set_font_name(const char*);\n    void update_label(const char*);\n\n    void select_font(const QFont*);\n    QFont *current_selection();\n    char *current_face();\n    char *current_style();\n    int current_size();\n    void add_choice(const QFont*, const char*);\n    void set_apply_btn_name(const char*);\n\nsignals:\n    void select_action(int, const char*, void*);\n\nprivate slots:\n    void action_slot();\n    void quit_slot();\n    void cancel_action_slot(bool);\n    void face_changed_slot(QListWidgetItem*, QListWidgetItem*);\n    void style_changed_slot(QListWidgetItem*, QListWidgetItem*);\n    void size_changed_slot(QListWidgetItem*, QListWidgetItem*);\n    void menu_choice_slot(int);\n\nprivate:\n    QListWidget *ft_face_list;\n    QListWidget *ft_style_list;\n    QListWidget *ft_size_list;\n    QTextEdit   *ft_preview;\n    QToolButton *ft_apply;\n    QComboBox   *ft_menu;\n    QFontDatabase *ft_fdb;\n\n    static QTfontDlg *activeFontSels[4];\n};\n\n#endif\n\n\n'xictools/xic/src/qtxic/qtmain.h'\n:\n\n\n#ifndef QTMAIN_H\n#define QTMAIN_H\n\n#include \"main.h\"\n#include \"qtinterf/qtinterf.h\"\n#include \"qtinterf/qtfont.h\"\n#include \"qtinterf/qtcanvas.h\"\n#include \"dsp_tkif.h\"\n\n#include <QDialog>\n#include <QEvent>\n#include <QKeyEvent>\n#include <QFontMetrics>\n\n\n\n\n\nstruct sKeyEvent;\nclass QTcoord;\nclass QTparam;\nclass cKeys;\nclass QTexpandDlg;\nclass QTzoomDlg;\nclass QTgridDlg;\nclass QTidleproc;\nclass QTltab;\n\nclass QMenu;\nclass QMenuBar;\nclass QToolBar;\nclass QLineEdit;\nclass QPushButton;\nclass QEnterEvent;\nclass QFocusEvent;\nclass QSplitter;\nclass QWheelEvent;\n\n\nenum XIC_WINDOW_CLASS\n{\n    XW_DEFAULT,\n    XW_TEXT,\n    XW_DRAWING,\n    XW_LPAL,\n    XW_LTAB\n};\n\n#define GS_NBTNS 8\n\ntypedef bool(*EventHandlerFunc)(QObject*, QEvent*, void*);\n\nclass QTeventMonitor : public QObject\n{\n    Q_OBJECT\n\npublic:\n\n\n    struct evl_t\n    {\n        evl_t(QObject *o, QEvent *e) : obj(o), ev(e), next(0) { }\n        ~evl_t()    { delete ev; }\n\n        QObject     *obj;\n        QEvent      *ev;\n        evl_t       *next;\n    };\n\n\n\n    struct ol_t\n    {\n        ol_t(const QObject *o, ol_t *n) : obj(o), next(n) { }\n\n        const QObject *obj;\n        ol_t        *next;\n    };\n\n    QTeventMonitor()\n    {\n        em_event_list = 0;\n        em_busy_allow_list = 0;\n        em_event_handler = 0;\n        em_event_handler_arg = 0;\n        for (int i = 0; i < GS_NBTNS; i++)\n            em_button_state[i] = false;\n    }\n\n    bool has_saved_events() const   { return (em_event_list != 0); }\n\n\n\n    void do_saved_events()\n        {\n            while (em_event_list) {\n                evl_t *evtmp = em_event_list;\n                em_event_list = evtmp->next;\n                QObject::eventFilter(evtmp->obj, evtmp->ev);\n                delete evtmp;\n            }\n        }\n\n\n\n    void save_event(QObject *obj, const QEvent *evp)\n        {\n#if QT_VERSION >= QT_VERSION_CHECK(6,0,0)\n            QEvent *ev = evp->clone();\n#else\n\n            (void)evp;\n            QEvent *ev = 0;\n#endif\n            if (!em_event_list)\n                em_event_list = new evl_t(obj, ev);\n            else {\n                evl_t *evl = em_event_list;\n                while (evl->next)\n                    evl = evl->next;\n                evl->next = new evl_t(obj, ev);\n            }\n        }\n\n\n\n    bool is_busy_allow(const QObject *obj)\n        {\n            for (ol_t *e = em_busy_allow_list; e; e = e->next) {\n                if (e->obj == obj)\n                    return (true);\n            }\n            return (false);\n        }\n\n\n\n\n    void add_busy_allow(const QObject *obj)\n        {\n            if (!is_busy_allow(obj)) {\n                em_busy_allow_list = new ol_t(obj, em_busy_allow_list);\n            }\n        }\n\n\n\n    void remove_busy_allow(const QObject *obj)\n        {\n            ol_t *ep = 0;\n            for (ol_t *e = em_busy_allow_list; e; e = e->next) {\n                if (e->obj == obj) {\n                    if (ep)\n                        ep->next = e->next;\n                    else\n                        em_busy_allow_list = e->next;\n                    delete e;\n                    return;\n                }\n                ep = e;\n            }\n        }\n\n    EventHandlerFunc set_event_handler(EventHandlerFunc func, void *arg)\n        {\n            EventHandlerFunc f = em_event_handler;\n            em_event_handler = func;\n            em_event_handler_arg = arg;\n            return (f);\n        }\n\n    static int saved_events_idle(void *arg)\n        {\n            QTeventMonitor *evmon = static_cast<QTeventMonitor*>(arg);\n            if (evmon)\n                evmon->do_saved_events();\n            return (0);\n        }\n\n    static void  log_event(const QObject*, const QEvent*);\n\nprivate:\n    evl_t       *em_event_list;\n    ol_t        *em_busy_allow_list;\n    EventHandlerFunc em_event_handler;\n    void        *em_event_handler_arg;\n    bool        em_button_state[GS_NBTNS];\n\nprotected:\n    bool eventFilter(QObject*, QEvent*) override;\n};\n\n\nclass QTpkg : public DSPpkg\n{\npublic:\n    QTpkg()\n        {\n            pkg_busy_popup      = 0;\n            pkg_in_main_loop    = false;\n            pkg_not_mapped      = false;\n        }\n\n    static QTpkg *self() { return (dynamic_cast<QTpkg*>(DSPpkg::self())); }\n\n\n    GRwbag *NewGX();\n    int Initialize(GRwbag*);\n    void ReinitNoGraphics();\n    void Halt();\n    void AppLoop();\n    bool CheckForInterrupt();\n    int Iconify(int);\n    bool SubwinInit(int);\n    void SubwinDestroy(int);\n\n    bool SetWorking(bool);\n    void SetOverrideBusy(bool);\n    bool GetMainWinIdentifier(char*);\n\n    bool UsingX11();\n    void CloseGraphicsConnection();\n    const char *GetDisplayString();\n    bool CheckScreenAccess(hostent*, const char*, const char*);\n    int RegisterIdleProc(int(*)(void*), void*);\n    bool RemoveIdleProc(int);\n    int RegisterTimeoutProc(int, int(*)(void*), void*);\n    bool RemoveTimeoutProc(int);\n    int StartTimer(int, bool*);\n    void SetFont(const char*, int, FNT_FMT = FNT_FMT_ANY);\n    const char *GetFont(int);\n    FNT_FMT GetFontFmt();\n\n\n    void PopUpBusy();\n    void SetWaitCursor(bool);\n\n    QTeventMonitor *EventMonitor()      { return (&pkg_event_monitor); }\n    void RegisterEventHandler(EventHandlerFunc f, void *a)\n                                { pkg_event_monitor.set_event_handler(f, a); }\n    bool NotMapped()                    { return (pkg_not_mapped); }\n\nprivate:\n    static int busy_msg_timeout(void*);\n\n    GRpopup     *pkg_busy_popup;\n    bool        pkg_in_main_loop;\n    bool        pkg_not_mapped;\n    QTeventMonitor pkg_event_monitor;\n};\n\n\n#define CBUFMAX 15\n\nclass cKeys : public QTcanvas\n{\n    Q_OBJECT\n\npublic:\n    cKeys(int, QWidget*);\n\n    QSize sizeHint() const;\n    void show_keys();\n    void set_keys(const char*);\n    void bsp_keys();\n    void check_exec(bool);\n\n    int key_pos()       { return (k_keypos); }\n    int key(int k)      { return (k_keys[k]); }\n    char *key_buf()     { return (k_keys); }\n    void append(char c) { k_keys[k_keypos++] = c; }\n\nprivate slots:\n    void font_changed(int);\n\nprivate:\n    int k_keypos;\n    int k_win_number;\n    char k_keys[CBUFMAX + 1];\n    const char *k_cmd;\n};\n\nclass QTsubwin : public QDialog, virtual public DSPwbag, public QTbag,\n    public QTdraw\n{\n    Q_OBJECT\n\npublic:\n    QTsubwin(int, QWidget* = 0);\n    ~QTsubwin();\n\n\n    void keyPressEvent(QKeyEvent *ev)\n        {\n            if (ev->key() != Qt::Key_Escape)\n                QDialog::keyPressEvent(ev);\n        }\n\n\n\n\n    void SwitchToPixmap();\n    void SwitchFromPixmap(const BBox*);\n    GRobject DrawableReset();\n    void CopyPixmap(const BBox*);\n    void DestroyPixmap();\n    bool DumpWindow(const char*, const BBox*);\n    bool PixmapOk();\n\n\n    void GetTextBuf(char*);\n    void SetTextBuf(const char*);\n    void ShowKeys();\n    void SetKeys(const char*);\n    void BspKeys();\n    bool AddKey(int);\n    bool CheckBsp();\n    void CheckExec(bool);\n    char *KeyBuf();\n    int KeyPos();\n\n\n    void SetLabelText(const char*);\n\n\n    void PopUpGrid(GRobject, ShowMode);\n    void PopUpExpand(GRobject, ShowMode,\n        bool(*)(const char*, void*), void*, const char*, bool);\n    void PopUpZoom(GRobject, ShowMode);\n\n\n\n    QToolBar *ToolBar()             const { return (sw_toolbar); }\n    cKeys *Keys()                   const { return (sw_keys_pressed); }\n    void clear_expand()             { sw_expand = 0; }\n    int win_number()                const { return (sw_win_number); }\n    int cursor_type()               const { return (sw_cursor_type); }\n    void set_cursor_type(int c)     { sw_cursor_type = c; }\n\n    QSize sizeHint()                const { return (QSize(500, 400)); }\n    QSize minimumSizeHint()         const { return (QSize(250, 200)); }\n\n\n\n    bool focusNextPrevChild(bool);\n\n    bool keypress_handler(unsigned int, unsigned int, const char*, bool, bool);\n\nsignals:\n    void update_coords(int, int);\n\nprotected slots:\n    void resize_slot(QResizeEvent*);\n    void button_down_slot(QMouseEvent*);\n    void button_up_slot(QMouseEvent*);\n    void double_click_slot(QMouseEvent*);\n    void motion_slot(QMouseEvent*);\n    void key_down_slot(QKeyEvent*);\n    void key_up_slot(QKeyEvent*);\n    void enter_slot(QEnterEvent*);\n    void leave_slot(QEvent*);\n    void focus_in_slot(QFocusEvent*);\n    void focus_out_slot(QFocusEvent*);\n    void mouse_wheel_slot(QWheelEvent*);\n    void drag_enter_slot(QDragEnterEvent*);\n    void drop_slot(QDropEvent*);\n    void font_changed(int);\n    void help_slot();\n\nprotected:\n    QToolBar    *sw_toolbar;\n    QPixmap     *sw_pixmap;\n    cKeys       *sw_keys_pressed;\n    QTexpandDlg *sw_expand;\n    QTzoomDlg   *sw_zoom;\n    QTgridDlg   *sw_gridpop;\n    WindowDesc  *sw_windesc;\n    int         sw_win_number;\n    int         sw_cursor_type;\n    int         sw_x0;\n    int         sw_y0;\n};\n\nstruct RunQueuedStruct\n{\n    RunQueuedStruct() { }\n    RunQueuedStruct(int(*f)(void*)) : func(f) { }\n    int (*func)(void*);\n};\nQ_DECLARE_METATYPE(RunQueuedStruct);\n\nclass QTmainwin : public QTsubwin\n{\n    Q_OBJECT\n\npublic:\n    static QTmainwin *self()\n        {\n            if (DSP()->MainWdesc())\n                return (dynamic_cast<QTmainwin*>(DSP()->MainWdesc()->Wbag()));\n            return (0);\n        }\n\n    static bool exists()\n        {\n            if (DSP()->MainWdesc()) {\n                return (dynamic_cast<QTmainwin*>(\n                    DSP()->MainWdesc()->Wbag()) != 0);\n            }\n            return (false);\n        }\n\n    QMenuBar *MenuBar()         { return (mw_menubar); }\n    QWidget *PromptLine()       { return (mw_promptline); }\n    QTltab *LayerTable()        { return (mw_layertab); }\n    QSplitter *splitter()       { return (mw_splitter); }\n\n    QWidget *TopButtonBox()     { return (mw_top_button_box); }\n    QWidget *PhysButtonBox()    { return (mw_phys_button_box); }\n    QWidget *ElecButtonBox()    { return (mw_elec_button_box); }\n\n\n    QTmainwin(QWidget* = 0);\n#ifdef Q_OS_MACOS\n    bool event(QEvent*);\n#endif\n    QSize sizeHint() const;\n    QSize minimumSizeHint() const;\n    void initialize();\n    void send_key_event(sKeyEvent*);\n\n\n    static char *get_cell_selection();\n    static void cells_panic();\n\n\n    static char *get_file_selection();\n    static void files_panic();\n\n\n    static char *get_lib_selection();\n    static void libs_panic();\n\n\n    static char *get_tree_selection();\n    static void tree_panic();\n\nsignals:\n    void side_button_press(MenuEnt*);\n    void run_queued(RunQueuedStruct, void*);\n\npublic slots:\n    void update_coords_slot(int, int);\n\nprivate slots:\n    void run_queued_slot(RunQueuedStruct, void*);\n\nprivate:\n\n    void closeEvent(QCloseEvent*);\n\n    QMenuBar    *mw_menubar;\n    QWidget     *mw_top_button_box;\n    QWidget     *mw_phys_button_box;\n    QWidget     *mw_elec_button_box;\n    QSplitter   *mw_splitter;\n\n    QWidget     *mw_promptline;\n    QTcoord     *mw_coords;\n    QTltab      *mw_layertab;\n    QTparam     *mw_status;\n};\n\n\n\n\n\n\ninline unsigned int mod_state(int qtstate)\n{\n    int state = 0;\n    if (qtstate & Qt::ShiftModifier)\n        state |= GR_SHIFT_MASK;\n    if (qtstate & Qt::ControlModifier)\n        state |= GR_CONTROL_MASK;\n    if (qtstate & Qt::AltModifier)\n        state |= GR_ALT_MASK;\n    if (qtstate & Qt::KeypadModifier)\n        state |= GR_KEYPAD_MASK;\n    return (state);\n}\n\n\ninline bool is_modifier_key(int key)\n{\n    return (\n        key == Qt::Key_Shift    ||\n        key == Qt::Key_Control  ||\n        key == Qt::Key_Meta     ||\n        key == Qt::Key_Alt      ||\n        key == Qt::Key_CapsLock);\n}\n\n#endif\n\n\n'xictools/xic/src/qtxic/qttech.h'\n:\n\n\n#ifndef QTTECH_H\n#define QTTECH_H\n\n#include \"main.h\"\n#include \"qtmain.h\"\n\n#include <QDialog>\n#include <QKeyEvent>\n\n\n\n\n\nclass QRadioButton;\nclass QToolButton;\nclass QLineEdit;\n\nclass QTwriteTechDlg : public QDialog\n{\n    Q_OBJECT\n\npublic:\n    QTwriteTechDlg(GRobject);\n    ~QTwriteTechDlg();\n\n#ifdef Q_OS_MACOS\n    bool event(QEvent*);\n#endif\n\n    void update();\n\n    void set_transient_for(QWidget *prnt)\n        {\n            Qt::WindowFlags f = windowFlags();\n            setParent(prnt);\n#ifdef Q_OS_MACOS\n            f |= Qt::Tool;\n#endif\n            setWindowFlags(f);\n        }\n\n\n    void keyPressEvent(QKeyEvent *ev)\n        {\n            if (ev->key() != Qt::Key_Escape)\n                QDialog::keyPressEvent(ev);\n        }\n\n    static QTwriteTechDlg *self()           { return (instPtr); }\n\nprivate slots:\n    void none_btn_slot(bool);\n    void cmt_btn_slot(bool);\n    void use_btn_slot(bool);\n    void help_btn_slot();\n    void write_btn_slot();\n    void dismiss_btn_slot();\n\nprivate:\n    GRobject    tc_caller;\n    QRadioButton *tc_none;\n    QRadioButton *tc_cmt;\n    QRadioButton *tc_use;\n    QLineEdit   *tc_entry;\n    QToolButton *tc_write;\n\n    static QTwriteTechDlg *instPtr;\n};\n\n#endif\n\n",
        "gt": [
            "'xictools/xt_base/include/qtinterf/qtfont.h'",
            "'xictools/xic/src/qtxic/qtmain.h'",
            "'xictools/xic/src/qtxic/qttech.h'"
        ]
    },
    {
        "files": [
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'",
            "'Tempest/Engine/gapi/metal/mtsamplercache.h'",
            "'Tempest/Engine/gapi/metal/mtdevice.h'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLResourceStateCommandEncoder.hpp'",
            "'Tempest/Engine/gapi/metalapi.cpp'"
        ],
        "content": "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n\n\n#include \"MTLAccelerationStructure.hpp\"\n#include \"MTLAccelerationStructureCommandEncoder.hpp\"\n#include \"MTLAccelerationStructureTypes.hpp\"\n#include \"MTLArgument.hpp\"\n#include \"MTLArgumentEncoder.hpp\"\n#include \"MTLBinaryArchive.hpp\"\n#include \"MTLBlitCommandEncoder.hpp\"\n#include \"MTLBlitPass.hpp\"\n#include \"MTLBuffer.hpp\"\n#include \"MTLCaptureManager.hpp\"\n#include \"MTLCaptureScope.hpp\"\n#include \"MTLCommandBuffer.hpp\"\n#include \"MTLCommandEncoder.hpp\"\n#include \"MTLCommandQueue.hpp\"\n#include \"MTLComputeCommandEncoder.hpp\"\n#include \"MTLComputePass.hpp\"\n#include \"MTLComputePipeline.hpp\"\n#include \"MTLCounters.hpp\"\n#include \"MTLDefines.hpp\"\n#include \"MTLDepthStencil.hpp\"\n#include \"MTLDevice.hpp\"\n#include \"MTLDrawable.hpp\"\n#include \"MTLDynamicLibrary.hpp\"\n#include \"MTLEvent.hpp\"\n#include \"MTLFence.hpp\"\n#include \"MTLFunctionConstantValues.hpp\"\n#include \"MTLFunctionDescriptor.hpp\"\n#include \"MTLFunctionHandle.hpp\"\n#include \"MTLFunctionLog.hpp\"\n#include \"MTLFunctionStitching.hpp\"\n#include \"MTLHeaderBridge.hpp\"\n#include \"MTLHeap.hpp\"\n#include \"MTLIndirectCommandBuffer.hpp\"\n#include \"MTLIndirectCommandEncoder.hpp\"\n#include \"MTLIntersectionFunctionTable.hpp\"\n#include \"MTLIOCommandBuffer.hpp\"\n#include \"MTLIOCommandQueue.hpp\"\n#include \"MTLIOCompressor.hpp\"\n#include \"MTLLibrary.hpp\"\n#include \"MTLLinkedFunctions.hpp\"\n#include \"MTLParallelRenderCommandEncoder.hpp\"\n#include \"MTLPipeline.hpp\"\n#include \"MTLPixelFormat.hpp\"\n#include \"MTLPrivate.hpp\"\n#include \"MTLRasterizationRate.hpp\"\n#include \"MTLRenderCommandEncoder.hpp\"\n#include \"MTLRenderPass.hpp\"\n#include \"MTLRenderPipeline.hpp\"\n#include \"MTLResource.hpp\"\n#include \"MTLResourceStateCommandEncoder.hpp\"\n#include \"MTLResourceStatePass.hpp\"\n#include \"MTLSampler.hpp\"\n#include \"MTLStageInputOutputDescriptor.hpp\"\n#include \"MTLTexture.hpp\"\n#include \"MTLTypes.hpp\"\n#include \"MTLVertexDescriptor.hpp\"\n#include \"MTLVisibleFunctionTable.hpp\"\n#include \"MTLVersion.hpp\"\n\n\n\n'Tempest/Engine/gapi/metal/mtsamplercache.h'\n:#pragma once\n\n#include <Tempest/AbstractGraphicsApi>\n#include <Metal/Metal.hpp>\n#include <mutex>\n\n#include \"nsptr.h\"\n\nnamespace Tempest {\nnamespace Detail {\n\nclass MtDevice;\n\nclass MtSamplerCache {\n  public:\n    MtSamplerCache(MTL::Device& dev);\n    ~MtSamplerCache();\n\n    MTL::SamplerState& get(Sampler src, bool argBuffers=false);\n\n  private:\n    NsPtr<MTL::SamplerState> mkSampler(const Sampler& src, bool argBuffers);\n\n    struct Entry {\n      Sampler                  src;\n      bool                     argBuffers = false;\n      NsPtr<MTL::SamplerState> val;\n      };\n\n    MTL::Device&             dev;\n    NsPtr<MTL::SamplerState> def;\n\n    std::mutex               sync;\n    std::vector<Entry>       values;\n  };\n\n}\n}\n\n'Tempest/Engine/gapi/metal/mtdevice.h'\n:#pragma once\n\n#include <Tempest/AbstractGraphicsApi>\n#include <Tempest/AccelerationStructure>\n#include <Tempest/RenderState>\n#include <Tempest/Except>\n\n#include <Metal/Metal.hpp>\n#include <Foundation/Foundation.hpp>\n\n#include \"../utility/compiller_hints.h\"\n#include \"gapi/shaderreflection.h\"\n#include \"mtsamplercache.h\"\n#include \"nsptr.h\"\n\nclass MTLDevice;\n\nnamespace Tempest {\nnamespace Detail {\n\ninline MTL::PixelFormat nativeFormat(TextureFormat frm) {\n  switch(frm) {\n    case Undefined:\n    case Last:\n      return MTL::PixelFormatInvalid;\n    case R8:\n      return MTL::PixelFormatR8Unorm;\n    case RG8:\n      return MTL::PixelFormatRG8Unorm;\n    case RGB8:\n      return MTL::PixelFormatInvalid;\n    case RGBA8:\n      return MTL::PixelFormatRGBA8Unorm;\n    case R16:\n      return MTL::PixelFormatR16Unorm;\n    case RG16:\n      return MTL::PixelFormatRG16Unorm;\n    case RGB16:\n      return MTL::PixelFormatInvalid;\n    case RGBA16:\n      return MTL::PixelFormatRGBA16Unorm;\n    case R32F:\n      return MTL::PixelFormatR32Float;\n    case RG32F:\n      return MTL::PixelFormatRG32Float;\n    case RGB32F:\n      return MTL::PixelFormatInvalid;\n    case RGBA32F:\n      return MTL::PixelFormatRGBA32Float;\n    case R32U:\n      return MTL::PixelFormatR32Uint;\n    case RG32U:\n      return MTL::PixelFormatRG32Uint;\n    case RGB32U:\n      return MTL::PixelFormatInvalid;\n    case RGBA32U:\n      return MTL::PixelFormatRGBA32Uint;\n    case Depth16:\n      return MTL::PixelFormatDepth16Unorm;\n    case Depth24x8:\n      return MTL::PixelFormatInvalid;\n    case Depth24S8:\n      return MTL::PixelFormatDepth24Unorm_Stencil8;\n    case Depth32F:\n      return MTL::PixelFormatDepth32Float;\n    case DXT1:\n      return MTL::PixelFormatBC1_RGBA;\n    case DXT3:\n      return MTL::PixelFormatBC2_RGBA;\n    case DXT5:\n      return MTL::PixelFormatBC3_RGBA;\n    case R11G11B10UF:\n      return MTL::PixelFormatRG11B10Float;\n    case RGBA16F:\n      return MTL::PixelFormatRGBA16Float;\n    }\n  return MTL::PixelFormatInvalid;\n  }\n\ninline MTL::VertexFormat nativeFormat(Decl::ComponentType t) {\n  switch(t) {\n    case Decl::ComponentType::count:\n    case Decl::ComponentType::float0:\n      return MTL::VertexFormatInvalid;\n    case Decl::ComponentType::float1:\n      return MTL::VertexFormatFloat;\n    case Decl::ComponentType::float2:\n      return MTL::VertexFormatFloat2;\n    case Decl::ComponentType::float3:\n      return MTL::VertexFormatFloat3;\n    case Decl::ComponentType::float4:\n      return MTL::VertexFormatFloat4;\n\n    case Decl::ComponentType::int1:\n      return MTL::VertexFormatInt;\n    case Decl::ComponentType::int2:\n      return MTL::VertexFormatInt2;\n    case Decl::ComponentType::int3:\n      return MTL::VertexFormatInt3;\n    case Decl::ComponentType::int4:\n      return MTL::VertexFormatInt4;\n\n    case Decl::ComponentType::uint1:\n      return MTL::VertexFormatUInt;\n    case Decl::ComponentType::uint2:\n      return MTL::VertexFormatUInt2;\n    case Decl::ComponentType::uint3:\n      return MTL::VertexFormatUInt3;\n    case Decl::ComponentType::uint4:\n      return MTL::VertexFormatUInt4;\n    }\n  return MTL::VertexFormatInvalid;\n  }\n\ninline MTL::CompareFunction nativeFormat(RenderState::ZTestMode m) {\n  switch(m) {\n    case RenderState::ZTestMode::Always:\n      return MTL::CompareFunctionAlways;\n    case RenderState::ZTestMode::Never:\n      return MTL::CompareFunctionNever;\n    case RenderState::ZTestMode::Greater:\n      return MTL::CompareFunctionGreater;\n    case RenderState::ZTestMode::Less:\n      return MTL::CompareFunctionLess;\n    case RenderState::ZTestMode::GEqual:\n      return MTL::CompareFunctionGreaterEqual;\n    case RenderState::ZTestMode::LEqual:\n      return MTL::CompareFunctionLessEqual;\n    case RenderState::ZTestMode::NoEqual:\n      return MTL::CompareFunctionNotEqual;\n    case RenderState::ZTestMode::Equal:\n      return MTL::CompareFunctionEqual;\n    }\n  return MTL::CompareFunctionAlways;\n  }\n\ninline MTL::BlendFactor nativeFormat(RenderState::BlendMode m) {\n  switch(m) {\n    case RenderState::BlendMode::Zero:\n      return MTL::BlendFactorZero;\n    case RenderState::BlendMode::One:\n      return MTL::BlendFactorOne;\n    case RenderState::BlendMode::SrcColor:\n      return MTL::BlendFactorSourceColor;\n    case RenderState::BlendMode::OneMinusSrcColor:\n      return MTL::BlendFactorOneMinusSourceColor;\n    case RenderState::BlendMode::SrcAlpha:\n      return MTL::BlendFactorSourceAlpha;\n    case RenderState::BlendMode::SrcAlphaSaturate:\n      return MTL::BlendFactorSourceAlphaSaturated;\n    case RenderState::BlendMode::OneMinusSrcAlpha:\n      return MTL::BlendFactorOneMinusSourceAlpha;\n    case RenderState::BlendMode::DstColor:\n      return MTL::BlendFactorDestinationColor;\n    case RenderState::BlendMode::OneMinusDstColor:\n      return MTL::BlendFactorOneMinusDestinationColor;\n    case RenderState::BlendMode::DstAlpha:\n      return MTL::BlendFactorDestinationAlpha;\n    case RenderState::BlendMode::OneMinusDstAlpha:\n      return MTL::BlendFactorOneMinusDestinationAlpha;\n    }\n  return MTL::BlendFactorZero;\n  }\n\ninline MTL::BlendOperation nativeFormat(RenderState::BlendOp op) {\n  switch(op) {\n    case RenderState::BlendOp::Add:\n      return MTL::BlendOperationAdd;\n    case RenderState::BlendOp::Max:\n      return MTL::BlendOperationMax;\n    case RenderState::BlendOp::Min:\n      return MTL::BlendOperationMin;\n    case RenderState::BlendOp::ReverseSubtract:\n      return MTL::BlendOperationReverseSubtract;\n    case RenderState::BlendOp::Subtract:\n      return MTL::BlendOperationSubtract;\n    }\n  return MTL::BlendOperationAdd;\n  }\n\ninline MTL::CullMode nativeFormat(RenderState::CullMode m) {\n  switch(m) {\n    case RenderState::CullMode::NoCull:\n      return MTL::CullModeNone;\n    case RenderState::CullMode::Back:\n      return MTL::CullModeBack;\n    case RenderState::CullMode::Front:\n      return MTL::CullModeFront;\n    }\n  return MTL::CullModeNone;\n  }\n\ninline MTL::PrimitiveType nativeFormat(Topology t) {\n  switch(t) {\n    case Topology::Points:    return MTL::PrimitiveTypePoint;\n    case Topology::Lines:     return MTL::PrimitiveTypeLine;\n    case Topology::Triangles: return MTL::PrimitiveTypeTriangle;\n    }\n  return MTL::PrimitiveTypePoint;\n  }\n\ninline MTL::IndexType nativeFormat(IndexClass icls) {\n  switch(icls) {\n    case IndexClass::i16: return MTL::IndexTypeUInt16;\n    case IndexClass::i32: return MTL::IndexTypeUInt32;\n    }\n  return MTL::IndexTypeUInt16;\n  }\n\ninline MTL::AccelerationStructureInstanceOptions nativeFormat(RtInstanceFlags f) {\n  MTL::AccelerationStructureInstanceOptions ret = 0;\n  if((f & RtInstanceFlags::NonOpaque)==RtInstanceFlags::NonOpaque)\n    ret |= MTL::AccelerationStructureInstanceOptionNonOpaque; else\n    ret |= MTL::AccelerationStructureInstanceOptionOpaque;\n  if((f & RtInstanceFlags::CullDisable)==RtInstanceFlags::CullDisable)\n    ret |= MTL::AccelerationStructureInstanceOptionDisableTriangleCulling;\n  if((f & RtInstanceFlags::CullFlip)==RtInstanceFlags::CullFlip)\n    ret |= MTL::AccelerationStructureInstanceOptionTriangleFrontFacingWindingCounterClockwise;\n  return ret;\n  }\n\ninline MTL::RenderStages nativeFormat(ShaderReflection::Stage st) {\n  uint32_t stageFlags = 0;\n  if(st&ShaderReflection::Compute)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Vertex)\n    stageFlags |= MTL::RenderStageVertex;\n  if(st&ShaderReflection::Control)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Evaluate)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Geometry)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Fragment)\n    stageFlags |= MTL::RenderStageFragment;\n  if(st&ShaderReflection::Task)\n    stageFlags |=  MTL::RenderStageObject;\n  if(st&ShaderReflection::Mesh)\n    stageFlags |=  MTL::RenderStageMesh;\n  return MTL::RenderStages(stageFlags);\n  }\n\nclass MtDevice : public AbstractGraphicsApi::Device {\n  public:\n    MtDevice(std::string_view name, bool validation);\n    ~MtDevice();\n\n    void onSubmit();\n    void onFinish();\n    void waitIdle() override;\n\n    bool     useNativeImageAtomic() const;\n    uint32_t linearImageAlignment() const;\n\n    static void handleError(NS::Error* err);\n\n    NsPtr<MTL::Device>         impl;\n    NsPtr<MTL::CommandQueue>   queue;\n\n    std::condition_variable    devIdleCv;\n    std::mutex                 devIdleSync;\n    std::atomic_uint32_t       devCmdBuf{0};\n\n    AbstractGraphicsApi::Props prop;\n    MtSamplerCache             samplers;\n    bool                       validation = false;\n    MTL::LanguageVersion       mslVersion = MTL::LanguageVersion2_0;\n    uint32_t                   ui32align  = 0;\n\n    static void deductProps(AbstractGraphicsApi::Props& prop, MTL::Device& dev);\n  };\n\ninline void mtAssert(void* obj, NS::Error* err) {\n  if(T_LIKELY(obj!=nullptr))\n    return;\n  MtDevice::handleError(err);\n  }\n\n}\n}\n\n'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLResourceStateCommandEncoder.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n#include \"MTLDefines.hpp\"\n#include \"MTLHeaderBridge.hpp\"\n#include \"MTLPrivate.hpp\"\n\n#include <Foundation/Foundation.hpp>\n\n#include \"MTLCommandEncoder.hpp\"\n#include \"MTLTypes.hpp\"\n\nnamespace MTL\n{\n_MTL_ENUM(NS::UInteger, SparseTextureMappingMode) {\n    SparseTextureMappingModeMap = 0,\n    SparseTextureMappingModeUnmap = 1,\n};\n\nstruct MapIndirectArguments\n{\n    uint32_t regionOriginX;\n    uint32_t regionOriginY;\n    uint32_t regionOriginZ;\n    uint32_t regionSizeWidth;\n    uint32_t regionSizeHeight;\n    uint32_t regionSizeDepth;\n    uint32_t mipMapLevel;\n    uint32_t sliceId;\n} _MTL_PACKED;\n\nclass ResourceStateCommandEncoder : public NS::Referencing<ResourceStateCommandEncoder, CommandEncoder>\n{\npublic:\n    void updateTextureMappings(const class Texture* texture, const MTL::SparseTextureMappingMode mode, const MTL::Region* regions, const NS::UInteger* mipLevels, const NS::UInteger* slices, NS::UInteger numRegions);\n\n    void updateTextureMapping(const class Texture* texture, const MTL::SparseTextureMappingMode mode, const MTL::Region region, const NS::UInteger mipLevel, const NS::UInteger slice);\n\n    void updateTextureMapping(const class Texture* texture, const MTL::SparseTextureMappingMode mode, const class Buffer* indirectBuffer, NS::UInteger indirectBufferOffset);\n\n    void updateFence(const class Fence* fence);\n\n    void waitForFence(const class Fence* fence);\n\n    void moveTextureMappingsFromTexture(const class Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const class Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin);\n};\n\n}\n\n\n_MTL_INLINE void MTL::ResourceStateCommandEncoder::updateTextureMappings(const MTL::Texture* texture, const MTL::SparseTextureMappingMode mode, const MTL::Region* regions, const NS::UInteger* mipLevels, const NS::UInteger* slices, NS::UInteger numRegions)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateTextureMappings_mode_regions_mipLevels_slices_numRegions_), texture, mode, regions, mipLevels, slices, numRegions);\n}\n\n\n_MTL_INLINE void MTL::ResourceStateCommandEncoder::updateTextureMapping(const MTL::Texture* texture, const MTL::SparseTextureMappingMode mode, const MTL::Region region, const NS::UInteger mipLevel, const NS::UInteger slice)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateTextureMapping_mode_region_mipLevel_slice_), texture, mode, region, mipLevel, slice);\n}\n\n\n_MTL_INLINE void MTL::ResourceStateCommandEncoder::updateTextureMapping(const MTL::Texture* texture, const MTL::SparseTextureMappingMode mode, const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateTextureMapping_mode_indirectBuffer_indirectBufferOffset_), texture, mode, indirectBuffer, indirectBufferOffset);\n}\n\n\n_MTL_INLINE void MTL::ResourceStateCommandEncoder::updateFence(const MTL::Fence* fence)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateFence_), fence);\n}\n\n\n_MTL_INLINE void MTL::ResourceStateCommandEncoder::waitForFence(const MTL::Fence* fence)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitForFence_), fence);\n}\n\n\n_MTL_INLINE void MTL::ResourceStateCommandEncoder::moveTextureMappingsFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(moveTextureMappingsFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_), sourceTexture, sourceSlice, sourceLevel, sourceOrigin, sourceSize, destinationTexture, destinationSlice, destinationLevel, destinationOrigin);\n}\n\n'Tempest/Engine/gapi/metalapi.cpp'\n:#if defined(TEMPEST_BUILD_METAL)\n\n#include \"metalapi.h\"\n\n#if __has_feature(objc_arc)\n#error \"Objective C++ ARC is not supported\"\n#endif\n\n#include <Tempest/Log>\n#include <Tempest/Pixmap>\n\n#include \"gapi/metal/mtdevice.h\"\n#include \"gapi/metal/mtbuffer.h\"\n#include \"gapi/metal/mtshader.h\"\n#include \"gapi/metal/mtpipeline.h\"\n#include \"gapi/metal/mtcommandbuffer.h\"\n#include \"gapi/metal/mttexture.h\"\n#include \"gapi/metal/mtpipelinelay.h\"\n#include \"gapi/metal/mtdescriptorarray.h\"\n#include \"gapi/metal/mtsync.h\"\n#include \"gapi/metal/mtswapchain.h\"\n#include \"gapi/metal/mtaccelerationstructure.h\"\n\n#include <Metal/Metal.hpp>\n\nusing namespace Tempest;\nusing namespace Tempest::Detail;\n\nMetalApi::MetalApi(ApiFlags f) {\n  if((f & ApiFlags::Validation)==ApiFlags::Validation) {\n    setenv(\"METAL_DEVICE_WRAPPER_TYPE\",\"1\",1);\n    setenv(\"METAL_DEBUG_ERROR_MODE\",   \"5\",0);\n    setenv(\"METAL_ERROR_MODE\",         \"5\",0);\n    validation = true;\n    }\n  }\n\nMetalApi::~MetalApi() {\n  }\n\nstd::vector<AbstractGraphicsApi::Props> MetalApi::devices() const {\n#if defined(__OSX__)\n  auto dev = MTL::CopyAllDevices();\n  try {\n    std::vector<AbstractGraphicsApi::Props> p(dev->count());\n    for(size_t i=0; i<p.size(); ++i) {\n      MtDevice::deductProps(p[i],*reinterpret_cast<MTL::Device*>(dev->object(i)));\n      }\n    dev->release();\n    return p;\n    }\n  catch(...) {\n    dev->release();\n    throw;\n    }\n#else\n  std::vector<AbstractGraphicsApi::Props> p(1);\n  auto     dev    = NsPtr<MTL::Device>(MTL::CreateSystemDefaultDevice());\n  uint32_t mslVer = 0;\n  MtDevice::deductProps(p[0],*dev);\n  return p;\n#endif\n  }\n\nAbstractGraphicsApi::Device* MetalApi::createDevice(std::string_view gpuName) {\n  return new MtDevice(gpuName,validation);\n  }\n\nvoid MetalApi::destroy(AbstractGraphicsApi::Device *d) {\n  delete d;\n  }\n\nAbstractGraphicsApi::Swapchain *MetalApi::createSwapchain(SystemApi::Window *w,\n                                                          AbstractGraphicsApi::Device* d) {\n  auto& dev = *reinterpret_cast<MtDevice*>(d);\n  return new MtSwapchain(dev,w);\n  }\n\nAbstractGraphicsApi::PPipeline MetalApi::createPipeline(AbstractGraphicsApi::Device *d,\n                                                        const RenderState &st,\n                                                        Topology tp,\n                                                        const AbstractGraphicsApi::PipelineLay &ulayImpl,\n                                                        const AbstractGraphicsApi::Shader*const* sh,\n                                                        size_t cnt) {\n  auto& dx  = *reinterpret_cast<MtDevice*>(d);\n  auto& lay = reinterpret_cast<const MtPipelineLay&>(ulayImpl);\n  const Detail::MtShader* shader[5] = {};\n  for(size_t i=0; i<cnt; ++i)\n    shader[i] = reinterpret_cast<const Detail::MtShader*>(sh[i]);\n  return PPipeline(new MtPipeline(dx,tp,st,lay, shader,cnt));\n  }\n\nAbstractGraphicsApi::PCompPipeline MetalApi::createComputePipeline(AbstractGraphicsApi::Device *d,\n                                                                   const AbstractGraphicsApi::PipelineLay& ulayImpl,\n                                                                   AbstractGraphicsApi::Shader *cs) {\n  auto& dx = *reinterpret_cast<MtDevice*>(d);\n  auto& cx = *reinterpret_cast<const MtShader*>(cs);\n  auto& lay = reinterpret_cast<const MtPipelineLay&>(ulayImpl);\n  return PCompPipeline(new MtCompPipeline(dx,lay,cx));\n  }\n\nAbstractGraphicsApi::PShader MetalApi::createShader(AbstractGraphicsApi::Device *d, const void *source, size_t src_size) {\n  auto& dx = *reinterpret_cast<MtDevice*>(d);\n  return PShader(new MtShader(dx,source,src_size));\n  }\n\nAbstractGraphicsApi::Fence *MetalApi::createFence(AbstractGraphicsApi::Device*) {\n  return new MtSync();\n  }\n\nAbstractGraphicsApi::PBuffer MetalApi::createBuffer(AbstractGraphicsApi::Device *d, const void *mem, size_t size,\n                                                    MemUsage usage, BufferHeap flg) {\n  auto& dx = *reinterpret_cast<MtDevice*>(d);\n\n  MTL::ResourceOptions opt = 0;\n\n  switch(flg) {\n    case BufferHeap::Device:\n      opt |= MTL::ResourceStorageModePrivate;\n      break;\n    case BufferHeap::Upload:\n#ifndef __IOS__\n      if(size>PAGE_SIZE)\n        opt |= MTL::ResourceStorageModeManaged; else\n        opt |= MTL::ResourceStorageModeShared;\n#else\n      opt |= MTL::ResourceStorageModeShared;\n#endif\n      opt |= MTL::ResourceCPUCacheModeWriteCombined;\n      break;\n    case BufferHeap::Readback:\n      opt |= MTL::ResourceStorageModeManaged;\n      opt |= MTL::ResourceCPUCacheModeDefaultCache;\n      break;\n    }\n\n  return PBuffer(new MtBuffer(dx,mem,size,opt));\n  }\n\nAbstractGraphicsApi::PTexture MetalApi::createTexture(AbstractGraphicsApi::Device *d,\n                                                      const Pixmap &p, TextureFormat frm, uint32_t mips) {\n  auto& dev = *reinterpret_cast<MtDevice*>(d);\n  return PTexture(new MtTexture(dev,p,mips,frm));\n  }\n\nAbstractGraphicsApi::PTexture MetalApi::createTexture(AbstractGraphicsApi::Device *d,\n                                                      const uint32_t w, const uint32_t h, uint32_t mips, TextureFormat frm) {\n  auto& dev = *reinterpret_cast<MtDevice*>(d);\n  return PTexture(new MtTexture(dev,w,h,1,mips,frm,false));\n  }\n\nAbstractGraphicsApi::PTexture MetalApi::createStorage(AbstractGraphicsApi::Device *d,\n                                                      const uint32_t w, const uint32_t h, uint32_t mips, TextureFormat frm) {\n  auto& dev = *reinterpret_cast<MtDevice*>(d);\n  return PTexture(new MtTexture(dev,w,h,1,mips,frm,true));\n  }\n\nAbstractGraphicsApi::PTexture MetalApi::createStorage(Device* d,\n                                                      const uint32_t w, const uint32_t h, const uint32_t depth, uint32_t mips,\n                                                      TextureFormat frm) {\n  auto& dev = *reinterpret_cast<MtDevice*>(d);\n  return PTexture(new MtTexture(dev,w,h,depth,mips,frm,true));\n  }\n\nAbstractGraphicsApi::AccelerationStructure* MetalApi::createBottomAccelerationStruct(Device* d, const RtGeometry* geom, size_t size) {\n  auto& dev = *reinterpret_cast<MtDevice*>(d);\n\n\n  return new MtAccelerationStructure(dev, geom, size);\n  }\n\nAbstractGraphicsApi::AccelerationStructure* MetalApi::createTopAccelerationStruct(Device* d, const RtInstance* inst, AccelerationStructure*const* as, size_t size) {\n  auto& dev = *reinterpret_cast<MtDevice*>(d);\n  return new MtTopAccelerationStructure(dev,inst,as,size);\n  }\n\nvoid MetalApi::readPixels(AbstractGraphicsApi::Device*,\n                          Pixmap& out, const AbstractGraphicsApi::PTexture t,\n                          TextureFormat frm, const uint32_t w, const uint32_t h, uint32_t mip, bool storageImg) {\n  auto& tx = *reinterpret_cast<MtTexture*>(t.handler);\n  tx.readPixels(out,frm,w,h,mip);\n  }\n\nvoid MetalApi::readBytes(AbstractGraphicsApi::Device*, AbstractGraphicsApi::Buffer *buf,\n                         void *out, size_t size) {\n  buf->read(out,0,size);\n  }\n\nAbstractGraphicsApi::Desc *MetalApi::createDescriptors(AbstractGraphicsApi::Device* d,\n                                                       AbstractGraphicsApi::PipelineLay& layP) {\n  auto& dev = *reinterpret_cast<MtDevice*>(d);\n  auto& lay = reinterpret_cast<MtPipelineLay&>(layP);\n  return new MtDescriptorArray(dev,lay);\n  }\n\nAbstractGraphicsApi::PPipelineLay MetalApi::createPipelineLayout(AbstractGraphicsApi::Device*,\n                                                                 const AbstractGraphicsApi::Shader*const*sh,\n                                                                 size_t cnt) {\n  auto bufferSizeBuffer = ShaderReflection::None;\n  const std::vector<Detail::ShaderReflection::Binding>* lay[5] = {};\n\n  for(size_t i=0; i<cnt; ++i) {\n    if(sh[i]==nullptr)\n      continue;\n    auto* s = reinterpret_cast<const MtShader*>(sh[i]);\n    lay[i] = &s->lay;\n    if(s->bufferSizeBuffer) {\n      bufferSizeBuffer = ShaderReflection::Stage(bufferSizeBuffer | s->stage);\n      }\n    }\n\n  return PPipelineLay(new MtPipelineLay(lay,cnt,bufferSizeBuffer));\n  }\n\nAbstractGraphicsApi::CommandBuffer *MetalApi::createCommandBuffer(AbstractGraphicsApi::Device *d) {\n  auto& dx = *reinterpret_cast<MtDevice*>(d);\n  return new MtCommandBuffer(dx);\n  }\n\nvoid MetalApi::present(AbstractGraphicsApi::Device*, AbstractGraphicsApi::Swapchain *sw) {\n  auto& s   = *reinterpret_cast<MtSwapchain*>(sw);\n  s.present();\n  }\n\nvoid MetalApi::submit(AbstractGraphicsApi::Device *d,\n                      AbstractGraphicsApi::CommandBuffer* pcmd,\n                      AbstractGraphicsApi::Fence* doneCpu) {\n  auto& fence = *reinterpret_cast<MtSync*>(doneCpu);\n  fence.signal();\n\n  auto* dx = reinterpret_cast<MtDevice*>(d);\n  auto& cx = *reinterpret_cast<MtCommandBuffer*>(pcmd);\n\n  MTL::CommandBuffer& cmd = *cx.impl;\n  dx->onSubmit();\n  cmd.addCompletedHandler(^(MTL::CommandBuffer* c){\n    MTL::CommandBufferStatus s = c->status();\n    if(s==MTL::CommandBufferStatusNotEnqueued ||\n       s==MTL::CommandBufferStatusEnqueued ||\n       s==MTL::CommandBufferStatusCommitted ||\n       s==MTL::CommandBufferStatusScheduled)\n      return;\n\n    if(s==MTL::CommandBufferStatusCompleted)\n      fence.reset(); else\n      fence.reset(s, MTL::CommandBufferError(c->error()->code()), c->error());\n    dx->onFinish();\n    });\n  cmd.commit();\n  }\n\nvoid MetalApi::getCaps(AbstractGraphicsApi::Device *d, AbstractGraphicsApi::Props &caps) {\n  auto& dx = *reinterpret_cast<MtDevice*>(d);\n  caps = dx.prop;\n  }\n\n#endif\n\n",
        "gt": [
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLResourceStateCommandEncoder.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'",
            "'Tempest/Engine/gapi/metal/mtsamplercache.h'",
            "'Tempest/Engine/gapi/metal/mtdevice.h'",
            "'Tempest/Engine/gapi/metalapi.cpp'"
        ]
    },
    {
        "files": [
            "'beacon/third_party/hnsd/src/utils.h'",
            "'beacon/third_party/hnsquery/bio.h'",
            "'beacon/third_party/hnsd/uv/src/win/handle-inl.h'",
            "'beacon/third_party/hnsd/src/hsk.h'",
            "'beacon/third_party/hnsd/uv/src/win/stream-inl.h'"
        ],
        "content": "'beacon/third_party/hnsd/src/utils.h'\n:#ifndef _HSK_UTILS_H\n#define _HSK_UTILS_H\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"uv.h\"\n\nint64_t\nhsk_now(void);\n\nvoid\nhsk_date(\n  int64_t now,\n  uint32_t *year,\n  uint32_t *month,\n  uint32_t *day,\n  uint32_t *hour,\n  uint32_t *min,\n  uint32_t *sec\n);\n\nvoid\nhsk_ymdh(uint32_t *year, uint32_t *month, uint32_t *day, uint32_t *hour);\n\nvoid\nhsk_ymd(uint32_t *year, uint32_t *month, uint32_t *day);\n\nuint32_t\nhsk_random(void);\n\nuint64_t\nhsk_nonce(void);\n\nsize_t\nhsk_hex_encode_size(size_t data_len);\n\nchar *\nhsk_hex_encode(const uint8_t *data, size_t data_len, char *str);\n\nconst char *\nhsk_hex_encode32(const uint8_t *data);\n\nconst char *\nhsk_hex_encode20(const uint8_t *data);\n\nsize_t\nhsk_hex_decode_size(const char *str);\n\nbool\nhsk_hex_decode(const char *str, uint8_t *data);\n\nvoid\nhsk_to_lower(char *name);\n\n\n\n\nvoid\nhsk_uv_close_free(uv_handle_t *handle);\n\n#endif\n\n'beacon/third_party/hnsquery/bio.h'\n:\n\n#ifndef HNSQ_BIO_H\n#define HNSQ_BIO_H\n\n#include <assert.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"hsk.h\"\n\nstatic inline bool\nread_u8(uint8_t **data, size_t *len, uint8_t *out) {\n    if (*len < 1)\n        return false;\n    *out = (*data)[0];\n    *data += 1;\n    *len -= 1;\n    return true;\n}\n\nstatic inline bool\nread_u16(uint8_t **data, size_t *len, uint16_t *out) {\n    if (*len < 2)\n        return false;\n#ifndef HSK_BIG_ENDIAN\n    memcpy(out, *data, 2);\n#else\n    *out = 0;\n  *out |= ((uint16_t)(*data)[1]) << 8;\n  *out |= (uint16_t)(*data)[0];\n#endif\n    *data += 2;\n    *len -= 2;\n    return true;\n}\n\nstatic inline bool\nread_u32(uint8_t **data, size_t *len, uint32_t *out) {\n    if (*len < 4)\n        return false;\n#ifndef HSK_BIG_ENDIAN\n    memcpy(out, *data, 4);\n#else\n    *out = 0;\n  *out |= ((uint32_t)(*data)[3]) << 24;\n  *out |= ((uint32_t)(*data)[2]) << 16;\n  *out |= ((uint32_t)(*data)[1]) << 8;\n  *out |= (uint32_t)(*data)[0];\n#endif\n    *data += 4;\n    *len -= 4;\n    return true;\n}\n\nstatic inline bool\nread_u64(uint8_t **data, size_t *len, uint64_t *out) {\n    if (*len < 8)\n        return false;\n#ifndef HSK_BIG_ENDIAN\n    memcpy(out, *data, 8);\n#else\n    *out = 0;\n  *out |= ((uint64_t)(*data)[7]) << 56;\n  *out |= ((uint64_t)(*data)[6]) << 48;\n  *out |= ((uint64_t)(*data)[5]) << 40;\n  *out |= ((uint64_t)(*data)[4]) << 32;\n  *out |= ((uint64_t)(*data)[3]) << 24;\n  *out |= ((uint64_t)(*data)[2]) << 16;\n  *out |= ((uint64_t)(*data)[1]) << 8;\n  *out |= (uint64_t)(*data)[0];\n#endif\n    *data += 8;\n    *len -= 8;\n    return true;\n}\n\nstatic inline bool\nread_i8(uint8_t **data, size_t *len, int8_t *out) {\n    return read_u8(data, len, (uint8_t *)out);\n}\n\nstatic inline bool\nread_i16(uint8_t **data, size_t *len, int16_t *out) {\n    return read_u16(data, len, (uint16_t *)out);\n}\n\nstatic inline bool\nread_i32(uint8_t **data, size_t *len, int32_t *out) {\n    return read_u32(data, len, (uint32_t *)out);\n}\n\nstatic inline bool\nread_i64(uint8_t **data, size_t *len, int64_t *out) {\n    return read_u64(data, len, (uint64_t *)out);\n}\n\nstatic inline bool\nread_u16be(uint8_t **data, size_t *len, uint16_t *out) {\n    if (*len < 2)\n        return false;\n#ifdef HSK_BIG_ENDIAN\n    memcpy(out, *data, 2);\n#else\n    *out = 0;\n    *out |= ((uint16_t)(*data)[0]) << 8;\n    *out |= (uint16_t)(*data)[1];\n#endif\n    *data += 2;\n    *len -= 2;\n    return true;\n}\n\nstatic inline bool\nread_u32be(uint8_t **data, size_t *len, uint32_t *out) {\n    if (*len < 4)\n        return false;\n#ifdef HSK_BIG_ENDIAN\n    memcpy(out, *data, 4);\n#else\n    *out = 0;\n    *out |= ((uint32_t)(*data)[0]) << 24;\n    *out |= ((uint32_t)(*data)[1]) << 16;\n    *out |= ((uint32_t)(*data)[2]) << 8;\n    *out |= (uint32_t)(*data)[3];\n#endif\n    *data += 4;\n    *len -= 4;\n    return true;\n}\n\nstatic inline bool\nread_u64be(uint8_t **data, size_t *len, uint64_t *out) {\n    if (*len < 8)\n        return false;\n#ifdef HSK_BIG_ENDIAN\n    memcpy(out, *data, 8);\n#else\n    *out = 0;\n    *out |= ((uint64_t)(*data)[0]) << 56;\n    *out |= ((uint64_t)(*data)[1]) << 48;\n    *out |= ((uint64_t)(*data)[2]) << 40;\n    *out |= ((uint64_t)(*data)[3]) << 32;\n    *out |= ((uint64_t)(*data)[4]) << 24;\n    *out |= ((uint64_t)(*data)[5]) << 16;\n    *out |= ((uint64_t)(*data)[6]) << 8;\n    *out |= (uint64_t)(*data)[7];\n#endif\n    *data += 8;\n    *len -= 8;\n    return true;\n}\n\nstatic inline bool\nread_i16be(uint8_t **data, size_t *len, int16_t *out) {\n    return read_u16be(data, len, (uint16_t *)out);\n}\n\nstatic inline bool\nread_i32be(uint8_t **data, size_t *len, int32_t *out) {\n    return read_u32be(data, len, (uint32_t *)out);\n}\n\nstatic inline bool\nread_i64be(uint8_t **data, size_t *len, int64_t *out) {\n    return read_u64be(data, len, (uint64_t *)out);\n}\n\nstatic inline bool\nslice_bytes(uint8_t **data, size_t *len, uint8_t **out, size_t size) {\n    if (*len < size)\n        return false;\n    *out = *data;\n    *data += size;\n    *len -= size;\n    return true;\n}\n\nstatic inline bool\nread_bytes(uint8_t **data, size_t *len, uint8_t *out, size_t size) {\n    if (*len < size)\n        return false;\n    memcpy(out, *data, size);\n    *data += size;\n    *len -= size;\n    return true;\n}\n\nstatic inline bool\nalloc_bytes(uint8_t **data, size_t *len, uint8_t **out, size_t size) {\n    if (*len < size)\n        return false;\n\n    uint8_t *o = malloc(size);\n\n    if (o == NULL)\n        return false;\n\n    if (!read_bytes(data, len, o, size)) {\n        free(o);\n        return false;\n    }\n\n    *out = o;\n\n    return true;\n}\n\nstatic inline bool\nslice_ascii(uint8_t **data, size_t *len, char **out, size_t size) {\n    if (!slice_bytes(data, len, (uint8_t **)out, size))\n        return false;\n\n    uint8_t i;\n    for (i = 0; i < size; i++) {\n        uint8_t ch = (*out)[i];\n\n\n        if (ch & 0x80)\n            return false;\n\n\n        if (ch == 0x7f)\n            return false;\n\n\n\n        if (ch < 0x20\n            && ch != 0x09\n            && ch != 0x0a\n            && ch != 0x0d) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nstatic inline bool\nread_ascii(uint8_t **data, size_t *len, char *out, size_t size) {\n    char *chunk;\n\n    if (!slice_ascii(data, len, &chunk, size))\n        return false;\n\n    memcpy((void *)out, chunk, size);\n    out[size] = '\\0';\n\n    return true;\n}\n\nstatic inline bool\nalloc_ascii(uint8_t **data, size_t *len, char **out, size_t size) {\n    if (*len < size)\n        return false;\n\n    char *o = malloc(size + 1);\n\n    if (o == NULL)\n        return false;\n\n    if (!read_ascii(data, len, o, size)) {\n        free(o);\n        return false;\n    }\n\n    *out = o;\n\n    return true;\n}\n\nstatic inline size_t\nwrite_u8(uint8_t **data, uint8_t out) {\n    if (data == NULL || *data == NULL)\n        return 1;\n    (*data)[0] = out;\n    *data += 1;\n    return 1;\n}\n\nstatic inline size_t\nwrite_u16(uint8_t **data, uint16_t out) {\n    if (data == NULL || *data == NULL)\n        return 2;\n#ifndef HSK_BIG_ENDIAN\n    memcpy(*data, &out, 2);\n#else\n    (*data)[0] = (uint8_t)out;\n  (*data)[1] = (uint8_t)(out >> 8);\n#endif\n    *data += 2;\n    return 2;\n}\n\nstatic inline size_t\nwrite_u32(uint8_t **data, uint32_t out) {\n    if (data == NULL || *data == NULL)\n        return 4;\n#ifndef HSK_BIG_ENDIAN\n    memcpy(*data, &out, 4);\n#else\n    (*data)[0] = (uint8_t)out;\n  (*data)[1] = (uint8_t)(out >> 8);\n  (*data)[2] = (uint8_t)(out >> 16);\n  (*data)[3] = (uint8_t)(out >> 24);\n#endif\n    *data += 4;\n    return 4;\n}\n\nstatic inline size_t\nwrite_u64(uint8_t **data, uint64_t out) {\n    if (data == NULL || *data == NULL)\n        return 8;\n#ifndef HSK_BIG_ENDIAN\n    memcpy(*data, &out, 8);\n#else\n    (*data)[0] = (uint8_t)out;\n  (*data)[1] = (uint8_t)(out >> 8);\n  (*data)[2] = (uint8_t)(out >> 16);\n  (*data)[3] = (uint8_t)(out >> 24);\n  (*data)[4] = (uint8_t)(out >> 32);\n  (*data)[5] = (uint8_t)(out >> 40);\n  (*data)[6] = (uint8_t)(out >> 48);\n  (*data)[7] = (uint8_t)(out >> 56);\n#endif\n    *data += 8;\n    return 8;\n}\n\nstatic inline size_t\nwrite_i8(uint8_t **data, int8_t out) {\n    return write_u8(data, (uint8_t)out);\n}\n\nstatic inline size_t\nwrite_i16(uint8_t **data, int16_t out) {\n    return write_u16(data, (uint16_t)out);\n}\n\nstatic inline size_t\nwrite_i32(uint8_t **data, int32_t out) {\n    return write_u32(data, (uint32_t)out);\n}\n\nstatic inline size_t\nwrite_i64(uint8_t **data, int64_t out) {\n    return write_u64(data, (uint64_t)out);\n}\n\nstatic inline size_t\nwrite_u16be(uint8_t **data, uint16_t out) {\n    if (data == NULL || *data == NULL)\n        return 2;\n#ifdef HSK_BIG_ENDIAN\n    memcpy(*data, &out, 2);\n#else\n    (*data)[1] = (uint8_t)out;\n    (*data)[0] = (uint8_t)(out >> 8);\n#endif\n    *data += 2;\n    return 2;\n}\n\nstatic inline size_t\nwrite_u32be(uint8_t **data, uint32_t out) {\n    if (data == NULL || *data == NULL)\n        return 4;\n#ifdef HSK_BIG_ENDIAN\n    memcpy(*data, &out, 4);\n#else\n    (*data)[3] = (uint8_t)out;\n    (*data)[2] = (uint8_t)(out >> 8);\n    (*data)[1] = (uint8_t)(out >> 16);\n    (*data)[0] = (uint8_t)(out >> 24);\n#endif\n    *data += 4;\n    return 4;\n}\n\nstatic inline size_t\nwrite_u64be(uint8_t **data, uint64_t out) {\n    if (data == NULL || *data == NULL)\n        return 8;\n#ifdef HSK_BIG_ENDIAN\n    memcpy(*data, &out, 8);\n#else\n    (*data)[7] = (uint8_t)out;\n    (*data)[6] = (uint8_t)(out >> 8);\n    (*data)[5] = (uint8_t)(out >> 16);\n    (*data)[4] = (uint8_t)(out >> 24);\n    (*data)[3] = (uint8_t)(out >> 32);\n    (*data)[2] = (uint8_t)(out >> 40);\n    (*data)[1] = (uint8_t)(out >> 48);\n    (*data)[0] = (uint8_t)(out >> 56);\n#endif\n    *data += 8;\n    return 8;\n}\n\nstatic inline size_t\nwrite_i16be(uint8_t **data, int16_t out) {\n    return write_u16be(data, (uint16_t)out);\n}\n\nstatic inline size_t\nwrite_i32be(uint8_t **data, int32_t out) {\n    return write_u32be(data, (uint32_t)out);\n}\n\nstatic inline size_t\nwrite_i64be(uint8_t **data, int64_t out) {\n    return write_u64be(data, (uint64_t)out);\n}\n\nstatic inline size_t\nwrite_bytes(uint8_t **data, const uint8_t *bytes, size_t size) {\n    if (data == NULL || *data == NULL)\n        return size;\n    memcpy(*data, bytes, size);\n    *data += size;\n    return size;\n}\n\nstatic inline bool\nread_varint(uint8_t **data, size_t *data_len, uint64_t *value) {\n    if (data_len == 0)\n        return false;\n\n    uint8_t prefix = (*data)[0];\n\n    *data += 1;\n    *data_len -= 1;\n\n    switch (prefix) {\n        case 0xff: {\n            uint64_t v;\n\n            if (!read_u64(data, data_len, &v))\n                return false;\n\n            if (v <= 0xffffffff)\n                return false;\n\n            *value = v;\n            return true;\n        }\n        case 0xfe: {\n            uint32_t v;\n\n            if (!read_u32(data, data_len, &v))\n                return false;\n\n            if (v <= 0xffff)\n                return false;\n\n            *value = (uint64_t)v;\n            break;\n        }\n        case 0xfd: {\n            uint16_t v;\n\n            if (!read_u16(data, data_len, &v))\n                return false;\n\n            if (v < 0xfd)\n                return false;\n\n            *value = (uint64_t)v;\n            break;\n        }\n        default: {\n            *value = (uint64_t)prefix;\n            break;\n        }\n    }\n\n    return true;\n}\n\nstatic inline bool\nread_varsize(uint8_t **data, size_t *data_len, size_t *value) {\n    size_t v;\n\n    if (!read_varint(data, data_len, (uint64_t *)&v))\n        return false;\n\n    if ((int32_t)v < 0)\n        return false;\n\n    *value = v;\n\n    return true;\n}\n\nstatic inline bool\nsize_varint(uint64_t value) {\n    if (value < 0xfd)\n        return 1;\n\n    if (value <= 0xffff)\n        return 3;\n\n    if (value <= 0xffffffff)\n        return 5;\n\n    return 9;\n}\n\nstatic inline size_t\nsize_varsize(size_t value) {\n    return size_varint((uint64_t)value);\n}\n\nstatic inline size_t\nwrite_varint(uint8_t **data, uint64_t size) {\n    if (data == NULL || *data == NULL)\n        return size_varsize(size);\n\n    if (size < 0xfd) {\n        write_u8(data, (uint8_t)size);\n        return 1;\n    }\n\n    if (size <= 0xffff) {\n        write_u8(data, 0xfd);\n        write_u16(data, (uint16_t)size);\n        return 3;\n    }\n\n    if (size <= 0xffffffff) {\n        write_u8(data, 0xfe);\n        write_u32(data, (uint32_t)size);\n        return 5;\n    }\n\n    write_u8(data, 0xff);\n    write_u64(data, (uint64_t)size);\n    return 9;\n}\n\nstatic inline size_t\nwrite_varsize(uint8_t **data, size_t size) {\n    return write_varint(data, (uint64_t)size);\n}\n\nstatic inline bool\nslice_varbytes(\n        uint8_t **data,\n        size_t *data_len,\n        uint8_t **out,\n        size_t *out_len\n) {\n    size_t size;\n\n    if (!read_varsize(data, data_len, &size))\n        return false;\n\n    if (!slice_bytes(data, data_len, out, size))\n        return false;\n\n    *out_len = size;\n\n    return true;\n}\n\nstatic inline bool\nread_varbytes(\n        uint8_t **data,\n        size_t *data_len,\n        uint8_t *out,\n        size_t out_size,\n        size_t *out_len\n) {\n    size_t size;\n\n    if (!read_varsize(data, data_len, &size))\n        return false;\n\n    if (out_size < size)\n        return false;\n\n    if (!read_bytes(data, data_len, out, size))\n        return false;\n\n    *out_len = size;\n\n    return true;\n}\n\nstatic inline bool\nalloc_varbytes(\n        uint8_t **data,\n        size_t *data_len,\n        uint8_t **out,\n        size_t *out_len\n) {\n    size_t size;\n\n    if (!read_varsize(data, data_len, &size))\n        return false;\n\n    if (!alloc_bytes(data, data_len, out, size))\n        return false;\n\n    *out_len = size;\n\n    return true;\n}\n\nstatic inline size_t\nsize_varbytes(size_t size) {\n    return size_varsize(size) + size;\n}\n\nstatic inline size_t\nwrite_varbytes(uint8_t **data, const uint8_t *bytes, size_t size) {\n    if (data == NULL || *data == NULL)\n        return size_varbytes(size);\n    size_t s = 0;\n    s += write_varsize(data, size);\n    s += write_bytes(data, bytes, size);\n    return s;\n}\n\nstatic inline uint8_t\nget_u8(const uint8_t *data) {\n    return data[0];\n}\n\nstatic inline uint16_t\nget_u16(const uint8_t *data) {\n    uint16_t out;\n#ifndef HSK_BIG_ENDIAN\n    memcpy(&out, data, 2);\n#else\n    out = 0;\n  out |= ((uint16_t)data[1]) << 8;\n  out |= (uint16_t)data[0];\n#endif\n    return out;\n}\n\nstatic inline uint32_t\nget_u32(const uint8_t *data) {\n    uint32_t out;\n#ifndef HSK_BIG_ENDIAN\n    memcpy(&out, data, 4);\n#else\n    out = 0;\n  out |= ((uint32_t)data[3]) << 24;\n  out |= ((uint32_t)data[2]) << 16;\n  out |= ((uint32_t)data[1]) << 8;\n  out |= (uint32_t)data[0];\n#endif\n    return out;\n}\n\nstatic inline uint64_t\nget_u64(const uint8_t *data) {\n    uint64_t out;\n#ifndef HSK_BIG_ENDIAN\n    memcpy(&out, data, 8);\n#else\n    out = 0;\n  out |= ((uint64_t)data[7]) << 56;\n  out |= ((uint64_t)data[6]) << 48;\n  out |= ((uint64_t)data[5]) << 40;\n  out |= ((uint64_t)data[4]) << 32;\n  out |= ((uint64_t)data[3]) << 24;\n  out |= ((uint64_t)data[2]) << 16;\n  out |= ((uint64_t)data[1]) << 8;\n  out |= (uint64_t)data[0];\n#endif\n    return out;\n}\n\nstatic inline int8_t\nget_i8(const uint8_t *data) {\n    return get_u8(data);\n}\n\nstatic inline int16_t\nget_i16(const uint8_t *data) {\n    return get_u16(data);\n}\n\nstatic inline int32_t\nget_i32(const uint8_t *data) {\n    return get_u32(data);\n}\n\nstatic inline int64_t\nget_i64(const uint8_t *data) {\n    return get_u64(data);\n}\n\nstatic inline uint16_t\nget_u16be(const uint8_t *data) {\n    uint16_t out;\n#ifdef HSK_BIG_ENDIAN\n    memcpy(&out, data, 2);\n#else\n    out = 0;\n    out |= ((uint16_t)data[0]) << 8;\n    out |= (uint16_t)data[1];\n#endif\n    return out;\n}\n\nstatic inline uint32_t\nget_u32be(const uint8_t *data) {\n    uint32_t out;\n#ifdef HSK_BIG_ENDIAN\n    memcpy(&out, data, 4);\n#else\n    out = 0;\n    out |= ((uint32_t)data[0]) << 24;\n    out |= ((uint32_t)data[1]) << 16;\n    out |= ((uint32_t)data[2]) << 8;\n    out |= (uint32_t)data[3];\n#endif\n    return out;\n}\n\nstatic inline uint64_t\nget_u64be(const uint8_t *data) {\n    uint64_t out;\n#ifdef HSK_BIG_ENDIAN\n    memcpy(&out, data, 8);\n#else\n    out = 0;\n    out |= ((uint64_t)data[0]) << 56;\n    out |= ((uint64_t)data[1]) << 48;\n    out |= ((uint64_t)data[2]) << 40;\n    out |= ((uint64_t)data[3]) << 32;\n    out |= ((uint64_t)data[4]) << 24;\n    out |= ((uint64_t)data[5]) << 16;\n    out |= ((uint64_t)data[6]) << 8;\n    out |= (uint64_t)data[7];\n#endif\n    return out;\n}\n\nstatic inline int16_t\nget_i16be(const uint8_t *data) {\n    return get_u16be(data);\n}\n\nstatic inline int32_t\nget_i32be(const uint8_t *data) {\n    return get_u32be(data);\n}\n\nstatic inline int64_t\nget_i64be(const uint8_t *data) {\n    return get_u64be(data);\n}\n\nstatic inline void\nset_u8(uint8_t *data, uint8_t out) {\n    data[0] = out;\n}\n\nstatic inline void\nset_u16(uint8_t *data, uint16_t out) {\n#ifndef HSK_BIG_ENDIAN\n    memcpy(data, &out, 2);\n#else\n    data[0] = (uint8_t)out;\n  data[1] = (uint8_t)(out >> 8);\n#endif\n}\n\nstatic inline void\nset_u32(uint8_t *data, uint32_t out) {\n#ifndef HSK_BIG_ENDIAN\n    memcpy(data, &out, 4);\n#else\n    data[0] = (uint8_t)out;\n  data[1] = (uint8_t)(out >> 8);\n  data[2] = (uint8_t)(out >> 16);\n  data[3] = (uint8_t)(out >> 24);\n#endif\n}\n\nstatic inline void\nset_u64(uint8_t *data, uint64_t out) {\n#ifndef HSK_BIG_ENDIAN\n    memcpy(data, &out, 8);\n#else\n    data[0] = (uint8_t)out;\n  data[1] = (uint8_t)(out >> 8);\n  data[2] = (uint8_t)(out >> 16);\n  data[3] = (uint8_t)(out >> 24);\n  data[4] = (uint8_t)(out >> 32);\n  data[5] = (uint8_t)(out >> 40);\n  data[6] = (uint8_t)(out >> 48);\n  data[7] = (uint8_t)(out >> 56);\n#endif\n}\n\nstatic inline void\nset_i8(uint8_t *data, int8_t out) {\n    set_u8(data, (uint8_t)out);\n}\n\nstatic inline void\nset_i16(uint8_t *data, int16_t out) {\n    set_u16(data, (uint16_t)out);\n}\n\nstatic inline void\nset_i32(uint8_t *data, int32_t out) {\n    set_u32(data, (uint32_t)out);\n}\n\nstatic inline void\nset_i64(uint8_t *data, int64_t out) {\n    set_u64(data, (uint64_t)out);\n}\n\nstatic inline void\nset_u16be(uint8_t *data, uint16_t out) {\n#ifdef HSK_BIG_ENDIAN\n    memcpy(data, &out, 2);\n#else\n    data[1] = (uint8_t)out;\n    data[0] = (uint8_t)(out >> 8);\n#endif\n}\n\nstatic inline void\nset_u32be(uint8_t *data, uint32_t out) {\n#ifdef HSK_BIG_ENDIAN\n    memcpy(data, &out, 4);\n#else\n    data[3] = (uint8_t)out;\n    data[2] = (uint8_t)(out >> 8);\n    data[1] = (uint8_t)(out >> 16);\n    data[0] = (uint8_t)(out >> 24);\n#endif\n}\n\nstatic inline void\nset_u64be(uint8_t *data, uint64_t out) {\n#ifdef HSK_BIG_ENDIAN\n    memcpy(data, &out, 8);\n#else\n    data[7] = (uint8_t)out;\n    data[6] = (uint8_t)(out >> 8);\n    data[5] = (uint8_t)(out >> 16);\n    data[4] = (uint8_t)(out >> 24);\n    data[3] = (uint8_t)(out >> 32);\n    data[2] = (uint8_t)(out >> 40);\n    data[1] = (uint8_t)(out >> 48);\n    data[0] = (uint8_t)(out >> 56);\n#endif\n}\n\nstatic inline void\nset_i16be(uint8_t *data, int16_t out) {\n    set_u16be(data, (uint16_t)out);\n}\n\nstatic inline void\nset_i32be(uint8_t *data, int32_t out) {\n    set_u32be(data, (uint32_t)out);\n}\n\nstatic inline void\nset_i64be(uint8_t *data, int64_t out) {\n    set_u64be(data, (uint64_t)out);\n}\n\n\n#endif\n\n'beacon/third_party/hnsd/uv/src/win/handle-inl.h'\n:\n\n#ifndef UV_WIN_HANDLE_INL_H_\n#define UV_WIN_HANDLE_INL_H_\n\n#include <assert.h>\n#include <io.h>\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n\n#define DECREASE_ACTIVE_COUNT(loop, handle)                             \\\n  do {                                                                  \\\n    if (--(handle)->activecnt == 0 &&                                   \\\n        !((handle)->flags & UV__HANDLE_CLOSING)) {                      \\\n      uv__handle_stop((handle));                                        \\\n    }                                                                   \\\n    assert((handle)->activecnt >= 0);                                   \\\n  } while (0)\n\n\n#define INCREASE_ACTIVE_COUNT(loop, handle)                             \\\n  do {                                                                  \\\n    if ((handle)->activecnt++ == 0) {                                   \\\n      uv__handle_start((handle));                                       \\\n    }                                                                   \\\n    assert((handle)->activecnt > 0);                                    \\\n  } while (0)\n\n\n#define DECREASE_PENDING_REQ_COUNT(handle)                              \\\n  do {                                                                  \\\n    assert(handle->reqs_pending > 0);                                   \\\n    handle->reqs_pending--;                                             \\\n                                                                        \\\n    if (handle->flags & UV__HANDLE_CLOSING &&                           \\\n        handle->reqs_pending == 0) {                                    \\\n      uv_want_endgame(loop, (uv_handle_t*)handle);                      \\\n    }                                                                   \\\n  } while (0)\n\n\n#define uv__handle_closing(handle)                                      \\\n  do {                                                                  \\\n    assert(!((handle)->flags & UV__HANDLE_CLOSING));                    \\\n                                                                        \\\n    if (!(((handle)->flags & UV__HANDLE_ACTIVE) &&                      \\\n          ((handle)->flags & UV__HANDLE_REF)))                          \\\n      uv__active_handle_add((uv_handle_t*) (handle));                   \\\n                                                                        \\\n    (handle)->flags |= UV__HANDLE_CLOSING;                              \\\n    (handle)->flags &= ~UV__HANDLE_ACTIVE;                              \\\n  } while (0)\n\n\n#define uv__handle_close(handle)                                        \\\n  do {                                                                  \\\n    QUEUE_REMOVE(&(handle)->handle_queue);                              \\\n    uv__active_handle_rm((uv_handle_t*) (handle));                      \\\n                                                                        \\\n    (handle)->flags |= UV_HANDLE_CLOSED;                                \\\n                                                                        \\\n    if ((handle)->close_cb)                                             \\\n      (handle)->close_cb((uv_handle_t*) (handle));                      \\\n  } while (0)\n\n\nINLINE static void uv_want_endgame(uv_loop_t* loop, uv_handle_t* handle) {\n  if (!(handle->flags & UV_HANDLE_ENDGAME_QUEUED)) {\n    handle->flags |= UV_HANDLE_ENDGAME_QUEUED;\n\n    handle->endgame_next = loop->endgame_handles;\n    loop->endgame_handles = handle;\n  }\n}\n\n\nINLINE static void uv_process_endgames(uv_loop_t* loop) {\n  uv_handle_t* handle;\n\n  while (loop->endgame_handles) {\n    handle = loop->endgame_handles;\n    loop->endgame_handles = handle->endgame_next;\n\n    handle->flags &= ~UV_HANDLE_ENDGAME_QUEUED;\n\n    switch (handle->type) {\n      case UV_TCP:\n        uv_tcp_endgame(loop, (uv_tcp_t*) handle);\n        break;\n\n      case UV_NAMED_PIPE:\n        uv_pipe_endgame(loop, (uv_pipe_t*) handle);\n        break;\n\n      case UV_TTY:\n        uv_tty_endgame(loop, (uv_tty_t*) handle);\n        break;\n\n      case UV_UDP:\n        uv_udp_endgame(loop, (uv_udp_t*) handle);\n        break;\n\n      case UV_POLL:\n        uv_poll_endgame(loop, (uv_poll_t*) handle);\n        break;\n\n      case UV_TIMER:\n        uv_timer_endgame(loop, (uv_timer_t*) handle);\n        break;\n\n      case UV_PREPARE:\n      case UV_CHECK:\n      case UV_IDLE:\n        uv_loop_watcher_endgame(loop, handle);\n        break;\n\n      case UV_ASYNC:\n        uv_async_endgame(loop, (uv_async_t*) handle);\n        break;\n\n      case UV_SIGNAL:\n        uv_signal_endgame(loop, (uv_signal_t*) handle);\n        break;\n\n      case UV_PROCESS:\n        uv_process_endgame(loop, (uv_process_t*) handle);\n        break;\n\n      case UV_FS_EVENT:\n        uv_fs_event_endgame(loop, (uv_fs_event_t*) handle);\n        break;\n\n      case UV_FS_POLL:\n        uv__fs_poll_endgame(loop, (uv_fs_poll_t*) handle);\n        break;\n\n      default:\n        assert(0);\n        break;\n    }\n  }\n}\n\nINLINE static HANDLE uv__get_osfhandle(int fd)\n{\n\n\n\n\n\n  HANDLE handle;\n  UV_BEGIN_DISABLE_CRT_ASSERT();\n  handle = (HANDLE) _get_osfhandle(fd);\n  UV_END_DISABLE_CRT_ASSERT();\n  return handle;\n}\n\n#endif\n\n'beacon/third_party/hnsd/src/hsk.h'\n:#ifndef _HSK_HSK_H\n#define _HSK_HSK_H\n\n#include \"addr.h\"\n#include \"addrmgr.h\"\n#include \"aead.h\"\n#include \"base32.h\"\n#include \"blake2b.h\"\n#include \"bn.h\"\n#include \"brontide.h\"\n#include \"chain.h\"\n#include \"constants.h\"\n#include \"dns.h\"\n#include \"dnssec.h\"\n#include \"ec.h\"\n#include \"ecc.h\"\n#include \"error.h\"\n\n#include \"hash.h\"\n#include \"header.h\"\n#include \"map.h\"\n#include \"msg.h\"\n#include \"proof.h\"\n#include \"random.h\"\n#include \"req.h\"\n#include \"resource.h\"\n\n#include \"sha256.h\"\n#include \"sig0.h\"\n#include \"siphash.h\"\n#include \"timedata.h\"\n#include \"utils.h\"\n\n#endif\n\n'beacon/third_party/hnsd/uv/src/win/stream-inl.h'\n:\n\n#ifndef UV_WIN_STREAM_INL_H_\n#define UV_WIN_STREAM_INL_H_\n\n#include <assert.h>\n\n#include \"uv.h\"\n#include \"internal.h\"\n#include \"handle-inl.h\"\n#include \"req-inl.h\"\n\n\nINLINE static void uv_stream_init(uv_loop_t* loop,\n                                  uv_stream_t* handle,\n                                  uv_handle_type type) {\n  uv__handle_init(loop, (uv_handle_t*) handle, type);\n  handle->write_queue_size = 0;\n  handle->activecnt = 0;\n  handle->stream.conn.shutdown_req = NULL;\n}\n\n\nINLINE static void uv_connection_init(uv_stream_t* handle) {\n  handle->flags |= UV_HANDLE_CONNECTION;\n  handle->stream.conn.write_reqs_pending = 0;\n\n  UV_REQ_INIT(&handle->read_req, UV_READ);\n  handle->read_req.event_handle = NULL;\n  handle->read_req.wait_handle = INVALID_HANDLE_VALUE;\n  handle->read_req.data = handle;\n}\n\n\n#endif\n",
        "gt": [
            "'beacon/third_party/hnsd/src/utils.h'",
            "'beacon/third_party/hnsd/src/hsk.h'",
            "'beacon/third_party/hnsquery/bio.h'",
            "'beacon/third_party/hnsd/uv/src/win/handle-inl.h'",
            "'beacon/third_party/hnsd/uv/src/win/stream-inl.h'"
        ]
    },
    {
        "files": [
            "'operon/include/operon/interpreter/functions.hpp'",
            "'operon/include/operon/interpreter/backend/eve/derivatives.hpp'",
            "'operon/include/operon/interpreter/backend/plain.hpp'",
            "'operon/include/operon/interpreter/backend/eve.hpp'"
        ],
        "content": "'operon/include/operon/interpreter/functions.hpp'\n:\n\n\n#ifndef OPERON_INTERPRETER_FUNCTIONS_HPP\n#define OPERON_INTERPRETER_FUNCTIONS_HPP\n\n#include \"operon/core/node.hpp\"\n#if defined(OPERON_MATH_EIGEN)\n#include \"operon/interpreter/backend/eigen.hpp\"\n#elif defined(OPERON_MATH_EVE)\n#include \"operon/interpreter/backend/eve.hpp\"\n#elif defined(OPERON_MATH_ARMA)\n#include \"operon/interpreter/backend/arma.hpp\"\n#elif defined(OPERON_MATH_BLAZE)\n#include \"operon/interpreter/backend/blaze.hpp\"\n#elif defined(OPERON_MATH_FASTOR)\n#include \"operon/interpreter/backend/fastor.hpp\"\n#elif defined(OPERON_MATH_STL)\n#include \"operon/interpreter/backend/plain.hpp\"\n#elif defined(OPERON_MATH_VDT)\n#include \"operon/interpreter/backend/vdt.hpp\"\n#elif defined(OPERON_MATH_XTENSOR)\n#include \"operon/interpreter/backend/xtensor.hpp\"\n#elif defined(OPERON_MATH_FAST_V1)\n#include \"operon/interpreter/backend/fast_v1.hpp\"\n#elif defined(OPERON_MATH_FAST_V2)\n#include \"operon/interpreter/backend/fast_v2.hpp\"\n#elif defined(OPERON_MATH_FAST_V3)\n#include \"operon/interpreter/backend/fast_v3.hpp\"\n#endif\n\nnamespace Operon {\n\n    template<typename T, std::size_t S>\n    auto Fill(Backend::View<T, S> view, int idx, T value) {\n        auto* p = view.data_handle() + idx * S;\n        std::fill_n(p, S, value);\n    };\n\n\n    template<typename T, Operon::NodeType N = Operon::NodeTypes::NoType, bool C = false, std::size_t S = Backend::BatchSize<T>>\n    struct Func {\n        auto operator()(Backend::View<T, S> , std::integral auto , std::integral auto... ) {\n            throw std::runtime_error(fmt::format(\"backend error: missing specialization for function: {}\\n\", Operon::Node{N}.Name()));\n        }\n    };\n\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Add, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto... args) {\n            auto* h = view.data_handle();\n            if constexpr (C) {\n                Backend::Add<T, S>(h + result * S, h + result * S, (h + args * S)...);\n            } else {\n                Backend::Add<T, S>(h + result * S, (h + args * S)...);\n            }\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Mul, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto... args) {\n            auto* h = view.data_handle();\n            if constexpr (C) {\n                Backend::Mul<T, S>(h + result * S, h + result * S, (h + args * S)...);\n            } else {\n                Backend::Mul<T, S>(h + result * S, (h + args * S)...);\n            }\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Sub, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto first, std::integral auto... args) {\n            auto* h = view.data_handle();\n\n            if constexpr (C) {\n                if constexpr (sizeof...(args) == 0) {\n                    Backend::Sub<T, S>(h + result * S, h + result * S, h + first * S);\n                } else {\n                    Backend::Sub<T, S>(h + result * S, h + result * S, h + first * S, (h + args * S)...);\n                }\n            } else {\n                if constexpr (sizeof...(args) == 0) {\n                    Backend::Neg<T, S>(h + result * S, h + first * S);\n                } else {\n                    Backend::Sub<T, S>(h + result * S, h + first * S, (h + args * S)...);\n                }\n            }\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Div, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto first, std::integral auto... args) {\n            auto* h = view.data_handle();\n\n            if constexpr (C) {\n                if constexpr (sizeof...(args) == 0) {\n                    Backend::Div<T, S>(h + result * S, h + result * S, h + first * S);\n                } else {\n                    Backend::Div<T, S>(h + result * S, h + result * S, h + first * S, (h + args * S)...);\n                }\n            } else {\n                if constexpr (sizeof...(args) == 0) {\n                    Backend::Inv<T, S>(h + result * S, h + first * S);\n                } else {\n                    Backend::Div<T, S>(h + result * S, h + first * S, (h + args * S)...);\n                }\n            }\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Fmin, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto first, std::integral auto... args) {\n            auto* h = view.data_handle();\n\n            if constexpr (C) {\n                if constexpr (sizeof...(args) == 0) {\n                    Backend::Min<T, S>(h + result * S, h + result * S, h + first * S);\n                } else {\n                    Backend::Min<T, S>(h + result * S, h + result * S, h + first * S, (h + args * S)...);\n                }\n            } else {\n                if constexpr (sizeof...(args) == 0) {\n                    Backend::Cpy<T, S>(h + result * S, h + first * S);\n                } else {\n                    Backend::Min<T, S>(h + result * S, h + first * S, (h + args * S)...);\n                }\n            }\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Fmax, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto first, std::integral auto... args) {\n            auto* h = view.data_handle();\n\n            if constexpr (C) {\n                if constexpr (sizeof...(args) == 0) {\n                    Backend::Max<T, S>(h + result * S, h + result * S, h + first * S);\n                } else {\n                    Backend::Max<T, S>(h + result * S, h + result * S, h + first * S, (h + args * S)...);\n                }\n            } else {\n                if constexpr (sizeof...(args) == 0) {\n                    Backend::Cpy<T, S>(h + result * S, h + first * S);\n                } else {\n                    Backend::Max<T, S>(h + result * S, h + first * S, (h + args * S)...);\n                }\n            }\n        }\n    };\n\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Aq, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i, std::integral auto j) {\n            auto* h = view.data_handle();\n            Backend::Aq<T, S>(h + result * S, h + i * S, h + j * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Pow, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i, std::integral auto j) {\n            auto* h = view.data_handle();\n            Backend::Pow<T, S>(h + result * S, h + i * S, h + j * S);\n        }\n    };\n\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Abs, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Abs<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Square, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Square<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Exp, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Exp<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Log, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Log<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Logabs, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Logabs<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Log1p, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Log1p<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Sqrt, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Sqrt<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Sqrtabs, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Sqrtabs<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Cbrt, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Cbrt<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Ceil, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Ceil<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Floor, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Floor<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Sin, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Sin<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Cos, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Cos<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Tan, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Tan<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Asin, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Asin<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Acos, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Acos<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Atan, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Atan<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Sinh, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Sinh<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Cosh, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Cosh<T, S>(h + result * S, h + i * S);\n        }\n    };\n\n    template<typename T, bool C, std::size_t S>\n    struct Func<T, Operon::NodeType::Tanh, C, S> {\n        auto operator()(Backend::View<T, S> view, std::integral auto result, std::integral auto i) {\n            auto* h = view.data_handle();\n            Backend::Tanh<T, S>(h + result * S, h + i * S);\n        }\n    };\n}\n\n#endif\n\n'operon/include/operon/interpreter/backend/eve/derivatives.hpp'\n:\n\n\n#ifndef OPERON_BACKEND_EVE_DERIVATIVES_HPP\n#define OPERON_BACKEND_EVE_DERIVATIVES_HPP\n\n#include \"functions.hpp\"\n\nnamespace Operon::Backend {\nnamespace detail {\n    template<typename T>\n    inline auto IsNaN(T value) { return eve::all(eve::is_nan(value)); }\n\n    template<typename Compare>\n    struct FComp {\n        auto operator()(auto x, auto y) const {\n            using T = std::common_type_t<decltype(x), decltype(y)>;\n            if ((IsNaN(x) && IsNaN(y)) || eve::all(x == y)) {\n                return std::numeric_limits<T>::quiet_NaN();\n            }\n            if (IsNaN(x)) { return T{0}; }\n            if (IsNaN(y)) { return T{1}; }\n            return static_cast<T>(Compare{}(T{x}, T{y}));\n        }\n    };\n}\n\n    template<typename T, std::size_t S = Backend::BatchSize<T>>\n    auto Add(std::vector<Operon::Node> const& , Backend::View<T const, S> , Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        std::ranges::fill_n(Ptr(trace, j), S, T{1});\n    }\n\n    template<typename T, std::size_t S>\n    auto Mul(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto i, std::integral auto j) {\n        using W = eve::wide<T>;\n        auto constexpr L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pi = Ptr(primal, i);\n        auto const* pj = Ptr(primal, j);\n\n        for(auto s = 0UL; s < S; s += L) {\n            eve::store(W{pi+s} / W{pj+s}, res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Sub(std::vector<Operon::Node> const& nodes, Backend::View<T const, S> , Backend::View<T> trace, std::integral auto i, std::integral auto j) {\n        auto v = (nodes[i].Arity == 1 || j < i-1) ? T{-1} : T{+1};\n        std::fill_n(Ptr(trace, j), S, v);\n    }\n\n    template<typename T, std::size_t S>\n    auto Div(std::vector<Operon::Node> const& nodes, Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto i, std::integral auto j) {\n        using W = eve::wide<T>;\n        auto constexpr L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pi = Ptr(primal, i);\n        auto const* pj = Ptr(primal, j);\n        if (nodes[i].Arity == 1) {\n            for (auto s = 0UL; s < S; s += L) {\n                eve::store(-eve::rec(eve::sqr(W{pj+s})), res+s);\n            }\n        } else {\n            auto v = j == i-1 ? T{1} : T{-1};\n            for (auto s = 0UL; s < S; s += L) {\n                eve::store(v * W{pi+s} / W{pj+s}, res+s);\n            }\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Aq(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto i, std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const k = i-1;\n        auto const* pi = Ptr(primal, i);\n        auto const* pj = Ptr(primal, j);\n        auto const* pk = Ptr(primal, k);\n\n        if (j == i-1) {\n            for (auto s = 0UL; s < S; s += L) {\n                eve::store(W{pi+s} / W{pj+s}, res+s);\n            }\n        } else {\n            for (auto s = 0UL; s < S; s += L) {\n                W a{pi+s};\n                W b{pj+s};\n                W c{pk+s};\n                W r = -b * a * a * a / (c * c);\n                eve::store(r, res+s);\n            }\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Pow(std::vector<Operon::Node> const& nodes, Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto i, std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pi = Ptr(primal, i);\n        auto const* pj = Ptr(primal, j);\n        if (j == i-1) {\n            auto const k = j - (nodes[j].Length + 1);\n            auto const* pk = Ptr(primal, k);\n            for (auto s = 0UL; s < S; s += L) {\n                eve::store(W{pi+s} * W{pk+s} / W{pj+s}, res+s);\n            }\n        } else {\n            auto const k = i-1;\n            auto const* pk = Ptr(primal, k);\n            for (auto s = 0UL; s < S; s += L) {\n                eve::store(W{pi+s} * eve::log(W{pk+s}), res+s);\n            }\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Min(std::vector<Operon::Node> const& nodes, Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto i, std::integral auto j) {\n        auto k = j == i - 1 ? (j - nodes[j].Length - 1) : i - 1;\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        auto const* pk = Ptr(primal, k);\n        std::transform(pj, pj+S, pk, res, detail::FComp<std::less<>>{});\n    }\n\n    template<typename T, std::size_t S>\n    auto Max(std::vector<Operon::Node> const& nodes, Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto i, std::integral auto j) {\n        auto k = j == i - 1 ? (j - nodes[j].Length - 1) : i - 1;\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        auto const* pk = Ptr(primal, k);\n        std::transform(pj, pj+S, pk, res, detail::FComp<std::greater<>>{});\n    }\n\n    template<typename T, std::size_t S>\n    auto Square(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(T{2} * W{pj+s}, res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Abs(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::sign(W{pj+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Ceil(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto  , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::ceil(W{pj+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Floor(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto  , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::floor(W{pj+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Exp(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto i, std::integral auto j) {\n        std::ranges::copy_n(Ptr(primal, i), S, Ptr(trace, j));\n    }\n\n    template<typename T, std::size_t S>\n    auto Log(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::rec(W{pj+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Log1p(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::rec(T{1} + W{pj+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Logabs(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::sign(W{pj+s}) / eve::abs(W{pj+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Sin(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::cos(W{pj+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Cos(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(-eve::sin(W{pj+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Tan(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(T{1} + eve::sqr(eve::tan(W{pj+s})), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Sinh(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::cosh(W{pj+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Cosh(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::sinh(W{pj+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Tanh(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(T{1} - eve::sqr(eve::tanh(W{pj+s})), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Asin(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::rec(eve::sqrt(T{1} - eve::sqr(W{pj+s}))), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Acos(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(-eve::rec(eve::sqrt(T{1} - eve::sqr(W{pj+s}))), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Atan(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto , std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::rec(T{1} + eve::sqr(W{pj+s})), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Sqrt(std::vector<Operon::Node> const&  , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto i, std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pi = Ptr(primal, i);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::rec(T{2} * W{pi+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Sqrtabs(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto i, std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pi = Ptr(primal, i);\n        auto const* pj = Ptr(primal, j);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::sign(W{pj+s}) / (T{2} * W{pi+s}), res+s);\n        }\n    }\n\n    template<typename T, std::size_t S>\n    auto Cbrt(std::vector<Operon::Node> const& , Backend::View<T const, S> primal, Backend::View<T> trace, std::integral auto i, std::integral auto j) {\n        using W = eve::wide<T>;\n        static constexpr auto L = W::size();\n\n        auto* res = Ptr(trace, j);\n        auto const* pi = Ptr(primal, i);\n        for (auto s = 0UL; s < S; s += L) {\n            eve::store(eve::rec(T{3} * eve::sqr(W{pi+s})), res+s);\n        }\n    }\n}\n\n#endif\n\n'operon/include/operon/interpreter/backend/plain.hpp'\n:\n\n\n#ifndef OPERON_BACKEND_PLAIN_HPP\n#define OPERON_BACKEND_PLAIN_HPP\n\n#include \"plain/derivatives.hpp\"\n\n#endif\n'operon/include/operon/interpreter/backend/eve.hpp'\n:\n\n\n#ifndef OPERON_BACKEND_EVE_HPP\n#define OPERON_BACKEND_EVE_HPP\n\n#include \"eve/derivatives.hpp\"\n\n#endif",
        "gt": [
            "'operon/include/operon/interpreter/backend/plain.hpp'",
            "'operon/include/operon/interpreter/functions.hpp'",
            "'operon/include/operon/interpreter/backend/eve/derivatives.hpp'",
            "'operon/include/operon/interpreter/backend/eve.hpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/NodeClass.h'",
            "'OpcUaStack/src/OpcUaStackServer/AddressSpaceModel/Attribute.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/ViewService.cpp'",
            "'OpcUaStack/src/OpcUaStackServer/AddressSpaceModel/AttributeAccess.h'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackCore/ServiceSet/NodeClass.h'\n:\n\n#ifndef __OpcUaStackCore_NodeClass_h__\n#define __OpcUaStackCore_NodeClass_h__\n\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n\nnamespace OpcUaStackCore\n{\n\ttypedef enum {\n\t\tNodeClassType_Unspecified = 0,\n\t\tNodeClassType_Object = 1,\n\t\tNodeClassType_Variable = 2,\n\t\tNodeClassType_Method = 4,\n\t\tNodeClassType_ObjectType = 8,\n\t\tNodeClassType_VariableType = 16,\n\t\tNodeClassType_ReferenceType = 32,\n\t\tNodeClassType_DataType = 64,\n\t\tNodeClassType_View = 128,\n\t\tNodeClassType_Dummy = 256,\n\t} NodeClassType;\n\n\n\tclass DLLEXPORT NodeClass\n\t: public  Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<NodeClass> SPtr;\n\n\t\tNodeClass(void);\n\t\tvirtual ~NodeClass(void);\n\n\t\tstatic std::string toString(NodeClassType nodeClassType);\n\t\tstatic NodeClassType toNodeClassType(const std::string& nodeClassTypeString);\n\n\t\tvoid nodeClassType(const NodeClassType nodeClassType);\n\t\tNodeClassType nodeClassType(void) const;\n\n\t\tvoid opcUaBinaryEncode(std::ostream& os) const;\n\t\tvoid opcUaBinaryDecode(std::istream& is);\n\n\t  private:\n\t\tNodeClassType nodeClassType_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackServer/AddressSpaceModel/Attribute.h'\n:\n\n#ifndef __OpcUaStackServer_Attribute_h__\n#define __OpcUaStackServer_Attribute_h__\n\n#include <boost/optional.hpp>\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n#include \"OpcUaStackCore/ServiceSet/NodeClass.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaAttributeId.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackServer\n{\n\n\ttypedef enum\n\t{\n\t\tAttributeModel_Mandatory,\n\t\tAttributeModel_Optional\n\t} AttributeModel;\n\n\n\tclass DLLEXPORT Attribute\n\t{\n\t  public:\n\t\tAttribute(void);\n\t\tvirtual ~Attribute(void);\n\n\t\tvirtual OpcUaUInt32 id(void) = 0;\n\t\tvirtual std::string name(void) = 0;\n\t\tvirtual std::string description(void);\n\t\tvirtual OpcUaBuildInType type(void) = 0;\n\t\tvirtual bool exist(void) = 0;\n\t\tvirtual void exist(bool exist) = 0;\n\t\tvirtual Attribute* clone(void) = 0;\n\t\tvirtual void copyTo(Attribute* attribute) = 0;\n\t\tvirtual bool equal(void) = 0;\n\n\t\tvirtual void out(std::ostream& os) const = 0;\n\t\tfriend std::ostream& operator<<(std::ostream& os, const Attribute& value) {\n\t\t\tvalue.out(os);\n\t\t\treturn os;\n\t\t}\n\n\t  private:\n\t};\n\n\n\ttemplate<typename DATATYPE>\n\t  class DLLEXPORT AttributeData\n\t  : public Attribute\n\t  {\n\t    public:\n\t\t  AttributeData(void)\n\t\t  : Attribute()\n\t\t  , data_()\n\t\t  , exist_(false)\n\t\t  {}\n\n\t\t  AttributeData(const DATATYPE& data)\n\t\t  : Attribute()\n\t\t  , exist_(true)\n\t\t  {\n\t\t\t  data_ = data;\n\t\t  }\n\n\t\t  virtual ~AttributeData(void)\n\t\t  {}\n\n\t\t  void reset(void)\n\t\t  {\n\t\t\t  exist_ = false;\n\t\t  }\n\n\t\t  void data(const DATATYPE& data) {\n\t\t\t  exist_ = true;\n\t\t\t  data_ = data;\n\t\t  }\n\n\t\t  DATATYPE& data(void) {\n\t\t\t  return data_;\n\t\t  }\n\n\t\t  boost::optional<DATATYPE&> data_optional(void) {\n\t\t\t  if (!exist_) return nullptr;\n\t\t\t  return data_;\n\t\t  }\n\n\t\t  bool exist(void) {\n\t\t\t  return exist_;\n\t\t  }\n\n\t\t  void exist(bool exist) {\n\t\t\t  exist_ = exist;\n\t\t  }\n\n\t\t  virtual void out(std::ostream& os) const {\n\t\t\t  os << data_;\n\t\t  }\n\t\t  friend std::ostream& operator<<(std::ostream& os, const AttributeData& attributeData) {\n\t\t\tos << attributeData.data_;\n\t\t\treturn os;\n\t\t  }\n\n\t    private:\n\t\t  bool exist_;\n\t\t  DATATYPE data_;\n\t  };\n\n\n    template<typename DATATYPE, OpcUaUInt32 id_, OpcUaBuildInType type_>\n\t  class DLLEXPORT AttributeMeta\n\t  : public AttributeData<DATATYPE>\n\t  {\n\t    public:\n\t\t\tAttributeMeta(void)\n\t\t\t: AttributeData<DATATYPE>()\n\t\t\t{}\n\n\t\t\tAttributeMeta(const DATATYPE& data)\n\t\t\t: AttributeData<DATATYPE>(data)\n\t\t\t{}\n\n\t\t\tvirtual ~AttributeMeta(void)\n\t\t\t{}\n\n\t\t\tOpcUaUInt32 id(void) {\n\t\t\t\treturn id_;\n\t\t\t}\n\n\t\t\tstd::string name(void) {\n\t\t\t\tswitch (id_)\n\t\t\t\t{\n\t\t\t\t\tcase AttributeId_AccessLevel: return \"AccessLevel\";\n\t\t\t\t\tcase AttributeId_ArrayDimensions: return \"ArrayDimensions\";\n\t\t\t\t\tcase AttributeId_BrowseName: return \"BrowseName\";\n\t\t\t\t\tcase AttributeId_ContainsNoLoops: return \"ContainsNoLoops\";\n\t\t\t\t\tcase AttributeId_DataType: return \"DataType\";\n\t\t\t\t\tcase AttributeId_Description: return \"Description\";\n\t\t\t\t\tcase AttributeId_DisplayName: return \"DisplayName\";\n\t\t\t\t\tcase AttributeId_EventNotifier: return \"EventNotifier\";\n\t\t\t\t\tcase AttributeId_Executable: return \"Executable\";\n\t\t\t\t\tcase AttributeId_Historizing: return \"Historizing\";\n\t\t\t\t\tcase AttributeId_InverseName: return \"InverseName\";\n\t\t\t\t\tcase AttributeId_IsAbstract: return \"IsAbstrace\";\n\t\t\t\t\tcase AttributeId_MinimumSamplingInterval: return \"MinimumSamplingInterval\";\n\t\t\t\t\tcase AttributeId_NodeClass: return \"NodeClass\";\n\t\t\t\t\tcase AttributeId_NodeId: return \"NodeId\";\n\t\t\t\t\tcase AttributeId_Symmetric: return \"Symmetric\";\n\t\t\t\t\tcase AttributeId_UserAccessLevel: return \"UserAccessLevel\";\n\t\t\t\t\tcase AttributeId_UserExecutable: return \"UserExecutable\";\n\t\t\t\t\tcase AttributeId_UserWriteMask: return \"UserWriteMask\";\n\t\t\t\t\tcase AttributeId_Value: return \"Value\";\n\t\t\t\t\tcase AttributeId_ValueRank: return \"ValueRank\";\n\t\t\t\t\tcase AttributeId_WriteMask: return \"WriteMask\";\n\t\t\t\t\tdefault: return \"Unknown\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOpcUaBuildInType type(void) {\n\t\t\t\treturn type_;\n\t\t\t}\n\n\t\t\tAttribute* clone(void) {\n\t\t\t\tAttribute* clone = new AttributeMeta<DATATYPE, id_, type_>();\n\t\t\t\tcopyTo(clone);\n\t\t\t\treturn clone;\n\t\t\t}\n\n\t\t\tvoid copyTo(Attribute* attribute) {\n\t\t\t\tAttributeMeta<DATATYPE, id_, type_>* attributeMeta;\n\t\t\t\tattributeMeta = reinterpret_cast<AttributeMeta<DATATYPE, id_, type_>*>(attribute);\n\t\t\t\tif (this->exist()) attributeMeta->data(this->data());\n\t\t\t}\n\n\t\t\tbool equal(void) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t  };\n\n\t  typedef AttributeMeta<OpcUaByte, AttributeId_AccessLevel, OpcUaBuildInType_OpcUaUInt32> AccessLevelAttribute;\n\t  typedef AttributeMeta<OpcUaNodeId, AttributeId_NodeId, OpcUaBuildInType_OpcUaNodeId> NodeIdAttribute;\n\t  typedef AttributeMeta<NodeClassType, AttributeId_NodeClass, OpcUaBuildInType_OpcUaUInt32> NodeClassAttribute;\n\t  typedef AttributeMeta<OpcUaQualifiedName, AttributeId_BrowseName, OpcUaBuildInType_OpcUaQualifiedName> BrowseNameAttribute;\n\t  typedef AttributeMeta<OpcUaLocalizedText, AttributeId_DisplayName, OpcUaBuildInType_OpcUaLocalizedText> DisplayNameAttribute;\n\t  typedef AttributeMeta<OpcUaLocalizedText, AttributeId_Description, OpcUaBuildInType_OpcUaLocalizedText> DescriptionAttribute;\n\t  typedef AttributeMeta<OpcUaUInt32, AttributeId_WriteMask, OpcUaBuildInType_OpcUaUInt32> WriteMaskAttribute;\n\t  typedef AttributeMeta<OpcUaUInt32, AttributeId_UserWriteMask, OpcUaBuildInType_OpcUaUInt32> UserWriteMaskAttribute;\n\t  typedef AttributeMeta<OpcUaBoolean, AttributeId_IsAbstract, OpcUaBuildInType_OpcUaBoolean> IsAbstractAttribute;\n\t  typedef AttributeMeta<OpcUaBoolean, AttributeId_Symmetric, OpcUaBuildInType_OpcUaBoolean> SymmetricAttribute;\n\t  typedef AttributeMeta<OpcUaLocalizedText, AttributeId_InverseName, OpcUaBuildInType_OpcUaLocalizedText> InverseNameAttribute;\n\t  typedef AttributeMeta<OpcUaBoolean, AttributeId_ContainsNoLoops, OpcUaBuildInType_OpcUaBoolean> ContainsNoLoopsAttribute;\n\t  typedef AttributeMeta<OpcUaByte, AttributeId_EventNotifier, OpcUaBuildInType_OpcUaByte> EventNotifierAttribute;\n\t  typedef AttributeMeta<OpcUaDataValue, AttributeId_Value, OpcUaBuildInType_OpcUaDataValue> ValueAttribute;\n\t  typedef AttributeMeta<OpcUaInt32, AttributeId_ValueRank, OpcUaBuildInType_OpcUaInt32> ValueRankAttribute;\n\t  typedef AttributeMeta<OpcUaUInt32Array, AttributeId_ArrayDimensions, OpcUaBuildInType_OpcUaUInt32> ArrayDimensionsAttribute;\n\t  typedef AttributeMeta<OpcUaDouble, AttributeId_MinimumSamplingInterval, OpcUaBuildInType_OpcUaDouble> MinimumSamplingIntervalAttribute;\n\t  typedef AttributeMeta<OpcUaBoolean, AttributeId_Historizing, OpcUaBuildInType_OpcUaBoolean> HistorizingAttribute;\n\t  typedef AttributeMeta<OpcUaNodeId, AttributeId_DataType, OpcUaBuildInType_OpcUaNodeId> DataTypeAttribute;\n\t  typedef AttributeMeta<OpcUaBoolean, AttributeId_Executable, OpcUaBuildInType_OpcUaBoolean> ExecutableAttribute;\n\t  typedef AttributeMeta<OpcUaBoolean, AttributeId_UserExecutable, OpcUaBuildInType_OpcUaBoolean> UserExecutableAttribute;\n\t  typedef AttributeMeta<OpcUaByte, AttributeId_UserAccessLevel, OpcUaBuildInType_OpcUaByte> UserAccessLevelAttribute;\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackServer/ServiceSet/ViewService.cpp'\n:\n\n#include \"OpcUaStackCore/BuildInTypes/OpcUaIdentifier.h\"\n#include \"OpcUaStackCore/Base/Log.h\"\n#include \"OpcUaStackCore/ServiceSet/ViewServiceTransaction.h\"\n#include \"OpcUaStackServer/ServiceSet/ViewService.h\"\n#include \"OpcUaStackServer/AddressSpaceModel/AttributeAccess.h\"\n\n\nnamespace OpcUaStackServer\n{\n\n\tViewService::ViewService(void)\n\t{\n\t}\n\n\tViewService::~ViewService(void)\n\t{\n\t}\n\n\tvoid\n\tViewService::receive(Message::SPtr message)\n\t{\n\t\tServiceTransaction::SPtr serviceTransaction = boost::static_pointer_cast<ServiceTransaction>(message);\n\t\tswitch (serviceTransaction->nodeTypeRequest().nodeId<uint32_t>())\n\t\t{\n\t\t\tcase OpcUaId_BrowseRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveBrowseRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_BrowseNextRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveBrowseNextRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_TranslateBrowsePathsToNodeIdsRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveTranslateBrowsePathsToNodeIdsRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_RegisterNodesRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveRegisterNodesRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_UnregisterNodesRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveUnregisterNodesRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tserviceTransaction->statusCode(BadInternalError);\n\t\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t}\n\t}\n\n\tvoid\n\tViewService::receiveBrowseRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionBrowse::SPtr trx = boost::static_pointer_cast<ServiceTransactionBrowse>(serviceTransaction);\n\t\tBrowseRequest::SPtr browseRequest = trx->request();\n\t\tBrowseResponse::SPtr browseResponse = trx->response();\n\n\n\t\tuint32_t nodes = browseRequest->nodesToBrowse()->size();\n\t\tLog(Debug, \"attribute service browse request\")\n\t\t\t.parameter(\"Trx\", serviceTransaction->transactionId())\n\t\t\t.parameter(\"NumberNodes\", nodes);\n\n\t\tBrowseResultArray::SPtr browseResultArray = constructSPtr<BrowseResultArray>();\n\t\tbrowseResponse->results(browseResultArray);\n\t\tbrowseResultArray->resize(nodes);\n\n\t\tfor (uint32_t idx = 0; idx < nodes; idx++) {\n\t\t\tBrowseDescription::SPtr browseDescription;\n\t\t\tbrowseRequest->nodesToBrowse()->get(idx, browseDescription);\n\n\t\t\tBrowseResult::SPtr browseResult = constructSPtr<BrowseResult>();\n\t\t\tbrowseResultArray->set(idx, browseResult);\n\n\t\t\tReferenceDescriptionVec::iterator it;\n\t\t\tReferenceDescriptionVec referenceDescriptionVec;\n\t\t\tOpcUaStatusCode statusCode = browseNode(browseDescription, referenceDescriptionVec);\n\t\t\tbrowseResult->statusCode(statusCode);\n\n\t\t\tReferenceDescriptionArray::SPtr referenceDescriptionArray = constructSPtr<ReferenceDescriptionArray>();\n\t\t\treferenceDescriptionArray->resize(referenceDescriptionVec.size());\n\t\t\tbrowseResult->references(referenceDescriptionArray);\n\t\t\tfor (it = referenceDescriptionVec.begin(); it != referenceDescriptionVec.end(); it++) {\n\t\t\t\tLog(Debug, \"reference\")\n\t\t\t\t\t.parameter(\"Trx\", serviceTransaction->transactionId())\n\t\t\t\t\t.parameter(\"SourceNodeId\", browseDescription->nodeId())\n\t\t\t\t\t.parameter(\"TargetNodeId\", (*it)->expandedNodeId())\n\t\t\t\t\t.parameter(\"TargetDisplayName\", (*it)->displayName().text())\n\t\t\t\t\t.parameter(\"ReferenceType\", ReferenceTypeMap::nodeIdToString(*(*it)->referenceTypeId()));\n\n\t\t\t\treferenceDescriptionArray->push_back(*it);\n\t\t\t}\n\n\t\t\tLog(Debug, \"attribute service browse request\")\n\t\t\t\t.parameter(\"Trx\", serviceTransaction->transactionId())\n\t\t\t\t.parameter(\"NodeId\", *browseDescription->nodeId())\n\t\t\t\t.parameter(\"References\", referenceDescriptionVec.size())\n\t\t\t\t.parameter(\"StatusCode\", OpcUaStatusCodeMap::shortString(statusCode));\n\t\t}\n\n\t\tserviceTransaction->statusCode(Success);\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tViewService::receiveBrowseNextRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\n\t\tserviceTransaction->statusCode(BadInternalError);\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tViewService::receiveTranslateBrowsePathsToNodeIdsRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionTranslateBrowsePathsToNodeIds::SPtr trx = boost::static_pointer_cast<ServiceTransactionTranslateBrowsePathsToNodeIds>(serviceTransaction);\n\t\tTranslateBrowsePathsToNodeIdsRequest::SPtr request = trx->request();\n\t\tTranslateBrowsePathsToNodeIdsResponse::SPtr response = trx->response();\n\n\t\tBrowsePathArray::SPtr browsePaths = request->browsePaths();\n\t\tif (browsePaths->size() == 0) {\n\t\t\tLog(Debug, \"no browse path elements exist\")\n\t\t\t\t.parameter(\"TransactionId\", serviceTransaction->transactionId());\n\t\t\tserviceTransaction->statusCode(Success);\n\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t\treturn;\n\t\t}\n\n\t\tresponse->results()->resize(browsePaths->size());\n\n\t\tfor (uint32_t idx=0; idx<browsePaths->size(); idx++) {\n\n\n\t\t\tBrowsePath::SPtr browsePath;\n\t\t\tif (!browsePaths->get(idx, browsePath)) {\n\t\t\t\tLog(Debug, \"browse paths invalid\")\n\t\t\t\t\t.parameter(\"TransactionId\", serviceTransaction->transactionId());\n\n\t\t\t\tserviceTransaction->statusCode(BadInternalError);\n\t\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tOpcUaNodeId::SPtr actualNode = browsePath->startingNode();\n\t\t\tRelativePath* relativePath = &browsePath->relativePath();\n\n\t\t\tBrowsePathResult::SPtr result = constructSPtr<BrowsePathResult>();\n\t\t\tresult->statusCode(Success);\n\t\t\tresponse->results()->push_back(result);\n\n\t\t\tif (relativePath->elements()->size() == 0) {\n\t\t\t\tresult->statusCode(BadInvalidArgument);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (uint32_t idx=0; idx<relativePath->elements()->size(); idx++) {\n\t\t\t\tRelativePathElement::SPtr relativePathElement;\n\t\t\t\tif (!relativePath->elements()->get(idx, relativePathElement)) {\n\t\t\t\t\tresult->statusCode(BadInvalidArgument);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tLog(Debug, \"TranslateBrowsePathsToNodeId\")\n\t\t\t\t\t.parameter(\"NodeId\", *actualNode);\n\t\t\t\tLog(Debug, \"  --\")\n\t\t\t\t    .parameter(\"PathElement\", relativePathElement->targetName().toString());\n\n\t\t\t\tif (!getNodeFromPathElement(*actualNode, relativePathElement->targetName())) {\n\t\t\t\t\tLog(Debug, \"node id not found\")\n\t\t\t\t\t\t.parameter(\"NodeId\", *actualNode)\n\t\t\t\t\t\t.parameter(\"PathElement\", relativePathElement->targetName().toString());\n\t\t\t\t\tresult->statusCode(BadNotFound);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (result->statusCode() == Success) {\n\t\t\t\tresult->targets()->resize(1);\n\n\t\t\t\tBrowsePathTarget::SPtr browsePathTarget = constructSPtr<BrowsePathTarget>();\n\n\t\t\t\tOpcUaExpandedNodeId::SPtr targetNodeId = constructSPtr<OpcUaExpandedNodeId>();\n\t\t\t\tactualNode->copyTo(*targetNodeId);\n\n\t\t\t\tbrowsePathTarget->tragetId(targetNodeId);\n\t\t\t\tbrowsePathTarget->remainingPathIndex(0xFFFFFFFF);\n\t\t\t\tresult->targets()->push_back(browsePathTarget);\n\t\t\t}\n\t\t}\n\n\t\tserviceTransaction->statusCode(Success);\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tViewService::receiveRegisterNodesRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\n\t\tserviceTransaction->statusCode(BadInternalError);\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tViewService::receiveUnregisterNodesRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\n\t\tserviceTransaction->statusCode(BadInternalError);\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\n\tOpcUaStatusCode\n\tViewService::browseNode(BrowseDescription::SPtr& browseDescription, ReferenceDescriptionVec& referenceDescriptionVec)\n\t{\n\t\tBaseNodeClass::SPtr baseNodeClass = informationModel_->find(*browseDescription->nodeId());\n\t\tif (baseNodeClass.get() == nullptr) {\n\t\t\treturn BadNodeIdUnknown;\n\t\t}\n\n\t\tReferenceItemMap& referenceItemMap = baseNodeClass->referenceItemMap();\n\t\tLog(Debug, \"read references\")\n\t\t\t.parameter(\"NodeId\", baseNodeClass->nodeId())\n\t\t\t.parameter(\"References\", referenceItemMap.size());\n\n\t\tfor (const auto& referenceItem : referenceItemMap) {\n\t\t\tOpcUaNodeId referenceTypeNodeId = referenceItem->typeId_;\n\n\t\t\tif (browseDescription->browseDirection() == BrowseDirection_Forward) {\n\t\t\t\tif (!referenceItem->isForward_) continue;\n\t\t\t}\n\n\t\t\tif (browseDescription->browseDirection() == BrowseDirection_Inverse) {\n\t\t\t\tif (referenceItem->isForward_) continue;\n\t\t\t}\n\n\t\t\tif (checkReferenceType(referenceTypeNodeId, browseDescription) != Success) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBaseNodeClass::SPtr baseNodeClassTarget = informationModel_->find(referenceItem->nodeId_);\n\t\t\tif (baseNodeClassTarget.get() == nullptr) {\n\t\t\t\tLog(Debug, \"target node not found\")\n\t\t\t\t\t.parameter(\"NodeId\", baseNodeClass->nodeId())\n\t\t\t\t\t.parameter(\"TargetNodeId\", referenceItem->nodeId_);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tReferenceDescription::SPtr referenceDescription = constructSPtr<ReferenceDescription>();\n\t\t\treferenceDescriptionVec.push_back(referenceDescription);\n\n\t\t\tOpcUaExpandedNodeId::SPtr targetNodeId = constructSPtr<OpcUaExpandedNodeId>();\n\t\t\tbaseNodeClassTarget->nodeId().data().copyTo(*targetNodeId);\n\t\t\treferenceDescription->expandedNodeId(targetNodeId);\n\t\t\treferenceTypeNodeId.copyTo(*referenceDescription->referenceTypeId());\n\t\t\treferenceDescription->isForward(referenceItem->isForward_);\n\t\t\treferenceDescription->displayName(baseNodeClassTarget->displayName().data());\n\t\t\treferenceDescription->browseName(baseNodeClassTarget->browseName().data());\n\t\t\treferenceDescription->nodeClass(baseNodeClassTarget->nodeClass().data());\n\n\t\t\tauto itp = baseNodeClassTarget->referenceItemMap().equal_range(*ReferenceTypeMap::hasTypeDefinitionTypeNodeId());\n\t\t\tif (itp.first != itp.second) {\n\t\t\t\tReferenceItem::SPtr referenceItem = itp.first->second;\n\t\t\t\treferenceItem->nodeId_.copyTo(*referenceDescription->typeDefinition());\n\t\t\t}\n\t\t}\n\n\t\treturn Success;\n\t}\n\n\tOpcUaStatusCode\n\tViewService::checkReferenceType(OpcUaNodeId& referenceTypeNodeId, BrowseDescription::SPtr& browseDescription)\n\t{\n\t\tOpcUaNodeId nullNodeId;\n\t\tnullNodeId.set(0);\n\t\tif (*browseDescription->referenceTypeId() == nullNodeId) return Success;\n\n\t\tOpcUaNodeId allNodeId;\n\t\tallNodeId.set(31);\n\t\tif (*browseDescription->referenceTypeId() == allNodeId) return Success;\n\n\t\tBaseNodeClass::SPtr baseNodeClass = informationModel_->find(referenceTypeNodeId);\n\t\tif (baseNodeClass.get() == nullptr) {\n\t\t\treturn BadNotFound;\n\t\t}\n\t\treturn hashSubtype(baseNodeClass,  browseDescription);\n\t\treturn Success;\n\t}\n\n\tOpcUaStatusCode\n\tViewService::hashSubtype(BaseNodeClass::SPtr baseNodeClass, BrowseDescription::SPtr browseDescription, uint32_t hopCounter)\n\t{\n\n\t\tif (hopCounter == 0) return BadInternalError;\n\n\t\tif (*browseDescription->referenceTypeId() == baseNodeClass->nodeId().data()) {\n\t\t\treturn Success;\n\t\t}\n\n\t\tauto it = baseNodeClass->referenceItemMap().equal_range(*ReferenceTypeMap::hasSubtypeTypeNodeId());\n\t\tif (it.first == it.second) {\n\t\t\treturn BadNotFound;\n\t\t}\n\n\t\tfor (auto itl = it.first; itl != it.second; ++itl) {\n\t\t\tReferenceItem::SPtr referenceItem  = itl->second;\n\n\t\t\tif (referenceItem->isForward_) continue;\n\n\t\t\tBaseNodeClass::SPtr baseNodeClassTarget = informationModel_->find(referenceItem->nodeId_);\n\t\t\tif (baseNodeClassTarget.get() == nullptr) {\n\t\t\t\treturn BadNodeIdUnknown;\n\t\t\t}\n\n\t\t\treturn hashSubtype(baseNodeClassTarget, browseDescription, hopCounter-1);\n\t\t}\n\n\t\treturn BadNotFound;\n\t}\n\n\tbool\n\tViewService::getNodeFromPathElement(OpcUaNodeId& nodeId, OpcUaQualifiedName& pathElement)\n\t{\n\t\tBaseNodeClass::SPtr baseNodeClass = informationModel_->find(nodeId);\n\t\tif (baseNodeClass.get() == nullptr) {\n\t\t\treturn false;\n\t\t}\n\n\t\tReferenceItemMap& referenceItemMap = baseNodeClass->referenceItemMap();\n\t\tfor (auto it = referenceItemMap.begin(); it != referenceItemMap.end(); ++it) {\n\t\t\tReferenceItem::SPtr referenceItem = *it;\n\t\t\tOpcUaNodeId referenceTypeNodeId = referenceItem->typeId_;\n\n\t\t\tBaseNodeClass::SPtr baseNodeClassTarget = informationModel_->find(referenceItem->nodeId_);\n\t\t\tif (baseNodeClassTarget.get() == nullptr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (baseNodeClassTarget->browseName().data() == pathElement) {\n\t\t\t\treferenceItem->nodeId_.copyTo(nodeId);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n'OpcUaStack/src/OpcUaStackServer/AddressSpaceModel/AttributeAccess.h'\n:\n\n#ifndef __OpcUaStackServer_AttributeAccess_h__\n#define __OpcUaStackServer_AttributeAccess_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackServer/AddressSpaceModel/Attribute.h\"\n\nnamespace OpcUaStackServer\n{\n\n\tclass DLLEXPORT AttributeAccess\n\t{\n\t  public:\n\t\tstatic bool copy(Attribute& attribute, OpcUaVariant& variant);\n\t\tstatic bool copy(OpcUaVariant& variant, Attribute& attribute);\n\t\tstatic bool copy(Attribute& attribute, OpcUaDataValue& dataValue);\n\t\tstatic bool copy(OpcUaDataValue& dataValue, Attribute& attribute);\n\n\t\tstatic bool trigger(OpcUaDataValue& dataValue, Attribute& attribute, DataChangeTrigger dataChangeTrigger = DCT_StatusValue);\n\t};\n\n}\n\n#endif\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/NodeClass.h'",
            "'OpcUaStack/src/OpcUaStackServer/AddressSpaceModel/Attribute.h'",
            "'OpcUaStack/src/OpcUaStackServer/AddressSpaceModel/AttributeAccess.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/ViewService.cpp'"
        ]
    },
    {
        "files": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/integrate.cpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/stepper_categories.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/integrate_const.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp'"
        ],
        "content": "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/integrate.cpp'\n:\n\n\n#define BOOST_TEST_MODULE odeint_integrate_functions\n\n#include <vector>\n#include <cmath>\n#include <iostream>\n\n#include <boost/numeric/odeint/config.hpp>\n\n#include <boost/array.hpp>\n#include <boost/ref.hpp>\n#include <boost/iterator/counting_iterator.hpp>\n\n#include <boost/test/unit_test.hpp>\n\n#include <boost/mpl/vector.hpp>\n\n\n#include <boost/numeric/odeint/integrate/integrate_const.hpp>\n#include <boost/numeric/odeint/integrate/integrate_adaptive.hpp>\n#include <boost/numeric/odeint/integrate/integrate_times.hpp>\n#include <boost/numeric/odeint/integrate/integrate_n_steps.hpp>\n#include <boost/numeric/odeint/stepper/euler.hpp>\n#include <boost/numeric/odeint/stepper/modified_midpoint.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta4.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta_cash_karp54.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta_dopri5.hpp>\n#include <boost/numeric/odeint/stepper/runge_kutta_fehlberg78.hpp>\n#include <boost/numeric/odeint/stepper/controlled_runge_kutta.hpp>\n#include <boost/numeric/odeint/stepper/bulirsch_stoer.hpp>\n#include <boost/numeric/odeint/stepper/dense_output_runge_kutta.hpp>\n#include <boost/numeric/odeint/stepper/bulirsch_stoer_dense_out.hpp>\n\n#include <boost/numeric/odeint/util/detail/less_with_sign.hpp>\n\nusing namespace boost::unit_test;\nusing namespace boost::numeric::odeint;\nnamespace mpl = boost::mpl;\n\n\ntypedef double value_type;\ntypedef std::vector< value_type > state_type;\n\nvoid lorenz( const state_type &x , state_type &dxdt , const value_type t )\n{\n\n    const value_type R( 28.0 );\n    const value_type b( value_type( 8.0 ) / value_type( 3.0 ) );\n\n\n    dxdt[0] = 1.0;\n    dxdt[1] = R * x[0] - x[1] - x[0] * x[2];\n    dxdt[2] = -b * x[2] + x[0] * x[1];\n}\n\nstruct push_back_time\n{\n    std::vector< double >& m_times;\n\n    state_type& m_x;\n\n    push_back_time( std::vector< double > &times , state_type &x )\n    :  m_times( times ) , m_x( x ) { }\n\n    void operator()( const state_type &x , double t )\n    {\n        m_times.push_back( t );\n        boost::numeric::odeint::copy( x , m_x );\n    }\n};\n\ntemplate< class Stepper >\nstruct perform_integrate_const_test\n{\n    void operator()( const value_type t_end , const value_type dt )\n    {\n        std::cout << \"Testing integrate_const with \" << typeid( Stepper ).name() << std::endl;\n\n        state_type x( 3 , 10.0 ) , x_end( 3 );\n\n        std::vector< value_type > times;\n\n        integrate_const( Stepper() , lorenz , x , 0.0 , t_end ,\n                                        dt , push_back_time( times , x_end ) );\n\n\n\n\n\n        BOOST_CHECK_EQUAL( static_cast<int>(times.size()) , static_cast<int>(floor(t_end/dt))+1 );\n\n        for( size_t i=0 ; i<times.size() ; ++i )\n        {\n\n\n            BOOST_CHECK_SMALL( times[i] - static_cast< value_type >(i)*dt , (i+1) * 2E-16 );\n        }\n\n\n        BOOST_CHECK_SMALL( (10.0 + times[times.size()-1]) - x_end[0] , 1E-6 );\n\n\n    }\n};\n\ntemplate< class Stepper >\nstruct perform_integrate_adaptive_test\n{\n    void operator()( const value_type t_end = 10.0 , const value_type dt = 0.03 )\n    {\n        std::cout << \"Testing integrate_adaptive with \" << typeid( Stepper ).name() << std::endl;\n\n        state_type x( 3 , 10.0 ) , x_end( 3 );\n\n        std::vector< value_type > times;\n\n        size_t steps = integrate_adaptive( Stepper() , *lorenz , x , 0.0 , t_end ,\n                                        dt , push_back_time( times , x_end ) );\n\n\n\n        BOOST_CHECK_EQUAL( times.size() , steps+1 );\n\n        BOOST_CHECK_SMALL( times[0] - 0.0 , 2E-16 );\n        BOOST_CHECK_SMALL( times[times.size()-1] - t_end , times.size() * 2E-16 );\n\n\n        BOOST_CHECK_SMALL( (10.0 + t_end) - x_end[0] , 1E-6 );\n\n\n    }\n};\n\n\ntemplate< class Stepper >\nstruct perform_integrate_times_test\n{\n    void operator()( const int n = 10 , const int dn=1 , const value_type dt = 0.03 )\n    {\n        std::cout << \"Testing integrate_times with \" << typeid( Stepper ).name() << std::endl;\n\n        state_type x( 3 ) , x_end( 3 );\n        x[0] = x[1] = x[2] = 10.0;\n\n        std::vector< double > times;\n\n        std::vector< double > obs_times( abs(n) );\n        for( int i=0 ; boost::numeric::odeint::detail::less_with_sign( i ,\n                       static_cast<int>(obs_times.size()) ,\n                       dt ) ; i+=dn )\n        {\n            obs_times[i] = i;\n        }\n\n        integrate_times( Stepper() , lorenz , x , obs_times.begin() , obs_times.end() ,\n                    dt , push_back_time( times , x_end ) );\n\n        BOOST_CHECK_EQUAL( static_cast<int>(times.size()) , abs(n) );\n\n        for( size_t i=0 ; i<times.size() ; ++i )\n\n            BOOST_CHECK_EQUAL( times[i] , static_cast<double>(i) );\n\n\n        BOOST_CHECK_SMALL( (10.0 + 1.0*times[times.size()-1]) - x_end[0] , 1E-6 );\n\n\n    }\n};\n\ntemplate< class Stepper >\nstruct perform_integrate_n_steps_test\n{\n    void operator()( const int n = 200 , const value_type dt = 0.01 )\n    {\n        std::cout << \"Testing integrate_n_steps with \" << typeid( Stepper ).name() << std::endl;\n\n        state_type x( 3 ) , x_end( 3 );\n        x[0] = x[1] = x[2] = 10.0;\n\n        std::vector< double > times;\n\n\n        value_type end_time = integrate_n_steps( Stepper() , lorenz , x , 0.0 , dt , n , push_back_time( times , x_end ) );\n\n        BOOST_CHECK_SMALL( end_time - n*dt , 2E-16 );\n        BOOST_CHECK_EQUAL( static_cast<int>(times.size()) , n+1 );\n\n        for( size_t i=0 ; i<times.size() ; ++i )\n\n            BOOST_CHECK_SMALL( times[i] - static_cast< value_type >(i)*dt , 2E-16 );\n\n\n        BOOST_CHECK_SMALL( (10.0 + end_time) - x_end[0] , 1E-6 );\n\n\n\n    }\n};\n\n\n\nclass stepper_methods : public mpl::vector<\n    euler< state_type > ,\n    modified_midpoint< state_type > ,\n    runge_kutta4< state_type > ,\n    runge_kutta_cash_karp54< state_type > ,\n    runge_kutta_dopri5< state_type > ,\n    runge_kutta_fehlberg78< state_type > ,\n    controlled_runge_kutta< runge_kutta_cash_karp54< state_type > > ,\n    controlled_runge_kutta< runge_kutta_dopri5< state_type > > ,\n    controlled_runge_kutta< runge_kutta_fehlberg78< state_type > > ,\n    bulirsch_stoer< state_type > ,\n    dense_output_runge_kutta< controlled_runge_kutta< runge_kutta_dopri5< state_type > > >\n\n> { };\n\n\n\nBOOST_AUTO_TEST_SUITE( integrate_test )\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_const_test_case , Stepper, stepper_methods )\n{\n    perform_integrate_const_test< Stepper > tester;\n    tester( 1.005 , 0.01 );\n    tester( 1.0 , 0.01 );\n    tester( 1.1 , 0.01 );\n    tester( -1.005 , -0.01 );\n}\n\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_adaptive_test_case , Stepper, stepper_methods )\n{\n    perform_integrate_adaptive_test< Stepper > tester;\n    tester( 1.005 , 0.01 );\n    tester( 1.0 , 0.01 );\n    tester( 1.1 , 0.01 );\n    tester( -1.005 , -0.01 );\n}\n\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_times_test_case , Stepper, stepper_methods )\n{\n    perform_integrate_times_test< Stepper > tester;\n    tester();\n\n}\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_n_steps_test_case , Stepper, stepper_methods )\n{\n    perform_integrate_n_steps_test< Stepper > tester;\n    tester();\n    tester( 200 , 0.01 );\n    tester( 200 , 0.01 );\n    tester( 200 , 0.01 );\n    tester( 200 , -0.01 );\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/stepper_categories.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_STEPPER_STEPPER_CATEGORIES_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_STEPPER_STEPPER_CATEGORIES_HPP_INCLUDED\n\n#include <boost/type_traits/integral_constant.hpp>\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\n\n\n\nstruct stepper_tag {};\n\n\n\n\nstruct error_stepper_tag : stepper_tag {};\nstruct explicit_error_stepper_tag : error_stepper_tag {};\nstruct explicit_error_stepper_fsal_tag : error_stepper_tag {};\n\nstruct controlled_stepper_tag {};\nstruct explicit_controlled_stepper_tag : controlled_stepper_tag {};\nstruct explicit_controlled_stepper_fsal_tag : controlled_stepper_tag {};\n\nstruct dense_output_stepper_tag {};\n\n\ntemplate< class tag > struct base_tag ;\ntemplate< > struct base_tag< stepper_tag > { typedef stepper_tag type; };\ntemplate< > struct base_tag< error_stepper_tag > { typedef stepper_tag type; };\ntemplate< > struct base_tag< explicit_error_stepper_tag > { typedef stepper_tag type; };\ntemplate< > struct base_tag< explicit_error_stepper_fsal_tag > { typedef stepper_tag type; };\n\ntemplate< > struct base_tag< controlled_stepper_tag > { typedef controlled_stepper_tag type; };\ntemplate< > struct base_tag< explicit_controlled_stepper_tag > { typedef controlled_stepper_tag type; };\ntemplate< > struct base_tag< explicit_controlled_stepper_fsal_tag > { typedef controlled_stepper_tag type; };\n\ntemplate< > struct base_tag< dense_output_stepper_tag > { typedef dense_output_stepper_tag type; };\n\n\n}\n}\n}\n\n\n#endif\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/integrate_const.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_INTEGRATE_INTEGRATE_CONST_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_INTEGRATE_INTEGRATE_CONST_HPP_INCLUDED\n\n#include <boost/type_traits/is_same.hpp>\n\n#include <boost/numeric/odeint/stepper/stepper_categories.hpp>\n#include <boost/numeric/odeint/integrate/null_observer.hpp>\n#include <boost/numeric/odeint/integrate/detail/integrate_const.hpp>\n#include <boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp>\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\n\n\n\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer >\nsize_t integrate_const(\n        Stepper stepper , System system , State &start_state ,\n        Time start_time , Time end_time , Time dt ,\n        Observer observer\n)\n{\n\n    if( boost::is_same< null_observer , Observer >::value )\n    {\n        return detail::integrate_adaptive(\n                stepper , system , start_state ,\n                start_time , end_time  , dt ,\n                observer , typename Stepper::stepper_category() );\n    }\n    else\n    {\n        return detail::integrate_const( stepper , system , start_state ,\n                                        start_time , end_time , dt ,\n                                        observer , typename Stepper::stepper_category() );\n      }\n}\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer >\nsize_t integrate_const(\n        Stepper stepper , System system , const State &start_state ,\n        Time start_time , Time end_time , Time dt ,\n        Observer observer\n)\n{\n\n    if( boost::is_same< null_observer , Observer >::value )\n    {\n        return detail::integrate_adaptive(\n                stepper , system , start_state ,\n                start_time , end_time  , dt ,\n                observer , typename Stepper::stepper_category() );\n    }\n    else\n    {\n        return detail::integrate_const( stepper , system , start_state ,\n                                        start_time , end_time , dt ,\n                                        observer , typename Stepper::stepper_category() );\n    }\n}\n\n\n\n\n\n\ntemplate< class Stepper , class System , class State , class Time >\nsize_t integrate_const(\n        Stepper stepper , System system , State &start_state ,\n        Time start_time , Time end_time , Time dt\n)\n{\n    return integrate_const( stepper , system , start_state , start_time , end_time , dt , null_observer() );\n}\n\n\ntemplate< class Stepper , class System , class State , class Time >\nsize_t integrate_const(\n        Stepper stepper , System system , const State &start_state ,\n        Time start_time , Time end_time , Time dt\n)\n{\n    return integrate_const( stepper , system , start_state , start_time , end_time , dt , null_observer() );\n}\n\n\n\n\n\n\n\n\n\n}\n}\n}\n\n\n\n#endif\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_INTEGRATE_DETAIL_INTEGRATE_ADAPTIVE_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_INTEGRATE_DETAIL_INTEGRATE_ADAPTIVE_HPP_INCLUDED\n\n#include <stdexcept>\n\n#include <boost/numeric/odeint/stepper/stepper_categories.hpp>\n#include <boost/numeric/odeint/stepper/controlled_step_result.hpp>\n#include <boost/numeric/odeint/integrate/detail/integrate_const.hpp>\n#include <boost/numeric/odeint/util/bind.hpp>\n#include <boost/numeric/odeint/util/unwrap_reference.hpp>\n#include <boost/numeric/odeint/util/copy.hpp>\n\n#include <boost/numeric/odeint/util/detail/less_with_sign.hpp>\n\n\n#include <iostream>\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\nnamespace detail {\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer>\nsize_t integrate_const(\n        Stepper stepper , System system , State &start_state ,\n        Time start_time , Time end_time , Time dt ,\n        Observer observer , stepper_tag );\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer >\nsize_t integrate_adaptive(\n        Stepper stepper , System system , State &start_state ,\n        Time start_time , Time end_time , Time dt ,\n        Observer observer , stepper_tag\n)\n{\n    size_t steps = detail::integrate_const( stepper , system , start_state , start_time ,\n                                            end_time , dt , observer , stepper_tag() );\n    Time end = start_time + dt*steps;\n    if( less_with_sign( end , end_time , dt ) )\n    {\n        stepper.do_step( system , start_state , end , end_time - end );\n        steps++;\n        typename odeint::unwrap_reference< Observer >::type &obs = observer;\n        obs( start_state , end_time );\n    }\n    return steps;\n}\n\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer >\nsize_t integrate_adaptive(\n        Stepper stepper , System system , State &start_state ,\n        Time &start_time , Time end_time , Time &dt ,\n        Observer observer , controlled_stepper_tag\n)\n{\n    typename odeint::unwrap_reference< Observer >::type &obs = observer;\n\n    const size_t max_attempts = 1000;\n    const char *error_string = \"Integrate adaptive : Maximal number of iterations reached. A step size could not be found.\";\n    size_t count = 0;\n    while( less_with_sign( start_time , end_time , dt ) )\n    {\n        obs( start_state , start_time );\n        if( less_with_sign( end_time , start_time + dt , dt ) )\n        {\n            dt = end_time - start_time;\n        }\n\n        size_t trials = 0;\n        controlled_step_result res = success;\n        do\n        {\n            res = stepper.try_step( system , start_state , start_time , dt );\n            ++trials;\n        }\n        while( ( res == fail ) && ( trials < max_attempts ) );\n        if( trials == max_attempts ) throw std::overflow_error( error_string );\n\n        ++count;\n    }\n    obs( start_state , start_time );\n    return count;\n}\n\n\n\ntemplate< class Stepper , class System , class State , class Time , class Observer >\nsize_t integrate_adaptive(\n        Stepper stepper , System system , State &start_state ,\n        Time start_time , Time end_time , Time dt ,\n        Observer observer , dense_output_stepper_tag )\n{\n    typename odeint::unwrap_reference< Observer >::type &obs = observer;\n\n    size_t count = 0;\n    stepper.initialize( start_state , start_time , dt );\n\n    while( less_with_sign( stepper.current_time() , end_time , stepper.current_time_step() ) )\n    {\n        while( less_eq_with_sign( stepper.current_time() + stepper.current_time_step() ,\n               end_time ,\n               stepper.current_time_step() ) )\n        {\n            obs( stepper.current_state() , stepper.current_time() );\n            stepper.do_step( system );\n            ++count;\n        }\n        stepper.initialize( stepper.current_state() , stepper.current_time() , end_time - stepper.current_time() );\n    }\n    obs( stepper.current_state() , stepper.current_time() );\n\n    boost::numeric::odeint::copy( stepper.current_state() , start_state );\n    return count;\n}\n\n\n\n\n}\n}\n}\n}\n\n\n#endif\n",
        "gt": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/stepper_categories.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/integrate/integrate_const.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/integrate.cpp'"
        ]
    },
    {
        "files": [
            "'OpenSPH/core/common/Globals.h'",
            "'OpenSPH/test/utils/SequenceTest.h'",
            "'OpenSPH/core/gravity/test/NBodySolver.cpp'"
        ],
        "content": "'OpenSPH/core/common/Globals.h'\n:#pragma once\n\n\n\n\n\n\n#include \"objects/Object.h\"\n\nNAMESPACE_SPH_BEGIN\n\n\n#ifdef SPH_SINGLE_PRECISION\nusing Float = float;\n#else\nusing Float = double;\n#endif\n\n\nusing Size = uint32_t;\n\n\nusing SignedSize = int32_t;\n\n\nconstexpr int DIMENSIONS = 3;\n\n\nconstexpr int PRECISION = std::is_same<Float, double>::value ? 12 : 6;\n\n\nINLINE constexpr Float operator\"\" _f(const long double v) {\n    return Float(v);\n}\n\nconstexpr char SPH_CODE_NAME[] = \"OpenSPH\";\n\n#define SPH_STR(x) SPH_XSTR(x)\n#define SPH_XSTR(x) #x\n\n#ifdef SPH_VERSION\nconstexpr char SPH_CODE_VERSION[] = SPH_STR(SPH_VERSION);\n#else\nconstexpr char SPH_CODE_VERSION[] = \"unknown\";\n#endif\n\nNAMESPACE_SPH_END\n\n'OpenSPH/test/utils/SequenceTest.h'\n:#pragma once\n\n#include \"common/Globals.h\"\n#include \"objects/wrappers/Outcome.h\"\n\n\n\n\n\n\nNAMESPACE_SPH_BEGIN\n\n\n\n\n\n\ntemplate <typename Test>\nclass SequenceTest {\nprivate:\n    Test& test;\n\n    Size failedIdx = 0;\n    Outcome result{ SUCCESS };\n\npublic:\n    explicit SequenceTest(Test& test)\n        : test(test) {}\n\n    bool performTest(const Size idx) {\n        result = test(idx);\n        if (!result) {\n            failedIdx = idx;\n            return false;\n        }\n        return true;\n    }\n\n    friend std::ostream& operator<<(std::ostream& stream, const SequenceTest& sequence) {\n        if (sequence.result) {\n            stream << \"All tests in sequence passed\" << std::endl;\n            return stream;\n        }\n        stream << \"Test sequence failed with index \" << sequence.failedIdx << std::endl;\n        stream << sequence.result.error() << std::endl;\n        return stream;\n    }\n\n    const Outcome& outcome() const {\n        return result;\n    }\n};\n\n\n\nstruct SequenceSuccessful {\n    friend std::ostream& operator<<(std::ostream& stream, const SequenceSuccessful&) {\n        stream << \"Sequence Test:\";\n        return stream;\n    }\n};\nconst SequenceSuccessful SEQUENCE_SUCCESS;\n\ntemplate <typename Test>\nINLINE bool operator==(const SequenceSuccessful, const SequenceTest<Test>& sequence) {\n    return (bool)sequence.outcome();\n}\n\n\n#define REQUIRE_SEQUENCE(test, from, to) REQUIRE(SEQUENCE_SUCCESS == testSequence(test, from, to))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntemplate <typename Test>\nSequenceTest<Test> testSequence(Test& test, const Size from, const Size to) {\n    SPH_ASSERT(from < to);\n    SequenceTest<Test> sequenceTest(test);\n    for (Size idx = from; idx < to; ++idx) {\n        if (!sequenceTest.performTest(idx)) {\n            return sequenceTest;\n        }\n    }\n    return sequenceTest;\n}\n\nNAMESPACE_SPH_END\n\n'OpenSPH/core/gravity/test/NBodySolver.cpp'\n:#include \"gravity/NBodySolver.h\"\n#include \"catch.hpp\"\n#include \"gravity/Collision.h\"\n#include \"physics/Integrals.h\"\n#include \"quantities/IMaterial.h\"\n#include \"quantities/Quantity.h\"\n#include \"tests/Approx.h\"\n#include \"tests/Setup.h\"\n#include \"thread/Pool.h\"\n#include \"timestepping/TimeStepping.h\"\n#include \"utils/SequenceTest.h\"\n#include \"utils/Utils.h\"\n\nusing namespace Sph;\n\ntemplate <typename TTimestepping, typename TFunctor>\nstatic void integrate(SharedPtr<Storage> storage, ISolver& solver, const Float dt, TFunctor functor) {\n    RunSettings settings;\n    settings.set(RunSettingsId::TIMESTEPPING_INITIAL_TIMESTEP, dt)\n        .set(RunSettingsId::TIMESTEPPING_MAX_TIMESTEP, dt)\n        .set(RunSettingsId::TIMESTEPPING_CRITERION, EMPTY_FLAGS);\n\n    ThreadPool& pool = *ThreadPool::getGlobalInstance();\n    TTimestepping timestepping(storage, settings);\n    Statistics stats;\n\n    auto test = [&](Size i) -> Outcome {\n        stats.set(StatisticsId::RUN_TIME, i * dt);\n        timestepping.step(pool, solver, stats);\n        return functor(i);\n    };\n    REQUIRE_SEQUENCE(test, 1, 10000);\n}\n\nTEST_CASE(\"Local frame rotation\", \"[nbody]\") {\n    RunSettings settings;\n    settings.set(RunSettingsId::NBODY_INERTIA_TENSOR, true);\n    ThreadPool& pool = *ThreadPool::getGlobalInstance();\n    HardSphereSolver solver(pool, settings);\n    SharedPtr<Storage> storage = makeShared<Storage>(makeAuto<NullMaterial>(EMPTY_SETTINGS));\n    storage->insert<Vector>(\n        QuantityId::POSITION, OrderEnum::SECOND, Array<Vector>{ Vector(0._f, 0._f, 0._f, 1._f) });\n    storage->insert<Float>(QuantityId::MASS, OrderEnum::ZERO, 1._f);\n    solver.create(*storage, storage->getMaterial(0));\n\n    ArrayView<Vector> w = storage->getValue<Vector>(QuantityId::ANGULAR_FREQUENCY);\n    ArrayView<Vector> L = storage->getValue<Vector>(QuantityId::ANGULAR_MOMENTUM);\n    ArrayView<SymmetricTensor> I = storage->getValue<SymmetricTensor>(QuantityId::MOMENT_OF_INERTIA);\n    w[0] = Vector(0._f, 0._f, 2._f * PI);\n    L[0] = I[0] * w[0];\n\n    ArrayView<Tensor> E = storage->getValue<Tensor>(QuantityId::LOCAL_FRAME);\n    REQUIRE(E[0] == Tensor::identity());\n\n    Statistics stats;\n    solver.collide(*storage, stats, 0.25_f);\n    REQUIRE(E[0] == approx(convert<Tensor>(AffineMatrix::rotateZ(PI / 2._f))));\n\n    solver.collide(*storage, stats, 0.25_f);\n    REQUIRE(E[0] == approx(convert<Tensor>(AffineMatrix::rotateZ(PI))));\n\n    solver.collide(*storage, stats, 0.25_f);\n    REQUIRE(E[0] == approx(convert<Tensor>(AffineMatrix::rotateZ(3._f / 2._f * PI))));\n\n    solver.collide(*storage, stats, 0.25_f);\n    REQUIRE(E[0] == approx(Tensor::identity()));\n}\n\ntemplate <typename TTimestepping>\nstatic void flywheel(const Float dt, const Float eps) {\n    RunSettings settings;\n    settings.set(RunSettingsId::NBODY_MAX_ROTATION_ANGLE, 1.e-4_f);\n    settings.set(RunSettingsId::NBODY_INERTIA_TENSOR, true);\n\n    ThreadPool& pool = *ThreadPool::getGlobalInstance();\n    HardSphereSolver solver(pool, settings);\n    SharedPtr<Storage> storage = makeShared<Storage>(makeAuto<NullMaterial>(EMPTY_SETTINGS));\n    storage->insert<Vector>(QuantityId::POSITION,\n        OrderEnum::SECOND,\n        Array<Vector>{ Vector(0._f, 0._f, 0._f, 1._f) });\n    storage->insert<Float>(QuantityId::MASS, OrderEnum::ZERO, 2._f);\n    solver.create(*storage, storage->getMaterial(0));\n\n    ArrayView<SymmetricTensor> I = storage->getValue<SymmetricTensor>(QuantityId::MOMENT_OF_INERTIA);\n    ArrayView<Tensor> E = storage->getValue<Tensor>(QuantityId::LOCAL_FRAME);\n    ArrayView<Vector> w = storage->getValue<Vector>(QuantityId::ANGULAR_FREQUENCY);\n    ArrayView<Vector> L = storage->getValue<Vector>(QuantityId::ANGULAR_MOMENTUM);\n    w[0] = Vector(2.5_f, -4._f, 9._f);\n    const Float I1 = 3._f;\n    const Float I3 = 1.2_f;\n    I[0] = SymmetricTensor(Vector(I1, I1, I3), Vector(0._f));\n    L[0] = I[0] * w[0];\n\n    const SymmetricTensor I0 = I[0];\n    const Vector w0 = w[0];\n    const Vector L0 = L[0];\n\n    auto test = [&](Size) -> Outcome {\n\n        const Vector L = transform(I[0], convert<AffineMatrix>(E[0])) * w[0];\n        if (L != approx(L0, eps)) {\n            return makeFailed(\"Angular momentum not conserved:\\n{} == {}\", L, L0);\n        }\n\n\n        if (getLength(w[0]) != approx(getLength(w0), eps)) {\n            return makeFailed(\"omega not conserved:\\n{} == {}\", getLength(w[0]), getLength(w0));\n        }\n\n\n        if (I[0] != I0) {\n            return makeFailed(\"Moment of inertia changed:\\n{} == {}\", I[0], I0);\n        }\n\n\n        if (dot(w[0], L) != approx(dot(w0, L0), eps)) {\n            return makeFailed(\"Angle between w and L not conserved:\\n{} == {}\", dot(w[0], L), dot(w0, L0));\n        }\n\n        return SUCCESS;\n    };\n    integrate<TTimestepping>(storage, solver, dt, test);\n\n\n    REQUIRE(w[0] != approx(w0));\n}\n\nTEMPLATE_TEST_CASE(\"Flywheel small timestep\", \"[nbody]\", EulerExplicit, LeapFrog) {\n    flywheel<TestType>(1.e-5_f, 4.e-5_f);\n}\n\nTEMPLATE_TEST_CASE(\"Flywheel large timestep\", \"[nbody]\", EulerExplicit, LeapFrog) {\n    flywheel<TestType>(1.e-3_f, 0.01_f);\n}\n\nstatic SharedPtr<Storage> makeTwoParticles() {\n    SharedPtr<Storage> storage = makeShared<Storage>(makeAuto<NullMaterial>(EMPTY_SETTINGS));\n    storage->insert<Vector>(QuantityId::POSITION,\n        OrderEnum::SECOND,\n        Array<Vector>{ Vector(2._f, 0._f, 0._f, 1._f), Vector(-2._f, 0._f, 0._f, 0.5_f) });\n    storage->insert<Float>(QuantityId::MASS, OrderEnum::ZERO, 2._f);\n\n    ArrayView<Vector> v = storage->getDt<Vector>(QuantityId::POSITION);\n    v[0] = Vector(-5._f, 0._f, 0._f);\n    v[1] = Vector(5._f, 0._f, 0._f);\n    return storage;\n}\n\nTEMPLATE_TEST_CASE(\"Collision bounce two\", \"[nbody]\", EulerExplicit, LeapFrog) {\n    RunSettings settings;\n    settings.set(RunSettingsId::COLLISION_HANDLER, CollisionHandlerEnum::ELASTIC_BOUNCE)\n        .set(RunSettingsId::COLLISION_RESTITUTION_NORMAL, 1._f)\n        .set(RunSettingsId::COLLISION_RESTITUTION_TANGENT, 1._f)\n        .set(RunSettingsId::NBODY_INERTIA_TENSOR, true);\n\n    ThreadPool& pool = *ThreadPool::getGlobalInstance();\n    HardSphereSolver solver(pool, settings);\n\n    SharedPtr<Storage> storage = makeTwoParticles();\n    solver.create(*storage, storage->getMaterial(0));\n\n    const Float dt = 1.e-4_f;\n    ArrayView<const Vector> r, v, dv;\n    tie(r, v, dv) = storage->getAll<Vector>(QuantityId::POSITION);\n    ArrayView<const SymmetricTensor> I = storage->getValue<SymmetricTensor>(QuantityId::MOMENT_OF_INERTIA);\n    ArrayView<const Vector> w = storage->getValue<Vector>(QuantityId::ANGULAR_FREQUENCY);\n\n    const Float dist = getLength(r[0] - r[1]) - r[0][H] - r[1][H];\n    const Float v_rel = getLength(v[0] - v[1]);\n    const Float t_coll = dist / v_rel;\n    const Vector r0 = r[0];\n    const Vector r1 = r[1];\n    const Vector v0 = v[0];\n    const Vector v1 = v[1];\n    const Float I0 = I[0].trace() / 3._f;\n    const Float I1 = I[1].trace() / 3._f;\n\n    auto test = [&](Size i) -> Outcome {\n        const Float t = i * dt;\n\n        if (r[0][H] != r0[H] || r[1][H] != r1[H]) {\n            return makeFailed(\"Radius changed\");\n        }\n        if (I[0] != approx(SymmetricTensor::identity() * I0)) {\n            return makeFailed(\"Moment of inertia changed\\n{} == {}\", I[0], I0);\n        }\n        if (I[1] != approx(SymmetricTensor::identity() * I1)) {\n            return makeFailed(\"Moment of inertia changed\\n{} == {}\", I[1], I1);\n        }\n        if (w[0] != Vector(0._f) || w[1] != Vector(0._f)) {\n            return makeFailed(\"Angular velocity increased\");\n        }\n        if (storage->getParticleCnt() != 2) {\n            return makeFailed(\"Particle number changed\");\n        }\n        if (t < t_coll) {\n            if (r[0] != approx(r0 + v0 * t) || r[1] != approx(r1 + v1 * t)) {\n                return makeFailed(\"Incorrect positions\");\n            }\n            if (v[0] != approx(v0, 1.e-6_f) || v[1] != approx(v1, 1.e-6_f)) {\n\n                return makeFailed(\"Velocities changed before bounce\\nt = {} (t_coll = {})\\n{} == {}\\n{} == {}\",\n                                  t, t_coll, v[0], v0, v[1],  v1);\n\n            }\n        } else {\n            if (v[0] != approx(v1, 1.e-6_f) || v[1] != approx(v0, 1.e-6_f)) {\n\n                return makeFailed(\"Velocities changed after bounce\\nt = {} (t_coll = {})\\n{} == {}\\n{} == {}\",\n                                  t, t_coll, v[0], v0, v[1], v1);\n\n            }\n        }\n        return SUCCESS;\n    };\n    integrate<TestType>(storage, solver, dt, test);\n\n\n    REQUIRE(v[0] == approx(v1, 1.e-6_f));\n    REQUIRE(v[1] == approx(v0, 1.e-6_f));\n}\n\nTEMPLATE_TEST_CASE(\"Collision merge two\", \"[nbody]\", EulerExplicit, LeapFrog) {\n    RunSettings settings;\n    settings.set(RunSettingsId::NBODY_INERTIA_TENSOR, true)\n        .set(RunSettingsId::COLLISION_HANDLER, CollisionHandlerEnum::PERFECT_MERGING)\n        .set(RunSettingsId::COLLISION_BOUNCE_MERGE_LIMIT, 0._f)\n        .set(RunSettingsId::COLLISION_ROTATION_MERGE_LIMIT, 0._f);\n\n    ThreadPool& pool = *ThreadPool::getGlobalInstance();\n    HardSphereSolver solver(pool, settings);\n\n    SharedPtr<Storage> storage = makeTwoParticles();\n    solver.create(*storage, storage->getMaterial(0));\n\n    const Float dt = 1.e-4_f;\n    ArrayView<const Vector> r, v, dv;\n    tie(r, v, dv) = storage->getAll<Vector>(QuantityId::POSITION);\n    ArrayView<const SymmetricTensor> I = storage->getValue<SymmetricTensor>(QuantityId::MOMENT_OF_INERTIA);\n    ArrayView<const Vector> w = storage->getValue<Vector>(QuantityId::ANGULAR_FREQUENCY);\n\n    const Float dist = getLength(r[0] - r[1]) - r[0][H] - r[1][H];\n    const Float v_rel = getLength(v[0] - v[1]);\n    const Float t_coll = dist / v_rel;\n    const Vector r0 = r[0];\n    const Vector r1 = r[1];\n    const Vector v0 = v[0];\n    const Vector v1 = v[1];\n    const Float I0 = I[0].trace() / 3._f;\n    const Float I1 = I[1].trace() / 3._f;\n\n    bool didMerge = false;\n    auto test = [&](Size i) -> Outcome {\n        const Float t = i * dt;\n\n        if (t < t_coll) {\n            if (storage->getParticleCnt() != 2) {\n                return makeFailed(\"Particle number changed before merge\");\n            }\n            if (r[0] != approx(r0 + v0 * t) || r[1] != approx(r1 + v1 * t)) {\n                return makeFailed(\"Incorrect positions\");\n            }\n            if (v[0] != approx(v0, 1.e-6_f) || v[1] != approx(v1, 1.e-6_f)) {\n\n                return makeFailed(\"Velocities changed before merge\\nt = {} (t_coll = {})\\n{} == {}\\n{} == {}\",\n                                  t, t_coll, v[0], v0, v[1], v1);\n\n            }\n            if (r[0][H] != r0[H] || r[1][H] != r1[H]) {\n                return makeFailed(\"Radius changed\");\n            }\n            if (I[0] != approx(SymmetricTensor::identity() * I0)) {\n                return makeFailed(\"Moment of inertia changed\\n{} == {}\", I[0], I0);\n            }\n            if (I[1] != approx(SymmetricTensor::identity() * I1)) {\n                return makeFailed(\"Moment of inertia changed\\n{} == {}\", I[1], I1);\n            }\n            if (w[0] != Vector(0._f) || w[1] != Vector(0._f)) {\n                return makeFailed(\"Angular velocity increased\");\n            }\n        } else {\n            if (!didMerge) {\n                tie(r, v, dv) = storage->getAll<Vector>(QuantityId::POSITION);\n                I = storage->getValue<SymmetricTensor>(QuantityId::MOMENT_OF_INERTIA);\n                w = storage->getValue<Vector>(QuantityId::ANGULAR_FREQUENCY);\n            }\n            didMerge = true;\n            if (storage->getParticleCnt() != 1) {\n                return makeFailed(\"Particle number incorrect\");\n            }\n            if (v[0] != approx(Vector(0._f), 1.e-6_f)) {\n\n                return makeFailed(\"Incorrect velocities after merge\\nt = {} (t_coll = {})\\n{} == 0.\",\n                                   t, t_coll, v[0]);\n\n            }\n            if (w[0] != Vector(0._f)) {\n                return makeFailed(\"Angular velocity increased after merge\");\n            }\n\n            if (I[0].offDiagonal() != Vector(0._f)) {\n                return makeFailed(\"Moment of inertia not diagonal after merge\");\n            }\n            if (I[0](1, 1) != I[0](2, 2)) {\n                return makeFailed(\"Moment of inertia not symmetric\");\n            }\n            if (3._f * I[0](0, 0) > I[0](1, 1)) {\n                return makeFailed(\"Loo high value of Ixx:\\n{} > {}\", I[0](0, 0), I[0](1, 1));\n            }\n        }\n        return SUCCESS;\n    };\n    integrate<TestType>(storage, solver, dt, test);\n\n    REQUIRE(didMerge);\n}\n\nTEMPLATE_TEST_CASE(\"Collision merge off-center\", \"[nbody]\", EulerExplicit, LeapFrog) {\n\n    RunSettings settings;\n    settings.set(RunSettingsId::COLLISION_HANDLER, CollisionHandlerEnum::PERFECT_MERGING)\n        .set(RunSettingsId::COLLISION_BOUNCE_MERGE_LIMIT, 0._f)\n        .set(RunSettingsId::COLLISION_ROTATION_MERGE_LIMIT, 0._f)\n        .set(RunSettingsId::NBODY_INERTIA_TENSOR, true);\n\n    ThreadPool& pool = *ThreadPool::getGlobalInstance();\n    HardSphereSolver solver(pool, settings);\n\n    SharedPtr<Storage> storage = makeTwoParticles();\n    solver.create(*storage, storage->getMaterial(0));\n\n    ArrayView<Vector> r, v, dv;\n    tie(r, v, dv) = storage->getAll<Vector>(QuantityId::POSITION);\n    r[0][Y] = r[0][H] + r[1][H] - 1.e-5_f;\n    const Float L0 = getLength(v[0] - v[1]) * r[0][Y];\n    Tensor E_prev = Tensor::null();\n\n    bool didMerge = false;\n    auto test = [&](Size) -> Outcome {\n        if (storage->getParticleCnt() == 2) {\n\n            return SUCCESS;\n        }\n        if (storage->getParticleCnt() != 1) {\n            return Outcome(false);\n        }\n        didMerge = true;\n        ArrayView<const Vector> w = storage->getValue<Vector>(QuantityId::ANGULAR_FREQUENCY);\n        ArrayView<const SymmetricTensor> I =\n            storage->getValue<SymmetricTensor>(QuantityId::MOMENT_OF_INERTIA);\n        ArrayView<const Tensor> E = storage->getValue<Tensor>(QuantityId::LOCAL_FRAME);\n\n        if (w[0] == approx(Vector(0._f), 0.5_f)) {\n            return makeFailed(\"No rotation after merge:\\n{}\", w[0]);\n        }\n        const Float L = getLength(I[0] * w[0]);\n        if (L != approx(L0, 1.e-6_f)) {\n            return makeFailed(\"Angular momentum not conserved:\\n{} == {}\", L, L0);\n        }\n        if (E[0] == approx(E_prev, 1.e-6_f)) {\n            return makeFailed(\"Local frame not changed:\\n{} == {}\", E[0], E_prev);\n        }\n        if (convert<AffineMatrix>(I[0]).isIsotropic()) {\n            return makeFailed(\"I should not be isotropic:\\n{}\", I[0]);\n        }\n        E_prev = E[0];\n        return SUCCESS;\n    };\n    integrate<TestType>(storage, solver, 1.e-4_f, test);\n\n    REQUIRE(didMerge);\n}\n\nTEMPLATE_TEST_CASE(\"Collision merge miss\", \"[nbody]\", EulerExplicit, LeapFrog) {\n    RunSettings settings;\n    settings.set(RunSettingsId::COLLISION_HANDLER, CollisionHandlerEnum::PERFECT_MERGING)\n        .set(RunSettingsId::COLLISION_BOUNCE_MERGE_LIMIT, 0._f)\n        .set(RunSettingsId::COLLISION_ROTATION_MERGE_LIMIT, 0._f)\n        .set(RunSettingsId::NBODY_INERTIA_TENSOR, true);\n\n    ThreadPool& pool = *ThreadPool::getGlobalInstance();\n    HardSphereSolver solver(pool, settings);\n\n    SharedPtr<Storage> storage = makeTwoParticles();\n    solver.create(*storage, storage->getMaterial(0));\n\n    ArrayView<Vector> r, v, dv;\n    tie(r, v, dv) = storage->getAll<Vector>(QuantityId::POSITION);\n    r[0][Y] = r[0][H] + r[1][H] + 1.e-5_f;\n\n    auto test = [&](Size) -> Outcome {\n        if (storage->getParticleCnt() != 2) {\n            return Outcome(false);\n        }\n        return SUCCESS;\n    };\n    integrate<TestType>(storage, solver, 1.e-4_f, test);\n}\n\nTEMPLATE_TEST_CASE(\"Collision merge rejection\", \"[nbody]\", EulerExplicit, LeapFrog) {\n    RunSettings settings;\n    settings.set(RunSettingsId::NBODY_INERTIA_TENSOR, true)\n        .set(RunSettingsId::COLLISION_HANDLER, CollisionHandlerEnum::MERGE_OR_BOUNCE)\n        .set(RunSettingsId::COLLISION_BOUNCE_MERGE_LIMIT, 1.e6_f);\n\n    ThreadPool& pool = *ThreadPool::getGlobalInstance();\n    HardSphereSolver solver(pool, settings);\n\n    SharedPtr<Storage> storage = makeTwoParticles();\n    solver.create(*storage, storage->getMaterial(0));\n\n    Array<Float> m0 = storage->getValue<Float>(QuantityId::MASS).clone();\n    Array<Vector> w0 = storage->getValue<Vector>(QuantityId::ANGULAR_FREQUENCY).clone();\n    Array<SymmetricTensor> I0 = storage->getValue<SymmetricTensor>(QuantityId::MOMENT_OF_INERTIA).clone();\n\n    auto test = [&](Size) -> Outcome { return SUCCESS; };\n    integrate<TestType>(storage, solver, 1.e-4_f, test);\n\n    Array<Float> m1 = storage->getValue<Float>(QuantityId::MASS).clone();\n    Array<Vector> w1 = storage->getValue<Vector>(QuantityId::ANGULAR_FREQUENCY).clone();\n    Array<SymmetricTensor> I1 = storage->getValue<SymmetricTensor>(QuantityId::MOMENT_OF_INERTIA).clone();\n\n\n    REQUIRE(m0 == m1);\n    REQUIRE(w0 == w1);\n    REQUIRE(I0 == I1);\n}\n\nTEST_CASE(\"Collision repel\", \"[nbody]\") {\n    Storage storage;\n\n    storage.insert<Vector>(QuantityId::POSITION,\n        OrderEnum::SECOND,\n        Array<Vector>{ Vector(0._f, 0._f, 0._f, 1._f), Vector(1._f, 0._f, 0._f, 0.25_f) });\n    storage.insert<Float>(QuantityId::MASS, OrderEnum::ZERO, Array<Float>{ 1._f, 0.1_f });\n\n    CenterOfMass com;\n    const Vector com1 = com.evaluate(storage);\n\n    RunSettings settings;\n    settings.set(RunSettingsId::COLLISION_RESTITUTION_NORMAL, 0._f);\n    settings.set(RunSettingsId::COLLISION_RESTITUTION_TANGENT, 0._f);\n    RepelHandler<ElasticBounceHandler> repel(settings);\n    repel.initialize(storage);\n    FlatSet<Size> dummy;\n    repel.handle(0, 1, dummy);\n    const Vector com2 = com.evaluate(storage);\n    REQUIRE(com1 == approx(com2));\n\n    ArrayView<Vector> r = storage.getValue<Vector>(QuantityId::POSITION);\n    REQUIRE(r[0][H] + r[1][H] == approx(getLength(r[0] - r[1])));\n\n    r[1] = Vector(10._f, 0._f, 0._f, 0.2_f);\n    repel.initialize(storage);\n    REQUIRE_SPH_ASSERT(repel.handle(0, 1, dummy));\n}\n\ntemplate <typename TTimestepping>\nstatic SharedPtr<Storage> runCloud(const RunSettings& settings, const Size particleCount) {\n    ThreadPool& pool = *ThreadPool::getGlobalInstance();\n    HardSphereSolver solver(pool, settings);\n\n    SharedPtr<Storage> storage = makeShared<Storage>(Tests::getStorage(particleCount));\n    solver.create(*storage, storage->getMaterial(0));\n\n    ArrayView<Vector> r, v, dv;\n    tie(r, v, dv) = storage->getAll<Vector>(QuantityId::POSITION);\n    for (Size i = 0; i < r.size(); ++i) {\n        r[i][H] = 0.01_f;\n        v[i] = -4._f * r[i];\n    }\n    integrate<TTimestepping>(storage, solver, 1.e-4_f, [](Size) -> Outcome { return SUCCESS; });\n\n    return storage;\n}\n\nTEMPLATE_TEST_CASE(\"Collision cloud merge\", \"[nbody]\", EulerExplicit, LeapFrog) {\n\n    RunSettings settings;\n    settings.set(RunSettingsId::NBODY_INERTIA_TENSOR, true)\n        .set(RunSettingsId::COLLISION_HANDLER, CollisionHandlerEnum::PERFECT_MERGING)\n        .set(RunSettingsId::COLLISION_OVERLAP, OverlapEnum::FORCE_MERGE)\n        .set(RunSettingsId::COLLISION_BOUNCE_MERGE_LIMIT, 0._f)\n        .set(RunSettingsId::COLLISION_ROTATION_MERGE_LIMIT, 0._f);\n    SharedPtr<Storage> storage = runCloud<TestType>(settings, 100);\n\n\n    REQUIRE(storage->getParticleCnt() == 1);\n}\n\nTEMPLATE_TEST_CASE(\"Collision cloud merge&bounce\", \"[nbody]\", EulerExplicit, LeapFrog) {\n\n\n    RunSettings settings;\n    settings.set(RunSettingsId::NBODY_INERTIA_TENSOR, true)\n        .set(RunSettingsId::COLLISION_HANDLER, CollisionHandlerEnum::MERGE_OR_BOUNCE)\n        .set(RunSettingsId::COLLISION_OVERLAP, OverlapEnum::REPEL)\n        .set(RunSettingsId::COLLISION_BOUNCE_MERGE_LIMIT, 0._f)\n        .set(RunSettingsId::COLLISION_ROTATION_MERGE_LIMIT, 0._f);\n    SharedPtr<Storage> storage = runCloud<TestType>(settings, 100);\n\n\n    REQUIRE(storage->getParticleCnt() > 1);\n    REQUIRE(storage->getParticleCnt() < 30);\n}\n\nTEMPLATE_TEST_CASE(\"Collision cloud bounce\", \"[nbody]\", EulerExplicit, LeapFrog) {\n\n\n    RunSettings settings;\n    settings.set(RunSettingsId::NBODY_INERTIA_TENSOR, true)\n        .set(RunSettingsId::COLLISION_HANDLER, CollisionHandlerEnum::ELASTIC_BOUNCE)\n        .set(RunSettingsId::COLLISION_OVERLAP, OverlapEnum::NONE);\n    ThreadPool& pool = *ThreadPool::getGlobalInstance();\n    HardSphereSolver solver(pool, settings);\n    REQUIRE_NOTHROW(runCloud<TestType>(settings, 50));\n}\n",
        "gt": [
            "'OpenSPH/core/common/Globals.h'",
            "'OpenSPH/test/utils/SequenceTest.h'",
            "'OpenSPH/core/gravity/test/NBodySolver.cpp'"
        ]
    },
    {
        "files": [
            "'beacon/third_party/hnsd/uv/src/win/internal.h'",
            "'beacon/third_party/hnsd/uv/src/win/req-inl.h'",
            "'beacon/third_party/hnsd/uv/src/win/winsock.h'",
            "'beacon/third_party/hnsd/uv/src/win/stream-inl.h'"
        ],
        "content": "'beacon/third_party/hnsd/uv/src/win/internal.h'\n:\n\n#ifndef UV_WIN_INTERNAL_H_\n#define UV_WIN_INTERNAL_H_\n\n#include \"uv.h\"\n#include \"../uv-common.h\"\n\n#include \"tree.h\"\n#include \"winapi.h\"\n#include \"winsock.h\"\n\n#ifdef _MSC_VER\n# define INLINE __inline\n# define UV_THREAD_LOCAL __declspec( thread )\n#else\n# define INLINE inline\n# define UV_THREAD_LOCAL __thread\n#endif\n\n\n#ifdef _DEBUG\n\nextern UV_THREAD_LOCAL int uv__crt_assert_enabled;\n\n#define UV_BEGIN_DISABLE_CRT_ASSERT()                           \\\n  {                                                             \\\n    int uv__saved_crt_assert_enabled = uv__crt_assert_enabled;  \\\n    uv__crt_assert_enabled = FALSE;\n\n\n#define UV_END_DISABLE_CRT_ASSERT()                             \\\n    uv__crt_assert_enabled = uv__saved_crt_assert_enabled;      \\\n  }\n\n#else\n#define UV_BEGIN_DISABLE_CRT_ASSERT()\n#define UV_END_DISABLE_CRT_ASSERT()\n#endif\n\n\n\n\n#define UV_HANDLE_CLOSED                        0x00000002\n#define UV_HANDLE_ENDGAME_QUEUED                0x00000008\n\n\n\n\n\n\n\n#define UV_HANDLE_READING                       0x00000100\n#define UV_HANDLE_BOUND                         0x00000200\n#define UV_HANDLE_LISTENING                     0x00000800\n#define UV_HANDLE_CONNECTION                    0x00001000\n#define UV_HANDLE_READABLE                      0x00008000\n#define UV_HANDLE_WRITABLE                      0x00010000\n#define UV_HANDLE_READ_PENDING                  0x00020000\n#define UV_HANDLE_SYNC_BYPASS_IOCP              0x00040000\n#define UV_HANDLE_ZERO_READ                     0x00080000\n#define UV_HANDLE_EMULATE_IOCP                  0x00100000\n#define UV_HANDLE_BLOCKING_WRITES               0x00200000\n#define UV_HANDLE_CANCELLATION_PENDING          0x00400000\n\n\n#define UV_HANDLE_IPV6                          0x01000000\n\n\n#define UV_HANDLE_TCP_NODELAY                   0x02000000\n#define UV_HANDLE_TCP_KEEPALIVE                 0x04000000\n#define UV_HANDLE_TCP_SINGLE_ACCEPT             0x08000000\n#define UV_HANDLE_TCP_ACCEPT_STATE_CHANGING     0x10000000\n#define UV_HANDLE_TCP_SOCKET_CLOSED             0x20000000\n#define UV_HANDLE_SHARED_TCP_SOCKET             0x40000000\n\n\n#define UV_HANDLE_NON_OVERLAPPED_PIPE           0x01000000\n#define UV_HANDLE_PIPESERVER                    0x02000000\n#define UV_HANDLE_PIPE_READ_CANCELABLE          0x04000000\n\n\n#define UV_HANDLE_TTY_READABLE                  0x01000000\n#define UV_HANDLE_TTY_RAW                       0x02000000\n#define UV_HANDLE_TTY_SAVED_POSITION            0x04000000\n#define UV_HANDLE_TTY_SAVED_ATTRIBUTES          0x08000000\n\n\n#define UV_HANDLE_POLL_SLOW                     0x02000000\n\n\n\n\n\n\n\n\n\n\ntypedef struct {\n  WSAPROTOCOL_INFOW socket_info;\n  int delayed_error;\n} uv__ipc_socket_info_ex;\n\nint uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb);\nint uv_tcp_accept(uv_tcp_t* server, uv_tcp_t* client);\nint uv_tcp_read_start(uv_tcp_t* handle, uv_alloc_cb alloc_cb,\n    uv_read_cb read_cb);\nint uv_tcp_write(uv_loop_t* loop, uv_write_t* req, uv_tcp_t* handle,\n    const uv_buf_t bufs[], unsigned int nbufs, uv_write_cb cb);\nint uv__tcp_try_write(uv_tcp_t* handle, const uv_buf_t bufs[],\n    unsigned int nbufs);\n\nvoid uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle, uv_req_t* req);\nvoid uv_process_tcp_write_req(uv_loop_t* loop, uv_tcp_t* handle,\n    uv_write_t* req);\nvoid uv_process_tcp_accept_req(uv_loop_t* loop, uv_tcp_t* handle,\n    uv_req_t* req);\nvoid uv_process_tcp_connect_req(uv_loop_t* loop, uv_tcp_t* handle,\n    uv_connect_t* req);\n\nvoid uv_tcp_close(uv_loop_t* loop, uv_tcp_t* tcp);\nvoid uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle);\n\nint uv_tcp_import(uv_tcp_t* tcp, uv__ipc_socket_info_ex* socket_info_ex,\n    int tcp_connection);\n\nint uv_tcp_duplicate_socket(uv_tcp_t* handle, int pid,\n    LPWSAPROTOCOL_INFOW protocol_info);\n\n\n\nvoid uv_process_udp_recv_req(uv_loop_t* loop, uv_udp_t* handle, uv_req_t* req);\nvoid uv_process_udp_send_req(uv_loop_t* loop, uv_udp_t* handle,\n    uv_udp_send_t* req);\n\nvoid uv_udp_close(uv_loop_t* loop, uv_udp_t* handle);\nvoid uv_udp_endgame(uv_loop_t* loop, uv_udp_t* handle);\n\n\n\nint uv_stdio_pipe_server(uv_loop_t* loop, uv_pipe_t* handle, DWORD access,\n    char* name, size_t nameSize);\n\nint uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb);\nint uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client);\nint uv_pipe_read_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,\n    uv_read_cb read_cb);\nint uv_pipe_write(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,\n    const uv_buf_t bufs[], unsigned int nbufs, uv_write_cb cb);\nint uv_pipe_write2(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,\n    const uv_buf_t bufs[], unsigned int nbufs, uv_stream_t* send_handle,\n    uv_write_cb cb);\nvoid uv__pipe_pause_read(uv_pipe_t* handle);\nvoid uv__pipe_unpause_read(uv_pipe_t* handle);\nvoid uv__pipe_stop_read(uv_pipe_t* handle);\n\nvoid uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,\n    uv_req_t* req);\nvoid uv_process_pipe_write_req(uv_loop_t* loop, uv_pipe_t* handle,\n    uv_write_t* req);\nvoid uv_process_pipe_accept_req(uv_loop_t* loop, uv_pipe_t* handle,\n    uv_req_t* raw_req);\nvoid uv_process_pipe_connect_req(uv_loop_t* loop, uv_pipe_t* handle,\n    uv_connect_t* req);\nvoid uv_process_pipe_shutdown_req(uv_loop_t* loop, uv_pipe_t* handle,\n    uv_shutdown_t* req);\n\nvoid uv_pipe_close(uv_loop_t* loop, uv_pipe_t* handle);\nvoid uv_pipe_cleanup(uv_loop_t* loop, uv_pipe_t* handle);\nvoid uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle);\n\n\n\nvoid uv_console_init(void);\n\nint uv_tty_read_start(uv_tty_t* handle, uv_alloc_cb alloc_cb,\n    uv_read_cb read_cb);\nint uv_tty_read_stop(uv_tty_t* handle);\nint uv_tty_write(uv_loop_t* loop, uv_write_t* req, uv_tty_t* handle,\n    const uv_buf_t bufs[], unsigned int nbufs, uv_write_cb cb);\nint uv__tty_try_write(uv_tty_t* handle, const uv_buf_t bufs[],\n    unsigned int nbufs);\nvoid uv_tty_close(uv_tty_t* handle);\n\nvoid uv_process_tty_read_req(uv_loop_t* loop, uv_tty_t* handle,\n    uv_req_t* req);\nvoid uv_process_tty_write_req(uv_loop_t* loop, uv_tty_t* handle,\n    uv_write_t* req);\n\nvoid uv_process_tty_accept_req(uv_loop_t* loop, uv_tty_t* handle,\n    uv_req_t* raw_req);\n\nvoid uv_process_tty_connect_req(uv_loop_t* loop, uv_tty_t* handle,\n    uv_connect_t* req);\n\nvoid uv_tty_endgame(uv_loop_t* loop, uv_tty_t* handle);\n\n\n\nvoid uv_process_poll_req(uv_loop_t* loop, uv_poll_t* handle,\n    uv_req_t* req);\n\nint uv_poll_close(uv_loop_t* loop, uv_poll_t* handle);\nvoid uv_poll_endgame(uv_loop_t* loop, uv_poll_t* handle);\n\n\n\nvoid uv_timer_endgame(uv_loop_t* loop, uv_timer_t* handle);\n\nDWORD uv__next_timeout(const uv_loop_t* loop);\nvoid uv_process_timers(uv_loop_t* loop);\n\n\n\nvoid uv_loop_watcher_endgame(uv_loop_t* loop, uv_handle_t* handle);\n\nvoid uv_prepare_invoke(uv_loop_t* loop);\nvoid uv_check_invoke(uv_loop_t* loop);\nvoid uv_idle_invoke(uv_loop_t* loop);\n\nvoid uv__once_init(void);\n\n\n\nvoid uv_async_close(uv_loop_t* loop, uv_async_t* handle);\nvoid uv_async_endgame(uv_loop_t* loop, uv_async_t* handle);\n\nvoid uv_process_async_wakeup_req(uv_loop_t* loop, uv_async_t* handle,\n    uv_req_t* req);\n\n\n\nvoid uv_signals_init(void);\nint uv__signal_dispatch(int signum);\n\nvoid uv_signal_close(uv_loop_t* loop, uv_signal_t* handle);\nvoid uv_signal_endgame(uv_loop_t* loop, uv_signal_t* handle);\n\nvoid uv_process_signal_req(uv_loop_t* loop, uv_signal_t* handle,\n    uv_req_t* req);\n\n\n\nvoid uv_process_proc_exit(uv_loop_t* loop, uv_process_t* handle);\nvoid uv_process_close(uv_loop_t* loop, uv_process_t* handle);\nvoid uv_process_endgame(uv_loop_t* loop, uv_process_t* handle);\n\n\n\nint uv_translate_sys_error(int sys_errno);\n\n\n\nvoid uv_fs_init(void);\n\n\n\nvoid uv_process_fs_event_req(uv_loop_t* loop, uv_req_t* req,\n    uv_fs_event_t* handle);\nvoid uv_fs_event_close(uv_loop_t* loop, uv_fs_event_t* handle);\nvoid uv_fs_event_endgame(uv_loop_t* loop, uv_fs_event_t* handle);\n\n\n\nvoid uv__fs_poll_endgame(uv_loop_t* loop, uv_fs_poll_t* handle);\n\n\n\nvoid uv__util_init(void);\n\nuint64_t uv__hrtime(double scale);\nint uv_current_pid(void);\n__declspec(noreturn) void uv_fatal_error(const int errorno, const char* syscall);\nint uv__getpwuid_r(uv_passwd_t* pwd);\nint uv__convert_utf16_to_utf8(const WCHAR* utf16, int utf16len, char** utf8);\nint uv__convert_utf8_to_utf16(const char* utf8, int utf8len, WCHAR** utf16);\n\n\n\nint uv__stdio_create(uv_loop_t* loop,\n                     const uv_process_options_t* options,\n                     BYTE** buffer_ptr);\nvoid uv__stdio_destroy(BYTE* buffer);\nvoid uv__stdio_noinherit(BYTE* buffer);\nint uv__stdio_verify(BYTE* buffer, WORD size);\nWORD uv__stdio_size(BYTE* buffer);\nHANDLE uv__stdio_handle(BYTE* buffer, int fd);\n\n\n\nvoid uv_winapi_init(void);\n\n\n\nvoid uv_winsock_init(void);\n\nint uv_ntstatus_to_winsock_error(NTSTATUS status);\n\nBOOL uv_get_acceptex_function(SOCKET socket, LPFN_ACCEPTEX* target);\nBOOL uv_get_connectex_function(SOCKET socket, LPFN_CONNECTEX* target);\n\nint WSAAPI uv_wsarecv_workaround(SOCKET socket, WSABUF* buffers,\n    DWORD buffer_count, DWORD* bytes, DWORD* flags, WSAOVERLAPPED *overlapped,\n    LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\nint WSAAPI uv_wsarecvfrom_workaround(SOCKET socket, WSABUF* buffers,\n    DWORD buffer_count, DWORD* bytes, DWORD* flags, struct sockaddr* addr,\n    int* addr_len, WSAOVERLAPPED *overlapped,\n    LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\n\nint WSAAPI uv_msafd_poll(SOCKET socket, AFD_POLL_INFO* info_in,\n    AFD_POLL_INFO* info_out, OVERLAPPED* overlapped);\n\n\nextern int uv_tcp_non_ifs_lsp_ipv4;\nextern int uv_tcp_non_ifs_lsp_ipv6;\n\n\nextern struct sockaddr_in uv_addr_ip4_any_;\nextern struct sockaddr_in6 uv_addr_ip6_any_;\n\n\nvoid uv__wake_all_loops(void);\n\n\nvoid uv__init_detect_system_wakeup(void);\n\n#endif\n\n'beacon/third_party/hnsd/uv/src/win/req-inl.h'\n:\n\n#ifndef UV_WIN_REQ_INL_H_\n#define UV_WIN_REQ_INL_H_\n\n#include <assert.h>\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n\n#define SET_REQ_STATUS(req, status)                                     \\\n   (req)->u.io.overlapped.Internal = (ULONG_PTR) (status)\n\n#define SET_REQ_ERROR(req, error)                                       \\\n  SET_REQ_STATUS((req), NTSTATUS_FROM_WIN32((error)))\n\n\n#define SET_REQ_SUCCESS(req)                                            \\\n  SET_REQ_STATUS((req), STATUS_SUCCESS)\n\n#define GET_REQ_STATUS(req)                                             \\\n  ((NTSTATUS) (req)->u.io.overlapped.Internal)\n\n#define REQ_SUCCESS(req)                                                \\\n  (NT_SUCCESS(GET_REQ_STATUS((req))))\n\n#define GET_REQ_ERROR(req)                                              \\\n  (pRtlNtStatusToDosError(GET_REQ_STATUS((req))))\n\n#define GET_REQ_SOCK_ERROR(req)                                         \\\n  (uv_ntstatus_to_winsock_error(GET_REQ_STATUS((req))))\n\n\n#define REGISTER_HANDLE_REQ(loop, handle, req)                          \\\n  do {                                                                  \\\n    INCREASE_ACTIVE_COUNT((loop), (handle));                            \\\n    uv__req_register((loop), (req));                                    \\\n  } while (0)\n\n#define UNREGISTER_HANDLE_REQ(loop, handle, req)                        \\\n  do {                                                                  \\\n    DECREASE_ACTIVE_COUNT((loop), (handle));                            \\\n    uv__req_unregister((loop), (req));                                  \\\n  } while (0)\n\n\n#define UV_SUCCEEDED_WITHOUT_IOCP(result)                               \\\n  ((result) && (handle->flags & UV_HANDLE_SYNC_BYPASS_IOCP))\n\n#define UV_SUCCEEDED_WITH_IOCP(result)                                  \\\n  ((result) || (GetLastError() == ERROR_IO_PENDING))\n\n\n#define POST_COMPLETION_FOR_REQ(loop, req)                              \\\n  if (!PostQueuedCompletionStatus((loop)->iocp,                         \\\n                                  0,                                    \\\n                                  0,                                    \\\n                                  &((req)->u.io.overlapped))) {         \\\n    uv_fatal_error(GetLastError(), \"PostQueuedCompletionStatus\");       \\\n  }\n\n\nINLINE static uv_req_t* uv_overlapped_to_req(OVERLAPPED* overlapped) {\n  return CONTAINING_RECORD(overlapped, uv_req_t, u.io.overlapped);\n}\n\n\nINLINE static void uv_insert_pending_req(uv_loop_t* loop, uv_req_t* req) {\n  req->next_req = NULL;\n  if (loop->pending_reqs_tail) {\n#ifdef _DEBUG\n\n    uv_req_t* current = loop->pending_reqs_tail;\n    do {\n      assert(req != current);\n      current = current->next_req;\n    } while(current != loop->pending_reqs_tail);\n#endif\n\n    req->next_req = loop->pending_reqs_tail->next_req;\n    loop->pending_reqs_tail->next_req = req;\n    loop->pending_reqs_tail = req;\n  } else {\n    req->next_req = req;\n    loop->pending_reqs_tail = req;\n  }\n}\n\n\n#define DELEGATE_STREAM_REQ(loop, req, method, handle_at)                     \\\n  do {                                                                        \\\n    switch (((uv_handle_t*) (req)->handle_at)->type) {                        \\\n      case UV_TCP:                                                            \\\n        uv_process_tcp_##method##_req(loop,                                   \\\n                                      (uv_tcp_t*) ((req)->handle_at),         \\\n                                      req);                                   \\\n        break;                                                                \\\n                                                                              \\\n      case UV_NAMED_PIPE:                                                     \\\n        uv_process_pipe_##method##_req(loop,                                  \\\n                                       (uv_pipe_t*) ((req)->handle_at),       \\\n                                       req);                                  \\\n        break;                                                                \\\n                                                                              \\\n      case UV_TTY:                                                            \\\n        uv_process_tty_##method##_req(loop,                                   \\\n                                      (uv_tty_t*) ((req)->handle_at),         \\\n                                      req);                                   \\\n        break;                                                                \\\n                                                                              \\\n      default:                                                                \\\n        assert(0);                                                            \\\n    }                                                                         \\\n  } while (0)\n\n\nINLINE static int uv_process_reqs(uv_loop_t* loop) {\n  uv_req_t* req;\n  uv_req_t* first;\n  uv_req_t* next;\n\n  if (loop->pending_reqs_tail == NULL)\n    return 0;\n\n  first = loop->pending_reqs_tail->next_req;\n  next = first;\n  loop->pending_reqs_tail = NULL;\n\n  while (next != NULL) {\n    req = next;\n    next = req->next_req != first ? req->next_req : NULL;\n\n    switch (req->type) {\n      case UV_READ:\n        DELEGATE_STREAM_REQ(loop, req, read, data);\n        break;\n\n      case UV_WRITE:\n        DELEGATE_STREAM_REQ(loop, (uv_write_t*) req, write, handle);\n        break;\n\n      case UV_ACCEPT:\n        DELEGATE_STREAM_REQ(loop, req, accept, data);\n        break;\n\n      case UV_CONNECT:\n        DELEGATE_STREAM_REQ(loop, (uv_connect_t*) req, connect, handle);\n        break;\n\n      case UV_SHUTDOWN:\n\n        assert(((uv_shutdown_t*) req)->handle->type == UV_NAMED_PIPE);\n        uv_process_pipe_shutdown_req(\n            loop,\n            (uv_pipe_t*) ((uv_shutdown_t*) req)->handle,\n            (uv_shutdown_t*) req);\n        break;\n\n      case UV_UDP_RECV:\n        uv_process_udp_recv_req(loop, (uv_udp_t*) req->data, req);\n        break;\n\n      case UV_UDP_SEND:\n        uv_process_udp_send_req(loop,\n                                ((uv_udp_send_t*) req)->handle,\n                                (uv_udp_send_t*) req);\n        break;\n\n      case UV_WAKEUP:\n        uv_process_async_wakeup_req(loop, (uv_async_t*) req->data, req);\n        break;\n\n      case UV_SIGNAL_REQ:\n        uv_process_signal_req(loop, (uv_signal_t*) req->data, req);\n        break;\n\n      case UV_POLL_REQ:\n        uv_process_poll_req(loop, (uv_poll_t*) req->data, req);\n        break;\n\n      case UV_PROCESS_EXIT:\n        uv_process_proc_exit(loop, (uv_process_t*) req->data);\n        break;\n\n      case UV_FS_EVENT_REQ:\n        uv_process_fs_event_req(loop, req, (uv_fs_event_t*) req->data);\n        break;\n\n      default:\n        assert(0);\n    }\n  }\n\n  return 1;\n}\n\n#endif\n\n'beacon/third_party/hnsd/uv/src/win/winsock.h'\n:\n\n#ifndef UV_WIN_WINSOCK_H_\n#define UV_WIN_WINSOCK_H_\n\n#include <winsock2.h>\n#include <iptypes.h>\n#include <mswsock.h>\n#include <ws2tcpip.h>\n#include <windows.h>\n\n#include \"winapi.h\"\n\n\n\n#ifndef SO_UPDATE_CONNECT_CONTEXT\n# define SO_UPDATE_CONNECT_CONTEXT 0x7010\n#endif\n\n#ifndef TCP_KEEPALIVE\n# define TCP_KEEPALIVE 3\n#endif\n\n#ifndef IPV6_V6ONLY\n# define IPV6_V6ONLY 27\n#endif\n\n#ifndef IPV6_HOPLIMIT\n# define IPV6_HOPLIMIT 21\n#endif\n\n#ifndef SIO_BASE_HANDLE\n# define SIO_BASE_HANDLE 0x48000022\n#endif\n\n\n#ifndef TDI_RECEIVE_NORMAL\n  #define TDI_RECEIVE_BROADCAST           0x00000004\n  #define TDI_RECEIVE_MULTICAST           0x00000008\n  #define TDI_RECEIVE_PARTIAL             0x00000010\n  #define TDI_RECEIVE_NORMAL              0x00000020\n  #define TDI_RECEIVE_EXPEDITED           0x00000040\n  #define TDI_RECEIVE_PEEK                0x00000080\n  #define TDI_RECEIVE_NO_RESPONSE_EXP     0x00000100\n  #define TDI_RECEIVE_COPY_LOOKAHEAD      0x00000200\n  #define TDI_RECEIVE_ENTIRE_MESSAGE      0x00000400\n  #define TDI_RECEIVE_AT_DISPATCH_LEVEL   0x00000800\n  #define TDI_RECEIVE_CONTROL_INFO        0x00001000\n  #define TDI_RECEIVE_FORCE_INDICATION    0x00002000\n  #define TDI_RECEIVE_NO_PUSH             0x00004000\n#endif\n\n\n\n#define AFD_NO_FAST_IO   0x00000001\n#define AFD_OVERLAPPED   0x00000002\n#define AFD_IMMEDIATE    0x00000004\n\n#define AFD_POLL_RECEIVE_BIT            0\n#define AFD_POLL_RECEIVE                (1 << AFD_POLL_RECEIVE_BIT)\n#define AFD_POLL_RECEIVE_EXPEDITED_BIT  1\n#define AFD_POLL_RECEIVE_EXPEDITED      (1 << AFD_POLL_RECEIVE_EXPEDITED_BIT)\n#define AFD_POLL_SEND_BIT               2\n#define AFD_POLL_SEND                   (1 << AFD_POLL_SEND_BIT)\n#define AFD_POLL_DISCONNECT_BIT         3\n#define AFD_POLL_DISCONNECT             (1 << AFD_POLL_DISCONNECT_BIT)\n#define AFD_POLL_ABORT_BIT              4\n#define AFD_POLL_ABORT                  (1 << AFD_POLL_ABORT_BIT)\n#define AFD_POLL_LOCAL_CLOSE_BIT        5\n#define AFD_POLL_LOCAL_CLOSE            (1 << AFD_POLL_LOCAL_CLOSE_BIT)\n#define AFD_POLL_CONNECT_BIT            6\n#define AFD_POLL_CONNECT                (1 << AFD_POLL_CONNECT_BIT)\n#define AFD_POLL_ACCEPT_BIT             7\n#define AFD_POLL_ACCEPT                 (1 << AFD_POLL_ACCEPT_BIT)\n#define AFD_POLL_CONNECT_FAIL_BIT       8\n#define AFD_POLL_CONNECT_FAIL           (1 << AFD_POLL_CONNECT_FAIL_BIT)\n#define AFD_POLL_QOS_BIT                9\n#define AFD_POLL_QOS                    (1 << AFD_POLL_QOS_BIT)\n#define AFD_POLL_GROUP_QOS_BIT          10\n#define AFD_POLL_GROUP_QOS              (1 << AFD_POLL_GROUP_QOS_BIT)\n\n#define AFD_NUM_POLL_EVENTS             11\n#define AFD_POLL_ALL                    ((1 << AFD_NUM_POLL_EVENTS) - 1)\n\ntypedef struct _AFD_RECV_DATAGRAM_INFO {\n    LPWSABUF BufferArray;\n    ULONG BufferCount;\n    ULONG AfdFlags;\n    ULONG TdiFlags;\n    struct sockaddr* Address;\n    int* AddressLength;\n} AFD_RECV_DATAGRAM_INFO, *PAFD_RECV_DATAGRAM_INFO;\n\ntypedef struct _AFD_RECV_INFO {\n    LPWSABUF BufferArray;\n    ULONG BufferCount;\n    ULONG AfdFlags;\n    ULONG TdiFlags;\n} AFD_RECV_INFO, *PAFD_RECV_INFO;\n\n\n#define _AFD_CONTROL_CODE(operation, method) \\\n    ((FSCTL_AFD_BASE) << 12 | (operation << 2) | method)\n\n#define FSCTL_AFD_BASE FILE_DEVICE_NETWORK\n\n#define AFD_RECEIVE            5\n#define AFD_RECEIVE_DATAGRAM   6\n#define AFD_POLL               9\n\n#define IOCTL_AFD_RECEIVE \\\n    _AFD_CONTROL_CODE(AFD_RECEIVE, METHOD_NEITHER)\n\n#define IOCTL_AFD_RECEIVE_DATAGRAM \\\n    _AFD_CONTROL_CODE(AFD_RECEIVE_DATAGRAM, METHOD_NEITHER)\n\n#define IOCTL_AFD_POLL \\\n    _AFD_CONTROL_CODE(AFD_POLL, METHOD_BUFFERED)\n\n#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)\ntypedef struct _IP_ADAPTER_UNICAST_ADDRESS_XP {\n\n   union {\n    ULONGLONG Alignment;\n     struct {\n      ULONG Length;\n      DWORD Flags;\n    };\n  };\n  struct _IP_ADAPTER_UNICAST_ADDRESS_XP *Next;\n  SOCKET_ADDRESS Address;\n  IP_PREFIX_ORIGIN PrefixOrigin;\n  IP_SUFFIX_ORIGIN SuffixOrigin;\n  IP_DAD_STATE DadState;\n  ULONG ValidLifetime;\n  ULONG PreferredLifetime;\n  ULONG LeaseLifetime;\n} IP_ADAPTER_UNICAST_ADDRESS_XP,*PIP_ADAPTER_UNICAST_ADDRESS_XP;\n\ntypedef struct _IP_ADAPTER_UNICAST_ADDRESS_LH {\n  union {\n    ULONGLONG Alignment;\n    struct {\n      ULONG Length;\n      DWORD Flags;\n    };\n  };\n  struct _IP_ADAPTER_UNICAST_ADDRESS_LH *Next;\n  SOCKET_ADDRESS Address;\n  IP_PREFIX_ORIGIN PrefixOrigin;\n  IP_SUFFIX_ORIGIN SuffixOrigin;\n  IP_DAD_STATE DadState;\n  ULONG ValidLifetime;\n  ULONG PreferredLifetime;\n  ULONG LeaseLifetime;\n  UINT8 OnLinkPrefixLength;\n} IP_ADAPTER_UNICAST_ADDRESS_LH,*PIP_ADAPTER_UNICAST_ADDRESS_LH;\n\n#endif\n\nint uv__convert_to_localhost_if_unspecified(const struct sockaddr* addr,\n                                            struct sockaddr_storage* storage);\n\n#endif\n\n'beacon/third_party/hnsd/uv/src/win/stream-inl.h'\n:\n\n#ifndef UV_WIN_STREAM_INL_H_\n#define UV_WIN_STREAM_INL_H_\n\n#include <assert.h>\n\n#include \"uv.h\"\n#include \"internal.h\"\n#include \"handle-inl.h\"\n#include \"req-inl.h\"\n\n\nINLINE static void uv_stream_init(uv_loop_t* loop,\n                                  uv_stream_t* handle,\n                                  uv_handle_type type) {\n  uv__handle_init(loop, (uv_handle_t*) handle, type);\n  handle->write_queue_size = 0;\n  handle->activecnt = 0;\n  handle->stream.conn.shutdown_req = NULL;\n}\n\n\nINLINE static void uv_connection_init(uv_stream_t* handle) {\n  handle->flags |= UV_HANDLE_CONNECTION;\n  handle->stream.conn.write_reqs_pending = 0;\n\n  UV_REQ_INIT(&handle->read_req, UV_READ);\n  handle->read_req.event_handle = NULL;\n  handle->read_req.wait_handle = INVALID_HANDLE_VALUE;\n  handle->read_req.data = handle;\n}\n\n\n#endif\n",
        "gt": [
            "'beacon/third_party/hnsd/uv/src/win/winsock.h'",
            "'beacon/third_party/hnsd/uv/src/win/internal.h'",
            "'beacon/third_party/hnsd/uv/src/win/req-inl.h'",
            "'beacon/third_party/hnsd/uv/src/win/stream-inl.h'"
        ]
    },
    {
        "files": [
            "'OpenStudioApplication/src/shared_gui_components/OSListView.hpp'",
            "'OpenStudioApplication/src/shared_gui_components/WorkflowController.hpp'",
            "'OpenStudioApplication/src/shared_gui_components/EditController.cpp'",
            "'OpenStudioApplication/src/shared_gui_components/OSListController.hpp'"
        ],
        "content": "'OpenStudioApplication/src/shared_gui_components/OSListView.hpp'\n:\n\n#ifndef SHAREDGUICOMPONENTS_OSLISTVIEW_HPP\n#define SHAREDGUICOMPONENTS_OSLISTVIEW_HPP\n\n#include \"OSListController.hpp\"\n#include <QWidget>\n#include <QSharedPointer>\n#include <map>\n#include <openstudio/utilities/core/Logger.hpp>\n\nclass QScrollArea;\nclass QVBoxLayout;\nclass QGraphicsObject;\n\nnamespace openstudio {\n\nclass OSListItem;\nclass OSItemDelegate;\n\n\nclass OSListView : public QWidget\n{\n  Q_OBJECT\n\n public:\n  explicit OSListView(bool scrollable = false, QWidget* parent = nullptr);\n\n  virtual ~OSListView();\n\n  void setDelegate(QSharedPointer<OSItemDelegate> delegate);\n\n  void setListController(QSharedPointer<OSListController> listController);\n\n  QSharedPointer<OSListController> listController() const;\n\n  void setSpacing(int spacing);\n\n  void setContentsMargins(int left, int top, int right, int bottom);\n\n  void setHorizontalScrollBarAlwaysOn(bool alwaysOn);\n\n  void setVerticalScrollBarAlwaysOn(bool alwaysOn);\n\n public slots:\n\n  void refreshAllViews();\n\n protected:\n  void paintEvent(QPaintEvent*) override;\n\n private slots:\n\n  void insertItemView(int i);\n\n  void removeItemView(int i);\n\n  void removePair(QObject* object);\n\n  void refreshItemView(int i);\n\n private:\n  QSharedPointer<OSItemDelegate> m_delegate;\n\n  QSharedPointer<OSListController> m_listController;\n\n  QVBoxLayout* m_mainVLayout;\n\n\n  std::map<QObject*, QSharedPointer<OSListItem>> m_widgetItemPairs;\n\n  bool m_scrollable;\n\n  QScrollArea* m_scrollArea;\n\n  REGISTER_LOGGER(\"openstudio.shared_gui_components.OSListView\");\n};\n\n}\n\n#endif\n\n'OpenStudioApplication/src/shared_gui_components/WorkflowController.hpp'\n:\n\n#ifndef SHAREDGUICOMPONENTS_WORKFLOWCONTROLLER_HPP\n#define SHAREDGUICOMPONENTS_WORKFLOWCONTROLLER_HPP\n\n#include \"OSListController.hpp\"\n#include \"OSListView.hpp\"\n#include \"BaseApp.hpp\"\n#include <openstudio/utilities/bcl/BCLMeasure.hpp>\n#include <openstudio/utilities/core/Logger.hpp>\n#include <openstudio/utilities/filetypes/WorkflowStep.hpp>\n#include <QObject>\n#include <QSharedPointer>\n#include <map>\n\nnamespace openstudio {\n\nnamespace measuretab {\n\nclass WorkflowSectionItem;\nclass WorkflowStepController;\nclass MeasureStepItem;\nclass MeasureStepController;\n\n}\n\nnamespace measure {\n\nclass OSArgument;\n\n}\n\nnamespace measuretab {\n\n\n\n\n\nclass WorkflowController : public OSListController\n{\n  Q_OBJECT\n\n public:\n  explicit WorkflowController(BaseApp* t_baseApp);\n\n  QSharedPointer<OSListItem> itemAt(int i) override;\n\n  int count() override;\n\n private:\n  void addItem(QSharedPointer<OSListItem> item);\n\n  std::vector<QSharedPointer<WorkflowSectionItem>> m_workflowSectionItems;\n};\n\n\nclass WorkflowSectionItemDelegate : public OSItemDelegate\n{\n  Q_OBJECT\n\n public:\n  explicit WorkflowSectionItemDelegate();\n\n  QWidget* view(QSharedPointer<OSListItem> dataSource) override;\n\n private:\n};\n\n\n\nclass WorkflowSectionItem : public OSListItem\n{\n  Q_OBJECT\n\n public:\n  WorkflowSectionItem(const MeasureType& measureType, const QString& label, BaseApp* t_baseApp);\n\n  QString label() const;\n\n  boost::optional<MeasureType> measureType() const;\n\n  QSharedPointer<WorkflowStepController> workflowStepController() const;\n\n private:\n  QString m_label;\n  boost::optional<MeasureType> m_measureType;\n\n  QSharedPointer<WorkflowStepController> m_workflowStepController;\n};\n\n\nclass WorkflowStepController : public OSListController\n{\n  Q_OBJECT\n\n public:\n  explicit WorkflowStepController(BaseApp* t_baseApp);\n};\n\n\nclass MeasureStepController : public WorkflowStepController\n{\n  Q_OBJECT\n\n public:\n  MeasureStepController(MeasureType measureType, BaseApp* t_baseApp);\n\n  QSharedPointer<OSListItem> itemAt(int i) override;\n\n  int count() override;\n\n  MeasureType measureType() const;\n  MeasureLanguage measureLanguage() const;\n\n  std::vector<MeasureStep> measureSteps() const;\n\n  void removeItemForStep(MeasureStep step);\n\n  void moveUp(MeasureStep step);\n\n  void moveDown(MeasureStep step);\n\n public slots:\n\n  void addItemForDroppedMeasure(QDropEvent* event);\n\n private:\n  void addItem(QSharedPointer<OSListItem> item);\n\n  MeasureType m_measureType;\n  MeasureLanguage m_measureLanguage;\n\n  BaseApp* m_app;\n\n  std::vector<QSharedPointer<MeasureStepItem>> m_measureStepItems;\n};\n\n\nclass MeasureStepItemDelegate : public OSItemDelegate\n{\n  Q_OBJECT\n\n public:\n  explicit MeasureStepItemDelegate();\n\n  QWidget* view(QSharedPointer<OSListItem> dataSource) override;\n\n private:\n};\n\n\nclass MeasureStepItem : public OSListItem\n{\n  Q_OBJECT\n\n public:\n  MeasureStepItem(MeasureType measureType, MeasureStep step, BaseApp* t_baseApp);\n\n  QString name() const;\n\n\n\n  MeasureType measureType() const;\n\n  MeasureLanguage measureLanguage() const;\n\n  MeasureStep measureStep() const;\n\n  QString description() const;\n\n  QString modelerDescription() const;\n\n  QString scriptFileName() const;\n\n  OptionalBCLMeasure bclMeasure() const;\n\n\n  std::vector<measure::OSArgument> arguments() const;\n\n  bool hasIncompleteArguments() const;\n\n  std::vector<measure::OSArgument> incompleteArguments() const;\n\n public slots:\n\n  void remove();\n\n  void moveUp();\n\n  void moveDown();\n\n  void setName(const QString& name);\n\n\n\n  void setDescription(const QString& description);\n\n  void setArgument(const measure::OSArgument& argument);\n\n  void setSelected(bool isSelected) override;\n\n signals:\n\n  void nameChanged(const QString& name);\n\n\n\n  void descriptionChanged();\n\n  void argumentsChanged(bool isIncomplete);\n\n private:\n  MeasureType m_measureType;\n  MeasureLanguage m_measureLanguage;\n  MeasureStep m_step;\n  BaseApp* m_app;\n};\n\n}\n\n}\n\n#endif\n\n'OpenStudioApplication/src/shared_gui_components/EditController.cpp'\n:\n\n#include \"EditController.hpp\"\n#include \"EditView.hpp\"\n#include \"OSViewSwitcher.hpp\"\n#include \"WorkflowController.hpp\"\n\n#include <openstudio/utilities/bcl/BCLMeasure.hpp>\n#include <openstudio/utilities/core/Assert.hpp>\n\n#include <QWidget>\n#include <QLineEdit>\n#include <QLabel>\n#include <QTextEdit>\n#include <QComboBox>\n#include <QCheckBox>\n#include <QMessageBox>\n\nnamespace openstudio {\n\nEditController::EditController(bool applyMeasureNow) : editView(new OSViewSwitcher()) {\n  if (applyMeasureNow) {\n    m_editNullView = new EditNullView(\"Select a Measure to Apply\");\n  } else {\n    m_editNullView = new EditNullView();\n  }\n  editRubyMeasureView = new EditRubyMeasureView(applyMeasureNow);\n\n  reset();\n}\n\nEditController::~EditController() {\n  delete editView;\n  delete m_editNullView;\n  delete editRubyMeasureView;\n}\n\nvoid EditController::setMeasureStepItem(measuretab::MeasureStepItem* measureStepItem, BaseApp* t_app) {\n  m_measureStepItem = measureStepItem;\n\n  editRubyMeasureView->clear();\n\n  editView->setView(editRubyMeasureView);\n\n\n\n  editRubyMeasureView->nameLineEdit->setText(m_measureStepItem->name());\n\n  connect(editRubyMeasureView->nameLineEdit, &QLineEdit::textEdited, m_measureStepItem.data(), &measuretab::MeasureStepItem::setName);\n\n\n\n  editRubyMeasureView->descriptionTextEdit->setText(m_measureStepItem->description());\n\n  connect(editRubyMeasureView->descriptionTextEdit, &QTextEdit::textChanged, this, &EditController::updateDescription);\n\n\n\n  editRubyMeasureView->modelerDescriptionTextEdit->setText(m_measureStepItem->modelerDescription());\n\n\n  try {\n    std::vector<measure::OSArgument> arguments = m_measureStepItem->arguments();\n\n    for (const auto& arg : arguments) {\n      QSharedPointer<InputController> inputController = QSharedPointer<InputController>(new InputController(this, arg, t_app));\n\n      m_inputControllers.push_back(inputController);\n\n      editRubyMeasureView->addInputView(inputController->inputView);\n    }\n  } catch (const std::exception& e) {\n    QTextEdit* error = new QTextEdit(e.what());\n    error->setReadOnly(true);\n    error->setWordWrapMode(QTextOption::WrapAtWordBoundaryOrAnywhere);\n    editRubyMeasureView->addInputView(error);\n  }\n}\n\nmeasuretab::MeasureStepItem* EditController::measureStepItem() const {\n  return m_measureStepItem;\n}\n\nvoid EditController::updateDescription() {\n  m_measureStepItem->setDescription(editRubyMeasureView->descriptionTextEdit->toPlainText());\n}\n\nvoid EditController::reset() {\n\n  editView->setView(m_editNullView);\n\n  m_inputControllers.clear();\n\n  m_measureStepItem = nullptr;\n\n  if (editRubyMeasureView != nullptr) {\n    editRubyMeasureView->nameLineEdit->disconnect();\n    editRubyMeasureView->descriptionTextEdit->disconnect();\n  }\n}\n\nclass EditMeasureMessageBox : public QMessageBox\n{\n  Q_OBJECT\n\n public:\n\n\n  static bool warning(BaseApp* t_app) {\n    int result = QMessageBox::warning(t_app->mainWidget(), \"Clear Results?\",\n                                      \"Editing this measure will clear all results and save your project. Do you want to proceed?\", QMessageBox::Ok,\n                                      QMessageBox::Cancel);\n\n    return (result == QMessageBox::Ok);\n  }\n};\n\nInputController::InputController(EditController* editController, measure::OSArgument argument, BaseApp* t_app)\n  : m_app(t_app), m_editController(editController), m_argument(std::move(argument)) {\n  if (m_argument.type() == measure::OSArgumentType::Double) {\n    auto* doubleInputView = new DoubleInputView();\n\n    doubleInputView->setName(m_argument.displayName(), m_argument.units(), m_argument.description());\n\n    if (m_argument.hasValue()) {\n      doubleInputView->lineEdit->setText(QString::fromStdString(m_argument.valueAsString()));\n    } else if (m_argument.hasDefaultValue()) {\n      doubleInputView->lineEdit->setText(QString::fromStdString(m_argument.defaultValueAsString()));\n    }\n\n    connect(doubleInputView->lineEdit, &QLineEdit::textEdited, this,\n            static_cast<void (InputController::*)(const QString&)>(&InputController::setValue));\n\n    inputView = doubleInputView;\n  } else if (m_argument.type() == measure::OSArgumentType::Choice) {\n    auto* choiceInputView = new ChoiceInputView();\n\n    choiceInputView->setName(m_argument.displayName(), m_argument.units(), m_argument.description());\n\n\n\n    const std::vector<std::string>& choices = m_argument.choiceValueDisplayNames();\n    const std::vector<std::string>& values = m_argument.choiceValues();\n\n    int i = 0;\n    for (const auto& choice : choices) {\n      choiceInputView->comboBox->addItem(QString::fromStdString(choice), QString::fromStdString(values[i]));\n\n      i++;\n    }\n\n\n\n    if (!m_argument.hasDefaultValue()) {\n      choiceInputView->comboBox->insertItem(0, \"\");\n    } else {\n      int index = choiceInputView->comboBox->findData(QString::fromStdString(m_argument.defaultValueAsString()));\n\n      if (index == -1) {\n        index = choiceInputView->comboBox->findText(QString::fromStdString(m_argument.defaultValueAsString()));\n      }\n\n      if (index == -1) {\n\n        choiceInputView->comboBox->insertItem(0, \"\");\n      }\n    }\n\n\n    if (m_argument.hasValue()) {\n      int index = choiceInputView->comboBox->findData(QString::fromStdString(m_argument.valueAsString()));\n\n      if (index == -1) {\n        index = choiceInputView->comboBox->findText(QString::fromStdString(m_argument.valueAsString()));\n      }\n\n      if (index != -1) {\n        choiceInputView->comboBox->setCurrentIndex(index);\n      } else {\n\n        choiceInputView->comboBox->setCurrentIndex(0);\n      }\n    } else if (m_argument.hasDefaultValue()) {\n      int index = choiceInputView->comboBox->findData(QString::fromStdString(m_argument.defaultValueAsString()));\n\n      if (index == -1) {\n        index = choiceInputView->comboBox->findText(QString::fromStdString(m_argument.defaultValueAsString()));\n      }\n\n      if (index != -1) {\n        choiceInputView->comboBox->setCurrentIndex(index);\n      } else {\n\n        choiceInputView->comboBox->setCurrentIndex(0);\n      }\n    } else {\n      choiceInputView->comboBox->setCurrentIndex(0);\n    }\n\n    connect(choiceInputView->comboBox, static_cast<void (QComboBox::*)(int)>(&QComboBox::currentIndexChanged), this,\n            &InputController::setValueForIndex);\n\n    inputView = choiceInputView;\n  } else if (m_argument.type() == measure::OSArgumentType::Boolean) {\n    auto* boolInputView = new BoolInputView();\n\n    boolInputView->setName(m_argument.displayName(), m_argument.units(), m_argument.description());\n\n    if (m_argument.hasValue()) {\n      boolInputView->checkBox->setChecked(m_argument.valueAsBool());\n    } else if (m_argument.hasDefaultValue()) {\n      boolInputView->checkBox->setChecked(m_argument.defaultValueAsBool());\n    } else {\n      boolInputView->checkBox->setChecked(false);\n      m_argument.setValue(false);\n    }\n\n    connect(boolInputView->checkBox, &InputCheckBox::clicked, this, static_cast<void (InputController::*)(bool)>(&InputController::setValue));\n\n    inputView = boolInputView;\n  } else if (m_argument.type() == measure::OSArgumentType::Integer) {\n    auto* integerInputView = new IntegerInputView();\n\n    integerInputView->setName(m_argument.displayName(), m_argument.units(), m_argument.description());\n\n    if (m_argument.hasValue()) {\n      integerInputView->lineEdit->setText(QString::fromStdString(m_argument.valueAsString()));\n    } else if (m_argument.hasDefaultValue()) {\n      integerInputView->lineEdit->setText(QString::fromStdString(m_argument.defaultValueAsString()));\n    }\n\n    connect(integerInputView->lineEdit, &QLineEdit::textEdited, this,\n            static_cast<void (InputController::*)(const QString&)>(&InputController::setValue));\n\n    inputView = integerInputView;\n  } else if (m_argument.type() == measure::OSArgumentType::String) {\n    auto* stringInputView = new StringInputView();\n\n    stringInputView->setName(m_argument.displayName(), m_argument.units(), m_argument.description());\n\n    if (m_argument.hasValue()) {\n      stringInputView->lineEdit->setText(QString::fromStdString(m_argument.valueAsString()));\n    } else if (m_argument.hasDefaultValue()) {\n      stringInputView->lineEdit->setText(QString::fromStdString(m_argument.defaultValueAsString()));\n    }\n\n    connect(stringInputView->lineEdit, &QLineEdit::textEdited, this,\n            static_cast<void (InputController::*)(const QString&)>(&InputController::setValue));\n\n    inputView = stringInputView;\n  } else {\n    inputView = new InputView();\n  }\n\n  inputView->setIncomplete(isArgumentIncomplete());\n}\n\nInputController::~InputController() {\n  delete inputView;\n}\n\nvoid InputController::setValue(const QString& text) {\n  if (isItOKToClearResults()) {\n    if (text.isEmpty()) {\n      m_argument.clearValue();\n    } else {\n      m_argument.setValue(text.toStdString());\n    }\n\n    m_editController->measureStepItem()->setArgument(m_argument);\n\n    inputView->setIncomplete(isArgumentIncomplete());\n  }\n}\n\nvoid InputController::setValue(bool value) {\n  if (isItOKToClearResults()) {\n    m_argument.setValue(value);\n\n    m_editController->measureStepItem()->setArgument(m_argument);\n\n    inputView->setIncomplete(isArgumentIncomplete());\n  }\n}\n\nvoid InputController::setValueForIndex(int index) {\n  if (isItOKToClearResults()) {\n    QString value = qobject_cast<ChoiceInputView*>(inputView)->comboBox->itemData(index).toString();\n\n    if (value.isEmpty()) {\n      m_argument.clearValue();\n    } else {\n      m_argument.setValue(value.toStdString());\n    }\n\n    m_editController->measureStepItem()->setArgument(m_argument);\n\n    inputView->setIncomplete(isArgumentIncomplete());\n  }\n}\n\nbool InputController::isArgumentIncomplete() const {\n  bool result = false;\n  std::vector<measure::OSArgument> incompleteArguments = m_editController->measureStepItem()->incompleteArguments();\n  for (const auto& incompleteArgument : incompleteArguments) {\n    if (incompleteArgument.name() == m_argument.name()) {\n      result = true;\n    }\n  }\n  return result;\n}\n\nbool InputController::isItOKToClearResults() {\n\n  return true;\n}\n\n}\n\n'OpenStudioApplication/src/shared_gui_components/OSListController.hpp'\n:\n\n#ifndef SHAREDGUICOMPONENTS_OSLISTCONTROLLER_HPP\n#define SHAREDGUICOMPONENTS_OSLISTCONTROLLER_HPP\n\n#include <QObject>\n#include <QSharedPointer>\n#include <QPointer>\n#include <openstudio/nano/nano_signal_slot.hpp>\n#include <vector>\n\nclass QWidget;\nclass QGraphicsObject;\n\nnamespace openstudio {\n\nclass OSListItem;\nclass OSItemSelectionController;\n\n\nclass OSListController\n  : public QObject\n  , public Nano::Observer\n{\n  Q_OBJECT\n\n public:\n  OSListController();\n\n  virtual ~OSListController();\n\n  virtual QSharedPointer<OSListItem> itemAt(int i) = 0;\n\n  virtual int count() = 0;\n\n\n\n\n  QSharedPointer<OSItemSelectionController> selectionController() const;\n\n  void setSelectionController(QSharedPointer<OSItemSelectionController> controller);\n\n signals:\n\n\n  void itemInserted(int index);\n\n\n  void itemRemoved(int index);\n\n\n\n  void itemChanged(int index);\n\n\n\n  void modelReset();\n\n private:\n  friend class OSListItem;\n  friend class OSItemSelectionController;\n\n\n\n\n\n\n  void registerItem(QPointer<OSListItem> item);\n\n  void unregisterItem(QPointer<OSListItem> item);\n\n  QSharedPointer<OSItemSelectionController> m_selectionController;\n\n  std::vector<QPointer<OSListItem>> m_registeredItems;\n};\n\n\nclass OSListItem : public QObject\n{\n  Q_OBJECT\n\n public:\n  explicit OSListItem(OSListController* listController = nullptr);\n\n  virtual ~OSListItem();\n\n  void setController(OSListController* controller);\n\n  OSListController* controller() const {\n    return m_listController.get();\n  }\n\n  bool isSelected() const;\n\n public slots:\n\n  virtual void setSelected(bool isSelected);\n\n  void toggleSelected();\n\n signals:\n\n  void selectedChanged(bool isSelected);\n\n protected:\n  QPointer<OSListController> m_listController;\n};\n\n\n\nclass OSItemSelectionController\n  : public QObject\n  , public Nano::Observer\n{\n  Q_OBJECT\n\n public:\n  OSItemSelectionController();\n\n  virtual ~OSItemSelectionController() {}\n\n  void setAllowMultipleSelections(bool multipleSelections);\n\n  bool allowMultipleSelections() const;\n\n  std::vector<QPointer<OSListItem>> selectedItems() const;\n\n public slots:\n\n  void unselectAllItems();\n\n  void selectAllItems();\n\n  void emitSelectionChanged();\n\n signals:\n\n  void selectionChanged(std::vector<QPointer<OSListItem>> selectedItems);\n\n private:\n  friend class OSListItem;\n  friend class OSListController;\n\n\n  void registerListController(OSListController* listController);\n\n  void unregisterListController(OSListController* listController);\n\n\n\n\n\n  void addSelectedItem(OSListItem* item);\n\n\n  void removeSelectedItem(OSListItem* item);\n\n  std::vector<QPointer<OSListItem>> m_selectedItems;\n\n\n\n  std::vector<QPointer<OSListController>> m_listControllers;\n\n  bool m_allowMultipleSelections;\n};\n\n\nclass OSItemDelegate\n  : public QObject\n  , public Nano::Observer\n{\n  Q_OBJECT\n\n public:\n  virtual ~OSItemDelegate() {}\n\n  virtual QWidget* view(QSharedPointer<OSListItem> dataSource);\n};\n\n\nclass OSGraphicsItemDelegate\n  : public QObject\n  , public Nano::Observer\n{\n  Q_OBJECT;\n\n public:\n  virtual ~OSGraphicsItemDelegate() {}\n\n  virtual QGraphicsObject* view(QSharedPointer<OSListItem> dataSource);\n};\n\n}\n\n#endif\n",
        "gt": [
            "'OpenStudioApplication/src/shared_gui_components/OSListController.hpp'",
            "'OpenStudioApplication/src/shared_gui_components/OSListView.hpp'",
            "'OpenStudioApplication/src/shared_gui_components/WorkflowController.hpp'",
            "'OpenStudioApplication/src/shared_gui_components/EditController.cpp'"
        ]
    },
    {
        "files": [
            "'pinba2/src/report_snapshot.cpp'",
            "'pinba2/include/pinba/hdr_histogram.h'",
            "'pinba2/include/pinba/histogram.h'"
        ],
        "content": "'pinba2/src/report_snapshot.cpp'\n:#include \"pinba/globals.h\"\n#include \"pinba/packet.h\"\n#include \"pinba/histogram.h\"\n#include \"pinba/report.h\"\n#include \"pinba/report_util.h\"\n#include \"pinba/report_by_packet.h\"\n#include \"pinba/report_by_request.h\"\n#include \"pinba/report_by_timer.h\"\n\n\n\ntemplate<class T>\ninline double operator/(T const& value, duration_t d)\n{\n\treturn ((double)value / d.nsec) * nsec_in_sec;\n}\n\nvoid debug_dump_report_snapshot(FILE *sink, report_snapshot_t *snapshot, str_ref name)\n{\n\tauto const write_hv = [&](report_snapshot_t::position_t const& pos)\n\t{\n\t\tff::fmt(sink, \" [\");\n\t\tauto const *histogram = snapshot->get_histogram(pos);\n\t\tif (histogram != nullptr)\n\t\t{\n\n\n\n\n\n\n\n\n\n\n\n\t\t\tif (HISTOGRAM_KIND__FLAT == snapshot->histogram_kind())\n\t\t\t{\n\t\t\t\tauto const *hv = static_cast<flat_histogram_t const*>(histogram);\n\n\t\t\t\tauto const& hvalues = hv->values;\n\t\t\t\tfor (auto it = hvalues.begin(), it_end = hvalues.end(); it != it_end; ++it)\n\t\t\t\t{\n\t\t\t\t\tff::fmt(sink, \"{0}{1}: {2}\", (hvalues.begin() == it)?\"\":\", \", it->bucket_id, it->value);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (HISTOGRAM_KIND__HDR == snapshot->histogram_kind())\n\t\t\t{\n\t\t\t\tauto const *hv = static_cast<hdr_histogram_t const*>(histogram);\n\t\t\t\tbool printed_something = false;\n\n\t\t\t\tfor (uint32_t i = 0; i < hv->counts_len(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (hv->count_at_index(i) == 0)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tff::fmt(sink, \"{0}{1}: {2}\", (printed_something)?\", \":\"\", hv->value_at_index(i), hv->count_at_index(i));\n\t\t\t\t\tprinted_something = true;\n\t\t\t\t}\n\n\t\t\t\tif (hv->negative_inf() > 0)\n\t\t\t\t{\n\t\t\t\t\tff::fmt(sink, \"{0}min:{1}\", (printed_something)?\", \":\"\", hv->negative_inf());\n\t\t\t\t\tprinted_something = true;\n\t\t\t\t}\n\n\t\t\t\tif (hv->positive_inf() > 0)\n\t\t\t\t{\n\t\t\t\t\tff::fmt(sink, \"{0}max:{1}\", (printed_something)?\", \":\"\", hv->positive_inf());\n\t\t\t\t\tprinted_something = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tff::fmt(sink, \"]\");\n\t};\n\n\tff::fmt(sink, \">-------------- {0} ------->>\\n\", name);\n\n\tfor (auto pos = snapshot->pos_first(), end = snapshot->pos_last(); !snapshot->pos_equal(pos, end); pos = snapshot->pos_next(pos))\n\t{\n\t\tauto const key = snapshot->get_key(pos);\n\t\tff::fmt(sink, \"[{0}] -> \", report_key_to_string(key, snapshot->dictionary()));\n\n\t\tauto const data_kind = snapshot->data_kind();\n\n\t\tswitch (data_kind)\n\t\t{\n\t\tcase REPORT_KIND__BY_PACKET_DATA:\n\t\t{\n\t\t\tauto const *rinfo = snapshot->report_info();\n\t\t\tauto const *data  = reinterpret_cast<report_row_data___by_packet_t*>(snapshot->get_data(pos));\n\n\t\t\tff::fmt(sink, \"{{ {0}, {1}, {2}, {3}, {4}, {5}, {6} }\",\n\t\t\t\tdata->req_count, data->timer_count, data->time_total, data->ru_utime, data->ru_stime,\n\t\t\t\tdata->traffic, data->mem_used);\n\n\t\t\tauto const time_window = rinfo->time_window;\n\t\t\tff::fmt(sink, \" {{ rps: {0} }\",\n\t\t\t\tff::as_printf(\"%.06lf\", data->req_count / time_window));\n\n\t\t\twrite_hv(pos);\n\t\t}\n\t\tbreak;\n\n\t\tcase REPORT_KIND__BY_REQUEST_DATA:\n\t\t{\n\t\t\tauto const *rinfo = snapshot->report_info();\n\t\t\tauto const *data  = reinterpret_cast<report_row_data___by_request_t*>(snapshot->get_data(pos));\n\n\t\t\tff::fmt(sink, \"{{ {0}, {1}, {2}, {3}, {4}, {5} }\",\n\t\t\t\tdata->req_count, data->time_total, data->ru_utime, data->ru_stime,\n\t\t\t\tdata->traffic, data->mem_used);\n\n\t\t\tauto const time_window = rinfo->time_window;\n\t\t\tff::fmt(sink, \" {{ rps: {0} }\",\n\t\t\t\tff::as_printf(\"%.06lf\", data->req_count / time_window));\n\n\t\t\twrite_hv(pos);\n\t\t}\n\t\tbreak;\n\n\t\tcase REPORT_KIND__BY_TIMER_DATA:\n\t\t{\n\t\t\tauto const *rinfo = snapshot->report_info();\n\t\t\tauto const *data  = reinterpret_cast<report_row_data___by_timer_t*>(snapshot->get_data(pos));\n\n\t\t\tff::fmt(sink, \"{{ {0}, {1}, {2}, {3}, {4} }\",\n\t\t\t\tdata->req_count, data->hit_count, data->time_total, data->ru_utime, data->ru_stime);\n\n\t\t\tauto const time_window = rinfo->time_window;\n\t\t\tff::fmt(sink, \" {{ rps: {0}, tps: {1} }\",\n\t\t\t\tff::as_printf(\"%.06lf\", data->req_count / time_window),\n\t\t\t\tff::as_printf(\"%.06lf\", data->hit_count / time_window));\n\n\t\t\twrite_hv(pos);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tff::fmt(sink, \"unknown report snapshot data_kind(): {0}\", data_kind);\n\t\t\tbreak;\n\t\t}\n\n\t\tff::fmt(sink, \"\\n\");\n\t}\n\n\tff::fmt(sink, \"<<-----------------------<\\n\");\n\tff::fmt(sink, \"\\n\");\n}\n'pinba2/include/pinba/hdr_histogram.h'\n:#ifndef PINBA__HDR_HISTOGRAM_H_\n#define PINBA__HDR_HISTOGRAM_H_\n\n#include <cstdint>\n#include <cmath>\n#include <memory>\n#include <type_traits>\n\n#include <boost/noncopyable.hpp>\n\n#include <meow/error.hpp>\n#include <meow/str_ref.hpp>\n#include <meow/format/format.hpp>\n\n#include \"misc/nmpa.h\"\n\n#include \"pinba/globals.h\"\n#include \"pinba/limits.h\"\n\n\n\nstruct hdr_histogram_conf_t\n{\n\n\tuint16_t sub_bucket_count;\n\tuint16_t sub_bucket_half_count;\n\tuint16_t sub_bucket_mask;\n\tuint8_t unit_magnitude;\n\tuint8_t sub_bucket_half_count_magnitude;\n\n\n\tint64_t lowest_trackable_value;\n\tint64_t highest_trackable_value;\n\tint64_t significant_bits;\n\tint32_t bucket_count;\n\tint32_t counts_len;\n};\n\nstatic inline int32_t hdr___buckets_needed_to_cover_value(int64_t value, int32_t sub_bucket_count, int32_t unit_magnitude)\n{\n\tint64_t smallest_untrackable_value = ((int64_t) sub_bucket_count) << unit_magnitude;\n\tint32_t buckets_needed = 1;\n\twhile (smallest_untrackable_value <= value)\n\t{\n\t\tif (smallest_untrackable_value > INT64_MAX / 2)\n\t\t{\n\t\t\treturn buckets_needed + 1;\n\t\t}\n\t\tsmallest_untrackable_value <<= 1;\n\t\tbuckets_needed++;\n\t}\n\n\treturn buckets_needed;\n}\n\nstatic inline int64_t hdr___int_power(int64_t base, int64_t exp)\n{\n\tint64_t result = 1;\n\twhile(exp)\n\t{\n\t\tresult *= base;\n\t\texp--;\n\t}\n\treturn result;\n};\n\ninline meow::error_t hdr_histogram_configure(\n\t\thdr_histogram_conf_t *cfg,\n\t\tint64_t lowest_trackable_value,\n\t\tint64_t highest_trackable_value,\n\t\tint significant_bits)\n{\n\tif (lowest_trackable_value <= 0)\n\t{\n\t\treturn meow::format::fmt_err(\"lowest_trackable_value must be > 0, {0} given\", lowest_trackable_value);\n\t}\n\n\tif (lowest_trackable_value * 2 > highest_trackable_value)\n\t{\n\t\treturn meow::format::fmt_err(\"lowest_trackable_value * 2 must be <= highest_trackable_value, {0}*2 > {1}\",\n\t\t\tlowest_trackable_value, highest_trackable_value);\n\t}\n\n\tif (significant_bits < 1 || significant_bits > 14)\n\t{\n\t\treturn meow::format::fmt_err(\"significant_bits must be in range [1, 14], {0} given\", significant_bits);\n\t}\n\n\tcfg->lowest_trackable_value = lowest_trackable_value;\n\tcfg->significant_bits = significant_bits;\n\tcfg->highest_trackable_value = highest_trackable_value;\n\n\tint64_t const largest_value_with_single_unit_resolution = 2 * (1 << significant_bits);\n\n\tint32_t const sub_bucket_count_magnitude = (int32_t) ceil(log((double)largest_value_with_single_unit_resolution) / log(2));\n\tassert(sub_bucket_count_magnitude < UINT8_MAX);\n\tcfg->sub_bucket_half_count_magnitude = (uint8_t)((sub_bucket_count_magnitude > 1) ? sub_bucket_count_magnitude : 1) - 1;\n\n\tint64_t const unit_magnitude = (int32_t) floor(log((double)lowest_trackable_value) / log(2));\n\tassert(unit_magnitude < UINT8_MAX);\n\tcfg->unit_magnitude = (uint8_t)unit_magnitude;\n\n\tint32_t const sub_bucket_count      = (int32_t) pow(2, (cfg->sub_bucket_half_count_magnitude + 1));\n\tassert(sub_bucket_count < UINT16_MAX);\n\tcfg->sub_bucket_count = (uint16_t)sub_bucket_count;\n\tcfg->sub_bucket_half_count = cfg->sub_bucket_count / 2;\n\tcfg->sub_bucket_mask       = ((int16_t) cfg->sub_bucket_count - 1) << cfg->unit_magnitude;\n\n\n\tcfg->bucket_count = hdr___buckets_needed_to_cover_value(highest_trackable_value, cfg->sub_bucket_count, (int32_t)cfg->unit_magnitude);\n\tcfg->counts_len = (cfg->bucket_count + 1) * (cfg->sub_bucket_count / 2);\n\n\treturn {};\n}\n\ninline meow::error_t hdr_histogram_configure___sig_figures(\n\t\thdr_histogram_conf_t* cfg,\n\t\tint64_t lowest_trackable_value,\n\t\tint64_t highest_trackable_value,\n\t\tint significant_figures)\n{\n\n\tint const sig_bits = 64 - __builtin_clzll(hdr___int_power(10, significant_figures));\n\treturn hdr_histogram_configure(cfg, lowest_trackable_value, highest_trackable_value, sig_bits);\n}\n\n\n\ntemplate<class CounterT>\nstruct hdr_histogram___impl_t : private boost::noncopyable\n{\n\tusing self_t    = hdr_histogram___impl_t;\n\tusing counter_t = CounterT;\n\tusing config_t  = hdr_histogram_conf_t;\n\n\tstatic_assert(std::is_integral<counter_t>::value, \"T must be an integral type\");\n\npublic:\n\n\thdr_histogram___impl_t(struct nmpa_s *nmpa, config_t const& conf)\n\t{\n\t\tnmpa_                           = nmpa;\n\n\t\tnegative_inf_                   = 0;\n\t\tpositive_inf_                   = 0;\n\t\ttotal_count_                    = 0;\n\t\tcounts_nonzero_                 = 0;\n\t\tcounts_maxlen_                  = conf.counts_len;\n\n\t\tsub_bucket_count                = conf.sub_bucket_count;\n\t\tsub_bucket_half_count           = conf.sub_bucket_half_count;\n\t\tsub_bucket_mask                 = conf.sub_bucket_mask;\n\t\tunit_magnitude                  = conf.unit_magnitude;\n\t\tsub_bucket_half_count_magnitude = conf.sub_bucket_half_count_magnitude;\n\n\n\t\tcounts_len_                     = conf.sub_bucket_half_count;\n\t\tcounts_ = (counter_t*)nmpa_calloc(nmpa_, counts_len_ * sizeof(counter_t));\n\t\tif (counts_ == nullptr)\n\t\t\tthrow std::bad_alloc();\n\t}\n\n\t~hdr_histogram___impl_t()\n\t{\n\n\n\t}\n\n\n\thdr_histogram___impl_t(hdr_histogram___impl_t const& other) = delete;\n\thdr_histogram___impl_t& operator=(hdr_histogram___impl_t const& other) = delete;\n\n\n\n\thdr_histogram___impl_t(hdr_histogram___impl_t&& other) noexcept\n\t{\n\t\t(*this) = std::move(other);\n\t}\n\n\thdr_histogram___impl_t& operator=(hdr_histogram___impl_t&& other) noexcept\n\t{\n\t\tnmpa_                           = other.nmpa;\n\n\t\tnegative_inf_                   = other.negative_inf_;\n\t\tpositive_inf_                   = other.positive_inf_;\n\t\ttotal_count_                    = other.total_count_;\n\t\tcounts_nonzero_                 = other.counts_nonzero_;\n\t\tcounts_len_                     = other.counts_len_;\n\t\tcounts_maxlen_                  = other.counts_maxlen_;\n\n\t\tsub_bucket_count                = other.sub_bucket_count;\n\t\tsub_bucket_half_count           = other.sub_bucket_half_count;\n\t\tsub_bucket_mask                 = other.sub_bucket_mask;\n\t\tunit_magnitude                  = other.unit_magnitude;\n\t\tsub_bucket_half_count_magnitude = other.sub_bucket_half_count_magnitude;\n\n\t\tcounts_ = other.counts_;\n\t\tother.counts_ = nullptr;\n\n\t\treturn *this;\n\t}\n\npublic:\n\n\tcounter_t negative_inf() const noexcept { return negative_inf_; }\n\tcounter_t positive_inf() const noexcept { return positive_inf_; }\n\tuint64_t  total_count() const noexcept { return total_count_; }\n\tuint32_t  counts_nonzero() const noexcept { return counts_nonzero_; }\n\tuint32_t  counts_len() const noexcept { return counts_len_; }\n\n\tusing counts_range_t    = meow::string_ref<counter_t const>;\n\tusing counts_range_nc_t = meow::string_ref<counter_t>;\n\n\tcounts_range_t get_counts_range() const\n\t{\n\t\treturn { this->counts_, this->counts_len_ };\n\t}\n\n\tcounts_range_nc_t mutable_counts_range()\n\t{\n\t\treturn { this->counts_, this->counts_len_ };\n\t}\n\n\tuint64_t get_allocated_size() const\n\t{\n\t\treturn sizeof(counter_t) * this->counts_len_;\n\t}\n\npublic:\n\n\tbool increment(config_t const& conf, int64_t value, counter_t increment_by = 1) noexcept\n\t{\n\n\n\n\n\n\n\n\n\n\n\t\tif (__builtin_expect(value < conf.lowest_trackable_value, 0))\n\t\t{\n\t\t\tthis->negative_inf_ += increment_by;\n\t\t}\n\t\telse if (__builtin_expect(value > conf.highest_trackable_value, 0))\n\t\t{\n\t\t\tthis->positive_inf_ += increment_by;\n\t\t}\n\t\telse {\n\t\t\tint32_t const counts_index = counts_index_for(value);\n\n\n\t\t\tif ((uint32_t)counts_index >= counts_len_)\n\t\t\t{\n\t\t\t\tcounter_t *tmp = (counter_t*)nmpa_realloc(nmpa_, counts_, counts_len_ * sizeof(counter_t), counts_maxlen_ * sizeof(counter_t));\n\t\t\t\tif (tmp == nullptr)\n\t\t\t\t{\n\n\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tstd::uninitialized_fill(tmp + counts_len_, tmp + counts_maxlen_, 0);\n\t\t\t\tcounts_len_ = counts_maxlen_;\n\t\t\t\tcounts_ = tmp;\n\t\t\t}\n\n\t\t\tcounter_t& counter = this->counts_[counts_index];\n\n\t\t\tcounts_nonzero_ += (counter == 0);\n\t\t\tcounter         += increment_by;\n\t\t}\n\n\t\tthis->total_count_ += increment_by;\n\t\treturn true;\n\t}\n\n\tvoid merge_other_with_same_conf(self_t const& other, config_t const& conf)\n\t{\n\t\tassert(this->counts_maxlen_ == other.counts_maxlen_);\n\n\t\tif (this->counts_len_ < other.counts_len_)\n\t\t{\n\t\t\tcounter_t *tmp = (counter_t*)nmpa_realloc(nmpa_, counts_, counts_len_ * sizeof(counter_t), counts_maxlen_ * sizeof(counter_t));\n\t\t\tif (tmp == nullptr)\n\t\t\t\tthrow std::bad_alloc();\n\n\t\t\tstd::uninitialized_fill(tmp + counts_len_, tmp + counts_maxlen_, 0);\n\t\t\tcounts_len_ = counts_maxlen_;\n\t\t\tcounts_ = tmp;\n\t\t}\n\n\t\tfor (uint32_t i = 0; i < other.counts_len_; i++)\n\t\t{\n\t\t\tcounter_t&       dst_counter = this->counts_[i];\n\t\t\tcounter_t const& src_counter = other.counts_[i];\n\n\t\t\tif ((dst_counter == 0) && (src_counter != 0))\n\t\t\t\tthis->counts_nonzero_ += 1;\n\n\t\t\tdst_counter += src_counter;\n\t\t}\n\n\t\tthis->negative_inf_ += other.negative_inf_;\n\t\tthis->positive_inf_ += other.positive_inf_;\n\t\tthis->total_count_ += other.total_count_;\n\t}\n\npublic:\n\n\tinline int64_t get_percentile(config_t const& conf, double percentile) const\n\t{\n\t\tif (percentile == 0.)\n\t\t\treturn conf.lowest_trackable_value;\n\n\t\tif (this->total_count() == 0)\n\t\t\treturn conf.lowest_trackable_value;\n\n\t\tuint64_t required_sum = [&]()\n\t\t{\n\t\t\tuint64_t const res = std::ceil(this->total_count() * percentile / 100.0);\n\t\t\tuint64_t const total = (uint64_t)this->total_count();\n\t\t\treturn (res > total) ? total : res;\n\t\t}();\n\n\n\n\n\n\t\tif (required_sum <= (uint64_t)this->negative_inf())\n\t\t\treturn conf.lowest_trackable_value;\n\n\n\t\tif (required_sum > (uint64_t)(this->total_count() - this->positive_inf()))\n\t\t\treturn conf.highest_trackable_value;\n\n\n\t\trequired_sum -= this->negative_inf();\n\n\n\n\t\tuint64_t current_sum = 0;\n\n\t\tauto const counts_r = this->get_counts_range();\n\n\t\tfor (uint32_t i = 0; i < counts_r.size(); i++)\n\t\t{\n\t\t\tuint32_t const bucket_id       = i;\n\t\t\tuint64_t const next_has_values = counts_r[i];\n\t\t\tuint64_t const need_values     = required_sum - current_sum;\n\n\t\t\tif (next_has_values < need_values)\n\t\t\t{\n\t\t\t\tcurrent_sum += next_has_values;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (next_has_values == need_values)\n\t\t\t{\n\n\t\t\t\tint64_t const result = this->highest_equivalent_value(this->value_at_index(bucket_id));\n\t\t\t\treturn (result < conf.highest_trackable_value)\n\t\t\t\t\t\t? result\n\t\t\t\t\t\t: conf.highest_trackable_value;\n\t\t\t}\n\n\n\t\t\t{\n\t\t\t\tint64_t const d = this->size_of_equivalent_value_range(bucket_id) * need_values / next_has_values;\n\n\n\t\t\t\tint64_t const result = this->lowest_equivalent_value(this->value_at_index(bucket_id)) + d;\n\t\t\t\treturn (result < conf.highest_trackable_value)\n\t\t\t\t\t\t? result\n\t\t\t\t\t\t: conf.highest_trackable_value;\n\t\t\t}\n\t\t}\n\n\n\t\t{\n\t\t\tmeow::format::fmt(stderr, \"{0} internal failure, dumping histogram\\n\", __func__);\n\t\t\tmeow::format::fmt(stderr, \"{0} neg_inf: {1}, pos_inf: {2}, total_count: {3}, hv_size: {4}\\n\",\n\t\t\t\t__func__, this->negative_inf(), this->positive_inf(), this->total_count(), this->counts_len_);\n\n\t\t\tfor (uint32_t i = 0; i < counts_r.size(); i++)\n\t\t\t\tmeow::format::fmt(stderr, \"[{0}] -> {1}\\n\", this->value_at_index(i), this->count_at_index(i));\n\t\t}\n\n\t\tassert(!\"must not be reached\");\n\t}\n\npublic:\n\n\tinline counter_t count_at_index(int32_t index) const\n\t{\n\t\treturn this->counts_[index];\n\t}\n\n\tinline int64_t value_at_index(int32_t index) const\n\t{\n\t\tint32_t bucket_index = (index >> this->sub_bucket_half_count_magnitude) - 1;\n\t\tint32_t sub_bucket_index = (index & (this->sub_bucket_half_count - 1)) + this->sub_bucket_half_count;\n\n\t\tif (bucket_index < 0)\n\t\t{\n\t\t\tsub_bucket_index -= this->sub_bucket_half_count;\n\t\t\tbucket_index = 0;\n\t\t}\n\n\t\treturn value_from_index(bucket_index, sub_bucket_index, this->unit_magnitude);\n\t}\n\n\tinline int64_t size_of_equivalent_value_range(int64_t value) const\n\t{\n\t\tint32_t const bucket_index     = get_bucket_index(value);\n\t\tint32_t const sub_bucket_index = get_sub_bucket_index(value, bucket_index, this->unit_magnitude);\n\t\tint32_t const adjusted_bucket  = (sub_bucket_index >= this->sub_bucket_count) ? (bucket_index + 1) : bucket_index;\n\t\treturn int64_t(1) << (this->unit_magnitude + adjusted_bucket);\n\t}\n\n\tinline int64_t next_non_equivalent_value(int64_t value) const\n\t{\n\t\treturn lowest_equivalent_value(value) + size_of_equivalent_value_range(value);\n\t}\n\n\tinline int64_t lowest_equivalent_value(int64_t value) const\n\t{\n\t\tint32_t const bucket_index     = get_bucket_index(value);\n\t\tint32_t const sub_bucket_index = get_sub_bucket_index(value, bucket_index, this->unit_magnitude);\n\t\treturn value_from_index(bucket_index, sub_bucket_index, this->unit_magnitude);\n\t}\n\n\tinline int64_t highest_equivalent_value(int64_t value) const\n\t{\n\t\treturn next_non_equivalent_value(value) - 1;\n\t}\n\npublic:\n\n\tstatic inline int64_t value_from_index(int32_t bucket_index, int32_t sub_bucket_index, int32_t unit_magnitude)\n\t{\n\t\treturn ((int64_t) sub_bucket_index) << (bucket_index + unit_magnitude);\n\t}\n\n\tstatic inline int32_t get_sub_bucket_index(int64_t value, int32_t bucket_index, int32_t unit_magnitude)\n\t{\n\t\treturn (int32_t)(value >> (bucket_index + unit_magnitude));\n\t}\n\n\tinline int32_t get_bucket_index(int64_t value) const\n\t{\n\n\t\tint32_t const pow2ceiling = (sizeof(unsigned long long) * 8) - __builtin_clzll(value | this->sub_bucket_mask);\n\n\t\treturn pow2ceiling - this->unit_magnitude - (this->sub_bucket_half_count_magnitude + 1);\n\t}\n\n\tinline int32_t counts_index( int32_t bucket_index, int32_t sub_bucket_index) const\n\t{\n\n\n\t\tint32_t const bucket_base_index = (bucket_index + 1) << this->sub_bucket_half_count_magnitude;\n\n\t\tint32_t const offset_in_bucket = sub_bucket_index - this->sub_bucket_half_count;\n\n\t\treturn bucket_base_index + offset_in_bucket;\n\t}\n\n\tinline int32_t counts_index_for(int64_t value) const\n\t{\n\t\tint32_t const bucket_index     = get_bucket_index(value);\n\t\tint32_t const sub_bucket_index = get_sub_bucket_index(value, bucket_index, this->unit_magnitude);\n\n\t\treturn counts_index(bucket_index, sub_bucket_index);\n\t}\n\nprivate:\n\tstruct nmpa_s *nmpa_;\n\n\n\n\tuint16_t   sub_bucket_count;\n\tuint16_t   sub_bucket_half_count;\n\tuint16_t   sub_bucket_mask;\n\tuint8_t    unit_magnitude;\n\tuint8_t    sub_bucket_half_count_magnitude;\n\n\n\tuint32_t   counts_nonzero_;\n\tuint32_t   counts_len_;\n\n\n\tuint64_t   total_count_;\n\n\n\tcounter_t  *counts_;\n\n\n\tuint32_t    counts_maxlen_;\n\tcounter_t   negative_inf_;\n\tcounter_t   positive_inf_;\n\tuint32_t    padding____;\n\n};\nstatic_assert(sizeof(hdr_histogram___impl_t<uint32_t>) == 56, \"\");\n\n\n\ntemplate<class SinkT, class Histogram>\ninline void hdr_histogram___debug_dump(SinkT& sink, Histogram const& hv, meow::str_ref func_name)\n{\n\tauto const counts_r = hv.get_counts_range();\n\n\tmeow::format::fmt(stderr, \"{0} internal failure, dumping histogram\\n\", func_name);\n\tmeow::format::fmt(stderr, \"{0} neg_inf: {1}, pos_inf: {2}, total_count: {3}, hv_size: {4}\\n\",\n\t\tfunc_name, hv.negative_inf(), hv.positive_inf(), hv.total_count(), counts_r.size());\n\n\tfor (uint32_t i = 0; i < counts_r.size(); i++)\n\t\tmeow::format::fmt(stderr, \"  [{0}] -> {1}\\n\", hv.value_at_index(i), hv.count_at_index(i));\n}\n\n\n\n#endif\n\n'pinba2/include/pinba/histogram.h'\n:#ifndef PINBA__HISTOGRAM_H_\n#define PINBA__HISTOGRAM_H_\n\n#include <cstdint>\n#include <cmath>\n\n#include \"pinba/limits.h\"\n#include \"pinba/hdr_histogram.h\"\n\n\n\n\nstruct histogram_conf_t\n{\n\tduration_t  min_value;\n\tduration_t  max_value;\n\tduration_t  unit_size;\n\tint         precision_bits;\n\n\n\tduration_t bucket_d;\n\n\thdr_histogram_conf_t hdr;\n};\n\n\n\n\nstruct histogram_value_t\n{\n\tuint32_t bucket_id;\n\tuint32_t value;\n};\nstatic_assert(sizeof(histogram_value_t) == sizeof(uint64_t), \"histogram_value_t must have no padding\");\n\ninline constexpr bool operator<(histogram_value_t const& l, histogram_value_t const& r)\n{\n\treturn l.bucket_id < r.bucket_id;\n}\n\ntypedef std::vector<histogram_value_t> histogram_values_t;\n\nstruct flat_histogram_t\n{\n\thistogram_values_t  values;\n\tuint32_t            total_count;\n\tuint32_t            negative_inf;\n\tuint32_t            positive_inf;\n};\nstatic_assert(sizeof(flat_histogram_t) == (sizeof(histogram_values_t)+4*sizeof(uint32_t)), \"flat_histogram_t must have no padding\");\n\ninline duration_t get_percentile(flat_histogram_t const& hv, histogram_conf_t const& conf, double percentile)\n{\n\tif (percentile == 0.)\n\t\treturn conf.min_value;\n\n\tif (hv.total_count == 0)\n\t\treturn conf.min_value;\n\n\tuint32_t required_sum = [&]()\n\t{\n\t\tuint32_t const res = std::ceil(hv.total_count * percentile / 100.0);\n\t\treturn (res > hv.total_count) ? hv.total_count : res;\n\t}();\n\n\n\n\n\tif (required_sum == 0)\n\t\treturn conf.min_value;\n\n\n\tif (required_sum <= hv.negative_inf)\n\t\treturn conf.min_value;\n\n\n\tif (required_sum > (hv.total_count - hv.positive_inf))\n\t\treturn conf.max_value;\n\n\n\trequired_sum -= hv.negative_inf;\n\n\n\n\tuint32_t current_sum = 0;\n\n\tfor (auto const& item : hv.values)\n\t{\n\t\tuint32_t const bucket_id       = item.bucket_id;\n\t\tuint32_t const next_has_values = item.value;\n\t\tuint32_t const need_values     = required_sum - current_sum;\n\n\t\tif (next_has_values < need_values)\n\t\t{\n\t\t\tcurrent_sum += next_has_values;\n\n\t\t\tcontinue;\n\t\t}\n\n\n\n\t\tif (next_has_values == need_values)\n\t\t{\n\n\t\t\treturn conf.min_value + conf.bucket_d * bucket_id;\n\t\t}\n\n\n\t\t{\n\t\t\tduration_t const d = conf.bucket_d * need_values / next_has_values;\n\n\n\n\t\t\tassert(bucket_id > 0);\n\t\t\treturn conf.min_value + conf.bucket_d * (bucket_id - 1) + d;\n\t\t}\n\t}\n\n\n\t{\n\t\tff::fmt(stderr, \"{0} internal failure, dumping histogram\\n\", __func__);\n\t\tff::fmt(stderr, \"{0} neg_inf: {1}, pos_inf: {2}, value_count: {3}, hv_size: {4}\\n\",\n\t\t\t__func__, hv.negative_inf, hv.positive_inf, hv.total_count, hv.values.size());\n\n\t\tfor (auto const& item : hv.values)\n\t\t\tff::fmt(stderr, \"[{0}] -> {1}\\n\", item.bucket_id, item.value);\n\t}\n\n\tassert(!\"must not be reached\");\n}\n\n\n\n\nstruct hdr_histogram_t : public hdr_histogram___impl_t<uint32_t>\n{\n\tusing base_t = hdr_histogram___impl_t<uint32_t>;\n\n\thdr_histogram_t(struct nmpa_s *nmpa, histogram_conf_t const& conf)\n\t\t: base_t(nmpa, conf.hdr)\n\t{\n\t}\n\n\tvoid increment(histogram_conf_t const& conf, duration_t const d, uint32_t increment_by = 1)\n\t{\n\n\t\tauto const dr = std::div(d.nsec, conf.unit_size.nsec);\n\t\tint64_t const value = dr.quot + (dr.rem != 0);\n\n\t\tthis->base_t::increment(conf.hdr, value, increment_by);\n\t}\n\n\tvoid merge_other_with_same_conf(hdr_histogram_t const& other, histogram_conf_t const& conf)\n\t{\n\t\treturn this->base_t::merge_other_with_same_conf(other, conf.hdr);\n\t}\n};\n\ninline duration_t get_percentile(hdr_histogram_t const& hv, histogram_conf_t const& conf, double percentile)\n{\n\tint64_t const pct_value = hv.get_percentile(conf.hdr, percentile);\n\treturn pct_value * conf.unit_size;\n}\n\ninline meow::error_t hdr_histogram_configure(hdr_histogram_conf_t *conf, histogram_conf_t const& hv_conf)\n{\n\n\tint64_t low  = (hv_conf.min_value / hv_conf.unit_size).nsec;\n\tif (low <= 0)\n\t\tlow = 1;\n\n\tint64_t const high = (hv_conf.max_value / hv_conf.unit_size).nsec;\n\treturn hdr_histogram_configure(conf, low, high, hv_conf.precision_bits);\n}\n\n\n\n\ninline flat_histogram_t histogram___convert_hdr_to_flat(hdr_histogram_t const& hdr, histogram_conf_t const& conf)\n{\n\tflat_histogram_t flat;\n\n\tflat.total_count  = hdr.total_count();\n\tflat.negative_inf = hdr.negative_inf();\n\tflat.positive_inf = hdr.positive_inf();\n\n\tflat.values.clear();\n\tflat.values.resize(hdr.counts_nonzero());\n\n\tauto const counts_r = hdr.get_counts_range();\n\n\tuint32_t read_position = 0;\n\tfor (uint32_t i = 0; i < hdr.counts_nonzero(); i++)\n\t{\n\t\twhile (counts_r[read_position] == 0)\n\t\t\tread_position++;\n\n\t\thistogram_value_t& hv_value = flat.values[i];\n\t\thv_value.bucket_id = (uint32_t) hdr.value_at_index(read_position);\n\t\thv_value.value     = counts_r[read_position];\n\n\t\tread_position++;\n\t}\n\n\tassert(read_position <= counts_r.size());\n\n\treturn flat;\n}\n\n\n\n#endif\n",
        "gt": [
            "'pinba2/include/pinba/hdr_histogram.h'",
            "'pinba2/include/pinba/histogram.h'",
            "'pinba2/src/report_snapshot.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/ModifySubscriptionRequest.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/SubscriptionService.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/SubscriptionService.cpp'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/SubscriptionServiceTransaction.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/SubscriptionManager.h'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackCore/ServiceSet/ModifySubscriptionRequest.h'\n:\n\n#ifndef __OpcUaStackCore_ModifySubscriptionRequest_h__\n#define __OpcUaStackCore_ModifySubscriptionRequest_h__\n\n#include <stdint.h>\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/BuildInTypes/BuildInTypes.h\"\n#include \"OpcUaStackCore/SecureChannel/RequestHeader.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT ModifySubscriptionRequest\n\t: public Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<ModifySubscriptionRequest> SPtr;\n\n\t\tModifySubscriptionRequest(void);\n\t\tvirtual ~ModifySubscriptionRequest(void);\n\n\t\tvoid subscriptionId(const OpcUaUInt32& subscriptionId);\n\t\tOpcUaUInt32 subscriptionId(void) const;\n\t\tvoid requestedPublishingInterval(const OpcUaDouble& requestedPublishingInterval);\n\t\tOpcUaDouble requestedPublishingInterval(void) const;\n\t\tvoid requestedLifetimeCount(const OpcUaUInt32& requestedLifetimeCount);\n\t\tOpcUaUInt32 requestedLifetimeCount(void) const;\n\t\tvoid requestedMaxKeepAliveCount(const OpcUaUInt32& requestedMaxKeepAliveCount);\n\t\tOpcUaUInt32 requestedMaxKeepAliveCount(void) const;\n\t\tvoid maxNotificationsPerPublish(const OpcUaUInt32& maxNotificationsPerPublish);\n\t\tOpcUaUInt32 maxNotificationsPerPublish(void) const;\n\t\tvoid priority(const OpcUaByte& priority);\n\t\tOpcUaByte priority(void) const;\n\n\t\tvoid opcUaBinaryEncode(std::ostream& os) const;\n\t\tvoid opcUaBinaryDecode(std::istream& is);\n\n\t  private:\n\t\tOpcUaUInt32 subscriptionId_;\n\t\tOpcUaDouble requestedPublishingInterval_;\n\t\tOpcUaUInt32 requestedLifetimeCount_;\n\t\tOpcUaUInt32 requestedMaxKeepAliveCount_;\n\t\tOpcUaUInt32 maxNotificationsPerPublish_;\n\t\tOpcUaByte priority_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackServer/ServiceSet/SubscriptionService.h'\n:\n\n#ifndef __OpcUaStackServer_SubscriptionService_h__\n#define __OpcUaStackServer_SubscriptionService_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/ServiceSetApplication/ForwardGlobalSync.h\"\n#include \"OpcUaStackCore/ServiceSet/SubscriptionServiceTransaction.h\"\n#include \"OpcUaStackCore/ServiceSet/MonitoredItemServiceTransaction.h\"\n#include \"OpcUaStackServer/ServiceSet/ServiceSetBase.h\"\n#include \"OpcUaStackServer/ServiceSet/SubscriptionManager.h\"\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackServer\n{\n\n\tclass DLLEXPORT SubscriptionService\n\t: public ServiceSetBase\n\t, public Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<SubscriptionService> SPtr;\n\t\ttypedef std::map<uint32_t, SubscriptionManager::SPtr> SubscriptionManagerMap;\n\n\t\tSubscriptionService(void);\n\t\t~SubscriptionService(void);\n\n\t\tbool init(void);\n\n\n\t\tvoid receive(Message::SPtr message);\n\n\n\t  private:\n\n\t\tvoid receiveCreateSubscriptionRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveDeleteSubscriptionsRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveModifySubscriptionRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receivePublishRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveRepublishRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveSetPublishingModeRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveTransferSubscriptionsRequest(ServiceTransaction::SPtr serviceTransaction);\n\n\n\t\tvoid receiveCreateMonitoredItemsRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveDeleteMonitoredItemsRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveModifyMonitoredItemsRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveSetMonitoringModeRequest(ServiceTransaction::SPtr serviceTransaction);\n\t\tvoid receiveSetTriggeringRequest(ServiceTransaction::SPtr serviceTransaction);\n\n\t\tSubscriptionManagerMap subscriptionManagerMap_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackServer/ServiceSet/SubscriptionService.cpp'\n:\n\n#include \"OpcUaStackCore/BuildInTypes/OpcUaIdentifier.h\"\n#include \"OpcUaStackCore/Base/Log.h\"\n#include \"OpcUaStackServer/ServiceSet/SubscriptionService.h\"\n\nnamespace OpcUaStackServer\n{\n\n\tSubscriptionService::SubscriptionService(void)\n\t{\n\t}\n\n\tSubscriptionService::~SubscriptionService(void)\n\t{\n\t}\n\n\tbool\n\tSubscriptionService::init(void)\n\t{\n\t\treturn true;\n\t}\n\n\tvoid\n\tSubscriptionService::receive(Message::SPtr message)\n\t{\n\t\tServiceTransaction::SPtr serviceTransaction = boost::static_pointer_cast<ServiceTransaction>(message);\n\t\tswitch (serviceTransaction->nodeTypeRequest().nodeId<uint32_t>())\n\t\t{\n\n\n\n\t\t\tcase OpcUaId_CreateSubscriptionRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveCreateSubscriptionRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_DeleteSubscriptionsRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveDeleteSubscriptionsRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_ModifySubscriptionRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveModifySubscriptionRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_PublishRequest_Encoding_DefaultBinary:\n\t\t\t\treceivePublishRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_RepublishRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveRepublishRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_SetPublishingModeRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveSetPublishingModeRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_TransferSubscriptionsRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveTransferSubscriptionsRequest(serviceTransaction);\n\t\t\t\tbreak;\n\n\n\n\n\t\t\tcase OpcUaId_CreateMonitoredItemsRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveCreateMonitoredItemsRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_DeleteMonitoredItemsRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveDeleteMonitoredItemsRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_ModifyMonitoredItemsRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveModifyMonitoredItemsRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_SetMonitoringModeRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveSetMonitoringModeRequest(serviceTransaction);\n\t\t\t\tbreak;\n\t\t\tcase OpcUaId_SetTriggeringRequest_Encoding_DefaultBinary:\n\t\t\t\treceiveSetTriggeringRequest(serviceTransaction);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tserviceTransaction->statusCode(BadInternalError);\n\t\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvoid\n\tSubscriptionService::receiveCreateSubscriptionRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionCreateSubscription::SPtr trx = boost::static_pointer_cast<ServiceTransactionCreateSubscription>(serviceTransaction);\n\t\tCreateSubscriptionRequest::SPtr createSubscriptionRequest = trx->request();\n\t\tCreateSubscriptionResponse::SPtr createSubscriptionResponse = trx->response();\n\n\t\tLog(Debug, \"create subscription\")\n\t\t\t.parameter(\"Trx\", serviceTransaction->transactionId())\n\t\t\t.parameter(\"PublisingInterval\", createSubscriptionRequest->requestedPublishingInterval())\n\t\t\t.parameter(\"LifetimeCount\", createSubscriptionRequest->requestedLifetimeCount())\n\t\t\t.parameter(\"MaxKeepAliveCount\", createSubscriptionRequest->requestedMaxKeepAliveCount())\n\t\t\t.parameter(\"SessionId\", trx->sessionId());\n\n\n\t\tSubscriptionManager::SPtr subscriptionManager;\n\t\tSubscriptionManagerMap::iterator it = subscriptionManagerMap_.find(trx->sessionId());\n\t\tif (it == subscriptionManagerMap_.end()) {\n\t\t\tsubscriptionManager = constructSPtr<SubscriptionManager>();\n\t\t\tsubscriptionManager->ioThread(ioThread());\n\t\t\tsubscriptionManager->informationModel(informationModel_);\n\t\t\tsubscriptionManager->forwardGlobalSync(forwardGlobalSync_);\n\t\t\tsubscriptionManager->sessionId(trx->sessionId());\n\t\t\tsubscriptionManagerMap_.insert(std::make_pair(trx->sessionId(), subscriptionManager));\n\t\t}\n\t\telse {\n\t\t\tsubscriptionManager = it->second;\n\t\t}\n\n\t\tserviceTransaction->statusCode(subscriptionManager->receive(trx));\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tSubscriptionService::receiveDeleteSubscriptionsRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionDeleteSubscriptions::SPtr trx = boost::static_pointer_cast<ServiceTransactionDeleteSubscriptions>(serviceTransaction);\n\t\tDeleteSubscriptionsRequest::SPtr deleteSubscriptionsRequest = trx->request();\n\t\tDeleteSubscriptionsResponse::SPtr deleteSubscriptionsResponse = trx->response();\n\n\t\tLog(Debug, \"delete subscription\")\n\t\t\t.parameter(\"Trx\", serviceTransaction->transactionId());\n\n\n\t\tSubscriptionManager::SPtr subscriptionManager;\n\t\tSubscriptionManagerMap::iterator it = subscriptionManagerMap_.find(trx->sessionId());\n\t\tif (it == subscriptionManagerMap_.end()) {\n\t\t\tserviceTransaction->statusCode(BadNothingToDo);\n\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t\treturn;\n\t\t}\n\t\tsubscriptionManager = it->second;\n\n\t\tserviceTransaction->statusCode(subscriptionManager->receive(trx));\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\n\t\tif (subscriptionManager->size() == 0) {\n\t\t\tsubscriptionManagerMap_.erase(it);\n\t\t}\n\t}\n\n\tvoid\n\tSubscriptionService::receiveModifySubscriptionRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\n\t\tserviceTransaction->statusCode(BadInternalError);\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tSubscriptionService::receivePublishRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionPublish::SPtr trx = boost::static_pointer_cast<ServiceTransactionPublish>(serviceTransaction);\n\t\tPublishRequest::SPtr publishRequest = trx->request();\n\t\tPublishResponse::SPtr publishResponse = trx->response();\n\n\t\t{\n\t\t\tLog log(Debug, \"publish request\");\n\t\t\tlog.parameter(\"Trx\", serviceTransaction->transactionId());\n\n\t\t\tSubscriptionAcknowledgementArray::SPtr acks = publishRequest->subscriptionAcknowledgements();\n\t\t\tfor (uint32_t idx=0; idx<acks->size(); idx++) {\n\t\t\t\tSubscriptionAcknowledgement::SPtr ack;\n\t\t\t\tacks->get(idx, ack);\n\t\t\t\tlog.parameter(\"Ack-SubscriptionId\", ack->subscriptionId());\n\t\t\t\tlog.parameter(\"Ack-SequenceNumber\", ack->sequenceNumber());\n\t\t\t}\n\t\t}\n\n\n\t\tSubscriptionManager::SPtr subscriptionManager;\n\t\tSubscriptionManagerMap::iterator it = subscriptionManagerMap_.find(trx->sessionId());\n\t\tif (it == subscriptionManagerMap_.end()) {\n\t\t\tserviceTransaction->statusCode(BadNothingToDo);\n\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t\treturn;\n\t\t}\n\t\tsubscriptionManager = it->second;\n\n\t\tsubscriptionManager->receive(trx);\n\t}\n\n\tvoid\n\tSubscriptionService::receiveRepublishRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionRepublish::SPtr trx = boost::static_pointer_cast<ServiceTransactionRepublish>(serviceTransaction);\n\t\tRepublishRequest::SPtr republishRequest = trx->request();\n\t\tRepublishResponse::SPtr republishResponse = trx->response();\n\n\t\tLog(Debug, \"republish request\")\n\t\t    .parameter(\"Trx\", serviceTransaction->transactionId())\n\t\t    .parameter(\"SequenceNumber\", republishRequest->retransmitSequenceNumber());\n\n\n\t\tserviceTransaction->statusCode(BadMessageNotAvailable);\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tSubscriptionService::receiveSetPublishingModeRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\n\t\tserviceTransaction->statusCode(BadInternalError);\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tSubscriptionService::receiveTransferSubscriptionsRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\n\t\tserviceTransaction->statusCode(BadInternalError);\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\n\n\n\n\n\n\n\n\n\tvoid\n\tSubscriptionService::receiveCreateMonitoredItemsRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionCreateMonitoredItems::SPtr trx = boost::static_pointer_cast<ServiceTransactionCreateMonitoredItems>(serviceTransaction);\n\n\n\t\tSubscriptionManager::SPtr subscriptionManager;\n\t\tSubscriptionManagerMap::iterator it = subscriptionManagerMap_.find(trx->sessionId());\n\t\tif (it == subscriptionManagerMap_.end()) {\n\t\t\tserviceTransaction->statusCode(BadSubscriptionIdInvalid);\n\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t\treturn;\n\t\t}\n\t\tsubscriptionManager = it->second;\n\n\n\t\tserviceTransaction->statusCode(subscriptionManager->receive(trx));\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tSubscriptionService::receiveDeleteMonitoredItemsRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionDeleteMonitoredItems::SPtr trx = boost::static_pointer_cast<ServiceTransactionDeleteMonitoredItems>(serviceTransaction);\n\n\n\t\tSubscriptionManager::SPtr subscriptionManager;\n\t\tSubscriptionManagerMap::iterator it = subscriptionManagerMap_.find(trx->sessionId());\n\t\tif (it == subscriptionManagerMap_.end()) {\n\t\t\tserviceTransaction->statusCode(BadSubscriptionIdInvalid);\n\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t\treturn;\n\t\t}\n\t\tsubscriptionManager = it->second;\n\n\n\t\tserviceTransaction->statusCode(subscriptionManager->receive(trx));\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tSubscriptionService::receiveModifyMonitoredItemsRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionModifyMonitoredItems::SPtr trx = boost::static_pointer_cast<ServiceTransactionModifyMonitoredItems>(serviceTransaction);\n\n\n\t\tSubscriptionManager::SPtr subscriptionManager;\n\t\tSubscriptionManagerMap::iterator it = subscriptionManagerMap_.find(trx->sessionId());\n\t\tif (it == subscriptionManagerMap_.end()) {\n\t\t\tserviceTransaction->statusCode(BadSubscriptionIdInvalid);\n\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t\treturn;\n\t\t}\n\t\tsubscriptionManager = it->second;\n\n\n\t\tserviceTransaction->statusCode(subscriptionManager->receive(trx));\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tSubscriptionService::receiveSetMonitoringModeRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionSetMonitoringMode::SPtr trx = boost::static_pointer_cast<ServiceTransactionSetMonitoringMode>(serviceTransaction);\n\n\n\t\tSubscriptionManager::SPtr subscriptionManager;\n\t\tSubscriptionManagerMap::iterator it = subscriptionManagerMap_.find(trx->sessionId());\n\t\tif (it == subscriptionManagerMap_.end()) {\n\t\t\tserviceTransaction->statusCode(BadSubscriptionIdInvalid);\n\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t\treturn;\n\t\t}\n\t\tsubscriptionManager = it->second;\n\n\n\t\tserviceTransaction->statusCode(subscriptionManager->receive(trx));\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n\tvoid\n\tSubscriptionService::receiveSetTriggeringRequest(ServiceTransaction::SPtr serviceTransaction)\n\t{\n\t\tServiceTransactionSetTriggering::SPtr trx = boost::static_pointer_cast<ServiceTransactionSetTriggering>(serviceTransaction);\n\n\n\t\tSubscriptionManager::SPtr subscriptionManager;\n\t\tSubscriptionManagerMap::iterator it = subscriptionManagerMap_.find(trx->sessionId());\n\t\tif (it == subscriptionManagerMap_.end()) {\n\t\t\tserviceTransaction->statusCode(BadSubscriptionIdInvalid);\n\t\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t\t\treturn;\n\t\t}\n\t\tsubscriptionManager = it->second;\n\n\n\t\tserviceTransaction->statusCode(subscriptionManager->receive(trx));\n\t\tserviceTransaction->componentSession()->send(serviceTransaction);\n\t}\n\n}\n\n'OpcUaStack/src/OpcUaStackCore/ServiceSet/SubscriptionServiceTransaction.h'\n:\n\n#ifndef __OpcUaStackCore_SubscriptionServiceTransaction_h__\n#define __OpcUaStackCore_SubscriptionServiceTransaction_h__\n\n#include \"OpcUaStackCore/BuildInTypes/OpcUaIdentifier.h\"\n#include \"OpcUaStackCore/ServiceSet/ServiceTransactionTemplate.h\"\n#include \"OpcUaStackCore/ServiceSet/CreateSubscriptionRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/CreateSubscriptionResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/ModifySubscriptionRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/ModifySubscriptionResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/SetPublishingModeRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/SetPublishingModeResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/PublishRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/PublishResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/RepublishRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/RepublishResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/TransferSubscriptionsRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/TransferSubscriptionsResponse.h\"\n#include \"OpcUaStackCore/ServiceSet/DeleteSubscriptionsRequest.h\"\n#include \"OpcUaStackCore/ServiceSet/DeleteSubscriptionsResponse.h\"\n\nnamespace OpcUaStackCore\n{\n\n\ttypedef ServiceTransactionTemplate<\n\t\tCreateSubscriptionRequest,\n\t\tCreateSubscriptionResponse,\n\t\tOpcUaId_CreateSubscriptionRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_CreateSubscriptionResponse_Encoding_DefaultBinary\n\t> ServiceTransactionCreateSubscription;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tModifySubscriptionRequest,\n\t\tModifySubscriptionResponse,\n\t\tOpcUaId_ModifySubscriptionRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_ModifySubscriptionResponse_Encoding_DefaultBinary\n\t> ServiceTransactionModifySubscription;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tSetPublishingModeRequest,\n\t\tSetPublishingModeResponse,\n\t\tOpcUaId_SetPublishingModeRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_SetPublishingModeResponse_Encoding_DefaultBinary\n\t> ServiceTransactionSetPublishingMode;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tPublishRequest,\n\t\tPublishResponse,\n\t\tOpcUaId_PublishRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_PublishResponse_Encoding_DefaultBinary\n\t> ServiceTransactionPublish;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tRepublishRequest,\n\t\tRepublishResponse,\n\t\tOpcUaId_RepublishRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_RepublishResponse_Encoding_DefaultBinary\n\t> ServiceTransactionRepublish;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tTransferSubscriptionsRequest,\n\t\tTransferSubscriptionsResponse,\n\t\tOpcUaId_TransferSubscriptionsRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_TransferSubscriptionsResponse_Encoding_DefaultBinary\n\t> ServiceTransactionTransferSubscriptions;\n\n\ttypedef ServiceTransactionTemplate<\n\t\tDeleteSubscriptionsRequest,\n\t\tDeleteSubscriptionsResponse,\n\t\tOpcUaId_DeleteSubscriptionsRequest_Encoding_DefaultBinary,\n\t\tOpcUaId_DeleteSubscriptionsResponse_Encoding_DefaultBinary\n\t> ServiceTransactionDeleteSubscriptions;\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackServer/ServiceSet/SubscriptionManager.h'\n:\n\n#ifndef __OpcUaStackServer_SubscriptionManager_h__\n#define __OpcUaStackServer_SubscriptionManager_h__\n\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/Base/ObjectPool.h\"\n#include \"OpcUaStackCore/Base/IOService.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaStatusCode.h\"\n#include \"OpcUaStackCore/Utility/SlotTimer.h\"\n#include \"OpcUaStackCore/ServiceSetApplication/ForwardGlobalSync.h\"\n#include \"OpcUaStackCore/ServiceSet/SubscriptionServiceTransaction.h\"\n#include \"OpcUaStackCore/ServiceSet/MonitoredItemServiceTransaction.h\"\n#include \"OpcUaStackServer/ServiceSet/Subscription.h\"\n#include \"OpcUaStackServer/InformationModel/InformationModel.h\"\n\n#include <set>\n\nusing namespace OpcUaStackCore;\n\nnamespace OpcUaStackServer\n{\n\n\ttypedef std::list<ServiceTransactionPublish::SPtr> ServiceTransactionPublishList;\n\ttypedef std::list<uint32_t> SubscriptionIdList;\n\n\tclass DLLEXPORT SubscriptionManager\n\t: public Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<SubscriptionManager> SPtr;\n\n\t\tSubscriptionManager(void);\n\t\t~SubscriptionManager(void);\n\n\t\tvoid ioThread(IOThread* ioThread);\n\t\tvoid informationModel(InformationModel::SPtr informationModel);\n\t\tvoid forwardGlobalSync(ForwardGlobalSync::SPtr& forwardGlobalSync);\n\t\tvoid sessionId(uint32_t sessionId);\n\n\t\tOpcUaStatusCode receive(ServiceTransactionCreateSubscription::SPtr trx);\n\t\tOpcUaStatusCode receive(ServiceTransactionDeleteSubscriptions::SPtr trx);\n\t\tOpcUaStatusCode receive(ServiceTransactionPublish::SPtr trx);\n\n\t\tOpcUaStatusCode receive(ServiceTransactionCreateMonitoredItems::SPtr trx);\n\t\tOpcUaStatusCode receive(ServiceTransactionDeleteMonitoredItems::SPtr trx);\n\t\tOpcUaStatusCode receive(ServiceTransactionModifyMonitoredItems::SPtr trx);\n\t\tOpcUaStatusCode receive(ServiceTransactionSetMonitoringMode::SPtr trx);\n\t\tOpcUaStatusCode receive(ServiceTransactionSetTriggering::SPtr trx);\n\n\t\tsize_t size(void);\n\n\t  private:\n\t\tvoid subscriptionPublishTimeout(Subscription::SPtr subscription);\n\t\tOpcUaStatusCode receiveAcknowledgement(uint32_t subscriptionId, uint32_t acknowledgmentNumber);\n\n\t\tIOThread* ioThread_;\n\t\tInformationModel::SPtr informationModel_;\n\t\tForwardGlobalSync::SPtr forwardGlobalSync_;\n\t\tSubscriptionMap subscriptionMap_;\n\t\tuint32_t sessionId_;\n\n\t\tServiceTransactionPublishList serviceTransactionPublishList_;\n\t\tSubscriptionIdList subscriptionIdList_;\n\n\t\tdouble minPublishingInterval_;\n\t\tuint32_t minLifetimeCount_;\n\t\tuint32_t minMaxKeepAliveCount_;\n\t};\n\n}\n\n#endif\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/ModifySubscriptionRequest.h'",
            "'OpcUaStack/src/OpcUaStackCore/ServiceSet/SubscriptionServiceTransaction.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/SubscriptionManager.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/SubscriptionService.h'",
            "'OpcUaStack/src/OpcUaStackServer/ServiceSet/SubscriptionService.cpp'"
        ]
    },
    {
        "files": [
            "'parthenon/src/mesh/forest/logical_coordinate_transformation.hpp'",
            "'parthenon/src/bvals/comms/bnd_info.cpp'",
            "'parthenon/src/bvals/neighbor_block.hpp'"
        ],
        "content": "'parthenon/src/mesh/forest/logical_coordinate_transformation.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n#ifndef MESH_FOREST_LOGICAL_COORDINATE_TRANSFORMATION_HPP_\n#define MESH_FOREST_LOGICAL_COORDINATE_TRANSFORMATION_HPP_\n\n#include <array>\n#include <map>\n#include <memory>\n#include <set>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#include \"basic_types.hpp\"\n#include \"defs.hpp\"\n#include \"mesh/forest/logical_location.hpp\"\n#include \"utils/bit_hacks.hpp\"\n#include \"utils/cell_center_offsets.hpp\"\n#include \"utils/indexer.hpp\"\n\nnamespace parthenon {\nnamespace forest {\n\nstruct LogicalCoordinateTransformation {\n  KOKKOS_INLINE_FUNCTION\n  LogicalCoordinateTransformation()\n      : dir_connection{0, 1, 2}, dir_connection_inverse{0, 1, 2},\n        dir_flip{false, false, false}, offset{0, 0, 0} {};\n\n  void SetDirection(CoordinateDirection origin, CoordinateDirection neighbor,\n                    bool reversed = false) {\n    dir_connection[origin - 1] = neighbor - 1;\n    dir_connection_inverse[neighbor - 1] = origin - 1;\n    dir_flip[origin - 1] = reversed;\n  }\n\n  LogicalLocation Transform(const LogicalLocation &loc_in,\n                            std::int64_t destination) const;\n  LogicalLocation InverseTransform(const LogicalLocation &loc_in,\n                                   std::int64_t origin) const;\n  CellCentOffsets Transform(CellCentOffsets in) const;\n\n  KOKKOS_INLINE_FUNCTION\n  std::tuple<TopologicalElement, Real> Transform(TopologicalElement el) const {\n    int iel = static_cast<int>(el);\n    Real fac = 1.0;\n    if (iel >= 3 && iel < 9) {\n      int dir = iel % 3;\n      iel = (iel / 3) * 3 + abs(dir_connection[dir]);\n      fac = dir_flip[dir] ? -1.0 : 1.0;\n    }\n    return {static_cast<TopologicalElement>(iel), fac};\n  }\n\n  KOKKOS_INLINE_FUNCTION\n  std::tuple<TopologicalElement, Real> InverseTransform(TopologicalElement el) const {\n    int iel = static_cast<int>(el);\n    Real fac = 1.0;\n    if (iel >= 3 && iel < 9) {\n      const int dir = iel % 3;\n      const int outdir = abs(dir_connection_inverse[dir]);\n      iel = (iel / 3) * 3 + outdir;\n      fac = dir_flip[outdir] ? -1.0 : 1.0;\n    }\n    return {static_cast<TopologicalElement>(iel), fac};\n  }\n\n  KOKKOS_INLINE_FUNCTION\n  std::array<int, 3> Transform(std::array<int, 3> ijk) const {\n    std::array<int, 3> ijk_out;\n    for (int dir = 0; dir < 3; ++dir) {\n      const int outdir = abs(dir_connection[dir]);\n      ijk_out[outdir] = dir_flip[dir] ? ncell - 1 - ijk[dir] : ijk[dir];\n    }\n    return ijk_out;\n  }\n\n  KOKKOS_INLINE_FUNCTION\n  std::array<int, 3> InverseTransform(std::array<int, 3> ijk) const {\n    std::array<int, 3> ijk_out;\n    for (int dir = 0; dir < 3; ++dir) {\n      const int indir = abs(dir_connection[dir]);\n      ijk_out[dir] = dir_flip[dir] ? ncell - 1 - ijk[indir] : ijk[indir];\n    }\n    return ijk_out;\n  }\n\n  bool use_offset = false;\n  std::array<int, 3> offset;\n  std::array<int, 3> dir_connection, dir_connection_inverse;\n  std::array<bool, 3> dir_flip;\n  int ncell;\n};\n\nLogicalCoordinateTransformation\nComposeTransformations(const LogicalCoordinateTransformation &first,\n                       const LogicalCoordinateTransformation &second);\n\nstruct NeighborLocation {\n  NeighborLocation(const LogicalLocation &g, const LogicalLocation &o,\n                   const LogicalCoordinateTransformation &lcoord_trans)\n      : global_loc(g), origin_loc(o), lcoord_trans(lcoord_trans) {}\n  LogicalLocation global_loc;\n  LogicalLocation\n      origin_loc;\n  LogicalCoordinateTransformation lcoord_trans;\n};\n\n}\n}\n\n#endif\n\n'parthenon/src/bvals/comms/bnd_info.cpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"basic_types.hpp\"\n#include \"bvals/comms/bnd_info.hpp\"\n#include \"bvals/neighbor_block.hpp\"\n#include \"config.hpp\"\n#include \"globals.hpp\"\n#include \"interface/state_descriptor.hpp\"\n#include \"interface/variable.hpp\"\n#include \"kokkos_abstraction.hpp\"\n#include \"mesh/domain.hpp\"\n#include \"mesh/mesh.hpp\"\n#include \"mesh/mesh_refinement.hpp\"\n#include \"mesh/meshblock.hpp\"\n#include \"prolong_restrict/prolong_restrict.hpp\"\n#include \"utils/error_checking.hpp\"\n\nnamespace parthenon {\n\nvoid ProResCache_t::Initialize(int n_regions, StateDescriptor *pkg) {\n  prores_info = ParArray1D<ProResInfo>(\"prores_info\", n_regions);\n  prores_info_h = Kokkos::create_mirror_view(prores_info);\n  int nref_funcs = pkg->NumRefinementFuncs();\n\n\n\n  buffer_subset_sizes.clear();\n  buffer_subset_sizes.resize(nref_funcs, 0);\n  buffer_subsets = ParArray2D<std::size_t>(\"buffer_subsets\", nref_funcs, n_regions);\n  buffer_subsets_h = Kokkos::create_mirror_view(buffer_subsets);\n}\n\nvoid ProResCache_t::RegisterRegionHost(int region, ProResInfo pri, Variable<Real> *v,\n                                       StateDescriptor *pkg) {\n  prores_info_h(region) = pri;\n  if (v->HasRefinementOps()) {\n\n\n\n\n\n    std::size_t rfid = pkg->RefinementFuncID((v->GetRefinementFunctions()));\n    buffer_subsets_h(rfid, buffer_subset_sizes[rfid]++) = region;\n  }\n}\n\n\n\nstd::vector<TopologicalElement>\nGetFluxCorrectionElements(const std::shared_ptr<Variable<Real>> &v,\n                          const CellCentOffsets &offsets) {\n  using TE = TopologicalElement;\n  std::vector<TopologicalElement> elements;\n  if (v->IsSet(Metadata::Face)) {\n    if (offsets.IsFace()) {\n      if (std::abs(offsets(X1DIR))) elements = {TE::F1};\n      if (std::abs(offsets(X2DIR))) elements = {TE::F2};\n      if (std::abs(offsets(X3DIR))) elements = {TE::F3};\n    } else {\n      PARTHENON_FAIL(\"Flux correction for face fluxes only occurs on shared faces.\");\n    }\n  } else if (v->IsSet(Metadata::Edge)) {\n    if (offsets.IsFace()) {\n      if (std::abs(offsets(X1DIR))) elements = {TE::E2, TE::E3};\n      if (std::abs(offsets(X2DIR))) elements = {TE::E3, TE::E1};\n      if (std::abs(offsets(X3DIR))) elements = {TE::E1, TE::E2};\n    } else if (offsets.IsEdge()) {\n      if (offsets(X1DIR) == 0) elements = {TE::E1};\n      if (offsets(X2DIR) == 0) elements = {TE::E2};\n      if (offsets(X3DIR) == 0) elements = {TE::E3};\n    } else {\n      PARTHENON_FAIL(\n          \"Flux correction for edge fluxes only occurs on shared faces and edges.\");\n    }\n  } else if (v->IsSet(Metadata::Node)) {\n    elements = {TE::NN};\n  } else {\n    PARTHENON_FAIL(\"Only faces, edges, and nodes can be fluxes.\");\n  }\n  return elements;\n}\n\nSpatiallyMaskedIndexer6D\nCalcIndices(const NeighborBlock &nb, MeshBlock *pmb,\n            const std::shared_ptr<Variable<Real>> &v, TopologicalElement el,\n            IndexRangeType ir_type, bool prores,\n            const forest::LogicalCoordinateTransformation &lcoord_trans =\n                forest::LogicalCoordinateTransformation()) {\n  std::array<int, 3> tensor_shape{v->GetDim(6), v->GetDim(5), v->GetDim(4)};\n  const bool flux = v->IsSet(Metadata::Flux);\n\n  const auto &loc = pmb->loc;\n  bool is_fine_field = v->IsSet(Metadata::Fine);\n  auto shape = is_fine_field ? pmb->f_cellbounds : pmb->cellbounds;\n\n\n\n\n  if (prores || nb.loc.level() < loc.level())\n    shape = is_fine_field ? pmb->cellbounds : pmb->c_cellbounds;\n\n\n\n  int fine_field_fac = is_fine_field ? 2 : 1;\n  int coarse_fac = nb.loc.level() > loc.level() ? 2 : 1;\n  auto neighbor_shape =\n      IndexShape(nb.block_size.nx(X3DIR) * fine_field_fac / coarse_fac,\n                 nb.block_size.nx(X2DIR) * fine_field_fac / coarse_fac,\n                 nb.block_size.nx(X1DIR) * fine_field_fac / coarse_fac, Globals::nghost);\n\n  IndexDomain interior = IndexDomain::interior;\n  std::array<IndexRange, 3> bounds{shape.GetBoundsI(interior, el),\n                                   shape.GetBoundsJ(interior, el),\n                                   shape.GetBoundsK(interior, el)};\n  std::array<IndexRange, 3> neighbor_bounds{neighbor_shape.GetBoundsI(interior, el),\n                                            neighbor_shape.GetBoundsJ(interior, el),\n                                            neighbor_shape.GetBoundsK(interior, el)};\n\n  std::array<bool, 3> not_symmetry{!pmb->block_size.symmetry(X1DIR),\n                                   !pmb->block_size.symmetry(X2DIR),\n                                   !pmb->block_size.symmetry(X3DIR)};\n\n\n\n\n  std::array<int, 3> top_offset{TopologicalOffsetI(el), TopologicalOffsetJ(el),\n                                TopologicalOffsetK(el)};\n  std::array<int, 3> block_offset = nb.offsets;\n\n  int interior_offset =\n      ir_type == IndexRangeType::BoundaryInteriorSend ? Globals::nghost : 0;\n  int exterior_offset =\n      ir_type == IndexRangeType::BoundaryExteriorRecv ? Globals::nghost : 0;\n  if (prores) {\n\n\n\n    exterior_offset /= 2;\n  }\n\n  std::array<int, 3> s, e;\n  for (int dir = 0; dir < 3; ++dir) {\n    if (block_offset[dir] == 0) {\n      s[dir] = bounds[dir].s;\n      e[dir] = bounds[dir].e;\n      if ((loc.level() < nb.origin_loc.level()) &&\n          not_symmetry[dir]) {\n\n\n\n\n\n\n\n        const int extra_zones = (bounds[dir].e - bounds[dir].s + 1) -\n                                (neighbor_bounds[dir].e - neighbor_bounds[dir].s + 1);\n        s[dir] += nb.origin_loc.l(dir) % 2 == 1 ? extra_zones - interior_offset : 0;\n        e[dir] -= nb.origin_loc.l(dir) % 2 == 0 ? extra_zones - interior_offset : 0;\n        if (ir_type == IndexRangeType::InteriorSend && !prores) {\n\n          s[dir] -= Globals::nghost;\n          e[dir] += Globals::nghost;\n        }\n      }\n      if (loc.level() > nb.origin_loc.level() && not_symmetry[dir]) {\n\n\n\n        s[dir] -= loc.l(dir) % 2 == 1 ? exterior_offset : 0;\n        e[dir] += loc.l(dir) % 2 == 0 ? exterior_offset : 0;\n        if (ir_type == IndexRangeType::InteriorRecv && !prores) {\n\n          s[dir] -= Globals::nghost;\n          e[dir] += Globals::nghost;\n        }\n      }\n\n\n      if (prores && not_symmetry[dir] && IndexRangeType::InteriorRecv == ir_type) {\n        s[dir] -= Globals::nghost / 2;\n        e[dir] += Globals::nghost / 2;\n      }\n    } else if (block_offset[dir] > 0) {\n\n      s[dir] = bounds[dir].e + (flux ? 0 : -interior_offset + 1 - top_offset[dir]);\n      e[dir] = bounds[dir].e + (flux ? 0 : exterior_offset);\n    } else {\n      s[dir] = bounds[dir].s + (flux ? 0 : -exterior_offset);\n      e[dir] = bounds[dir].s + (flux ? 0 : interior_offset - 1 + top_offset[dir]);\n    }\n  }\n\n\n\n  if (ir_type == IndexRangeType::BoundaryExteriorRecv) {\n    s = lcoord_trans.Transform(s);\n    e = lcoord_trans.Transform(e);\n\n\n    for (int dir = 0; dir < 3; ++dir) {\n      if (s[dir] > e[dir]) {\n        int temp = s[dir];\n        s[dir] = e[dir];\n        e[dir] = temp;\n      }\n    }\n  }\n\n  block_ownership_t owns(true);\n\n\n\n\n  if (ir_type == IndexRangeType::BoundaryExteriorRecv) {\n    int sox1 = -block_offset[0];\n    int sox2 = -block_offset[1];\n    int sox3 = -block_offset[2];\n    if (nb.origin_loc.level() < loc.level()) {\n\n\n      if (sox1 == 0) sox1 = loc.l(0) % 2 == 1 ? 1 : -1;\n      if (sox2 == 0) sox2 = loc.l(1) % 2 == 1 ? 1 : -1;\n      if (sox3 == 0) sox3 = loc.l(2) % 2 == 1 ? 1 : -1;\n    }\n    owns = GetIndexRangeMaskFromOwnership(el, nb.ownership, sox1, sox2, sox3);\n  }\n  return SpatiallyMaskedIndexer6D(owns, {0, tensor_shape[0] - 1},\n                                  {0, tensor_shape[1] - 1}, {0, tensor_shape[2] - 1},\n                                  {s[2], e[2]}, {s[1], e[1]}, {s[0], e[0]});\n}\n\nint GetBufferSize(MeshBlock *pmb, const NeighborBlock &nb,\n                  std::shared_ptr<Variable<Real>> v) {\n\n\n\n  auto &cb = v->IsSet(Metadata::Fine) ? pmb->f_cellbounds : pmb->cellbounds;\n  int topo_comp = (v->IsSet(Metadata::Face) || v->IsSet(Metadata::Edge)) ? 3 : 1;\n  const IndexDomain in = IndexDomain::entire;\n\n\n  const int isize = cb.ie(in) - cb.is(in) + 2;\n  const int jsize = cb.je(in) - cb.js(in) + 2;\n  const int ksize = cb.ke(in) - cb.ks(in) + 2;\n  return (nb.offsets(X1DIR) == 0 ? isize : Globals::nghost + 1) *\n         (nb.offsets(X2DIR) == 0 ? jsize : Globals::nghost + 1) *\n         (nb.offsets(X3DIR) == 0 ? ksize : Globals::nghost + 1) * v->GetDim(6) *\n         v->GetDim(5) * v->GetDim(4) * topo_comp;\n}\n\nBndInfo::BndInfo(MeshBlock *pmb, const NeighborBlock &nb,\n                 std::shared_ptr<Variable<Real>> v,\n                 CommBuffer<buf_pool_t<Real>::owner_t> *combuf,\n                 IndexRangeType idx_range_type) {\n  allocated = v->IsAllocated();\n  alloc_status = v->GetAllocationStatus();\n\n  buf = combuf->buffer();\n  same_to_same = pmb->gid == nb.gid && nb.offsets.IsCell();\n  lcoord_trans = nb.lcoord_trans;\n  if (!allocated) return;\n\n  if (nb.origin_loc.level() < pmb->loc.level()) {\n    var = v->coarse_s.Get();\n  } else {\n    var = v->data.Get();\n  }\n\n  coords = pmb->coords;\n\n  auto elements = v->GetTopologicalElements();\n  if (v->IsSet(Metadata::Flux)) elements = GetFluxCorrectionElements(v, nb.offsets);\n  ntopological_elements = elements.size();\n\n  lcoord_trans.ncell = var.GetDim(1);\n  int idx{0};\n  for (auto el : elements) {\n    topo_idx[idx] = el;\n    if (idx_range_type == IndexRangeType::BoundaryExteriorRecv)\n      el = std::get<0>(lcoord_trans.InverseTransform(el));\n    idxer[idx] = CalcIndices(nb, pmb, v, el, idx_range_type, false, lcoord_trans);\n    idx++;\n  }\n}\n\nBndInfo BndInfo::GetSendBndInfo(MeshBlock *pmb, const NeighborBlock &nb,\n                                std::shared_ptr<Variable<Real>> v,\n                                CommBuffer<buf_pool_t<Real>::owner_t> *buf) {\n  auto idx_range_type = IndexRangeType::BoundaryInteriorSend;\n\n\n\n  if (nb.offsets.IsCell()) idx_range_type = IndexRangeType::InteriorSend;\n  return BndInfo(pmb, nb, v, buf, idx_range_type);\n}\n\nBndInfo BndInfo::GetSetBndInfo(MeshBlock *pmb, const NeighborBlock &nb,\n                               std::shared_ptr<Variable<Real>> v,\n                               CommBuffer<buf_pool_t<Real>::owner_t> *buf) {\n  auto idx_range_type = IndexRangeType::BoundaryExteriorRecv;\n\n\n\n  if (nb.offsets.IsCell()) idx_range_type = IndexRangeType::InteriorRecv;\n  BndInfo out(pmb, nb, v, buf, idx_range_type);\n\n  auto buf_state = buf->GetState();\n  if (buf_state == BufferState::received) {\n    out.buf_allocated = true;\n  } else if (buf_state == BufferState::received_null) {\n    out.buf_allocated = false;\n  } else {\n    printf(\"%i [rank: %i] -> %i [rank: %i] (Set %s) is in state %i.\\n\", nb.gid, nb.rank,\n           pmb->gid, Globals::my_rank, v->label().c_str(), static_cast<int>(buf_state));\n    PARTHENON_FAIL(\"Buffer should be in a received state.\");\n  }\n  return out;\n}\n\nProResInfo::ProResInfo(MeshBlock *pmb, const NeighborBlock &nb,\n                       std::shared_ptr<Variable<Real>> v) {\n  allocated = v->IsAllocated();\n  alloc_status = v->GetAllocationStatus();\n  ntopological_elements = v->GetTopologicalElements().size();\n  coords = pmb->coords;\n\n  if (pmb->pmr) coarse_coords = pmb->pmr->GetCoarseCoords();\n\n  fine = v->data.Get();\n  coarse = v->coarse_s.Get();\n}\n\nProResInfo ProResInfo::GetInteriorRestrict(MeshBlock *pmb, const NeighborBlock &nb,\n                                           std::shared_ptr<Variable<Real>> v) {\n  ProResInfo out(pmb, nb, v);\n  if (!out.allocated) return out;\n\n  if (nb.loc.level() < pmb->loc.level()) {\n    for (auto el : v->GetTopologicalElements()) {\n      out.IncludeTopoEl(el) = true;\n      out.idxer[static_cast<int>(el)] =\n          CalcIndices(nb, pmb, v, el, IndexRangeType::InteriorSend, true);\n    }\n    out.refinement_op = RefinementOp_t::Restriction;\n  }\n  return out;\n}\n\nProResInfo ProResInfo::GetInteriorProlongate(MeshBlock *pmb, const NeighborBlock &nb,\n                                             std::shared_ptr<Variable<Real>> v) {\n  ProResInfo out(pmb, nb, v);\n  if (!out.allocated) return out;\n\n  if (nb.loc.level() < pmb->loc.level()) {\n    for (auto el : v->GetTopologicalElements())\n      out.IncludeTopoEl(el) = true;\n    for (auto el : {TE::CC, TE::F1, TE::F2, TE::F3, TE::E1, TE::E2, TE::E3, TE::NN})\n      out.idxer[static_cast<int>(el)] =\n          CalcIndices(nb, pmb, v, el, IndexRangeType::InteriorRecv, true);\n    out.refinement_op = RefinementOp_t::Prolongation;\n  }\n  return out;\n}\n\nProResInfo ProResInfo::GetSend(MeshBlock *pmb, const NeighborBlock &nb,\n                               std::shared_ptr<Variable<Real>> v) {\n  ProResInfo out(pmb, nb, v);\n  if (!out.allocated) return out;\n\n  if (nb.origin_loc.level() < pmb->loc.level()) {\n    auto elements = v->GetTopologicalElements();\n    if (v->IsSet(Metadata::Flux)) elements = GetFluxCorrectionElements(v, nb.offsets);\n    for (auto el : elements) {\n      out.IncludeTopoEl(el) = true;\n      out.idxer[static_cast<int>(el)] =\n          CalcIndices(nb, pmb, v, el, IndexRangeType::BoundaryInteriorSend, true);\n    }\n    out.refinement_op = RefinementOp_t::Restriction;\n  }\n  return out;\n}\n\nProResInfo ProResInfo::GetSet(MeshBlock *pmb, const NeighborBlock &nb,\n                              std::shared_ptr<Variable<Real>> v) {\n  ProResInfo out(pmb, nb, v);\n\n\n\n\n  bool restricted = false;\n  int mylevel = pmb->loc.level();\n  if (mylevel > 0) {\n    for (const auto &nb : pmb->neighbors) {\n      restricted = restricted || (nb.origin_loc.level() == (mylevel - 1));\n    }\n  }\n\n  for (auto el : v->GetTopologicalElements()) {\n    out.IncludeTopoEl(el) = true;\n    if (nb.origin_loc.level() < mylevel) {\n      out.refinement_op = RefinementOp_t::Prolongation;\n    } else {\n      if (restricted) {\n        out.refinement_op = RefinementOp_t::Restriction;\n        out.idxer[static_cast<int>(el)] =\n            CalcIndices(nb, pmb, v, el, IndexRangeType::BoundaryExteriorRecv, true);\n      }\n    }\n  }\n\n\n\n\n\n\n\n\n\n\n  if (nb.origin_loc.level() < mylevel) {\n    for (auto el : {TE::CC, TE::F1, TE::F2, TE::F3, TE::E1, TE::E2, TE::E3, TE::NN})\n      out.idxer[static_cast<int>(el)] =\n          CalcIndices(nb, pmb, v, el, IndexRangeType::BoundaryExteriorRecv, true);\n  }\n  return out;\n}\n}\n\n'parthenon/src/bvals/neighbor_block.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef BVALS_NEIGHBOR_BLOCK_HPP_\n#define BVALS_NEIGHBOR_BLOCK_HPP_\n\n\n\n\n\n\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"parthenon_mpi.hpp\"\n\n#include \"defs.hpp\"\n#include \"mesh/forest/block_ownership.hpp\"\n#include \"mesh/forest/logical_coordinate_transformation.hpp\"\n#include \"mesh/forest/logical_location.hpp\"\n#include \"parthenon_arrays.hpp\"\n#include \"utils/cell_center_offsets.hpp\"\n#include \"utils/error_checking.hpp\"\n\nnamespace parthenon {\n\n\nclass Mesh;\nstruct RegionSize;\n\n\n\n\n\nstruct NeighborBlock {\n\n  int rank, gid;\n\n  int bufid, targetid;\n\n  LogicalLocation loc;\n\n  LogicalLocation origin_loc;\n\n\n  int fi1, fi2;\n\n  RegionSize block_size;\n\n  CellCentOffsets offsets;\n\n  block_ownership_t ownership;\n\n  forest::LogicalCoordinateTransformation lcoord_trans;\n\n  NeighborBlock();\n  NeighborBlock(Mesh *mesh, LogicalLocation loc, LogicalLocation origin_loc, int rank,\n                int gid, std::array<int, 3> offsets, int bid, int target_id, int ifi1,\n                int ifi2);\n};\n\n\n\n\n\n\nclass BufferID {\n\n  using NeighborIndexes = std::array<int, 5>;\n  std::vector<NeighborIndexes> nis;\n\n public:\n  BufferID(int dim, bool multilevel);\n\n  int GetID(int ox1, int ox2, int ox3, int f1, int f2) const {\n    NeighborIndexes in{ox1, ox2, ox3, f1, f2};\n    for (int i = 0; i < nis.size(); ++i) {\n      if (nis[i] == in) return i;\n    }\n    return -1;\n  }\n\n  int size() const { return nis.size(); }\n};\n\n}\n\n#endif\n",
        "gt": [
            "'parthenon/src/mesh/forest/logical_coordinate_transformation.hpp'",
            "'parthenon/src/bvals/neighbor_block.hpp'",
            "'parthenon/src/bvals/comms/bnd_info.cpp'"
        ]
    },
    {
        "files": [
            "'elaphureLink/thirdparty/asio/include/asio/generic/datagram_protocol.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/generic/basic_endpoint.hpp'",
            "'elaphureLink/test/misc/asio_1/asio_1.cpp'",
            "'elaphureLink/thirdparty/asio/include/asio.hpp'"
        ],
        "content": "'elaphureLink/thirdparty/asio/include/asio/generic/datagram_protocol.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_GENERIC_DATAGRAM_PROTOCOL_HPP\n#define ASIO_GENERIC_DATAGRAM_PROTOCOL_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n\n#include <typeinfo>\n#include \"asio/basic_datagram_socket.hpp\"\n#include \"asio/detail/socket_types.hpp\"\n#include \"asio/detail/throw_exception.hpp\"\n#include \"asio/generic/basic_endpoint.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace generic {\n\n\n\nclass datagram_protocol\n{\npublic:\n\n  datagram_protocol(int address_family, int socket_protocol)\n    : family_(address_family),\n      protocol_(socket_protocol)\n  {\n  }\n\n\n\n  template <typename Protocol>\n  datagram_protocol(const Protocol& source_protocol)\n    : family_(source_protocol.family()),\n      protocol_(source_protocol.protocol())\n  {\n    if (source_protocol.type() != type())\n    {\n      std::bad_cast ex;\n      asio::detail::throw_exception(ex);\n    }\n  }\n\n\n  int type() const ASIO_NOEXCEPT\n  {\n    return ASIO_OS_DEF(SOCK_DGRAM);\n  }\n\n\n  int protocol() const ASIO_NOEXCEPT\n  {\n    return protocol_;\n  }\n\n\n  int family() const ASIO_NOEXCEPT\n  {\n    return family_;\n  }\n\n\n  friend bool operator==(const datagram_protocol& p1,\n      const datagram_protocol& p2)\n  {\n    return p1.family_ == p2.family_ && p1.protocol_ == p2.protocol_;\n  }\n\n\n  friend bool operator!=(const datagram_protocol& p1,\n      const datagram_protocol& p2)\n  {\n    return !(p1 == p2);\n  }\n\n\n  typedef basic_endpoint<datagram_protocol> endpoint;\n\n\n  typedef basic_datagram_socket<datagram_protocol> socket;\n\nprivate:\n  int family_;\n  int protocol_;\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/generic/basic_endpoint.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_GENERIC_BASIC_ENDPOINT_HPP\n#define ASIO_GENERIC_BASIC_ENDPOINT_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include \"asio/generic/detail/endpoint.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\nnamespace generic {\n\n\n\ntemplate <typename Protocol>\nclass basic_endpoint\n{\npublic:\n\n  typedef Protocol protocol_type;\n\n\n\n#if defined(GENERATING_DOCUMENTATION)\n  typedef implementation_defined data_type;\n#else\n  typedef asio::detail::socket_addr_type data_type;\n#endif\n\n\n  basic_endpoint() ASIO_NOEXCEPT\n  {\n  }\n\n\n  basic_endpoint(const void* socket_address,\n      std::size_t socket_address_size, int socket_protocol = 0)\n    : impl_(socket_address, socket_address_size, socket_protocol)\n  {\n  }\n\n\n  template <typename Endpoint>\n  basic_endpoint(const Endpoint& endpoint)\n    : impl_(endpoint.data(), endpoint.size(), endpoint.protocol().protocol())\n  {\n  }\n\n\n  basic_endpoint(const basic_endpoint& other)\n    : impl_(other.impl_)\n  {\n  }\n\n#if defined(ASIO_HAS_MOVE)\n\n  basic_endpoint(basic_endpoint&& other)\n    : impl_(other.impl_)\n  {\n  }\n#endif\n\n\n  basic_endpoint& operator=(const basic_endpoint& other)\n  {\n    impl_ = other.impl_;\n    return *this;\n  }\n\n#if defined(ASIO_HAS_MOVE)\n\n  basic_endpoint& operator=(basic_endpoint&& other)\n  {\n    impl_ = other.impl_;\n    return *this;\n  }\n#endif\n\n\n  protocol_type protocol() const\n  {\n    return protocol_type(impl_.family(), impl_.protocol());\n  }\n\n\n  data_type* data()\n  {\n    return impl_.data();\n  }\n\n\n  const data_type* data() const\n  {\n    return impl_.data();\n  }\n\n\n  std::size_t size() const\n  {\n    return impl_.size();\n  }\n\n\n  void resize(std::size_t new_size)\n  {\n    impl_.resize(new_size);\n  }\n\n\n  std::size_t capacity() const\n  {\n    return impl_.capacity();\n  }\n\n\n  friend bool operator==(const basic_endpoint<Protocol>& e1,\n      const basic_endpoint<Protocol>& e2)\n  {\n    return e1.impl_ == e2.impl_;\n  }\n\n\n  friend bool operator!=(const basic_endpoint<Protocol>& e1,\n      const basic_endpoint<Protocol>& e2)\n  {\n    return !(e1.impl_ == e2.impl_);\n  }\n\n\n  friend bool operator<(const basic_endpoint<Protocol>& e1,\n      const basic_endpoint<Protocol>& e2)\n  {\n    return e1.impl_ < e2.impl_;\n  }\n\n\n  friend bool operator>(const basic_endpoint<Protocol>& e1,\n      const basic_endpoint<Protocol>& e2)\n  {\n    return e2.impl_ < e1.impl_;\n  }\n\n\n  friend bool operator<=(const basic_endpoint<Protocol>& e1,\n      const basic_endpoint<Protocol>& e2)\n  {\n    return !(e2 < e1);\n  }\n\n\n  friend bool operator>=(const basic_endpoint<Protocol>& e1,\n      const basic_endpoint<Protocol>& e2)\n  {\n    return !(e1 < e2);\n  }\n\nprivate:\n\n  asio::generic::detail::endpoint impl_;\n};\n\n}\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n\n'elaphureLink/test/misc/asio_1/asio_1.cpp'\n:﻿#include <iostream>\n#include <mutex>\n#include <condition_variable>\n\n#include <sdkddkver.h>\n#include \"thirdparty/asio/include/asio.hpp\"\n#include <windows.h>\n\nusing asio::ip::tcp;\n\nusing onSocketConnectCallbackType    = void (*)(const char *);\nusing onSocketDisconnectCallbackType = void (*)(const char *);\n\nclass SocketClient\n{\n    public:\n    SocketClient()\n        : is_running_(false),\n          connect_callback_(nullptr),\n          disconnect_callback_(nullptr)\n    {\n    }\n\n    ~SocketClient()\n    {\n\n        if (main_thread_.joinable()) {\n            main_thread_.detach();\n        }\n    }\n\n\n    void send_something(void *buffer, size_t length)\n    {\n        asio::write(get_socket(), asio::buffer(buffer, length));\n    }\n\n\n    int init_socket(std::string address, std::string port = \"3240\")\n    {\n        socket_.reset(nullptr);\n\n        io_context_ = std::make_unique<asio::io_context>();\n        tcp::resolver resolver(get_io_context());\n\n        socket_ = std::make_unique<asio::ip::tcp::socket>(get_io_context());\n\n        try {\n            endpoint_ = resolver.resolve(address, port);\n        } catch (std::exception &e) {\n            return -1;\n        }\n\n        return 0;\n    }\n\n\n    void kill()\n    {\n        socket_.get()->close();\n        io_context_.get()->stop();\n\n        Sleep(100);\n    }\n\n    int start()\n    {\n        using namespace std::chrono_literals;\n\n        std::unique_lock<std::mutex> lk(running_status_mutex_);\n        if (is_running_) {\n            return 0;\n        }\n\n        is_running_post_done_ = false;\n        is_running_           = true;\n\n        do_connect(endpoint_);\n\n        main_thread_ = std::thread([&]() {\n            try {\n                get_io_context().run();\n            } catch (std::exception &e) {\n                set_running_status(false, e.what());\n            }\n\n        });\n\n        running_cv_.wait(lk, [this]() { return is_running_post_done_; });\n\n        return !is_running_;\n    }\n\n    void wait_main_thread()\n    {\n        main_thread_.join();\n    }\n\n\n\n\n\n    public:\n    asio::io_context &get_io_context()\n    {\n        return *(io_context_.get());\n    }\n\n    asio::ip::tcp::socket &get_socket()\n    {\n        return *(socket_.get());\n    }\n\n    bool is_socket_running()\n    {\n        return is_running_;\n    }\n\n    void set_running_status(bool status, const std::string msg)\n    {\n        is_running_ = status;\n        if (status) {\n            if (connect_callback_) {\n                connect_callback_(msg.c_str());\n            }\n        } else {\n            if (disconnect_callback_) {\n                disconnect_callback_(msg.c_str());\n            }\n        }\n    }\n\n    void set_connect_callback(onSocketConnectCallbackType callback)\n    {\n        connect_callback_ = callback;\n    }\n\n    void set_disconnect_callback(onSocketDisconnectCallbackType callback)\n    {\n        disconnect_callback_ = callback;\n    }\n\n    private:\n    void close()\n    {\n        is_running_ = false;\n        asio::post(get_io_context(),\n                   [this]() {\n                       get_socket().close();\n                   });\n    }\n\n    void do_connect(const tcp::resolver::results_type &endpoints)\n    {\n        asio::async_connect(get_socket(), endpoints,\n                            [&](std::error_code ec, tcp::endpoint) {\n                                is_running_post_done_ = true;\n\n                                if (!ec) {\n\n\n                                    asio::ip::tcp::no_delay option(true);\n                                    get_socket().set_option(option);\n\n                                    set_running_status(true, \"Proxy started.\");\n                                    running_cv_.notify_all();\n                                    do_read_header();\n                                } else {\n                                    set_running_status(false, ec.message());\n                                    running_cv_.notify_all();\n                                    close();\n                                }\n                            });\n    }\n\n    void do_read_header()\n    {\n        asio::ip::tcp::no_delay option;\n        get_socket().get_option(option);\n        bool is_set = option.value();\n        assert(is_set == true);\n\n        try {\n            char data[10000];\n\n            asio::error_code error;\n            for (;;) {\n\n\n\n\n                size_t length = get_socket().read_some(asio::buffer(data), error);\n                if (error == asio::error::eof) {\n                    auto e = asio::system_error(error);\n                    set_running_status(false, e.what());\n                    break;\n                } else if (error) {\n                    throw asio::system_error(error);\n                }\n\n\n                asio::write(get_socket(), asio::buffer(data, length));\n\n                std::cout.write(data, length);\n            }\n        } catch (std::exception &e) {\n            set_running_status(false, e.what());\n        }\n    }\n\n\n    private:\n    bool                    is_running_;\n    bool                    is_running_post_done_;\n    std::mutex              running_status_mutex_;\n    std::condition_variable running_cv_;\n\n    std::unique_ptr<asio::io_context> io_context_;\n    std::unique_ptr<tcp::socket>      socket_;\n\n    tcp::resolver::results_type endpoint_;\n\n    std::thread main_thread_;\n\n    onSocketConnectCallbackType    connect_callback_;\n    onSocketDisconnectCallbackType disconnect_callback_;\n};\n\nclass ProxyManager\n{\n    public:\n    bool is_proxy_running()\n    {\n        if (client_.get()) {\n            return client_.get()->is_socket_running();\n        }\n\n        return false;\n    }\n\n    void set_on_proxy_connect_callback(onSocketConnectCallbackType callback)\n    {\n        if (client_.get()) {\n            client_.get()->set_connect_callback(callback);\n        }\n    }\n\n    void set_on_proxy_disconnect_callback(onSocketDisconnectCallbackType callback)\n    {\n        if (client_.get()) {\n            client_.get()->set_disconnect_callback(callback);\n        }\n    }\n\n    int start_with_address(std::string address)\n    {\n        stop();\n        client_ = std::make_unique<SocketClient>();\n\n\n        int ret = client_.get()->init_socket(address, \"3240\");\n        if (ret != 0) {\n            return ret;\n        }\n\n        return client_.get()->start();\n    }\n\n    void stop()\n    {\n        if (client_.get()) {\n            client_.get()->kill();\n        }\n        client_.reset(nullptr);\n    }\n\n    private:\n    std::unique_ptr<SocketClient> client_;\n};\n\nProxyManager kManager;\n\n\nextern \"C\" __declspec(dllexport) int start_proxy_with_address(char *address)\n{\n    return kManager.start_with_address(address);\n}\n\nextern \"C\" __declspec(dllexport) void stop_proxy()\n{\n    kManager.stop();\n}\n\n\nextern \"C\" __declspec(dllexport) void memory_leak_test()\n{\n    SocketClient c;\n\n    int i = 0;\n    while (i++ < 50) {\n        c.init_socket(\"127.0.0.1\", \"88\");\n        c.start();\n        c.wait_main_thread();\n    }\n}\n\nextern \"C\" __declspec(dllexport) int invalid_url_test(char *address, char *port)\n{\n    SocketClient c;\n\n    int ret = c.init_socket(address, port);\n    if (ret != 0) {\n        return ret;\n    }\n\n    ret = c.start();\n    Sleep(5 * 1000);\n    c.kill();\n    return ret;\n}\n\nvoid internal_invalid_url_test()\n{\n    char address[] = \"www.bing.com\";\n    char port[]    = \"80\";\n\n    invalid_url_test(const_cast<char *>(\"127.0.0.1\"), const_cast<char *>(\"3240\"));\n    invalid_url_test(const_cast<char *>(\"www.bing.com\"), const_cast<char *>(\"80\"));\n    invalid_url_test(const_cast<char *>(\"127.0.0.1\"), const_cast<char *>(\"3240\"));\n    invalid_url_test(const_cast<char *>(\"127.0.0.1\"), const_cast<char *>(\"80\"));\n    invalid_url_test(const_cast<char *>(\"1111111\"), const_cast<char *>(\"3240\"));\n    invalid_url_test(const_cast<char *>(\"1.01.1.1\"), const_cast<char *>(\"3240\"));\n    invalid_url_test(const_cast<char *>(\"1.0x01.1.1\"), const_cast<char *>(\"3240\"));\n\n    Sleep(INFINITE);\n}\n\nextern \"C\" __declspec(dllexport) void tcp_no_delay_test()\n{\n    SocketClient c;\n\n    char address[] = \"127.0.0.1\";\n    char port[]    = \"3240\";\n\n    int ret = c.init_socket(address, port);\n    if (ret != 0) {\n        throw \"connect failed\";\n    }\n\n    ret = c.start();\n    if (ret != 0) {\n        throw \"connect failed\";\n    }\n\n    char buffer[] = \"123\";\n    try {\n        c.send_something(buffer, 3);\n        c.send_something(buffer, 3);\n    } catch (std::exception &e) {\n        std::string msg = e.what();\n        throw msg;\n    }\n\n    Sleep(3000);\n    return;\n}\n\n\nint main()\n{\n    return 0;\n}\n'elaphureLink/thirdparty/asio/include/asio.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_HPP\n#define ASIO_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/associated_allocator.hpp\"\n#include \"asio/associated_executor.hpp\"\n#include \"asio/associated_cancellation_slot.hpp\"\n#include \"asio/associator.hpp\"\n#include \"asio/async_result.hpp\"\n#include \"asio/awaitable.hpp\"\n#include \"asio/basic_datagram_socket.hpp\"\n#include \"asio/basic_deadline_timer.hpp\"\n#include \"asio/basic_file.hpp\"\n#include \"asio/basic_io_object.hpp\"\n#include \"asio/basic_random_access_file.hpp\"\n#include \"asio/basic_raw_socket.hpp\"\n#include \"asio/basic_readable_pipe.hpp\"\n#include \"asio/basic_seq_packet_socket.hpp\"\n#include \"asio/basic_serial_port.hpp\"\n#include \"asio/basic_signal_set.hpp\"\n#include \"asio/basic_socket.hpp\"\n#include \"asio/basic_socket_acceptor.hpp\"\n#include \"asio/basic_socket_iostream.hpp\"\n#include \"asio/basic_socket_streambuf.hpp\"\n#include \"asio/basic_stream_file.hpp\"\n#include \"asio/basic_stream_socket.hpp\"\n#include \"asio/basic_streambuf.hpp\"\n#include \"asio/basic_waitable_timer.hpp\"\n#include \"asio/basic_writable_pipe.hpp\"\n#include \"asio/bind_allocator.hpp\"\n#include \"asio/bind_cancellation_slot.hpp\"\n#include \"asio/bind_executor.hpp\"\n#include \"asio/buffer.hpp\"\n#include \"asio/buffer_registration.hpp\"\n#include \"asio/buffered_read_stream_fwd.hpp\"\n#include \"asio/buffered_read_stream.hpp\"\n#include \"asio/buffered_stream_fwd.hpp\"\n#include \"asio/buffered_stream.hpp\"\n#include \"asio/buffered_write_stream_fwd.hpp\"\n#include \"asio/buffered_write_stream.hpp\"\n#include \"asio/buffers_iterator.hpp\"\n#include \"asio/cancellation_signal.hpp\"\n#include \"asio/cancellation_state.hpp\"\n#include \"asio/cancellation_type.hpp\"\n#include \"asio/co_spawn.hpp\"\n#include \"asio/completion_condition.hpp\"\n#include \"asio/compose.hpp\"\n#include \"asio/connect.hpp\"\n#include \"asio/connect_pipe.hpp\"\n#include \"asio/coroutine.hpp\"\n#include \"asio/deadline_timer.hpp\"\n#include \"asio/defer.hpp\"\n#include \"asio/detached.hpp\"\n#include \"asio/dispatch.hpp\"\n#include \"asio/error.hpp\"\n#include \"asio/error_code.hpp\"\n#include \"asio/execution.hpp\"\n#include \"asio/execution/allocator.hpp\"\n#include \"asio/execution/any_executor.hpp\"\n#include \"asio/execution/blocking.hpp\"\n#include \"asio/execution/blocking_adaptation.hpp\"\n#include \"asio/execution/bulk_execute.hpp\"\n#include \"asio/execution/bulk_guarantee.hpp\"\n#include \"asio/execution/connect.hpp\"\n#include \"asio/execution/context.hpp\"\n#include \"asio/execution/context_as.hpp\"\n#include \"asio/execution/execute.hpp\"\n#include \"asio/execution/executor.hpp\"\n#include \"asio/execution/invocable_archetype.hpp\"\n#include \"asio/execution/mapping.hpp\"\n#include \"asio/execution/occupancy.hpp\"\n#include \"asio/execution/operation_state.hpp\"\n#include \"asio/execution/outstanding_work.hpp\"\n#include \"asio/execution/prefer_only.hpp\"\n#include \"asio/execution/receiver.hpp\"\n#include \"asio/execution/receiver_invocation_error.hpp\"\n#include \"asio/execution/relationship.hpp\"\n#include \"asio/execution/schedule.hpp\"\n#include \"asio/execution/scheduler.hpp\"\n#include \"asio/execution/sender.hpp\"\n#include \"asio/execution/set_done.hpp\"\n#include \"asio/execution/set_error.hpp\"\n#include \"asio/execution/set_value.hpp\"\n#include \"asio/execution/start.hpp\"\n#include \"asio/execution_context.hpp\"\n#include \"asio/executor.hpp\"\n#include \"asio/executor_work_guard.hpp\"\n#include \"asio/file_base.hpp\"\n#include \"asio/generic/basic_endpoint.hpp\"\n#include \"asio/generic/datagram_protocol.hpp\"\n#include \"asio/generic/raw_protocol.hpp\"\n#include \"asio/generic/seq_packet_protocol.hpp\"\n#include \"asio/generic/stream_protocol.hpp\"\n#include \"asio/handler_alloc_hook.hpp\"\n#include \"asio/handler_continuation_hook.hpp\"\n#include \"asio/handler_invoke_hook.hpp\"\n#include \"asio/high_resolution_timer.hpp\"\n#include \"asio/io_context.hpp\"\n#include \"asio/io_context_strand.hpp\"\n#include \"asio/io_service.hpp\"\n#include \"asio/io_service_strand.hpp\"\n#include \"asio/ip/address.hpp\"\n#include \"asio/ip/address_v4.hpp\"\n#include \"asio/ip/address_v4_iterator.hpp\"\n#include \"asio/ip/address_v4_range.hpp\"\n#include \"asio/ip/address_v6.hpp\"\n#include \"asio/ip/address_v6_iterator.hpp\"\n#include \"asio/ip/address_v6_range.hpp\"\n#include \"asio/ip/network_v4.hpp\"\n#include \"asio/ip/network_v6.hpp\"\n#include \"asio/ip/bad_address_cast.hpp\"\n#include \"asio/ip/basic_endpoint.hpp\"\n#include \"asio/ip/basic_resolver.hpp\"\n#include \"asio/ip/basic_resolver_entry.hpp\"\n#include \"asio/ip/basic_resolver_iterator.hpp\"\n#include \"asio/ip/basic_resolver_query.hpp\"\n#include \"asio/ip/host_name.hpp\"\n#include \"asio/ip/icmp.hpp\"\n#include \"asio/ip/multicast.hpp\"\n#include \"asio/ip/resolver_base.hpp\"\n#include \"asio/ip/resolver_query_base.hpp\"\n#include \"asio/ip/tcp.hpp\"\n#include \"asio/ip/udp.hpp\"\n#include \"asio/ip/unicast.hpp\"\n#include \"asio/ip/v6_only.hpp\"\n#include \"asio/is_applicable_property.hpp\"\n#include \"asio/is_executor.hpp\"\n#include \"asio/is_read_buffered.hpp\"\n#include \"asio/is_write_buffered.hpp\"\n#include \"asio/local/basic_endpoint.hpp\"\n#include \"asio/local/connect_pair.hpp\"\n#include \"asio/local/datagram_protocol.hpp\"\n#include \"asio/local/stream_protocol.hpp\"\n#include \"asio/multiple_exceptions.hpp\"\n#include \"asio/packaged_task.hpp\"\n#include \"asio/placeholders.hpp\"\n#include \"asio/posix/basic_descriptor.hpp\"\n#include \"asio/posix/basic_stream_descriptor.hpp\"\n#include \"asio/posix/descriptor.hpp\"\n#include \"asio/posix/descriptor_base.hpp\"\n#include \"asio/posix/stream_descriptor.hpp\"\n#include \"asio/post.hpp\"\n#include \"asio/prefer.hpp\"\n#include \"asio/query.hpp\"\n#include \"asio/random_access_file.hpp\"\n#include \"asio/read.hpp\"\n#include \"asio/read_at.hpp\"\n#include \"asio/read_until.hpp\"\n#include \"asio/readable_pipe.hpp\"\n#include \"asio/recycling_allocator.hpp\"\n#include \"asio/redirect_error.hpp\"\n#include \"asio/registered_buffer.hpp\"\n#include \"asio/require.hpp\"\n#include \"asio/require_concept.hpp\"\n#include \"asio/serial_port.hpp\"\n#include \"asio/serial_port_base.hpp\"\n#include \"asio/signal_set.hpp\"\n#include \"asio/socket_base.hpp\"\n#include \"asio/static_thread_pool.hpp\"\n#include \"asio/steady_timer.hpp\"\n#include \"asio/strand.hpp\"\n#include \"asio/stream_file.hpp\"\n#include \"asio/streambuf.hpp\"\n#include \"asio/system_context.hpp\"\n#include \"asio/system_error.hpp\"\n#include \"asio/system_executor.hpp\"\n#include \"asio/system_timer.hpp\"\n#include \"asio/this_coro.hpp\"\n#include \"asio/thread.hpp\"\n#include \"asio/thread_pool.hpp\"\n#include \"asio/time_traits.hpp\"\n#include \"asio/use_awaitable.hpp\"\n#include \"asio/use_future.hpp\"\n#include \"asio/uses_executor.hpp\"\n#include \"asio/version.hpp\"\n#include \"asio/wait_traits.hpp\"\n#include \"asio/windows/basic_object_handle.hpp\"\n#include \"asio/windows/basic_overlapped_handle.hpp\"\n#include \"asio/windows/basic_random_access_handle.hpp\"\n#include \"asio/windows/basic_stream_handle.hpp\"\n#include \"asio/windows/object_handle.hpp\"\n#include \"asio/windows/overlapped_handle.hpp\"\n#include \"asio/windows/overlapped_ptr.hpp\"\n#include \"asio/windows/random_access_handle.hpp\"\n#include \"asio/windows/stream_handle.hpp\"\n#include \"asio/writable_pipe.hpp\"\n#include \"asio/write.hpp\"\n#include \"asio/write_at.hpp\"\n\n#endif\n",
        "gt": [
            "'elaphureLink/thirdparty/asio/include/asio/generic/basic_endpoint.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/generic/datagram_protocol.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio.hpp'",
            "'elaphureLink/test/misc/asio_1/asio_1.cpp'"
        ]
    },
    {
        "files": [
            "'DataConfig/DataConfig/Source/DataConfigTests/Private/DcTestProperty.cpp'",
            "'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyTypes.h'",
            "'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyWriter.h'"
        ],
        "content": "'DataConfig/DataConfig/Source/DataConfigTests/Private/DcTestProperty.cpp'\n:#include \"DcTestProperty.h\"\n#include \"DataConfig/Extra/Misc/DcTestCommon.h\"\n#include \"DataConfig/DcTypes.h\"\n#include \"DataConfig/Property/DcPropertyReader.h\"\n#include \"DataConfig/Property/DcPropertyWriter.h\"\n#include \"DataConfig/Property/DcPropertyUtils.h\"\n#include \"DataConfig/Automation/DcAutomation.h\"\n#include \"DataConfig/Automation/DcAutomationUtils.h\"\n\nvoid FDcTestStruct1::MakeFixture()\n{\n\tBoolField = true;\n\tNameField = TEXT(\"AName\");\n\tStringField = TEXT(\"AStr\");\n\tTextField = FText::FromString(TEXT(\"AText\"));\n\tEnumField = EDcTestEnum1::Tard;\n\n\tFloatField = 17.5f;\n\tDoubleField = 19.375;\n\n\tInt8Field = -43;\n\tInt16Field = -2243;\n\tInt32Field = -23415;\n\tInt64Field = -1524523;\n\n\tUInt8Field = 213;\n\tUInt16Field = 2243,\n\tUInt32Field = 23415;\n\tUInt64Field = 1524523;\n}\n\nvoid FDcTestStruct3::MakeFixtureNoStructMap()\n{\n\tStringArray.Add(TEXT(\"Foo\"));\n\tStringArray.Add(TEXT(\"Bar\"));\n\tStringArray.Add(TEXT(\"Baz\"));\n\n\tStringSet.Add(TEXT(\"Doo\"));\n\tStringSet.Add(TEXT(\"Dar\"));\n\tStringSet.Add(TEXT(\"Daz\"));\n\n\tStringMap.Add(TEXT(\"One\"), TEXT(\"1\"));\n\tStringMap.Add(TEXT(\"Two\"), TEXT(\"2\"));\n\tStringMap.Add(TEXT(\"Three\"), TEXT(\"3\"));\n\n\tStructArray.Add({TEXT(\"One\"), 1});\n\tStructArray.Add({TEXT(\"Two\"), 2});\n\tStructArray.Add({TEXT(\"Three\"), 3});\n\n\tStructSet.Add({TEXT(\"One\"), 1});\n\tStructSet.Add({TEXT(\"Two\"), 2});\n\tStructSet.Add({TEXT(\"Three\"), 3});\n}\n\nvoid FDcTestStruct3::MakeFixtureFull()\n{\n\tMakeFixtureNoStructMap();\n\n\tStructMap.Add({TEXT(\"One\"), 1}, {TEXT(\"Uno\"), 1});\n\tStructMap.Add({TEXT(\"Two\"), 2}, {TEXT(\"Dos\"), 2});\n\tStructMap.Add({TEXT(\"Three\"), 3}, {TEXT(\"Tres\"), 3});\n}\n\n\nint UDcTestDelegateClass1::ReturnOne(int Int) { return Int; }\nvoid UDcTestDelegateClass1::ReturnNone(int Int) {  }\n\nDC_TEST(\"DataConfig.Core.Property.Primitive1\")\n{\n\tFDcTestStruct1 Source;\n\tSource.MakeFixture();\n\n\tFDcTestStruct1 Dest;\n\n\tFDcPropertyDatum SourceDatum(&Source);\n\tFDcPropertyDatum DestDatum(&Dest);\n\n\tUTEST_OK(\"FDcTestStruct1 roundtrip\", DcPropertyPipeVisit(SourceDatum, DestDatum));\n\tUTEST_OK(\"FDcTestStruct1 roundtrip equal\", DcAutomationUtils::TestReadDatumEqual(SourceDatum, DestDatum));\n\n\treturn true;\n}\n\nDC_TEST(\"DataConfig.Core.Property.Primitive2\")\n{\n\tFDcTestStruct2 Source;\n\tUDcTestDelegateClass1* DelegateObj = NewObject<UDcTestDelegateClass1>();\n\tUObject* InterfaceObj = NewObject<UDcTestInterface1Beta>();\n\n\tSource.ClassField = UDcTestDelegateClass1::StaticClass();\n\tSource.WeakObjetField = DelegateObj;\n\tSource.LazyObjectField = DelegateObj;\n\tSource.SoftObjectField = DelegateObj;\n\tSource.SoftClassField = UDcTestDelegateClass1::StaticClass();\n\tSource.InterfaceField = InterfaceObj;\n\tSource.FieldPathField = DcPropertyUtils::FirstEffectiveProperty(FDcTestStruct1::StaticStruct()->PropertyLink);\n\n\tSource.DelegateField.BindDynamic(DelegateObj, &UDcTestDelegateClass1::ReturnOne);\n\tSource.DynMulticastField.AddDynamic(DelegateObj, &UDcTestDelegateClass1::ReturnNone);\n\n\tFDcTestStruct2 Dest;\n\n\tFDcPropertyDatum SourceDatum(&Source);\n\tFDcPropertyDatum DestDatum(&Dest);\n\n\tUTEST_OK(\"FDcTestStruct2 roundtrip\", DcPropertyPipeVisit(SourceDatum, DestDatum));\n\tUTEST_OK(\"FDcTestStruct2 roundtrip equal\", DcAutomationUtils::TestReadDatumEqual(SourceDatum, DestDatum));\n\n\n\tif (0)\n\t{\n\t\tFDcReader Reader;\n\t\tReader.ReadWeakObjectField(&Source.WeakObjetField).Ok();\n\t\tReader.ReadLazyObjectField(&Source.LazyObjectField).Ok();\n\t\tReader.ReadSoftObjectField(&Source.SoftObjectField).Ok();\n\t\tReader.ReadSoftClassField(&Source.SoftClassField).Ok();\n\t\tReader.ReadInterfaceField(&Source.InterfaceField).Ok();\n\t\tReader.ReadDelegate(&Source.DelegateField).Ok();\n\t\tReader.ReadMulticastInlineDelegate(&Source.DynMulticastField).Ok();\n\n\t\tFDcWriter Writer;\n\t\tWriter.WriteWeakObjectField(Source.WeakObjetField).Ok();\n\t\tWriter.WriteLazyObjectField(Source.LazyObjectField).Ok();\n\t\tWriter.WriteSoftObjectField(Source.SoftObjectField).Ok();\n\t\tWriter.WriteSoftClassField(Source.SoftClassField).Ok();\n\t\tWriter.WriteInterfaceField(Source.InterfaceField).Ok();\n\t\tWriter.WriteDelegate(Source.DelegateField).Ok();\n\t\tWriter.WriteMulticastInlineDelegate(Source.DynMulticastField).Ok();\n\t}\n\n\treturn true;\n}\n\nDC_TEST(\"DataConfig.Core.Property.Primitive_SparseDelegate\")\n{\n\tUDcTestDelegateClass1* Source = NewObject<UDcTestDelegateClass1>();\n\n\tSource->SparseCallback1.AddDynamic(Source, &UDcTestDelegateClass1::ReturnNone);\n\n\tUDcTestDelegateClass1* Dest = NewObject<UDcTestDelegateClass1>();\n\tUTEST_FALSE(\"Sparse delegate was not bound\", Dest->SparseCallback1.IsBound());\n\n\tFDcPropertyDatum SourceDatum(UDcTestDelegateClass1::StaticClass(), Source);\n\tFDcPropertyDatum DestDatum(UDcTestDelegateClass1::StaticClass(), Dest);\n\n\tUTEST_OK(\"UDcTestDelegateClass1 roundtrip\", DcPropertyPipeVisit(SourceDatum, DestDatum));\n\tUTEST_OK(\"UDcTestDelegateClass1 roundtrip equal\", DcAutomationUtils::TestReadDatumEqual(SourceDatum, DestDatum));\n\n\tUTEST_TRUE(\"Sparse delegate is bound\", Dest->SparseCallback1.IsBound());\n\n\tDest->SparseCallback1.Clear();\n\tUTEST_FALSE(\"Sparse delegate was not bound\", Dest->SparseCallback1.IsBound());\n\n\tUDcTestDelegateClass1* Tmp = NewObject<UDcTestDelegateClass1>();\n\n\tFDcPropertyReader Reader(SourceDatum);\n\tFDcPropertyWriter Writer(DestDatum);\n\n\tUTEST_OK(\"Try ReadSparseDelegateField\", Reader.ReadClassRoot());\n\tUTEST_OK(\"Try WriteSparseDelegateField\", Writer.WriteClassRoot());\n\n\tUTEST_OK(\"Try ReadSparseDelegateField\", Reader.ReadName(nullptr));\n\tUTEST_OK(\"Try WriteSparseDelegateField\", Writer.WriteName(TEXT(\"SparseCallback1\")));\n\n\tUTEST_OK(\"Try ReadSparseDelegateField\", Reader.ReadSparseDelegateField(&Tmp->SparseCallback1));\n\tUTEST_OK(\"Try WriteSparseDelegateField\", Writer.WriteSparseDelegateField(Tmp->SparseCallback1));\n\n\tUTEST_TRUE(\"Sparse delegate is bound\", Dest->SparseCallback1.IsBound());\n\n\treturn true;\n}\n\nDC_TEST(\"DataConfig.Core.Property.Containers\")\n{\n\tFDcTestStruct3 Source;\n\tSource.MakeFixtureFull();\n\n\tFDcTestStruct3 Dest;\n\n\tFDcPropertyDatum SourceDatum(&Source);\n\tFDcPropertyDatum DestDatum(&Dest);\n\n\tUTEST_OK(\"FDcTestStruct3 roundtrip\", DcPropertyPipeVisit(SourceDatum, DestDatum));\n\tUTEST_OK(\"FDcTestStruct3 roundtrip equal\", DcAutomationUtils::TestReadDatumEqual(SourceDatum, DestDatum));\n\n\treturn true;\n}\n\n\nDC_TEST(\"DataConfig.Core.Property.ObjectReference\")\n{\n\tFDcTestStruct4 Source;\n\n\tUDcShapeBox* Box = NewObject<UDcShapeBox>();\n\tBox->ShapeName = TEXT(\"MyBox\");\n\tBox->Height = 12.3f;\n\tBox->Width = 23.4f;\n\n\tSource.InlineObjectField1 = Box;\n\tSource.InlineObjectField2 = nullptr;\n\n\tSource.NormalObjectField1 = NewObject<UDcTestClass1>();\n\tSource.NormalObjectField1->IntField = 123;\n\tSource.NormalObjectField1->StrField = TEXT(\"Foo\");\n\tSource.NormalObjectField2 = nullptr;\n\n\tFDcTestStruct4 Dest;\n\n\n\tDest.InlineObjectField1 = NewObject<UDcShapeBox>();\n\tDest.InlineObjectField2 = nullptr;\n\n\tFDcPropertyDatum SourceDatum(&Source);\n\tFDcPropertyDatum DestDatum(&Dest);\n\n\tUTEST_OK(\"FDcTestStruct4 roundtrip\", DcPropertyPipeVisit(SourceDatum, DestDatum));\n\tUTEST_OK(\"FDcTestStruct4 roundtrip equal\", DcAutomationUtils::TestReadDatumEqual(SourceDatum, DestDatum));\n\n\treturn true;\n}\n\n\nDC_TEST(\"DataConfig.Core.Property.Blob\")\n{\n\tFDcTestStruct_Blob Source;\n\n\tSource.BlobField1.Add(1);\n\tSource.BlobField1.Add(2);\n\tSource.BlobField1.Add(3);\n\n\tSource.BlobField2.Add(253);\n\tSource.BlobField2.Add(254);\n\tSource.BlobField2.Add(255);\n\n\tFDcTestStruct_Blob Dest;\n\n\tFDcPropertyDatum SourceDatum(&Source);\n\tFDcPropertyDatum DestDatum(&Dest);\n\n\tFDcPropertyReader Reader(SourceDatum);\n\tFDcPropertyWriter Writer(DestDatum);\n\n\t{\n\n\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Reader.ReadStructRoot());\n\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Writer.WriteStructRoot());\n\n\t\t{\n\t\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Reader.ReadName(nullptr));\n\t\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Writer.WriteName(TEXT(\"BlobField1\")));\n\n\t\t\tFDcBlobViewData BlobView;\n\t\t\tbool bCanCoerce;\n\t\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Reader.Coercion(EDcDataEntry::Blob, &bCanCoerce));\n\t\t\tUTEST_TRUE(\"FDcTestStruct_Blob roundtrip\", bCanCoerce);\n\t\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Reader.ReadBlob(&BlobView));\n\n\t\t\tbool bWriteOk;\n\t\t\tUTEST_TRUE(\"FDcTestStruct_Blob roundtrip\", Writer.PeekWrite(EDcDataEntry::Blob, &bWriteOk).Ok() && bWriteOk);\n\t\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Writer.WriteBlob(BlobView));\n\t\t}\n\n\t\t{\n\t\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Reader.ReadName(nullptr));\n\t\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Writer.WriteName(TEXT(\"BlobField2\")));\n\n\t\t\tFDcBlobViewData BlobView;\n\t\t\tbool bCanCoerce;\n\t\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Reader.Coercion(EDcDataEntry::Blob, &bCanCoerce));\n\t\t\tUTEST_TRUE(\"FDcTestStruct_Blob roundtrip\", bCanCoerce);\n\t\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Reader.ReadBlob(&BlobView));\n\n\t\t\tbool bWriteOk;\n\t\t\tUTEST_TRUE(\"FDcTestStruct_Blob roundtrip\", Writer.PeekWrite(EDcDataEntry::Blob, &bWriteOk).Ok() && bWriteOk);\n\t\t\tUTEST_OK(\"FDcTestStruct_Blob roundtrip\", Writer.WriteBlob(BlobView));\n\t\t}\n\t}\n\n\tUTEST_OK(\"FDcTestStruct_Blob roundtrip equal\", DcAutomationUtils::TestReadDatumEqual(SourceDatum, DestDatum));\n\n\treturn true;\n}\n\nDC_TEST(\"DataConfig.Core.Property.FieldScalarRoots\")\n{\n\tFDcTestStruct1 Source;\n\tSource.MakeFixture();\n\n\tFDcTestStruct1 Dest;\n\n\tFDcPropertyDatum SourceDatum(&Source);\n\tFDcPropertyDatum DestDatum(&Dest);\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"BoolField\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"BoolField\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"NameField\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"NameField\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"StringField\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"StringField\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"TextField\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"TextField\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"EnumField\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"EnumField\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"FloatField\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"FloatField\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"DoubleField\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"DoubleField\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"Int8Field\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"Int8Field\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"Int16Field\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"Int16Field\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"Int32Field\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"Int32Field\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"Int64Field\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"Int64Field\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"UInt8Field\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"UInt8Field\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"UInt16Field\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"UInt16Field\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"UInt32Field\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"UInt32Field\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"UInt64Field\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"UInt64Field\"))\n\t));\n\n\tUTEST_OK(\"Scalar Root Roundtrip\", DcAutomationUtils::TestReadDatumEqual(SourceDatum, DestDatum));\n\n\treturn true;\n}\n\n\nDC_TEST(\"DataConfig.Core.Property.Containers2\")\n{\n\tFDcTestStruct3 Source;\n\n\tSource.StringArray.Add(TEXT(\"Foo\"));\n\tSource.StringArray.Add(TEXT(\"Bar\"));\n\tSource.StringArray.Add(TEXT(\"Baz\"));\n\n\tSource.StringSet.Add(TEXT(\"Foo\"));\n\tSource.StringSet.Add(TEXT(\"Bar\"));\n\tSource.StringSet.Add(TEXT(\"Baz\"));\n\n\tSource.StringMap.Add(TEXT(\"1\"), TEXT(\"One\"));\n\tSource.StringMap.Add(TEXT(\"2\"), TEXT(\"Two\"));\n\tSource.StringMap.Add(TEXT(\"3\"), TEXT(\"Three\"));\n\n\tSource.StructArray.Add({TEXT(\"One\"), 1});\n\tSource.StructArray.Add({TEXT(\"Two\"), 2});\n\tSource.StructArray.Add({TEXT(\"Three\"), 3});\n\n\tSource.StructSet.Add({TEXT(\"One\"), 1});\n\tSource.StructSet.Add({TEXT(\"Two\"), 2});\n\tSource.StructSet.Add({TEXT(\"Three\"), 3});\n\n\tSource.StructMap.Add({TEXT(\"One\"), 1}, {TEXT(\"Uno\"), 1});\n\tSource.StructMap.Add({TEXT(\"Two\"), 2}, {TEXT(\"Dos\"), 2});\n\tSource.StructMap.Add({TEXT(\"Three\"), 3}, {TEXT(\"Tres\"), 3});\n\n\tFDcTestStruct3 Dest;\n\n\tFDcPropertyDatum SourceDatum(&Source);\n\tFDcPropertyDatum DestDatum(&Dest);\n\n\tUTEST_OK(\"Container Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"StringArray\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"StringArray\"))\n\t));\n\n\tUTEST_OK(\"Container Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"StringSet\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"StringSet\"))\n\t));\n\n\tUTEST_OK(\"Container Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"StringMap\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"StringMap\"))\n\t));\n\n\tUTEST_OK(\"Container Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"StructArray\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"StructArray\"))\n\t));\n\n\tUTEST_OK(\"Container Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"StructSet\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"StructSet\"))\n\t));\n\n\tUTEST_OK(\"Container Root Roundtrip\", DcPropertyPipeVisit(\n\t\tDcAutomationUtils::TryGetMemberDatum(SourceDatum, TEXT(\"StructMap\")),\n\t\tDcAutomationUtils::TryGetMemberDatum(DestDatum, TEXT(\"StructMap\"))\n\t));\n\n\tUTEST_OK(\"Container Root Roundtrip\", DcAutomationUtils::TestReadDatumEqual(SourceDatum, DestDatum));\n\n\treturn true;\n}\n\n\n\n'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyTypes.h'\n:#pragma once\n\n#include \"DataConfig/DcTypes.h\"\n#include \"UObject/UnrealType.h\"\n\nusing FDcProcessPropertyPredicateSignature = bool(*)(FProperty* Property);\nDECLARE_DELEGATE_RetVal_OneParam(bool, FDcProcessPropertyPredicateDelegate, FProperty*);\n\nusing FDcExpandObjectPredicateSignature = bool(*)(FObjectProperty* ObjectProperty);\nDECLARE_DELEGATE_RetVal_OneParam(bool, FDcExpandObjectPredicateDelegate, FObjectProperty*);\n\nstruct DATACONFIGCORE_API FDcPropertyConfig\n{\n\tFDcProcessPropertyPredicateDelegate ProcessPropertyPredicate;\n\tFDcExpandObjectPredicateDelegate ExpandObjectPredicate;\n\n\tstatic FDcPropertyConfig MakeDefault();\n\tstatic FDcPropertyConfig MakeNoExpandObject();\n\n\tFDcResult Prepare();\n\n\tbool ShouldProcessProperty(FProperty* Property);\n\tFProperty* NextProcessProperty(FProperty* Property);\n\tFProperty* FirstProcessProperty(FProperty* Property);\n\tFProperty* NextProcessPropertyByName(UStruct* Struct, FProperty* InProperty, const FName& Name);\n\tFProperty* FindProcessPropertyByName(UStruct* Struct, const FName& Name);\n\n\tbool ShouldExpandObject(FObjectProperty* ObjectProperty);\n};\n\n\n\n'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyWriter.h'\n:#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"DataConfig/Property/DcPropertyDatum.h\"\n#include \"DataConfig/Property/DcPropertyTypes.h\"\n#include \"DataConfig/Writer/DcWriter.h\"\n#include \"DataConfig/Diagnostic/DcDiagnostic.h\"\n\nnamespace DcPropertyWriterDetails\n{\n\tstruct FWriteState\n\t{\n\t\tusing ImplStorageType = TAlignedBytes<96, MIN_ALIGNMENT>;\n\t\tImplStorageType ImplStorage;\n\t};\n}\n\nstruct DATACONFIGCORE_API FDcPropertyWriter : public FDcWriter, private FNoncopyable\n{\n\tFDcPropertyWriter();\n\tFDcPropertyWriter(FDcPropertyDatum Datum);\n\n\tenum EArrayWriter { Array };\n\tenum ESetWriter { Set };\n\n\tFDcPropertyWriter(EArrayWriter, FProperty* InInnerProperty, void* InArray, EArrayPropertyFlags InArrayFlags = EArrayPropertyFlags::None);\n\tFDcPropertyWriter(ESetWriter, FProperty* InElementProperty, void* InSet);\n\tFDcPropertyWriter(FProperty* InKeyProperty, FProperty* InValueProperty, void* InMap, EMapPropertyFlags InMapFlags = EMapPropertyFlags::None);\n\n\tFDcResult PeekWrite(EDcDataEntry Next, bool* bOutOk) override;\n\n\tFDcResult WriteNone() override;\n\tFDcResult WriteBool(bool Value) override;\n\tFDcResult WriteName(const FName& Value) override;\n\tFDcResult WriteString(const FString& Value) override;\n\tFDcResult WriteText(const FText& Value) override;\n\tFDcResult WriteEnum(const FDcEnumData& Value) override;\n\n\tFDcResult WriteStructRootAccess(FDcStructAccess& Access) override;\n\tFDcResult WriteStructEndAccess(FDcStructAccess& Access) override;\n\n\tFDcResult WriteClassRootAccess(FDcClassAccess& Access) override;\n\tFDcResult WriteClassEndAccess(FDcClassAccess& Access) override;\n\n\tFDcResult WriteMapRoot() override;\n\tFDcResult WriteMapEnd() override;\n\n\tFDcResult WriteArrayRoot() override;\n\tFDcResult WriteArrayEnd() override;\n\n\tFDcResult WriteSetRoot() override;\n\tFDcResult WriteSetEnd() override;\n\n\tFDcResult WriteOptionalRoot() override;\n\tFDcResult WriteOptionalEnd() override;\n\n\tFDcResult WriteObjectReference(const UObject* Value) override;\n\tFDcResult WriteClassReference(const UClass* Value) override;\n\n\tFDcResult WriteWeakObjectReference(const FWeakObjectPtr& Value) override;\n\tFDcResult WriteLazyObjectReference(const FLazyObjectPtr& Value) override;\n\tFDcResult WriteSoftObjectReference(const FSoftObjectPtr& Value) override;\n\tFDcResult WriteSoftClassReference(const FSoftObjectPtr& Value) override;\n\tFDcResult WriteInterfaceReference(const FScriptInterface& Value) override;\n\n\tFDcResult WriteFieldPath(const FFieldPath& Value) override;\n\tFDcResult WriteDelegate(const FScriptDelegate& Value) override;\n\tFDcResult WriteMulticastInlineDelegate(const FMulticastScriptDelegate& Value) override;\n\tFDcResult WriteMulticastSparseDelegate(const FMulticastScriptDelegate& Value) override;\n\n\tFDcResult WriteInt8(const int8& Value) override;\n\tFDcResult WriteInt16(const int16& Value) override;\n\tFDcResult WriteInt32(const int32& Value) override;\n\tFDcResult WriteInt64(const int64& Value) override;\n\n\tFDcResult WriteUInt8(const uint8& Value) override;\n\tFDcResult WriteUInt16(const uint16& Value) override;\n\tFDcResult WriteUInt32(const uint32& Value) override;\n\tFDcResult WriteUInt64(const uint64& Value) override;\n\n\tFDcResult WriteFloat(const float& Value) override;\n\tFDcResult WriteDouble(const double& Value) override;\n\tFDcResult WriteBlob(const FDcBlobViewData& Value) override;\n\n\n\tFDcResult SkipWrite();\n\n\tFDcResult PeekWriteProperty(FFieldVariant* OutProperty);\n\n\tFDcResult WriteDataEntry(FFieldClass* ExpectedPropertyClass, FDcPropertyDatum& OutDatum);\n\n\n\tFDcResult PushTopClassPropertyState(const FDcPropertyDatum& Datum);\n\tFDcResult PushTopStructPropertyState(const FDcPropertyDatum& Datum, const FName& StructName);\n\n\n\tbool IsWritingScalarArrayItem();\n\n\tFDcResult SetConfig(FDcPropertyConfig InConfig);\n\tFDcPropertyConfig Config;\n\n\tTArray<DcPropertyWriterDetails::FWriteState, TInlineAllocator<4>> States;\n\n\tFDcDiagnosticHighlight FormatHighlight();\n\tvoid FormatDiagnostic(FDcDiagnostic& Diag) override;\n\n\tstatic FName ClassId();\n\tFName GetId() override;\n};\n\n\n\n",
        "gt": [
            "'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyTypes.h'",
            "'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyWriter.h'",
            "'DataConfig/DataConfig/Source/DataConfigTests/Private/DcTestProperty.cpp'"
        ]
    },
    {
        "files": [
            "'knowrob/include/knowrob/plugins/PluginLibrary.h'",
            "'knowrob/src/reasoner/mongolog/MongologReasoner.cpp'",
            "'knowrob/include/knowrob/reasoner/ReasonerManager.h'",
            "'knowrob/include/knowrob/storage/StorageManager.h'",
            "'knowrob/include/knowrob/plugins/PluginManager.h'"
        ],
        "content": "'knowrob/include/knowrob/plugins/PluginLibrary.h'\n:\n\n#ifndef KNOWROB_PLUGIN_LIBRARY_H_\n#define KNOWROB_PLUGIN_LIBRARY_H_\n\n#include <string>\n#include <memory>\n#include <dlfcn.h>\n#include \"knowrob/plugins/PluginFactory.h\"\n\nnamespace knowrob {\n\n\ttemplate<class T>\n\tclass PluginLibrary : public PluginFactory<T> {\n\tpublic:\n\n\t\texplicit PluginLibrary(std::string_view dllPath)\n\t\t\t\t: dllPath_(dllPath),\n\t\t\t\t  handle_(nullptr),\n\t\t\t\t  create_(nullptr),\n\t\t\t\t  get_name_(nullptr) {\n\t\t}\n\n\t\t~PluginLibrary() override {\n\t\t\tif (handle_) {\n\t\t\t\tdlclose(handle_);\n\t\t\t\thandle_ = nullptr;\n\t\t\t}\n\t\t}\n\n\n\t\tPluginLibrary(const PluginLibrary &) = delete;\n\n\n\t\tbool isLoaded() {\n\t\t\treturn (create_ != nullptr && get_name_ != nullptr);\n\t\t}\n\n\n\t\tbool loadDLL() {\n\t\t\thandle_ = dlopen(dllPath_.c_str(), RTLD_LAZY);\n\t\t\tif (handle_ != nullptr) {\n\t\t\t\tcreate_ = (std::shared_ptr<T> (*)()) dlsym(handle_, \"knowrob_createPlugin\");\n\t\t\t\tget_name_ = (char *(*)()) dlsym(handle_, \"knowrob_getPluginName\");\n\t\t\t\treturn isLoaded();\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\n\t\tstd::shared_ptr<NamedPlugin<T>> create(std::string_view pluginID) override {\n\t\t\treturn std::make_shared<NamedPlugin<T>>(pluginID, PluginLanguage::CPP, create_());\n\t\t}\n\n\n\t\tstd::string_view name() const override { return name_; };\n\n\tprotected:\n\t\tconst std::string dllPath_;\n\t\tstd::string name_;\n\n\t\tvoid *handle_;\n\n\n\t\tstd::shared_ptr<T> (*create_)();\n\n\n\t\tchar *(*get_name_)();\n\t};\n}\n\n#endif\n\n'knowrob/src/reasoner/mongolog/MongologReasoner.cpp'\n:\n\n#include <gtest/gtest.h>\n\n#include \"knowrob/Logger.h\"\n#include \"knowrob/reasoner/prolog/PrologTests.h\"\n#include \"knowrob/reasoner/ReasonerManager.h\"\n#include \"knowrob/reasoner/mongolog/MongologReasoner.h\"\n#include \"knowrob/queries/QueryError.h\"\n#include \"knowrob/reasoner/ReasonerError.h\"\n#include \"knowrob/terms/Numeric.h\"\n#include \"knowrob/knowrob.h\"\n\nusing namespace knowrob;\n\n\nKNOWROB_BUILTIN_REASONER(\"Mongolog\", MongologReasoner)\n\n\nforeign_t pl_is_readonly2(term_t, term_t);\n\nforeign_t pl_db_name3(term_t, term_t, term_t);\n\nforeign_t pl_uri3(term_t, term_t, term_t);\n\nforeign_t pl_assert_triple_cpp9(term_t, term_t, term_t, term_t, term_t, term_t, term_t, term_t, term_t);\n\nMongologReasoner::MongologReasoner()\n\t\t: PrologReasoner() {}\n\nMongologReasoner::~MongologReasoner()\n= default;\n\nvoid MongologReasoner::unload() {\n\tstatic auto unload_f = \"mongolog_reasoner_unload\";\n\tPROLOG_ENGINE_EVAL(getReasonerQuery(PrologTerm(unload_f)));\n\n\tPrologReasoner::unload();\n}\n\nbool MongologReasoner::initializeDefaultPackages() {\n\tstatic bool initialized = false;\n\n\tif (!initialized) {\n\t\tinitialized = true;\n\n\t\tconsult(std::filesystem::path(\"reasoner\") / \"mongolog\" / \"__init__.pl\",\n\t\t\t\t\"user\", false);\n\n\t\tPL_register_foreign(\"mng_is_readonly_cpp\",\n\t\t\t\t\t\t\t2, (pl_function_t) pl_is_readonly2, 0);\n\t\tPL_register_foreign(\"mng_db_name_cpp\",\n\t\t\t\t\t\t\t3, (pl_function_t) pl_db_name3, 0);\n\t\tPL_register_foreign(\"mng_uri_cpp\",\n\t\t\t\t\t\t\t3, (pl_function_t) pl_uri3, 0);\n\n\t\tPL_register_foreign(\"mng_assert_triple_cpp\",\n\t\t\t\t\t\t\t9, (pl_function_t) pl_assert_triple_cpp9, 0);\n\t}\n\n\treturn true;\n}\n\nbool MongologReasoner::initializeReasoner(const PropertyTree &reasonerConfiguration) {\n\tif (!PrologReasoner::initializeReasoner(reasonerConfiguration)) return false;\n\n\tif (!knowledgeGraph_) {\n\t\tknowledgeGraph_ = std::make_shared<MongoKnowledgeGraph>();\n\t\tknowledgeGraph_->setVocabulary(std::make_shared<Vocabulary>());\n\t\tknowledgeGraph_->initializeBackend(\n\t\t\t\tMongoKnowledgeGraph::DB_URI_DEFAULT,\n\t\t\t\tMongoKnowledgeGraph::DB_NAME_KNOWROB,\n\t\t\t\tMongoKnowledgeGraph::COLL_NAME_TRIPLES\n\t\t);\n\t\treasonerManager().backendManager()->addPlugin(\"mongo\", PluginLanguage::CPP, knowledgeGraph_);\n\t\tKB_WARN(\"Falling back to default configuration for MongoDB!\");\n\t}\n\n\treturn true;\n}\n\nstd::string_view MongologReasoner::callFunctor() {\n\tstatic const auto call_f = \"mongolog_call\";\n\treturn call_f;\n}\n\nstatic inline std::shared_ptr<MongologReasoner> getMongologReasoner(term_t t_reasonerManager,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tterm_t t_reasonerModule) {\n\tauto definedReasoner = PrologReasoner::getDefinedReasoner(t_reasonerManager, t_reasonerModule);\n\tif (!definedReasoner) {\n\t\tKB_ERROR(\"unable to find reasoner with id '{}' (manager id: {}).\",\n\t\t\t\t *PrologTerm::toKnowRobTerm(t_reasonerModule),\n\t\t\t\t *PrologTerm::toKnowRobTerm(t_reasonerManager));\n\t\treturn {};\n\t}\n\tauto reasoner = definedReasoner->value();\n\tauto mongolog = std::dynamic_pointer_cast<MongologReasoner>(reasoner);\n\tif (!mongolog) {\n\t\tKB_ERROR(\"reasoner with id '{}' (manager id: {}) is not a mongolog reasoner.\",\n\t\t\t\t *PrologTerm::toKnowRobTerm(t_reasonerModule),\n\t\t\t\t *PrologTerm::toKnowRobTerm(t_reasonerManager));\n\t}\n\treturn mongolog;\n}\n\n\nforeign_t pl_is_readonly2(term_t t_reasonerManager, term_t t_reasonerModule) {\n\tauto mongolog = getMongologReasoner(t_reasonerManager, t_reasonerModule);\n\tif (mongolog) {\n\t\treturn mongolog->knowledgeGraph()->isReadOnly();\n\t}\n\treturn false;\n}\n\nforeign_t pl_db_name3(term_t t_reasonerManager, term_t t_reasonerModule, term_t t_dbName) {\n\tauto mongolog = getMongologReasoner(t_reasonerManager, t_reasonerModule);\n\tif (mongolog) {\n\t\tauto &dbName = mongolog->knowledgeGraph()->dbName();\n\t\treturn PL_unify_atom_chars(t_dbName, dbName.c_str());\n\t}\n\treturn false;\n}\n\nforeign_t pl_uri3(term_t t_reasonerManager, term_t t_reasonerModule, term_t t_uri) {\n\tauto mongolog = getMongologReasoner(t_reasonerManager, t_reasonerModule);\n\tif (mongolog) {\n\t\tauto &uri = mongolog->knowledgeGraph()->dbURI();\n\t\treturn PL_unify_atom_chars(t_uri, uri.c_str());\n\t}\n\treturn false;\n}\n\nforeign_t pl_assert_triple_cpp9(term_t t_reasonerManager,\n\t\t\t\t\t\t\t\tterm_t t_reasonerModule,\n\t\t\t\t\t\t\t\tterm_t t_subjectTerm,\n\t\t\t\t\t\t\t\tterm_t t_propertyTerm,\n\t\t\t\t\t\t\t\tterm_t t_objectTerm,\n\t\t\t\t\t\t\t\tterm_t t_graphTerm,\n\t\t\t\t\t\t\t\tterm_t t_beginTerm,\n\t\t\t\t\t\t\t\tterm_t t_endTerm,\n\t\t\t\t\t\t\t\tterm_t t_confidenceTerm) {\n\tauto mongolog = getMongologReasoner(t_reasonerManager, t_reasonerModule);\n\tif (mongolog) {\n\t\tTripleView tripleData;\n\n\n\t\tauto subjectTerm = PrologTerm::toKnowRobTerm(t_subjectTerm);\n\t\tif (subjectTerm->termType() != TermType::ATOMIC) throw QueryError(\"invalid subject term {}\", *subjectTerm);\n\t\ttripleData.setSubject(((Atomic *) subjectTerm.get())->stringForm());\n\n\n\t\tauto propertyTerm = PrologTerm::toKnowRobTerm(t_propertyTerm);\n\t\tif (propertyTerm->termType() != TermType::ATOMIC) throw QueryError(\"invalid property term {}\", *propertyTerm);\n\t\ttripleData.setPredicate(((Atomic *) propertyTerm.get())->stringForm());\n\n\n\t\tauto objectTerm = PrologTerm::toKnowRobTerm(t_objectTerm);\n\t\tif(objectTerm->termType() == TermType::ATOMIC) {\n\t\t\tauto atomic = std::static_pointer_cast<Atomic>(objectTerm);\n\t\t\tif (atomic->isNumeric()) {\n\t\t\t\ttripleData.setXSDValue(atomic->stringForm(),\n\t\t\t\t\tstd::static_pointer_cast<Numeric>(atomic)->xsdType());\n\t\t\t} else if (atomic->isIRI()) {\n\t\t\t\ttripleData.setObjectIRI(atomic->stringForm());\n\t\t\t} else if (atomic->isBlank()) {\n\t\t\t\ttripleData.setObjectBlank(atomic->stringForm());\n\t\t\t} else {\n\t\t\t\ttripleData.setStringValue(atomic->stringForm());\n\t\t\t}\n\t\t} else {\n\t\t\tthrow QueryError(\"object term {} of triple has an invalid type\", *objectTerm);\n\t\t}\n\n\n\t\tTermPtr graphTerm;\n\t\tif (!PL_is_variable(t_graphTerm)) {\n\t\t\tgraphTerm = PrologTerm::toKnowRobTerm(t_graphTerm);\n\t\t\tif (graphTerm->termType() != TermType::ATOMIC) throw QueryError(\"invalid property term {}\", *graphTerm);\n\t\t\ttripleData.setGraph(((Atomic *) graphTerm.get())->stringForm());\n\t\t} else {\n\t\t\ttripleData.setGraph(mongolog->reasonerManager().backendManager()->vocabulary()->importHierarchy()->defaultGraph());\n\t\t}\n\n\n\t\tTermPtr confidenceTerm;\n\t\tif (!PL_is_variable(t_confidenceTerm)) {\n\t\t\tconfidenceTerm = PrologTerm::toKnowRobTerm(t_confidenceTerm);\n\t\t\tif (confidenceTerm->isNumeric()) {\n\t\t\t\ttripleData.setConfidence(std::static_pointer_cast<Numeric>(confidenceTerm)->asDouble());\n\t\t\t} else {\n\t\t\t\tthrow QueryError(\"invalid confidence term {}\", *confidenceTerm);\n\t\t\t}\n\t\t}\n\n\n\t\tTermPtr beginTerm;\n\t\tif (!PL_is_variable(t_beginTerm)) {\n\t\t\tbeginTerm = PrologTerm::toKnowRobTerm(t_beginTerm);\n\t\t\tif (beginTerm->isNumeric()) {\n\t\t\t\ttripleData.setBegin(std::static_pointer_cast<Numeric>(beginTerm)->asDouble());\n\t\t\t} else {\n\t\t\t\tthrow QueryError(\"invalid begin term {}\", *beginTerm);\n\t\t\t}\n\t\t}\n\n\n\t\tTermPtr endTerm;\n\t\tif (!PL_is_variable(t_endTerm)) {\n\t\t\tendTerm = PrologTerm::toKnowRobTerm(t_endTerm);\n\t\t\tif (endTerm->isNumeric()) {\n\t\t\t\ttripleData.setEnd(std::static_pointer_cast<Numeric>(endTerm)->asDouble());\n\t\t\t} else {\n\t\t\t\tthrow QueryError(\"invalid end term {}\", *endTerm);\n\t\t\t}\n\t\t}\n\n\t\tmongolog->reasonerManager().kb()->edb()->mergeInsert(mongolog->knowledgeGraph(), tripleData);\n\n\t\treturn true;\n\t} else {\n\t\tKB_WARN(\"[mongolog] unable to assert triple: reasoner not found\");\n\t\treturn false;\n\t}\n}\n\nnamespace knowrob::testing {\n\tclass MongologTests : public PrologTestsBase {\n\tprotected:\n\t\tstatic std::shared_ptr<MongologReasoner> reasoner_;\n\t\tstatic std::shared_ptr<KnowledgeBase> kb_;\n\t\tstatic std::shared_ptr<MongoKnowledgeGraph> db_;\n\n\t\tstatic std::shared_ptr<knowrob::MongoKnowledgeGraph>\n\t\tcreateBackend2(const std::string &name, const std::shared_ptr<KnowledgeBase> &kb) {\n\t\t\tauto kg = std::make_shared<MongoKnowledgeGraph>();\n\t\t\tkb->backendManager()->addPlugin(name, PluginLanguage::CPP, kg);\n\t\t\tkg->initializeBackend(\n\t\t\t\t\tMongoKnowledgeGraph::DB_URI_DEFAULT,\n\t\t\t\t\tMongoKnowledgeGraph::DB_NAME_TESTS,\n\t\t\t\t\tMongoKnowledgeGraph::COLL_NAME_TRIPLES);\n\t\t\tkg->drop();\n\t\t\tkg->tripleCollection()->createTripleIndex();\n\t\t\treturn kg;\n\t\t}\n\n\t\tstatic std::shared_ptr<MongologReasoner>\n\t\tcreateReasoner2(const std::string &name, const std::shared_ptr<KnowledgeBase> &kb,\n\t\t\t\t\t\tconst std::shared_ptr<MongoKnowledgeGraph> &db) {\n\t\t\tauto r = std::make_shared<MongologReasoner>();\n\t\t\tr->setStorage(db);\n\t\t\tkb->reasonerManager()->addPlugin(name, PluginLanguage::CPP, r);\n\t\t\tr->initializeReasoner(knowrob::PropertyTree());\n\t\t\tr->load_rdf_xml(\"http:\n\t\t\treturn r;\n\t\t}\n\n\n\t\tstatic void SetUpTestSuite() {\n\n\t\t\ttry {\n\t\t\t\treasoner();\n\t\t\t} catch (std::exception &e) {\n\t\t\t\tFAIL() << \"SetUpTestSuite failed: \" << e.what();\n\t\t\t}\n\t\t}\n\n\n\t\tstatic void TearDownTestSuite() {\n\t\t\treasoner_ = nullptr;\n\t\t\tdb_ = nullptr;\n\t\t\tkb_ = nullptr;\n\t\t}\n\n\t\tstatic void runTests(const std::string &t) {\n\t\t\ttry {\n\t\t\t\trunPrologTests(reasoner(), t);\n\t\t\t} catch (std::exception &e) {\n\t\t\t\tFAIL() << \"runTests failed: \" << e.what();\n\t\t\t}\n\t\t}\n\n\t\tstatic std::shared_ptr<MongologReasoner> reasoner() {\n\t\t\tif (!reasoner_) {\n\t\t\t\tstd::stringstream ss;\n\t\t\t\tss << \"mongolog_\";\n\t\t\t\tinsertUnique(ss);\n\n\t\t\t\tkb_ = KnowledgeBase::create();\n\t\t\t\tdb_ = createBackend2(ss.str(), kb_);\n\t\t\t\treasoner_ = createReasoner2(ss.str(), kb_, db_);\n\n\t\t\t\tkb_->loadCommon();\n\t\t\t\tkb_->init();\n\t\t\t}\n\t\t\treturn reasoner_;\n\t\t}\n\n\t\tstatic std::string getPath(const std::string &filename) {\n\t\t\treturn std::filesystem::path(\"reasoner\") / \"mongolog\" / filename;\n\t\t}\n\t};\n\n\tstd::shared_ptr<MongologReasoner> MongologTests::reasoner_;\n\tstd::shared_ptr<KnowledgeBase> MongologTests::kb_;\n\tstd::shared_ptr<MongoKnowledgeGraph> MongologTests::db_;\n}\nusing namespace knowrob::testing;\n\nTEST_F(MongologTests, arithmetic) { runTests(getPath(\"iso/arithmetic.pl\")); }\n\nTEST_F(MongologTests, atoms) { runTests(getPath(\"iso/atoms.pl\")); }\n\nTEST_F(MongologTests, comparison) { runTests(getPath(\"iso/comparison.pl\")); }\n\nTEST_F(MongologTests, control) { runTests(getPath(\"iso/control.pl\")); }\n\nTEST_F(MongologTests, findall) { runTests(getPath(\"iso/findall.pl\")); }\n\nTEST_F(MongologTests, lists) { runTests(getPath(\"iso/lists.pl\")); }\n\nTEST_F(MongologTests, meta) { runTests(getPath(\"iso/meta.pl\")); }\n\nTEST_F(MongologTests, terms) { runTests(getPath(\"iso/terms.pl\")); }\n\nTEST_F(MongologTests, typecheck) { runTests(getPath(\"iso/typecheck.pl\")); }\n\nTEST_F(MongologTests, unification) { runTests(getPath(\"iso/unification.pl\")); }\n\nTEST_F(MongologTests, database) { runTests(getPath(\"database.pl\")); }\n\nTEST_F(MongologTests, fluents) { runTests(getPath(\"fluents.pl\")); }\n\nTEST_F(MongologTests, sgml) { runTests(getPath(\"sgml.pl\")); }\n\nTEST_F(MongologTests, annotation) { runTests(getPath(\"annotation.pl\")); }\n\nTEST_F(MongologTests, triple) { runTests(getPath(\"triple.plt\")); }\n\n'knowrob/include/knowrob/reasoner/ReasonerManager.h'\n:\n\n#ifndef KNOWROB_REASONER_MANAGER_H_\n#define KNOWROB_REASONER_MANAGER_H_\n\n#include \"knowrob/plugins/PluginManager.h\"\n#include \"knowrob/storage/StorageManager.h\"\n#include \"knowrob/KnowledgeBase.h\"\n#include \"knowrob/reasoner/GoalDrivenReasoner.h\"\n#include \"knowrob/reasoner/DataDrivenReasoner.h\"\n\nnamespace knowrob {\n\n\tclass ReasonerManager : public PluginManager<Reasoner> {\n\tpublic:\n\n\t\tReasonerManager(KnowledgeBase *kb, const std::shared_ptr<StorageManager> &backendManager);\n\n\t\t~ReasonerManager() override;\n\n\n\t\tauto kb() const { return kb_; }\n\n\n\t\tauto backendManager() const { return backendManager_; }\n\n\n\t\tauto &goalDriven() const { return goalDriven_; }\n\n\n\t\tauto &dataDriven() const { return dataDriven_; }\n\n\n\t\tstd::vector<DefiningReasoner> findDefiningReasoner(const PredicateIndicator &indicator) const;\n\n\n\t\tstd::shared_ptr<Storage> getReasonerStorage(const std::shared_ptr<NamedReasoner> &reasoner);\n\n\n\t\tstd::shared_ptr<NamedReasoner> loadPlugin(const boost::property_tree::ptree &config) override;\n\n\n\t\tstd::shared_ptr<NamedReasoner>\n\t\taddPlugin(std::string_view reasonerID, PluginLanguage language, const std::shared_ptr<Reasoner> &reasoner) override;\n\n\n\t\tstatic TokenBufferPtr evaluateQuery(\n\t\t\t\tconst GoalDrivenReasonerPtr &reasoner,\n\t\t\t\tconst std::vector<FirstOrderLiteralPtr> &literals,\n\t\t\t\tconst QueryContextPtr &ctx);\n\n\tprivate:\n\t\tKnowledgeBase *kb_;\n\t\tstd::shared_ptr<StorageManager> backendManager_;\n\n\t\tstd::map<std::string_view, StoragePtr, std::less<>> reasonerBackends_;\n\t\tstd::map<std::string_view, DataDrivenReasonerPtr> dataDriven_;\n\t\tstd::map<std::string_view, GoalDrivenReasonerPtr> goalDriven_;\n\n\t\tvoid setReasonerStorage(const std::shared_ptr<NamedPlugin<Reasoner>> &plugin, const std::shared_ptr<Storage> &dataBackend);\n\n\t\tvoid initPlugin(const std::shared_ptr<NamedReasoner> &namedReasoner);\n\n\t\tstatic bool initializeReasoner(const std::shared_ptr<NamedReasoner> &namedReasoner, PropertyTree &config);\n\t};\n}\n\n\n\n\n#define KNOWROB_BUILTIN_REASONER(Name, Type) class Type ## _Registration{ static bool isRegistered; }; \\\n        bool Type ## _Registration::isRegistered = knowrob::PluginManager<knowrob::Reasoner>::addFactory<Type>(Name);\n\n#endif\n\n'knowrob/include/knowrob/storage/StorageManager.h'\n:\n\n#ifndef KNOWROB_STORAGE_MANAGER_H_\n#define KNOWROB_STORAGE_MANAGER_H_\n\n#include <map>\n#include \"knowrob/semweb/Vocabulary.h\"\n#include \"knowrob/plugins/PluginManager.h\"\n#include \"QueryableStorage.h\"\n\nnamespace knowrob {\n\n\tclass StorageManager : public PluginManager<Storage> {\n\tpublic:\n\n\t\texplicit StorageManager(const std::shared_ptr<Vocabulary> &vocabulary);\n\n\t\t~StorageManager() override = default;\n\n\n\t\tauto &vocabulary() const { return vocabulary_; }\n\n\n\t\tconst auto &persistent() const { return persistent_; }\n\n\n\t\tconst auto &queryable() const { return queryable_; }\n\n\n\t\tvoid addPlugin(const std::shared_ptr<NamedBackend> &backend);\n\n\n\t\tstd::shared_ptr<NamedBackend> loadPlugin(const boost::property_tree::ptree &config) override;\n\n\n\t\tstd::shared_ptr<NamedBackend> addPlugin(std::string_view reasonerID, PluginLanguage language, const StoragePtr &backend) override;\n\n\tprivate:\n\t\tstd::shared_ptr<Vocabulary> vocabulary_;\n\t\tstd::map<std::string_view, QueryableBackendPtr> persistent_;\n\t\tstd::map<std::string_view, QueryableBackendPtr> queryable_;\n\n\t\tvoid initBackend(const std::shared_ptr<NamedBackend> &definedKG);\n\t};\n}\n\n\n\n\n#define KNOWROB_BUILTIN_STORAGE(Name, Type) class Type ## _Registration{ static bool isRegistered; }; \\\n        bool Type ## _Registration::isRegistered = knowrob::PluginManager<knowrob::Storage>::addFactory<Type>(Name);\n\n#endif\n\n'knowrob/include/knowrob/plugins/PluginManager.h'\n:\n\n#ifndef KNOWROB_PLUGIN_MANAGER_H_\n#define KNOWROB_PLUGIN_MANAGER_H_\n\n#include <memory>\n#include <map>\n#include <string>\n#include <mutex>\n#include <boost/property_tree/ptree.hpp>\n#include \"knowrob/plugins/TypedPluginFactory.h\"\n#include \"knowrob/plugins/PluginLibrary.h\"\n#include \"knowrob/plugins/PluginModule.h\"\n#include \"knowrob/Logger.h\"\n#include \"knowrob/URI.h\"\n\nnamespace knowrob {\n\n\ttemplate<class T>\n\tclass PluginManager {\n\tpublic:\n\t\tPluginManager() {\n\t\t\tstd::lock_guard<std::mutex> scoped_lock(staticMutex_);\n\t\t\tpluginManagers_ = pluginManagers();\n\t\t\tmanagerID_ = (managerIDCounter()++);\n\t\t\t(*pluginManagers_)[managerID_] = this;\n\t\t}\n\n\t\tvirtual ~PluginManager() {\n\t\t\t{\n\t\t\t\tstd::lock_guard<std::mutex> scoped_lock(staticMutex_);\n\t\t\t\tpluginManagers_->erase(managerID_);\n\t\t\t}\n\n\t\t\tfor (auto &entry : loadedModules_) {\n\t\t\t\tentry.second->unloadModule();\n\t\t\t}\n\t\t\tloadedModules_.clear();\n\t\t\tloadedPlugins_.clear();\n\t\t\tpluginPool_.clear();\n\t\t}\n\n\n\t\tauto managerID() const { return managerID_; }\n\n\n\t\tconst auto &plugins() const { return pluginPool_; }\n\n\n\t\tstatic PluginManager<T> *getManager(uint32_t managerID) {\n\t\t\tauto it = pluginManagers()->find(managerID);\n\t\t\tif (it != pluginManagers()->end()) {\n\t\t\t\treturn it->second;\n\t\t\t} else {\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t}\n\n\n\t\tstd::shared_ptr<NamedPlugin<T>> getPluginWithID(std::string_view pluginID) {\n\t\t\tauto it = pluginPool_.find(pluginID);\n\t\t\tif (it != pluginPool_.end()) {\n\t\t\t\treturn it->second;\n\t\t\t} else {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}\n\n\n\t\tstatic bool addFactory(std::string_view typeName, const std::shared_ptr<PluginFactory<T>> &factory) {\n\t\t\tauto &factories = pluginFactories();\n\t\t\tif (factories.find(typeName) != factories.end()) {\n\t\t\t\tKB_WARN(\"overwriting factory for plugin type '{}'\", typeName);\n\t\t\t}\n\t\t\tfactories.emplace(typeName, factory);\n\t\t\treturn true;\n\t\t}\n\n\n\t\ttemplate<class U>\n\t\tstatic bool addFactory(std::string_view typeName) {\n\t\t\treturn addFactory(typeName, std::make_shared<TypedPluginFactory<U, T>>(typeName));\n\t\t}\n\n\n\t\tvirtual std::shared_ptr<NamedPlugin<T>> loadPlugin(const boost::property_tree::ptree &config) = 0;\n\n\n\t\tvirtual std::shared_ptr<NamedPlugin<T>>\n\t\taddPlugin(std::string_view reasonerID, PluginLanguage language, const std::shared_ptr<T> &reasoner) = 0;\n\n\n\t\tvoid removePlugin(const std::shared_ptr<NamedPlugin<T>> &namedPlugin) { pluginPool_.erase(namedPlugin->name()); }\n\n\n\t\tvoid removePlugin(std::string_view pluginID) { pluginPool_.erase(pluginID); }\n\n\tprotected:\n\t\tstd::shared_ptr<std::map<uint32_t, PluginManager *>> pluginManagers_;\n\n\t\tstd::mutex staticMutex_;\n\n\t\tuint32_t managerID_;\n\n\t\tuint32_t pluginIndex_ = 0;\n\n\n\n\t\tstd::map<std::string_view, std::shared_ptr<NamedPlugin<T>>, std::less<>> pluginPool_;\n\n\t\tstd::map<std::string, std::shared_ptr<PluginLibrary<T>>, std::less<>> loadedPlugins_;\n\t\tstd::map<std::string, std::shared_ptr<PluginModule<T>>, std::less<>> loadedModules_;\n\n\n\t\tstatic uint32_t &managerIDCounter() {\n\t\t\tstatic uint32_t val = 0;\n\t\t\treturn val;\n\t\t}\n\n\n\t\tstatic auto &pluginFactories() {\n\t\t\tstatic std::map<std::string, std::shared_ptr<PluginFactory<T>>, std::less<>> factories;\n\t\t\treturn factories;\n\t\t}\n\n\n\t\tstatic auto &pluginManagers() {\n\t\t\tstatic auto val = std::make_shared<std::map<uint32_t, PluginManager *>>();\n\t\t\treturn val;\n\t\t}\n\n\t\tstd::shared_ptr<PluginLibrary<T>> loadSharedLibrary(std::string_view path) {\n\t\t\tauto absPath = std::filesystem::absolute(path);\n\t\t\tauto it = loadedPlugins_.find(absPath);\n\t\t\tif (it == loadedPlugins_.end()) {\n\t\t\t\tauto p = std::make_shared<PluginLibrary<T>>(absPath.c_str());\n\t\t\t\tauto jt = loadedPlugins_.insert(std::pair<std::string,\n\t\t\t\t\t\tstd::shared_ptr<PluginLibrary<T>>>(absPath, p));\n\t\t\t\tif (jt.first->second->loadDLL()) {\n\t\t\t\t\treturn jt.first->second;\n\t\t\t\t}\n\t\t\t} else if (it->second->isLoaded()) {\n\t\t\t\treturn it->second;\n\t\t\t}\n\t\t\tKB_WARN(\"Failed to open plugin library at path '{}'.\", path);\n\t\t\treturn {};\n\t\t}\n\n\t\tstd::shared_ptr<PluginModule<T>> loadPythonModule(std::string_view path, std::string_view type) {\n\t\t\tauto it = loadedModules_.find(path);\n\t\t\tif (it == loadedModules_.end()) {\n\t\t\t\tauto p = std::make_shared<PluginModule<T>>(path, type);\n\t\t\t\tauto jt = loadedModules_.insert(std::pair<std::string,\n\t\t\t\t\t\tstd::shared_ptr<PluginModule<T>>>(path, p));\n\t\t\t\tif (jt.first->second->loadModule()) {\n\t\t\t\t\treturn jt.first->second;\n\t\t\t\t}\n\t\t\t} else if (it->second->isLoaded()) {\n\t\t\t\treturn it->second;\n\t\t\t}\n\t\t\tKB_WARN(\"Failed to open plugin module at path '{}'.\", path);\n\t\t\treturn {};\n\t\t}\n\n\t\tstd::shared_ptr<PluginFactory<T>> findFactory(const boost::property_tree::ptree &config) {\n\t\t\tauto lib = config.get_optional<std::string>(\"lib\");\n\t\t\tauto module = config.get_optional<std::string>(\"module\");\n\t\t\tauto type = config.get_optional<std::string>(\"type\");\n\n\t\t\tif (lib.has_value()) {\n\t\t\t\treturn loadSharedLibrary(URI::resolve(lib.value()));\n\t\t\t} else if (module.has_value()) {\n\t\t\t\tif (type.has_value()) {\n\t\t\t\t\treturn loadPythonModule(URI::resolve(module.value()), type.value());\n\t\t\t\t} else {\n\t\t\t\t\tKB_WARN(\"modules require type key in settings, but it's missing for module '{}'.\", module.value());\n\t\t\t\t}\n\t\t\t} else if (type.has_value()) {\n\n\t\t\t\tconst auto &it = pluginFactories().find(type.value());\n\t\t\t\tif (it == pluginFactories().end()) {\n\t\t\t\t\tKB_WARN(\"no factory registered for plugin type '{}'.\", type.value());\n\t\t\t\t} else {\n\t\t\t\t\treturn it->second;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tKB_WARN(\"missing 'type', 'lib' and 'module' key in plugin config.\");\n\t\t\t}\n\t\t\treturn {};\n\t\t}\n\n\t\tstd::string\n\t\tgetPluginID(const std::shared_ptr<PluginFactory<T>> &factory, const boost::property_tree::ptree &config) {\n\t\t\tauto name = config.get_optional<std::string>(\"name\");\n\t\t\tif (name.has_value()) {\n\t\t\t\treturn name.value();\n\t\t\t} else {\n\t\t\t\treturn std::string(factory->name()) + std::to_string(pluginIndex_++);\n\t\t\t}\n\t\t}\n\t};\n}\n\n#endif\n",
        "gt": [
            "'knowrob/include/knowrob/plugins/PluginLibrary.h'",
            "'knowrob/include/knowrob/plugins/PluginManager.h'",
            "'knowrob/include/knowrob/storage/StorageManager.h'",
            "'knowrob/include/knowrob/reasoner/ReasonerManager.h'",
            "'knowrob/src/reasoner/mongolog/MongologReasoner.cpp'"
        ]
    },
    {
        "files": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/rosenbrock4_dense_output.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/rosenbrock4_controller.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/integrate_implicit.cpp'"
        ],
        "content": "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/rosenbrock4_dense_output.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_STEPPER_ROSENBROCK4_DENSE_OUTPUT_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_STEPPER_ROSENBROCK4_DENSE_OUTPUT_HPP_INCLUDED\n\n\n#include <utility>\n\n#include <boost/numeric/odeint/util/bind.hpp>\n\n#include <boost/numeric/odeint/stepper/rosenbrock4_controller.hpp>\n#include <boost/numeric/odeint/util/is_resizeable.hpp>\n\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\ntemplate< class ControlledStepper >\nclass rosenbrock4_dense_output\n{\n\npublic:\n\n    typedef ControlledStepper controlled_stepper_type;\n    typedef typename controlled_stepper_type::stepper_type stepper_type;\n    typedef typename stepper_type::value_type value_type;\n    typedef typename stepper_type::state_type state_type;\n    typedef typename stepper_type::wrapped_state_type wrapped_state_type;\n    typedef typename stepper_type::time_type time_type;\n    typedef typename stepper_type::deriv_type deriv_type;\n    typedef typename stepper_type::wrapped_deriv_type wrapped_deriv_type;\n    typedef typename stepper_type::resizer_type resizer_type;\n    typedef dense_output_stepper_tag stepper_category;\n\n    typedef rosenbrock4_dense_output< ControlledStepper > dense_output_stepper_type;\n\n    rosenbrock4_dense_output( const controlled_stepper_type &stepper = controlled_stepper_type() )\n    : m_stepper( stepper ) ,\n      m_x1() , m_x2() ,\n      m_current_state_x1( true ) ,\n      m_t() , m_t_old() , m_dt()\n    {\n    }\n\n\n\n    template< class StateType >\n    void initialize( const StateType &x0 , time_type t0 , time_type dt0 )\n    {\n        m_resizer.adjust_size( x0 , detail::bind( &dense_output_stepper_type::template resize_impl< StateType > , detail::ref( *this ) , detail::_1 ) );\n        get_current_state() = x0;\n        m_t = t0;\n        m_dt = dt0;\n    }\n\n    template< class System >\n    std::pair< time_type , time_type > do_step( System system )\n    {\n        const size_t max_count = 1000;\n\n        controlled_step_result res = fail;\n        m_t_old = m_t;\n        size_t count = 0;\n        do\n        {\n            res = m_stepper.try_step( system , get_current_state() , m_t , get_old_state() , m_dt );\n            if( count++ == max_count )\n                throw std::overflow_error( \"rosenbrock4 : too much iterations!\");\n        }\n        while( res == fail );\n        m_stepper.stepper().prepare_dense_output();\n        this->toggle_current_state();\n        return std::make_pair( m_t_old , m_t );\n    }\n\n\n\n    template< class StateOut >\n    void calc_state( time_type t , StateOut &x )\n    {\n        m_stepper.stepper().calc_state( t , x , get_old_state() , m_t_old , get_current_state() , m_t );\n    }\n\n    template< class StateOut >\n    void calc_state( time_type t , const StateOut &x )\n    {\n        m_stepper.stepper().calc_state( t , x , get_old_state() , m_t_old , get_current_state() , m_t );\n    }\n\n\n    template< class StateType >\n    void adjust_size( const StateType &x )\n    {\n        m_stepper.adjust_size( x );\n        resize_impl( x );\n    }\n\n\n\n\n    const state_type& current_state( void ) const\n    {\n        return get_current_state();\n    }\n\n    time_type current_time( void ) const\n    {\n        return m_t;\n    }\n\n    const state_type& previous_state( void ) const\n    {\n        return get_old_state();\n    }\n\n    time_type previous_time( void ) const\n    {\n        return m_t_old;\n    }\n\n    time_type current_time_step( void ) const\n    {\n        return m_dt;\n    }\n\n\n\n\nprivate:\n\n    state_type& get_current_state( void )\n    {\n        return m_current_state_x1 ? m_x1.m_v : m_x2.m_v ;\n    }\n\n    const state_type& get_current_state( void ) const\n    {\n        return m_current_state_x1 ? m_x1.m_v : m_x2.m_v ;\n    }\n\n    state_type& get_old_state( void )\n    {\n        return m_current_state_x1 ? m_x2.m_v : m_x1.m_v ;\n    }\n\n    const state_type& get_old_state( void ) const\n    {\n        return m_current_state_x1 ? m_x2.m_v : m_x1.m_v ;\n    }\n\n    void toggle_current_state( void )\n    {\n        m_current_state_x1 = ! m_current_state_x1;\n    }\n\n\n    template< class StateIn >\n    bool resize_impl( const StateIn &x )\n    {\n        bool resized = false;\n        resized |= adjust_size_by_resizeability( m_x1 , x , typename is_resizeable<state_type>::type() );\n        resized |= adjust_size_by_resizeability( m_x2 , x , typename is_resizeable<state_type>::type() );\n        return resized;\n    }\n\n\n    controlled_stepper_type m_stepper;\n    resizer_type m_resizer;\n    wrapped_state_type m_x1 , m_x2;\n    bool m_current_state_x1;\n    time_type m_t , m_t_old , m_dt;\n};\n\n\n\n}\n}\n}\n\n\n#endif\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/rosenbrock4_controller.hpp'\n:\n\n\n#ifndef BOOST_NUMERIC_ODEINT_STEPPER_ROSENBROCK4_CONTROLLER_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_STEPPER_ROSENBROCK4_CONTROLLER_HPP_INCLUDED\n\n#include <boost/config.hpp>\n#include <boost/numeric/odeint/util/bind.hpp>\n\n#include <boost/numeric/odeint/stepper/controlled_step_result.hpp>\n#include <boost/numeric/odeint/stepper/stepper_categories.hpp>\n\n#include <boost/numeric/odeint/util/copy.hpp>\n#include <boost/numeric/odeint/util/is_resizeable.hpp>\n\n#include <boost/numeric/odeint/stepper/rosenbrock4.hpp>\n\nnamespace boost {\nnamespace numeric {\nnamespace odeint {\n\ntemplate< class Stepper >\nclass rosenbrock4_controller\n{\nprivate:\n\n\npublic:\n\n    typedef Stepper stepper_type;\n    typedef typename stepper_type::value_type value_type;\n    typedef typename stepper_type::state_type state_type;\n    typedef typename stepper_type::wrapped_state_type wrapped_state_type;\n    typedef typename stepper_type::time_type time_type;\n    typedef typename stepper_type::deriv_type deriv_type;\n    typedef typename stepper_type::wrapped_deriv_type wrapped_deriv_type;\n    typedef typename stepper_type::resizer_type resizer_type;\n    typedef controlled_stepper_tag stepper_category;\n\n    typedef rosenbrock4_controller< Stepper > controller_type;\n\n\n    rosenbrock4_controller( value_type atol = 1.0e-6 , value_type rtol = 1.0e-6 , const stepper_type &stepper = stepper_type() )\n    : m_stepper( stepper ) , m_atol( atol ) , m_rtol( rtol ) ,\n      m_first_step( true ) , m_err_old( 0.0 ) , m_dt_old( 0.0 ) ,\n      m_last_rejected( false )\n    { }\n\n\n    value_type error( const state_type &x , const state_type &xold , const state_type &xerr )\n    {\n        BOOST_USING_STD_MAX();\n        using std::abs;\n\n        const size_t n = x.size();\n        value_type err = 0.0 , sk = 0.0;\n        for( size_t i=0 ; i<n ; ++i )\n        {\n            sk = m_atol + m_rtol * max BOOST_PREVENT_MACRO_SUBSTITUTION ( abs( xold[i] ) , abs( x[i] ) );\n            err += xerr[i] * xerr[i] / sk / sk;\n        }\n        return sqrt( err / value_type( n ) );\n    }\n\n    value_type last_error( void ) const\n    {\n        return m_err_old;\n    }\n\n\n\n\n    template< class System >\n    boost::numeric::odeint::controlled_step_result\n    try_step( System sys , state_type &x , time_type &t , time_type &dt )\n    {\n        m_xnew_resizer.adjust_size( x , detail::bind( &controller_type::template resize_m_xnew< state_type > , detail::ref( *this ) , detail::_1 ) );\n        boost::numeric::odeint::controlled_step_result res = try_step( sys , x , t , m_xnew.m_v , dt );\n        if( res == success )\n        {\n            boost::numeric::odeint::copy( m_xnew.m_v , x );\n        }\n        return res;\n    }\n\n\n    template< class System >\n    boost::numeric::odeint::controlled_step_result\n    try_step( System sys , const state_type &x , time_type &t , state_type &xout , time_type &dt )\n    {\n        BOOST_USING_STD_MIN();\n        BOOST_USING_STD_MAX();\n        using std::pow;\n\n        static const value_type safe = 0.9 , fac1 = 5.0 , fac2 = 1.0 / 6.0;\n\n        m_xerr_resizer.adjust_size( x , detail::bind( &controller_type::template resize_m_xerr< state_type > , detail::ref( *this ) , detail::_1 ) );\n\n        m_stepper.do_step( sys , x , t , xout , dt , m_xerr.m_v );\n        value_type err = error( xout , x , m_xerr.m_v );\n\n        value_type fac = max BOOST_PREVENT_MACRO_SUBSTITUTION ( fac2 , min BOOST_PREVENT_MACRO_SUBSTITUTION ( fac1 , pow( err , 0.25 ) / safe ) );\n        value_type dt_new = dt / fac;\n        if ( err <= 1.0 )\n        {\n            if( m_first_step )\n            {\n                m_first_step = false;\n            }\n            else\n            {\n                value_type fac_pred = ( m_dt_old / dt ) * pow( err * err / m_err_old , 0.25 ) / safe;\n                fac_pred = max BOOST_PREVENT_MACRO_SUBSTITUTION ( fac2 , min BOOST_PREVENT_MACRO_SUBSTITUTION ( fac1 , fac_pred ) );\n                fac = max BOOST_PREVENT_MACRO_SUBSTITUTION ( fac , fac_pred );\n                dt_new = dt / fac;\n            }\n\n            m_dt_old = dt;\n            m_err_old = max BOOST_PREVENT_MACRO_SUBSTITUTION ( 0.01 , err );\n            if( m_last_rejected )\n                dt_new = ( dt >= 0.0 ? min BOOST_PREVENT_MACRO_SUBSTITUTION ( dt_new , dt ) : max BOOST_PREVENT_MACRO_SUBSTITUTION ( dt_new , dt ) );\n            t += dt;\n            dt = dt_new;\n            m_last_rejected = false;\n            return success;\n        }\n        else\n        {\n            dt = dt_new;\n            m_last_rejected = true;\n            return fail;\n        }\n    }\n\n\n    template< class StateType >\n    void adjust_size( const StateType &x )\n    {\n        resize_m_xerr( x );\n        resize_m_xnew( x );\n    }\n\n\n\n    stepper_type& stepper( void )\n    {\n        return m_stepper;\n    }\n\n    const stepper_type& stepper( void ) const\n    {\n        return m_stepper;\n    }\n\n\n\n\nprivate:\n\n    template< class StateIn >\n    bool resize_m_xerr( const StateIn &x )\n    {\n        return adjust_size_by_resizeability( m_xerr , x , typename is_resizeable<state_type>::type() );\n    }\n\n    template< class StateIn >\n    bool resize_m_xnew( const StateIn &x )\n    {\n        return adjust_size_by_resizeability( m_xnew , x , typename is_resizeable<state_type>::type() );\n    }\n\n\n    stepper_type m_stepper;\n    resizer_type m_xerr_resizer;\n    resizer_type m_xnew_resizer;\n    wrapped_state_type m_xerr;\n    wrapped_state_type m_xnew;\n    value_type m_atol , m_rtol;\n    bool m_first_step;\n    value_type m_err_old , m_dt_old;\n    bool m_last_rejected;\n};\n\n\n\n\n\n\n}\n}\n}\n\n\n#endif\n\n'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/integrate_implicit.cpp'\n:\n\n#define BOOST_TEST_MODULE odeint_integrate_functions_implicit\n\n#include <vector>\n#include <cmath>\n#include <iostream>\n\n#include <boost/numeric/odeint/config.hpp>\n\n#include <boost/array.hpp>\n#include <boost/ref.hpp>\n#include <boost/iterator/counting_iterator.hpp>\n#include <boost/numeric/ublas/vector.hpp>\n#include <boost/numeric/ublas/matrix.hpp>\n\n#include <boost/test/unit_test.hpp>\n\n#include <boost/mpl/vector.hpp>\n\n#include <boost/numeric/odeint/integrate/integrate_const.hpp>\n#include <boost/numeric/odeint/integrate/integrate_adaptive.hpp>\n#include <boost/numeric/odeint/integrate/integrate_times.hpp>\n#include <boost/numeric/odeint/integrate/integrate_n_steps.hpp>\n#include <boost/numeric/odeint/stepper/rosenbrock4.hpp>\n#include <boost/numeric/odeint/stepper/rosenbrock4_controller.hpp>\n#include <boost/numeric/odeint/stepper/rosenbrock4_dense_output.hpp>\n\n\nusing namespace boost::unit_test;\nusing namespace boost::numeric::odeint;\nnamespace mpl = boost::mpl;\nnamespace ublas = boost::numeric::ublas;\n\ntypedef double value_type;\ntypedef ublas::vector< value_type > state_type;\ntypedef boost::numeric::ublas::matrix< value_type > matrix_type;\n\nstruct sys\n{\n    void operator()( const state_type &x , state_type &dxdt , const value_type &t ) const\n    {\n        dxdt( 0 ) = x( 0 ) + 2 * x( 1 );\n        dxdt( 1 ) = x( 1 );\n    }\n};\n\nstruct jacobi\n{\n    void operator()( const state_type &x , matrix_type &jacobi , const value_type &t , state_type &dfdt ) const\n    {\n        jacobi( 0 , 0 ) = 1;\n        jacobi( 0 , 1 ) = 2;\n        jacobi( 1 , 0 ) = 0;\n        jacobi( 1 , 1 ) = 1;\n        dfdt( 0 ) = 0.0;\n        dfdt( 1 ) = 0.0;\n    }\n};\n\nstruct push_back_time\n{\n    std::vector< double >& m_times;\n\n    push_back_time( std::vector< double > &times )\n    :  m_times( times ) { }\n\n    void operator()( const state_type &x , double t )\n    {\n        m_times.push_back( t );\n    }\n};\n\ntemplate< class Stepper >\nstruct perform_integrate_const_test\n{\n    void operator()( void )\n    {\n        state_type x( 2 , 1.0 );\n        const value_type dt = 0.03;\n        const value_type t_end = 10.0;\n\n        std::vector< value_type > times;\n\n        integrate_const( Stepper() , std::make_pair( sys() , jacobi() ) , x , 0.0 , t_end ,\n                                        dt , push_back_time( times ) );\n\n        BOOST_CHECK_EQUAL( static_cast<int>(times.size()) , static_cast<int>(floor(t_end/dt))+1 );\n\n        for( size_t i=0 ; i<times.size() ; ++i )\n        {\n\n\n            BOOST_CHECK_SMALL( times[i] - static_cast< value_type >(i)*dt , (i+1) * 2.0e-16 );\n        }\n    }\n};\n\ntemplate< class Stepper >\nstruct perform_integrate_adaptive_test\n{\n    void operator()( void )\n    {\n        state_type x( 2 , 1.0 );\n        const value_type dt = 0.03;\n        const value_type t_end = 10.0;\n\n        std::vector< value_type > times;\n\n        size_t steps = integrate_adaptive( Stepper() , std::make_pair( sys() , jacobi() ) , x , 0.0 , t_end ,\n                                        dt , push_back_time( times ) );\n\n        BOOST_CHECK_EQUAL( times.size() , steps+1 );\n\n        BOOST_CHECK_SMALL( times[0] - 0.0 , 2.0e-16 );\n        BOOST_CHECK_SMALL( times[times.size()-1] - t_end , times.size() * 3.0e-16 );\n    }\n};\n\n\ntemplate< class Stepper >\nstruct perform_integrate_times_test\n{\n    void operator()( void )\n    {\n        state_type x( 2 , 1.0 );\n\n        const value_type dt = 0.03;\n\n        std::vector< double > times;\n\n\n        integrate_times( Stepper() , std::make_pair( sys() , jacobi() ) , x ,\n                    boost::counting_iterator<int>(0) , boost::counting_iterator<int>(10) ,\n                    dt , push_back_time( times ) );\n\n        BOOST_CHECK_EQUAL( static_cast<int>(times.size()) , 10 );\n\n        for( size_t i=0 ; i<times.size() ; ++i )\n\n            BOOST_CHECK_EQUAL( times[i] , static_cast<double>(i) );\n    }\n};\n\ntemplate< class Stepper >\nstruct perform_integrate_n_steps_test\n{\n    void operator()( void )\n    {\n        state_type x( 2 , 1.0 );\n\n        const value_type dt = 0.03;\n        const int n = 200;\n\n        std::vector< double > times;\n\n\n        value_type end_time = integrate_n_steps( Stepper() , std::make_pair( sys() , jacobi() ) , x , 0.0 , dt , n , push_back_time( times ) );\n\n        BOOST_CHECK_SMALL( end_time - n*dt , 3.0e-16 );\n        BOOST_CHECK_EQUAL( static_cast<int>(times.size()) , n+1 );\n\n        for( size_t i=0 ; i<times.size() ; ++i )\n\n            BOOST_CHECK_SMALL( times[i] - static_cast< value_type >(i)*dt , (i+1) * 2.0e-16 );\n    }\n};\n\n\n\nclass stepper_methods : public mpl::vector<\n    rosenbrock4< value_type > ,\n    rosenbrock4_controller< rosenbrock4< value_type > > ,\n    rosenbrock4_dense_output< rosenbrock4_controller< rosenbrock4< value_type > > >\n> { };\n\n\n\nBOOST_AUTO_TEST_SUITE( integrate_test )\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_const_test_case , Stepper, stepper_methods )\n{\n    perform_integrate_const_test< Stepper > tester;\n    tester();\n}\n\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_adaptive_test_case , Stepper, stepper_methods )\n{\n    perform_integrate_adaptive_test< Stepper > tester;\n    tester();\n}\n\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_times_test_case , Stepper, stepper_methods )\n{\n    perform_integrate_times_test< Stepper > tester;\n    tester();\n}\n\n\nclass simple_stepper_methods : public mpl::vector<\n    rosenbrock4< value_type >\n> { };\n\nBOOST_AUTO_TEST_CASE_TEMPLATE( integrate_n_steps_test_case , Stepper, simple_stepper_methods )\n{\n    perform_integrate_n_steps_test< Stepper > tester;\n    tester();\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n",
        "gt": [
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/rosenbrock4_controller.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/boost/numeric/odeint/stepper/rosenbrock4_dense_output.hpp'",
            "'Implicit-SVSDF-Planner/src/uav_simulator/so3_quadrotor_simulator/include/ode/libs/numeric/odeint/test/integrate_implicit.cpp'"
        ]
    },
    {
        "files": [
            "'webpp/examples/003-FCGI-hello-world/main.cpp'",
            "'webpp/webpp/http/routes/path_valves.hpp'",
            "'webpp/webpp/http/routes/static_router.hpp'",
            "'webpp/webpp/http/routes/valves.hpp'",
            "'webpp/examples/003-FCGI-hello-world/app.h'",
            "'webpp/webpp/webpp.hpp'"
        ],
        "content": "'webpp/examples/003-FCGI-hello-world/main.cpp'\n:#include \"app.h\"\n\n#include <webpp/fcgi/fcgi.hpp>\n\nint main() {\n    webpp::http::fastcgi::fcgi<app> my_app;\n    return my_app();\n}\n\n'webpp/webpp/http/routes/path_valves.hpp'\n:\n\n#ifndef WEBPP_HTTP_ROUTES_PATH_VALVES_HPP\n#define WEBPP_HTTP_ROUTES_PATH_VALVES_HPP\n\n#include \"../../std/concepts.hpp\"\n#include \"../../std/string.hpp\"\n#include \"../../std/string_concepts.hpp\"\n#include \"../../std/string_view.hpp\"\n#include \"valve_traits.hpp\"\n\nnamespace webpp::http {\n\n    static constexpr struct endpath_valve {\n        template <Traits TraitsType>\n        [[nodiscard]] constexpr bool operator()(basic_context<TraitsType>& ctx) const noexcept {\n            return ctx.path_traverser().at_end();\n        }\n\n        constexpr void to_string(istl::String auto& out) const {\n            out.append(\" endpath\");\n        }\n    } endpath;\n\n\n    template <typename... CallableSegments>\n    struct segment_valve : valve<segment_valve<CallableSegments...>>, stl::tuple<CallableSegments...> {\n        static_assert((true && ... && !istl::StringLiteral<CallableSegments>),\n                      \"Callables should not be strings\");\n        using valve_type = valve<segment_valve<CallableSegments...>>;\n        using tuple_type = stl::tuple<CallableSegments...>;\n\n        constexpr segment_valve() noexcept(stl::is_nothrow_default_constructible_v<tuple_type>)\n            requires(stl::is_default_constructible_v<tuple_type>)\n        = default;\n\n        template <typename... Args>\n            requires stl::constructible_from<tuple_type, Args...>\n        explicit constexpr segment_valve(Args&&... args)\n          noexcept(stl::is_nothrow_constructible_v<tuple_type, Args...>)\n          : tuple_type{stl::forward<Args>(args)...} {}\n\n        constexpr segment_valve(segment_valve const&)                     = default;\n        constexpr segment_valve(segment_valve&&) noexcept                 = default;\n        constexpr segment_valve& operator=(segment_valve&&) noexcept      = default;\n        constexpr segment_valve& operator=(segment_valve const&) noexcept = default;\n        constexpr ~segment_valve()                                        = default;\n\n        using valve_type::operator();\n\n        template <Traits TraitsType>\n        constexpr bool operator()(basic_context<TraitsType>& ctx) {\n            using context_type = basic_context<TraitsType>;\n            return stl::apply(\n              [&ctx]<typename... T>(T&&... callables) constexpr {\n                  return (\n                    valve_traits<T, context_type>::call_set_get(stl::forward<T>(callables), ctx) && ...);\n              },\n              as_tuple());\n        }\n\n        [[nodiscard]] constexpr tuple_type& as_tuple() noexcept {\n            return *static_cast<tuple_type*>(this);\n        }\n\n        [[nodiscard]] constexpr tuple_type const& as_tuple() const noexcept {\n            return *static_cast<tuple_type const*>(this);\n        }\n\n        constexpr void to_string(istl::String auto& out) const {\n            stl::apply(\n              [&out]<typename... T>(T&&... callables) constexpr {\n                  int index = 0;\n                  (([&out, &index](auto&& callable) constexpr {\n                       if (index++ != 0) {\n                           out.append(\" /\");\n                       }\n                       valve_to_string(out, callable);\n                   })(stl::forward<T>(callables)),\n                   ...);\n              },\n              as_tuple());\n        }\n\n        template <typename RouterT>\n            requires((ValveRequiresSetup<RouterT, CallableSegments> || ...))\n        constexpr void setup(RouterT& inp_router) {\n            istl::for_each_element(\n              [&inp_router]<typename T>(T& callable) constexpr {\n                  if constexpr (ValveRequiresSetup<RouterT, T>) {\n                      callable.setup(inp_router);\n                  }\n              },\n              as_tuple());\n        }\n    };\n\n    template <typename Segment>\n    struct segment_string {\n      private:\n        Segment seg;\n\n      public:\n        explicit constexpr segment_string(Segment&& inp_seg) noexcept : seg{stl::move(inp_seg)} {}\n\n        explicit constexpr segment_string(Segment const& inp_seg) : seg{inp_seg} {}\n\n        constexpr segment_string(segment_string const&)                = default;\n        constexpr segment_string(segment_string&&) noexcept            = default;\n        constexpr ~segment_string()                                    = default;\n        constexpr segment_string& operator=(segment_string const&)     = default;\n        constexpr segment_string& operator=(segment_string&&) noexcept = default;\n\n        template <typename TraitsType>\n        [[nodiscard]] constexpr bool operator()(basic_context<TraitsType>& ctx) const noexcept {\n            return ctx.check_segment(seg);\n        }\n\n        constexpr void to_string(istl::String auto& out) const {\n            out.append(\" \");\n            out.append(seg);\n        }\n    };\n\n    template <typename Seg>\n    segment_string(Seg&&) -> segment_string<stl::remove_cvref_t<Seg>>;\n\n    template <istl::StringLiteral StrT>\n    [[nodiscard]] static constexpr auto tag_invoke([[maybe_unused]] valvify_tag tag, StrT&& next) noexcept {\n        return segment_string{istl::string_viewify(stl::forward<StrT>(next))};\n    }\n\n\n    template <istl::StringView T>\n    [[nodiscard]] static constexpr auto tag_invoke([[maybe_unused]] valvify_tag tag, T&& next) noexcept {\n        return segment_string{stl::forward<T>(next)};\n    }\n\n\n    template <istl::String T>\n    [[nodiscard]] static constexpr auto tag_invoke([[maybe_unused]] valvify_tag tag, T&& next) {\n        return segment_string{stl::forward<T>(next)};\n    }\n\n}\n\n#endif\n\n'webpp/webpp/http/routes/static_router.hpp'\n:#ifndef WEBPP_HTTP_STATIC_ROUTER_HPP\n#define WEBPP_HTTP_STATIC_ROUTER_HPP\n\n#include \"valves.hpp\"\n\nnamespace webpp::http {\n    template <typename ObjectsType, typename RoutesType>\n    struct static_router;\n\n\n    template <typename... ObjectType, typename... RouteType>\n    struct static_router<istl::type_list<ObjectType...>, istl::type_list<RouteType...>> {\n        using routes_type  = forward_valve<RouteType...>;\n        using objects_type = stl::tuple<ObjectType...>;\n\n      private:\n        routes_type routes;\n\n        constexpr void setup_routes() {\n            istl::for_each_element(\n              [this](auto& route) {\n                  setup_route(route, *this);\n              },\n              routes.as_tuple());\n        }\n\n      public:\n\n        [[no_unique_address]] objects_type objects{};\n\n\n\n        explicit constexpr static_router(RouteType&&... _route) : routes{stl::forward<RouteType>(_route)...} {\n            setup_routes();\n        }\n\n        explicit constexpr static_router(stl::tuple<RouteType...>&& inp_routes)\n          : routes{stl::move(inp_routes)} {\n            setup_routes();\n        }\n\n        explicit constexpr static_router(stl::tuple<RouteType...> const& inp_routes) : routes{inp_routes} {\n            setup_routes();\n        }\n\n        explicit constexpr static_router(objects_type inp_objects, RouteType&&... inp_routes)\n          : routes{stl::forward<RouteType>(inp_routes)...},\n            objects{stl::move(inp_objects)} {\n            setup_routes();\n        }\n\n        constexpr static_router(objects_type inp_objects, stl::tuple<RouteType...> const& inp_routes)\n          : routes{inp_routes},\n            objects{stl::move(inp_objects)} {\n            setup_routes();\n        }\n\n        constexpr static_router(objects_type inp_objects, stl::tuple<RouteType...>&& inp_routes)\n          : routes{stl::move(inp_routes)},\n            objects{stl::move(inp_objects)} {\n            setup_routes();\n        }\n\n        constexpr static_router(static_router const&) noexcept = default;\n        constexpr static_router(static_router&&) noexcept      = default;\n        constexpr ~static_router()                             = default;\n\n        constexpr static_router& operator=(static_router&&) noexcept = default;\n        constexpr static_router& operator=(static_router const&)     = default;\n\n\n        [[nodiscard]] static constexpr stl::size_t route_count() noexcept {\n            return sizeof...(RouteType);\n        }\n\n\n        template <stl::size_t N = 0>\n        consteval auto& operator[](stl::size_t const index) const noexcept {\n            if (N == index) {\n                return stl::get<N>(routes);\n            }\n            if constexpr (N + 1 < route_count()) {\n                return operator[]<N + 1>(index);\n            }\n\n            stl::terminate();\n        }\n\n        constexpr routes_type const& get_routes() const noexcept {\n            return routes;\n        }\n\n\n        template <HTTPRequest RequestType>\n        constexpr HTTPResponse auto operator()(RequestType&& req) {\n            using req_type     = stl::remove_cvref_t<RequestType>;\n            using traits_type  = typename req_type::traits_type;\n            using context_type = basic_context<traits_type>;\n            context_type ctx{req};\n\n            routes(ctx);\n\n            if (ctx.response.empty()) {\n\n                ctx.response = http::status_code::not_found;\n            }\n            return stl::move(ctx.response);\n        }\n\n\n        template <Traits TraitsType>\n        constexpr void operator()(basic_context<TraitsType>& ctx) {\n            routes(ctx);\n        }\n\n\n        template <istl::String StrT>\n        constexpr void to_string(StrT& out) const {\n            routes.to_string(out);\n        }\n\n\n        template <istl::String StrT = stl::string, typename... Args>\n        [[nodiscard]] constexpr StrT to_string(Args&&... args) const {\n            StrT out{stl::forward<Args>(args)...};\n            to_string(out);\n            return out;\n        }\n    };\n\n    template <typename... RouteType>\n    static_router(RouteType&&...) -> static_router<istl::type_list<>, istl::type_list<RouteType...>>;\n\n    template <typename... RouteType>\n    static_router(\n      stl::tuple<RouteType...>&&) -> static_router<istl::type_list<>, istl::type_list<RouteType...>>;\n\n    template <typename... RouteType>\n    static_router(\n      stl::tuple<RouteType...> const&) -> static_router<istl::type_list<>, istl::type_list<RouteType...>>;\n\n    template <typename... RouteType>\n    static_router(\n      stl::tuple<RouteType...>&) -> static_router<istl::type_list<>, istl::type_list<RouteType...>>;\n\n    template <typename... ObjectsType, typename... RouteType>\n    static_router(\n      stl::tuple<ObjectsType...>,\n      RouteType&&...) -> static_router<istl::type_list<ObjectsType...>, istl::type_list<RouteType...>>;\n\n    template <typename... ObjectsType, typename... RouteType>\n    static_router(stl::tuple<ObjectsType...>, stl::tuple<RouteType...>&&)\n      -> static_router<istl::type_list<ObjectsType...>, istl::type_list<RouteType...>>;\n\n    template <typename... ObjectsType, typename... RouteType>\n    static_router(stl::tuple<ObjectsType...>, stl::tuple<RouteType...> const&)\n      -> static_router<istl::type_list<ObjectsType...>, istl::type_list<RouteType...>>;\n\n    template <typename... ObjectsType, typename... RouteType>\n    static_router(stl::tuple<ObjectsType...>, stl::tuple<RouteType...>&)\n      -> static_router<istl::type_list<ObjectsType...>, istl::type_list<RouteType...>>;\n\n}\n\n#endif\n\n'webpp/webpp/http/routes/valves.hpp'\n:\n\n#ifndef WEBPP_HTTP_ROUTER_VALVE_HPP\n#define WEBPP_HTTP_ROUTER_VALVE_HPP\n\n#include \"../../std/tuple.hpp\"\n#include \"grouping_valves.hpp\"\n#include \"logical_valves.hpp\"\n#include \"member_function_valves.hpp\"\n#include \"path_valves.hpp\"\n#include \"router_concepts.hpp\"\n#include \"valve_traits.hpp\"\n\nnamespace webpp::http {\n\n    template <typename Self>\n    struct valve {\n        template <template <typename...> typename T>\n        static constexpr bool is_self_of = istl::template_of_v<T, Self>;\n\n        using routes_type = typename routes_type_of_valve<Self>::type;\n\n        template <template <typename...> typename T>\n        static constexpr bool is_routes_of = istl::template_of_v<T, routes_type>;\n\n        template <typename Callable>\n        [[nodiscard]] constexpr auto operator>>(Callable&& callable) const {\n            using callable_type = stl::remove_cvref_t<Callable>;\n            if constexpr (is_routes_of<forward_valve>) {\n                if constexpr (istl::template_of_v<forward_valve, callable_type>) {\n\n\n                    return rebind_self<forward_valve>(\n                      stl::tuple_cat(routes().as_tuple(), callable.as_tuple()));\n                } else {\n                    return rebind_self<forward_valve>(\n                      stl::tuple_cat(routes().as_tuple(),\n                                     stl::make_tuple(valvify(stl::forward<Callable>(callable)))));\n                }\n\n\n\n\n\n\n\n            } else {\n                return rebind_next<forward_valve>(stl::forward<Callable>(callable));\n            }\n        }\n\n        template <typename Callable>\n        [[nodiscard]] constexpr auto operator&&([[maybe_unused]] Callable&& callable) const {\n            using callable_type = stl::remove_cvref_t<Callable>;\n\n            if constexpr (stl::same_as<routes_type, callable_type>) {\n                return *this;\n            } else if constexpr (stl::same_as<not_valve<routes_type>, callable_type>) {\n                return rebind_self<negative_valve>(routes());\n            } else if constexpr (stl::same_as<routes_type, not_valve<callable_type>>) {\n                return rebind_self<negative_valve>(stl::forward<Callable>(callable));\n            } else {\n                return rebind_next<and_valve>(stl::forward<Callable>(callable));\n            }\n        }\n\n        template <typename Callable>\n        [[nodiscard]] constexpr auto operator||(Callable&& callable) const {\n            using callable_type = stl::remove_cvref_t<Callable>;\n\n            if constexpr (stl::same_as<routes_type, callable_type>) {\n                return *this;\n            } else if constexpr (stl::same_as<not_valve<routes_type>, callable_type>) {\n                return rebind_self<positive_valve>(routes());\n            } else if constexpr (stl::same_as<routes_type, not_valve<callable_type>>) {\n                return rebind_self<positive_valve>(stl::forward<Callable>(callable));\n            } else {\n                return rebind_next<or_valve>(stl::forward<Callable>(callable));\n            }\n        }\n\n        [[nodiscard]] constexpr auto operator!() const {\n            if constexpr (istl::remove_template_of_v<not_valve, routes_type>) {\n\n                if constexpr (stl::same_as<bool, typename valve_traits<routes_type>::return_type>) {\n\n                    return routes().unwrap();\n                } else {\n                    return rebind_self<positive_valve>(routes().unwrap());\n                }\n            } else {\n                return rebind_next<not_valve>();\n            }\n        }\n\n        template <typename Callable>\n        [[nodiscard]] constexpr auto operator+(Callable&& callable) const {\n            if constexpr (is_self_of<valves_group>) {\n                return self()->append_postroute(valvify(stl::forward<Callable>(callable)));\n            } else {\n                return valves_group{postrouting_valve{valvify(stl::forward<Callable>(callable))}, routes()};\n            }\n        }\n\n        template <typename Callable>\n        [[nodiscard]] constexpr auto operator-(Callable&& callable) const {\n            if constexpr (is_self_of<valves_group>) {\n                return self()->append_preroute(valvify(stl::forward<Callable>(callable)));\n            } else {\n                return valves_group{prerouting_valve{valvify(stl::forward<Callable>(callable))}, routes()};\n            }\n        }\n\n        template <typename Callable>\n        [[nodiscard]] constexpr auto operator*(Callable&& callable) const {\n            if constexpr (is_self_of<valves_group>) {\n                return self()->append_mangler(valvify(stl::forward<Callable>(callable)));\n            } else {\n                return valves_group{mangler_valve{valvify(stl::forward<Callable>(callable))}, routes()};\n            }\n        }\n\n        template <typename CallableSegment>\n        [[nodiscard]] constexpr auto operator/(CallableSegment&& inp_segment) const {\n            using seg_type = stl::remove_cvref_t<CallableSegment>;\n            if constexpr (is_routes_of<segment_valve>) {\n                if constexpr (istl::template_of_v<segment_valve, seg_type>) {\n\n\n                    return rebind_self<segment_valve>(\n                      stl::tuple_cat(routes().as_tuple(), inp_segment.as_tuple()));\n                } else {\n                    return rebind_self<segment_valve>(\n                      stl::tuple_cat(routes().as_tuple(),\n                                     stl::make_tuple(valvify(stl::forward<CallableSegment>(inp_segment)))));\n                }\n            } else {\n                return rebind_next<segment_valve>(stl::forward<CallableSegment>(inp_segment));\n            }\n        }\n\n        template <typename SegT>\n        [[nodiscard]] constexpr auto operator%(SegT&& inp_segment) const {\n            using seg_type = stl::remove_cvref_t<SegT>;\n            if constexpr (is_routes_of<segment_valve>) {\n                if constexpr (istl::template_of_v<segment_valve, seg_type>) {\n\n\n                    return rebind_self<segment_valve>(\n                      stl::tuple_cat(routes().as_tuple(), inp_segment.as_tuple(), stl::make_tuple(endpath)));\n                } else {\n                    return rebind_self<segment_valve>(stl::tuple_cat(\n                      routes().as_tuple(),\n                      stl::make_tuple(valvify(stl::forward<SegT>(inp_segment))),\n                      stl::make_tuple(endpath)));\n                }\n            } else {\n                return rebind_next<segment_valve>(stl::forward<SegT>(inp_segment), endpath);\n            }\n        }\n\n\n\n        template <Context CtxT>\n            requires(\n              !stl::is_void_v<Self> &&\n              requires {\n                  typename stl::remove_cvref_t<CtxT>::traits_type;\n                  requires !istl::cvref_as<CtxT,\n                                           basic_context<typename stl::remove_cvref_t<CtxT>::traits_type>>;\n              })\n        [[nodiscard]] constexpr auto operator()(CtxT&& inp_ctx) {\n            using traits_type  = typename stl::remove_cvref_t<CtxT>::traits_type;\n            using context_type = basic_context<traits_type>;\n            context_type ctx{stl::forward<CtxT>(inp_ctx)};\n            (*self())(ctx);\n            return stl::move(ctx.response);\n        }\n\n\n      private:\n        [[nodiscard]] constexpr auto const* self() const noexcept\n            requires(!stl::is_void_v<Self>)\n        {\n            return static_cast<Self const*>(this);\n        }\n\n        [[nodiscard]] constexpr auto* self() noexcept\n            requires(!stl::is_void_v<Self>)\n        {\n            return static_cast<Self*>(this);\n        }\n\n        [[nodiscard]] constexpr decltype(auto) routes() noexcept {\n            if constexpr (stl::is_void_v<Self>) {\n                return forward_valve<>{};\n            } else {\n                if constexpr (is_self_of<valves_group>) {\n                    return self()->get_routes();\n                } else {\n                    return *self();\n                }\n            }\n        }\n\n        [[nodiscard]] constexpr decltype(auto) routes() const noexcept {\n            if constexpr (stl::is_void_v<Self>) {\n                return forward_valve<>{};\n            } else {\n                if constexpr (is_self_of<valves_group>) {\n                    return self()->get_routes();\n                } else {\n                    return *self();\n                }\n            }\n        }\n\n        template <template <typename...> typename Templ, typename... T, typename... Args>\n        [[nodiscard]] constexpr auto rebind_next(Args&&... nexts) const {\n\n\n            if constexpr (stl::is_void_v<Self> ||\n                          (is_self_of<valves_group> && istl::cvref_as<decltype(routes()), forward_valve<>>) )\n            {\n                return rebind_self<Templ, T...>(stl::forward<Args>(nexts)...);\n            } else {\n                return rebind_self<Templ, T...>(routes(), stl::forward<Args>(nexts)...);\n            }\n        }\n\n\n\n        template <template <typename...> typename Templ, typename... T, typename... TupT>\n        [[nodiscard]] constexpr auto rebind_self(stl::tuple<TupT...>&& nexts) const {\n            using valve_type = Templ<T..., valvified_type<TupT>...>;\n            if constexpr (is_self_of<valves_group>) {\n                return self()->replace_route(\n                  ([&nexts]<stl::size_t... I>(stl::index_sequence<I...>) constexpr {\n                      return valve_type{valvify(stl::move(stl::get<I>(nexts)))...};\n                  })(stl::index_sequence_for<TupT...>{}));\n            } else {\n                return ([&nexts]<stl::size_t... I>(stl::index_sequence<I...>) constexpr {\n                    return valve_type{valvify(stl::move(stl::get<I>(nexts)))...};\n                })(stl::index_sequence_for<TupT...>{});\n            }\n        }\n\n        template <template <typename...> typename Templ, typename... T, typename... Args>\n        [[nodiscard]] constexpr auto rebind_self(Args&&... nexts) const {\n            static_assert((Valvifiable<Args> && ...),\n                          \"We're not able to valvify the valve, \"\n                          \"did you include the required headers \"\n                          \"that defines the right valvify function?\");\n            using valve_type = Templ<T..., valvified_type<Args>...>;\n            static_assert(stl::is_constructible_v<valve_type, valvified_type<Args>...>,\n                          \"The specified valves are unknown even after valvifying them, \"\n                          \"did you forget to include the required headers that define \"\n                          \"the right valvify functions to convert your valves to the right type?\");\n            if constexpr (is_self_of<valves_group>) {\n                return self()->replace_route(valve_type{valvify(stl::forward<Args>(nexts))...});\n            } else {\n                return valve_type{valvify(stl::forward<Args>(nexts))...};\n            }\n        }\n    };\n\n\n}\n\n#endif\n\n'webpp/examples/003-FCGI-hello-world/app.h'\n:\n\n#ifndef WEBPP_FCGI_EXAMPLE_APP_H\n#define WEBPP_FCGI_EXAMPLE_APP_H\n\n#include <webpp/http/http.hpp>\n#include <webpp/webpp.hpp>\n\n\nstruct app {\n    using namespace webpp;\n    using namespace webpp::http;\n\n    auto home(Context auto& ctx) noexcept {\n        return ctx.string(\"Home page\");\n    }\n\n    auto about(Context auto& ctx) noexcept {\n        return ctx.string(\"About page\");\n    }\n\n    auto operator()(HTTPRequest auto& req) noexcept {\n        using extensions = extension_pack<string_response>;\n        const auto admin = []() {\n            return \"Nice page.\";\n        };\n\n\n        static_router router{get and root / \"home\" >>\n                                       [this](context& ctx) {\n                                           return this->home(ctx);\n                                       },\n                             get & (root / \"about\" >>\n                                    [this](context& ctx) {\n                                        return this->about(ctx);\n                                    }),\n                             root / \"admin\" >> admin};\n\n        return router(req);\n    }\n};\n\n#endif\n\n'webpp/webpp/webpp.hpp'\n:#ifndef WEBPP_WEBPP_HPP\n#define WEBPP_WEBPP_HPP\n\n#include \"http/bodies/string.hpp\"\n#include \"http/header_fields.hpp\"\n#include \"http/http.hpp\"\n#include \"http/request.hpp\"\n#include \"http/response.hpp\"\n#include \"http/response_body.hpp\"\n#include \"http/routes/context.hpp\"\n#include \"http/routes/dynamic_router.hpp\"\n#include \"http/routes/methods.hpp\"\n#include \"http/routes/static_router.hpp\"\n\n\n\n#endif\n",
        "gt": [
            "'webpp/webpp/http/routes/path_valves.hpp'",
            "'webpp/webpp/http/routes/valves.hpp'",
            "'webpp/webpp/http/routes/static_router.hpp'",
            "'webpp/webpp/webpp.hpp'",
            "'webpp/examples/003-FCGI-hello-world/app.h'",
            "'webpp/examples/003-FCGI-hello-world/main.cpp'"
        ]
    },
    {
        "files": [
            "'DataConfig/DataConfig/Source/DataConfigEngineExtra/Private/DataConfig/EngineExtra/SerDe/DcSerDeGameplayTags.cpp'",
            "'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Writer/DcWriter.h'",
            "'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyWriter.h'"
        ],
        "content": "'DataConfig/DataConfig/Source/DataConfigEngineExtra/Private/DataConfig/EngineExtra/SerDe/DcSerDeGameplayTags.cpp'\n:#include \"DataConfig/EngineExtra/SerDe/DcSerDeGameplayTags.h\"\n#include \"DataConfig/DcEnv.h\"\n#include \"DataConfig/Reader/DcReader.h\"\n#include \"DataConfig/Property/DcPropertyUtils.h\"\n#include \"DataConfig/Property/DcPropertyWriter.h\"\n#include \"DataConfig/Diagnostic/DcDiagnosticSerDe.h\"\n#include \"DataConfig/Diagnostic/DcDiagnosticReadWrite.h\"\n#include \"DataConfig/Automation/DcAutomation.h\"\n#include \"DataConfig/Automation/DcAutomationUtils.h\"\n#include \"DataConfig/EngineExtra/Diagnostic/DcDiagnosticEngineExtra.h\"\n#include \"DataConfig/Json/DcJsonReader.h\"\n#include \"DataConfig/Deserialize/DcDeserializeUtils.h\"\n#include \"DataConfig/Extra/Misc/DcTestCommon.h\"\n#include \"DataConfig/Json/DcJsonWriter.h\"\n#include \"DataConfig/Serialize/DcSerializeUtils.h\"\n\nnamespace DcEngineExtra {\n\nstatic FDcResult _StringToGameplayTag(FDcDeserializeContext& Ctx, const FString& Str, FGameplayTag* OutTagPtr)\n{\n\tFString FixedString;\n\tFText Err;\n\tif (!FGameplayTag::IsValidGameplayTagString(Str, &Err, &FixedString))\n\t{\n\t\treturn DC_FAIL(DcDEngineExtra, InvalidGameplayTagStringFixErr)\n\t\t\t<< Str << FixedString << Err;\n\t}\n\n\tFName TagName(*Str);\n\tFGameplayTag Tag = UGameplayTagsManager::Get().RequestGameplayTag(TagName, false);\n\tif (!Tag.IsValid())\n\t{\n\t\treturn DC_FAIL(DcDEngineExtra, InvalidGameplayTagString) << Str;\n\t}\n\n\t*OutTagPtr = Tag;\n\treturn DcOk();\n}\n\nFDcResult HandlerGameplayTagDeserialize(FDcDeserializeContext& Ctx)\n{\n\tEDcDataEntry Next;\n\tDC_TRY(Ctx.Reader->PeekRead(&Next));\n\n\tFDcPropertyDatum Datum;\n\tDC_TRY(Ctx.Writer->WriteDataEntry(FStructProperty::StaticClass(), Datum));\n\n\tUScriptStruct* Struct = DcPropertyUtils::TryGetStructClass(Datum.Property);\n\tif (Struct == nullptr\n\t\t|| Struct != FGameplayTag::StaticStruct())\n\t{\n\t\treturn DC_FAIL(DcDSerDe, StructNotFound)\n\t\t\t<< TEXT(\"GameplayTag\")\n\t\t\t<< Datum.Property.GetFName() << Datum.Property.GetClassName();\n\t}\n\n\tFGameplayTag* TagPtr = (FGameplayTag*)Datum.DataPtr;\n\n\tif (Next == EDcDataEntry::None)\n\t{\n\t\tDC_TRY(Ctx.Reader->ReadNone());\n\t\t*TagPtr = FGameplayTag::EmptyTag;\n\n\t\treturn DcOk();\n\t}\n\telse if (Next == EDcDataEntry::String)\n\t{\n\t\tFString Str;\n\t\tDC_TRY(Ctx.Reader->ReadString(&Str));\n\t\tDC_TRY(_StringToGameplayTag(Ctx, Str, TagPtr));\n\n\t\treturn DcOk();\n\t}\n\telse\n\t{\n\t\treturn DC_FAIL(DcDSerDe, DataEntryMismatch2)\n\t\t\t<< EDcDataEntry::None << EDcDataEntry::String << Next;\n\t}\n}\n\nFDcResult HandlerGameplayTagContainerDeserialize(FDcDeserializeContext& Ctx)\n{\n\tEDcDataEntry Next;\n\tDC_TRY(Ctx.Reader->PeekRead(&Next));\n\n\tFDcPropertyDatum Datum;\n\tDC_TRY(Ctx.Writer->WriteDataEntry(FStructProperty::StaticClass(), Datum));\n\n\tUScriptStruct* Struct = DcPropertyUtils::TryGetStructClass(Datum.Property);\n\tif (Struct == nullptr\n\t\t|| Struct != FGameplayTagContainer::StaticStruct())\n\t{\n\t\treturn DC_FAIL(DcDSerDe, StructNotFound)\n\t\t\t<< TEXT(\"GameplayTagContainer\")\n\t\t\t<< Datum.Property.GetFName() << Datum.Property.GetClassName();\n\t}\n\n\tFGameplayTagContainer* ContainerPtr = (FGameplayTagContainer*)Datum.DataPtr;\n\n\tDC_TRY(Ctx.Reader->ReadArrayRoot());\n\n\tEDcDataEntry CurPeek;\n\twhile (true)\n\t{\n\t\tDC_TRY(Ctx.Reader->PeekRead(&CurPeek));\n\t\tif (CurPeek == EDcDataEntry::ArrayEnd)\n\t\t\tbreak;\n\n\t\tFString Str;\n\t\tDC_TRY(Ctx.Reader->ReadString(&Str));\n\n\t\tFGameplayTag Tag;\n\t\tDC_TRY(_StringToGameplayTag(Ctx, Str, &Tag));\n\n\t\tContainerPtr->AddTag(Tag);\n\t}\n\n\tDC_TRY(Ctx.Reader->ReadArrayEnd());\n\n\treturn DcOk();\n}\n\nFDcResult HandlerGameplayTagSerialize(FDcSerializeContext& Ctx)\n{\n\tFDcPropertyDatum Datum;\n\tDC_TRY(Ctx.Reader->ReadDataEntry(FStructProperty::StaticClass(), Datum));\n\n\tUScriptStruct* Struct = DcPropertyUtils::TryGetStructClass(Datum.Property);\n\tif (Struct == FGameplayTag::StaticStruct())\n\t{\n\t\tFGameplayTag* GameplayTagPtr = (FGameplayTag*)Datum.DataPtr;\n\t\tif (GameplayTagPtr->IsValid())\n\t\t\tDC_TRY(Ctx.Writer->WriteString(GameplayTagPtr->ToString()));\n\t\telse\n\t\t\tDC_TRY(Ctx.Writer->WriteNone());\n\t}\n\telse\n\t{\n\t\treturn DC_FAIL(DcDReadWrite, PropertyMismatch)\n\t\t\t<< TEXT(\"GameplayTag\") << Datum.Property.GetFName() << Datum.Property.GetClassName();\n\t}\n\n\treturn DcOk();\n}\n\nFDcResult HandlerGameplayTagContainerSerialize(FDcSerializeContext& Ctx)\n{\n\tFDcPropertyDatum Datum;\n\tDC_TRY(Ctx.Reader->ReadDataEntry(FStructProperty::StaticClass(), Datum));\n\n\tUScriptStruct* Struct = DcPropertyUtils::TryGetStructClass(Datum.Property);\n\tif (Struct == FGameplayTagContainer::StaticStruct())\n\t{\n\t\tDC_TRY(Ctx.Writer->WriteArrayRoot());\n\t\tFGameplayTagContainer* GameplayTagContainerPtr = (FGameplayTagContainer*)Datum.DataPtr;\n\t\tfor (auto& Iter : *GameplayTagContainerPtr)\n\t\t\tDC_TRY(Ctx.Writer->WriteString(Iter.ToString()));\n\t\tDC_TRY(Ctx.Writer->WriteArrayEnd());\n\t}\n\telse\n\t{\n\t\treturn DC_FAIL(DcDReadWrite, PropertyMismatch)\n\t\t\t<< TEXT(\"GameplayTagContainer\") << Datum.Property.GetFName() << Datum.Property.GetClassName();\n\t}\n\n\treturn DcOk();\n}\n\n}\n\nDC_TEST(\"DataConfig.EngineExtra.GameplayTags\")\n{\n\tusing namespace DcEngineExtra;\n\tFDcEngineExtraTestStructWithGameplayTag1 Dest;\n\tFDcPropertyDatum DestDatum(&Dest);\n\n\tUTEST_TRUE(\"Has natively added 'DataConfig.Foo.Bar'\", UGameplayTagsManager::Get().RequestGameplayTag(TEXT(\"DataConfig.Foo.Bar\")).IsValid());\n\n\tFString Str = TEXT(R\"(\n\t\t{\n\t\t\t\"TagField1\" : null,\n\t\t\t\"TagField2\" : \"DataConfig.Foo.Bar\"\n\t\t}\n\t)\");\n\tFDcJsonReader Reader(Str);\n\n\t{\n\t\tUTEST_OK(\"Editor Extra FGameplayTag SerDe\", DcAutomationUtils::DeserializeFrom(&Reader, DestDatum,\n\t\t[](FDcDeserializeContext& Ctx) {\n\t\t\tCtx.Deserializer->AddStructHandler(\n\t\t\t\tTBaseStructure<FGameplayTag>::Get(),\n\t\t\t\tFDcDeserializeDelegate::CreateStatic(HandlerGameplayTagDeserialize)\n\t\t\t);\n\t\t}));\n\n\t\tUTEST_FALSE(\"Editor Extra FGameplayTag SerDe\", Dest.TagField1.IsValid());\n\t\tUTEST_TRUE(\"Editor Extra FGameplayTag SerDe\", Dest.TagField2.IsValid());\n\t\tUTEST_TRUE(\"Editor Extra FGameplayTag SerDe\", Dest.TagField2 == UGameplayTagsManager::Get().RequestGameplayTag(TEXT(\"DataConfig.Foo.Bar\")));\n\t}\n\n\t{\n\t\tFDcJsonWriter Writer;\n\t\tUTEST_OK(\"Editor Extra FGameplayTag SerDe\", DcAutomationUtils::SerializeInto(&Writer, DestDatum,\n\t\t[](FDcSerializeContext& Ctx) {\n\t\t\tCtx.Serializer->AddStructHandler(\n\t\t\t\tTBaseStructure<FGameplayTag>::Get(),\n\t\t\t\tFDcSerializeDelegate::CreateStatic(HandlerGameplayTagSerialize)\n\t\t\t);\n\t\t}));\n\t\tWriter.Sb << TCHAR('\\n');\n\t\tUTEST_EQUAL(\"Editor Extra FGameplayTag SerDe\", Writer.Sb.ToString(), DcAutomationUtils::DcReindentStringLiteral(Str));\n\t}\n\n\tFString StrBad = TEXT(R\"(\n\t\t{\n\t\t\t\"TagField1\" : \"DataConfig.Valid.But.Does.Not.Exist\"\n\t\t}\n\t)\");\n\tUTEST_OK(\"Editor Extra FGameplayTag SerDe\", Reader.SetNewString(*StrBad));\n\tUTEST_DIAG(\"Editor Extra FGameplayTag SerDe\", DcAutomationUtils::DeserializeFrom(&Reader, DestDatum,\n\t[](FDcDeserializeContext& Ctx) {\n\t\tCtx.Deserializer->AddStructHandler(\n\t\t\tTBaseStructure<FGameplayTag>::Get(),\n\t\t\tFDcDeserializeDelegate::CreateStatic(HandlerGameplayTagDeserialize)\n\t\t);\n\t}), DcDEngineExtra, InvalidGameplayTagString);\n\n\treturn true;\n}\n\nDC_TEST(\"DataConfig.EngineExtra.GameplayTagContainer\")\n{\n\tusing namespace DcEngineExtra;\n\tFDcEngineExtraTestStructWithGameplayTag2 Dest;\n\tFDcPropertyDatum DestDatum(&Dest);\n\n\tUTEST_TRUE(\"Has natively added 'DataConfig.Foo.Bar'\", UGameplayTagsManager::Get().RequestGameplayTag(TEXT(\"DataConfig.Foo.Bar\")).IsValid());\n\n\tFString Str = TEXT(R\"(\n\t\t{\n\t\t\t\"TagContainerField1\" : [],\n\t\t\t\"TagContainerField2\" : [\n\t\t\t\t\"DataConfig.Foo.Bar\",\n\t\t\t\t\"DataConfig.Foo.Bar.Baz\",\n\t\t\t\t\"DataConfig.Tar.Taz\"\n\t\t\t]\n\t\t}\n\t)\");\n\n\t{\n\t\tFDcJsonReader Reader(Str);\n\t\tUTEST_OK(\"Editor Extra FGameplayTagContainer SerDe\", DcAutomationUtils::DeserializeFrom(&Reader, DestDatum,\n\t\t[](FDcDeserializeContext& Ctx) {\n\t\t\tCtx.Deserializer->AddStructHandler(\n\t\t\t\tTBaseStructure<FGameplayTagContainer>::Get(),\n\t\t\t\tFDcDeserializeDelegate::CreateStatic(HandlerGameplayTagContainerDeserialize)\n\t\t\t);\n\t\t}));\n\n\t\tUTEST_TRUE(\"Editor Extra FGameplayTagContainer SerDe\", Dest.TagContainerField1.Num() == 0);\n\t\tUTEST_TRUE(\"Editor Extra FGameplayTagContainer SerDe\", Dest.TagContainerField2.Num() == 3);\n\t\tUTEST_TRUE(\"Editor Extra FGameplayTagContainer SerDe\", Dest.TagContainerField2.HasTagExact(\n\t\t\tUGameplayTagsManager::Get().RequestGameplayTag(TEXT(\"DataConfig.Foo.Bar\"))\n\t\t));\n\t\tUTEST_TRUE(\"Editor Extra FGameplayTagContainer SerDe\", Dest.TagContainerField2.HasTagExact(\n\t\t\tUGameplayTagsManager::Get().RequestGameplayTag(TEXT(\"DataConfig.Foo.Bar.Baz\"))\n\t\t));\n\t\tUTEST_TRUE(\"Editor Extra FGameplayTagContainer SerDe\", Dest.TagContainerField2.HasTagExact(\n\t\t\tUGameplayTagsManager::Get().RequestGameplayTag(TEXT(\"DataConfig.Tar.Taz\"))\n\t\t));\n\t}\n\n\t{\n\t\tFDcJsonWriter Writer;\n\t\tUTEST_OK(\"Editor Extra FGameplayTagContainer SerDe\", DcAutomationUtils::SerializeInto(&Writer, DestDatum,\n\t\t[](FDcSerializeContext& Ctx) {\n\t\t\tCtx.Serializer->AddStructHandler(\n\t\t\t\tTBaseStructure<FGameplayTagContainer>::Get(),\n\t\t\t\tFDcSerializeDelegate::CreateStatic(HandlerGameplayTagContainerSerialize)\n\t\t\t);\n\t\t}));\n\t\tWriter.Sb << TCHAR('\\n');\n\t\tUTEST_EQUAL(\"Editor Extra FGameplayTagContainer SerDe\", Writer.Sb.ToString(), DcAutomationUtils::DcReindentStringLiteral(Str));\n\t}\n\n\treturn true;\n}\n\n\n\n\n'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Writer/DcWriter.h'\n:#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Runtime/Launch/Resources/Version.h\"\n#include \"DataConfig/DcTypes.h\"\n\nstruct FDcDiagnostic;\n\nstruct DATACONFIGCORE_API FDcWriter\n{\n\tvirtual ~FDcWriter();\n\n\tvirtual FDcResult PeekWrite(EDcDataEntry Next, bool* bOutOk);\n\n\tvirtual FDcResult WriteNone();\n\tvirtual FDcResult WriteBool(bool Value);\n\tvirtual FDcResult WriteName(const FName& Value);\n\tvirtual FDcResult WriteString(const FString& Value);\n\tvirtual FDcResult WriteText(const FText& Value);\n\tvirtual FDcResult WriteEnum(const FDcEnumData& Value);\n\n\ttemplate<typename TEnum>\n\tFDcResult WriteEnumField(const TEnum& Value);\n\n\tvirtual FDcResult WriteStructRootAccess(FDcStructAccess& Access);\n\tvirtual FDcResult WriteStructEndAccess(FDcStructAccess& Access);\n\n\tvirtual FDcResult WriteClassRootAccess(FDcClassAccess& Access);\n\tvirtual FDcResult WriteClassEndAccess(FDcClassAccess& Access);\n\n\tFDcResult WriteStructRoot();\n\tFDcResult WriteStructEnd();\n\n\tFDcResult WriteClassRoot();\n\tFDcResult WriteClassEnd();\n\n\tvirtual FDcResult WriteMapRoot();\n\tvirtual FDcResult WriteMapEnd();\n\n\tvirtual FDcResult WriteArrayRoot();\n\tvirtual FDcResult WriteArrayEnd();\n\n\tvirtual FDcResult WriteSetRoot();\n\tvirtual FDcResult WriteSetEnd();\n\n\tvirtual FDcResult WriteOptionalRoot();\n\tvirtual FDcResult WriteOptionalEnd();\n\n\tvirtual FDcResult WriteObjectReference(const UObject* Value);\n\tvirtual FDcResult WriteClassReference(const UClass* Value);\n\n\tvirtual FDcResult WriteWeakObjectReference(const FWeakObjectPtr& Value);\n\tvirtual FDcResult WriteLazyObjectReference(const FLazyObjectPtr& Value);\n\tvirtual FDcResult WriteSoftObjectReference(const FSoftObjectPtr& Value);\n\tvirtual FDcResult WriteSoftClassReference(const FSoftObjectPtr& Value);\n\tvirtual FDcResult WriteInterfaceReference(const FScriptInterface& Value);\n\n\ttemplate<typename TObject>\n\tFDcResult WriteWeakObjectField(const TWeakObjectPtr<TObject>& Value);\n\ttemplate<typename TObject>\n\tFDcResult WriteLazyObjectField(const TLazyObjectPtr<TObject>& Value);\n\ttemplate<typename TObject>\n\tFDcResult WriteSoftObjectField(const TSoftObjectPtr<TObject>& Value);\n\ttemplate<typename TClass>\n\tFDcResult WriteSoftClassField(const TSoftClassPtr<TClass>& Value);\n\ttemplate<typename TInterface>\n\tFDcResult WriteInterfaceField(const TScriptInterface<TInterface>& Value);\n\n\tvirtual FDcResult WriteFieldPath(const FFieldPath& Value);\n\ttemplate<typename TProperty>\n\tFDcResult WritePropertyField(const TFieldPath<TProperty>& Value);\n\n\tvirtual FDcResult WriteDelegate(const FScriptDelegate& Value);\n\tvirtual FDcResult WriteMulticastInlineDelegate(const FMulticastScriptDelegate& Value);\n\tvirtual FDcResult WriteMulticastSparseDelegate(const FMulticastScriptDelegate& Value);\n\n\ttemplate<typename MulticastDelegate, typename OwningClass, typename DelegateInfoClass>\n\tFDcResult WriteSparseDelegateField(const TSparseDynamicDelegate<MulticastDelegate, OwningClass, DelegateInfoClass>& Value);\n\n\tvirtual FDcResult WriteInt8(const int8& Value);\n\tvirtual FDcResult WriteInt16(const int16& Value);\n\tvirtual FDcResult WriteInt32(const int32& Value);\n\tvirtual FDcResult WriteInt64(const int64& Value);\n\n\tvirtual FDcResult WriteUInt8(const uint8& Value);\n\tvirtual FDcResult WriteUInt16(const uint16& Value);\n\tvirtual FDcResult WriteUInt32(const uint32& Value);\n\tvirtual FDcResult WriteUInt64(const uint64& Value);\n\n\tvirtual FDcResult WriteFloat(const float& Value);\n\tvirtual FDcResult WriteDouble(const double& Value);\n\n\tvirtual FDcResult WriteBlob(const FDcBlobViewData& Value);\n\n\tvirtual void FormatDiagnostic(FDcDiagnostic& Diag);\n\n\tFORCEINLINE friend FDcDiagnostic& operator<<(FDcDiagnostic& Diag, FDcWriter& Self)\n\t{\n\t\tSelf.FormatDiagnostic(Diag);\n\t\treturn Diag;\n\t}\n\n#if ENGINE_MAJOR_VERSION == 5\n\ttemplate<typename TObject>\n\tFDcResult WriteTObjectPtr(const TObjectPtr<TObject>& Value);\n#endif\n\n\tstatic FName ClassId();\n\tvirtual FName GetId();\n\n\ttemplate<typename T>\n\tT* CastById();\n\n\ttemplate<typename T>\n\tT* CastByIdChecked();\n};\n\n\n#include \"DataConfig/Writer/DcWriter.inl\"\n\n\n'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyWriter.h'\n:#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"DataConfig/Property/DcPropertyDatum.h\"\n#include \"DataConfig/Property/DcPropertyTypes.h\"\n#include \"DataConfig/Writer/DcWriter.h\"\n#include \"DataConfig/Diagnostic/DcDiagnostic.h\"\n\nnamespace DcPropertyWriterDetails\n{\n\tstruct FWriteState\n\t{\n\t\tusing ImplStorageType = TAlignedBytes<96, MIN_ALIGNMENT>;\n\t\tImplStorageType ImplStorage;\n\t};\n}\n\nstruct DATACONFIGCORE_API FDcPropertyWriter : public FDcWriter, private FNoncopyable\n{\n\tFDcPropertyWriter();\n\tFDcPropertyWriter(FDcPropertyDatum Datum);\n\n\tenum EArrayWriter { Array };\n\tenum ESetWriter { Set };\n\n\tFDcPropertyWriter(EArrayWriter, FProperty* InInnerProperty, void* InArray, EArrayPropertyFlags InArrayFlags = EArrayPropertyFlags::None);\n\tFDcPropertyWriter(ESetWriter, FProperty* InElementProperty, void* InSet);\n\tFDcPropertyWriter(FProperty* InKeyProperty, FProperty* InValueProperty, void* InMap, EMapPropertyFlags InMapFlags = EMapPropertyFlags::None);\n\n\tFDcResult PeekWrite(EDcDataEntry Next, bool* bOutOk) override;\n\n\tFDcResult WriteNone() override;\n\tFDcResult WriteBool(bool Value) override;\n\tFDcResult WriteName(const FName& Value) override;\n\tFDcResult WriteString(const FString& Value) override;\n\tFDcResult WriteText(const FText& Value) override;\n\tFDcResult WriteEnum(const FDcEnumData& Value) override;\n\n\tFDcResult WriteStructRootAccess(FDcStructAccess& Access) override;\n\tFDcResult WriteStructEndAccess(FDcStructAccess& Access) override;\n\n\tFDcResult WriteClassRootAccess(FDcClassAccess& Access) override;\n\tFDcResult WriteClassEndAccess(FDcClassAccess& Access) override;\n\n\tFDcResult WriteMapRoot() override;\n\tFDcResult WriteMapEnd() override;\n\n\tFDcResult WriteArrayRoot() override;\n\tFDcResult WriteArrayEnd() override;\n\n\tFDcResult WriteSetRoot() override;\n\tFDcResult WriteSetEnd() override;\n\n\tFDcResult WriteOptionalRoot() override;\n\tFDcResult WriteOptionalEnd() override;\n\n\tFDcResult WriteObjectReference(const UObject* Value) override;\n\tFDcResult WriteClassReference(const UClass* Value) override;\n\n\tFDcResult WriteWeakObjectReference(const FWeakObjectPtr& Value) override;\n\tFDcResult WriteLazyObjectReference(const FLazyObjectPtr& Value) override;\n\tFDcResult WriteSoftObjectReference(const FSoftObjectPtr& Value) override;\n\tFDcResult WriteSoftClassReference(const FSoftObjectPtr& Value) override;\n\tFDcResult WriteInterfaceReference(const FScriptInterface& Value) override;\n\n\tFDcResult WriteFieldPath(const FFieldPath& Value) override;\n\tFDcResult WriteDelegate(const FScriptDelegate& Value) override;\n\tFDcResult WriteMulticastInlineDelegate(const FMulticastScriptDelegate& Value) override;\n\tFDcResult WriteMulticastSparseDelegate(const FMulticastScriptDelegate& Value) override;\n\n\tFDcResult WriteInt8(const int8& Value) override;\n\tFDcResult WriteInt16(const int16& Value) override;\n\tFDcResult WriteInt32(const int32& Value) override;\n\tFDcResult WriteInt64(const int64& Value) override;\n\n\tFDcResult WriteUInt8(const uint8& Value) override;\n\tFDcResult WriteUInt16(const uint16& Value) override;\n\tFDcResult WriteUInt32(const uint32& Value) override;\n\tFDcResult WriteUInt64(const uint64& Value) override;\n\n\tFDcResult WriteFloat(const float& Value) override;\n\tFDcResult WriteDouble(const double& Value) override;\n\tFDcResult WriteBlob(const FDcBlobViewData& Value) override;\n\n\n\tFDcResult SkipWrite();\n\n\tFDcResult PeekWriteProperty(FFieldVariant* OutProperty);\n\n\tFDcResult WriteDataEntry(FFieldClass* ExpectedPropertyClass, FDcPropertyDatum& OutDatum);\n\n\n\tFDcResult PushTopClassPropertyState(const FDcPropertyDatum& Datum);\n\tFDcResult PushTopStructPropertyState(const FDcPropertyDatum& Datum, const FName& StructName);\n\n\n\tbool IsWritingScalarArrayItem();\n\n\tFDcResult SetConfig(FDcPropertyConfig InConfig);\n\tFDcPropertyConfig Config;\n\n\tTArray<DcPropertyWriterDetails::FWriteState, TInlineAllocator<4>> States;\n\n\tFDcDiagnosticHighlight FormatHighlight();\n\tvoid FormatDiagnostic(FDcDiagnostic& Diag) override;\n\n\tstatic FName ClassId();\n\tFName GetId() override;\n};\n\n\n\n",
        "gt": [
            "'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Writer/DcWriter.h'",
            "'DataConfig/DataConfig/Source/DataConfigCore/Public/DataConfig/Property/DcPropertyWriter.h'",
            "'DataConfig/DataConfig/Source/DataConfigEngineExtra/Private/DataConfig/EngineExtra/SerDe/DcSerDeGameplayTags.cpp'"
        ]
    },
    {
        "files": [
            "'pyeos/contracts/eosio.system/eosio.system.hpp'",
            "'pyeos/contracts/eosiolib/time.hpp'",
            "'pyeos/libraries/vm_manager/utility.cpp'"
        ],
        "content": "'pyeos/contracts/eosio.system/eosio.system.hpp'\n:\n#pragma once\n\n#include <eosio.system/native.hpp>\n#include <eosiolib/asset.hpp>\n#include <eosiolib/time.hpp>\n#include <eosiolib/privileged.hpp>\n#include <eosiolib/singleton.hpp>\n#include <eosio.system/exchange_state.hpp>\n\n#include <string>\n\nnamespace eosiosystem {\n\n   using eosio::asset;\n   using eosio::indexed_by;\n   using eosio::const_mem_fun;\n   using eosio::block_timestamp;\n\n   struct name_bid {\n     account_name            newname;\n     account_name            high_bidder;\n     int64_t                 high_bid = 0;\n     uint64_t                last_bid_time = 0;\n\n     auto     primary_key()const { return newname;                          }\n     uint64_t by_high_bid()const { return static_cast<uint64_t>(-high_bid); }\n   };\n\n   typedef eosio::multi_index< N(namebids), name_bid,\n                               indexed_by<N(highbid), const_mem_fun<name_bid, uint64_t, &name_bid::by_high_bid>  >\n                               >  name_bid_table;\n\n   struct jit_bid {\n     account_name            high_bidder;\n     int64_t                 high_bid = 0;\n     uint64_t                last_bid_time = 0;\n     uint64_t                start_bid_time = 0;\n     uint64_t                jit_remains;\n   };\n\n   struct boost_account {\n      account_name    account;\n      uint64_t        expiration;\n\n      uint64_t primary_key()const { return account; }\n\n      EOSLIB_SERIALIZE( boost_account, (account)(expiration) )\n   };\n\n   typedef eosio::singleton<N(jitbid), jit_bid> jit_bid_singleton;\n\n   typedef eosio::multi_index< N(boost), boost_account>  boost_table;\n\n   struct eosio_global_state : eosio::blockchain_parameters {\n      uint64_t free_ram()const { return max_ram_size - total_ram_bytes_reserved; }\n\n      uint64_t             max_ram_size = 64ll*1024 * 1024 * 1024;\n      uint64_t             total_ram_bytes_reserved = 0;\n      int64_t              total_ram_stake = 0;\n\n      block_timestamp      last_producer_schedule_update;\n      uint64_t             last_pervote_bucket_fill = 0;\n      int64_t              pervote_bucket = 0;\n      int64_t              perblock_bucket = 0;\n      uint32_t             total_unpaid_blocks = 0;\n      int64_t              total_activated_stake = 0;\n      uint64_t             thresh_activated_stake_time = 0;\n      uint16_t             last_producer_schedule_size = 0;\n      double               total_producer_vote_weight = 0;\n      block_timestamp      last_name_close;\n\n\n      EOSLIB_SERIALIZE_DERIVED( eosio_global_state, eosio::blockchain_parameters,\n                                (max_ram_size)(total_ram_bytes_reserved)(total_ram_stake)\n                                (last_producer_schedule_update)(last_pervote_bucket_fill)\n                                (pervote_bucket)(perblock_bucket)(total_unpaid_blocks)(total_activated_stake)(thresh_activated_stake_time)\n                                (last_producer_schedule_size)(total_producer_vote_weight)(last_name_close) )\n   };\n\n   struct producer_info {\n      account_name          owner;\n      double                total_votes = 0;\n      eosio::public_key     producer_key;\n      bool                  is_active = true;\n      std::string           url;\n      uint32_t              unpaid_blocks = 0;\n      uint64_t              last_claim_time = 0;\n      uint16_t              location = 0;\n\n      uint64_t primary_key()const { return owner;                                   }\n      double   by_votes()const    { return is_active ? -total_votes : total_votes;  }\n      bool     active()const      { return is_active;                               }\n      void     deactivate()       { producer_key = public_key(); is_active = false; }\n\n\n      EOSLIB_SERIALIZE( producer_info, (owner)(total_votes)(producer_key)(is_active)(url)\n                        (unpaid_blocks)(last_claim_time)(location) )\n   };\n\n   struct voter_info {\n      account_name                owner = 0;\n      account_name                proxy = 0;\n      std::vector<account_name>   producers;\n      int64_t                     staked = 0;\n\n\n      double                      last_vote_weight = 0;\n\n\n      double                      proxied_vote_weight= 0;\n      bool                        is_proxy = 0;\n\n\n      uint32_t                    reserved1 = 0;\n      _time                        reserved2 = 0;\n      eosio::asset                reserved3;\n\n      uint64_t primary_key()const { return owner; }\n\n\n      EOSLIB_SERIALIZE( voter_info, (owner)(proxy)(producers)(staked)(last_vote_weight)(proxied_vote_weight)(is_proxy)(reserved1)(reserved2)(reserved3) )\n   };\n\n   typedef eosio::multi_index< N(voters), voter_info>  voters_table;\n\n\n   typedef eosio::multi_index< N(producers), producer_info,\n                               indexed_by<N(prototalvote), const_mem_fun<producer_info, double, &producer_info::by_votes>  >\n                               >  producers_table;\n\n   typedef eosio::singleton<N(global), eosio_global_state> global_state_singleton;\n\n\n   static constexpr uint32_t     seconds_per_day = 24 * 3600;\n   static constexpr uint64_t     system_token_symbol = CORE_SYMBOL;\n\n   class system_contract : public native {\n      private:\n         voters_table           _voters;\n         producers_table        _producers;\n         global_state_singleton _global;\n\n         eosio_global_state     _gstate;\n         rammarket              _rammarket;\n         jit_bid_singleton      _jitbid;\n         boost_table           _boost;\n\n      public:\n         system_contract( account_name s );\n         ~system_contract();\n\n\n         void onblock( block_timestamp timestamp, account_name producer );\n\n\n\n\n\n         void delegatebw( account_name from, account_name receiver,\n                          asset stake_net_quantity, asset stake_cpu_quantity, bool transfer );\n\n\n\n         void undelegatebw( account_name from, account_name receiver,\n                            asset unstake_net_quantity, asset unstake_cpu_quantity );\n\n\n\n         void buyram( account_name buyer, account_name receiver, asset tokens );\n         void buyrambytes( account_name buyer, account_name receiver, uint32_t bytes );\n\n\n         void sellram( account_name receiver, int64_t bytes );\n\n\n         void refund( account_name owner );\n\n\n\n         void regproducer( const account_name producer, const public_key& producer_key, const std::string& url, uint16_t location );\n\n         void unregprod( const account_name producer );\n\n         void setram( uint64_t max_ram_size );\n\n         void voteproducer( const account_name voter, const account_name proxy, const std::vector<account_name>& producers );\n\n         void regproxy( const account_name proxy, bool isproxy );\n\n         void setparams( const eosio::blockchain_parameters& params );\n\n\n         void claimrewards( const account_name& owner );\n\n         void setpriv( account_name account, uint8_t ispriv );\n\n         void rmvproducer( account_name producer );\n\n         void bidname( account_name bidder, account_name newname, asset bid );\n         void bidjit( account_name bidder, asset bid );\n         void boost(account_name account);\n         void cancelboost(account_name account);\n\n      private:\n         void update_elected_producers( block_timestamp timestamp );\n\n\n\n\n         void changebw( account_name from, account_name receiver,\n                        asset stake_net_quantity, asset stake_cpu_quantity, bool transfer );\n\n\n         static eosio_global_state get_default_parameters();\n\n         void update_votes( const account_name voter, const account_name proxy, const std::vector<account_name>& producers, bool voting );\n\n\n         void propagate_weight_change( const voter_info& voter );\n   };\n\n}\n\n'pyeos/contracts/eosiolib/time.hpp'\n:#pragma once\n#include <stdint.h>\n#include <string>\n#include <eosiolib/eosio.hpp>\n\nnamespace eosio {\n  class microseconds {\n    public:\n        explicit microseconds( int64_t c = 0) :_count(c){}\n        static microseconds maximum() { return microseconds(0x7fffffffffffffffll); }\n        friend microseconds operator + (const  microseconds& l, const microseconds& r ) { return microseconds(l._count+r._count); }\n        friend microseconds operator - (const  microseconds& l, const microseconds& r ) { return microseconds(l._count-r._count); }\n\n\n        bool operator==(const microseconds& c)const { return _count == c._count; }\n        bool operator!=(const microseconds& c)const { return _count != c._count; }\n        friend bool operator>(const microseconds& a, const microseconds& b){ return a._count > b._count; }\n        friend bool operator>=(const microseconds& a, const microseconds& b){ return a._count >= b._count; }\n        friend bool operator<(const microseconds& a, const microseconds& b){ return a._count < b._count; }\n        friend bool operator<=(const microseconds& a, const microseconds& b){ return a._count <= b._count; }\n        microseconds& operator+=(const microseconds& c) { _count += c._count; return *this; }\n        microseconds& operator-=(const microseconds& c) { _count -= c._count; return *this; }\n        int64_t count()const { return _count; }\n        int64_t to_seconds()const { return _count/1000000; }\n\n        int64_t _count;\n        EOSLIB_SERIALIZE( microseconds, (_count) )\n    private:\n        friend class time_point;\n  };\n\n  inline microseconds seconds( int64_t s ) { return microseconds( s * 1000000 ); }\n  inline microseconds milliseconds( int64_t s ) { return microseconds( s * 1000 ); }\n  inline microseconds minutes(int64_t m) { return seconds(60*m); }\n  inline microseconds hours(int64_t h) { return minutes(60*h); }\n  inline microseconds days(int64_t d) { return hours(24*d); }\n\n  class time_point {\n    public:\n        explicit time_point( microseconds e = microseconds() ) :elapsed(e){}\n        operator std::string()const;\n        static time_point from_iso_string( const std::string& s );\n        const microseconds& time_since_epoch()const { return elapsed; }\n        uint32_t            sec_since_epoch()const  { return uint32_t(elapsed.count() / 1000000); }\n        bool   operator > ( const time_point& t )const                              { return elapsed._count > t.elapsed._count; }\n        bool   operator >=( const time_point& t )const                              { return elapsed._count >=t.elapsed._count; }\n        bool   operator < ( const time_point& t )const                              { return elapsed._count < t.elapsed._count; }\n        bool   operator <=( const time_point& t )const                              { return elapsed._count <=t.elapsed._count; }\n        bool   operator ==( const time_point& t )const                              { return elapsed._count ==t.elapsed._count; }\n        bool   operator !=( const time_point& t )const                              { return elapsed._count !=t.elapsed._count; }\n        time_point&  operator += ( const microseconds& m)                           { elapsed+=m; return *this;                 }\n        time_point&  operator -= ( const microseconds& m)                           { elapsed-=m; return *this;                 }\n        time_point   operator + (const microseconds& m) const { return time_point(elapsed+m); }\n        time_point   operator + (const time_point& m) const { return time_point(elapsed+m.elapsed); }\n        time_point   operator - (const microseconds& m) const { return time_point(elapsed-m); }\n        microseconds operator - (const time_point& m) const { return microseconds(elapsed.count() - m.elapsed.count()); }\n        microseconds elapsed;\n        EOSLIB_SERIALIZE( time_point, (elapsed) )\n  };\n\n\n  class time_point_sec\n  {\n    public:\n        time_point_sec()\n        :utc_seconds(0){}\n\n        explicit time_point_sec(uint32_t seconds )\n        :utc_seconds(seconds){}\n\n        time_point_sec( const time_point& t )\n        :utc_seconds( uint32_t(t.time_since_epoch().count() / 1000000ll) ){}\n\n        static time_point_sec maximum() { return time_point_sec(0xffffffff); }\n        static time_point_sec min() { return time_point_sec(0); }\n\n        operator time_point()const { return time_point( eosio::seconds( utc_seconds) ); }\n        uint32_t sec_since_epoch()const { return utc_seconds; }\n\n        time_point_sec operator = ( const eosio::time_point& t )\n        {\n          utc_seconds = uint32_t(t.time_since_epoch().count() / 1000000ll);\n          return *this;\n        }\n        friend bool      operator < ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds < b.utc_seconds; }\n        friend bool      operator > ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds > b.utc_seconds; }\n        friend bool      operator <= ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds <= b.utc_seconds; }\n        friend bool      operator >= ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds >= b.utc_seconds; }\n        friend bool      operator == ( const time_point_sec& a, const time_point_sec& b ) { return a.utc_seconds == b.utc_seconds; }\n        friend bool      operator != ( const time_point_sec& a, const time_point_sec& b ) { return a.utc_seconds != b.utc_seconds; }\n        time_point_sec&  operator += ( uint32_t m ) { utc_seconds+=m; return *this; }\n        time_point_sec&  operator += ( microseconds m ) { utc_seconds+=m.to_seconds(); return *this; }\n        time_point_sec&  operator += ( time_point_sec m ) { utc_seconds+=m.utc_seconds; return *this; }\n        time_point_sec&  operator -= ( uint32_t m ) { utc_seconds-=m; return *this; }\n        time_point_sec&  operator -= ( microseconds m ) { utc_seconds-=m.to_seconds(); return *this; }\n        time_point_sec&  operator -= ( time_point_sec m ) { utc_seconds-=m.utc_seconds; return *this; }\n        time_point_sec   operator +( uint32_t offset )const { return time_point_sec(utc_seconds + offset); }\n        time_point_sec   operator -( uint32_t offset )const { return time_point_sec(utc_seconds - offset); }\n\n        friend time_point   operator + ( const time_point_sec& t, const microseconds& m )   { return time_point(t) + m;             }\n        friend time_point   operator - ( const time_point_sec& t, const microseconds& m )   { return time_point(t) - m;             }\n        friend microseconds operator - ( const time_point_sec& t, const time_point_sec& m ) { return time_point(t) - time_point(m); }\n        friend microseconds operator - ( const time_point& t, const time_point_sec& m ) { return time_point(t) - time_point(m); }\n        uint32_t utc_seconds;\n\n        EOSLIB_SERIALIZE( time_point_sec, (utc_seconds) )\n  };\n\n\n   class block_timestamp {\n      public:\n         explicit block_timestamp( uint32_t s=0 ) :slot(s){}\n\n         block_timestamp(const time_point& t) {\n            set_time_point(t);\n         }\n\n         block_timestamp(const time_point_sec& t) {\n            set_time_point(t);\n         }\n\n         static block_timestamp maximum() { return block_timestamp( 0xffff ); }\n         static block_timestamp min() { return block_timestamp(0); }\n\n         block_timestamp next() const {\n            eosio_assert( std::numeric_limits<uint32_t>::max() - slot >= 1, \"block timestamp overflow\" );\n            auto result = block_timestamp(*this);\n            result.slot += 1;\n            return result;\n         }\n\n         time_point to_time_point() const {\n            return (time_point)(*this);\n         }\n\n         operator time_point() const {\n            int64_t msec = slot * (int64_t)block_interval_ms;\n            msec += block_timestamp_epoch;\n            return time_point(milliseconds(msec));\n         }\n\n         void operator = (const time_point& t ) {\n            set_time_point(t);\n         }\n\n         bool   operator > ( const block_timestamp& t )const   { return slot >  t.slot; }\n         bool   operator >=( const block_timestamp& t )const   { return slot >= t.slot; }\n         bool   operator < ( const block_timestamp& t )const   { return slot <  t.slot; }\n         bool   operator <=( const block_timestamp& t )const   { return slot <= t.slot; }\n         bool   operator ==( const block_timestamp& t )const   { return slot == t.slot; }\n         bool   operator !=( const block_timestamp& t )const   { return slot != t.slot; }\n         uint32_t slot;\n         static constexpr int32_t block_interval_ms = 500;\n         static constexpr int64_t block_timestamp_epoch = 946684800000ll;\n\n         EOSLIB_SERIALIZE( block_timestamp, (slot) )\n      private:\n\n\n      void set_time_point(const time_point& t) {\n         int64_t micro_since_epoch = t.time_since_epoch().count();\n         int64_t msec_since_epoch  = micro_since_epoch / 1000;\n         slot = uint32_t(( msec_since_epoch - block_timestamp_epoch ) / int64_t(block_interval_ms));\n      }\n\n      void set_time_point(const time_point_sec& t) {\n         int64_t  sec_since_epoch = t.sec_since_epoch();\n         slot = uint32_t((sec_since_epoch * 1000 - block_timestamp_epoch) / block_interval_ms);\n      }\n   };\n   typedef block_timestamp block_timestamp_type;\n\n}\n\n'pyeos/libraries/vm_manager/utility.cpp'\n:#include \"ro_db.hpp\"\n#include <eosiolib/multi_index.hpp>\n#include <eosio.system/eosio.system.hpp>\n\n#include <fc/time.hpp>\n\nusing namespace std;\n\nextern \"C\" uint64_t  current_time();\n\nstruct boost_account {\n   account_name    account;\n   uint64_t        expiration;\n\n   uint64_t primary_key()const { return account; }\n\n   EOSLIB_SERIALIZE( boost_account, (account)(expiration) )\n};\n\nbool is_boost_account(uint64_t account) {\n   eosio::multi_index<N(boost), boost_account> _boost_account(N(eosio), N(eosio));\n   if (_boost_account.find(account) != _boost_account.end()) {\n      return true;\n   }\n   return false;\n}\n\ntypedef void (*fn_on_boost_account)(void* v, uint64_t account, uint64_t expiration);\n\nvoid visit_boost_account(fn_on_boost_account fn, void* param) {\n   eosio::multi_index<N(boost), boost_account> _boost_account(N(eosio), N(eosio));\n   for (auto itr = _boost_account.begin(); itr != _boost_account.end(); itr++) {\n      fn(param, itr->account, itr->expiration);\n   }\n}\n\n\nbool is_boost_account(uint64_t account, bool& expired) {\n   uint64_t _now = fc::time_point::now().time_since_epoch().count();\n   eosio::multi_index<N(boost), boost_account> _boost(N(eosio), N(eosio));\n\n   auto itr = _boost.find(account);\n   expired = false;\n   if (itr != _boost.end()) {\n      if (itr->expiration < _now) {\n         expired = true;\n      }\n      return true;\n   }\n   return false;\n}\n\nusing namespace eosiosystem;\n\nvoid list_producers_() {\n   producers_table        _producers(N(eosio), N(eosio));\n   auto idx = _producers.get_index<N(prototalvote)>();\n\n   for ( auto it = idx.cbegin(); it != idx.cend() && 0 < it->total_votes && it->active(); ++it ) {\n      printf(\"++++it->owner: %s total votes %f\\n\", eosio::name{it->owner}.to_string().c_str(), it->total_votes);\n   }\n}\n\n",
        "gt": [
            "'pyeos/contracts/eosiolib/time.hpp'",
            "'pyeos/contracts/eosio.system/eosio.system.hpp'",
            "'pyeos/libraries/vm_manager/utility.cpp'"
        ]
    },
    {
        "files": [
            "'dynamic_task_allocation/src/allocation_common/include/Core.hpp'",
            "'dynamic_task_allocation/src/control_terminal/include/topic_info.h'",
            "'dynamic_task_allocation/src/control_terminal/include/maindialog.h'",
            "'dynamic_task_allocation/src/control_terminal/src/main.cpp'",
            "'dynamic_task_allocation/src/allocation_common/include/Line.hpp'",
            "'dynamic_task_allocation/src/allocation_common/include/Circle.hpp'"
        ],
        "content": "'dynamic_task_allocation/src/allocation_common/include/Core.hpp'\n:#ifndef CORE_HPP\n#define CORE_HPP\n\n#include <Circle.hpp>\n#include <Line.hpp>\n#include <PPoint.hpp>\n#include <DPoint.hpp>\n#include <Angle.hpp>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <stdio.h>\n#include <signal.h>\n#include <time.h>\n#include <ros/ros.h>\n#include <boost/thread.hpp>\n#include <boost/bind.hpp>\n#include <boost/thread/mutex.hpp>\n\n#define MAXNUM_AGENT 10\n#define LOCATION_ERROR 0.2\n#define EXPLORE_TIME 30\n#define HIT_TIME 30\n\nenum Robots_mode\n{\n    IDLE,\n    PLAN,\n    EXECUTE,\n    EXPLORE,\n    HIT,\n    DAMAGE,\n    RESET\n};\n\nenum Reward_causes\n{\n    Invalid_task,\n    Valid_task,\n    Drop_task,\n    Complete_target,\n    Explore_task,\n    Robot_damage,\n    All_complete,\n};\n\nenum Allocation_mode\n{\n    ALLOCATION_START,\n    ALLOCATION_PAUSE,\n    ALLOCATION_STOP\n};\n\nenum Allocation_method\n{\n    Prediction,\n    Market,\n    DQN\n};\n\nstruct Gazebo_robot_info\n{\n\n    int    robot_ID;\n    DPoint robot_pos;\n    double robot_ori;\n    DPoint robot_vel;\n    double robot_w;\n};\n\nstruct Gazebo_task_info\n{\n\n    int    task_ID;\n    DPoint task_pos;\n};\n\nstruct Allocation_robot_info\n{\n\n    int    robot_power;\n\n    int    robot_ID;\n    char   robot_mode;\n    float  move_distance;\n    bool   isvalid;\n\n    int    which_task;\n    int    which_target;\n\n    DPoint expect_pos;\n    vector<int> target_list;\n    vector<int> task_list;\n\n    Allocation_robot_info()\n    {\n        robot_power=0;\n        robot_ID=0;\n        robot_mode=IDLE;\n        which_task=-1;\n        which_target=-1;\n        target_list.clear();\n        task_list.clear();\n        expect_pos=DPoint(-100,-100);\n        move_distance=0;\n        isvalid=true;\n    }\n    void robot_reset()\n    {\n        robot_mode=RESET;\n        which_task=-1;\n        which_target=-1;\n        target_list.clear();\n        task_list.clear();\n        expect_pos=DPoint(-100,-100);\n        move_distance=0;\n        isvalid=true;\n    }\n};\n\nstruct Allocation_task_info\n{\n\n    int    task_power;\n\n    int    task_ID;\n    int    known_power;\n    bool   istarget;\n    double current_distance;\n    bool   iscomplete;\n    bool   isexplored;\n    bool   isallocated;\n    Allocation_task_info()\n    {\n        task_power=0;\n        task_ID=0;\n        known_power=0;\n        current_distance=1000;\n        istarget=false;\n        iscomplete=false;\n        isexplored=false;\n        isallocated=false;\n    }\n    void task_reset()\n    {\n        known_power=0;\n        current_distance=1000;\n        istarget=false;\n        iscomplete=false;\n        isexplored=false;\n        isallocated=false;\n    }\n};\n\nstruct Robot_info\n{\n    Gazebo_robot_info gazebo_robot_info;\n    Allocation_robot_info allocation_robot_info;\n};\n\nstruct Task_info\n{\n    Gazebo_task_info gazebo_task_info;\n    Allocation_task_info allocation_task_info;\n};\n\nstruct Terminal2Gazebo_info\n{\n    std::vector<int>  robot_pos_x;\n    std::vector<int>  robot_pos_y;\n    std::vector<int>  task_pos_x;\n    std::vector<int>  task_pos_y;\n    bool is_noise;\n    bool isNew_allocation;\n};\n\nstruct Terminal2Robots_info\n{\n    char allocation_mode;\n    bool greedorprobability;\n    char allocation_method;\n    bool finish_episode;\n    bool finish_train;\n\n    std::vector<Allocation_robot_info> all_allocation_robot_info;\n    std::vector<Allocation_task_info> all_allocation_task_info;\n};\n\nstruct Gazebo2World_info\n{\n    std::vector<Gazebo_robot_info> gazebo_robots_info;\n    std::vector<Gazebo_task_info>  gazebo_tasks_info;\n};\n#endif\n\n'dynamic_task_allocation/src/control_terminal/include/topic_info.h'\n:#ifndef TOPIC_INFO_H\n#define TOPIC_INFO_H\n\n#include <Core.hpp>\n#include <QThread>\n#include <std_msgs/Header.h>\n#include <std_msgs/String.h>\n#include <allocation_common/terminal2gazebo_info.h>\n#include <allocation_common/terminal2robot_info.h>\n#include <allocation_common/terminal2DQN_info.h>\n#include <allocation_common/allocation2terminal_info.h>\n\nclass Topic_Info:public QThread\n{\npublic:\n\n    boost::shared_ptr<ros::NodeHandle> nh_;\n    ros::Subscriber  allocation2terminal_sub_[MAXNUM_AGENT];\n    ros::Publisher   terminal2robot_pub_;\n    ros::Publisher   terminal2gazebo_pub_;\n    ros::Publisher   terminal2DQN_pub_;\n    ros::Timer       terminalinfo_publish_timer_;\n\n    allocation_common::terminal2robot_info  terminal2robot_pub_info_;\n\n    Terminal2Robots_info terminal2robots_info;\n    Terminal2Gazebo_info terminal2gazebo_info;\n\n\n    vector<int> timeforupdatetask_;\n    vector<int> timeforupdaterobot_;\npublic:\n    Topic_Info();\n    void run();\n    void update_allocation_info(const allocation_common::allocation2terminal_info::ConstPtr & _msg, int topic_id);\n    void publish(const ros::TimerEvent &);\n    ~Topic_Info();\n};\n\n#endif\n\n'dynamic_task_allocation/src/control_terminal/include/maindialog.h'\n:#ifndef MAINDIALOG_H\n#define MAINDIALOG_H\n\n#include <QtCore>\n#include <QDialog>\n#include <QTime>\n#include <QTimer>\n#include <QVector>\n#include <QString>\n#include <QMessageBox>\n#include <QSpinBox>\n#include <QDebug>\n#include <topic_info.h>\n#include <stdio.h>\n\nnamespace Ui {\nclass MainDialog;\n}\n\nclass MainDialog : public QDialog\n{\n    Q_OBJECT\n\npublic:\n    explicit MainDialog(Terminal2Gazebo_info &terminal2gazebo_info, Terminal2Robots_info &terminal2robots_info, QWidget *parent = 0);\n    ~MainDialog();\n    bool init_robots();\n    void restart_game(int count);\npublic:\n\n    Ui::MainDialog *ui;\n\n    QList<QSpinBox*> agent_power_;\n    QList<QPushButton*> agent_vaild_;\n    QList<QLineEdit*> agent_distance_;\n    QMessageBox *notice_;\n    QTimer *timer_;\n\n    QVector<QVector<int>>  lab_tasks_;\n    QVector<QString>  task_info_show_;\n\n    Terminal2Gazebo_info* terminal2gazebo_info_;\n    Terminal2Robots_info* terminal2robots_info_;\n\n    ros::NodeHandle nh_;\n    int  num_robots_;\n    int  num_tasks_;\n\n    QTime   current_time_;\n    QString current_mode_;\n    double  duration_time_;\n    double  tmp_time_;\n    bool    is_robot_exsit_;\n\nprivate slots:\n    void timerUpdate();\n    bool on_init_map_clicked();\n    void on_start_pause_clicked();\n    void on_stop_clicked();\n    void on_show_more_clicked();\n};\n\n#endif\n\n'dynamic_task_allocation/src/control_terminal/src/main.cpp'\n:#include \"maindialog.h\"\n#include <QApplication>\n#include <QIcon>\n\nint main(int argc, char *argv[])\n{\n    QApplication a(argc, argv);\n    QString myDir=QCoreApplication::applicationDirPath();\n    QDir::setCurrent(myDir);\n\n    ros::init(argc,argv,\"control_terminal_node\");\n    ROS_INFO(\"start control_terminal process\");\n\n    Topic_Info topic_info;\n    MainDialog w(topic_info.terminal2gazebo_info,topic_info.terminal2robots_info);\n    w.show();\n    topic_info.start();\n    return a.exec();\n}\n\n'dynamic_task_allocation/src/allocation_common/include/Line.hpp'\n:#ifndef LINE_HPP\n#define LINE_HPP\n\n#include \"PPoint.hpp\"\n#include <cmath>\n\nconst double eps=1e-5;\nclass Line_\n{\n\npublic:\n\n\tLine_();\n\tLine_(const Line_ & line);\n\n\tLine_(double a,double b,double c);\n\n\tLine_(double k,double b);\n\n\ttemplate<typename _Tp>  Line_(const DPoint_<_Tp> & pt1,const DPoint_<_Tp> & pt2);\n\n\ttemplate<typename _Tp>  Line_(double k,const DPoint_<_Tp> & pt);\n\n\n\n\tbool isParallel(const Line_ & line) const;\n\n\tbool isOrthogonal (const Line_ & line) const;\n\n\ttemplate<typename _Tp> double distance(const DPoint_<_Tp> & pt) const ;\n\n\tdouble distance(const Line_ & line) const ;\n\n    bool crosspoint(const Line_ & line, DPoint_<double> &pt) const;\n\n\tdouble A_,B_,C_;\n\tdouble k_,b_;\n\tbool   isSlope_;\n\tbool   isLine_;\n};\n\n\n\ninline Line_::Line_() : A_(0.),B_(0.),C_(0.),k_(0.),b_(0.),isSlope_(false),isLine_(false) {}\ninline Line_::Line_(const Line_ & line) : A_(line.A_),B_(line.B_),C_(line.C_),\n\tk_(line.k_),b_(line.b_),isSlope_(line.isSlope_),isLine_(line.isLine_) {}\ninline Line_::Line_(double a,double b,double c) : A_(a),B_(b),C_(c),isLine_(a!=0||b!=0)\n{\n\tif(B_!=0)\n\t{\n\t\tisSlope_=true;\n\t\tk_=-A_/B_;\n\t\tb_=-C_/B_;\n\t}\n\telse\n\t{\n\t\tk_=0;\n\t\tb_=0;\n\t\tisSlope_=false;\n\t}\n}\ninline Line_::Line_(double k,double b) : A_(k),B_(-1),C_(b),k_(k),b_(b),isSlope_(true),isLine_(true) {}\ntemplate<typename _Tp> inline Line_::Line_(const DPoint_<_Tp> & pt1,const DPoint_<_Tp> & pt2)\n{\n\tif(pt1!=pt2)\n\t{\n\t\tisLine_=true;\n        if(pt1.x_!=pt2.x_)\n\t\t{\n\t\t\tk_=double(pt2.y_-pt1.y_)/double(pt2.x_-pt1.x_);\n\t\t\tb_=double(pt1.y_*pt2.x_-pt2.y_*pt1.x_)/double(pt2.x_-pt1.x_);\n\t\t\tA_=k_;\n\t\t\tB_=-1.0;\n\t\t\tC_=b_;\n\t\t\tisSlope_=true;\n\t\t}\n        else\n\t\t{\n\n            A_=1.0;\n            if((pt2.y_-pt1.y_)<0)\n              A_=-1.0;\n\t\t\tB_=0.0;\n            C_=-1.0*A_*pt1.x_;\n\n\n\t\t\tk_=0;\n\t\t\tb_=0;\n\t\t\tisSlope_=false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tA_=0;B_=0;C_=0;k_=0;b_=0;\n\t\tisLine_=false;\n\t\tisSlope_=false;\n\t}\n}\ntemplate<typename _Tp> inline  Line_::Line_(double k,const DPoint_<_Tp> & pt)\n{\n\tk_ = k;\n\tb_ = double(pt.y_-k*pt.x_);\n\tA_ = k;\n\tB_ = -1.0;\n\tC_ = b_;\n\tisLine_=true;\n\tisSlope_=true;\n}\ninline bool Line_::isParallel(const Line_ & line) const\n{\n\tif(isLine_&&line.isLine_)\n\t\treturn((line.A_*B_-A_*line.B_)==0);\n\telse\n\t\treturn (false);\n}\ninline bool Line_::isOrthogonal(const Line_ & line) const\n{\n\tif(isLine_&&line.isLine_)\n\t\treturn((A_*line.A_+B_*line.B_)==0);\n\telse\n\t\treturn (false);\n}\n\ntemplate<typename _Tp> inline double Line_::distance(const DPoint_<_Tp> & pt) const\n{\n\treturn (std::abs(A_*pt.x_+B_*pt.y_+C_)/sqrt(A_*A_+B_*B_));\n}\ninline double Line_::distance(const Line_ & line) const\n{\n\tif(isParallel(line))\n\t\treturn (std::abs(C_-line.C_)/sqrt(A_*A_+B_*B_));\n\telse\n\t\treturn (0.0);\n}\ninline bool Line_::crosspoint(const Line_ & line, DPoint_<double> &pt) const\n{\n\tdouble ycoef=double(A_*line.B_-line.A_*B_);\n\tif(isLine_&&line.isLine_&&ycoef!=0)\n\t{\n\t\tpt.x_=double(B_*line.C_-line.B_*C_)/ycoef;\n\t\tpt.y_=double(-A_*line.C_+line.A_*C_)/ycoef;\n\n        return 1;\n\t}\n    else\n        return 0;\n}\n\ntemplate<typename _Tp> static inline Line_ verticalline(const Line_ & line,const DPoint_<_Tp> & pt)\n{\n\tif(line.isLine_)\n\t{\n\t\tif(line.isSlope_)\n\t\t{\n\t\t\tif(line.k_==0)\n\t\t\t\treturn Line_(1,0,-pt.x_);\n\t\t\telse\n\t\t\t\treturn Line_(-1.0/line.k_,pt);\n\t\t}\n\t\telse\n\t\t\treturn Line_(0.0,pt.y_);\n\t}\n\telse\n\t\treturn Line_();\n}\n\ntemplate<typename _Tp> static inline DPoint_<_Tp> pointinline(const Line_ & line , const DPoint_<_Tp> & pt,double dis)\n{\n\tdouble theta=atan2(line.A_,-line.B_);\n\treturn DPoint_<_Tp>(_Tp(pt.x_+dis*cos(theta)),_Tp(pt.y_+dis*sin(theta)));\n}\n\n\n\ntemplate<typename _Tp> static inline DPoint_<_Tp> verticalpoint(const Line_ & line , const DPoint_<_Tp> & pt)\n{\n\tDPoint_<double> outpt=DPoint_<double>(0.0,0.0);\n\tif(line.isLine_)\n\t{\n\t\tLine_ vertical_line=verticalline(line,pt);\n        line.crosspoint(vertical_line, outpt);\n\t}\n\treturn outpt;\n}\n\n\n\nclass LineSegment\n{\npublic:\n    enum {\n      StartLeft = 0,\n      BetweenStartAndEnd = 1,\n      EndPtRight = 2\n    };\n\npublic:\n    LineSegment(){\n      vector_=end_=start_=DPoint(0,0);\n    }\n    LineSegment(const DPoint & _start, const DPoint & _end){\n       start_ =_start;\n       end_   =_end;\n       vector_=end_-start_;\n    }\n    LineSegment(const LineSegment & _lineSement){\n        start_ =_lineSement.start_;\n        end_   =_lineSement.end_;\n        vector_=_lineSement.vector_;\n    }\n\n\n    double distance(const DPoint & pt,bool isBetween = false) const\n    {\n        DPoint vector_vp = pt- start_;\n        double dotProduct = vector_vp.x_*vector_.x_ + vector_vp.y_ *vector_.y_;\n        double LineSegLength = vector_.norm() * vector_.norm();\n        double distance = 0;\n        if(dotProduct <= 0)\n        {\n           if(!isBetween)\n              distance = pt.distance(start_);\n           else\n               distance=100;\n        }\n        else if (dotProduct >= LineSegLength)\n        {\n           if(!isBetween)\n              distance = pt.distance(end_);\n           else\n               distance=100;\n        }\n        else\n        {\n           double r = dotProduct / LineSegLength;\n           DPoint vert_pt = start_ + r *vector_;\n           distance = pt.distance(vert_pt);\n        }\n        return distance;\n    }\n\n    double distance() const {\n      return vector_.norm();\n    }\n\n    bool crosspoint(LineSegment ls, DPoint& lscp)\n    {\n        Line_ l1(start_, end_), l2(ls.start_, ls.end_);\n        DPoint fin_pt=lscp;\n        if( l1.crosspoint(l2, fin_pt) )\n        {\n            if(isInLineSegment(fin_pt) && ls.isInLineSegment(fin_pt) )\n            {\n                lscp = fin_pt;\n                return 1;\n            }\n            else\n                return 0;\n        }\n        else\n            return 0;\n    }\n\n    bool isInLineSegment(DPoint pt)\n    {\n        DPoint vec1 = start_ - pt, vec2 = pt - end_;\n        double  re = vec1.dot(vec2)/(vec1.norm()*vec2.norm());\n        if( fabs(re - 1.0) < eps)\n            return 1;\n        else\n            return 0;\n    }\n    int  decideWhere(const DPoint & pt)\n    {\n\n        DPoint vector_vp = pt- start_;\n        double dotProduct = vector_vp.x_*vector_.x_ + vector_vp.y_ *vector_.y_;\n        double LineSegLength = vector_.norm() * vector_.norm();\n        if(dotProduct < 0)\n            return StartLeft;\n        else if (dotProduct > LineSegLength)\n            return EndPtRight;\n        else\n            return  BetweenStartAndEnd;\n    }\n\npublic:\n    DPoint start_;\n    DPoint end_;\n    DPoint vector_;\n};\n\n#endif\n\n'dynamic_task_allocation/src/allocation_common/include/Circle.hpp'\n:#ifndef CIRCLE_HPP\n#define CIRCLE_HPP\n\n#include \"Line.hpp\"\n#include <cmath>\n#include <vector>\n\nusing std::vector;\n\nclass Circle\n{\n\npublic:\n\n\tCircle();\n\ttemplate<typename _Tp> Circle(double _radius, const DPoint_<_Tp> & _center);\n\tCircle(const Circle & _circle);\n\n\ttemplate<typename _Tp>  Circle(const DPoint_<_Tp> & pt1, const DPoint_<_Tp> & pt2);\n\n\n\ttemplate<typename _Tp> bool inside(const DPoint_<_Tp> & pt) const;\n\n\ttemplate<typename _Tp> bool onedge(const DPoint_<_Tp> & pt) const;\n\n\tstd::vector< DPoint_<double> > crosspoint(const Line_ & line) const;\n\n\ttemplate<typename _Tp> std::vector< DPoint_<double> > tangentpoint(const DPoint_<_Tp> & pt) const;\n\n\n \tbool isIntersect(const Line_ & line) const;\n\tbool isContact (const Line_ & line)  const;\n\tbool isSeparate (const Line_ & line) const;\n\n\tdouble radius_;\n\tDPoint_<double> center_;\n};\n\n\n\ninline Circle::Circle() : radius_(0.0),center_(DPoint_<double>(0.0,0.0)) {};\ntemplate<typename _Tp> inline Circle::Circle(double _radius, const DPoint_<_Tp> & _center) : radius_(_radius),center_(_center)  {};\ninline Circle::Circle(const Circle & _circle) : radius_(_circle.radius_),center_(_circle.center_) {};\ntemplate<typename _Tp> inline Circle::Circle( const DPoint_<_Tp> & pt1, const DPoint_<_Tp> & pt2)\n{\n\tradius_=pt1.distance(pt2)/2.0;\n\tcenter_=(DPoint2d(pt1)+DPoint2d(pt2))*(1/2.0);\n}\ntemplate<typename _Tp> inline bool Circle::inside(const DPoint_<_Tp> & pt) const\n{\n\treturn(center_.distance(pt)<radius_);\n}\ntemplate<typename _Tp> inline bool Circle::onedge(const DPoint_<_Tp> & pt) const\n{\n\treturn(center_.distance(pt)==radius_);\n}\ninline bool Circle:: isIntersect(const Line_ & line) const\n{\n\treturn (line.distance(center_)<radius_);\n}\ninline bool Circle:: isContact (const Line_ & line) const\n{\n\treturn (line.distance(center_)==radius_);\n}\ninline bool Circle:: isSeparate (const Line_ & line) const\n{\n\treturn (line.distance(center_)>radius_);\n}\n\n\ninline std::vector< DPoint_<double> > Circle::crosspoint(const Line_ & line) const\n{\n\tvector< DPoint_<double> > cross_point;\n\tcross_point.reserve(2);\n\tdouble  disLine=line.distance(center_);\n\n\tif(disLine<=radius_)\n\t {\n\t    if(disLine<radius_)\n\t    {\n            DPoint2d pt=verticalpoint(line,center_);\n            double tmpdis=DPoint2d(pt-center_).norm();\n            double dis=sqrt(radius_*radius_-tmpdis*tmpdis);\n            cross_point.push_back(pointinline(line,pt,dis));\n            cross_point.push_back(pointinline(line,pt,-dis));\n\t    }\n\t    else\n\t       cross_point.push_back(verticalpoint(line,center_));\n\t }\n\treturn cross_point;\n}\n\ntemplate<typename _Tp> inline std::vector< DPoint_<double> > Circle::tangentpoint(const DPoint_<_Tp> & pt) const\n{\n\tvector< DPoint_<double> > tangent_point;\n\tdouble dispt=center_.distance(pt);\n\tif(dispt>=radius_)\n\t{\n\t\tif(dispt>radius_)\n\t\t{\n\t\t\tDPoint2d Vect=center_-DPoint2d(pt);\n\t\t        Angle theta=Vect.angle();\n\t\t        Angle theta_e=Angle(asin(radius_/dispt));\n\t\t        double dis=dispt*cos(theta_e.radian_);\n\t\t\tAngle tmp=theta+theta_e;\n\t\t\ttangent_point.push_back(DPoint2d(pt)+DPoint2d(dis*cos(tmp.radian_),dis*sin(tmp.radian_)));\n\t\t\ttmp = theta-theta_e;\n\t\t\ttangent_point.push_back(DPoint2d(pt)+DPoint2d(dis*cos(tmp.radian_),dis*sin(tmp.radian_)));\n\t\t}\n\t\telse\n\t\t   tangent_point.push_back(DPoint2d(pt));\n\n\t}\n\treturn tangent_point;\n}\n#endif\n",
        "gt": [
            "'dynamic_task_allocation/src/allocation_common/include/Line.hpp'",
            "'dynamic_task_allocation/src/allocation_common/include/Circle.hpp'",
            "'dynamic_task_allocation/src/allocation_common/include/Core.hpp'",
            "'dynamic_task_allocation/src/control_terminal/include/topic_info.h'",
            "'dynamic_task_allocation/src/control_terminal/include/maindialog.h'",
            "'dynamic_task_allocation/src/control_terminal/src/main.cpp'"
        ]
    },
    {
        "files": [
            "'knowrob/include/knowrob/queries/QueryParser.h'",
            "'knowrob/include/knowrob/formulas/ModalFormula.h'",
            "'knowrob/include/knowrob/formulas/Predicate.h'",
            "'knowrob/tests/StorageTest.cpp'"
        ],
        "content": "'knowrob/include/knowrob/queries/QueryParser.h'\n:\n\n#ifndef KNOWROB_QUERY_PARSER_H\n#define KNOWROB_QUERY_PARSER_H\n\n#include \"knowrob/formulas/Formula.h\"\n#include \"knowrob/formulas/Predicate.h\"\n#include \"knowrob/terms/Function.h\"\n#include \"knowrob/semweb/GraphTerm.h\"\n\nnamespace knowrob {\n\n\tclass QueryParser {\n\tpublic:\n\n\t\tstatic FormulaPtr parse(const std::string &queryString);\n\n\n\t\tstatic PredicatePtr parsePredicate(const std::string &queryString);\n\n\n\t\tstatic std::shared_ptr<GraphTerm> parseGraphTerm(const std::string &queryString);\n\n\n\t\tstatic FunctionPtr parseFunction(const std::string &queryString);\n\n\n\t\tstatic TermPtr parseConstant(const std::string &queryString);\n\n\n\t\tstatic std::string parseRawAtom(const std::string &queryString);\n\n\t};\n\n}\n\n#endif\n\n'knowrob/include/knowrob/formulas/ModalFormula.h'\n:\n\n#ifndef KNOWROB_MODAL_FORMULA_H\n#define KNOWROB_MODAL_FORMULA_H\n\n#include \"CompoundFormula.h\"\n#include \"ModalOperator.h\"\n#include \"knowrob/TimeInterval.h\"\n\nnamespace knowrob {\n\n\tclass ModalFormula : public CompoundFormula {\n\tpublic:\n\n\t\tModalFormula(ModalOperatorPtr modalOperator, const FormulaPtr &formula);\n\n\n\t\tconst ModalOperatorPtr &modalOperator() const { return modalOperator_; }\n\n\n\t\tconst FormulaPtr &modalFormula() const { return formulae_[0]; }\n\n\n\t\tbool isModalPossibility() const { return !isModalNecessity(); }\n\n\n\t\tbool isModalNecessity() const;\n\n\n\t\tconst char *operator_symbol() const override;\n\n\n\t\tvoid write(std::ostream &os) const override;\n\n\tprotected:\n\t\tconst ModalOperatorPtr modalOperator_;\n\n\t\tbool isEqual(const Formula &other) const override;\n\t};\n\n\tnamespace modals {\n\n\t\tstd::shared_ptr<ModalFormula> B(const FormulaPtr &phi);\n\n\n\t\tModalOperatorPtr B();\n\n\n\t\tModalOperatorPtr B(std::string_view perspective);\n\n\n\t\tModalOperatorPtr B(std::string_view perspective, double confidence);\n\n\n\t\tModalOperatorPtr B(double confidence);\n\n\n\t\tstd::shared_ptr<ModalFormula> K(const FormulaPtr &phi);\n\n\n\t\tModalOperatorPtr K();\n\n\n\t\tModalOperatorPtr K(std::string_view perspective);\n\n\n\t\tstd::shared_ptr<ModalFormula> P(const FormulaPtr &phi);\n\n\n\t\tModalOperatorPtr P();\n\n\n\t\tModalOperatorPtr P(const TimeInterval &timeInterval);\n\n\n\t\tstd::shared_ptr<ModalFormula> H(const FormulaPtr &phi);\n\n\n\t\tModalOperatorPtr H();\n\n\n\t\tModalOperatorPtr H(const TimeInterval &timeInterval);\n\t}\n}\n\n\n#endif\n\n'knowrob/include/knowrob/formulas/Predicate.h'\n:\n\n#ifndef KNOWROB_PREDICATE_H_\n#define KNOWROB_PREDICATE_H_\n\n#include <vector>\n#include <memory>\n#include <string>\n#include \"Formula.h\"\n#include \"knowrob/terms/Term.h\"\n#include \"knowrob/terms/Bindings.h\"\n#include \"knowrob/terms/Atom.h\"\n#include \"knowrob/terms/Function.h\"\n\nnamespace knowrob {\n\n\tclass Predicate : public Formula {\n\tpublic:\n\n\t\texplicit Predicate(std::string_view functor, const std::vector<TermPtr> &arguments = {});\n\n\n\t\texplicit Predicate(AtomPtr functor, const std::vector<TermPtr> &arguments = {});\n\n\n\t\tauto &functor() const { return functor_; }\n\n\n\t\tauto arity() const { return arguments().size(); }\n\n\n\t\tconst std::vector<TermPtr> &arguments() const { return arguments_; }\n\n\n\t\tconst std::set<std::string_view> &variables() { return variables_; }\n\n\n\t\tvoid write(std::ostream &os) const override;\n\n\n\t\tsize_t hash() const;\n\n\t\tstatic FunctionPtr toFunction(const std::shared_ptr<Predicate> &predicate);\n\n\t\tstatic std::shared_ptr<Predicate> fromFunction(const FunctionPtr &fn);\n\n\tprotected:\n\t\tconst AtomPtr functor_;\n\t\tconst std::vector<TermPtr> arguments_;\n\t\tconst std::set<std::string_view> variables_;\n\n\t\tstd::set<std::string_view> getVariables1() const;\n\n\t\tbool isEqual(const Formula &other) const override;\n\t};\n\n\tusing PredicatePtr = std::shared_ptr<Predicate>;\n}\n\n#endif\n\n'knowrob/tests/StorageTest.cpp'\n:\n\n#include <gtest/gtest.h>\n#include \"knowrob/storage/mongo/MongoKnowledgeGraph.h\"\n#include \"knowrob/queries/QueryParser.h\"\n#include \"knowrob/semweb/OntologyParser.h\"\n#include \"knowrob/semweb/rdfs.h\"\n#include \"knowrob/storage/redland/RedlandModel.h\"\n#include \"knowrob/semweb/PrefixRegistry.h\"\n#include \"knowrob/storage/ReifiedTriple.h\"\n#include \"knowrob/integration/prolog/PrologEngine.h\"\n#include \"knowrob/storage/StorageInterface.h\"\n#include \"knowrob/integration/prolog/PrologBackend.h\"\n\nusing namespace knowrob;\nusing namespace knowrob::mongo;\nusing namespace knowrob::semweb;\n\ntemplate<typename T> std::shared_ptr<T> createBackend();\n\ntemplate<> std::shared_ptr<MongoKnowledgeGraph> createBackend<MongoKnowledgeGraph>() {\n\tauto kg = std::make_shared<MongoKnowledgeGraph>();\n\tkg->setVocabulary(std::make_shared<Vocabulary>());\n\tkg->initializeBackend(\n\t\t\tMongoKnowledgeGraph::DB_URI_DEFAULT,\n\t\t\tMongoKnowledgeGraph::DB_NAME_KNOWROB,\n\t\t\tMongoKnowledgeGraph::COLL_NAME_TESTS);\n\tkg->drop();\n\tkg->tripleCollection()->createTripleIndex();\n\treturn kg;\n}\n\ntemplate<> std::shared_ptr<RedlandModel> createBackend<RedlandModel>() {\n\tauto kg = std::make_shared<RedlandModel>();\n\tkg->setVocabulary(std::make_shared<Vocabulary>());\n\tkg->setHashesStorage(RedlandHashType::MEMORY);\n\tkg->initializeBackend();\n\treturn kg;\n}\n\ntemplate<> std::shared_ptr<PrologBackend> createBackend<PrologBackend>() {\n\tauto kg = std::make_shared<PrologBackend>();\n\tkg->setVocabulary(std::make_shared<Vocabulary>());\n\tkg->initializeBackend();\n\tkg->removeAll();\n\treturn kg;\n}\n\n\ntemplate <class BackendType>\nclass StorageTest : public ::testing::Test {\npublic:\n\tstatic std::shared_ptr<BackendType> kg_;\n\tstatic std::shared_ptr<QueryableStorage> queryable_;\n\tstatic std::shared_ptr<StorageInterface> backend_;\n\n\tstatic void SetUpTestSuite() {\n\t\tauto vocabulary = std::make_shared<Vocabulary>();\n\t\tauto backendManager = std::make_shared<StorageManager>(vocabulary);\n\t\tbackend_ = std::make_shared<StorageInterface>(backendManager);\n\t\tkg_ = createBackend<BackendType>();\n\t\tbackendManager->addPlugin(\"test\", PluginLanguage::CPP, kg_);\n\t\tqueryable_ = kg_;\n\t\tPrefixRegistry::registerPrefix(\"swrl_test\", \"http:\n\t}\n\n\tstatic void TearDownTestSuite() {\n\t\tqueryable_ = nullptr;\n\t\tbackend_ = nullptr;\n\t\tkg_ = nullptr;\n\t}\n\n\n\ttemplate<class T>\n\tstd::vector<BindingsPtr> lookup(const T &data) {\n\t\tstd::vector<BindingsPtr> out;\n\t\tauto pattern = std::make_shared<TriplePattern>(data);\n\t\tauto pattern_q = std::make_shared<GraphPathQuery>(pattern);\n\n\n\t\tauto expanded_q = queryable_->expand(pattern_q);\n\t\tbackend_->query(queryable_, expanded_q->expanded, [&out](const BindingsPtr &next) {\n\t\t\tout.push_back(next);\n\t\t});\n\t\treturn out;\n\t}\n\n\tstd::vector<BindingsPtr> query(const std::shared_ptr<GraphQuery> &query) {\n\t\tstd::vector<BindingsPtr> out;\n\n\n\t\tauto expanded_q = queryable_->expand(query);\n\t\tbackend_->query(queryable_, expanded_q->expanded, [&out](const BindingsPtr &next) {\n\t\t\tout.push_back(next);\n\t\t});\n\t\treturn out;\n\t}\n\n\tstatic bool insertOne(const Triple &triple) {\n\t\treturn backend_->createTransaction(queryable_, StorageInterface::Insert)->commit(triple);\n\t}\n\n\tstatic bool mergeOne(const Triple &triple) {\n\t\treturn backend_->mergeInsert(queryable_, triple);\n\t}\n\n\tbool loadOntology(std::string_view path) {\n\t\tauto resolved = URI::resolve(path);\n\t\tauto origin = DataSource::getNameFromURI(resolved);\n\t\tauto vocab = backend_->vocabulary();\n\t\tOntologyParser parser(resolved, semweb::TripleFormat::RDF_XML);\n\t\tparser.setOrigin(ImportHierarchy::ORIGIN_USER);\n\n\t\tparser.setFilter([vocab](const Triple &triple) {\n\t\t\treturn !vocab->isAnnotationProperty(triple.predicate());\n\t\t});\n\n\t\tparser.setBlankPrefix(std::string(\"_\") + origin);\n\t\tauto result = parser.run([](const TripleContainerPtr &tripleContainer) {\n\t\t\tqueryable_->insertAll(tripleContainer);\n\t\t});\n\t\tif (result) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tKB_WARN(\"Failed to parse ontology {} ({})\", resolved, origin);\n\t\t\treturn false;\n\t\t}\n\t}\n};\n\ntemplate <typename T> std::shared_ptr<T> StorageTest<T>::kg_;\ntemplate <typename T> std::shared_ptr<QueryableStorage> StorageTest<T>::queryable_;\ntemplate <typename T> std::shared_ptr<StorageInterface> StorageTest<T>::backend_;\n\nstatic TriplePattern parse(const std::string &str) {\n\tauto p = QueryParser::parsePredicate(str);\n\treturn {p->arguments()[0], p->arguments()[1], p->arguments()[2], false};\n}\n\nusing TestableBackends = ::testing::Types<RedlandModel, PrologBackend, MongoKnowledgeGraph>;\nTYPED_TEST_SUITE(StorageTest, TestableBackends);\n\n#define TEST_LOOKUP(x) StorageTest<TypeParam>::lookup(x)\n#define TEST_QUERY(x) StorageTest<TypeParam>::query(x)\n#define TEST_INSERT_ONE(x) StorageTest<TypeParam>::insertOne(x)\n#define TEST_MERGE_ONE(x) StorageTest<TypeParam>::mergeOne(x)\n\n#define swrl_test_ \"http:\n\nTYPED_TEST(StorageTest, Assert_a_b_c) {\n\tTripleCopy data_abc(swrl_test_\"a\", swrl_test_\"b\", swrl_test_\"c\");\n\tEXPECT_NO_THROW(TEST_INSERT_ONE(data_abc));\n\tEXPECT_EQ(TEST_LOOKUP(data_abc).size(), 1);\n\tEXPECT_EQ(TEST_LOOKUP(TripleCopy(swrl_test_\"x\",swrl_test_\"b\",swrl_test_\"c\")).size(), 0);\n\tEXPECT_EQ(TEST_LOOKUP(TripleCopy(swrl_test_\"a\",swrl_test_\"x\",swrl_test_\"c\")).size(), 0);\n\tEXPECT_EQ(TEST_LOOKUP(TripleCopy(swrl_test_\"a\",swrl_test_\"b\",swrl_test_\"x\")).size(), 0);\n\tEXPECT_EQ(TEST_LOOKUP(parse(\"triple(A, swrl_test:b, swrl_test:c)\")).size(), 1);\n\tEXPECT_EQ(TEST_LOOKUP(parse(\"triple(A, swrl_test:x, swrl_test:c)\")).size(), 0);\n\tEXPECT_EQ(TEST_LOOKUP(parse(\"triple(swrl_test:a, B, swrl_test:c)\")).size(), 1);\n\tEXPECT_EQ(TEST_LOOKUP(parse(\"triple(swrl_test:x, B, swrl_test:c)\")).size(), 0);\n\tEXPECT_EQ(TEST_LOOKUP(parse(\"triple(swrl_test:a, swrl_test:b, C)\")).size(), 1);\n\tEXPECT_EQ(TEST_LOOKUP(parse(\"triple(swrl_test:x, swrl_test:b, C)\")).size(), 0);\n}\n\nTYPED_TEST(StorageTest, TripleWithOrigin) {\n\tTripleCopy data_cbd(swrl_test_\"c\", swrl_test_\"b\", swrl_test_\"d\");\n\tEXPECT_EQ(TEST_LOOKUP(data_cbd).size(), 0);\n\tdata_cbd.setGraph(swrl_test_\"origin1\");\n\tEXPECT_NO_THROW(TEST_INSERT_ONE(data_cbd));\n\tEXPECT_EQ(TEST_LOOKUP(data_cbd).size(), 1);\n\tdata_cbd.setGraph(swrl_test_\"origin2\");\n\tEXPECT_NO_THROW(TEST_INSERT_ONE(data_cbd));\n\n\tEXPECT_EQ(TEST_LOOKUP(data_cbd).size(), 1);\n\n\n\n\n\n\tEXPECT_GE(TEST_LOOKUP(parse(\"triple(swrl_test:c, swrl_test:b, swrl_test:d)\")).size(), 1);\n\n\tEXPECT_NO_THROW(StorageTest<TypeParam>::queryable_->removeOne(data_cbd));\n\tEXPECT_EQ(TEST_LOOKUP(parse(\"triple(swrl_test:c, swrl_test:b, swrl_test:d)\")).size(), 1);\n\n\tEXPECT_NO_THROW(StorageTest<TypeParam>::queryable_->removeOne(data_cbd));\n\tEXPECT_EQ(TEST_LOOKUP(parse(\"triple(swrl_test:c, swrl_test:b, swrl_test:d)\")).size(), 1);\n\n\tdata_cbd.setGraph(swrl_test_\"origin1\");\n\tEXPECT_NO_THROW(StorageTest<TypeParam>::queryable_->removeOne(data_cbd));\n\tEXPECT_EQ(TEST_LOOKUP(parse(\"triple(swrl_test:c, swrl_test:b, swrl_test:d)\")).size(), 0);\n}\n\nTYPED_TEST(StorageTest, LoadTestOntology) {\n\tEXPECT_NO_THROW(StorageTest<TypeParam>::loadOntology(\"tests/owl/swrl.owl\"));\n\tEXPECT_NO_THROW(StorageTest<TypeParam>::loadOntology(\"tests/owl/datatype_test.owl\"));\n}\n\nTYPED_TEST(StorageTest, QuerySubclassOf) {\n\tTripleCopy triple(\n\t\t\tswrl_test_\"Adult\",\n\t\t\trdfs::subClassOf->stringForm().data(),\n\t\t\tswrl_test_\"TestThing\");\n\tEXPECT_EQ(TEST_LOOKUP(triple).size(), 1);\n}\n\nTYPED_TEST(StorageTest, QueryRange) {\n\tTripleCopy triple(\n\t\t\tswrl_test_\"hasParent\",\n\t\t\trdfs::range->stringForm().data(),\n\t\t\tswrl_test_\"TestThing\");\n\tEXPECT_EQ(TEST_LOOKUP(triple).size(), 1);\n}\n\nTYPED_TEST(StorageTest, DeleteSubclassOf) {\n\tTripleCopy triple(\n\t\t\tswrl_test_\"Adult\",\n\t\t\trdfs::subClassOf->stringForm().data(),\n\t\t\tswrl_test_\"TestThing\");\n\tEXPECT_NO_THROW(StorageTest<TypeParam>::queryable_->removeOne(triple));\n\tEXPECT_EQ(TEST_LOOKUP(triple).size(), 0);\n}\n\nTYPED_TEST(StorageTest, AssertSubclassOf) {\n\tTripleCopy existing(\n\t\t\tswrl_test_\"Adult\",\n\t\t\trdfs::subClassOf->stringForm().data(),\n\t\t\tswrl_test_\"TestThing\");\n\tTripleCopy not_existing(\n\t\t\tswrl_test_\"Adult\",\n\t\t\trdfs::subClassOf->stringForm().data(),\n\t\t\tswrl_test_\"Car\");\n\tEXPECT_NO_THROW(TEST_INSERT_ONE(existing));\n\tEXPECT_EQ(TEST_LOOKUP(existing).size(), 1);\n\tEXPECT_EQ(TEST_LOOKUP(not_existing).size(), 0);\n}\n\nTYPED_TEST(StorageTest, PathQuery) {\n\n\tauto q1 = std::make_shared<TriplePattern>(\n\t\t\tQueryParser::parsePredicate(\"triple(swrl_test:'Lea', swrl_test:hasAncestor, ?x)\"));\n\tauto q2 = std::make_shared<TriplePattern>(\n\t\t\tQueryParser::parsePredicate(\"triple(?x, swrl_test:hasAncestor, swrl_test:'Rex')\"));\n\tauto query = std::make_shared<GraphPathQuery>(std::vector<TriplePatternPtr>{q1, q2});\n\tauto fred_iri = IRIAtom::Tabled(swrl_test_\"Fred\");\n\tauto fred_var = std::make_shared<Variable>(\"x\");\n\tauto results = TEST_QUERY(query);\n\n\n\n\tEXPECT_GE(results.size(), 1);\n\tfor (auto &result : results) {\n\t\tEXPECT_EQ(*result, Bindings({{fred_var, fred_iri}}));\n\t}\n}\n\nTYPED_TEST(StorageTest, UnionQuery) {\n\n\tauto q1 = std::make_shared<TriplePattern>(\n\t\t\tQueryParser::parsePredicate(\"triple(swrl_test:'Fred', swrl_test:hasAncestor, ?x)\"));\n\tauto q2 = std::make_shared<TriplePattern>(\n\t\t\tQueryParser::parsePredicate(\"triple(swrl_test:'Fred', swrl_test:hasSibling, ?x)\"));\n\tauto t1 = std::make_shared<GraphPattern>(q1);\n\tauto t2 = std::make_shared<GraphPattern>(q2);\n\tauto unionTerm = std::make_shared<GraphUnion>(\n\t\t\tstd::vector<std::shared_ptr<GraphTerm>>{t1,t2});\n\tauto results = TEST_QUERY(std::make_shared<GraphQuery>(unionTerm));\n\tEXPECT_EQ(results.size(), 2);\n}\n\nTYPED_TEST(StorageTest, QueryNegatedTriple) {\n\tauto negated = std::make_shared<TriplePattern>(\n\t\t\tQueryParser::parsePredicate(\"triple(swrl_test:x, swrl_test:p, swrl_test:y)\"), true);\n\tEXPECT_EQ(TEST_LOOKUP(*negated).size(), 1);\n\tTripleCopy statement(swrl_test_\"x\", swrl_test_\"p\", swrl_test_\"y\");\n\tEXPECT_NO_THROW(TEST_INSERT_ONE(statement));\n\tEXPECT_EQ(TEST_LOOKUP(*negated).size(), 0);\n}\n\nTYPED_TEST(StorageTest, Knowledge) {\n\tTripleCopy statement(swrl_test_\"Lea\", swrl_test_\"hasName\", \"Lea\", knowrob::XSDType::STRING);\n\tstatement.setIsUncertain(false);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 0);\n\tEXPECT_NO_THROW(TEST_INSERT_ONE(statement));\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 1);\n\tstatement.setIsUncertain(true);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 1);\n}\n\nTYPED_TEST(StorageTest, KnowledgeOfAgent) {\n\n\tTripleCopy statement(swrl_test_\"Lea\", swrl_test_\"hasName\", \"Lea\", knowrob::XSDType::STRING);\n\tstatement.setIsUncertain(false);\n\tstatement.setPerspective(swrl_test_\"Lea\");\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 0);\n\tEXPECT_NO_THROW(TEST_INSERT_ONE(statement));\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 1);\n\n\tstatement.setPerspective(swrl_test_\"Fred\");\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 0);\n}\n\nTYPED_TEST(StorageTest, Belief) {\n\n\tTripleCopy statement(swrl_test_\"Fred\", swrl_test_\"hasName\", \"Fred\", knowrob::XSDType::STRING);\n\tstatement.setIsUncertain(true);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 0);\n\tEXPECT_NO_THROW(TEST_INSERT_ONE(statement));\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 1);\n\n\tstatement.setIsUncertain(false);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 0);\n}\n\nTYPED_TEST(StorageTest, WithConfidence) {\n\n\tTripleCopy statement(swrl_test_\"Bob\", swrl_test_\"hasName\", \"Bob\", knowrob::XSDType::STRING);\n\tstatement.setIsUncertain(true);\n\tstatement.setConfidence(0.5);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 0);\n\tEXPECT_NO_THROW(TEST_INSERT_ONE(statement));\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 1);\n\n\tstatement.setConfidence(0.0);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 1);\n\n\tstatement.setConfidence(0.9);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 0);\n}\n\nTYPED_TEST(StorageTest, WithTimeInterval) {\n\n\tTripleCopy statement(swrl_test_\"Alice\", swrl_test_\"hasName\", \"Alice\", knowrob::XSDType::STRING);\n\tstatement.setBegin(5.0);\n\tstatement.setEnd(10.0);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 0);\n\tEXPECT_NO_THROW(TEST_INSERT_ONE(statement));\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 1);\n\n\tstatement.setEnd(20.0);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 0);\n\n\tstatement.setIsOccasional(true);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 1);\n}\n\nTYPED_TEST(StorageTest, ExtendsTimeInterval) {\n\n\tTripleCopy statement(swrl_test_\"Alice\", swrl_test_\"hasName\", \"Alice\", knowrob::XSDType::STRING);\n\tstatement.setBegin(10.0);\n\tstatement.setEnd(20.0);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 0);\n\tEXPECT_NO_THROW(TEST_MERGE_ONE(statement));\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 1);\n\n\tstatement.setBegin(5.0);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 1);\n\n\tstatement.setBegin(0.0);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 0);\n\n\tstatement.setIsOccasional(true);\n\tEXPECT_EQ(TEST_LOOKUP(statement).size(), 1);\n}\n",
        "gt": [
            "'knowrob/include/knowrob/formulas/ModalFormula.h'",
            "'knowrob/include/knowrob/formulas/Predicate.h'",
            "'knowrob/include/knowrob/queries/QueryParser.h'",
            "'knowrob/tests/StorageTest.cpp'"
        ]
    },
    {
        "files": [
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelServerConfig.h'",
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelServer.h'",
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelConfig.h'",
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelServer.cpp'"
        ],
        "content": "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelServerConfig.h'\n:\n\n#ifndef __OpUaStackCore_SecureChannelServerConfig_h__\n#define __OpUaStackCore_SecureChannelServerConfig_h__\n\n#include \"OpcUaStackCore/SecureChannel/SecureChannelConfig.h\"\n#include \"OpcUaStackCore/ServiceSet/EndpointDescription.h\"\n#include \"OpcUaStackCore/Certificate/ApplicationCertificate.h\"\n#include \"OpcUaStackCore/Certificate/CryptoManager.h\"\n#include \"OpcUaStackCore/Base/os.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT SecureChannelServerConfig\n\t: public SecureChannelConfig\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<SecureChannelServerConfig> SPtr;\n\n\t\tSecureChannelServerConfig(void);\n\t\t~SecureChannelServerConfig(void);\n\n\t\tvoid endpointDescriptionArray(EndpointDescriptionArray::SPtr& endpointDescriptionArray);\n\t\tEndpointDescriptionArray::SPtr& endpointDescriptionArray(void);\n\t\tvoid endpointDescription(EndpointDescription::SPtr& endpointDescription);\n\t\tEndpointDescription::SPtr& endpointDescription(void);\n\t\tvoid endpointUrl(const std::string& endpointUrl);\n\t\tstd::string& endpointUrl(void);\n\t\tvoid applicationCertificate(ApplicationCertificate::SPtr& applicationCertificate);\n\t\tApplicationCertificate::SPtr& applicationCertificate(void);\n\t\tvoid cryptoManager(CryptoManager::SPtr& cryptoManager);\n\t\tCryptoManager::SPtr& cryptoManager(void);\n\n\t\tvoid secureChannelLog(bool secureChannelLog);\n\t\tbool secureChannelLog(void);\n\n\t  private:\n\t\tApplicationCertificate::SPtr applicationCertificate_;\n\t\tCryptoManager::SPtr cryptoManager_;\n\n\t\tEndpointDescriptionArray::SPtr endpointDescriptionArray_;\n\t\tEndpointDescription::SPtr endpointDescription_;\n\t\tstd::string endpointUrl_;\n\n\t\tbool secureChannelLog_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelServer.h'\n:\n\n#ifndef __OpUaStackCore_SecureChannelServer_h__\n#define __OpUaStackCore_SecureChannelServer_h__\n\n#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <map>\n#include \"OpcUaStackCore/Base/os.h\"\n#include \"OpcUaStackCore/SecureChannel/SecureChannelServerConfig.h\"\n#include \"OpcUaStackCore/SecureChannel/SecureChannelServerIf.h\"\n#include \"OpcUaStackCore/SecureChannel/SecureChannelBase.h\"\n#include \"OpcUaStackCore/TCPChannel/TCPAcceptor.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT SecureChannelServer\n\t: public SecureChannelBase\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<SecureChannelServer> SPtr;\n\t\ttypedef std::map<std::string, SecureChannelServer::SPtr> Map;\n\n\t\tSecureChannelServer(IOThread* ioThread);\n\t\t~SecureChannelServer(void);\n\n\t\tvoid secureChannelServerIf(SecureChannelServerIf* secureChannelServerIf);\n\t\tSecureChannelServerIf* secureChannelServerIf(void);\n\n\t\tbool accept(SecureChannelServerConfig::SPtr secureChannelServerConfig);\n\t\tvoid disconnect(void);\n\t\tvoid disconnect(SecureChannel* secureChannel);\n\t\tvoid sendResponse(SecureChannel* secureChannel, SecureChannelTransaction::SPtr& secureChannelTransaction);\n\n\n\t\tvoid handleDisconnect(SecureChannel* secureChannel);\n\t\tvoid handleRecvHello(SecureChannel* secureChannel, HelloMessage& hello);\n\t\tvoid handleRecvOpenSecureChannelRequest(SecureChannel* secureChannel, OpcUaUInt32 channelId, OpenSecureChannelRequest& openSecureChannelRequest);\n\t\tvoid handleRecvCloseSecureChannelRequest(SecureChannel* secureChannel, uint32_t channelId);\n\t\tvoid handleRecvMessageRequest(SecureChannel* secureChannel);\n\n\n\t  private:\n\t\tvoid accept(SecureChannel* secureChannel);\n\t\tvoid resolveComplete(\n\t\t\tconst boost::system::error_code& error,\n\t\t\tboost::asio::ip::tcp::resolver::iterator endpointIterator,\n\t\t\tSecureChannel* secureChannel\n\t\t);\n\t\tvoid acceptComplete(\n\t\t\tconst boost::system::error_code& error,\n\t\t\tSecureChannel* secureChannel\n\t\t);\n\n\t\tstd::string endpointUrl_;\n\t\tIOThread* ioThread_;\n\t\tboost::asio::ip::tcp::resolver resolver_;\n\t\tSecureChannelServerIf* secureChannelServerIf_;\n\t\tTCPAcceptor* tcpAcceptor_;\n\n\t\tObject::SPtr handle_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelConfig.h'\n:\n\n#ifndef __OpUaStackCore_SecureChannelConfig_h__\n#define __OpUaStackCore_SecureChannelConfig_h__\n\n#include \"OpcUaStackCore/Base/Object.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaBaseEnums.h\"\n#include \"OpcUaStackCore/BuildInTypes/OpcUaNumber.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tclass DLLEXPORT SecureChannelConfig\n\t: public Object\n\t{\n\t  public:\n\t\ttypedef boost::shared_ptr<SecureChannelConfig> SPtr;\n\n\t\tSecureChannelConfig(void);\n\t\tvirtual ~SecureChannelConfig(void);\n\n\t\tvoid receivedBufferSize(OpcUaUInt32 receivedBufferSize);\n\t\tOpcUaUInt32 receivedBufferSize(void);\n\t\tvoid sendBufferSize(OpcUaUInt32 sendBufferSize);\n\t\tOpcUaUInt32 sendBufferSize(void);\n\t\tvoid maxMessageSize(OpcUaUInt32 maxMessageSize);\n\t\tOpcUaUInt32 maxMessageSize(void);\n\t\tvoid maxChunkCount(OpcUaUInt32 maxChunkCount);\n\t\tOpcUaUInt32 maxChunkCount(void);\n\n\t  private:\n\t\tOpcUaUInt32 receivedBufferSize_;\n\t\tOpcUaUInt32 sendBufferSize_;\n\t\tOpcUaUInt32 maxMessageSize_;\n\t\tOpcUaUInt32 maxChunkCount_;\n\t};\n\n}\n\n#endif\n\n'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelServer.cpp'\n:\n\n#include \"OpcUaStackCore/Base/Log.h\"\n#include \"OpcUaStackCore/Base/Url.h\"\n#include \"OpcUaStackCore/SecureChannel/SecureChannelServer.h\"\n\nnamespace OpcUaStackCore\n{\n\n\tSecureChannelServer::SecureChannelServer(IOThread* ioThread)\n\t: SecureChannelBase(SecureChannelBase::SCT_Server)\n\t, secureChannelServerIf_(nullptr)\n\t, ioThread_(ioThread)\n\t, resolver_(ioThread->ioService()->io_service())\n\t, tcpAcceptor_(nullptr)\n\t, endpointUrl_(\"\")\n\t{\n\t}\n\n\tSecureChannelServer::~SecureChannelServer(void)\n\t{\n\t}\n\n\tvoid\n\tSecureChannelServer::secureChannelServerIf(SecureChannelServerIf* secureChannelServerIf)\n\t{\n\t\tsecureChannelServerIf_ = secureChannelServerIf;\n\t}\n\n\tSecureChannelServerIf*\n\tSecureChannelServer::secureChannelServerIf(void)\n\t{\n\t\treturn secureChannelServerIf_;\n\t}\n\n\tbool\n\tSecureChannelServer::accept(SecureChannelServerConfig::SPtr secureChannelServerConfig)\n\t{\n\t\tapplicationCertificate(secureChannelServerConfig->applicationCertificate());\n\t\tcryptoManager(secureChannelServerConfig->cryptoManager());\n\n\n\t\tif (secureChannelServerIf_ == nullptr) {\n\t\t\tLog(Error, \"secure channel server interface invalid; please register interface\")\n\t\t\t\t.parameter(\"EndpointUrl\", endpointUrl_);\n\t\t\treturn false;\n\t\t}\n\n\n\t\tauto secureChannel = new SecureChannel(ioThread_);\n\t\tsecureChannel->config_ = secureChannelServerConfig;\n\t\taccept(secureChannel);\n\t\treturn true;\n\t}\n\n\tvoid\n\tSecureChannelServer::disconnect(void)\n\t{\n\t\tif (tcpAcceptor_ != nullptr) {\n\n\n\t\t\ttcpAcceptor_->cancel();\n\t\t}\n\t\telse {\n\t\t\tsecureChannelServerIf_->handleEndpointClose(endpointUrl_);\n\t\t}\n\t}\n\n\tvoid\n\tSecureChannelServer::disconnect(SecureChannel* secureChannel)\n\t{\n\n\n\t\tsecureChannel->socket().cancel();\n\t\tsecureChannel->state_ = SecureChannel::S_CloseSecureChannel;\n\t}\n\n\tvoid\n\tSecureChannelServer::sendResponse(SecureChannel* secureChannel, SecureChannelTransaction::SPtr& secureChannelTransaction)\n\t{\n\n\t\tasyncWriteMessageResponse(secureChannel, secureChannelTransaction);\n\t}\n\n\tvoid\n\tSecureChannelServer::accept(SecureChannel* secureChannel)\n\t{\n\t\tauto config = boost::static_pointer_cast<SecureChannelServerConfig>(secureChannel->config_);\n\n\t\tendpointUrl_ = config->endpointUrl();\n\n\t\tsecureChannel->isLogging_ = config->secureChannelLog();\n\t\tsecureChannel->receivedBufferSize_ = config->receivedBufferSize();\n\t\tsecureChannel->sendBufferSize_ = config->sendBufferSize();\n\t\tsecureChannel->maxMessageSize_ = config->maxMessageSize();\n\t\tsecureChannel->maxChunkCount_ = config->maxChunkCount();\n\t\tsecureChannel->endpointUrl_ = config->endpointUrl();\n\n\n\t\tUrl url(config->endpointUrl());\n\t\tif (url.isHostAddress()) {\n\t\t\turl.host(\"0.0.0.0\");\n\t\t}\n\n\n\t\tsecureChannel->partner_.port(url.port());\n\t\tboost::asio::ip::tcp::resolver::query query(url.host(), url.portToString());\n\t\tresolver_.async_resolve(\n\t\t\tquery,\n\t\t\tboost::bind(\n\t\t\t\t&SecureChannelServer::resolveComplete,\n\t\t\t\tthis,\n\t\t\t\tboost::asio::placeholders::error,\n\t\t\t\tboost::asio::placeholders::iterator,\n\t\t\t\tsecureChannel\n\t\t\t)\n\t\t);\n\t}\n\n\tvoid\n\tSecureChannelServer::resolveComplete(\n\t\tconst boost::system::error_code& error,\n\t\tboost::asio::ip::tcp::resolver::iterator endpointIterator,\n\t\tSecureChannel* secureChannel\n\t)\n\t{\n\t\tif (error) {\n\t\t\tLog(Error, \"address resolver error\")\n\t\t\t\t.parameter(\"EndpointUrl\", secureChannel->endpointUrl_)\n\t\t\t\t.parameter(\"Message\", error.message());\n\n\n\t\t\tstd::string endpointUrl = secureChannel->endpointUrl_;\n\t\t\tdelete secureChannel;\n\n\n\t\t\tif (tcpAcceptor_ != nullptr) {\n\t\t\t\ttcpAcceptor_->close();\n\t\t\t\tdelete tcpAcceptor_;\n\t\t\t\ttcpAcceptor_ = nullptr;\n\t\t\t}\n\t\t\tsecureChannelServerIf_->handleEndpointClose(endpointUrl);\n\n\t\t\treturn;\n\t\t}\n\t\tsecureChannel->local_ = ((*endpointIterator).endpoint());\n\n\n\t\tif (tcpAcceptor_ == nullptr) {\n\t\t\tLog(Info, \"secure channel endpoint open\")\n\t\t\t\t.parameter(\"Address\", secureChannel->local_.address().to_string())\n\t\t\t\t.parameter(\"Port\", secureChannel->local_.port());\n\n\t\t\ttcpAcceptor_ = new TCPAcceptor(ioThread_->ioService()->io_service(), secureChannel->local_);\n\t\t\ttcpAcceptor_->listen();\n\n\t\t\tsecureChannelServerIf_->handleEndpointOpen(secureChannel->endpointUrl_);\n\t\t}\n\n\t\tsecureChannel->state_ = SecureChannel::S_Accepting;\n\t\ttcpAcceptor_->async_accept(\n\t\t\tsecureChannel->socket(),\n\t\t\tboost::bind(\n\t\t\t\t&SecureChannelServer::acceptComplete,\n\t\t\t\tthis,\n\t\t\t\tboost::asio::placeholders::error,\n\t\t\t\tsecureChannel\n\t\t\t)\n\t\t);\n\t}\n\n\tvoid\n\tSecureChannelServer::acceptComplete(\n\t\tconst boost::system::error_code& error,\n\t\tSecureChannel* secureChannel\n\t)\n\t{\n\t\tif (error) {\n\t\t\tLog(Info, \"cannot accept secure channel from client\")\n\t\t\t\t.parameter(\"Address\", secureChannel->partner_.address().to_string())\n\t\t\t\t.parameter(\"Port\", secureChannel->partner_.port())\n\t\t\t\t.parameter(\"Message\", error.message());\n\n\n\t\t\tstd::string endpointUrl = secureChannel->endpointUrl_;\n\t\t\tdelete secureChannel;\n\n\n\t\t\tif (tcpAcceptor_ != nullptr) {\n\t\t\t\ttcpAcceptor_->close();\n\t\t\t\tdelete tcpAcceptor_;\n\t\t\t\ttcpAcceptor_ = nullptr;\n\t\t\t}\n\t\t\tsecureChannelServerIf_->handleEndpointClose(endpointUrl);\n\n\t\t\treturn;\n\t\t}\n\n\t\tsecureChannel->partner_ = secureChannel->socket().remote_endpoint();\n\n\t\tLog(Info, \"accepted new secure channel from client\")\n\t\t\t.parameter(\"Address\", secureChannel->partner_.address().to_string())\n\t\t\t.parameter(\"Port\", secureChannel->partner_.port());\n\n\t\tsecureChannel->state_ = SecureChannel::S_Connected;\n\t\tasyncRead(secureChannel);\n\n\t\tSecureChannelServerConfig::SPtr config;\n\t\tconfig = boost::static_pointer_cast<SecureChannelServerConfig>(secureChannel->config_);\n\t\taccept(config);\n\t}\n\n\tvoid\n\tSecureChannelServer::handleDisconnect(SecureChannel* secureChannel)\n\t{\n\t\tLog(Info, \"secure channel closed\")\n\t\t\t.parameter(\"Local-Address\", secureChannel->local_.address().to_string())\n\t\t\t.parameter(\"Local-Port\", secureChannel->local_.port())\n\t\t\t.parameter(\"Partner-Address\", secureChannel->partner_.address().to_string())\n\t\t\t.parameter(\"Partner-Port\", secureChannel->partner_.port());\n\n\t\tsecureChannelServerIf_->handleDisconnect(secureChannel);\n\t\tdelete secureChannel;\n\t}\n\n\tvoid\n\tSecureChannelServer::handleRecvHello(SecureChannel* secureChannel, HelloMessage& hello)\n\t{\n\t\tAcknowledgeMessage acknowledge;\n\n\n\t\tif (hello.protocolVersion() != 0) {\n\t\t\tLog(Error, \"receive invalid protocol version in hello request\");\n\t\t\tsecureChannel->socket().cancel();\n\t\t\tsecureChannel->state_ = SecureChannel::S_CloseSecureChannel;\n\t\t\treturn;\n\t\t}\n\t\tacknowledge.protocolVersion(0);\n\n\n\t\tif (hello.receivedBufferSize() > secureChannel->receivedBufferSize_) {\n\t\t\tacknowledge.receivedBufferSize(secureChannel->receivedBufferSize_);\n\t\t}\n\t\telse {\n\t\t\tacknowledge.receivedBufferSize(hello.receivedBufferSize());\n\t\t}\n\t\tsecureChannel->receivedBufferSize_ = acknowledge.receivedBufferSize();\n\n\n\t\tif (hello.sendBufferSize() > secureChannel->sendBufferSize_) {\n\t\t\tacknowledge.sendBufferSize(secureChannel->sendBufferSize_);\n\t\t}\n\t\telse {\n\t\t\tacknowledge.sendBufferSize(hello.sendBufferSize());\n\t\t}\n\t\tsecureChannel->sendBufferSize_ = acknowledge.sendBufferSize();\n\n\n\t\tif (hello.maxMessageSize() > secureChannel->maxMessageSize_) {\n\t\t\tacknowledge.maxMessageSize(secureChannel->maxMessageSize_);\n\t\t}\n\t\telse {\n\t\t\tacknowledge.maxMessageSize(hello.maxMessageSize());\n\t\t}\n\t\tsecureChannel->maxMessageSize_ = acknowledge.maxMessageSize();\n\n\n\t\tif (hello.maxChunkCount() > secureChannel->maxChunkCount_) {\n\t\t\tacknowledge.maxChunkCount(secureChannel->maxChunkCount_);\n\t\t}\n\t\telse {\n\t\t\tacknowledge.maxChunkCount(hello.maxChunkCount());\n\t\t}\n\t\tsecureChannel->maxChunkCount_ = acknowledge.maxChunkCount();\n\n\t\tasyncWriteAcknowledge(secureChannel, acknowledge);\n\t}\n\n\tvoid\n\tSecureChannelServer::handleRecvOpenSecureChannelRequest(\n\t\tSecureChannel* secureChannel,\n\t\tOpcUaUInt32 channelId,\n\t\tOpenSecureChannelRequest& openSecureChannelRequest\n\t)\n\t{\n\n\n\t\tSecureChannelServerConfig::SPtr secureChannelServerConfig;\n\t\tsecureChannelServerConfig = boost::static_pointer_cast<SecureChannelServerConfig>(secureChannel->config_);\n\n\t\tEndpointDescription::SPtr endpointDescription;\n\t\tsecureChannelServerConfig->endpointDescriptionArray()->get(0, endpointDescription);\n\t\tsecureChannelServerConfig->endpointDescription(endpointDescription);\n\n\n\t\tbool success = true;\n\t\tif (openSecureChannelRequest.requestType() == RT_ISSUE) {\n\n\n\n\t\t\tif (secureChannel->channelId_ != 0) {\n\t\t\t\tsuccess = false;\n\t\t\t\tLog(Error, \"receive invalid request type in OpenSecureChannelRequest\")\n\t\t\t\t\t.parameter(\"Local-Address\", secureChannel->local_.address().to_string())\n\t\t\t\t\t.parameter(\"Local-Port\", secureChannel->local_.port())\n\t\t\t\t\t.parameter(\"Partner-Address\", secureChannel->partner_.address().to_string())\n\t\t\t\t\t.parameter(\"Partner-Port\", secureChannel->partner_.port())\n\t\t\t\t\t.parameter(\"RequestedType\", openSecureChannelRequest.requestType());\n\t\t\t}\n\t\t\tsecureChannel->gChannelId_++;\n\t\t\tsecureChannel->channelId_ = secureChannel->gChannelId_;\n\t\t}\n\t\telse if (openSecureChannelRequest.requestType() ==  RT_RENEW) {\n\n\n\n\t\t\tif (secureChannel->channelId_ != channelId) {\n\t\t\t\tsuccess = false;\n\t\t\t\tLog(Error, \"receive invalid channel id in OpenSecureChannelRequest\")\n\t\t\t\t\t.parameter(\"Local-Address\", secureChannel->local_.address().to_string())\n\t\t\t\t\t.parameter(\"Local-Port\", secureChannel->local_.port())\n\t\t\t\t\t.parameter(\"Partner-Address\", secureChannel->partner_.address().to_string())\n\t\t\t\t\t.parameter(\"Partner-Port\", secureChannel->partner_.port())\n\t\t\t\t\t.parameter(\"ChannelId\", channelId);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsuccess = false;\n\t\t\tLog(Error, \"receive invalid OpenSecureChannelRequest\")\n\t\t\t\t.parameter(\"Local-Address\", secureChannel->local_.address().to_string())\n\t\t\t\t.parameter(\"Local-Port\", secureChannel->local_.port())\n\t\t\t\t.parameter(\"Partner-Address\", secureChannel->partner_.address().to_string())\n\t\t\t\t.parameter(\"Partner-Port\", secureChannel->partner_.port())\n\t\t\t\t.parameter(\"ChannelId\", channelId);\n\t\t}\n\t\tif (!success) {\n\t\t\tsecureChannel->socket().close();\n\t\t\tsecureChannel->state_ = SecureChannel::S_CloseSecureChannel;\n\t\t\treturn;\n\t\t}\n\n\n\t\tsecureChannel->secureTokenVec_.push_back(std::rand());\n\n\n\t\tOpenSecureChannelResponse::SPtr openSecureChannelResponse = constructSPtr<OpenSecureChannelResponse>();\n\t\tOpcUaByte serverNonce[1];\n\t\tserverNonce[0] = 0x01;\n\t\topenSecureChannelResponse->securityToken()->channelId(secureChannel->channelId_);\n\t\topenSecureChannelResponse->securityToken()->tokenId(secureChannel->secureTokenVec_[secureChannel->secureTokenVec_.size()-1]);\n\t\topenSecureChannelResponse->securityToken()->createAt().dateTime(boost::posix_time::microsec_clock::local_time());\n\t\topenSecureChannelResponse->securityToken()->revisedLifetime(openSecureChannelRequest.requestedLifetime());\n\t\topenSecureChannelResponse->responseHeader()->requestHandle(openSecureChannelRequest.requestHeader()->requestHandle());\n\t\topenSecureChannelResponse->responseHeader()->time().dateTime(boost::posix_time::microsec_clock::local_time());\n\t\topenSecureChannelResponse->serverNonce(serverNonce, 1);\n\n\n\t\tasyncWriteOpenSecureChannelResponse(secureChannel, openSecureChannelResponse);\n\n\t\tif (openSecureChannelRequest.requestType() ==  RT_ISSUE) {\n\t\t\tsecureChannelServerIf_->handleConnect(secureChannel);\n\t\t}\n\t}\n\n\tvoid\n\tSecureChannelServer::handleRecvCloseSecureChannelRequest(SecureChannel* secureChannel, uint32_t channelId)\n\t{\n\t\tLog(Debug, \"close secure channel, because receive close secure channel from partner\")\n\t\t\t.parameter(\"Local-Address\", secureChannel->local_.address().to_string())\n\t\t\t.parameter(\"Local-Port\", secureChannel->local_.port())\n\t\t\t.parameter(\"Partner-Address\", secureChannel->partner_.address().to_string())\n\t\t\t.parameter(\"Partner-Port\", secureChannel->partner_.port());\n\n\t\tsecureChannel->socket().cancel();\n\t\tsecureChannel->state_ = SecureChannel::S_CloseSecureChannel;\n\t}\n\n\tvoid\n\tSecureChannelServer::handleRecvMessageRequest(SecureChannel* secureChannel)\n\t{\n\t\tsecureChannelServerIf_->handleMessageRequest(secureChannel);\n\t}\n\n}\n",
        "gt": [
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelConfig.h'",
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelServerConfig.h'",
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelServer.h'",
            "'OpcUaStack/src/OpcUaStackCore/SecureChannel/SecureChannelServer.cpp'"
        ]
    },
    {
        "files": [
            "'Tempest/Engine/gapi/metal/mtdevice.h'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'",
            "'Tempest/Engine/gapi/metal/mtpipeline.cpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLAccelerationStructureTypes.hpp'"
        ],
        "content": "'Tempest/Engine/gapi/metal/mtdevice.h'\n:#pragma once\n\n#include <Tempest/AbstractGraphicsApi>\n#include <Tempest/AccelerationStructure>\n#include <Tempest/RenderState>\n#include <Tempest/Except>\n\n#include <Metal/Metal.hpp>\n#include <Foundation/Foundation.hpp>\n\n#include \"../utility/compiller_hints.h\"\n#include \"gapi/shaderreflection.h\"\n#include \"mtsamplercache.h\"\n#include \"nsptr.h\"\n\nclass MTLDevice;\n\nnamespace Tempest {\nnamespace Detail {\n\ninline MTL::PixelFormat nativeFormat(TextureFormat frm) {\n  switch(frm) {\n    case Undefined:\n    case Last:\n      return MTL::PixelFormatInvalid;\n    case R8:\n      return MTL::PixelFormatR8Unorm;\n    case RG8:\n      return MTL::PixelFormatRG8Unorm;\n    case RGB8:\n      return MTL::PixelFormatInvalid;\n    case RGBA8:\n      return MTL::PixelFormatRGBA8Unorm;\n    case R16:\n      return MTL::PixelFormatR16Unorm;\n    case RG16:\n      return MTL::PixelFormatRG16Unorm;\n    case RGB16:\n      return MTL::PixelFormatInvalid;\n    case RGBA16:\n      return MTL::PixelFormatRGBA16Unorm;\n    case R32F:\n      return MTL::PixelFormatR32Float;\n    case RG32F:\n      return MTL::PixelFormatRG32Float;\n    case RGB32F:\n      return MTL::PixelFormatInvalid;\n    case RGBA32F:\n      return MTL::PixelFormatRGBA32Float;\n    case R32U:\n      return MTL::PixelFormatR32Uint;\n    case RG32U:\n      return MTL::PixelFormatRG32Uint;\n    case RGB32U:\n      return MTL::PixelFormatInvalid;\n    case RGBA32U:\n      return MTL::PixelFormatRGBA32Uint;\n    case Depth16:\n      return MTL::PixelFormatDepth16Unorm;\n    case Depth24x8:\n      return MTL::PixelFormatInvalid;\n    case Depth24S8:\n      return MTL::PixelFormatDepth24Unorm_Stencil8;\n    case Depth32F:\n      return MTL::PixelFormatDepth32Float;\n    case DXT1:\n      return MTL::PixelFormatBC1_RGBA;\n    case DXT3:\n      return MTL::PixelFormatBC2_RGBA;\n    case DXT5:\n      return MTL::PixelFormatBC3_RGBA;\n    case R11G11B10UF:\n      return MTL::PixelFormatRG11B10Float;\n    case RGBA16F:\n      return MTL::PixelFormatRGBA16Float;\n    }\n  return MTL::PixelFormatInvalid;\n  }\n\ninline MTL::VertexFormat nativeFormat(Decl::ComponentType t) {\n  switch(t) {\n    case Decl::ComponentType::count:\n    case Decl::ComponentType::float0:\n      return MTL::VertexFormatInvalid;\n    case Decl::ComponentType::float1:\n      return MTL::VertexFormatFloat;\n    case Decl::ComponentType::float2:\n      return MTL::VertexFormatFloat2;\n    case Decl::ComponentType::float3:\n      return MTL::VertexFormatFloat3;\n    case Decl::ComponentType::float4:\n      return MTL::VertexFormatFloat4;\n\n    case Decl::ComponentType::int1:\n      return MTL::VertexFormatInt;\n    case Decl::ComponentType::int2:\n      return MTL::VertexFormatInt2;\n    case Decl::ComponentType::int3:\n      return MTL::VertexFormatInt3;\n    case Decl::ComponentType::int4:\n      return MTL::VertexFormatInt4;\n\n    case Decl::ComponentType::uint1:\n      return MTL::VertexFormatUInt;\n    case Decl::ComponentType::uint2:\n      return MTL::VertexFormatUInt2;\n    case Decl::ComponentType::uint3:\n      return MTL::VertexFormatUInt3;\n    case Decl::ComponentType::uint4:\n      return MTL::VertexFormatUInt4;\n    }\n  return MTL::VertexFormatInvalid;\n  }\n\ninline MTL::CompareFunction nativeFormat(RenderState::ZTestMode m) {\n  switch(m) {\n    case RenderState::ZTestMode::Always:\n      return MTL::CompareFunctionAlways;\n    case RenderState::ZTestMode::Never:\n      return MTL::CompareFunctionNever;\n    case RenderState::ZTestMode::Greater:\n      return MTL::CompareFunctionGreater;\n    case RenderState::ZTestMode::Less:\n      return MTL::CompareFunctionLess;\n    case RenderState::ZTestMode::GEqual:\n      return MTL::CompareFunctionGreaterEqual;\n    case RenderState::ZTestMode::LEqual:\n      return MTL::CompareFunctionLessEqual;\n    case RenderState::ZTestMode::NoEqual:\n      return MTL::CompareFunctionNotEqual;\n    case RenderState::ZTestMode::Equal:\n      return MTL::CompareFunctionEqual;\n    }\n  return MTL::CompareFunctionAlways;\n  }\n\ninline MTL::BlendFactor nativeFormat(RenderState::BlendMode m) {\n  switch(m) {\n    case RenderState::BlendMode::Zero:\n      return MTL::BlendFactorZero;\n    case RenderState::BlendMode::One:\n      return MTL::BlendFactorOne;\n    case RenderState::BlendMode::SrcColor:\n      return MTL::BlendFactorSourceColor;\n    case RenderState::BlendMode::OneMinusSrcColor:\n      return MTL::BlendFactorOneMinusSourceColor;\n    case RenderState::BlendMode::SrcAlpha:\n      return MTL::BlendFactorSourceAlpha;\n    case RenderState::BlendMode::SrcAlphaSaturate:\n      return MTL::BlendFactorSourceAlphaSaturated;\n    case RenderState::BlendMode::OneMinusSrcAlpha:\n      return MTL::BlendFactorOneMinusSourceAlpha;\n    case RenderState::BlendMode::DstColor:\n      return MTL::BlendFactorDestinationColor;\n    case RenderState::BlendMode::OneMinusDstColor:\n      return MTL::BlendFactorOneMinusDestinationColor;\n    case RenderState::BlendMode::DstAlpha:\n      return MTL::BlendFactorDestinationAlpha;\n    case RenderState::BlendMode::OneMinusDstAlpha:\n      return MTL::BlendFactorOneMinusDestinationAlpha;\n    }\n  return MTL::BlendFactorZero;\n  }\n\ninline MTL::BlendOperation nativeFormat(RenderState::BlendOp op) {\n  switch(op) {\n    case RenderState::BlendOp::Add:\n      return MTL::BlendOperationAdd;\n    case RenderState::BlendOp::Max:\n      return MTL::BlendOperationMax;\n    case RenderState::BlendOp::Min:\n      return MTL::BlendOperationMin;\n    case RenderState::BlendOp::ReverseSubtract:\n      return MTL::BlendOperationReverseSubtract;\n    case RenderState::BlendOp::Subtract:\n      return MTL::BlendOperationSubtract;\n    }\n  return MTL::BlendOperationAdd;\n  }\n\ninline MTL::CullMode nativeFormat(RenderState::CullMode m) {\n  switch(m) {\n    case RenderState::CullMode::NoCull:\n      return MTL::CullModeNone;\n    case RenderState::CullMode::Back:\n      return MTL::CullModeBack;\n    case RenderState::CullMode::Front:\n      return MTL::CullModeFront;\n    }\n  return MTL::CullModeNone;\n  }\n\ninline MTL::PrimitiveType nativeFormat(Topology t) {\n  switch(t) {\n    case Topology::Points:    return MTL::PrimitiveTypePoint;\n    case Topology::Lines:     return MTL::PrimitiveTypeLine;\n    case Topology::Triangles: return MTL::PrimitiveTypeTriangle;\n    }\n  return MTL::PrimitiveTypePoint;\n  }\n\ninline MTL::IndexType nativeFormat(IndexClass icls) {\n  switch(icls) {\n    case IndexClass::i16: return MTL::IndexTypeUInt16;\n    case IndexClass::i32: return MTL::IndexTypeUInt32;\n    }\n  return MTL::IndexTypeUInt16;\n  }\n\ninline MTL::AccelerationStructureInstanceOptions nativeFormat(RtInstanceFlags f) {\n  MTL::AccelerationStructureInstanceOptions ret = 0;\n  if((f & RtInstanceFlags::NonOpaque)==RtInstanceFlags::NonOpaque)\n    ret |= MTL::AccelerationStructureInstanceOptionNonOpaque; else\n    ret |= MTL::AccelerationStructureInstanceOptionOpaque;\n  if((f & RtInstanceFlags::CullDisable)==RtInstanceFlags::CullDisable)\n    ret |= MTL::AccelerationStructureInstanceOptionDisableTriangleCulling;\n  if((f & RtInstanceFlags::CullFlip)==RtInstanceFlags::CullFlip)\n    ret |= MTL::AccelerationStructureInstanceOptionTriangleFrontFacingWindingCounterClockwise;\n  return ret;\n  }\n\ninline MTL::RenderStages nativeFormat(ShaderReflection::Stage st) {\n  uint32_t stageFlags = 0;\n  if(st&ShaderReflection::Compute)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Vertex)\n    stageFlags |= MTL::RenderStageVertex;\n  if(st&ShaderReflection::Control)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Evaluate)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Geometry)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Fragment)\n    stageFlags |= MTL::RenderStageFragment;\n  if(st&ShaderReflection::Task)\n    stageFlags |=  MTL::RenderStageObject;\n  if(st&ShaderReflection::Mesh)\n    stageFlags |=  MTL::RenderStageMesh;\n  return MTL::RenderStages(stageFlags);\n  }\n\nclass MtDevice : public AbstractGraphicsApi::Device {\n  public:\n    MtDevice(std::string_view name, bool validation);\n    ~MtDevice();\n\n    void onSubmit();\n    void onFinish();\n    void waitIdle() override;\n\n    bool     useNativeImageAtomic() const;\n    uint32_t linearImageAlignment() const;\n\n    static void handleError(NS::Error* err);\n\n    NsPtr<MTL::Device>         impl;\n    NsPtr<MTL::CommandQueue>   queue;\n\n    std::condition_variable    devIdleCv;\n    std::mutex                 devIdleSync;\n    std::atomic_uint32_t       devCmdBuf{0};\n\n    AbstractGraphicsApi::Props prop;\n    MtSamplerCache             samplers;\n    bool                       validation = false;\n    MTL::LanguageVersion       mslVersion = MTL::LanguageVersion2_0;\n    uint32_t                   ui32align  = 0;\n\n    static void deductProps(AbstractGraphicsApi::Props& prop, MTL::Device& dev);\n  };\n\ninline void mtAssert(void* obj, NS::Error* err) {\n  if(T_LIKELY(obj!=nullptr))\n    return;\n  MtDevice::handleError(err);\n  }\n\n}\n}\n\n'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n\n\n#include \"MTLAccelerationStructure.hpp\"\n#include \"MTLAccelerationStructureCommandEncoder.hpp\"\n#include \"MTLAccelerationStructureTypes.hpp\"\n#include \"MTLArgument.hpp\"\n#include \"MTLArgumentEncoder.hpp\"\n#include \"MTLBinaryArchive.hpp\"\n#include \"MTLBlitCommandEncoder.hpp\"\n#include \"MTLBlitPass.hpp\"\n#include \"MTLBuffer.hpp\"\n#include \"MTLCaptureManager.hpp\"\n#include \"MTLCaptureScope.hpp\"\n#include \"MTLCommandBuffer.hpp\"\n#include \"MTLCommandEncoder.hpp\"\n#include \"MTLCommandQueue.hpp\"\n#include \"MTLComputeCommandEncoder.hpp\"\n#include \"MTLComputePass.hpp\"\n#include \"MTLComputePipeline.hpp\"\n#include \"MTLCounters.hpp\"\n#include \"MTLDefines.hpp\"\n#include \"MTLDepthStencil.hpp\"\n#include \"MTLDevice.hpp\"\n#include \"MTLDrawable.hpp\"\n#include \"MTLDynamicLibrary.hpp\"\n#include \"MTLEvent.hpp\"\n#include \"MTLFence.hpp\"\n#include \"MTLFunctionConstantValues.hpp\"\n#include \"MTLFunctionDescriptor.hpp\"\n#include \"MTLFunctionHandle.hpp\"\n#include \"MTLFunctionLog.hpp\"\n#include \"MTLFunctionStitching.hpp\"\n#include \"MTLHeaderBridge.hpp\"\n#include \"MTLHeap.hpp\"\n#include \"MTLIndirectCommandBuffer.hpp\"\n#include \"MTLIndirectCommandEncoder.hpp\"\n#include \"MTLIntersectionFunctionTable.hpp\"\n#include \"MTLIOCommandBuffer.hpp\"\n#include \"MTLIOCommandQueue.hpp\"\n#include \"MTLIOCompressor.hpp\"\n#include \"MTLLibrary.hpp\"\n#include \"MTLLinkedFunctions.hpp\"\n#include \"MTLParallelRenderCommandEncoder.hpp\"\n#include \"MTLPipeline.hpp\"\n#include \"MTLPixelFormat.hpp\"\n#include \"MTLPrivate.hpp\"\n#include \"MTLRasterizationRate.hpp\"\n#include \"MTLRenderCommandEncoder.hpp\"\n#include \"MTLRenderPass.hpp\"\n#include \"MTLRenderPipeline.hpp\"\n#include \"MTLResource.hpp\"\n#include \"MTLResourceStateCommandEncoder.hpp\"\n#include \"MTLResourceStatePass.hpp\"\n#include \"MTLSampler.hpp\"\n#include \"MTLStageInputOutputDescriptor.hpp\"\n#include \"MTLTexture.hpp\"\n#include \"MTLTypes.hpp\"\n#include \"MTLVertexDescriptor.hpp\"\n#include \"MTLVisibleFunctionTable.hpp\"\n#include \"MTLVersion.hpp\"\n\n\n\n'Tempest/Engine/gapi/metal/mtpipeline.cpp'\n:#if defined(TEMPEST_BUILD_METAL)\n\n#include \"mtpipeline.h\"\n\n#include \"mtdevice.h\"\n#include \"mtshader.h\"\n#include \"mtfbolayout.h\"\n#include \"mtpipelinelay.h\"\n\nusing namespace Tempest;\nusing namespace Tempest::Detail;\n\nMtPipeline::MtPipeline(MtDevice &d, Topology tp,\n                       const RenderState &rs,\n                       const MtPipelineLay& lay,\n                       const MtShader* const * sh, size_t count)\n  :lay(&lay), device(d), rs(rs) {\n  for(size_t i=0; i<count; ++i)\n    if(sh[i]!=nullptr)\n      modules[i] = Detail::DSharedPtr<const MtShader*>{sh[i]};\n\n  cullMode = nativeFormat(rs.cullFaceMode());\n  topology = nativeFormat(tp);\n\n  auto ddesc = NsPtr<MTL::DepthStencilDescriptor>::init();\n  ddesc->setDepthCompareFunction(nativeFormat(rs.zTestMode()));\n  ddesc->setDepthWriteEnabled(rs.isZWriteEnabled());\n  depthStZ = NsPtr<MTL::DepthStencilState>(d.impl->newDepthStencilState(ddesc.get()));\n\n  ddesc->setDepthCompareFunction(MTL::CompareFunctionAlways);\n  ddesc->setDepthWriteEnabled(false);\n  depthStNoZ = NsPtr<MTL::DepthStencilState>(d.impl->newDepthStencilState(ddesc.get()));\n\n  auto mesh = findShader(ShaderReflection::Mesh);\n  if(mesh!=nullptr) {\n    mkMeshPso(lay);\n    } else {\n    mkVertexPso(lay);\n    }\n\n  for(size_t i=0; i<lay.lay.size(); ++i) {\n    auto& l = lay.lay[i];\n    auto& m = lay.bind[i];\n    if(l.stage==0)\n      continue;\n    if(l.cls!=ShaderReflection::Ubo && l.cls!=ShaderReflection::SsboR && l.cls!=ShaderReflection::SsboRW)\n      continue;\n    MTL::Mutability mu = (l.cls==ShaderReflection::SsboRW) ? MTL::MutabilityMutable: MTL::MutabilityImmutable;\n\n    if(m.bindVs!=uint32_t(-1))\n      pdesc->vertexBuffers()->object(m.bindVs)->setMutability(mu);\n    if(m.bindFs!=uint32_t(-1) && pdesc!=nullptr)\n      pdesc->fragmentBuffers()->object(m.bindFs)->setMutability(mu);\n\n    if(m.bindTs!=uint32_t(-1))\n      mdesc->objectBuffers()->object(m.bindTs)->setMutability(mu);\n    if(m.bindMs!=uint32_t(-1))\n      mdesc->meshBuffers()->object(m.bindMs)->setMutability(mu);\n    if(m.bindFs!=uint32_t(-1) && mdesc!=nullptr)\n      mdesc->fragmentBuffers()->object(m.bindFs)->setMutability(mu);\n    }\n  }\n\nMtPipeline::~MtPipeline() {\n  }\n\nIVec3 MtPipeline::workGroupSize() const {\n  if(localSize.width>0)\n    return IVec3(int(localSize.width), int(localSize.height), int(localSize.depth));\n  return IVec3(int(localSizeMesh.width), int(localSizeMesh.height), int(localSizeMesh.depth));\n  }\n\nMTL::RenderPipelineState& MtPipeline::inst(const MtFboLayout& lay, size_t stride) {\n  std::lock_guard<SpinLock> guard(sync);\n\n  for(auto& i:instance)\n    if(i.stride==stride && i.fbo.equals(lay))\n      return *i.pso.get();\n  instance.emplace_back();\n\n  Inst& ix = instance.back();\n  ix.stride = stride;\n  ix.fbo    = lay;\n\n  MTL::RenderPipelineColorAttachmentDescriptorArray* att = nullptr;\n  if(pdesc!=nullptr)\n    att = pdesc->colorAttachments();\n  if(mdesc!=nullptr)\n    att = mdesc->colorAttachments();\n\n  for(size_t i=0; i<lay.numColors; ++i) {\n    auto clr = att->object(i);\n    clr->setPixelFormat(lay.colorFormat[i]);\n    clr->setBlendingEnabled(rs.hasBlend());\n    clr->setRgbBlendOperation          (nativeFormat(rs.blendOperation()));\n    clr->setAlphaBlendOperation        (nativeFormat(rs.blendOperation()));\n    clr->setDestinationRGBBlendFactor  (nativeFormat(rs.blendDest()));\n    clr->setDestinationAlphaBlendFactor(nativeFormat(rs.blendDest()));\n    clr->setSourceRGBBlendFactor       (nativeFormat(rs.blendSource()));\n    clr->setSourceAlphaBlendFactor     (nativeFormat(rs.blendSource()));\n    }\n\n  if(mdesc!=nullptr) {\n    mdesc->setDepthAttachmentPixelFormat(lay.depthFormat);\n\n    NS::Error* error = nullptr;\n    ix.pso = NsPtr<MTL::RenderPipelineState>(device.impl->newRenderPipelineState(mdesc.get(),MTL::PipelineOptionNone,nullptr,&error));\n    mtAssert(ix.pso.get(),error);\n    } else {\n    vdesc->layouts()->object(vboIndex)->setStride(stride);\n    pdesc->setDepthAttachmentPixelFormat(lay.depthFormat);\n\n    NS::Error* error = nullptr;\n    ix.pso = NsPtr<MTL::RenderPipelineState>(device.impl->newRenderPipelineState(pdesc.get(),&error));\n    mtAssert(ix.pso.get(),error);\n    }\n\n  return *ix.pso.get();\n  }\n\nconst MtShader* MtPipeline::findShader(ShaderReflection::Stage sh) const {\n  for(auto& i:modules)\n    if(i.handler!=nullptr && i.handler->stage==sh)\n      return i.handler;\n  return nullptr;\n  }\n\nvoid MtPipeline::mkVertexPso(const MtPipelineLay& lay) {\n  auto vert = findShader(ShaderReflection::Vertex);\n  auto tesc = findShader(ShaderReflection::Control);\n  auto tese = findShader(ShaderReflection::Evaluate);\n  auto frag = findShader(ShaderReflection::Fragment);\n\n  size_t offset = 0;\n  vboIndex = lay.vboIndex;\n  vdesc = NsPtr<MTL::VertexDescriptor>::init();\n  vdesc->retain();\n  for(size_t i=0; i<vert->vdecl.size(); ++i) {\n    const auto& v = vert->vdecl[i];\n    vdesc->attributes()->object(i)->setBufferIndex(vboIndex);\n    vdesc->attributes()->object(i)->setOffset(offset);\n    vdesc->attributes()->object(i)->setFormat(nativeFormat(v));\n    offset += Decl::size(v);\n    }\n  defaultStride = offset;\n\n  vdesc->layouts()->object(vboIndex)->setStride(defaultStride);\n  vdesc->layouts()->object(vboIndex)->setStepRate(1);\n  vdesc->layouts()->object(vboIndex)->setStepFunction(MTL::VertexStepFunctionPerVertex);\n\n  pdesc = NsPtr<MTL::RenderPipelineDescriptor>::init();\n  pdesc->retain();\n  pdesc->setSampleCount(1);\n  pdesc->setVertexFunction(vert->impl.get());\n  pdesc->setFragmentFunction(frag->impl.get());\n  pdesc->setRasterizationEnabled(!rs.isRasterDiscardEnabled());\n\n  if(tesc!=nullptr && tese!=nullptr) {\n    pdesc->setMaxTessellationFactor(16);\n    pdesc->setTessellationFactorScaleEnabled(false);\n    pdesc->setTessellationFactorStepFunction(MTL::TessellationFactorStepFunctionConstant);\n    pdesc->setTessellationOutputWindingOrder(tese->tese.winding);\n    pdesc->setTessellationPartitionMode(tese->tese.partition);\n    pdesc->setVertexFunction(tese->impl.get());\n\n    vdesc->layouts()->object(lay.vboIndex)->setStepFunction(MTL::VertexStepFunctionPerPatch);\n    pdesc->setVertexDescriptor(vdesc.get());\n    isTesselation = true;\n    } else {\n    pdesc->setVertexDescriptor(vdesc.get());\n    }\n  }\n\nvoid MtPipeline::mkMeshPso(const MtPipelineLay& lay) {\n  auto task = findShader(ShaderReflection::Task);\n  auto mesh = findShader(ShaderReflection::Mesh);\n  auto frag = findShader(ShaderReflection::Fragment);\n\n  if(task!=nullptr) {\n    localSize     = task->comp.localSize;\n    localSizeMesh = mesh->comp.localSize;\n    } else {\n    localSize     = MTL::Size(0,0,0);\n    localSizeMesh = mesh->comp.localSize;\n    }\n\n  mdesc = NsPtr<MTL::MeshRenderPipelineDescriptor>::init();\n  mdesc->retain();\n\n  mdesc->setObjectFunction((task!=nullptr) ? task->impl.get() : nullptr);\n  mdesc->setMeshFunction(mesh->impl.get());\n  mdesc->setFragmentFunction(frag->impl.get());\n  mdesc->setRasterizationEnabled(!rs.isRasterDiscardEnabled());\n\n  if(mesh!=nullptr) {\n    mdesc->setMaxTotalThreadsPerMeshThreadgroup(localSizeMesh.width*localSizeMesh.height*localSizeMesh.depth);\n\n    }\n\n  if(task!=nullptr) {\n    mdesc->setMaxTotalThreadsPerObjectThreadgroup(localSize.width*localSize.height*localSize.depth);\n\n    }\n  }\n\n\nMtCompPipeline::MtCompPipeline(MtDevice &device, const MtPipelineLay& lay, const MtShader &sh)\n  :lay(&lay) {\n  localSize = sh.comp.localSize;\n  auto desc = NsPtr<MTL::ComputePipelineDescriptor>::init();\n  desc->setComputeFunction(sh.impl.get());\n  desc->setThreadGroupSizeIsMultipleOfThreadExecutionWidth(false);\n  desc->setMaxTotalThreadsPerThreadgroup(localSize.width*localSize.height*localSize.depth);\n\n  for(size_t i=0; i<lay.lay.size(); ++i) {\n    auto& l = lay.lay[i];\n    auto& m = lay.bind[i];\n    if(l.stage==0)\n      continue;\n    if(l.cls!=ShaderReflection::Ubo && l.cls!=ShaderReflection::SsboR && l.cls!=ShaderReflection::SsboRW)\n      continue;\n    MTL::Mutability mu = (l.cls==ShaderReflection::SsboRW) ? MTL::MutabilityMutable: MTL::MutabilityImmutable;\n    if(m.bindCs!=uint32_t(-1))\n      desc->buffers()->object(m.bindCs)->setMutability(mu);\n    }\n\n  NS::Error* error = nullptr;\n  impl = NsPtr<MTL::ComputePipelineState>(device.impl->newComputePipelineState(desc.get(), MTL::PipelineOptionNone, nullptr, &error));\n  mtAssert(impl.get(),error);\n  }\n\nIVec3 MtCompPipeline::workGroupSize() const {\n  return IVec3{int(localSize.width),int(localSize.height),int(localSize.depth)};\n  }\n\n#endif\n\n'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLAccelerationStructureTypes.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n\n\n#include \"MTLDefines.hpp\"\n#include \"MTLPrivate.hpp\"\n#include \"MTLResource.hpp\"\n#include \"MTLStageInputOutputDescriptor.hpp\"\n\n#include \"../Foundation/NSRange.hpp\"\n\n\n\nnamespace MTL\n{\nstruct PackedFloat3\n{\n    PackedFloat3();\n    PackedFloat3(float x, float y, float z);\n\n    float& operator[](int idx);\n    float  operator[](int idx) const;\n\n    union\n    {\n        struct\n        {\n            float x;\n            float y;\n            float z;\n        };\n\n        float elements[3];\n    };\n} _MTL_PACKED;\n\nstruct PackedFloat4x3\n{\n    PackedFloat4x3();\n    PackedFloat4x3(const PackedFloat3& col0, const PackedFloat3& col1, const PackedFloat3& col2, const PackedFloat3& col3);\n\n    PackedFloat3&       operator[](int idx);\n    const PackedFloat3& operator[](int idx) const;\n\n    PackedFloat3        columns[4];\n} _MTL_PACKED;\n\nstruct AxisAlignedBoundingBox\n{\n    AxisAlignedBoundingBox();\n    AxisAlignedBoundingBox(PackedFloat3 p);\n    AxisAlignedBoundingBox(PackedFloat3 min, PackedFloat3 max);\n\n    PackedFloat3 min;\n    PackedFloat3 max;\n} _MTL_PACKED;\n}\n\n\n\n_MTL_INLINE MTL::PackedFloat3::PackedFloat3()\n    : x(0.0f)\n    , y(0.0f)\n    , z(0.0f)\n{\n}\n\n\n\n_MTL_INLINE MTL::PackedFloat3::PackedFloat3(float _x, float _y, float _z)\n    : x(_x)\n    , y(_y)\n    , z(_z)\n{\n}\n\n\n\n_MTL_INLINE float& MTL::PackedFloat3::operator[](int idx)\n{\n    return elements[idx];\n}\n\n\n\n_MTL_INLINE float MTL::PackedFloat3::operator[](int idx) const\n{\n    return elements[idx];\n}\n\n\n\n_MTL_INLINE MTL::PackedFloat4x3::PackedFloat4x3()\n{\n    columns[0] = PackedFloat3(0.0f, 0.0f, 0.0f);\n    columns[1] = PackedFloat3(0.0f, 0.0f, 0.0f);\n    columns[2] = PackedFloat3(0.0f, 0.0f, 0.0f);\n    columns[3] = PackedFloat3(0.0f, 0.0f, 0.0f);\n}\n\n\n\n_MTL_INLINE MTL::PackedFloat4x3::PackedFloat4x3(const PackedFloat3& col0, const PackedFloat3& col1, const PackedFloat3& col2, const PackedFloat3& col3)\n{\n    columns[0] = col0;\n    columns[1] = col1;\n    columns[2] = col2;\n    columns[3] = col3;\n}\n\n\n\n_MTL_INLINE MTL::PackedFloat3& MTL::PackedFloat4x3::operator[](int idx)\n{\n    return columns[idx];\n}\n\n\n\n_MTL_INLINE const MTL::PackedFloat3& MTL::PackedFloat4x3::operator[](int idx) const\n{\n    return columns[idx];\n}\n\n\n\n_MTL_INLINE MTL::AxisAlignedBoundingBox::AxisAlignedBoundingBox()\n    : min(INFINITY, INFINITY, INFINITY)\n    , max(-INFINITY, -INFINITY, -INFINITY)\n{\n}\n\n\n\n_MTL_INLINE MTL::AxisAlignedBoundingBox::AxisAlignedBoundingBox(PackedFloat3 p)\n    : min(p)\n    , max(p)\n{\n}\n\n\n\n_MTL_INLINE MTL::AxisAlignedBoundingBox::AxisAlignedBoundingBox(PackedFloat3 _min, PackedFloat3 _max)\n    : min(_min)\n    , max(_max)\n{\n}\n\n\n",
        "gt": [
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLAccelerationStructureTypes.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'",
            "'Tempest/Engine/gapi/metal/mtdevice.h'",
            "'Tempest/Engine/gapi/metal/mtpipeline.cpp'"
        ]
    },
    {
        "files": [
            "'Tempest/Engine/thirdparty/metal-cpp/Foundation/Foundation.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Foundation/NSProcessInfo.hpp'",
            "'Tempest/Engine/gapi/metal/mtsamplercache.cpp'",
            "'Tempest/Engine/gapi/metal/mtsamplercache.h'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLIOCompressor.hpp'"
        ],
        "content": "'Tempest/Engine/thirdparty/metal-cpp/Foundation/Foundation.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n\n\n#include \"NSArray.hpp\"\n#include \"NSAutoreleasePool.hpp\"\n#include \"NSBundle.hpp\"\n#include \"NSData.hpp\"\n#include \"NSDate.hpp\"\n#include \"NSDefines.hpp\"\n#include \"NSDictionary.hpp\"\n#include \"NSEnumerator.hpp\"\n#include \"NSError.hpp\"\n#include \"NSLock.hpp\"\n#include \"NSNotification.hpp\"\n#include \"NSNumber.hpp\"\n#include \"NSObject.hpp\"\n#include \"NSPrivate.hpp\"\n#include \"NSProcessInfo.hpp\"\n#include \"NSRange.hpp\"\n#include \"NSSet.hpp\"\n#include \"NSSharedPtr.hpp\"\n#include \"NSString.hpp\"\n#include \"NSTypes.hpp\"\n#include \"NSURL.hpp\"\n\n\n\n'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n\n\n#include \"MTLAccelerationStructure.hpp\"\n#include \"MTLAccelerationStructureCommandEncoder.hpp\"\n#include \"MTLAccelerationStructureTypes.hpp\"\n#include \"MTLArgument.hpp\"\n#include \"MTLArgumentEncoder.hpp\"\n#include \"MTLBinaryArchive.hpp\"\n#include \"MTLBlitCommandEncoder.hpp\"\n#include \"MTLBlitPass.hpp\"\n#include \"MTLBuffer.hpp\"\n#include \"MTLCaptureManager.hpp\"\n#include \"MTLCaptureScope.hpp\"\n#include \"MTLCommandBuffer.hpp\"\n#include \"MTLCommandEncoder.hpp\"\n#include \"MTLCommandQueue.hpp\"\n#include \"MTLComputeCommandEncoder.hpp\"\n#include \"MTLComputePass.hpp\"\n#include \"MTLComputePipeline.hpp\"\n#include \"MTLCounters.hpp\"\n#include \"MTLDefines.hpp\"\n#include \"MTLDepthStencil.hpp\"\n#include \"MTLDevice.hpp\"\n#include \"MTLDrawable.hpp\"\n#include \"MTLDynamicLibrary.hpp\"\n#include \"MTLEvent.hpp\"\n#include \"MTLFence.hpp\"\n#include \"MTLFunctionConstantValues.hpp\"\n#include \"MTLFunctionDescriptor.hpp\"\n#include \"MTLFunctionHandle.hpp\"\n#include \"MTLFunctionLog.hpp\"\n#include \"MTLFunctionStitching.hpp\"\n#include \"MTLHeaderBridge.hpp\"\n#include \"MTLHeap.hpp\"\n#include \"MTLIndirectCommandBuffer.hpp\"\n#include \"MTLIndirectCommandEncoder.hpp\"\n#include \"MTLIntersectionFunctionTable.hpp\"\n#include \"MTLIOCommandBuffer.hpp\"\n#include \"MTLIOCommandQueue.hpp\"\n#include \"MTLIOCompressor.hpp\"\n#include \"MTLLibrary.hpp\"\n#include \"MTLLinkedFunctions.hpp\"\n#include \"MTLParallelRenderCommandEncoder.hpp\"\n#include \"MTLPipeline.hpp\"\n#include \"MTLPixelFormat.hpp\"\n#include \"MTLPrivate.hpp\"\n#include \"MTLRasterizationRate.hpp\"\n#include \"MTLRenderCommandEncoder.hpp\"\n#include \"MTLRenderPass.hpp\"\n#include \"MTLRenderPipeline.hpp\"\n#include \"MTLResource.hpp\"\n#include \"MTLResourceStateCommandEncoder.hpp\"\n#include \"MTLResourceStatePass.hpp\"\n#include \"MTLSampler.hpp\"\n#include \"MTLStageInputOutputDescriptor.hpp\"\n#include \"MTLTexture.hpp\"\n#include \"MTLTypes.hpp\"\n#include \"MTLVertexDescriptor.hpp\"\n#include \"MTLVisibleFunctionTable.hpp\"\n#include \"MTLVersion.hpp\"\n\n\n\n'Tempest/Engine/thirdparty/metal-cpp/Foundation/NSProcessInfo.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n\n\n#include \"NSDefines.hpp\"\n#include \"NSNotification.hpp\"\n#include \"NSObject.hpp\"\n#include \"NSPrivate.hpp\"\n#include \"NSTypes.hpp\"\n\n#include <functional>\n\n\n\nnamespace NS\n{\n_NS_CONST(NotificationName, ProcessInfoThermalStateDidChangeNotification);\n_NS_CONST(NotificationName, ProcessInfoPowerStateDidChangeNotification);\n\n_NS_ENUM(NS::Integer, ProcessInfoThermalState) {\n    ProcessInfoThermalStateNominal = 0,\n    ProcessInfoThermalStateFair = 1,\n    ProcessInfoThermalStateSerious = 2,\n    ProcessInfoThermalStateCritical = 3\n};\n\n_NS_OPTIONS(std::uint64_t, ActivityOptions) {\n    ActivityIdleDisplaySleepDisabled = (1ULL << 40),\n    ActivityIdleSystemSleepDisabled = (1ULL << 20),\n    ActivitySuddenTerminationDisabled = (1ULL << 14),\n    ActivityAutomaticTerminationDisabled = (1ULL << 15),\n    ActivityUserInitiated = (0x00FFFFFFULL | ActivityIdleSystemSleepDisabled),\n    ActivityUserInitiatedAllowingIdleSystemSleep = (ActivityUserInitiated & ~ActivityIdleSystemSleepDisabled),\n    ActivityBackground = 0x000000FFULL,\n    ActivityLatencyCritical = 0xFF00000000ULL,\n};\n\nclass ProcessInfo : public Referencing<ProcessInfo>\n{\npublic:\n    static ProcessInfo*     processInfo();\n\n    class Array*            arguments() const;\n    class Dictionary*       environment() const;\n    class String*           hostName() const;\n    class String*           processName() const;\n    void                    setProcessName(const String* pString);\n    int                     processIdentifier() const;\n    class String*           globallyUniqueString() const;\n\n    class String*           userName() const;\n    class String*           fullUserName() const;\n\n    UInteger                operatingSystem() const;\n    OperatingSystemVersion  operatingSystemVersion() const;\n    class String*           operatingSystemVersionString() const;\n    bool                    isOperatingSystemAtLeastVersion(OperatingSystemVersion version) const;\n\n    UInteger                processorCount() const;\n    UInteger                activeProcessorCount() const;\n    unsigned long long      physicalMemory() const;\n    TimeInterval            systemUptime() const;\n\n    void                    disableSuddenTermination();\n    void                    enableSuddenTermination();\n\n    void                    disableAutomaticTermination(const class String* pReason);\n    void                    enableAutomaticTermination(const class String* pReason);\n    bool                    automaticTerminationSupportEnabled() const;\n    void                    setAutomaticTerminationSupportEnabled(bool enabled);\n\n    class Object*           beginActivity(ActivityOptions options, const class String* pReason);\n    void                    endActivity(class Object* pActivity);\n    void                    performActivity(ActivityOptions options, const class String* pReason, void (^block)(void));\n    void                    performActivity(ActivityOptions options, const class String* pReason, const std::function<void()>& func);\n    void                    performExpiringActivity(const class String* pReason, void (^block)(bool expired));\n    void                    performExpiringActivity(const class String* pReason, const std::function<void(bool expired)>& func);\n\n    ProcessInfoThermalState thermalState() const;\n    bool                    isLowPowerModeEnabled() const;\n\n    bool                    isiOSAppOnMac() const;\n    bool                    isMacCatalystApp() const;\n};\n}\n\n\n\n_NS_PRIVATE_DEF_CONST(NS::NotificationName, ProcessInfoThermalStateDidChangeNotification);\n_NS_PRIVATE_DEF_CONST(NS::NotificationName, ProcessInfoPowerStateDidChangeNotification);\n\n\n\n_NS_INLINE NS::ProcessInfo* NS::ProcessInfo::processInfo()\n{\n    return Object::sendMessage<ProcessInfo*>(_NS_PRIVATE_CLS(NSProcessInfo), _NS_PRIVATE_SEL(processInfo));\n}\n\n\n\n_NS_INLINE NS::Array* NS::ProcessInfo::arguments() const\n{\n    return Object::sendMessage<Array*>(this, _NS_PRIVATE_SEL(arguments));\n}\n\n\n\n_NS_INLINE NS::Dictionary* NS::ProcessInfo::environment() const\n{\n    return Object::sendMessage<Dictionary*>(this, _NS_PRIVATE_SEL(environment));\n}\n\n\n\n_NS_INLINE NS::String* NS::ProcessInfo::hostName() const\n{\n    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(hostName));\n}\n\n\n\n_NS_INLINE NS::String* NS::ProcessInfo::processName() const\n{\n    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(processName));\n}\n\n\n\n_NS_INLINE void NS::ProcessInfo::setProcessName(const String* pString)\n{\n    Object::sendMessage<void>(this, _NS_PRIVATE_SEL(setProcessName_), pString);\n}\n\n\n\n_NS_INLINE int NS::ProcessInfo::processIdentifier() const\n{\n    return Object::sendMessage<int>(this, _NS_PRIVATE_SEL(processIdentifier));\n}\n\n\n\n_NS_INLINE NS::String* NS::ProcessInfo::globallyUniqueString() const\n{\n    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(globallyUniqueString));\n}\n\n\n\n_NS_INLINE NS::String* NS::ProcessInfo::userName() const\n{\n    return Object::sendMessageSafe<String*>(this, _NS_PRIVATE_SEL(userName));\n}\n\n\n\n_NS_INLINE NS::String* NS::ProcessInfo::fullUserName() const\n{\n    return Object::sendMessageSafe<String*>(this, _NS_PRIVATE_SEL(fullUserName));\n}\n\n\n\n_NS_INLINE NS::UInteger NS::ProcessInfo::operatingSystem() const\n{\n    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(operatingSystem));\n}\n\n\n\n_NS_INLINE NS::OperatingSystemVersion NS::ProcessInfo::operatingSystemVersion() const\n{\n    return Object::sendMessage<OperatingSystemVersion>(this, _NS_PRIVATE_SEL(operatingSystemVersion));\n}\n\n\n\n_NS_INLINE NS::String* NS::ProcessInfo::operatingSystemVersionString() const\n{\n    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(operatingSystemVersionString));\n}\n\n\n\n_NS_INLINE bool NS::ProcessInfo::isOperatingSystemAtLeastVersion(OperatingSystemVersion version) const\n{\n    return Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(isOperatingSystemAtLeastVersion_), version);\n}\n\n\n\n_NS_INLINE NS::UInteger NS::ProcessInfo::processorCount() const\n{\n    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(processorCount));\n}\n\n\n\n_NS_INLINE NS::UInteger NS::ProcessInfo::activeProcessorCount() const\n{\n    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(activeProcessorCount));\n}\n\n\n\n_NS_INLINE unsigned long long NS::ProcessInfo::physicalMemory() const\n{\n    return Object::sendMessage<unsigned long long>(this, _NS_PRIVATE_SEL(physicalMemory));\n}\n\n\n\n_NS_INLINE NS::TimeInterval NS::ProcessInfo::systemUptime() const\n{\n    return Object::sendMessage<TimeInterval>(this, _NS_PRIVATE_SEL(systemUptime));\n}\n\n\n\n_NS_INLINE void NS::ProcessInfo::disableSuddenTermination()\n{\n    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(disableSuddenTermination));\n}\n\n\n\n_NS_INLINE void NS::ProcessInfo::enableSuddenTermination()\n{\n    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(enableSuddenTermination));\n}\n\n\n\n_NS_INLINE void NS::ProcessInfo::disableAutomaticTermination(const String* pReason)\n{\n    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(disableAutomaticTermination_), pReason);\n}\n\n\n\n_NS_INLINE void NS::ProcessInfo::enableAutomaticTermination(const String* pReason)\n{\n    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(enableAutomaticTermination_), pReason);\n}\n\n\n\n_NS_INLINE bool NS::ProcessInfo::automaticTerminationSupportEnabled() const\n{\n    return Object::sendMessageSafe<bool>(this, _NS_PRIVATE_SEL(automaticTerminationSupportEnabled));\n}\n\n\n\n_NS_INLINE void NS::ProcessInfo::setAutomaticTerminationSupportEnabled(bool enabled)\n{\n    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(setAutomaticTerminationSupportEnabled_), enabled);\n}\n\n\n\n_NS_INLINE NS::Object* NS::ProcessInfo::beginActivity(ActivityOptions options, const String* pReason)\n{\n    return Object::sendMessage<Object*>(this, _NS_PRIVATE_SEL(beginActivityWithOptions_reason_), options, pReason);\n}\n\n\n\n_NS_INLINE void NS::ProcessInfo::endActivity(Object* pActivity)\n{\n    Object::sendMessage<void>(this, _NS_PRIVATE_SEL(endActivity_), pActivity);\n}\n\n\n\n_NS_INLINE void NS::ProcessInfo::performActivity(ActivityOptions options, const String* pReason, void (^block)(void))\n{\n    Object::sendMessage<void>(this, _NS_PRIVATE_SEL(performActivityWithOptions_reason_usingBlock_), options, pReason, block);\n}\n\n\n\n_NS_INLINE void NS::ProcessInfo::performActivity(ActivityOptions options, const String* pReason, const std::function<void()>& function)\n{\n    __block std::function<void()> blockFunction = function;\n\n    performActivity(options, pReason, ^() { blockFunction(); });\n}\n\n\n\n_NS_INLINE void NS::ProcessInfo::performExpiringActivity(const String* pReason, void (^block)(bool expired))\n{\n    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(performExpiringActivityWithReason_usingBlock_), pReason, block);\n}\n\n\n\n_NS_INLINE void NS::ProcessInfo::performExpiringActivity(const String* pReason, const std::function<void(bool expired)>& function)\n{\n    __block std::function<void(bool expired)> blockFunction = function;\n\n    performExpiringActivity(pReason, ^(bool expired) { blockFunction(expired); });\n}\n\n\n\n_NS_INLINE NS::ProcessInfoThermalState NS::ProcessInfo::thermalState() const\n{\n    return Object::sendMessage<ProcessInfoThermalState>(this, _NS_PRIVATE_SEL(thermalState));\n}\n\n\n\n_NS_INLINE bool NS::ProcessInfo::isLowPowerModeEnabled() const\n{\n    return Object::sendMessageSafe<bool>(this, _NS_PRIVATE_SEL(isLowPowerModeEnabled));\n}\n\n\n\n_NS_INLINE bool NS::ProcessInfo::isiOSAppOnMac() const\n{\n    return Object::sendMessageSafe<bool>(this, _NS_PRIVATE_SEL(isiOSAppOnMac));\n}\n\n\n\n_NS_INLINE bool NS::ProcessInfo::isMacCatalystApp() const\n{\n    return Object::sendMessageSafe<bool>(this, _NS_PRIVATE_SEL(isMacCatalystApp));\n}\n\n\n\n'Tempest/Engine/gapi/metal/mtsamplercache.cpp'\n:#if defined(TEMPEST_BUILD_METAL)\n\n#include \"mtsamplercache.h\"\n\n#include \"mtdevice.h\"\n\nusing namespace Tempest;\nusing namespace Tempest::Detail;\n\nnamespace Tempest {\nnamespace Detail  {\n\nstatic MTL::SamplerAddressMode nativeFormat(ClampMode m) {\n  switch(m) {\n    case ClampMode::ClampToBorder:  return MTL::SamplerAddressModeClampToBorderColor;\n    case ClampMode::ClampToEdge:    return MTL::SamplerAddressModeClampToEdge;\n    case ClampMode::MirroredRepeat: return MTL::SamplerAddressModeMirrorRepeat;\n    case ClampMode::Repeat:         return MTL::SamplerAddressModeRepeat;\n    case ClampMode::Count:          return MTL::SamplerAddressModeRepeat;\n    }\n  return MTL::SamplerAddressModeRepeat;\n  }\n\nstatic MTL::SamplerMinMagFilter nativeFormat(Tempest::Filter f) {\n  switch(f) {\n    case Filter::Nearest: return MTL::SamplerMinMagFilterNearest;\n    case Filter::Linear:  return MTL::SamplerMinMagFilterLinear;\n    case Filter::Count:   return MTL::SamplerMinMagFilterLinear;\n    }\n  return MTL::SamplerMinMagFilterLinear;\n  }\n}\n}\n\nMtSamplerCache::MtSamplerCache(MTL::Device& dev)\n  :dev(dev) {\n  def = mkSampler(Sampler(),false);\n  if(def==nullptr)\n    throw std::system_error(Tempest::GraphicsErrc::NoDevice);\n  }\n\nMtSamplerCache::~MtSamplerCache() {\n  }\n\nMTL::SamplerState& MtSamplerCache::get(Tempest::Sampler src, bool argBuffers) {\n  src.mapping = ComponentMapping();\n  static const Tempest::Sampler defSrc;\n  if(src==defSrc)\n    return *def;\n\n  std::lock_guard<std::mutex> guard(sync);\n  for(auto& i:values)\n    if(i.src==src && i.argBuffers==argBuffers)\n      return *i.val;\n  values.emplace_back(Entry());\n  auto& b = values.back();\n  b.src        = src;\n  b.argBuffers = argBuffers;\n  b.val        = mkSampler(src,argBuffers);\n  if(b.val==nullptr)\n    throw std::system_error(Tempest::GraphicsErrc::OutOfHostMemory);\n  return *b.val;\n  }\n\nNsPtr<MTL::SamplerState> MtSamplerCache::mkSampler(const Tempest::Sampler& src, bool argBuffers) {\n  auto desc = NsPtr<MTL::SamplerDescriptor>::init();\n  desc->setRAddressMode(nativeFormat(src.uClamp));\n  desc->setSAddressMode(nativeFormat(src.vClamp));\n  desc->setTAddressMode(nativeFormat(src.wClamp));\n\n  desc->setMinFilter(nativeFormat(src.minFilter));\n  desc->setMagFilter(nativeFormat(src.magFilter));\n  if(src.mipFilter==Filter::Nearest)\n    desc->setMipFilter(MTL::SamplerMipFilterNearest); else\n    desc->setMipFilter(MTL::SamplerMipFilterLinear);\n  desc->setMaxAnisotropy(src.anisotropic ? 16 : 1);\n  desc->setBorderColor(MTL::SamplerBorderColorOpaqueWhite);\n  desc->setLodAverage(false);\n  desc->setSupportArgumentBuffers(argBuffers);\n\n  return NsPtr<MTL::SamplerState>(dev.newSamplerState(desc.get()));\n  }\n\n#endif\n\n'Tempest/Engine/gapi/metal/mtsamplercache.h'\n:#pragma once\n\n#include <Tempest/AbstractGraphicsApi>\n#include <Metal/Metal.hpp>\n#include <mutex>\n\n#include \"nsptr.h\"\n\nnamespace Tempest {\nnamespace Detail {\n\nclass MtDevice;\n\nclass MtSamplerCache {\n  public:\n    MtSamplerCache(MTL::Device& dev);\n    ~MtSamplerCache();\n\n    MTL::SamplerState& get(Sampler src, bool argBuffers=false);\n\n  private:\n    NsPtr<MTL::SamplerState> mkSampler(const Sampler& src, bool argBuffers);\n\n    struct Entry {\n      Sampler                  src;\n      bool                     argBuffers = false;\n      NsPtr<MTL::SamplerState> val;\n      };\n\n    MTL::Device&             dev;\n    NsPtr<MTL::SamplerState> def;\n\n    std::mutex               sync;\n    std::vector<Entry>       values;\n  };\n\n}\n}\n\n'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLIOCompressor.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n#include \"MTLDefines.hpp\"\n#include \"MTLHeaderBridge.hpp\"\n#include \"MTLPrivate.hpp\"\n#include \"MTLDevice.hpp\"\n\n#include <Foundation/Foundation.hpp>\n\nnamespace MTL\n{\nusing IOCompresionContext=void*;\n\n_MTL_ENUM(NS::Integer, IOCompressionStatus) {\n    IOCompressionStatusComplete = 0,\n    IOCompressionStatusError = 1,\n};\n\nsize_t IOCompressionContextDefaultChunkSize();\n\nIOCompresionContext IOCreateCompressionContext(const char* path, IOCompressionMethod type, size_t chunkSize);\n\nvoid IOCompressionContextAppendData(IOCompresionContext context, const void* data, size_t size);\n\nIOCompressionStatus IOFlushAndDestroyCompressionContext(IOCompresionContext context);\n\n}\n\n#if defined(MTL_PRIVATE_IMPLEMENTATION)\n\nnamespace MTL::Private {\n\nMTL_DEF_FUNC(MTLIOCompressionContextDefaultChunkSize, size_t (*)(void));\n\nMTL_DEF_FUNC( MTLIOCreateCompressionContext, void* (*)(const char*, MTL::IOCompressionMethod, size_t) );\n\nMTL_DEF_FUNC( MTLIOCompressionContextAppendData, void (*)(void*, const void*, size_t) );\n\nMTL_DEF_FUNC( MTLIOFlushAndDestroyCompressionContext, MTL::IOCompressionStatus (*)(void*) );\n\n}\n\n_NS_EXPORT size_t MTL::IOCompressionContextDefaultChunkSize()\n{\n    return MTL::Private::MTLIOCompressionContextDefaultChunkSize();\n}\n\n_NS_EXPORT void* MTL::IOCreateCompressionContext(const char* path, IOCompressionMethod type, size_t chunkSize)\n{\n    if ( MTL::Private::MTLIOCreateCompressionContext )\n    {\n        return MTL::Private::MTLIOCreateCompressionContext( path, type, chunkSize );\n    }\n    return nullptr;\n}\n\n_NS_EXPORT void MTL::IOCompressionContextAppendData(void* context, const void* data, size_t size)\n{\n    if ( MTL::Private::MTLIOCompressionContextAppendData )\n    {\n        MTL::Private::MTLIOCompressionContextAppendData( context, data, size );\n    }\n}\n\n_NS_EXPORT MTL::IOCompressionStatus MTL::IOFlushAndDestroyCompressionContext(void* context)\n{\n    if ( MTL::Private::MTLIOFlushAndDestroyCompressionContext )\n    {\n        return MTL::Private::MTLIOFlushAndDestroyCompressionContext( context );\n    }\n    return MTL::IOCompressionStatusError;\n}\n\n#endif\n",
        "gt": [
            "'Tempest/Engine/thirdparty/metal-cpp/Foundation/NSProcessInfo.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Foundation/Foundation.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLIOCompressor.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'",
            "'Tempest/Engine/gapi/metal/mtsamplercache.h'",
            "'Tempest/Engine/gapi/metal/mtsamplercache.cpp'"
        ]
    },
    {
        "files": [
            "'obproxy/deps/easy/src/io/easy_summary.h'",
            "'obproxy/deps/easy/src/io/easy_io.h'",
            "'obproxy/deps/easy/src/packet/http/easy_http_handler.h'"
        ],
        "content": "'obproxy/deps/easy/src/io/easy_summary.h'\n:#ifndef  EASY_SUMMARY_H\n#define  EASY_SUMMARY_H\n\n#include <easy_define.h>\n\n#include \"easy_io_struct.h\"\n#include \"easy_log.h\"\n\nEASY_CPP_START\n\n\nextern easy_summary_t          *easy_summary_create();\nextern void                     easy_summary_destroy(easy_summary_t *sum);\nextern easy_summary_node_t     *easy_summary_locate_node(int fd, easy_summary_t *sum, int hidden);\nextern void                     easy_summary_destroy_node(int fd, easy_summary_t *sum);\nextern void                     easy_summary_copy(easy_summary_t *src, easy_summary_t *dest);\nextern easy_summary_t          *easy_summary_diff(easy_summary_t *ns, easy_summary_t *os);\nextern void                     easy_summary_html_output(easy_pool_t *pool,\n        easy_list_t *bc, easy_summary_t *sum, easy_summary_t *last);\nextern void                     easy_summary_raw_output(easy_pool_t *pool,\n        easy_list_t *bc, easy_summary_t *sum, const char *desc);\n\n\n\nEASY_CPP_END\n\n#endif\n\n'obproxy/deps/easy/src/io/easy_io.h'\n:#ifndef EASY_IO_H_\n#define EASY_IO_H_\n\n#include <easy_define.h>\n\n#include <unistd.h>\n#include <pthread.h>\n#include \"easy_io_struct.h\"\n#include \"easy_log.h\"\n#include \"easy_summary.h\"\n\nEASY_CPP_START\n\n\n\nextern easy_io_t           *easy_eio_create(easy_io_t *eio, int io_thread_count);\nextern int                  easy_eio_start(easy_io_t *eio);\nextern int                  easy_eio_wait(easy_io_t *eio);\nextern int                  easy_eio_stop(easy_io_t *eio);\nextern int                  easy_eio_shutdown(easy_io_t *eio);\nextern void                 easy_eio_destroy(easy_io_t *eio);\nextern void                 easy_eio_set_keepalive(easy_io_t *eio, int keepalive_enabled);\n\nextern void                 easy_eio_set_uthread_start(easy_io_t *eio, easy_io_uthread_start_pt *on_utstart, void *args);\nextern struct ev_loop      *easy_eio_thread_loop(easy_io_t *eio, int index);\nextern void                 easy_eio_stat_watcher_start(easy_io_t *eio, ev_timer *stat_watcher,\n        double interval, easy_io_stat_t *iostat, easy_io_stat_process_pt *process);\n\n\n\nextern easy_listen_t       *easy_connection_add_listen(easy_io_t *eio, const char *host, int port, easy_io_handler_pt *handler);\nextern easy_connection_t   *easy_connection_connect_thread(easy_io_t *eio, easy_addr_t addr,\n        easy_io_handler_pt *handler, int conn_timeout, void *args, int flags);\nextern int                  easy_connection_connect(easy_io_t *eio, easy_addr_t addr,\n        easy_io_handler_pt *handler, int conn_timeout, void *args, int flags);\nextern int                  easy_connection_disconnect(easy_io_t *eio, easy_addr_t addr);\nextern int                  easy_connection_disconnect_thread(easy_io_t *eio, easy_addr_t addr);\nextern int                  easy_connection_send_session(easy_connection_t *c, easy_session_t *s);\nextern int                  easy_connection_send_session_data(easy_connection_t *c, easy_session_t *s);\nextern char                 *easy_connection_str(easy_connection_t *c);\nextern int                  easy_connection_dispatch_to_thread(easy_connection_t *c, easy_io_thread_t *ioth);\n\nextern easy_session_t       *easy_connection_connect_init(easy_session_t *s, easy_io_handler_pt *handler,\n        int conn_timeout, void *args, int flags, char *servername);\nextern easy_connection_t    *easy_connection_connect_thread_ex(easy_addr_t addr, easy_session_t *s);\nextern int                  easy_connection_connect_ex(easy_io_t *eio, easy_addr_t addr, easy_session_t *s);\nextern int                  easy_connection_destroy_dispatch(easy_connection_t *c);\nextern easy_listen_t        *easy_add_listen(easy_io_t *eio, const char *host, int port,\n        easy_io_handler_pt *handler, void *args);\nextern easy_listen_t        *easy_add_listen_addr(easy_io_t *eio, easy_addr_t addr,\n        easy_io_handler_pt *handler, int udp, void *args);\nextern int                  easy_connection_write_buffer(easy_connection_t *c, const char *data, int len);\nextern int                  easy_connection_pause(easy_connection_t *c, int ms);\n\n\nextern easy_session_t      *easy_session_create(int64_t size);\nextern void                 easy_session_destroy(void *s);\n\n\nextern int                  easy_client_uthread_wait_conn(easy_connection_t *c);\nextern int                  easy_client_uthread_wait_session(easy_session_t *s);\nextern void                 easy_client_uthread_set_handler(easy_io_handler_pt *handler);\n\n\nextern void                 easy_client_wait_init(easy_client_wait_t *w);\nextern void                 easy_client_wait(easy_client_wait_t *w, int count);\nextern void                 easy_client_wait_cleanup(easy_client_wait_t *w);\nextern void                 easy_client_wait_wakeup(easy_client_wait_t *w);\nextern void                 easy_client_wait_wakeup_request(easy_request_t *r);\nextern int                  easy_client_wait_process(easy_request_t *r);\n\nextern int                  easy_client_wait_batch_process(easy_message_t *m);\nextern void                *easy_client_send(easy_io_t *eio, easy_addr_t addr, easy_session_t *s);\nextern int                  easy_client_dispatch(easy_io_t *eio, easy_addr_t addr, easy_session_t *s);\n\n\nextern int                  easy_request_do_reply(easy_request_t *r);\nextern easy_thread_pool_t  *easy_thread_pool_create(easy_io_t *eio, int cnt, easy_request_process_pt *cb, void *args);\nextern easy_thread_pool_t  *easy_thread_pool_create_ex(easy_io_t *eio, int cnt, easy_baseth_on_start_pt *start,\n        easy_request_process_pt *cb, void *args);\nextern int                  easy_thread_pool_push(easy_thread_pool_t *tp, easy_request_t *r, uint64_t hv);\nextern int                  easy_thread_pool_push_message(easy_thread_pool_t *tp, easy_message_t *m, uint64_t hv);\nextern int                  easy_thread_pool_push_session(easy_thread_pool_t *tp, easy_session_t *s, uint64_t hv);\nextern void                 easy_request_addbuf(easy_request_t *r, easy_buf_t *b);\nextern void                 easy_request_addbuf_list(easy_request_t *r, easy_list_t *list);\nextern void                 easy_request_wakeup(easy_request_t *r);\nextern void                 easy_request_sleeping(easy_request_t *r);\nextern void                 easy_request_sleepless(easy_request_t *r);\n\n\nextern easy_file_task_t     *easy_file_task_create(easy_request_t *r, int fd, int bufsize);\nextern void                 easy_file_task_set(easy_file_task_t *ft, char *buffer, int64_t offset, int64_t bufsize, void *args);\nextern void                 easy_file_task_reset(easy_file_task_t *ft, int type);\n\n\nextern int                  easy_ssl_init();\nextern int                  easy_ssl_cleanup();\nextern easy_ssl_t          *easy_ssl_config_load(char *filename);\n\nextern easy_ssl_ctx_t      *easy_ssl_ctx_load(easy_pool_t *pool, const char *ssl_ca,\n                                              const char *ssl_cert, const char *ssl_key,\n                                              const int is_from_file, const int is_babassl,\n                                              const int is_server);\nextern int                  easy_ssl_ob_config_load(easy_io_t *eio, const char *ssl_ca,\n                                                    const char *ssl_cert, const char *ssl_key,\n                                                    const int is_from_file, const int is_babassl,\n                                                    const int used_for_rpc);\nextern int                  easy_ssl_ob_config_check(const char *ssl_ca,\n                                                     const char *ssl_cert, const char *ssl_key,\n                                                     const int is_from_file, const int is_babassl);\nextern int                  easy_ssl_config_destroy(easy_ssl_t *ssl);\nextern int easy_ssl_client_authenticate(easy_ssl_t *ssl, SSL *conn, const void *host, int len);\n\n\n\n#define EASY_IOTH_SELF ((easy_io_thread_t*) easy_baseth_self)\n#define easy_session_set_args(s, a)      (s)->r.args = (void*)a\n#define easy_session_set_handler(s,h,ua) (s)->thread_ptr = (void *)h; (s)->status = EASY_CONNECT_SEND; (s)->r.user_data = (void *)ua;\n#define easy_session_set_timeout(s, t)   (s)->timeout = t\n#define easy_request_set_wobj(r, w)      (r)->request_list_node.prev = (easy_list_t *)w\n#define easy_session_set_wobj(s, w)      easy_request_set_wobj(&((s)->r), w)\n#define easy_session_set_request(s, p, t, a)                \\\n    (s)->r.opacket = (void*) p;                             \\\n    (s)->r.args = (void*)a; (s)->timeout = t;\n#define easy_session_packet_create(type, s, size)           \\\n    ((s = easy_session_create(size + sizeof(type))) ? ({    \\\n        memset(&((s)->data[0]), 0, sizeof(type));           \\\n        (s)->r.opacket = &((s)->data[0]);                   \\\n        (type*) &((s)->data[0]);}) : NULL)\n#define easy_session_class_create(type, s, ...)             \\\n    ((s = easy_session_create(sizeof(type))) ? ({           \\\n        new(&((s)->data[0]))type(__VA_ARGS__);              \\\n        (s)->r.opacket = &((s)->data[0]);                   \\\n        (type*) &((s)->data[0]);}) : NULL)\n\n#ifdef EASY_MULTIPLICITY\n#define easy_io_create(eio, cnt)                    easy_eio_create(eio, cnt)\n#define easy_io_start(eio)                          easy_eio_start(eio)\n#define easy_io_wait(eio)                           easy_eio_wait(eio)\n#define easy_io_stop(eio)                           easy_eio_stop(eio)\n#define easy_io_shutdown(eio)                       easy_eio_shutdown(eio)\n#define easy_io_destroy(eio)                        easy_eio_destroy(eio)\n#define easy_io_thread_loop(a,b)                    easy_eio_thread_loop(a,b)\n#define easy_io_set_uthread_start(eio,start,args)   easy_eio_set_uthread_start(eio,start,args)\n#define easy_io_stat_watcher_start(a1,a2,a3,a4,a5)  easy_eio_stat_watcher_start(a1,a2,a3,a4,a5)\n#define easy_io_add_listen(eio,host,port,handler)   easy_connection_add_listen(eio,host,port,handler)\n#define easy_io_connect(eio,addr,handler,t,args)    easy_connection_connect(eio,addr,handler,t,args,0)\n#define easy_io_connect_thread(eio,addr,h,t,args)   easy_connection_connect_thread(eio,addr,h,t,args,0)\n#define easy_io_disconnect(eio,addr)                easy_connection_disconnect(eio,addr)\n#define easy_io_disconnect_thread(eio,addr)         easy_connection_disconnect_thread(eio,addr)\n#define easy_request_thread_create(eio,cnt,cb,args) easy_thread_pool_create(eio,cnt,cb,args)\n#define easy_io_dispatch(eio,addr,s)                easy_client_dispatch(eio,addr,s)\n#define easy_io_send(eio,addr,s)                    easy_client_send(eio,addr,s);\n#else\n#define easy_io_create(cnt)                         easy_eio_create(&easy_io_var, cnt)\n#define easy_io_start()                             easy_eio_start(&easy_io_var)\n#define easy_io_wait()                              easy_eio_wait(&easy_io_var)\n#define easy_io_stop()                              easy_eio_stop(&easy_io_var)\n#define easy_io_shutdown()                          easy_eio_shutdown(&easy_io_var)\n#define easy_io_destroy()                           easy_eio_destroy(&easy_io_var)\n#define easy_io_thread_loop(a)                      easy_eio_thread_loop(&easy_io_var,a)\n#define easy_io_set_uthread_start(start,args)       easy_eio_set_uthread_start(&easy_io_var,start,args)\n#define easy_io_stat_watcher_start(a1,a2,a3,a4)     easy_eio_stat_watcher_start(&easy_io_var,a1,a2,a3,a4)\n#define easy_io_add_listen(host,port,handler)       easy_connection_add_listen(&easy_io_var,host,port,handler)\n#define easy_io_connect(addr,handler,t,args)        easy_connection_connect(&easy_io_var,addr,handler,t,args,0)\n#define easy_io_connect_thread(addr,h,t,args)       easy_connection_connect_thread(&easy_io_var,addr,h,t,args,0)\n#define easy_io_disconnect(addr)                    easy_connection_disconnect(&easy_io_var,addr)\n#define easy_io_disconnect_thread(addr)             easy_connection_disconnect_thread(&easy_io_var,addr)\n#define easy_request_thread_create(cnt, cb, args)   easy_thread_pool_create(&easy_io_var, cnt, cb, args)\n#define easy_io_dispatch(addr,s)                    easy_client_dispatch(&easy_io_var,addr,s)\n#define easy_io_send(addr,s)                        easy_client_send(&easy_io_var,addr,s);\n#endif\n\nextern __thread easy_baseth_t *easy_baseth_self;\nextern easy_io_t        easy_io_var;\n\nEASY_CPP_END\n\n#endif\n\n'obproxy/deps/easy/src/packet/http/easy_http_handler.h'\n:#ifndef EASY_HTTP_HANDLER_H_\n#define EASY_HTTP_HANDLER_H_\n\n#include <easy_define.h>\n#include <easy_string.h>\n\nEASY_CPP_START\n\n#include <http_parser.h>\n#include <easy_io.h>\n\n#define EASY_HTTP_HDR_MAX_SIZE          128\n#define EASY_HTTP_CRLF                  \"\\r\\n\"\n\n\n#define EASY_HTTP_STATUS_200            \"200 OK\"\n#define EASY_HTTP_STATUS_201            \"201 Created\"\n#define EASY_HTTP_STATUS_202            \"202 Accepted\"\n#define EASY_HTTP_STATUS_204            \"204 No Content\"\n#define EASY_HTTP_STATUS_206            \"206 Partial Content\"\n#define EASY_HTTP_STATUS_301            \"301 Moved Permanently\"\n#define EASY_HTTP_STATUS_302            \"302 Moved Temporarily\"\n#define EASY_HTTP_STATUS_303            \"303 See Other\"\n#define EASY_HTTP_STATUS_304            \"304 Not Modified\"\n#define EASY_HTTP_STATUS_400            \"400 Bad Request\"\n#define EASY_HTTP_STATUS_401            \"401 Unauthorized\"\n#define EASY_HTTP_STATUS_402            \"402 Payment Required\"\n#define EASY_HTTP_STATUS_403            \"403 Forbidden\"\n#define EASY_HTTP_STATUS_404            \"404 Not Found\"\n#define EASY_HTTP_STATUS_405            \"405 Not Allowed\"\n#define EASY_HTTP_STATUS_406            \"406 Not Acceptable\"\n#define EASY_HTTP_STATUS_408            \"408 Request Time-out\"\n#define EASY_HTTP_STATUS_409            \"409 Conflict\"\n#define EASY_HTTP_STATUS_410            \"410 Gone\"\n#define EASY_HTTP_STATUS_411            \"411 Length Required\"\n#define EASY_HTTP_STATUS_412            \"412 Precondition Failed\"\n#define EASY_HTTP_STATUS_413            \"413 Request Entity Too Large\"\n#define EASY_HTTP_STATUS_415            \"415 Unsupported Media Type\"\n#define EASY_HTTP_STATUS_416            \"416 Requested Range Not Satisfiable\"\n#define EASY_HTTP_STATUS_500            \"500 Internal Server Error\"\n#define EASY_HTTP_STATUS_501            \"501 Method Not Implemented\"\n#define EASY_HTTP_STATUS_502            \"502 Bad Gateway\"\n#define EASY_HTTP_STATUS_503            \"503 Service Temporarily Unavailable\"\n#define EASY_HTTP_STATUS_504            \"504 Gateway Time-out\"\n#define EASY_HTTP_STATUS_507            \"507 Insufficient Storage\"\n\ntypedef struct easy_http_request_t      easy_http_request_t;\ntypedef struct easy_http_packet_t       easy_http_packet_t;\n\nstruct easy_http_request_t {\n    easy_message_t          *m;\n    http_parser             parser;\n\n    easy_buf_string_t       str_path;\n    easy_buf_string_t       str_query_string;\n    easy_buf_string_t       str_fragment;\n    easy_buf_string_t       str_body;\n    easy_buf_string_t       str_proto;\n    easy_buf_string_t       str_host;\n\n    easy_hash_string_t      *headers_in;\n    easy_hash_string_t      *headers_out;\n    easy_hash_string_t      *args_table;\n    easy_string_pair_t      *last_header, *end_header;\n\n\n    easy_buf_string_t       status_line;\n    easy_list_t             output;\n    easy_buf_string_t       content_type;\n    int64_t                 content_length;\n\n\n    unsigned int            message_begin_called : 1;\n    unsigned int            header_complete_called : 1;\n    unsigned int            message_complete_called : 1;\n    unsigned int            last_was_value : 1;\n    unsigned int            is_raw_header : 1;\n    unsigned int            args_parsed : 1;\n    unsigned int            wait_close : 1;\n    unsigned int            keep_alive : 1;\n    unsigned int            send_chunk : 1;\n    unsigned int            del_default_header : 1;\n\n    int                     parsed_byte;\n    void                    *user_data;\n};\n\nstruct easy_http_packet_t {\n    easy_buf_string_t       str_query_string;\n    easy_buf_string_t       str_path;\n    easy_hash_string_t      *headers_out;\n    easy_list_t             output;\n\n    enum http_method        method;\n\n    unsigned int            is_raw_header : 1;\n    unsigned int            keep_alive : 1;\n    unsigned int            del_default_header : 1;\n};\n\nvoid easy_http_add_header(easy_pool_t *pool, easy_hash_string_t *table, const char *name, const char *value);\nchar *easy_http_del_header(easy_hash_string_t *table, const char *name);\nchar *easy_http_get_header(easy_hash_string_t *table, const char *name);\n\nvoid easy_http_handler_init(easy_io_handler_pt *handler, easy_io_process_pt *process);\nvoid *easy_http_server_on_decode(easy_message_t *m);\nint easy_http_server_on_encode(easy_request_t *r, void *data);\nvoid *easy_http_client_on_decode(easy_message_t *m);\nint easy_http_client_on_encode(easy_request_t *r, void *data);\neasy_http_packet_t *easy_http_packet_create (easy_pool_t *pool);\n\nint easy_url_decode(char *str, int len);\nint easy_http_merge_path(char *newpath, int len, const char *rootpath, const char *addpath);\nint easy_http_request_printf(easy_http_request_t *r, const char *fmt, ...);\nchar *easy_http_get_args(easy_http_request_t *p, const char *name);\nvoid easy_header_set_case_sensitive(int value);\nvoid easy_header_set_max_size(int value);\neasy_hash_string_t *easy_header_create_table(easy_pool_t *pool);\nint easy_http_request_create (easy_message_t *m, enum http_parser_type type);\n\nextern http_parser_settings easy_http_request_settings;\nextern http_parser_settings easy_http_response_settings;\n\nEASY_CPP_END\n\n#endif\n",
        "gt": [
            "'obproxy/deps/easy/src/io/easy_summary.h'",
            "'obproxy/deps/easy/src/io/easy_io.h'",
            "'obproxy/deps/easy/src/packet/http/easy_http_handler.h'"
        ]
    },
    {
        "files": [
            "'Assemble-Them-All/simulation/opengl_viewer/include/linear_timer.h'",
            "'Assemble-Them-All/simulation/opengl_viewer/include/opengl_viewer.h'",
            "'Assemble-Them-All/simulation/redmax/Joint/JointFree3DEuler.h'",
            "'Assemble-Them-All/simulation/redmax/SimEnvGenerator.cpp'",
            "'Assemble-Them-All/simulation/redmax/Common.h'"
        ],
        "content": "'Assemble-Them-All/simulation/opengl_viewer/include/linear_timer.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef _OPENGL_VIEWER_LINEAR_TIMER_H_\n#define _OPENGL_VIEWER_LINEAR_TIMER_H_\n\n#include \"timer.h\"\n\nnamespace opengl_viewer {\n\nclass LinearTimer : public Timer {\npublic:\n  LinearTimer() : fps_(25), dt_(0.04f), current_time_(0.0f) {}\n\n  void Initialize(const int fps) {\n    fps_ = fps;\n    dt_ = 1.0f / fps;\n    current_time_ = 0.0f;\n  }\n\n  const float CurrentTime() {\n    const float current_time = current_time_;\n    current_time_ += dt_;\n    return current_time;\n  }\n\nprivate:\n  int fps_;\n  float dt_;\n  float current_time_;\n};\n\n}\n\n#endif\n'Assemble-Them-All/simulation/opengl_viewer/include/opengl_viewer.h'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef _OPENGL_VIEWER_OPENGL_VIEWER_H_\n#define _OPENGL_VIEWER_OPENGL_VIEWER_H_\n\n#include \"animator.h\"\n#include \"bounding_box.h\"\n#include \"dynamic_opengl_light.h\"\n#include \"dynamic_opengl_shape.h\"\n#include \"geometry.h\"\n#include \"image.h\"\n#include \"imgui_wrapper.h\"\n#include \"keyboard_handler.h\"\n#include \"linear_timer.h\"\n#include \"mouse_handler.h\"\n#include \"opengl_light.h\"\n#include \"opengl_shape.h\"\n#include \"option.h\"\n#include \"sample_imgui_wrapper.h\"\n#include \"shader_program.h\"\n#include \"static_opengl_light.h\"\n#include \"static_opengl_shape.h\"\n#include \"timer.h\"\n#include \"viewer.h\"\n\n#endif\n'Assemble-Them-All/simulation/redmax/Joint/JointFree3DEuler.h'\n:#pragma once\n#include \"Common.h\"\n#include \"Joint/Joint.h\"\n#include \"Joint/JointSphericalEuler.h\"\n#include \"Joint/JointTranslational.h\"\n\nnamespace redmax {\n\n\nclass JointFree3DEuler : public Joint {\npublic:\n    JointFree3DEuler(Simulation *sim, int id, Joint * parent, Matrix3 R_pj_0, Vector3 p_pj_0,\n        JointSphericalEuler::Chart chart = JointSphericalEuler::Chart::XYZ,\n        Joint::Frame frame = Joint::Frame::LOCAL);\n\n    virtual void update(bool design_gradient = false);\n\n    JointTranslational* _joint_translational;\n    JointSphericalEuler* _joint_spherical_euler;\n};\n\n}\n'Assemble-Them-All/simulation/redmax/SimEnvGenerator.cpp'\n:#include \"SimEnvGenerator.h\"\n#include \"Robot.h\"\n#include \"Body/BodyCuboid.h\"\n#include \"Body/BodyMeshObj.h\"\n#include \"Body/BodySphere.h\"\n#include \"Joint/JointFixed.h\"\n#include \"Joint/JointRevolute.h\"\n#include \"Joint/JointPrismatic.h\"\n#include \"Joint/JointFree2D.h\"\n#include \"Joint/JointTranslational.h\"\n#include \"Joint/JointSphericalEuler.h\"\n#include \"Joint/JointFree3DEuler.h\"\n#include \"Joint/JointFree3DExp.h\"\n#include \"Force/ForceGroundContact.h\"\n#include \"Force/ForceCuboidCuboidContact.h\"\n#include \"Force/ForceGeneralPrimitiveContact.h\"\n#include \"Force/ForceGeneralSDFContact.h\"\n#include \"Actuator/Actuator.h\"\n#include \"Actuator/ActuatorMotor.h\"\n#include \"Utils.h\"\n#include \"Common.h\"\n\nnamespace redmax {\n\nSimulation* SimEnvGenerator::createSinglePendulumTest(std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_gravity = -980. * Vector3::UnitZ();\n    options->_h = 0.01;\n    options->_integrator = integrator;\n\n\n    Simulation* sim = new Simulation(options, \"single pendulum\");\n\n\n    Robot* robot = new Robot();\n    Vector3 length;\n    length(0) = 10; length(1) = 1; length(2) = 1;\n    Vector3 pos;\n    pos(0) = 5; pos(1) = 0; pos(2) = 0;\n    Vector3 axis;\n    axis(0) = 0; axis(1) = 1; axis(2) = 0;\n\n    Joint* joint = new JointRevolute(sim, 0, axis, nullptr, Matrix3::Identity(), Vector3::Zero());\n    joint->set_damping(1e3);\n\n    BodyCuboid* body = new BodyCuboid(sim, joint, length, Matrix3::Identity(), pos, (dtype)1.0);\n\n    robot->_root_joints.push_back(joint);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\nSimulation* SimEnvGenerator::createSinglePendulumObjTest(std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_gravity = -980. * Vector3::UnitZ();\n    options->_h = 0.01;\n    options->_integrator = integrator;\n\n\n    Simulation* sim = new Simulation(options, \"single pendulum\");\n\n\n    Robot* robot = new Robot();\n    Vector3 length;\n    length(0) = 10; length(1) = 1; length(2) = 1;\n    Vector3 pos;\n    pos(0) = 5; pos(1) = 0; pos(2) = 0;\n    Vector3 axis;\n    axis(0) = 0; axis(1) = 1; axis(2) = 0;\n\n    Joint* joint = new JointRevolute(sim, 0, axis, nullptr, Matrix3::Identity(), Vector3::Zero());\n    joint->set_damping(1e3);\n\n\n\n\n\n\n\n\n\n    BodyMeshObj* body = new BodyMeshObj(sim, joint,\n        std::string(GRAPHICS_CODEBASE_SOURCE_DIR) + \"/resources/meshes/cube.obj\",\n        Matrix3::Identity(), pos, BodyMeshObj::BODY_TO_JOINT,\n        (dtype)1.0);\n\n    robot->_root_joints.push_back(joint);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\nSimulation* SimEnvGenerator::createMultiPendulumTest(int num_links, std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_gravity = -980. * Vector3::UnitZ();\n    options->_h = 0.01;\n    options->_integrator = integrator;\n\n\n    Simulation* sim = new Simulation(options, \"multi pendulum\");\n\n    Robot* robot = new Robot();\n    Vector3 length; length(0) = 10; length(1) = 1; length(2) = 1;\n    Vector3 body_pos; body_pos(0) = 5; body_pos(1) = 0; body_pos(2) = 0;\n    Vector3 joint_pos; joint_pos(0) = 10; joint_pos(1) = 0; joint_pos(2) = 0;\n\n    vector<Joint*> joints;\n    joints.clear();\n    for (int i = 0;i < num_links;++i) {\n        Joint* joint;\n        if (i == 0) {\n            joint = new JointRevolute(sim, i, Vector3::UnitY(), nullptr, Matrix3::Identity(), Vector3::Zero());\n        } else {\n            joint = new JointRevolute(sim, i, Vector3::UnitY(), joints[i - 1], Matrix3::Identity(), joint_pos);\n        }\n        joint->set_damping((dtype)1e2);\n        joints.push_back(joint);\n\n        BodyCuboid* body = new BodyCuboid(sim, joint, length, Matrix3::Identity(), body_pos, (dtype)1.0);\n\n    }\n\n    robot->_root_joints.push_back(joints[0]);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\nSimulation* SimEnvGenerator::createPrismaticTest(std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_gravity = -980. * Vector3::UnitZ();\n    options->_h = 0.01;\n    options->_integrator = integrator;\n\n\n    Simulation* sim = new Simulation(options, \"prismatic test\");\n\n    Robot* robot = new Robot();\n\n    Joint* joint0 = new JointPrismatic(sim, 0, Vector3::UnitX(), nullptr, Matrix3::Identity(), Vector3::Zero());\n    BodyCuboid* body0 = new BodyCuboid(sim, joint0, Vector3(20, 1, 1), Matrix3::Identity(), Vector3::Zero(), 1.);\n    Joint* joint1 = new JointRevolute(sim, 1, Vector3::UnitY(), joint0, Matrix3::Identity(), Vector3(-10, 0, 0));\n    joint1->_q(0) = constants::pi / 2.;\n    BodyCuboid* body1 = new BodyCuboid(sim, joint1, Vector3(1, 1, 10), Matrix3::Identity(), Vector3(0, 0, -5.), 1.);\n\n    robot->_root_joints.push_back(joint0);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\nSimulation* SimEnvGenerator::createFree2DTest(std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_gravity = -980. * Vector3::UnitY();\n    options->_h = 5e-3;\n    options->_integrator = integrator;\n\n\n    Simulation::ViewerOptions *viewer_options = new Simulation::ViewerOptions();\n    viewer_options->_fps = 60;\n    viewer_options->_speed = 0.5;\n    viewer_options->_camera_up = Vector3::UnitY();\n    viewer_options->_camera_pos = Vector3(0., 0., 2.);\n    viewer_options->_ground = false;\n\n\n    Simulation* sim = new Simulation(options, viewer_options, \"Free2D joint test\");\n\n    Robot* robot = new Robot();\n\n    Joint* joint0 = new JointFree2D(sim, 0, nullptr, Matrix3::Identity(), Vector3::Zero());\n    joint0->_q << -10, -10, 0;\n    joint0->_qdot << 50, 200, 20;\n    BodyCuboid* body0 = new BodyCuboid(sim, joint0, Vector3(1, 1, 1), Matrix3::Identity(), Vector3::Zero(), 1.);\n\n    robot->_root_joints.push_back(joint0);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\nSimulation* SimEnvGenerator::createFree3DEulerTest(std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_h = 5e-3;\n    options->_integrator = integrator;\n\n\n    Simulation::ViewerOptions *viewer_options = new Simulation::ViewerOptions();\n    viewer_options->_fps = 60;\n    viewer_options->_speed = 0.5;\n    viewer_options->_ground = true;\n    viewer_options->_E_g.setIdentity();\n\n\n    Simulation* sim = new Simulation(options, viewer_options, \"Free3D(euler) joint test\");\n\n    Robot* robot = new Robot();\n\n\n\n    Joint* joint0 = new JointFree3DEuler(sim, 0, nullptr, Matrix3::Identity(), Vector3(0, 0, 6.));\n\n    joint0->_qdot << 30., 0., 10., 5., 0., 0;\n    BodyCuboid* body0 = new BodyCuboid(sim, joint0, Vector3(4, 4, 4), Matrix3::Identity(), Vector3::Zero(), 1.);\n\n    Matrix4 E_g = Matrix4::Identity();\n    ForceGroundContact* force0 = new ForceGroundContact(sim, body0, E_g, 1e6, 1e3, 0.2, 3e1);\n    robot->add_force(force0);\n\n    robot->_root_joints.push_back(joint0);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\nSimulation* SimEnvGenerator::createFree3DExpTest(std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_h = 5e-3;\n    options->_integrator = integrator;\n\n\n    Simulation::ViewerOptions *viewer_options = new Simulation::ViewerOptions();\n    viewer_options->_fps = 60;\n    viewer_options->_speed = 0.5;\n    viewer_options->_ground = true;\n    viewer_options->_E_g.setIdentity();\n\n\n    Simulation* sim = new Simulation(options, viewer_options, \"Free3D(euler) joint test\");\n\n    Robot* robot = new Robot();\n\n\n\n    Joint* joint0 = new JointFree3DExp(sim, 0, nullptr, Matrix3::Identity(), Vector3(0, 0, 6.));\n\n    joint0->_qdot << 30., 0., 10., 5., 0., 0;\n    BodyCuboid* body0 = new BodyCuboid(sim, joint0, Vector3(4, 4, 4), Matrix3::Identity(), Vector3::Zero(), 1.);\n\n    Matrix4 E_g = Matrix4::Identity();\n    ForceGroundContact* force0 = new ForceGroundContact(sim, body0, E_g, 1e6, 1e3, 0.2, 3e1);\n    robot->add_force(force0);\n\n    robot->_root_joints.push_back(joint0);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\nSimulation* SimEnvGenerator::createGroundContactTest(std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_gravity = -980. * Vector3::UnitY();\n    options->_h = 5e-4;\n    options->_integrator = integrator;\n\n\n    Simulation::ViewerOptions *viewer_options = new Simulation::ViewerOptions();\n    viewer_options->_fps = 30;\n    viewer_options->_speed = 0.5;\n    viewer_options->_camera_up = Vector3::UnitY();\n    viewer_options->_camera_pos = Vector3(0.75, 0.75, 1.25);\n    viewer_options->_ground = true;\n    viewer_options->_E_g.topLeftCorner(3, 3) = Eigen::AngleAxis<dtype>(-constants::pi / 2., Vector3::UnitX()).matrix();\n    viewer_options->_E_g.topRightCorner(3, 1).setZero();\n\n\n\n\n    Simulation* sim = new Simulation(options, viewer_options, \"Free2D joint with ground\");\n\n    Robot* robot = new Robot();\n\n    Joint* joint0 = new JointFree2D(sim, 0, nullptr, Matrix3::Identity(), Vector3::Zero());\n    joint0->_q << -2, 2, 0;\n    joint0->_qdot << 5, 70, 5;\n\n    BodyCuboid* body0 = new BodyCuboid(sim, joint0, Vector3(3, 1, 1), Matrix3::Identity(), Vector3::Zero(), 1.);\n\n\n    Matrix3 R = Eigen::AngleAxis<dtype>(-constants::pi / 2., Vector3::UnitX()).matrix();\n    Matrix4 E_g = Matrix4::Identity();\n    E_g.topLeftCorner(3, 3) = R;\n    ForceGroundContact* force0 = new ForceGroundContact(sim, body0, E_g, 1e6, 1e4, 0.8, 3e1);\n    robot->add_force(force0);\n\n    robot->_root_joints.push_back(joint0);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\nSimulation* SimEnvGenerator::createBoxContactTest(std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_gravity = -980. * Vector3::UnitY();\n    options->_h = 5e-4;\n    options->_integrator = integrator;\n\n\n    Simulation::ViewerOptions *viewer_options = new Simulation::ViewerOptions();\n    viewer_options->_fps = 60;\n    viewer_options->_speed = 0.5;\n    viewer_options->_camera_up = Vector3::UnitY();\n    viewer_options->_camera_pos = Vector3(0.8, 0.75, 1.25);\n\n\n    viewer_options->_ground = true;\n    viewer_options->_E_g.topLeftCorner(3, 3) = Eigen::AngleAxis<dtype>(-constants::pi / 2., Vector3::UnitX()).matrix();\n    viewer_options->_E_g.topRightCorner(3, 1).setZero();\n\n\n\n\n    Simulation* sim = new Simulation(options, viewer_options, \"Free2D Box-Box contact with ground\");\n\n    Robot* robot = new Robot();\n\n    Joint* joint0 = new JointFree2D(sim, 0, nullptr, Matrix3::Identity(), Vector3(0.0, 0.5, 0.0));\n\n    joint0->_qdot << 45., 0., 0.;\n    BodyCuboid* body0 = new BodyCuboid(sim, joint0, Vector3(1, 1, 1), Matrix3::Identity(), Vector3::Zero(), 1.);\n\n    Joint* joint1 = new JointFree2D(sim, 1, nullptr, Matrix3::Identity(), Vector3(3.0, 0.5, 0.0));\n    BodyCuboid* body1 = new BodyCuboid(sim, joint1, Vector3(1, 1, 1), Matrix3::Identity(), Vector3::Zero(), 1.);\n\n    robot->_root_joints.push_back(joint0);\n    robot->_root_joints.push_back(joint1);\n\n\n    Matrix3 R = Eigen::AngleAxis<dtype>(-constants::pi / 2., Vector3::UnitX()).matrix();\n    Matrix4 E_g = Matrix4::Identity();\n    E_g.topLeftCorner(3, 3) = R;\n    ForceGroundContact* force0 = new ForceGroundContact(sim, body0, E_g, 1e5, 1e2, 0.2, 3e1);\n    robot->add_force(force0);\n    ForceGroundContact* force1 = new ForceGroundContact(sim, body1, E_g, 1e5, 1e2, 0.2, 3e1);\n    robot->add_force(force1);\n\n\n    ForceCuboidCuboidContact* force2 = new ForceCuboidCuboidContact(sim, body0, body1, 1e4, 0.0);\n    robot->add_force(force2);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\n\n\n\nSimulation* SimEnvGenerator::createTorqueFingerDemo(std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_gravity = -980. * Vector3::UnitY();\n    options->_h = 1e-2;\n    options->_integrator = integrator;\n\n\n    Simulation::ViewerOptions *viewer_options = new Simulation::ViewerOptions();\n    viewer_options->_fps = 30;\n    viewer_options->_speed = 0.5;\n    viewer_options->_camera_up = Vector3::UnitY();\n    viewer_options->_camera_pos = Vector3(0.6, 1.3, 2.0);\n\n    viewer_options->_camera_lookat = Vector3(0.1, 0.8, 0.);\n    viewer_options->_ground = true;\n    viewer_options->_E_g.topLeftCorner(3, 3) = Eigen::AngleAxis<dtype>(-constants::pi / 2., Vector3::UnitX()).matrix();\n    viewer_options->_E_g.topRightCorner(3, 1).setZero();\n\n\n\n\n    Simulation* sim = new Simulation(options, viewer_options, \"Torque-driven finger demo\");\n\n    Robot* robot = new Robot();\n\n\n    Joint* joint0 = new JointRevolute(sim, 0, Vector3(0, 0, -1), nullptr, Matrix3::Identity(), Vector3(0., 10., 0.));\n    joint0->set_damping(1e4);\n    BodyCuboid* body0 = new BodyCuboid(sim, joint0, Vector3(4, 1, 1), Matrix3::Identity(), Vector3(2., 0., 0.), 1.);\n    Actuator* actuator0 = new ActuatorMotor(\"actuator\", joint0, ActuatorMotor::ControlMode::FORCE, -1e5, 1e5);\n    robot->add_actuator(actuator0);\n\n\n    Joint* joint1 = new JointRevolute(sim, 1, Vector3(0, 0, -1), joint0, Matrix3::Identity(), Vector3(4., 0., 0.));\n    joint1->set_damping(1e4);\n    BodyCuboid* body1 = new BodyCuboid(sim, joint1, Vector3(2, 1, 1), Matrix3::Identity(), Vector3(1., 0., 0.), 1.);\n    Actuator* actuator1 = new ActuatorMotor(\"actuator\", joint1, ActuatorMotor::ControlMode::FORCE, -1e5, 1e5);\n    robot->add_actuator(actuator1);\n\n\n    Joint* joint2 = new JointRevolute(sim, 2, Vector3(0, 0, -1), joint1, Matrix3::Identity(), Vector3(2., 0., 0.));\n    joint2->set_damping(1e4);\n    BodyCuboid* body2 = new BodyCuboid(sim, joint2, Vector3(1, 1, 1), Matrix3::Identity(), Vector3(0.5, 0., 0.), 1.);\n    Actuator* actuator2 = new ActuatorMotor(\"actuator\", joint2, ActuatorMotor::ControlMode::FORCE, -1e5, 1e5);\n    robot->add_actuator(actuator2);\n\n    robot->_root_joints.push_back(joint0);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\n\n\n\nSimulation* SimEnvGenerator::createTorqueFingerFlickDemo(std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_gravity = -980. * Vector3::UnitY();\n    options->_h = 5e-4;\n    options->_integrator = integrator;\n\n\n    Simulation::ViewerOptions *viewer_options = new Simulation::ViewerOptions();\n    viewer_options->_fps = 30;\n    viewer_options->_speed = 0.5;\n    viewer_options->_camera_up = Vector3::UnitY();\n    viewer_options->_camera_pos = Vector3(0.8, 0.6, 2.0);\n\n    viewer_options->_camera_lookat = Vector3(0.3, 0.4, 0.);\n    viewer_options->_ground = true;\n    viewer_options->_E_g.topLeftCorner(3, 3) = Eigen::AngleAxis<dtype>(-constants::pi / 2., Vector3::UnitX()).matrix();\n    viewer_options->_E_g.topRightCorner(3, 1).setZero();\n\n\n\n\n    Simulation* sim = new Simulation(options, viewer_options, \"Torque-driven finger flick box demo\");\n\n    Robot* robot = new Robot();\n\n\n    Joint* joint0 = new JointRevolute(sim, 0, Vector3(0, 0, -1), nullptr, Matrix3::Identity(), Vector3(0., 3.2, 0.));\n    joint0->set_damping(1e4);\n    BodyCuboid* body0 = new BodyCuboid(sim, joint0, Vector3(4, 1, 1), Matrix3::Identity(), Vector3(2., 0., 0.), 1.);\n    Actuator* actuator0 = new ActuatorMotor(\"actuator\", joint0, ActuatorMotor::ControlMode::FORCE, -1e5, 1e5);\n    robot->add_actuator(actuator0);\n\n\n    Joint* joint1 = new JointRevolute(sim, 1, Vector3(0, 0, -1), joint0, Matrix3::Identity(), Vector3(4., 0., 0.));\n    joint1->set_damping(1e4);\n    BodyCuboid* body1 = new BodyCuboid(sim, joint1, Vector3(2, 1, 1), Matrix3::Identity(), Vector3(1., 0., 0.), 1.);\n    Actuator* actuator1 = new ActuatorMotor(\"actuator\", joint1, ActuatorMotor::ControlMode::FORCE, -1e5, 1e5);\n    robot->add_actuator(actuator1);\n\n\n    Joint* joint2 = new JointRevolute(sim, 2, Vector3(0, 0, -1), joint1, Matrix3::Identity(), Vector3(2., 0., 0.));\n    joint2->set_damping(1e4);\n    BodyCuboid* body2 = new BodyCuboid(sim, joint2, Vector3(1, 1, 1), Matrix3::Identity(), Vector3(0.5, 0., 0.), 1.);\n    Actuator* actuator2 = new ActuatorMotor(\"actuator\", joint2, ActuatorMotor::ControlMode::FORCE, -1e5, 1e5);\n    robot->add_actuator(actuator2);\n\n\n    Joint* box_joint = new JointFree2D(sim, 0, nullptr, Matrix3::Identity(), Vector3(5.2, 0.5, 0.0));\n    BodyCuboid* box = new BodyCuboid(sim, box_joint, Vector3(1, 1, 1), Matrix3::Identity(), Vector3::Zero(), 1.);\n    box->set_color(Vector3(0., 0.2, 0.4));\n\n\n    JointFixed* goal_joint = new JointFixed(sim, 10, nullptr, Matrix3::Identity(), Vector3(5.2 + 10.5, 0.5, 0.));\n    BodyCuboid* goal = new BodyCuboid(sim, goal_joint, Vector3(0.2, 0.2, 0.2), Matrix3::Identity(), Vector3::Zero(), 1.);\n    goal->set_color(Vector3(0., 1., 0.));\n\n    robot->_root_joints.push_back(joint0);\n    robot->_root_joints.push_back(box_joint);\n    robot->_root_joints.push_back(goal_joint);\n\n\n    Matrix3 R = Eigen::AngleAxis<dtype>(-constants::pi / 2., Vector3::UnitX()).matrix();\n    Matrix4 E_g = Matrix4::Identity();\n    E_g.topLeftCorner(3, 3) = R;\n    ForceGroundContact* force_ground_0 = new ForceGroundContact(sim, body0, E_g, 1e4, 1e2, 0.2, 3e1);\n    robot->add_force(force_ground_0);\n    ForceGroundContact* force_ground_1 = new ForceGroundContact(sim, body1, E_g, 1e4, 1e2, 0.2, 3e1);\n    robot->add_force(force_ground_1);\n    ForceGroundContact* force_ground_2 = new ForceGroundContact(sim, body2, E_g, 1e4, 1e2, 0.2, 3e1);\n    robot->add_force(force_ground_2);\n    ForceGroundContact* force_ground_3 = new ForceGroundContact(sim, box, E_g, 1e4, 1e2, 0.2, 3e1);\n    robot->add_force(force_ground_3);\n\n\n    ForceCuboidCuboidContact* force0 = new ForceCuboidCuboidContact(sim, body0, box, 1e4, 0.0);\n    robot->add_force(force0);\n\n    ForceCuboidCuboidContact* force1 = new ForceCuboidCuboidContact(sim, body1, box, 1e4, 0.0);\n    robot->add_force(force1);\n\n    ForceCuboidCuboidContact* force2 = new ForceCuboidCuboidContact(sim, body2, box, 1e4, 0.0);\n    robot->add_force(force2);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\nSimulation* SimEnvGenerator::createSphereGroundContactTest(std::string integrator) {\n\n    Simulation::Options *options = new Simulation::Options();\n    options->_h = 5e-4;\n    options->_integrator = integrator;\n\n\n    Simulation::ViewerOptions *viewer_options = new Simulation::ViewerOptions();\n    viewer_options->_ground = true;\n    viewer_options->_E_g.topRightCorner(3, 1).setZero();\n\n\n    Simulation* sim = new Simulation(options, viewer_options, \"Free2D joint with ground\");\n\n    Robot* robot = new Robot();\n\n    Matrix3 joint0_R;\n    joint0_R.col(0) = Vector3::UnitX();\n    joint0_R.col(1) = -Vector3::UnitZ();\n    joint0_R.col(2) = Vector3::UnitY();\n    Joint* joint0 = new JointFree2D(sim, 0, nullptr, joint0_R, Vector3(0, 0, 1.));\n    joint0->_qdot << 5., 0., 0.;\n\n\n\n\n    BodySphere* body0 = new BodySphere(sim, joint0, 1., Matrix3::Identity(), Vector3::Zero(), 1.);\n\n    Matrix4 E_g = Matrix4::Identity();\n    ForceGroundContact* force0 = new ForceGroundContact(sim, body0, E_g, 1e5, 1e3, 0.3, 3e1);\n    robot->add_force(force0);\n\n    robot->_root_joints.push_back(joint0);\n\n    robot->init();\n\n    sim->addRobot(robot);\n    sim->init();\n\n    return sim;\n}\n\n}\n'Assemble-Them-All/simulation/redmax/Common.h'\n:#pragma once\n#include <Eigen/Dense>\n#include <Eigen/Geometry>\n#include <Eigen/Sparse>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <fstream>\n#include <memory>\n#include <chrono>\n#include <sstream>\n#include <iomanip>\n#include <chrono>\n#include \"opengl_viewer.h\"\n\nusing namespace std;\nusing namespace Eigen;\n\nnamespace redmax {\n\nusing dtype = double;\n\ntypedef Eigen::Matrix<dtype, 1, 1> Vector1;\ntypedef Eigen::Matrix<dtype, 2, 1> Vector2;\ntypedef Eigen::Matrix<dtype, 3, 1> Vector3;\ntypedef Eigen::Matrix<dtype, 4, 1> Vector4;\ntypedef Eigen::Matrix<dtype, 5, 1> Vector5;\ntypedef Eigen::Matrix<dtype, 6, 1> Vector6;\ntypedef Eigen::Matrix<dtype, Eigen::Dynamic, 1> VectorX;\ntypedef Eigen::Matrix<dtype, 1, 1> RowVector1;\ntypedef Eigen::Matrix<dtype, 1, 2> RowVector2;\ntypedef Eigen::Matrix<dtype, 1, 3> RowVector3;\ntypedef Eigen::Matrix<dtype, 1, 4> RowVector4;\ntypedef Eigen::Matrix<dtype, 1, 5> RowVector5;\ntypedef Eigen::Matrix<dtype, 1, 6> RowVector6;\ntypedef Eigen::Matrix<dtype, 1, Eigen::Dynamic> RowVectorX;\ntypedef Eigen::Matrix<dtype, 3, 3> Matrix3;\ntypedef Eigen::Matrix<dtype, 4, 4> Matrix4;\ntypedef Eigen::Matrix<dtype, 5, 5> Matrix5;\ntypedef Eigen::Matrix<dtype, 6, 6> Matrix6;\ntypedef Eigen::Matrix<dtype, 3, 6> Matrix36;\ntypedef Eigen::Matrix<dtype, Eigen::Dynamic, Eigen::Dynamic> MatrixX;\ntypedef Eigen::Matrix<int  , Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> MatrixXir;\ntypedef Eigen::Matrix<dtype, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> MatrixXr;\ntypedef Eigen::DiagonalMatrix<dtype, Eigen::Dynamic> DiagonalMatrixX;\ntypedef Eigen::Matrix<dtype, 3, Eigen::Dynamic> Matrix3X;\ntypedef Eigen::SparseMatrix<dtype> SparseMatrixX;\ntypedef Eigen::Triplet<dtype> TripletX;\n\ntypedef Matrix3 SO3;\ntypedef Vector3 so3;\ntypedef Matrix4 SE3;\ntypedef Vector6 se3;\n\ninline void throw_error(std::string message) {\n    std::cerr << \"[Error] \" << message << std::endl;\n    throw message;\n}\n\n}",
        "gt": [
            "'Assemble-Them-All/simulation/opengl_viewer/include/linear_timer.h'",
            "'Assemble-Them-All/simulation/opengl_viewer/include/opengl_viewer.h'",
            "'Assemble-Them-All/simulation/redmax/Common.h'",
            "'Assemble-Them-All/simulation/redmax/Joint/JointFree3DEuler.h'",
            "'Assemble-Them-All/simulation/redmax/SimEnvGenerator.cpp'"
        ]
    },
    {
        "files": [
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLVisibleFunctionTable.hpp'",
            "'Tempest/Engine/gapi/metal/mtdescriptorarray.cpp'",
            "'Tempest/Engine/gapi/metal/mtsamplercache.h'",
            "'Tempest/Engine/gapi/metal/mtdevice.h'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'"
        ],
        "content": "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLVisibleFunctionTable.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n#include \"MTLDefines.hpp\"\n#include \"MTLHeaderBridge.hpp\"\n#include \"MTLPrivate.hpp\"\n\n#include <Foundation/Foundation.hpp>\n\n#include \"MTLResource.hpp\"\n#include \"MTLTypes.hpp\"\n\nnamespace MTL\n{\nclass VisibleFunctionTableDescriptor : public NS::Copying<VisibleFunctionTableDescriptor>\n{\npublic:\n    static class VisibleFunctionTableDescriptor* alloc();\n\n    class VisibleFunctionTableDescriptor*        init();\n\n    static class VisibleFunctionTableDescriptor* visibleFunctionTableDescriptor();\n\n    NS::UInteger                                 functionCount() const;\n    void                                         setFunctionCount(NS::UInteger functionCount);\n};\n\nclass VisibleFunctionTable : public NS::Referencing<VisibleFunctionTable, Resource>\n{\npublic:\n    MTL::ResourceID gpuResourceID() const;\n\n    void            setFunction(const class FunctionHandle* function, NS::UInteger index);\n\n    void            setFunctions(const class FunctionHandle* const functions[], NS::Range range);\n};\n\n}\n\n\n_MTL_INLINE MTL::VisibleFunctionTableDescriptor* MTL::VisibleFunctionTableDescriptor::alloc()\n{\n    return NS::Object::alloc<MTL::VisibleFunctionTableDescriptor>(_MTL_PRIVATE_CLS(MTLVisibleFunctionTableDescriptor));\n}\n\n\n_MTL_INLINE MTL::VisibleFunctionTableDescriptor* MTL::VisibleFunctionTableDescriptor::init()\n{\n    return NS::Object::init<MTL::VisibleFunctionTableDescriptor>();\n}\n\n\n_MTL_INLINE MTL::VisibleFunctionTableDescriptor* MTL::VisibleFunctionTableDescriptor::visibleFunctionTableDescriptor()\n{\n    return Object::sendMessage<MTL::VisibleFunctionTableDescriptor*>(_MTL_PRIVATE_CLS(MTLVisibleFunctionTableDescriptor), _MTL_PRIVATE_SEL(visibleFunctionTableDescriptor));\n}\n\n\n_MTL_INLINE NS::UInteger MTL::VisibleFunctionTableDescriptor::functionCount() const\n{\n    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(functionCount));\n}\n\n_MTL_INLINE void MTL::VisibleFunctionTableDescriptor::setFunctionCount(NS::UInteger functionCount)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctionCount_), functionCount);\n}\n\n\n_MTL_INLINE MTL::ResourceID MTL::VisibleFunctionTable::gpuResourceID() const\n{\n    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));\n}\n\n\n_MTL_INLINE void MTL::VisibleFunctionTable::setFunction(const MTL::FunctionHandle* function, NS::UInteger index)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunction_atIndex_), function, index);\n}\n\n\n_MTL_INLINE void MTL::VisibleFunctionTable::setFunctions(const MTL::FunctionHandle* const functions[], NS::Range range)\n{\n    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctions_withRange_), functions, range);\n}\n\n'Tempest/Engine/gapi/metal/mtdescriptorarray.cpp'\n:#if defined(TEMPEST_BUILD_METAL)\n\n#include \"mtdescriptorarray.h\"\n\n#include \"mtdevice.h\"\n#include \"mttexture.h\"\n#include \"mtbuffer.h\"\n#include \"mtpipelinelay.h\"\n#include \"mtaccelerationstructure.h\"\n#include \"mtshader.h\"\n\nusing namespace Tempest;\nusing namespace Tempest::Detail;\n\nMtDescriptorArray::MtDescriptorArray(MtDevice& dev, const MtPipelineLay &lay)\n  :dev(dev), lay(&lay), desc(lay.lay.size()), bufferSizeBuffer(lay.bufferSizeBuffer) {\n  }\n\nvoid MtDescriptorArray::set(size_t id, AbstractGraphicsApi::Texture *tex, const Sampler &smp, uint32_t mipLevel) {\n  auto& t = *reinterpret_cast<MtTexture*>(tex);\n  desc[id].val     = &t.view(smp.mapping,mipLevel);\n  desc[id].sampler = &dev.samplers.get(smp);\n  if(t.linearMem!=nullptr)\n    desc[id].valAtom = t.linearMem.get(); else\n    desc[id].valAtom = nullptr;\n  }\n\nvoid MtDescriptorArray::set(size_t id, const Sampler& smp) {\n  desc[id].val     = nullptr;\n  desc[id].sampler = &dev.samplers.get(smp);\n  }\n\nvoid MtDescriptorArray::set(size_t id, AbstractGraphicsApi::Buffer *buf, size_t offset) {\n  if(T_UNLIKELY(buf==nullptr)) {\n    desc[id].val    = nullptr;\n    desc[id].offset = offset;\n    desc[id].length = 0;\n    return;\n    }\n\n  auto& b = *reinterpret_cast<MtBuffer*>(buf);\n  desc[id].val    = b.impl.get();\n  desc[id].offset = offset;\n  desc[id].length = b.size - offset;\n  }\n\nvoid MtDescriptorArray::set(size_t id, AbstractGraphicsApi::AccelerationStructure* a) {\n  auto& as = *reinterpret_cast<MtTopAccelerationStructure*>(a);\n  desc[id].val  = as.impl.get();\n  desc[id].tlas = &as;\n  }\n\nvoid MtDescriptorArray::set(size_t id, AbstractGraphicsApi::Texture** tex, size_t cnt,\n                            const Sampler& smp, uint32_t mipLevel) {\n  auto& d   = desc[id];\n  auto  cls = lay.handler->lay[id].cls;\n\n  size_t shift = 0;\n  size_t bufSz = cnt*sizeof(MTL::ResourceID);\n  if(cls==ShaderReflection::Texture) {\n    bufSz  = ((bufSz+16-1)/16)*16;\n    shift  = bufSz;\n    bufSz += cnt*sizeof(MTL::ResourceID);\n    }\n  d.argsBuf = MtBuffer(dev, nullptr, bufSz, MTL::ResourceStorageModePrivate);\n\n  std::unique_ptr<uint8_t[]> addr(new uint8_t[bufSz]);\n  d.args.reserve(cnt);\n  d.args.clear();\n  for(size_t i=0; i<cnt; ++i) {\n    auto* ptr = reinterpret_cast<MTL::ResourceID*>(addr.get());\n    if(tex[i]==nullptr) {\n      ptr[i] = MTL::ResourceID{0};\n      continue;\n      }\n    auto& t    = *reinterpret_cast<MtTexture*>(tex[i]);\n    auto& view = t.view(smp.mapping,mipLevel);\n    ptr[i]     = view.gpuResourceID();\n    d.args.push_back(reinterpret_cast<MtTexture*>(tex[i])->impl.get());\n    }\n\n  if(cls==ShaderReflection::Texture) {\n    auto& sampler = dev.samplers.get(smp,true);\n    auto* ptr     = reinterpret_cast<MTL::ResourceID*>(addr.get() + shift);\n    for(size_t i=0; i<cnt; ++i) {\n      ptr[i] = sampler.gpuResourceID();\n      }\n    }\n\n  d.argsBuf.update(addr.get(), 0, bufSz);\n  }\n\nvoid MtDescriptorArray::set(size_t id, AbstractGraphicsApi::Buffer** buf, size_t cnt) {\n  auto& d = desc[id];\n\n  struct spvBufferDescriptor {\n    uint64_t ptr;\n    uint32_t len;\n\n    };\n  d.argsBuf = MtBuffer(dev, nullptr, cnt*sizeof(spvBufferDescriptor), MTL::ResourceStorageModePrivate);\n\n  std::unique_ptr<spvBufferDescriptor[]> addr(new spvBufferDescriptor[cnt]);\n  d.args.reserve(cnt);\n  d.args.clear();\n  for(size_t i=0; i<cnt; ++i) {\n    if(buf[i]==nullptr) {\n      addr[i].ptr = 0;\n      addr[i].len = 0;\n      continue;\n      }\n    addr[i].ptr = reinterpret_cast<MtBuffer*>(buf[i])->impl->gpuAddress();\n    addr[i].len = uint32_t(reinterpret_cast<MtBuffer*>(buf[i])->size);\n    d.args.push_back(reinterpret_cast<MtBuffer*>(buf[i])->impl.get());\n    }\n  d.argsBuf.update(addr.get(), 0, cnt*sizeof(spvBufferDescriptor));\n  }\n\nvoid MtDescriptorArray::fillBufferSizeBuffer(uint32_t* ret, ShaderReflection::Stage stage, const MtPipelineLay& lay) {\n  auto& lx  = lay.lay;\n  auto& mtl = lay.bind;\n  for(size_t i=0; i<lx.size(); ++i) {\n    if(lx[i].cls==ShaderReflection::SsboR ||\n       lx[i].cls==ShaderReflection::SsboRW) {\n      uint32_t at = uint32_t(-1);\n      switch(stage) {\n        case ShaderReflection::None:\n        case ShaderReflection::Control:\n        case ShaderReflection::Evaluate:\n        case ShaderReflection::Geometry:\n          break;\n        case ShaderReflection::Task:\n          at = mtl[i].bindTs;\n          break;\n        case ShaderReflection::Mesh:\n          at = mtl[i].bindMs;\n          break;\n        case ShaderReflection::Vertex:\n          at = mtl[i].bindVs;\n          break;\n        case ShaderReflection::Fragment:\n          at = mtl[i].bindFs;\n          break;\n        case ShaderReflection::Compute:\n          at = mtl[i].bindCs;\n          break;\n        }\n      if(at==uint32_t(-1))\n        continue;\n      ret[at] = uint32_t(desc[i].length);\n      }\n    }\n  }\n\nvoid MtDescriptorArray::useResource(MTL::ComputeCommandEncoder& cmd) {\n  implUseResource(cmd);\n  }\n\nvoid MtDescriptorArray::useResource(MTL::RenderCommandEncoder& cmd) {\n  implUseResource(cmd);\n  }\n\ntemplate<class Enc>\nvoid MtDescriptorArray::implUseResource(Enc&  cmd) {\n  auto& lx  = lay.handler->lay;\n  auto& mtl = lay.handler->bind;\n  for(size_t i=0; i<lx.size(); ++i) {\n    if(lx[i].cls==ShaderReflection::Tlas) {\n      auto& blas   = desc[i].tlas->blas;\n      auto  stages = nativeFormat(lx[i].stage);\n      implUseResource(cmd, blas.data(), blas.size(), MTL::ResourceUsageRead, stages);\n      }\n    if(lx[i].runtimeSized) {\n      auto& args  = desc[i].args;\n      auto  stages = nativeFormat(lx[i].stage);\n      implUseResource(cmd, args.data(), args.size(), MTL::ResourceUsageRead | MTL::ResourceUsageSample, stages);\n      }\n    }\n  }\n\nvoid MtDescriptorArray::implUseResource(MTL::ComputeCommandEncoder& cmd,\n                                        const MTL::Resource* const resources[], NS::UInteger count,\n                                        MTL::ResourceUsage usage, MTL::RenderStages stages) {\n  (void)stages;\n  cmd.useResources(resources, count, usage);\n  }\n\nvoid MtDescriptorArray::implUseResource(MTL::RenderCommandEncoder& cmd,\n                                        const MTL::Resource* const resources[], NS::UInteger count,\n                                        MTL::ResourceUsage usage, MTL::RenderStages stages) {\n  cmd.useResources(resources, count, usage, stages);\n  }\n\n#endif\n\n'Tempest/Engine/gapi/metal/mtsamplercache.h'\n:#pragma once\n\n#include <Tempest/AbstractGraphicsApi>\n#include <Metal/Metal.hpp>\n#include <mutex>\n\n#include \"nsptr.h\"\n\nnamespace Tempest {\nnamespace Detail {\n\nclass MtDevice;\n\nclass MtSamplerCache {\n  public:\n    MtSamplerCache(MTL::Device& dev);\n    ~MtSamplerCache();\n\n    MTL::SamplerState& get(Sampler src, bool argBuffers=false);\n\n  private:\n    NsPtr<MTL::SamplerState> mkSampler(const Sampler& src, bool argBuffers);\n\n    struct Entry {\n      Sampler                  src;\n      bool                     argBuffers = false;\n      NsPtr<MTL::SamplerState> val;\n      };\n\n    MTL::Device&             dev;\n    NsPtr<MTL::SamplerState> def;\n\n    std::mutex               sync;\n    std::vector<Entry>       values;\n  };\n\n}\n}\n\n'Tempest/Engine/gapi/metal/mtdevice.h'\n:#pragma once\n\n#include <Tempest/AbstractGraphicsApi>\n#include <Tempest/AccelerationStructure>\n#include <Tempest/RenderState>\n#include <Tempest/Except>\n\n#include <Metal/Metal.hpp>\n#include <Foundation/Foundation.hpp>\n\n#include \"../utility/compiller_hints.h\"\n#include \"gapi/shaderreflection.h\"\n#include \"mtsamplercache.h\"\n#include \"nsptr.h\"\n\nclass MTLDevice;\n\nnamespace Tempest {\nnamespace Detail {\n\ninline MTL::PixelFormat nativeFormat(TextureFormat frm) {\n  switch(frm) {\n    case Undefined:\n    case Last:\n      return MTL::PixelFormatInvalid;\n    case R8:\n      return MTL::PixelFormatR8Unorm;\n    case RG8:\n      return MTL::PixelFormatRG8Unorm;\n    case RGB8:\n      return MTL::PixelFormatInvalid;\n    case RGBA8:\n      return MTL::PixelFormatRGBA8Unorm;\n    case R16:\n      return MTL::PixelFormatR16Unorm;\n    case RG16:\n      return MTL::PixelFormatRG16Unorm;\n    case RGB16:\n      return MTL::PixelFormatInvalid;\n    case RGBA16:\n      return MTL::PixelFormatRGBA16Unorm;\n    case R32F:\n      return MTL::PixelFormatR32Float;\n    case RG32F:\n      return MTL::PixelFormatRG32Float;\n    case RGB32F:\n      return MTL::PixelFormatInvalid;\n    case RGBA32F:\n      return MTL::PixelFormatRGBA32Float;\n    case R32U:\n      return MTL::PixelFormatR32Uint;\n    case RG32U:\n      return MTL::PixelFormatRG32Uint;\n    case RGB32U:\n      return MTL::PixelFormatInvalid;\n    case RGBA32U:\n      return MTL::PixelFormatRGBA32Uint;\n    case Depth16:\n      return MTL::PixelFormatDepth16Unorm;\n    case Depth24x8:\n      return MTL::PixelFormatInvalid;\n    case Depth24S8:\n      return MTL::PixelFormatDepth24Unorm_Stencil8;\n    case Depth32F:\n      return MTL::PixelFormatDepth32Float;\n    case DXT1:\n      return MTL::PixelFormatBC1_RGBA;\n    case DXT3:\n      return MTL::PixelFormatBC2_RGBA;\n    case DXT5:\n      return MTL::PixelFormatBC3_RGBA;\n    case R11G11B10UF:\n      return MTL::PixelFormatRG11B10Float;\n    case RGBA16F:\n      return MTL::PixelFormatRGBA16Float;\n    }\n  return MTL::PixelFormatInvalid;\n  }\n\ninline MTL::VertexFormat nativeFormat(Decl::ComponentType t) {\n  switch(t) {\n    case Decl::ComponentType::count:\n    case Decl::ComponentType::float0:\n      return MTL::VertexFormatInvalid;\n    case Decl::ComponentType::float1:\n      return MTL::VertexFormatFloat;\n    case Decl::ComponentType::float2:\n      return MTL::VertexFormatFloat2;\n    case Decl::ComponentType::float3:\n      return MTL::VertexFormatFloat3;\n    case Decl::ComponentType::float4:\n      return MTL::VertexFormatFloat4;\n\n    case Decl::ComponentType::int1:\n      return MTL::VertexFormatInt;\n    case Decl::ComponentType::int2:\n      return MTL::VertexFormatInt2;\n    case Decl::ComponentType::int3:\n      return MTL::VertexFormatInt3;\n    case Decl::ComponentType::int4:\n      return MTL::VertexFormatInt4;\n\n    case Decl::ComponentType::uint1:\n      return MTL::VertexFormatUInt;\n    case Decl::ComponentType::uint2:\n      return MTL::VertexFormatUInt2;\n    case Decl::ComponentType::uint3:\n      return MTL::VertexFormatUInt3;\n    case Decl::ComponentType::uint4:\n      return MTL::VertexFormatUInt4;\n    }\n  return MTL::VertexFormatInvalid;\n  }\n\ninline MTL::CompareFunction nativeFormat(RenderState::ZTestMode m) {\n  switch(m) {\n    case RenderState::ZTestMode::Always:\n      return MTL::CompareFunctionAlways;\n    case RenderState::ZTestMode::Never:\n      return MTL::CompareFunctionNever;\n    case RenderState::ZTestMode::Greater:\n      return MTL::CompareFunctionGreater;\n    case RenderState::ZTestMode::Less:\n      return MTL::CompareFunctionLess;\n    case RenderState::ZTestMode::GEqual:\n      return MTL::CompareFunctionGreaterEqual;\n    case RenderState::ZTestMode::LEqual:\n      return MTL::CompareFunctionLessEqual;\n    case RenderState::ZTestMode::NoEqual:\n      return MTL::CompareFunctionNotEqual;\n    case RenderState::ZTestMode::Equal:\n      return MTL::CompareFunctionEqual;\n    }\n  return MTL::CompareFunctionAlways;\n  }\n\ninline MTL::BlendFactor nativeFormat(RenderState::BlendMode m) {\n  switch(m) {\n    case RenderState::BlendMode::Zero:\n      return MTL::BlendFactorZero;\n    case RenderState::BlendMode::One:\n      return MTL::BlendFactorOne;\n    case RenderState::BlendMode::SrcColor:\n      return MTL::BlendFactorSourceColor;\n    case RenderState::BlendMode::OneMinusSrcColor:\n      return MTL::BlendFactorOneMinusSourceColor;\n    case RenderState::BlendMode::SrcAlpha:\n      return MTL::BlendFactorSourceAlpha;\n    case RenderState::BlendMode::SrcAlphaSaturate:\n      return MTL::BlendFactorSourceAlphaSaturated;\n    case RenderState::BlendMode::OneMinusSrcAlpha:\n      return MTL::BlendFactorOneMinusSourceAlpha;\n    case RenderState::BlendMode::DstColor:\n      return MTL::BlendFactorDestinationColor;\n    case RenderState::BlendMode::OneMinusDstColor:\n      return MTL::BlendFactorOneMinusDestinationColor;\n    case RenderState::BlendMode::DstAlpha:\n      return MTL::BlendFactorDestinationAlpha;\n    case RenderState::BlendMode::OneMinusDstAlpha:\n      return MTL::BlendFactorOneMinusDestinationAlpha;\n    }\n  return MTL::BlendFactorZero;\n  }\n\ninline MTL::BlendOperation nativeFormat(RenderState::BlendOp op) {\n  switch(op) {\n    case RenderState::BlendOp::Add:\n      return MTL::BlendOperationAdd;\n    case RenderState::BlendOp::Max:\n      return MTL::BlendOperationMax;\n    case RenderState::BlendOp::Min:\n      return MTL::BlendOperationMin;\n    case RenderState::BlendOp::ReverseSubtract:\n      return MTL::BlendOperationReverseSubtract;\n    case RenderState::BlendOp::Subtract:\n      return MTL::BlendOperationSubtract;\n    }\n  return MTL::BlendOperationAdd;\n  }\n\ninline MTL::CullMode nativeFormat(RenderState::CullMode m) {\n  switch(m) {\n    case RenderState::CullMode::NoCull:\n      return MTL::CullModeNone;\n    case RenderState::CullMode::Back:\n      return MTL::CullModeBack;\n    case RenderState::CullMode::Front:\n      return MTL::CullModeFront;\n    }\n  return MTL::CullModeNone;\n  }\n\ninline MTL::PrimitiveType nativeFormat(Topology t) {\n  switch(t) {\n    case Topology::Points:    return MTL::PrimitiveTypePoint;\n    case Topology::Lines:     return MTL::PrimitiveTypeLine;\n    case Topology::Triangles: return MTL::PrimitiveTypeTriangle;\n    }\n  return MTL::PrimitiveTypePoint;\n  }\n\ninline MTL::IndexType nativeFormat(IndexClass icls) {\n  switch(icls) {\n    case IndexClass::i16: return MTL::IndexTypeUInt16;\n    case IndexClass::i32: return MTL::IndexTypeUInt32;\n    }\n  return MTL::IndexTypeUInt16;\n  }\n\ninline MTL::AccelerationStructureInstanceOptions nativeFormat(RtInstanceFlags f) {\n  MTL::AccelerationStructureInstanceOptions ret = 0;\n  if((f & RtInstanceFlags::NonOpaque)==RtInstanceFlags::NonOpaque)\n    ret |= MTL::AccelerationStructureInstanceOptionNonOpaque; else\n    ret |= MTL::AccelerationStructureInstanceOptionOpaque;\n  if((f & RtInstanceFlags::CullDisable)==RtInstanceFlags::CullDisable)\n    ret |= MTL::AccelerationStructureInstanceOptionDisableTriangleCulling;\n  if((f & RtInstanceFlags::CullFlip)==RtInstanceFlags::CullFlip)\n    ret |= MTL::AccelerationStructureInstanceOptionTriangleFrontFacingWindingCounterClockwise;\n  return ret;\n  }\n\ninline MTL::RenderStages nativeFormat(ShaderReflection::Stage st) {\n  uint32_t stageFlags = 0;\n  if(st&ShaderReflection::Compute)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Vertex)\n    stageFlags |= MTL::RenderStageVertex;\n  if(st&ShaderReflection::Control)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Evaluate)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Geometry)\n    stageFlags |= 0;\n  if(st&ShaderReflection::Fragment)\n    stageFlags |= MTL::RenderStageFragment;\n  if(st&ShaderReflection::Task)\n    stageFlags |=  MTL::RenderStageObject;\n  if(st&ShaderReflection::Mesh)\n    stageFlags |=  MTL::RenderStageMesh;\n  return MTL::RenderStages(stageFlags);\n  }\n\nclass MtDevice : public AbstractGraphicsApi::Device {\n  public:\n    MtDevice(std::string_view name, bool validation);\n    ~MtDevice();\n\n    void onSubmit();\n    void onFinish();\n    void waitIdle() override;\n\n    bool     useNativeImageAtomic() const;\n    uint32_t linearImageAlignment() const;\n\n    static void handleError(NS::Error* err);\n\n    NsPtr<MTL::Device>         impl;\n    NsPtr<MTL::CommandQueue>   queue;\n\n    std::condition_variable    devIdleCv;\n    std::mutex                 devIdleSync;\n    std::atomic_uint32_t       devCmdBuf{0};\n\n    AbstractGraphicsApi::Props prop;\n    MtSamplerCache             samplers;\n    bool                       validation = false;\n    MTL::LanguageVersion       mslVersion = MTL::LanguageVersion2_0;\n    uint32_t                   ui32align  = 0;\n\n    static void deductProps(AbstractGraphicsApi::Props& prop, MTL::Device& dev);\n  };\n\ninline void mtAssert(void* obj, NS::Error* err) {\n  if(T_LIKELY(obj!=nullptr))\n    return;\n  MtDevice::handleError(err);\n  }\n\n}\n}\n\n'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#pragma once\n\n\n\n#include \"MTLAccelerationStructure.hpp\"\n#include \"MTLAccelerationStructureCommandEncoder.hpp\"\n#include \"MTLAccelerationStructureTypes.hpp\"\n#include \"MTLArgument.hpp\"\n#include \"MTLArgumentEncoder.hpp\"\n#include \"MTLBinaryArchive.hpp\"\n#include \"MTLBlitCommandEncoder.hpp\"\n#include \"MTLBlitPass.hpp\"\n#include \"MTLBuffer.hpp\"\n#include \"MTLCaptureManager.hpp\"\n#include \"MTLCaptureScope.hpp\"\n#include \"MTLCommandBuffer.hpp\"\n#include \"MTLCommandEncoder.hpp\"\n#include \"MTLCommandQueue.hpp\"\n#include \"MTLComputeCommandEncoder.hpp\"\n#include \"MTLComputePass.hpp\"\n#include \"MTLComputePipeline.hpp\"\n#include \"MTLCounters.hpp\"\n#include \"MTLDefines.hpp\"\n#include \"MTLDepthStencil.hpp\"\n#include \"MTLDevice.hpp\"\n#include \"MTLDrawable.hpp\"\n#include \"MTLDynamicLibrary.hpp\"\n#include \"MTLEvent.hpp\"\n#include \"MTLFence.hpp\"\n#include \"MTLFunctionConstantValues.hpp\"\n#include \"MTLFunctionDescriptor.hpp\"\n#include \"MTLFunctionHandle.hpp\"\n#include \"MTLFunctionLog.hpp\"\n#include \"MTLFunctionStitching.hpp\"\n#include \"MTLHeaderBridge.hpp\"\n#include \"MTLHeap.hpp\"\n#include \"MTLIndirectCommandBuffer.hpp\"\n#include \"MTLIndirectCommandEncoder.hpp\"\n#include \"MTLIntersectionFunctionTable.hpp\"\n#include \"MTLIOCommandBuffer.hpp\"\n#include \"MTLIOCommandQueue.hpp\"\n#include \"MTLIOCompressor.hpp\"\n#include \"MTLLibrary.hpp\"\n#include \"MTLLinkedFunctions.hpp\"\n#include \"MTLParallelRenderCommandEncoder.hpp\"\n#include \"MTLPipeline.hpp\"\n#include \"MTLPixelFormat.hpp\"\n#include \"MTLPrivate.hpp\"\n#include \"MTLRasterizationRate.hpp\"\n#include \"MTLRenderCommandEncoder.hpp\"\n#include \"MTLRenderPass.hpp\"\n#include \"MTLRenderPipeline.hpp\"\n#include \"MTLResource.hpp\"\n#include \"MTLResourceStateCommandEncoder.hpp\"\n#include \"MTLResourceStatePass.hpp\"\n#include \"MTLSampler.hpp\"\n#include \"MTLStageInputOutputDescriptor.hpp\"\n#include \"MTLTexture.hpp\"\n#include \"MTLTypes.hpp\"\n#include \"MTLVertexDescriptor.hpp\"\n#include \"MTLVisibleFunctionTable.hpp\"\n#include \"MTLVersion.hpp\"\n\n\n",
        "gt": [
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/MTLVisibleFunctionTable.hpp'",
            "'Tempest/Engine/thirdparty/metal-cpp/Metal/Metal.hpp'",
            "'Tempest/Engine/gapi/metal/mtsamplercache.h'",
            "'Tempest/Engine/gapi/metal/mtdevice.h'",
            "'Tempest/Engine/gapi/metal/mtdescriptorarray.cpp'"
        ]
    },
    {
        "files": [
            "'OpenSPH/core/physics/Units.h'",
            "'OpenSPH/core/physics/Units.cpp'",
            "'OpenSPH/core/objects/containers/FlatMap.h'",
            "'OpenSPH/core/objects/containers/Tags.h'"
        ],
        "content": "'OpenSPH/core/physics/Units.h'\n:#pragma once\n\n#include \"math/MathUtils.h\"\n#include \"objects/containers/FlatMap.h\"\n#include \"objects/containers/StaticArray.h\"\n#include \"objects/wrappers/Expected.h\"\n#include \"physics/Constants.h\"\n\nNAMESPACE_SPH_BEGIN\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nenum class BasicDimension {\n    LENGTH,\n    MASS,\n    TIME,\n    ANGLE,\n};\n\nconstexpr Size DIMENSION_CNT = 4;\n\n\nclass UnitDimensions {\nprivate:\n    StaticArray<int, DIMENSION_CNT> values;\n\npublic:\n    UnitDimensions() = default;\n\n    UnitDimensions(const BasicDimension& basicDimension) {\n        values.fill(0);\n        values[int(basicDimension)] = 1;\n    }\n\n    UnitDimensions(const UnitDimensions& other) {\n        for (Size i = 0; i < DIMENSION_CNT; ++i) {\n            values[i] = other.values[i];\n        }\n    }\n\n    UnitDimensions(const int length, const int mass, const int time, const int angle)\n        : values{ length, mass, time, angle } {}\n\n    UnitDimensions& operator=(const UnitDimensions& other) {\n        for (Size i = 0; i < DIMENSION_CNT; ++i) {\n            values[i] = other.values[i];\n        }\n        return *this;\n    }\n\n    int& operator[](const BasicDimension dim) {\n        return values[int(dim)];\n    }\n\n    int operator[](const BasicDimension dim) const {\n        return values[int(dim)];\n    }\n\n    UnitDimensions& operator+=(const UnitDimensions& other) {\n        for (Size i = 0; i < DIMENSION_CNT; ++i) {\n            values[i] += other.values[i];\n        }\n        return *this;\n    }\n\n    UnitDimensions& operator-=(const UnitDimensions& other) {\n        for (Size i = 0; i < DIMENSION_CNT; ++i) {\n            values[i] -= other.values[i];\n        }\n        return *this;\n    }\n\n    friend UnitDimensions operator+(const UnitDimensions& dim1, const UnitDimensions& dim2) {\n        UnitDimensions sum(dim1);\n        sum += dim2;\n        return sum;\n    }\n\n    friend UnitDimensions operator-(const UnitDimensions& dim1, const UnitDimensions& dim2) {\n        UnitDimensions diff(dim1);\n        diff -= dim2;\n        return diff;\n    }\n\n    UnitDimensions operator-() const {\n        UnitDimensions dims;\n        for (Size i = 0; i < DIMENSION_CNT; ++i) {\n            dims.values[i] = -values[i];\n        }\n        return dims;\n    }\n\n    UnitDimensions& operator*=(const int mult) {\n        for (Size i = 0; i < DIMENSION_CNT; ++i) {\n            values[i] *= mult;\n        }\n        return *this;\n    }\n\n    friend UnitDimensions operator*(const UnitDimensions& dim, const int mult) {\n        UnitDimensions result(dim);\n        result *= mult;\n        return result;\n    }\n\n    friend UnitDimensions operator*(const int mult, const UnitDimensions& dim) {\n        return dim * mult;\n    }\n\n\n    bool operator==(const UnitDimensions& other) const {\n        return values == other.values;\n    }\n\n    bool operator!=(const UnitDimensions& other) const {\n        return values != other.values;\n    }\n\n    static UnitDimensions dimensionless() {\n        return { 0, 0, 0, 0 };\n    }\n\n    static UnitDimensions length() {\n        return BasicDimension::LENGTH;\n    }\n\n    static UnitDimensions mass() {\n        return BasicDimension::MASS;\n    }\n\n    static UnitDimensions time() {\n        return BasicDimension::TIME;\n    }\n\n    static UnitDimensions velocity() {\n        return length() - time();\n    }\n\n    static UnitDimensions acceleration() {\n        return length() - 2 * time();\n    }\n\n    static UnitDimensions area() {\n        return 2 * length();\n    }\n\n    static UnitDimensions volume() {\n        return 3 * length();\n    }\n\n    static UnitDimensions density() {\n        return mass() - volume();\n    }\n\n    static UnitDimensions numberDensity() {\n        return -volume();\n    }\n\n    static UnitDimensions force() {\n        return mass() + acceleration();\n    }\n\n    static UnitDimensions energy() {\n        return force() + length();\n    }\n\n    static UnitDimensions energyDensity() {\n        return energy() - volume();\n    }\n\n    static UnitDimensions power() {\n        return energy() - time();\n    }\n};\n\n\nclass UnitSystem {\nprivate:\n    StaticArray<Float, DIMENSION_CNT> coeffs;\n\npublic:\n    UnitSystem() = default;\n\n    UnitSystem(const UnitSystem& other) {\n        for (Size i = 0; i < DIMENSION_CNT; ++i) {\n            coeffs[i] = other.coeffs[i];\n        }\n    }\n\n    UnitSystem(const Float length, const Float mass, const Float time, const Float angle)\n        : coeffs{ length, mass, time, angle } {}\n\n\n    Float getFactor(const UnitDimensions& dimensions) const {\n        Float factor = 1._f;\n        for (Size i = 0; i < DIMENSION_CNT; ++i) {\n            factor *= pow(coeffs[i], Float(dimensions[BasicDimension(i)]));\n        }\n        return factor;\n    }\n\n    Float& operator[](const BasicDimension dim) {\n        return coeffs[int(dim)];\n    }\n\n    Float operator[](const BasicDimension dim) const {\n        return coeffs[int(dim)];\n    }\n\n    static UnitSystem SI() {\n        return { 1._f, 1._f, 1._f, 1._f };\n    }\n\n    static UnitSystem CGS() {\n        return { 0.01_f, 0.001_f, 1._f, 1._f };\n    }\n};\n\nextern UnitSystem CODE_UNITS;\n\n\nclass Unit {\nprivate:\n    Float data;\n    UnitDimensions dimensions;\n\npublic:\n    Unit() = default;\n\n\n    Unit(const Float& value, const UnitDimensions& dimensions, const UnitSystem& system)\n        : dimensions(dimensions) {\n\n        const Float conversion = system.getFactor(dimensions) / CODE_UNITS.getFactor(dimensions);\n        this->data = conversion * value;\n    }\n\n\n    Float value(const UnitSystem& system) const {\n        return data / system.getFactor(dimensions);\n    }\n\n    UnitDimensions dimension() const {\n        return dimensions;\n    }\n\n\n    Unit& operator+=(const Unit& other) {\n        SPH_ASSERT(dimensions == other.dimensions);\n        data += other.data;\n        return *this;\n    }\n\n    Unit& operator-=(const Unit& other) {\n        SPH_ASSERT(dimensions == other.dimensions);\n        data -= other.data;\n        return *this;\n    }\n\n    Unit operator-() const {\n        Unit neg;\n        neg.dimensions = dimensions;\n        neg.data = -data;\n        return neg;\n    }\n\n    Unit& operator*=(const Float f) {\n        data *= f;\n        return *this;\n    }\n\n    Unit& operator*=(const Unit& other) {\n        data *= other.data;\n        dimensions += other.dimensions;\n        return *this;\n    }\n\n    Unit& operator/=(const Unit& other) {\n        data /= other.data;\n        dimensions -= other.dimensions;\n        return *this;\n    }\n\n    bool operator==(const Unit& other) const {\n        SPH_ASSERT(dimensions == other.dimensions);\n        return data == other.data;\n    }\n\n    bool operator!=(const Unit& other) const {\n        return !(*this == other);\n    }\n\n    bool operator<(const Unit& other) const {\n        SPH_ASSERT(dimensions == other.dimensions);\n        return data < other.data;\n    }\n\n    bool operator<=(const Unit& other) const {\n        SPH_ASSERT(dimensions == other.dimensions);\n        return data <= other.data;\n    }\n\n    bool operator>(const Unit& other) const {\n        return !(*this <= other);\n    }\n\n    bool operator>=(const Unit& other) const {\n        return !(*this < other);\n    }\n\n\n\n\n\n\n\n\n    friend std::ostream& operator<<(std::ostream& stream, const Unit& u);\n\n    friend Unit pow(const Unit& u, const int power) {\n        Unit result;\n        result.data = pow(u.data, Float(power));\n        result.dimensions = u.dimensions * power;\n        return result;\n    }\n\n    friend bool almostEqual(const Unit& u1, const Unit& u2, const Float eps) {\n        SPH_ASSERT(u1.dimensions == u2.dimensions);\n        return Sph::almostEqual(u1.data, u2.data, eps);\n    }\n\n    static Unit dimensionless(const Float value) {\n        return Unit(value, UnitDimensions(0, 0, 0, 0), UnitSystem::SI());\n    }\n\n    static Unit kilogram(const Float value) {\n        return Unit(value, BasicDimension::MASS, UnitSystem::SI());\n    }\n\n    static Unit meter(const Float value) {\n        return Unit(value, BasicDimension::LENGTH, UnitSystem::SI());\n    }\n\n    static Unit second(const Float value) {\n        return Unit(value, BasicDimension::TIME, UnitSystem::SI());\n    }\n\n    static Unit radian(const Float value) {\n        return Unit(value, BasicDimension::ANGLE, UnitSystem::SI());\n    }\n};\n\ninline Unit operator+(const Unit& u1, const Unit& u2) {\n    Unit sum(u1);\n    sum += u2;\n    return sum;\n}\n\ninline Unit operator-(const Unit& u1, const Unit& u2) {\n    Unit diff(u1);\n    diff -= u2;\n    return diff;\n}\n\ninline Unit operator*(const Unit& u, const Float f) {\n    Unit mult(u);\n    mult *= f;\n    return mult;\n}\n\ninline Unit operator*(const Float f, const Unit& u) {\n    return u * f;\n}\n\ninline Unit operator*(const Unit& u1, const Unit& u2) {\n    Unit mult(u1);\n    mult *= u2;\n    return mult;\n}\n\ninline Unit operator/(const Unit& u1, const Unit& u2) {\n    Unit div(u1);\n    div /= u2;\n    return div;\n}\n\n\n\n\n\nINLINE Unit operator\"\" _kg(long double value) {\n    return Unit::kilogram(Float(value));\n}\nINLINE Unit operator\"\" _g(long double value) {\n    return 1.e-3_kg * Float(value);\n}\nINLINE Unit operator\"\" _m(long double value) {\n    return Unit::meter(Float(value));\n}\nINLINE Unit operator\"\" _cm(long double value) {\n    return 0.01_m * Float(value);\n}\nINLINE Unit operator\"\" _mm(long double value) {\n    return 1.e-3_m * Float(value);\n}\nINLINE Unit operator\"\" _km(long double value) {\n    return 1.e3_m * Float(value);\n}\nINLINE Unit operator\"\" _s(long double value) {\n    return Unit::second(Float(value));\n}\nINLINE Unit operator\"\" _rad(long double value) {\n    return Unit::radian(Float(value));\n}\nINLINE Unit operator\"\" _mps(long double value) {\n    return Unit(Float(value), UnitDimensions::velocity(), UnitSystem::SI());\n}\n\nExpected<Unit> parseUnit(const String& text);\n\n\n\n\n\nNAMESPACE_SPH_END\n\n'OpenSPH/core/physics/Units.cpp'\n:#include \"physics/Units.h\"\n#include \"objects/containers/FlatSet.h\"\n\nNAMESPACE_SPH_BEGIN\n\nUnitSystem CODE_UNITS = UnitSystem::SI();\n\nstruct UnitDesc {\n    String label;\n    Unit unit;\n\n    bool operator<(const UnitDesc& other) const {\n        return unit < other.unit;\n    }\n};\n\nFlatMap<BasicDimension, FlatSet<UnitDesc>> UNITS = [] {\n    FlatSet<UnitDesc> length(ELEMENTS_UNIQUE,\n        {\n            { \"mm\", 1._mm },\n            { \"cm\", 1._cm },\n            { \"m\", 1._m },\n            { \"km\", 1._km },\n            { \"au\", Unit::meter(Constants::au) },\n        });\n    FlatSet<UnitDesc> mass(ELEMENTS_UNIQUE,\n        {\n            { \"g\", 1.e-3_kg },\n            { \"kg\", 1._kg },\n            { \"M_sun\", Unit::kilogram(Constants::M_sun) },\n            { \"M_earth\", Unit::kilogram(Constants::M_earth) },\n        });\n    FlatSet<UnitDesc> time(ELEMENTS_UNIQUE,\n        {\n            { \"s\", 1._s },\n            { \"min\", 60._s },\n            { \"h\", 3600._s },\n            { \"d\", 86400._s },\n            { \"y\", 31556926._s },\n        });\n    FlatSet<UnitDesc> angle(ELEMENTS_UNIQUE,\n        {\n            { \"rad\", 1._rad },\n        });\n\n    FlatMap<BasicDimension, FlatSet<UnitDesc>> units;\n    units.insert(BasicDimension::LENGTH, std::move(length));\n    units.insert(BasicDimension::MASS, std::move(mass));\n    units.insert(BasicDimension::TIME, std::move(time));\n    units.insert(BasicDimension::ANGLE, std::move(angle));\n    return units;\n}();\n\nstd::ostream& operator<<(std::ostream& stream, const Unit& u) {\n    if (u.dimension() == UnitDimensions::dimensionless()) {\n        stream << u.value(UnitSystem::SI());\n    } else {\n        BasicDimension dim = BasicDimension(-1);\n        for (Size i = 0; i < DIMENSION_CNT; ++i) {\n            const int power = u.dimension()[BasicDimension(i)];\n            if (power != 0) {\n                dim = BasicDimension(i);\n                break;\n            }\n        }\n        SPH_ASSERT(dim != BasicDimension(-1));\n\n        UnitSystem system = CODE_UNITS;\n        Optional<UnitDesc> selectedDesc;\n        for (UnitDesc& desc : UNITS[dim]) {\n            if (!selectedDesc) {\n                selectedDesc = desc;\n            } else {\n                system[dim] = desc.unit.value(CODE_UNITS);\n                if (u.value(system) >= 1._f) {\n                    selectedDesc = desc;\n                }\n            }\n        }\n        system[dim] = selectedDesc->unit.value(CODE_UNITS);\n        stream << u.value(system) << selectedDesc->label;\n        if (u.dimension()[dim] != 1) {\n            stream << \"^\" << u.dimension()[dim];\n        }\n    }\n\n    return stream;\n}\n\nExpected<Unit> parseUnit(const String& text) {\n    Unit u = Unit::dimensionless(1._f);\n    Array<String> parts = split(text, ' ');\n    for (String& part : parts) {\n        if (part.empty()) {\n\n            continue;\n        }\n        Array<String> valueAndPower = split(part, '^');\n        if (valueAndPower.size() > 2) {\n            return makeUnexpected<Unit>(\"More than one exponent\");\n        }\n        SPH_ASSERT(valueAndPower.size() == 1 || valueAndPower.size() == 2);\n        int power;\n        if (valueAndPower.size() == 1) {\n\n            power = 1;\n            (void)power;\n        } else {\n            if (Optional<int> optPower = fromString<int>(valueAndPower[1])) {\n                power = optPower.value();\n            } else {\n                return makeUnexpected<Unit>(\"Cannot convert power to int\");\n            }\n        }\n    }\n    return u;\n}\n\nNAMESPACE_SPH_END\n\n'OpenSPH/core/objects/containers/FlatMap.h'\n:#pragma once\n\n\n\n\n\n\n#include \"objects/containers/Array.h\"\n#include \"objects/containers/Tags.h\"\n#include \"objects/wrappers/Optional.h\"\n#include <algorithm>\n\nNAMESPACE_SPH_BEGIN\n\n\n\n\n\ntemplate <typename TKey, typename TValue, typename TLess = std::less<TKey>>\nclass FlatMap : TLess, Noncopyable {\npublic:\n\n    class Element {\n        TKey k;\n        TValue v;\n\n    public:\n        Element() = default;\n        Element(const TKey& k, const TValue& v)\n            : k(k)\n            , v(v) {}\n        Element(const TKey& k, TValue&& v)\n            : k(k)\n            , v(std::move(v)) {}\n\n        INLINE const TKey& key() const {\n            return k;\n        }\n\n        INLINE const TValue& value() const {\n            return v;\n        }\n\n        INLINE TValue& value() {\n            return v;\n        }\n    };\n\nprivate:\n    Array<Element> data;\n\npublic:\n    FlatMap() = default;\n\n\n\n\n\n    template <typename Tag>\n    FlatMap(Tag t, std::initializer_list<Element> list)\n        : data(list) {\n        this->create(t);\n    }\n\n\n\n\n\n    template <typename Tag>\n    FlatMap(Tag t, Array<Element>&& values)\n        : data(std::move(values)) {\n        this->create(t);\n    }\n\n\n\n\n    INLINE TValue& operator[](const TKey& key) {\n        Element* element = this->find(key);\n        SPH_ASSERT(element);\n        return element->value();\n    }\n\n\n\n\n    INLINE const TValue& operator[](const TKey& key) const {\n        const Element* element = this->find(key);\n        SPH_ASSERT(element);\n        return element->value();\n    }\n\n\n    INLINE TValue& insert(const TKey& key, const TValue& value) {\n        Element* element = this->find(key);\n        if (!element) {\n            return this->add(key, value);\n        } else {\n            element->value() = value;\n            return element->value();\n        }\n    }\n\n\n    INLINE TValue& insert(const TKey& key, TValue&& value) {\n        Element* element = this->find(key);\n        if (!element) {\n            return this->add(key, std::move(value));\n        } else {\n            element->value() = std::move(value);\n            return element->value();\n        }\n    }\n\n\n\n\n    INLINE void remove(const TKey& key) {\n        Element* element = this->find(key);\n        SPH_ASSERT(element);\n        const Size index = element - &data[0];\n        data.remove(index);\n    }\n\n\n\n\n    INLINE bool tryRemove(const TKey& key) {\n        Element* element = this->find(key);\n        if (!element) {\n            return false;\n        } else {\n            const Size index = Size(element - &data[0]);\n            data.remove(index);\n            return true;\n        }\n    }\n\n\n    INLINE void clear() {\n        data.clear();\n    }\n\n\n\n\n    INLINE Optional<TValue&> tryGet(const TKey& key) {\n        Element* element = this->find(key);\n        if (!element) {\n            return NOTHING;\n        } else {\n            return element->value();\n        }\n    }\n\n\n    INLINE Optional<const TValue&> tryGet(const TKey& key) const {\n        const Element* element = this->find(key);\n        if (!element) {\n            return NOTHING;\n        } else {\n            return element->value();\n        }\n    }\n\n\n\n\n    INLINE bool contains(const TKey& key) const {\n        return this->find(key) != nullptr;\n    }\n\n\n    INLINE Size size() const {\n        return data.size();\n    }\n\n\n    INLINE Size empty() const {\n        return data.empty();\n    }\n\n\n    INLINE Iterator<Element> begin() {\n        return data.begin();\n    }\n\n\n    INLINE Iterator<const Element> begin() const {\n        return data.begin();\n    }\n\n\n    INLINE Iterator<Element> end() {\n        return data.end();\n    }\n\n\n    INLINE Iterator<const Element> end() const {\n        return data.end();\n    }\n\n    INLINE operator ArrayView<Element>() {\n        return data;\n    }\n\n    INLINE operator ArrayView<const Element>() const {\n        return data;\n    }\n\n    FlatMap clone() const {\n        FlatMap cloned;\n        cloned.data = data.clone();\n        return cloned;\n    }\n\nprivate:\n    void create(ElementsCommonTag) {\n        std::sort(data.begin(), data.end(), [this](const Element& e1, const Element& e2) {\n            return less(e1.key(), e2.key());\n        });\n        auto end = std::unique(data.begin(), data.end(), [this](const Element& e1, const Element& e2) {\n            return equal(e1.key(), e2.key());\n        });\n        data.resize(end - data.begin());\n        SPH_ASSERT(this->keysSortedAndUnique());\n    }\n\n    void create(ElementsUniqueTag) {\n        std::sort(data.begin(), data.end(), [this](const Element& e1, const Element& e2) {\n            return less(e1.key(), e2.key());\n        });\n        SPH_ASSERT(this->keysSortedAndUnique());\n    }\n\n    void create(ElementsSortedUniqueTag) {\n        SPH_ASSERT(this->keysSortedAndUnique());\n    }\n\n    bool keysSortedAndUnique() const {\n        if (!std::is_sorted(data.begin(), data.end(), [this](const Element& e1, const Element& e2) {\n                return less(e1.key(), e2.key());\n            })) {\n            return false;\n        }\n\n        for (Size i = 1; i < data.size(); ++i) {\n            if (equal(data[i].key(), data[i - 1].key())) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    INLINE bool less(const TKey& key1, const TKey& key2) const {\n        return TLess::operator()(key1, key2);\n    }\n\n    INLINE bool equal(const TKey& key1, const TKey& key2) const {\n        return !less(key1, key2) && !less(key2, key1);\n    }\n\n\n    INLINE Element* find(const TKey& key) {\n        auto compare = [this](const Element& element, const TKey& key) { return less(element.key(), key); };\n        auto iter = std::lower_bound(data.begin(), data.end(), key, compare);\n        if (iter != data.end() && equal(iter->key(), key)) {\n            return &*iter;\n        } else {\n            return nullptr;\n        }\n    }\n\n    INLINE const Element* find(const TKey& key) const {\n        return const_cast<FlatMap*>(this)->find(key);\n    }\n\n\n    template <typename T>\n    INLINE TValue& add(const TKey& key, T&& value) {\n        Size from = 0;\n        Size to = data.size();\n        Size mid = Size(-1);\n\n        while (from < to && from != mid) {\n            mid = (from + to) / 2;\n            SPH_ASSERT(!equal(data[mid].key(), key));\n            if (less(data[mid].key(), key)) {\n                from = mid + 1;\n            } else {\n                to = mid;\n            }\n        }\n        data.insert(from, Element{ key, std::forward<T>(value) });\n        return data[from].value();\n    }\n};\n\n\nNAMESPACE_SPH_END\n\n'OpenSPH/core/objects/containers/Tags.h'\n:#pragma once\n\n#include \"common/Assert.h\"\n\nNAMESPACE_SPH_BEGIN\n\n\nstruct ElementsCommonTag {};\n\nconst ElementsCommonTag ELEMENTS_COMMON;\n\n\nstruct ElementsUniqueTag {};\n\nconst ElementsUniqueTag ELEMENTS_UNIQUE;\n\n\nstruct ElementsSortedUniqueTag {};\n\nconst ElementsSortedUniqueTag ELEMENTS_SORTED_UNIQUE;\n\nNAMESPACE_SPH_END\n",
        "gt": [
            "'OpenSPH/core/objects/containers/Tags.h'",
            "'OpenSPH/core/objects/containers/FlatMap.h'",
            "'OpenSPH/core/physics/Units.h'",
            "'OpenSPH/core/physics/Units.cpp'"
        ]
    },
    {
        "files": [
            "'nymea/libnymea/types/statedescriptor.h'",
            "'nymea/libnymea-core/nymeacore.h'",
            "'nymea/libnymea/types/state.h'",
            "'nymea/libnymea-core/ruleengine/rule.h'",
            "'nymea/libnymea-core/ruleengine/stateevaluator.h'",
            "'nymea/server/nymeaapplication.cpp'"
        ],
        "content": "'nymea/libnymea/types/statedescriptor.h'\n:\n\n#ifndef STATEDESCRIPTOR_H\n#define STATEDESCRIPTOR_H\n\n#include \"libnymea.h\"\n#include \"typeutils.h\"\n#include \"paramdescriptor.h\"\n#include \"state.h\"\n#include \"event.h\"\n\n#include <QString>\n#include <QVariantList>\n#include <QDebug>\n\nclass LIBNYMEA_EXPORT StateDescriptor\n{\n    Q_GADGET\n    Q_PROPERTY(QUuid stateTypeId READ stateTypeId WRITE setStateTypeId USER true)\n    Q_PROPERTY(QUuid thingId READ thingId WRITE setThingId USER true)\n    Q_PROPERTY(QString interface READ interface WRITE setInterface USER true)\n    Q_PROPERTY(QString interfaceState READ interfaceState WRITE setInterfaceState USER true)\n    Q_PROPERTY(QVariant value READ stateValue WRITE setStateValue USER true)\n    Q_PROPERTY(QUuid valueThingId READ valueThingId WRITE setValueThingId USER true)\n    Q_PROPERTY(QUuid valueStateTypeId READ valueStateTypeId WRITE setValueStateTypeId USER true)\n    Q_PROPERTY(Types::ValueOperator operator READ operatorType WRITE setOperatorType)\npublic:\n    enum Type {\n        TypeThing,\n        TypeInterface\n    };\n\n    StateDescriptor();\n    StateDescriptor(const StateTypeId &stateTypeId, const ThingId &thingId, const QVariant &stateValue, Types::ValueOperator operatorType = Types::ValueOperatorEquals);\n    StateDescriptor(const QString &interface, const QString &interfaceState, const QVariant &stateValue, Types::ValueOperator operatorType = Types::ValueOperatorEquals);\n\n    Type type() const;\n\n    StateTypeId stateTypeId() const;\n    void setStateTypeId(const StateTypeId &stateTypeId);\n\n    ThingId thingId() const;\n    void setThingId(const ThingId &thingId);\n\n    QString interface() const;\n    void setInterface(const QString &interface);\n\n    QString interfaceState() const;\n    void setInterfaceState(const QString &interfaceState);\n\n    QVariant stateValue() const;\n    void setStateValue(const QVariant &value);\n\n    ThingId valueThingId() const;\n    void setValueThingId(const ThingId &valueThingId);\n\n    StateTypeId valueStateTypeId() const;\n    void setValueStateTypeId(const StateTypeId &valueStateTypeId);\n\n    Types::ValueOperator operatorType() const;\n    void setOperatorType(Types::ValueOperator opertatorType);\n\n    Q_INVOKABLE bool isValid() const;\n\n    bool operator ==(const StateDescriptor &other) const;\n\nprivate:\n    StateTypeId m_stateTypeId;\n    ThingId m_thingId;\n    QString m_interface;\n    QString m_interfaceState;\n    QVariant m_stateValue;\n    ThingId m_valueThingId;\n    StateTypeId m_valueStateTypeId;\n    Types::ValueOperator m_operatorType = Types::ValueOperatorEquals;\n};\nQ_DECLARE_METATYPE(StateDescriptor)\n\nQDebug operator<<(QDebug dbg, const StateDescriptor &stateDescriptor);\n\n#endif\n\n'nymea/libnymea-core/nymeacore.h'\n:\n\n#ifndef NYMEACORE_H\n#define NYMEACORE_H\n\n#include \"types/event.h\"\n#include \"types/thingclass.h\"\n#include \"integrations/integrationplugin.h\"\n#include \"integrations/thingdescriptor.h\"\n#include \"integrations/thingmanagerimplementation.h\"\n\n#include \"ruleengine/rule.h\"\n#include \"ruleengine/ruleengine.h\"\n\n#include \"servermanager.h\"\n\n#include \"time/timemanager.h\"\n#include \"hardwaremanagerimplementation.h\"\n\n#include \"debugserverhandler.h\"\n\n#include <QObject>\n\nclass Thing;\nclass LogEngine;\nclass Logger;\n\nclass NetworkManager;\n\nnamespace nymeaserver {\n\nclass JsonRPCServerImplementation;\nclass NymeaConfiguration;\nclass TagsStorage;\nclass UserManager;\nclass Platform;\nclass System;\nclass ExperienceManager;\nclass CloudManager;\nclass ZigbeeManager;\nclass ZWaveManager;\nclass ModbusRtuManager;\nclass SerialPortMonitor;\n\nnamespace scriptengine {\nclass ScriptEngine;\n}\nusing namespace scriptengine;\n\nclass NymeaCore : public QObject\n{\n    Q_OBJECT\n    friend class NymeaTestBase;\n\npublic:\n    enum ShutdownReason {\n        ShutdownReasonQuit,\n        ShutdownReasonTerm,\n        ShutdownReasonFailure,\n        ShutdownReasonRestart\n    };\n    Q_ENUM(ShutdownReason)\n\n    static NymeaCore* instance();\n    ~NymeaCore();\n\n    void init(const QStringList &additionalInterfaces = QStringList(), bool disableLogEngine = false);\n    void destroy(nymeaserver::NymeaCore::ShutdownReason reason);\n\n    RuleEngine::RuleError removeRule(const RuleId &id);\n\n    NymeaConfiguration *configuration() const;\n    LogEngine* logEngine() const;\n    JsonRPCServerImplementation *jsonRPCServer() const;\n    ThingManager *thingManager() const;\n    RuleEngine *ruleEngine() const;\n    ScriptEngine *scriptEngine() const;\n    TimeManager *timeManager() const;\n    ServerManager *serverManager() const;\n    BluetoothServer *bluetoothServer() const;\n    NetworkManager *networkManager() const;\n    UserManager *userManager() const;\n    CloudManager *cloudManager() const;\n    DebugServerHandler *debugServerHandler() const;\n    TagsStorage *tagsStorage() const;\n    Platform *platform() const;\n    ZigbeeManager *zigbeeManager() const;\n    ZWaveManager *zwaveManager() const;\n    ModbusRtuManager *modbusRtuManager() const;\n    ExperienceManager *experienceManager() const;\n\n    static QStringList getAvailableLanguages();\n    static QStringList loggingFilters();\n    static QStringList loggingFiltersPlugins();\n\nsignals:\n    void initialized();\n\nprivate:\n\n    explicit NymeaCore(QObject *parent = nullptr);\n    static NymeaCore *s_instance;\n    static ShutdownReason s_shutdownReason;\n\n    Platform *m_platform = nullptr;\n\n    NymeaConfiguration *m_configuration = nullptr;\n    ServerManager *m_serverManager = nullptr;\n    ThingManagerImplementation *m_thingManager = nullptr;\n    RuleEngine *m_ruleEngine = nullptr;\n    ScriptEngine *m_scriptEngine = nullptr;\n    LogEngine *m_logEngine = nullptr;\n    Logger *m_logger = nullptr;\n    TimeManager *m_timeManager = nullptr;\n    CloudManager *m_cloudManager = nullptr;\n    HardwareManagerImplementation *m_hardwareManager = nullptr;\n    DebugServerHandler *m_debugServerHandler = nullptr;\n    TagsStorage *m_tagsStorage = nullptr;\n\n    NetworkManager *m_networkManager = nullptr;\n    UserManager *m_userManager = nullptr;\n    System *m_system = nullptr;\n    ExperienceManager *m_experienceManager = nullptr;\n    ZigbeeManager *m_zigbeeManager = nullptr;\n    ZWaveManager *m_zwaveManager = nullptr;\n    SerialPortMonitor *m_serialPortMonitor = nullptr;\n    ModbusRtuManager *m_modbusRtuManager = nullptr;\n\n\nprivate slots:\n    void thingManagerLoaded();\n\n};\n\n}\n\n#endif\n\n'nymea/libnymea/types/state.h'\n:\n\n#ifndef STATE_H\n#define STATE_H\n\n#include \"libnymea.h\"\n#include \"typeutils.h\"\n\n#include <QVariant>\n#include <QDebug>\n\nclass LIBNYMEA_EXPORT State\n{\n    Q_GADGET\n    Q_PROPERTY(QUuid stateTypeId READ stateTypeId)\n    Q_PROPERTY(QVariant value READ value)\n    Q_PROPERTY(Types::StateValueFilter filter READ filter)\n    Q_PROPERTY(QVariant minValue READ minValue USER true)\n    Q_PROPERTY(QVariant maxValue READ maxValue USER true)\n    Q_PROPERTY(QVariantList possibleValues READ possibleValues USER true)\n\npublic:\n    State();\n    State(const StateTypeId &stateTypeId, const ThingId &thingId);\n\n    StateTypeId stateTypeId() const;\n    ThingId thingId() const;\n\n    QVariant value() const;\n\n    QVariant minValue() const;\n    QVariant maxValue() const;\n\n    QVariantList possibleValues() const;\n\n    Types::StateValueFilter filter() const;\n\nprivate:\n    friend class Thing;\n    void setValue(const QVariant &value);\n    void setMinValue(const QVariant &minValue);\n    void setMaxValue(const QVariant &maxValue);\n    void setPossibleValues(const QVariantList &values);\n    void setFilter(Types::StateValueFilter filter);\n\nprivate:\n    StateTypeId m_stateTypeId;\n    ThingId m_thingId;\n    QVariant m_value;\n    QVariant m_minValue;\n    QVariant m_maxValue;\n    QVariantList m_possibleValues;\n    Types::StateValueFilter m_filter = Types::StateValueFilterNone;\n};\nQ_DECLARE_METATYPE(State)\n\nclass States: public QList<State>\n{\n    Q_GADGET\n    Q_PROPERTY(int count READ count)\npublic:\n    States();\n    States(const QList<State> &other);\n    States(std::initializer_list<State> args):QList(args) {}\n    Q_INVOKABLE QVariant get(int index) const;\n    Q_INVOKABLE void put(const QVariant &variant);\n    Q_INVOKABLE QVariant stateValue(const StateTypeId &stateTypeId);\n};\nQ_DECLARE_METATYPE(States)\n\nQDebug operator<<(QDebug dbg, const State &event);\nQDebug operator<<(QDebug dbg, const QList<State> &events);\n\n#endif\n\n'nymea/libnymea-core/ruleengine/rule.h'\n:\n\n#ifndef RULE_H\n#define RULE_H\n\n#include \"types/state.h\"\n#include \"types/eventdescriptor.h\"\n#include \"time/timedescriptor.h\"\n#include \"ruleaction.h\"\n#include \"stateevaluator.h\"\n\n#include <QUuid>\n\nnamespace nymeaserver {\n\nclass Rule\n{\n    Q_GADGET\n    Q_PROPERTY(QUuid id READ id)\n    Q_PROPERTY(QString name READ name WRITE setName)\n    Q_PROPERTY(bool active READ active)\n    Q_PROPERTY(bool enabled READ enabled WRITE setEnabled USER true)\n    Q_PROPERTY(bool executable READ executable WRITE setExecutable USER true)\n    Q_PROPERTY(EventDescriptors eventDescriptors READ eventDescriptors WRITE setEventDescriptors USER true)\n    Q_PROPERTY(RuleActions actions READ actions WRITE setActions)\n    Q_PROPERTY(RuleActions exitActions READ exitActions WRITE setExitActions USER true)\n    Q_PROPERTY(nymeaserver::StateEvaluator stateEvaluator READ stateEvaluator WRITE setStateEvaluator USER true)\n    Q_PROPERTY(TimeDescriptor timeDescriptor READ timeDescriptor WRITE setTimeDescriptor USER true)\n\npublic:\n    Rule();\n\n    RuleId id() const;\n    void setId(const RuleId &ruleId);\n\n    QString name() const;\n    void setName(const QString &name);\n\n    bool active() const;\n    bool statesActive() const;\n    bool timeActive() const;\n\n    TimeDescriptor timeDescriptor() const;\n    void setTimeDescriptor(const TimeDescriptor &timeDescriptor);\n\n    StateEvaluator stateEvaluator() const;\n    void setStateEvaluator(const StateEvaluator &stateEvaluator);\n\n    EventDescriptors eventDescriptors() const;\n    void setEventDescriptors(const EventDescriptors &eventDescriptors);\n\n    RuleActions actions() const;\n    void setActions(const RuleActions actions);\n\n    RuleActions exitActions() const;\n    void setExitActions(const RuleActions exitActions);\n\n    bool enabled() const;\n    void setEnabled(const bool &enabled);\n\n    bool executable() const;\n    void setExecutable(const bool &executable);\n\n\n    bool isValid() const;\n    bool isConsistent() const;\n\nprivate:\n    friend class RuleEngine;\n    void setStatesActive(const bool &statesActive);\n    void setTimeActive(const bool &timeActive);\n    void setActive(const bool &active);\n\nprivate:\n    RuleId m_id;\n    QString m_name;\n    TimeDescriptor m_timeDescriptor;\n    StateEvaluator m_stateEvaluator;\n    EventDescriptors m_eventDescriptors;\n    RuleActions m_actions;\n    RuleActions m_exitActions;\n\n    bool m_enabled;\n    bool m_active;\n    bool m_statesActive;\n    bool m_timeActive;\n    bool m_executable;\n};\n\nclass Rules: QList<Rule>\n{\n    Q_GADGET\n    Q_PROPERTY(int count READ count)\npublic:\n    Rules();\n    Rules(const QList<Rule> &other);\n    Q_INVOKABLE QVariant get(int index) const;\n    Q_INVOKABLE void put(const QVariant &variant);\n};\n\nQDebug operator<<(QDebug dbg, const Rule &rule);\n\n}\nQ_DECLARE_METATYPE(nymeaserver::Rules)\n\n#endif\n\n'nymea/libnymea-core/ruleengine/stateevaluator.h'\n:\n\n#ifndef STATEEVALUATOR_H\n#define STATEEVALUATOR_H\n\n#include \"types/state.h\"\n#include \"types/statedescriptor.h\"\n\n#include <QDebug>\n\nclass NymeaSettings;\n\nnamespace nymeaserver {\nclass StateEvaluator;\n\nclass StateEvaluators: public QList<StateEvaluator>\n{\n    Q_GADGET\n    Q_PROPERTY(int count READ count)\npublic:\n    StateEvaluators();\n    StateEvaluators(const QList<StateEvaluator> &other);\n    Q_INVOKABLE QVariant get(int index) const;\n    Q_INVOKABLE void put(const QVariant &variant);\n};\n\nclass StateEvaluator\n{\n    Q_GADGET\n    Q_PROPERTY(StateDescriptor stateDescriptor READ stateDescriptor WRITE setStateDescriptor USER true)\n    Q_PROPERTY(nymeaserver::StateEvaluators childEvaluators READ childEvaluators WRITE setChildEvaluators USER true)\n    Q_PROPERTY(Types::StateOperator operator READ operatorType WRITE setOperatorType USER true)\npublic:\n    StateEvaluator(const StateDescriptor &stateDescriptor);\n    StateEvaluator(QList<StateEvaluator> childEvaluators = QList<StateEvaluator>(), Types::StateOperator stateOperator = Types::StateOperatorAnd);\n\n    StateDescriptor stateDescriptor() const;\n    void setStateDescriptor(const StateDescriptor &stateDescriptor);\n\n    StateEvaluators childEvaluators() const;\n    void setChildEvaluators(const StateEvaluators &childEvaluators);\n    void appendEvaluator(const StateEvaluator &stateEvaluator);\n\n    Types::StateOperator operatorType() const;\n    void setOperatorType(Types::StateOperator operatorType);\n\n    bool evaluate() const;\n    bool containsThing(const ThingId &thingId) const;\n\n    void removeThing(const ThingId &thingId);\n    QList<ThingId> containedThings() const;\n\n    void dumpToSettings(NymeaSettings &settings, const QString &groupName) const;\n    static StateEvaluator loadFromSettings(NymeaSettings &settings, const QString &groupPrefix);\n\n    bool isValid() const;\n    bool isEmpty() const;\n\nprivate:\n    bool evaluateDescriptor(const StateDescriptor &descriptor) const;\n\nprivate:\n    StateDescriptor m_stateDescriptor;\n\n    QList<StateEvaluator> m_childEvaluators;\n    Types::StateOperator m_operatorType;\n};\n\n\nQDebug operator<<(QDebug dbg, const StateEvaluator &stateEvaluator);\n\n}\nQ_DECLARE_METATYPE(nymeaserver::StateEvaluator)\nQ_DECLARE_METATYPE(nymeaserver::StateEvaluators)\n\n#endif\n\n'nymea/server/nymeaapplication.cpp'\n:\n\n\n\n#include \"nymeaapplication.h\"\n#include \"loggingcategories.h\"\n#include \"nymeacore.h\"\n\n#include <execinfo.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <cxxabi.h>\n\nQ_DECLARE_LOGGING_CATEGORY(dcApplication)\n\nnamespace nymeaserver {\n\nstatic int s_shutdownCounter = 0;\n\nstatic void catchUnixSignals(const std::vector<int>& quitSignals, const std::vector<int>& ignoreSignals = std::vector<int>())\n{\n    auto handler = [](int sig) ->void {\n\n\n        if (s_shutdownCounter > 0) {\n            if (s_shutdownCounter < 4) {\n                qCCritical(dcApplication()) << \"Shutdown in progress.\" << (4 - s_shutdownCounter) << \"more times to abort.\";\n                s_shutdownCounter++;\n                return;\n            }\n            exit(EXIT_FAILURE);\n            return;\n        }\n\n        NymeaCore::ShutdownReason reason = NymeaCore::ShutdownReasonQuit;\n        switch (sig) {\n        case SIGQUIT:\n            qCDebug(dcApplication) << \"Cought SIGQUIT signal...\";\n            reason = NymeaCore::ShutdownReasonQuit;\n            break;\n        case SIGINT:\n            qCDebug(dcApplication) << \"Cought SIGINT signal...\";\n            reason = NymeaCore::ShutdownReasonTerm;\n            break;\n        case SIGTERM:\n            qCDebug(dcApplication) << \"Cought SIGTERM signal...\";\n            reason = NymeaCore::ShutdownReasonTerm;\n            break;\n        case SIGHUP:\n            qCDebug(dcApplication) << \"Cought SIGHUP signal...\";\n            reason = NymeaCore::ShutdownReasonTerm;\n            break;\n        case SIGKILL:\n            qCDebug(dcApplication) << \"Cought SIGKILL signal...\";\n            reason = NymeaCore::ShutdownReasonTerm;\n            break;\n        case SIGSEGV:\n            qCDebug(dcApplication) << \"Cought SIGSEGV quit signal...\";\n            reason = NymeaCore::ShutdownReasonFailure;\n            break;\n        case SIGFPE:\n            qCDebug(dcApplication) << \"Cought SIGFPE quit signal...\";\n            reason = NymeaCore::ShutdownReasonFailure;\n            break;\n        default:\n            qCDebug(dcApplication) << \"Cought signal\" << sig;\n            break;\n        }\n\n        qCInfo(dcApplication) << \"=====================================\";\n        qCInfo(dcApplication) << \"Shutting down nymea:core\";\n        qCInfo(dcApplication) << \"=====================================\";\n\n        s_shutdownCounter++;\n        NymeaCore::instance()->destroy(reason);\n        NymeaApplication::quit();\n    };\n\n\n    for (int sig : ignoreSignals)\n        signal(sig, SIG_IGN);\n\n    for (int sig : quitSignals)\n        signal(sig, handler);\n}\n\n\n\nNymeaApplication::NymeaApplication(int &argc, char **argv) :\n    QCoreApplication(argc, argv)\n{\n\n    catchUnixSignals({SIGQUIT, SIGINT, SIGTERM, SIGHUP, SIGKILL,  SIGFPE});\n}\n\n}\n",
        "gt": [
            "'nymea/libnymea/types/state.h'",
            "'nymea/libnymea/types/statedescriptor.h'",
            "'nymea/libnymea-core/ruleengine/stateevaluator.h'",
            "'nymea/libnymea-core/ruleengine/rule.h'",
            "'nymea/libnymea-core/nymeacore.h'",
            "'nymea/server/nymeaapplication.cpp'"
        ]
    },
    {
        "files": [
            "'TinyGarble/scd/v_2_scd.h'",
            "'TinyGarble/scd/scheduling.h'",
            "'TinyGarble/scd/scheduling.cpp'"
        ],
        "content": "'TinyGarble/scd/v_2_scd.h'\n:\n\n#ifndef SCD_V_2_SCD_H_\n#define SCD_V_2_SCD_H_\n\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <utility>\nusing std::vector;\nusing std::pair;\nusing std::string;\n\nclass ReadGateString {\n public:\n  string input[2];\n  string output;\n  short type;\n};\n\nclass ReadCircuitString {\n\n public:\n  vector<ReadGateString> gate_list_string;\n  vector<ReadGateString> dff_list_string;\n  vector<pair<string, string>> assignment_list_string;\n  uint64_t p_init_size;\n  uint64_t g_init_size;\n  uint64_t e_init_size;\n  uint64_t p_input_size;\n  uint64_t g_input_size;\n  uint64_t e_input_size;\n  uint64_t output_size;\n  bool     has_terminate;\n\n  ReadCircuitString()\n      : gate_list_string(0),\n        dff_list_string(0) {\n    p_init_size = 0;\n    g_init_size = 0;\n    e_init_size = 0;\n    p_input_size = 0;\n    g_input_size = 0;\n    e_input_size = 0;\n    output_size = 0;\n    has_terminate = false;\n  }\n};\n\nclass ReadGate {\n public:\n  int64_t input[2];\n  int64_t output;\n  short type;\n};\n\nclass ReadCircuit {\n\n public:\n  vector<uint64_t> output_list;\n  vector<ReadGate> gate_list;\n  vector<ReadGate> dff_list;\n  vector<uint64_t> task_schedule;\n\n  uint64_t p_init_size;\n  uint64_t g_init_size;\n  uint64_t e_init_size;\n  uint64_t p_input_size;\n  uint64_t g_input_size;\n  uint64_t e_input_size;\n  uint64_t dff_size;\n  uint64_t gate_size;\n  uint64_t output_size;\n  uint64_t terminate_id;\n\n  uint64_t get_init_input_size() const {\n    return p_init_size + g_init_size + e_init_size + p_input_size + g_input_size\n        + e_input_size;\n  }\n\n  ReadCircuit()\n      : output_list(0),\n        gate_list(0),\n        dff_list(0),\n        task_schedule(0) {\n    p_init_size = 0;\n    g_init_size = 0;\n    e_init_size = 0;\n    p_input_size = 0;\n    g_input_size = 0;\n    e_input_size = 0;\n    dff_size = 0;\n    gate_size = 0;\n    output_size = 0;\n    terminate_id = 0;\n  }\n};\n\nint Verilog2SCD(const string &in_file_name, const string& out_mapping_filename,\n                const string &out_file_name);\nint Bris2SCD(const string &in_file_name, const string& out_mapping_filename,\n             const string &out_file_name);\n#endif\n\n'TinyGarble/scd/scheduling.h'\n:\n\n#ifndef SCD_SCHEDULING_H_\n#define SCD_SCHEDULING_H_\n\n#include \"scd/v_2_scd.h\"\n\nint SortNetlist(ReadCircuit* read_circuit,\n                const ReadCircuitString& read_circuit_string);\nint WriteMapping(const ReadCircuitString& read_circuit_string,\n                 const ReadCircuit &read_circuit,\n                 const string& out_mapping_filename);\n\n#endif\n\n'TinyGarble/scd/scheduling.cpp'\n:\n\n#include \"scd/scheduling.h\"\n\n#include <string>\n#include <cstring>\n#include \"scd/parse_netlist.h\"\n#include \"util/common.h\"\n#include \"util/log.h\"\n\nint QuickSort(int64_t *arr, int64_t *index, int64_t left, int64_t right) {\n  int64_t i = left, j = right;\n  int64_t tmp;\n  int64_t pivot = arr[(left + right) / 2];\n\n\n  while (i <= j) {\n    while (arr[i] > pivot)\n      i++;\n    while (arr[j] < pivot)\n      j--;\n    if (i <= j) {\n      tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n\n      tmp = index[i];\n      index[i] = index[j];\n      index[j] = tmp;\n\n      i++;\n      j--;\n    }\n  }\n\n  if (left < j)\n    QuickSort(arr, index, left, j);\n  if (i < right)\n    QuickSort(arr, index, i, right);\n\n  return SUCCESS;\n}\n\nint TopSort(const vector<ReadGate>& G, int64_t no_task, int64_t *index) {\n\n\n  int64_t *sl = new int64_t[no_task];\n\n  for (int64_t i = 0; i < no_task; i++)\n    index[i] = i;\n\n  for (int64_t i = no_task - 1; i >= 0; i--) {\n    int64_t max = 0;\n    for (int64_t j = i + 1; j < no_task; j++) {\n      if (G[j].input[0] == G[i].output)\n        if (sl[j] > max)\n          max = sl[j];\n      if (G[j].input[1] == G[i].output)\n        if (sl[j] > max)\n          max = sl[j];\n    }\n    sl[i] = 1 + max;\n  }\n\n\n  QuickSort(sl, index, 0, no_task - 1);\n\n  delete[] sl;\n  return SUCCESS;\n}\n\nint64_t GetMinIndex(int64_t *arr, int64_t size) {\n  int64_t minimum = arr[0], min_index = 0, i = 1;\n  while (i < size) {\n    if (arr[i] < minimum) {\n      minimum = arr[i];\n      min_index = i;\n    }\n    i++;\n  }\n  return min_index;\n}\n\nint64_t GetMax(int64_t *arr, int64_t size) {\n  int64_t maximum = arr[0], i = 1;\n  while (i < size) {\n    if (arr[i] > maximum)\n      maximum = arr[i];\n    i++;\n  }\n  return maximum;\n}\n\nint DFS(const ReadCircuit &read_circuit, vector<int> *status, int wire_index,\n        vector<int> *loop) {\n\n  const vector<ReadGate>& Gates = read_circuit.gate_list;\n  int64_t no_of_input_dff = read_circuit.get_init_input_size()\n      + read_circuit.dff_size;\n\n  if (wire_index < 0 || (*status)[wire_index] == 2) {\n    return SUCCESS;\n  } else if ((*status)[wire_index] == 1) {\n    loop->push_back(wire_index);\n    return FAILURE;\n  } else {\n    (*status)[wire_index] = 1;\n    if (DFS(read_circuit, status, Gates[wire_index - no_of_input_dff].input[0],\n            loop) == FAILURE) {\n      loop->push_back(wire_index);\n      return FAILURE;\n    }\n    if (DFS(read_circuit, status, Gates[wire_index - no_of_input_dff].input[1],\n            loop) == FAILURE) {\n      loop->push_back(wire_index);\n      return FAILURE;\n    }\n    (*status)[wire_index] = 2;\n  }\n  return SUCCESS;\n}\n\nint FindPath(const ReadCircuit &read_circuit, vector<int> *loop) {\n\n  vector<int> path;\n  int64_t no_of_input_dff = read_circuit.get_init_input_size()\n      + read_circuit.dff_size;\n  int64_t no_of_gate = read_circuit.gate_size;\n\n  vector<int> status(no_of_input_dff + no_of_gate);\n  for (int64_t i = 0; i < no_of_input_dff + no_of_gate; i++) {\n    if (i < no_of_input_dff) {\n      status[i] = 2;\n    } else {\n      status[i] = 0;\n    }\n  }\n\n  for (uint64_t i = 0; i < read_circuit.dff_size; i++) {\n    if (DFS(read_circuit, &status, read_circuit.dff_list[i].input[0],\n            loop) == FAILURE)\n      return FAILURE;\n  }\n\n  for (uint64_t i = 0; i < read_circuit.output_size; i++) {\n    if (DFS(read_circuit, &status, read_circuit.output_list[i], loop) == FAILURE)\n      return FAILURE;\n  }\n\n  for (int64_t i = 0; i < no_of_input_dff + no_of_gate; i++) {\n    if (status[i] != 2)\n      return FAILURE;\n  }\n\n  return SUCCESS;\n}\n\nint Schedule(const ReadCircuit &read_circuit, int64_t no_core, int64_t **core) {\n\n  const vector<ReadGate>& G = read_circuit.gate_list;\n  int64_t no_task;\n\n  int64_t input_size = read_circuit.get_init_input_size();\n\n  int64_t no_of_input_dff = input_size + read_circuit.dff_size;\n  no_task = read_circuit.gate_size;\n\n  vector<int> loop;\n  if (FindPath(read_circuit, &loop) != SUCCESS) {\n    LOG(ERROR) << \"There is a loop in the circuit.\" << endl;\n\n    string loop_srt = \"\";\n    for (uint64_t i = 0; i < loop.size(); i++) {\n      loop_srt += std::to_string(loop[i] - no_of_input_dff) + \" -> \";\n    }\n    LOG(ERROR) << loop_srt << endl;\n\n\n  }\n\n  int64_t *index;\n  index = new int64_t[no_task];\n  TopSort(G, no_task, index);\n\n\n  int64_t *p0, *p1, *core_busy, *core_index;\n\n  p0 = new int64_t[no_task];\n  memset(p0, -1, no_task * sizeof(int64_t));\n  p1 = new int64_t[no_task];\n  memset(p1, -1, no_task * sizeof(int64_t));\n\n  core_index = new int64_t[no_core];\n  memset(core_index, 0, no_core * sizeof(int64_t));\n  core_busy = new int64_t[no_core];\n  memset(core_busy, 0, no_core * sizeof(int64_t));\n\n  int64_t scheduled = 0;\n  while (scheduled < no_task) {\n    for (int64_t i = 0; i < no_task; i++) {\n      if (p0[index[i]] == -1) {\n        if (((G[index[i]].input[0] - no_of_input_dff < 0)\n            || (p0[G[index[i]].input[0] - no_of_input_dff] != -1))) {\n          if ((G[index[i]].input[1] - no_of_input_dff < 0)\n              || (p0[G[index[i]].input[1] - no_of_input_dff] != -1)) {\n            p1[index[i]] = GetMinIndex(core_busy, no_core);\n            core[p1[index[i]]][core_index[p1[index[i]]]] = index[i];\n            core_index[p1[index[i]]]++;\n            core_busy[p1[index[i]]] = core_busy[p1[index[i]]] + 1;\n            scheduled++;\n          }\n        }\n      }\n    }\n\n    for (int64_t i = 0; i < no_task; i++) {\n      p0[i] = p1[i];\n    }\n  }\n\n  delete[] index;\n  delete[] p0;\n  delete[] p1;\n  delete[] core_index;\n  delete[] core_busy;\n\n  return SUCCESS;\n}\n\nint TopologicalSortMultiCore(ReadCircuit &read_circuit) {\n\n  int64_t **core;\n  core = new int64_t*[1];\n  core[0] = new int64_t[read_circuit.gate_size + 1];\n  memset(core[0], -1, (read_circuit.gate_size + 1) * sizeof(uint64_t));\n\n  Schedule(read_circuit, 1, core);\n\n  read_circuit.task_schedule.resize(read_circuit.gate_size);\n\n  vector<int64_t> ts(read_circuit.gate_size);\n\n  int64_t input_size = read_circuit.get_init_input_size();\n  for (int64_t i = 0; i < (int64_t) read_circuit.gate_size; i++) {\n    read_circuit.task_schedule[i] = core[0][i];\n    ts[i] = core[0][i] + input_size + read_circuit.dff_size;\n  }\n\n  vector<int64_t> ts_1(\n      input_size + read_circuit.dff_size + read_circuit.gate_size);\n\n  for (int64_t i = 0; i < input_size + (int64_t) read_circuit.dff_size; i++) {\n    ts_1[i] = i;\n  }\n\n  for (int64_t i = 0; i < (int64_t) read_circuit.gate_size; i++) {\n    ts_1[ts[i]] = i + input_size + read_circuit.dff_size;\n  }\n  for (int64_t i = 0; i < (int64_t) read_circuit.dff_size; i++) {\n    if (read_circuit.dff_list[i].input[0] > 0) {\n      read_circuit.dff_list[i].input[0] =\n          ts_1[read_circuit.dff_list[i].input[0]];\n    }\n    if (read_circuit.dff_list[i].input[1] > 0) {\n      read_circuit.dff_list[i].input[1] =\n          ts_1[read_circuit.dff_list[i].input[1]];\n    }\n    read_circuit.dff_list[i].output = ts_1[read_circuit.dff_list[i].output];\n  }\n  for (int64_t i = 0; i < (int64_t) read_circuit.gate_size; i++) {\n    if (read_circuit.gate_list[i].input[0] > 0) {\n      read_circuit.gate_list[i].input[0] =\n          ts_1[read_circuit.gate_list[i].input[0]];\n    }\n    if (read_circuit.gate_list[i].input[1] > 0) {\n      read_circuit.gate_list[i].input[1] =\n          ts_1[read_circuit.gate_list[i].input[1]];\n    }\n    read_circuit.gate_list[i].output = ts_1[i + input_size\n        + read_circuit.dff_size];\n  }\n  for (int64_t i = 0; i < (int64_t) read_circuit.output_size; i++) {\n    read_circuit.output_list[i] = ts_1[read_circuit.output_list[i]];\n  }\n\n  LOG(INFO) << endl << \"Topological Sort\" << endl;\n  LOG(INFO) << \"dffs:\\tD\\tI\\tQ\" << endl;\n  for (int64_t i = 0; i < (int64_t) read_circuit.dff_size; i++) {\n    LOG(INFO) << i << \"\\t\" << Type2StrGate(read_circuit.dff_list[i].type)\n        << \"\\t\" << read_circuit.dff_list[i].input[0] << \"\\t\"\n        << read_circuit.dff_list[i].input[1] << \"\\t\"\n        << read_circuit.dff_list[i].output << endl;\n  }\n  LOG(INFO) << endl;\n\n  LOG(INFO) << \"gates:\\tI0\\tI1\\tO\" << endl;\n  for (int64_t i = 0; i < (int64_t) read_circuit.gate_size; i++) {\n    int64_t gid = read_circuit.task_schedule[i];\n    LOG(INFO) << i << \"\\t\" << Type2StrGate(read_circuit.gate_list[gid].type)\n        << \"\\t\" << read_circuit.gate_list[gid].input[0] << \"\\t\"\n        << read_circuit.gate_list[gid].input[1] << \"\\t\"\n        << read_circuit.gate_list[gid].output << endl;\n  }\n  LOG(INFO) << endl;\n\n  LOG(INFO) << \"outputs:\" << endl;\n  for (int64_t i = 0; i < (int64_t) read_circuit.output_size; i++) {\n    LOG(INFO) << read_circuit.output_list[i] << endl;\n  }\n  LOG(INFO) << endl;\n  delete[] core[0];\n  delete[] core;\n  return 0;\n}\n\n\nenum Mark {\n  UnMarked = 0,\n  TempMarked = 1,\n  PerMarked = 2\n};\n\nint TopologicalSortVisit(const ReadCircuit &read_circuit, vector<Mark>* marks,\n                         int64_t current_unmark_index,\n                         vector<int64_t>* sorted_list, vector<int64_t>* loop) {\n\n  int64_t init_input_size = read_circuit.get_init_input_size();\n  int64_t init_input_dff_size = init_input_size + read_circuit.dff_size;\n\n  if (current_unmark_index < 0) {\n    return SUCCESS;\n  } else if (marks->at(current_unmark_index) == Mark::TempMarked) {\n    LOG(ERROR) << \"There is a loop in the circuit.\" << endl;\n    loop->push_back(current_unmark_index);\n    return FAILURE;\n  } else if (marks->at(current_unmark_index) == Mark::UnMarked) {\n    marks->at(current_unmark_index) = Mark::TempMarked;\n\n    if (TopologicalSortVisit(\n        read_circuit,\n        marks,\n        read_circuit.gate_list[current_unmark_index - init_input_dff_size].input[0],\n        sorted_list, loop) == FAILURE) {\n      loop->push_back(current_unmark_index);\n      return FAILURE;\n    }\n    if (TopologicalSortVisit(\n        read_circuit,\n        marks,\n        read_circuit.gate_list[current_unmark_index - init_input_dff_size].input[1],\n        sorted_list, loop) == FAILURE) {\n      loop->push_back(current_unmark_index);\n      return FAILURE;\n    }\n\n    marks->at(current_unmark_index) = Mark::PerMarked;\n    sorted_list->push_back(current_unmark_index);\n  }\n\n  return SUCCESS;\n}\n\nint TopologicalSort(const ReadCircuit &read_circuit,\n                    vector<int64_t>* sorted_list,\n                    const ReadCircuitString& read_circuit_string) {\n\n  int64_t init_input_size = read_circuit.get_init_input_size();\n  int64_t init_input_dff_size = init_input_size + read_circuit.dff_size;\n\n  sorted_list->clear();\n  vector<Mark> marks(init_input_dff_size + read_circuit.gate_size,\n                     Mark::UnMarked);\n\n\n  for (int64_t i = 0; i < init_input_dff_size; i++) {\n    marks[i] = Mark::PerMarked;\n    sorted_list->push_back(i);\n  }\n\n  while (true) {\n    int64_t unmark_index = -1;\n\n    if (sorted_list->size() == init_input_dff_size + read_circuit.gate_size) {\n      break;\n    }\n    for (int64_t i = 0; i < (int64_t) read_circuit.gate_size; i++) {\n\n      if (marks[init_input_dff_size + i] == Mark::UnMarked) {\n        unmark_index = init_input_dff_size + i;\n        break;\n      }\n    }\n    if (unmark_index != -1) {\n      vector<int64_t> loop;\n      if (TopologicalSortVisit(read_circuit, &marks, unmark_index, sorted_list,\n                               &loop) == FAILURE) {\n        string loop_id_str = \"\";\n        string loop_name_str = \"\";\n        for (int64_t i = (int64_t) loop.size() - 1; i > 0; i--) {\n          loop_name_str += read_circuit_string.gate_list_string[loop[i]\n              - init_input_dff_size].output + \"->\";\n          loop_id_str += std::to_string(loop[i] - init_input_dff_size) + \"->\";\n        }\n        loop_name_str += read_circuit_string.gate_list_string[loop[0]\n            - init_input_dff_size].output;\n        loop_id_str += std::to_string(loop[0] - init_input_dff_size);\n        LOG(ERROR) << \"Loop name: \" << loop_name_str << endl << \"Loop ID: \"\n                   << loop_id_str << endl;\n        return FAILURE;\n      }\n    } else {\n      break;\n    }\n  }\n\n  CHECK_EXPR_MSG(\n      sorted_list->size() == init_input_dff_size + read_circuit.gate_size,\n      \"Some gates are not sorted.\");\n\n  return SUCCESS;\n}\n\nint SortNetlist(ReadCircuit *read_circuit,\n                const ReadCircuitString& read_circuit_string) {\n\n  int64_t init_input_size = read_circuit->get_init_input_size();\n  int64_t init_input_dff_size = init_input_size + read_circuit->dff_size;\n\n  vector<int64_t> sorted_list;\n  if (TopologicalSort(*read_circuit, &sorted_list, read_circuit_string) == FAILURE)\n    return FAILURE;\n\n  vector<int64_t> sorted_list_1(sorted_list.size());\n\n  for (int64_t i = 0; i < (int64_t) sorted_list.size(); i++) {\n    sorted_list_1[sorted_list[i]] = i;\n  }\n\n  read_circuit->task_schedule.clear();\n  read_circuit->task_schedule.resize(read_circuit->gate_list.size(), 0);\n  for (int64_t i = init_input_dff_size; i < (int64_t) sorted_list.size(); i++) {\n    read_circuit->task_schedule[i - init_input_dff_size] = sorted_list[i]\n        - init_input_dff_size;\n  }\n\n  for (int64_t i = 0; i < (int64_t) read_circuit->dff_size; i++) {\n    if (read_circuit->dff_list[i].input[0] > 0) {\n      read_circuit->dff_list[i].input[0] = sorted_list_1[read_circuit->dff_list[i]\n          .input[0]];\n    }\n    if (read_circuit->dff_list[i].input[1] > 0) {\n      read_circuit->dff_list[i].input[1] = sorted_list_1[read_circuit->dff_list[i]\n          .input[1]];\n    }\n    read_circuit->dff_list[i].output = sorted_list_1[read_circuit->dff_list[i]\n        .output];\n  }\n  for (int64_t i = 0; i < (int64_t) read_circuit->gate_size; i++) {\n    read_circuit->gate_list[i].output = sorted_list_1[init_input_dff_size + i];\n    if (read_circuit->gate_list[i].input[0] > 0) {\n      read_circuit->gate_list[i].input[0] =\n          sorted_list_1[read_circuit->gate_list[i].input[0]];\n      CHECK_EXPR_MSG(\n          read_circuit->gate_list[i].input[0] < read_circuit->gate_list[i].output,\n          \"input 0 is larger than gate id\");\n    }\n    if (read_circuit->gate_list[i].input[1] > 0) {\n      read_circuit->gate_list[i].input[1] =\n          sorted_list_1[read_circuit->gate_list[i].input[1]];\n      CHECK_EXPR_MSG(\n          read_circuit->gate_list[i].input[1] < read_circuit->gate_list[i].output,\n          \"input 1 is larger than gate id\");\n    }\n  }\n  for (int64_t i = 0; i < (int64_t) read_circuit->output_size; i++) {\n    read_circuit->output_list[i] = sorted_list_1[read_circuit->output_list[i]];\n  }\n\n  if (read_circuit->terminate_id != 0) {\n    read_circuit->terminate_id = sorted_list_1[read_circuit->terminate_id];\n  }\n\n  return SUCCESS;\n}\n\nint WriteMapping(const ReadCircuitString& read_circuit_string,\n                 const ReadCircuit &read_circuit,\n                 const string& out_mapping_filename) {\n\n  std::ofstream f(out_mapping_filename, std::ios::out);\n  if (!f.is_open()) {\n    LOG(ERROR) << \"can't open \" << out_mapping_filename << endl;\n    return FAILURE;\n  }\n\n  for (int64_t i = 0; i < (int64_t) read_circuit.dff_size; i++) {\n    f << read_circuit_string.dff_list_string[i].output << \" \"\n        << read_circuit.dff_list[i].output << endl;\n  }\n\n  for (int64_t i = 0; i < (int64_t) read_circuit.gate_size; i++) {\n    int64_t gid = read_circuit.task_schedule[i];\n    f << read_circuit_string.gate_list_string[gid].output << \" \"\n        << read_circuit.gate_list[gid].output << endl;\n  }\n\n  f << \"terminate \" << read_circuit.terminate_id << endl;\n\n  f.close();\n\n  return SUCCESS;\n}\n",
        "gt": [
            "'TinyGarble/scd/v_2_scd.h'",
            "'TinyGarble/scd/scheduling.h'",
            "'TinyGarble/scd/scheduling.cpp'"
        ]
    },
    {
        "files": [
            "'query-pdb/thirdparty/raw_pdb/src/PDB_ErrorCodes.h'",
            "'query-pdb/thirdparty/raw_pdb/src/PDB_DBIStream.h'",
            "'query-pdb/server/pdb_parser.cpp'",
            "'query-pdb/server/pdb_parser.h'"
        ],
        "content": "'query-pdb/thirdparty/raw_pdb/src/PDB_ErrorCodes.h'\n:\n\n\n#pragma once\n\n#include \"Foundation/PDB_Macros.h\"\n\n\nnamespace PDB\n{\n\tenum class PDB_NO_DISCARD ErrorCode : unsigned int\n\t{\n\t\tSuccess = 0u,\n\n\n\t\tInvalidSuperBlock,\n\t\tInvalidFreeBlockMap,\n\n\n\t\tInvalidStream,\n\t\tInvalidSignature,\n\t\tInvalidStreamIndex,\n\t\tUnknownVersion\n\t};\n}\n\n'query-pdb/thirdparty/raw_pdb/src/PDB_DBIStream.h'\n:\n\n\n#pragma once\n\n#include \"Foundation/PDB_Macros.h\"\n#include \"PDB_ErrorCodes.h\"\n#include \"PDB_DBITypes.h\"\n#include \"PDB_CoalescedMSFStream.h\"\n#include \"PDB_DirectMSFStream.h\"\n#include \"PDB_ImageSectionStream.h\"\n#include \"PDB_PublicSymbolStream.h\"\n#include \"PDB_GlobalSymbolStream.h\"\n#include \"PDB_SourceFileStream.h\"\n#include \"PDB_SectionContributionStream.h\"\n#include \"PDB_ModuleInfoStream.h\"\n\n\n\n\nnamespace PDB\n{\n\tclass RawFile;\n\n\n\tclass PDB_NO_DISCARD DBIStream\n\t{\n\tpublic:\n\t\tDBIStream(void) PDB_NO_EXCEPT;\n\t\texplicit DBIStream(const RawFile& file, const DBI::StreamHeader& header) PDB_NO_EXCEPT;\n\n\t\tPDB_DEFAULT_MOVE(DBIStream);\n\n\t\tPDB_NO_DISCARD ErrorCode HasValidImageSectionStream(const RawFile& file) const PDB_NO_EXCEPT;\n\t\tPDB_NO_DISCARD ErrorCode HasValidPublicSymbolStream(const RawFile& file) const PDB_NO_EXCEPT;\n\t\tPDB_NO_DISCARD ErrorCode HasValidGlobalSymbolStream(const RawFile& file) const PDB_NO_EXCEPT;\n\t\tPDB_NO_DISCARD ErrorCode HasValidSectionContributionStream(const RawFile& file) const PDB_NO_EXCEPT;\n\n\t\tPDB_NO_DISCARD CoalescedMSFStream CreateSymbolRecordStream(const RawFile& file) const PDB_NO_EXCEPT;\n\t\tPDB_NO_DISCARD ImageSectionStream CreateImageSectionStream(const RawFile& file) const PDB_NO_EXCEPT;\n\t\tPDB_NO_DISCARD PublicSymbolStream CreatePublicSymbolStream(const RawFile& file) const PDB_NO_EXCEPT;\n\t\tPDB_NO_DISCARD GlobalSymbolStream CreateGlobalSymbolStream(const RawFile& file) const PDB_NO_EXCEPT;\n\t\tPDB_NO_DISCARD SourceFileStream CreateSourceFileStream(const RawFile& file) const PDB_NO_EXCEPT;\n\t\tPDB_NO_DISCARD SectionContributionStream CreateSectionContributionStream(const RawFile& file) const PDB_NO_EXCEPT;\n\t\tPDB_NO_DISCARD ModuleInfoStream CreateModuleInfoStream(const RawFile& file) const PDB_NO_EXCEPT;\n\n\tprivate:\n\t\tDBI::StreamHeader m_header;\n\t\tDirectMSFStream m_stream;\n\n\t\tPDB_DISABLE_COPY(DBIStream);\n\t};\n\n\n\tPDB_NO_DISCARD ErrorCode HasValidDBIStream(const RawFile& file) PDB_NO_EXCEPT;\n\n\n\tPDB_NO_DISCARD DBIStream CreateDBIStream(const RawFile& file) PDB_NO_EXCEPT;\n}\n\n'query-pdb/server/pdb_parser.cpp'\n:#include <spdlog/spdlog.h>\n#include \"pdb_helper.h\"\n#include \"pdb_parser.h\"\n\npdb_parser::pdb_parser(const std::string &filename)\n        : file_(MemoryMappedFile::Open(filename.c_str())) {}\n\nstd::map<std::string, int64_t> pdb_parser::get_symbols(const std::set<std::string> &names) const {\n    return call_with_pdb_stream(get_symbols_impl, names);\n}\n\nstd::map<std::string, std::map<std::string, field_info>>\npdb_parser::get_struct(const std::map<std::string, std::set<std::string>> &names) const {\n    return call_with_pdb_stream(get_struct_impl, names);\n}\n\nstd::map<std::string, std::map<std::string, int64_t>>\npdb_parser::get_enum(const std::map<std::string, std::set<std::string>> &names) const {\n    return call_with_pdb_stream(get_enum_impl, names);\n}\n\nstd::map<std::string, int64_t>\npdb_parser::get_symbols_impl(\n        const PDB::RawFile &raw_file,\n        const PDB::DBIStream &dbi_stream,\n        const PDB::TPIStream &tpi_stream,\n        const std::set<std::string> &names\n) {\n    const PDB::ImageSectionStream image_section_stream =\n            dbi_stream.CreateImageSectionStream(raw_file);\n    const PDB::ModuleInfoStream module_info_stream =\n            dbi_stream.CreateModuleInfoStream(raw_file);\n    const PDB::CoalescedMSFStream symbol_record_stream =\n            dbi_stream.CreateSymbolRecordStream(raw_file);\n\n    std::map<std::string, int64_t> result;\n\n\n    const PDB::PublicSymbolStream public_symbol_stream =\n            dbi_stream.CreatePublicSymbolStream(raw_file);\n    {\n        const PDB::ArrayView<PDB::HashRecord> hash_records = public_symbol_stream.GetRecords();\n\n        for (const PDB::HashRecord &hash_record: hash_records) {\n            const PDB::CodeView::DBI::Record *record = public_symbol_stream.GetRecord(\n                    symbol_record_stream, hash_record);\n            const uint32_t rva = image_section_stream.ConvertSectionOffsetToRVA(\n                    record->data.S_PUB32.section,\n                    record->data.S_PUB32.offset);\n            if (rva == 0u) {\n\n\n                continue;\n            }\n\n            auto name = record->data.S_PUB32.name;\n            if (names.find(name) != names.end()) {\n                result.insert({name, rva});\n            }\n        }\n    }\n\n\n    const PDB::GlobalSymbolStream global_symbol_stream =\n            dbi_stream.CreateGlobalSymbolStream(raw_file);\n    {\n        const PDB::ArrayView<PDB::HashRecord> hash_records = global_symbol_stream.GetRecords();\n\n        for (const PDB::HashRecord &hash_record: hash_records) {\n            const PDB::CodeView::DBI::Record *record = global_symbol_stream.GetRecord(\n                    symbol_record_stream, hash_record);\n\n            const char *name = nullptr;\n            uint32_t rva = 0u;\n\n            if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_GDATA32) {\n                name = record->data.S_GDATA32.name;\n                rva = image_section_stream.ConvertSectionOffsetToRVA(\n                        record->data.S_GDATA32.section,\n                        record->data.S_GDATA32.offset);\n            } else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_GTHREAD32) {\n                name = record->data.S_GTHREAD32.name;\n                rva = image_section_stream.ConvertSectionOffsetToRVA(\n                        record->data.S_GTHREAD32.section,\n                        record->data.S_GTHREAD32.offset);\n            } else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_LDATA32) {\n                name = record->data.S_LDATA32.name;\n                rva = image_section_stream.ConvertSectionOffsetToRVA(\n                        record->data.S_LDATA32.section,\n                        record->data.S_LDATA32.offset);\n            } else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_LTHREAD32) {\n                name = record->data.S_LTHREAD32.name;\n                rva = image_section_stream.ConvertSectionOffsetToRVA(\n                        record->data.S_LTHREAD32.section,\n                        record->data.S_LTHREAD32.offset);\n            } else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_UDT) {\n                name = record->data.S_UDT.name;\n            } else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_UDT_ST) {\n                name = record->data.S_UDT_ST.name;\n            }\n\n            if (rva == 0u) {\n\n\n                continue;\n            }\n            if (names.find(name) != names.end()) {\n                result.insert({name, rva});\n            }\n        }\n    }\n\n\n    const PDB::ArrayView<PDB::ModuleInfoStream::Module> modules = module_info_stream.GetModules();\n\n    for (const PDB::ModuleInfoStream::Module &module: modules) {\n        if (!module.HasSymbolStream()) {\n            continue;\n        }\n\n        const PDB::ModuleSymbolStream module_symbol_stream =\n                module.CreateSymbolStream(raw_file);\n        module_symbol_stream.ForEachSymbol([&names, &result, &image_section_stream](\n                const PDB::CodeView::DBI::Record *record) {\n            const char *name = nullptr;\n            uint32_t rva = 0u;\n            if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_THUNK32) {\n                if (record->data.S_THUNK32.thunk ==\n                    PDB::CodeView::DBI::ThunkOrdinal::TrampolineIncremental) {\n\n\n                    name = \"ILT\";\n                    rva = image_section_stream.ConvertSectionOffsetToRVA(\n                            record->data.S_THUNK32.section,\n                            record->data.S_THUNK32.offset);\n                }\n            } else if (record->header.kind ==\n                       PDB::CodeView::DBI::SymbolRecordKind::S_TRAMPOLINE) {\n\n                name = \"ILT\";\n                rva = image_section_stream.ConvertSectionOffsetToRVA(\n                        record->data.S_TRAMPOLINE.thunkSection,\n                        record->data.S_TRAMPOLINE.thunkOffset);\n            } else if (record->header.kind ==\n                       PDB::CodeView::DBI::SymbolRecordKind::S_BLOCK32) {\n\n\n            } else if (record->header.kind ==\n                       PDB::CodeView::DBI::SymbolRecordKind::S_LABEL32) {\n\n            } else if (record->header.kind ==\n                       PDB::CodeView::DBI::SymbolRecordKind::S_LPROC32) {\n                name = record->data.S_LPROC32.name;\n                rva = image_section_stream.ConvertSectionOffsetToRVA(\n                        record->data.S_LPROC32.section,\n                        record->data.S_LPROC32.offset);\n            } else if (record->header.kind ==\n                       PDB::CodeView::DBI::SymbolRecordKind::S_GPROC32) {\n                name = record->data.S_GPROC32.name;\n                rva = image_section_stream.ConvertSectionOffsetToRVA(\n                        record->data.S_GPROC32.section,\n                        record->data.S_GPROC32.offset);\n            } else if (record->header.kind ==\n                       PDB::CodeView::DBI::SymbolRecordKind::S_LPROC32_ID) {\n                name = record->data.S_LPROC32_ID.name;\n                rva = image_section_stream.ConvertSectionOffsetToRVA(\n                        record->data.S_LPROC32_ID.section,\n                        record->data.S_LPROC32_ID.offset);\n            } else if (record->header.kind ==\n                       PDB::CodeView::DBI::SymbolRecordKind::S_GPROC32_ID) {\n                name = record->data.S_GPROC32_ID.name;\n                rva = image_section_stream.ConvertSectionOffsetToRVA(\n                        record->data.S_GPROC32_ID.section,\n                        record->data.S_GPROC32_ID.offset);\n            } else if (record->header.kind ==\n                       PDB::CodeView::DBI::SymbolRecordKind::S_REGREL32) {\n                name = record->data.S_REGREL32.name;\n\n\n            } else if (record->header.kind ==\n                       PDB::CodeView::DBI::SymbolRecordKind::S_LDATA32) {\n                name = record->data.S_LDATA32.name;\n                rva = image_section_stream.ConvertSectionOffsetToRVA(\n                        record->data.S_LDATA32.section,\n                        record->data.S_LDATA32.offset);\n            } else if (record->header.kind ==\n                       PDB::CodeView::DBI::SymbolRecordKind::S_LTHREAD32) {\n                name = record->data.S_LTHREAD32.name;\n                rva = image_section_stream.ConvertSectionOffsetToRVA(\n                        record->data.S_LTHREAD32.section,\n                        record->data.S_LTHREAD32.offset);\n            }\n\n            if (rva == 0u) {\n\n\n                return;\n            }\n\n            if (names.find(name) != names.end()) {\n                result.insert({name, rva});\n            }\n        });\n    }\n\n    for (const std::string &name: names) {\n        if (result.find(name) == result.end()) {\n            result.insert({name, -1});\n        }\n    }\n\n    return result;\n}\n\nstd::map<std::string, std::map<std::string, field_info>>\npdb_parser::get_struct_impl(\n        const PDB::RawFile &raw_file,\n        const PDB::DBIStream &dbi_stream,\n        const PDB::TPIStream &tpi_stream,\n        const std::map<std::string, std::set<std::string>> &names\n) {\n    std::map<std::string, std::map<std::string, field_info>> result;\n\n    for (const auto &record: tpi_stream.GetTypeRecords()) {\n        if (record->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_STRUCTURE) {\n            if (record->data.LF_CLASS.property.fwdref)\n                continue;\n\n            auto type_record = tpi_stream.GetTypeRecord(record->data.LF_CLASS.field);\n            if (!type_record)\n                continue;\n\n            auto leaf_name = GetLeafName(\n                    record->data.LF_CLASS.data, record->data.LF_CLASS.lfEasy.kind);\n\n            if (auto it = names.find(leaf_name); it != names.end()) {\n                std::map<std::string, field_info> fields =\n                        get_struct_single(tpi_stream, type_record, it->second);\n                result.insert({it->first, fields});\n            }\n        } else if (record->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_UNION) {\n            if (record->data.LF_UNION.property.fwdref)\n                continue;\n\n            auto type_record = tpi_stream.GetTypeRecord(record->data.LF_UNION.field);\n            if (!type_record)\n                continue;\n\n            auto leaf_name = GetLeafName(\n                    record->data.LF_UNION.data, static_cast<PDB::CodeView::TPI::TypeRecordKind>(0));\n\n            if (auto it = names.find(leaf_name); it != names.end()) {\n                std::map<std::string, field_info> fields =\n                        get_struct_single(tpi_stream, type_record, it->second);\n                result.insert({it->first, fields});\n            }\n        }\n    }\n\n    for (const auto &[name, fields]: names) {\n        if (result.find(name) == result.end()) {\n            std::map<std::string, field_info> empty_fields;\n            for (const auto &field: fields) {\n                empty_fields.insert({field, {}});\n            }\n\n            result.insert({name, empty_fields});\n        }\n    }\n    return result;\n}\n\nstd::map<std::string, field_info>\npdb_parser::get_struct_single(\n        const PDB::TPIStream &tpi_stream,\n        const PDB::CodeView::TPI::Record *record,\n        const std::set<std::string> &names\n) {\n    std::map<std::string, field_info> result;\n\n    const PDB::CodeView::TPI::Record *referenced_type = nullptr;\n    const PDB::CodeView::TPI::Record *modifier_record = nullptr;\n    const char *leaf_name = nullptr;\n    const char *type_name = nullptr;\n    uint16_t offset = 0;\n\n    auto maximum_size = record->header.size - sizeof(uint16_t);\n\n    for (size_t i = 0; i < maximum_size;) {\n        uint8_t pointer_level = 0;\n        auto field_record = reinterpret_cast<const PDB::CodeView::TPI::FieldList *>(\n                reinterpret_cast<const uint8_t *>(&record->data.LF_FIELD.list) + i);\n\n\n        if (field_record->kind != PDB::CodeView::TPI::TypeRecordKind::LF_BCLASS &&\n            field_record->kind != PDB::CodeView::TPI::TypeRecordKind::LF_VFUNCTAB &&\n            field_record->kind != PDB::CodeView::TPI::TypeRecordKind::LF_NESTTYPE &&\n            field_record->kind != PDB::CodeView::TPI::TypeRecordKind::LF_ENUM &&\n            field_record->kind != PDB::CodeView::TPI::TypeRecordKind::LF_MEMBER &&\n            field_record->kind != PDB::CodeView::TPI::TypeRecordKind::LF_STMEMBER &&\n            field_record->kind != PDB::CodeView::TPI::TypeRecordKind::LF_METHOD &&\n            field_record->kind != PDB::CodeView::TPI::TypeRecordKind::LF_ONEMETHOD) {\n\n            spdlog::warn(\"Unknown record kind {}\",\n                         static_cast<unsigned int>(field_record->kind));\n        }\n\n        if (field_record->kind == PDB::CodeView::TPI::TypeRecordKind::LF_MEMBER) {\n            if (field_record->data.LF_MEMBER.lfEasy.kind <\n                PDB::CodeView::TPI::TypeRecordKind::LF_NUMERIC)\n                offset = *reinterpret_cast<const uint16_t *>(\n                        &field_record->data.LF_MEMBER.offset[0]);\n            else\n                offset = *reinterpret_cast<const uint16_t *>(&field_record->data.LF_MEMBER.offset[\n                        sizeof(PDB::CodeView::TPI::TypeRecordKind)]);\n\n            leaf_name = GetLeafName(field_record->data.LF_MEMBER.offset,\n                                    field_record->data.LF_MEMBER.lfEasy.kind);\n            type_name = GetTypeName(tpi_stream, field_record->data.LF_MEMBER.index,\n                                    pointer_level, &referenced_type,\n                                    &modifier_record);\n\n            if (names.find(leaf_name) != names.end()) {\n                field_info info{};\n                info.offset = offset;\n                if (referenced_type &&\n                    referenced_type->header.kind ==\n                    PDB::CodeView::TPI::TypeRecordKind::LF_BITFIELD) {\n                    info.bitfield_offset = referenced_type->data.LF_BITFIELD.position;\n                }\n                result.insert({leaf_name, info});\n            }\n        } else if (field_record->kind == PDB::CodeView::TPI::TypeRecordKind::LF_NESTTYPE) {\n            leaf_name = &field_record->data.LF_NESTTYPE.name[0];\n        } else if (field_record->kind == PDB::CodeView::TPI::TypeRecordKind::LF_STMEMBER) {\n            leaf_name = &field_record->data.LF_STMEMBER.name[0];\n        } else if (field_record->kind == PDB::CodeView::TPI::TypeRecordKind::LF_METHOD) {\n            leaf_name = GetMethodName(field_record);\n        } else if (field_record->kind == PDB::CodeView::TPI::TypeRecordKind::LF_ONEMETHOD) {\n            leaf_name = GetMethodName(field_record);\n        } else if (field_record->kind == PDB::CodeView::TPI::TypeRecordKind::LF_BCLASS) {\n            leaf_name = GetLeafName(field_record->data.LF_BCLASS.offset,\n                                    field_record->data.LF_BCLASS.lfEasy.kind);\n\n            i += static_cast<size_t>(leaf_name - reinterpret_cast<const char *>(field_record));\n            i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));\n            continue;\n        } else if (field_record->kind == PDB::CodeView::TPI::TypeRecordKind::LF_VFUNCTAB) {\n            i += sizeof(PDB::CodeView::TPI::FieldList::Data::LF_VFUNCTAB);\n            i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));\n            continue;\n        } else {\n            break;\n        }\n\n        i += static_cast<size_t>(leaf_name - reinterpret_cast<const char *>(field_record));\n        i += strnlen(leaf_name, maximum_size - i - 1) + 1;\n        i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));\n    }\n\n    for (const std::string &name: names) {\n        if (result.find(name) == result.end()) {\n            result.insert({name, {}});\n        }\n    }\n\n    return result;\n}\n\nstd::map<std::string, std::map<std::string, int64_t>>\npdb_parser::get_enum_impl(\n        const PDB::RawFile &raw_file,\n        const PDB::DBIStream &dbi_stream,\n        const PDB::TPIStream &tpi_stream,\n        const std::map<std::string, std::set<std::string>> &names\n) {\n    std::map<std::string, std::map<std::string, int64_t>> result;\n\n    for (const auto &record: tpi_stream.GetTypeRecords()) {\n        if (record->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_ENUM) {\n            if (record->data.LF_ENUM.property.fwdref)\n                continue;\n\n            auto type_record = tpi_stream.GetTypeRecord(record->data.LF_ENUM.field);\n            if (!type_record)\n                continue;\n\n            auto leaf_name = record->data.LF_ENUM.name;\n            if (auto it = names.find(leaf_name); it != names.end()) {\n                std::map<std::string, int64_t> fields =\n                        get_enum_single(type_record, GetLeafSize(\n                                static_cast<PDB::CodeView::TPI::TypeRecordKind>(\n                                        record->data.LF_ENUM.utype)), it->second);\n                result.insert({it->first, fields});\n            }\n        }\n    }\n\n    for (const auto &[name, fields]: names) {\n        if (result.find(name) == result.end()) {\n            std::map<std::string, int64_t> empty_fields;\n            for (const auto &field: fields) {\n                empty_fields.insert({field, -1});\n            }\n            result.insert({name, empty_fields});\n        }\n    }\n    return result;\n}\n\nstd::map<std::string, int64_t>\npdb_parser::get_enum_single(\n        const PDB::CodeView::TPI::Record *record,\n        uint8_t underlying_type_size,\n        const std::set<std::string> &names\n) {\n    std::map<std::string, int64_t> result;\n\n    const char *leaf_name = nullptr;\n    uint64_t value = 0;\n    const char *value_ptr = nullptr;\n\n    auto maximum_size = record->header.size - sizeof(uint16_t);\n\n    for (size_t i = 0; i < maximum_size;) {\n        auto field_record = reinterpret_cast<const PDB::CodeView::TPI::FieldList *>(\n                reinterpret_cast<const uint8_t *>(&record->data.LF_FIELD.list) + i);\n\n        leaf_name = GetLeafName(field_record->data.LF_ENUMERATE.value,\n                                static_cast<PDB::CodeView::TPI::TypeRecordKind>(0u));\n\n        if (field_record->data.LF_ENUMERATE.lfEasy.kind <\n            PDB::CodeView::TPI::TypeRecordKind::LF_NUMERIC)\n            value_ptr = &field_record->data.LF_ENUMERATE.value[0];\n        else\n            value_ptr = &field_record->data.LF_ENUMERATE.value[\n                    sizeof(PDB::CodeView::TPI::TypeRecordKind)];\n\n        switch (underlying_type_size) {\n            case 1:\n                value = *reinterpret_cast<const uint8_t *>(\n                        &field_record->data.LF_ENUMERATE.value[0]);\n                break;\n            case 2:\n                value = *reinterpret_cast<const uint16_t *>(\n                        &field_record->data.LF_ENUMERATE.value[0]);\n                break;\n            case 4:\n                value = *reinterpret_cast<const uint32_t *>(\n                        &field_record->data.LF_ENUMERATE.value[0]);\n                break;\n            case 8:\n                value = *reinterpret_cast<const uint64_t *>(\n                        &field_record->data.LF_ENUMERATE.value[0]);\n                break;\n            default:\n                break;\n        }\n\n        if (names.find(leaf_name) != names.end()) {\n            result.insert({leaf_name, value});\n        }\n\n        i += static_cast<size_t>(leaf_name - reinterpret_cast<const char *>(field_record));\n        i += strnlen(leaf_name, maximum_size - i - 1) + 1;\n        i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));\n\n        (void) value_ptr;\n    }\n\n    for (const std::string &name: names) {\n        if (result.find(name) == result.end()) {\n            result.insert({name, -1});\n        }\n    }\n\n    return result;\n}\n\n'query-pdb/server/pdb_parser.h'\n:#ifndef QUERY_PDB_SERVER_PDB_PARSER_H\n#define QUERY_PDB_SERVER_PDB_PARSER_H\n\n#include <string>\n#include <memory>\n#include <set>\n#include <map>\n#include <PDB.h>\n#include <PDB_RawFile.h>\n#include <PDB_InfoStream.h>\n#include <PDB_DBIStream.h>\n#include <PDB_TPIStream.h>\n#include \"handle_guard.h\"\n\nstruct field_info {\n    int64_t offset;\n    int64_t bitfield_offset;\n\n    field_info() : offset(-1), bitfield_offset(0) {}\n\n    std::map<std::string, int64_t> to_map() const {\n        return {\n                {\"offset\",          offset},\n                {\"bitfield_offset\", bitfield_offset}\n        };\n    }\n};\n\nclass pdb_parser {\npublic:\n    explicit pdb_parser(const std::string &filename);\n\n    std::map<std::string, int64_t> get_symbols(const std::set<std::string> &names) const;\n\n    std::map<std::string, std::map<std::string, field_info>>\n    get_struct(const std::map<std::string, std::set<std::string>> &names) const;\n\n    std::map<std::string, std::map<std::string, int64_t>>\n    get_enum(const std::map<std::string, std::set<std::string>> &names) const;\n\nprivate:\n    handle_guard file_{};\n\n    static std::map<std::string, int64_t> get_symbols_impl(\n            const PDB::RawFile &raw_file,\n            const PDB::DBIStream &dbi_stream,\n            const PDB::TPIStream &tpi_stream,\n            const std::set<std::string> &names\n    );\n\n    static std::map<std::string, std::map<std::string, field_info>>\n    get_struct_impl(\n            const PDB::RawFile &raw_file,\n            const PDB::DBIStream &dbi_stream,\n            const PDB::TPIStream &tpi_stream,\n            const std::map<std::string, std::set<std::string>> &names\n    );\n\n    static std::map<std::string, field_info>\n    get_struct_single(\n            const PDB::TPIStream &tpi_stream,\n            const PDB::CodeView::TPI::Record *record,\n            const std::set<std::string> &names\n    );\n\n    static std::map<std::string, std::map<std::string, int64_t>>\n    get_enum_impl(\n            const PDB::RawFile &raw_file,\n            const PDB::DBIStream &dbi_stream,\n            const PDB::TPIStream &tpi_stream,\n            const std::map<std::string, std::set<std::string>> &names\n    );\n\n    static std::map<std::string, int64_t>\n    get_enum_single(\n            const PDB::CodeView::TPI::Record *record,\n            uint8_t underlying_type_size,\n            const std::set<std::string> &names\n    );\n\n    template<typename F, typename ...Args>\n    auto call_with_pdb_stream(F f, Args &&...args) const {\n\n        if (!file_.get().baseAddress ||\n            PDB::ValidateFile(file_.get().baseAddress) != PDB::ErrorCode::Success) {\n            throw std::runtime_error(\"invalid PDB file\");\n        }\n\n        const PDB::RawFile raw_file = PDB::CreateRawFile(file_.get().baseAddress);\n        if (PDB::HasValidDBIStream(raw_file) != PDB::ErrorCode::Success) {\n            throw std::runtime_error(\"invalid DBI stream\");\n        }\n\n        const PDB::InfoStream info_stream(raw_file);\n        if (info_stream.UsesDebugFastLink()) {\n            throw std::runtime_error(\"invalid info stream\");\n        }\n\n        const PDB::DBIStream dbi_stream = PDB::CreateDBIStream(raw_file);\n        if (dbi_stream.HasValidImageSectionStream(raw_file) != PDB::ErrorCode::Success ||\n            dbi_stream.HasValidPublicSymbolStream(raw_file) != PDB::ErrorCode::Success ||\n            dbi_stream.HasValidGlobalSymbolStream(raw_file) != PDB::ErrorCode::Success ||\n            dbi_stream.HasValidSectionContributionStream(raw_file) != PDB::ErrorCode::Success) {\n            throw std::runtime_error(\"invalid DBI streams\");\n        }\n\n        const PDB::TPIStream tpi_stream = PDB::CreateTPIStream(raw_file);\n        if (PDB::HasValidTPIStream(raw_file) != PDB::ErrorCode::Success) {\n            throw std::runtime_error(\"invalid TPI stream\");\n        }\n\n        return f(raw_file, dbi_stream, tpi_stream, std::forward<Args>(args)...);\n    }\n\n};\n\n#endif\n",
        "gt": [
            "'query-pdb/thirdparty/raw_pdb/src/PDB_ErrorCodes.h'",
            "'query-pdb/thirdparty/raw_pdb/src/PDB_DBIStream.h'",
            "'query-pdb/server/pdb_parser.h'",
            "'query-pdb/server/pdb_parser.cpp'"
        ]
    },
    {
        "files": [
            "'query-pdb/thirdparty/spdlog/include/spdlog/async_logger.h'",
            "'query-pdb/thirdparty/spdlog/tests/test_pattern_formatter.cpp'",
            "'query-pdb/thirdparty/spdlog/include/spdlog/async.h'",
            "'query-pdb/thirdparty/spdlog/tests/includes.h'"
        ],
        "content": "'query-pdb/thirdparty/spdlog/include/spdlog/async_logger.h'\n:\n\n\n#pragma once\n\n\n\n\n\n\n\n\n\n\n\n\n#include <spdlog/logger.h>\n\nnamespace spdlog {\n\n\nenum class async_overflow_policy\n{\n    block,\n    overrun_oldest\n\n};\n\nnamespace details {\nclass thread_pool;\n}\n\nclass SPDLOG_API async_logger final : public std::enable_shared_from_this<async_logger>, public logger\n{\n    friend class details::thread_pool;\n\npublic:\n    template<typename It>\n    async_logger(std::string logger_name, It begin, It end, std::weak_ptr<details::thread_pool> tp,\n        async_overflow_policy overflow_policy = async_overflow_policy::block)\n        : logger(std::move(logger_name), begin, end)\n        , thread_pool_(std::move(tp))\n        , overflow_policy_(overflow_policy)\n    {}\n\n    async_logger(std::string logger_name, sinks_init_list sinks_list, std::weak_ptr<details::thread_pool> tp,\n        async_overflow_policy overflow_policy = async_overflow_policy::block);\n\n    async_logger(std::string logger_name, sink_ptr single_sink, std::weak_ptr<details::thread_pool> tp,\n        async_overflow_policy overflow_policy = async_overflow_policy::block);\n\n    std::shared_ptr<logger> clone(std::string new_name) override;\n\nprotected:\n    void sink_it_(const details::log_msg &msg) override;\n    void flush_() override;\n    void backend_sink_it_(const details::log_msg &incoming_log_msg);\n    void backend_flush_();\n\nprivate:\n    std::weak_ptr<details::thread_pool> thread_pool_;\n    async_overflow_policy overflow_policy_;\n};\n}\n\n#ifdef SPDLOG_HEADER_ONLY\n#    include \"async_logger-inl.h\"\n#endif\n\n'query-pdb/thirdparty/spdlog/tests/test_pattern_formatter.cpp'\n:#include \"includes.h\"\n#include \"test_sink.h\"\n\nusing spdlog::memory_buf_t;\nusing spdlog::details::to_string_view;\n\n\ntemplate<typename... Args>\nstatic std::string log_to_str(const std::string &msg, const Args &... args)\n{\n    std::ostringstream oss;\n    auto oss_sink = std::make_shared<spdlog::sinks::ostream_sink_mt>(oss);\n    spdlog::logger oss_logger(\"pattern_tester\", oss_sink);\n    oss_logger.set_level(spdlog::level::info);\n\n    oss_logger.set_formatter(std::unique_ptr<spdlog::formatter>(new spdlog::pattern_formatter(args...)));\n\n    oss_logger.info(msg);\n    return oss.str();\n}\n\nTEST_CASE(\"custom eol\", \"[pattern_formatter]\")\n{\n    std::string msg = \"Hello custom eol test\";\n    std::string eol = \";)\";\n    REQUIRE(log_to_str(msg, \"%v\", spdlog::pattern_time_type::local, \";)\") == msg + eol);\n}\n\nTEST_CASE(\"empty format\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"\", spdlog::pattern_time_type::local, \"\").empty());\n}\n\nTEST_CASE(\"empty format2\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"\", spdlog::pattern_time_type::local, \"\\n\") == \"\\n\");\n}\n\nTEST_CASE(\"level\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%l] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[info] Some message\\n\");\n}\n\nTEST_CASE(\"short level\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%L] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[I] Some message\\n\");\n}\n\nTEST_CASE(\"name\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%n] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[pattern_tester] Some message\\n\");\n}\n\nTEST_CASE(\"date MM/DD/YY \", \"[pattern_formatter]\")\n{\n    auto now_tm = spdlog::details::os::localtime();\n    std::stringstream oss;\n    oss << std::setfill('0') << std::setw(2) << now_tm.tm_mon + 1 << \"/\" << std::setw(2) << now_tm.tm_mday << \"/\" << std::setw(2)\n        << (now_tm.tm_year + 1900) % 1000 << \" Some message\\n\";\n    REQUIRE(log_to_str(\"Some message\", \"%D %v\", spdlog::pattern_time_type::local, \"\\n\") == oss.str());\n}\n\nTEST_CASE(\"color range test1\", \"[pattern_formatter]\")\n{\n    auto formatter = std::make_shared<spdlog::pattern_formatter>(\"%^%v%$\", spdlog::pattern_time_type::local, \"\\n\");\n\n    memory_buf_t buf;\n    spdlog::fmt_lib::format_to(std::back_inserter(buf), \"Hello\");\n    memory_buf_t formatted;\n    std::string logger_name = \"test\";\n    spdlog::details::log_msg msg(logger_name, spdlog::level::info, spdlog::string_view_t(buf.data(), buf.size()));\n    formatter->format(msg, formatted);\n    REQUIRE(msg.color_range_start == 0);\n    REQUIRE(msg.color_range_end == 5);\n    REQUIRE(log_to_str(\"hello\", \"%^%v%$\", spdlog::pattern_time_type::local, \"\\n\") == \"hello\\n\");\n}\n\nTEST_CASE(\"color range test2\", \"[pattern_formatter]\")\n{\n    auto formatter = std::make_shared<spdlog::pattern_formatter>(\"%^%$\", spdlog::pattern_time_type::local, \"\\n\");\n    std::string logger_name = \"test\";\n    spdlog::details::log_msg msg(logger_name, spdlog::level::info, \"\");\n    memory_buf_t formatted;\n    formatter->format(msg, formatted);\n    REQUIRE(msg.color_range_start == 0);\n    REQUIRE(msg.color_range_end == 0);\n    REQUIRE(log_to_str(\"\", \"%^%$\", spdlog::pattern_time_type::local, \"\\n\") == \"\\n\");\n}\n\nTEST_CASE(\"color range test3\", \"[pattern_formatter]\")\n{\n    auto formatter = std::make_shared<spdlog::pattern_formatter>(\"%^***%$\");\n    std::string logger_name = \"test\";\n    spdlog::details::log_msg msg(logger_name, spdlog::level::info, \"ignored\");\n    memory_buf_t formatted;\n    formatter->format(msg, formatted);\n    REQUIRE(msg.color_range_start == 0);\n    REQUIRE(msg.color_range_end == 3);\n}\n\nTEST_CASE(\"color range test4\", \"[pattern_formatter]\")\n{\n    auto formatter = std::make_shared<spdlog::pattern_formatter>(\"XX%^YYY%$\", spdlog::pattern_time_type::local, \"\\n\");\n    std::string logger_name = \"test\";\n    spdlog::details::log_msg msg(logger_name, spdlog::level::info, \"ignored\");\n\n    memory_buf_t formatted;\n    formatter->format(msg, formatted);\n    REQUIRE(msg.color_range_start == 2);\n    REQUIRE(msg.color_range_end == 5);\n    REQUIRE(log_to_str(\"ignored\", \"XX%^YYY%$\", spdlog::pattern_time_type::local, \"\\n\") == \"XXYYY\\n\");\n}\n\nTEST_CASE(\"color range test5\", \"[pattern_formatter]\")\n{\n    auto formatter = std::make_shared<spdlog::pattern_formatter>(\"**%^\");\n    std::string logger_name = \"test\";\n    spdlog::details::log_msg msg(logger_name, spdlog::level::info, \"ignored\");\n    memory_buf_t formatted;\n    formatter->format(msg, formatted);\n    REQUIRE(msg.color_range_start == 2);\n    REQUIRE(msg.color_range_end == 0);\n}\n\nTEST_CASE(\"color range test6\", \"[pattern_formatter]\")\n{\n    auto formatter = std::make_shared<spdlog::pattern_formatter>(\"**%$\");\n    std::string logger_name = \"test\";\n    spdlog::details::log_msg msg(logger_name, spdlog::level::info, \"ignored\");\n    memory_buf_t formatted;\n    formatter->format(msg, formatted);\n    REQUIRE(msg.color_range_start == 0);\n    REQUIRE(msg.color_range_end == 2);\n}\n\n\n\n\n\nTEST_CASE(\"level_left_padded\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%8l] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[    info] Some message\\n\");\n    REQUIRE(log_to_str(\"Some message\", \"[%8!l] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[    info] Some message\\n\");\n}\n\nTEST_CASE(\"level_right_padded\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%-8l] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[info    ] Some message\\n\");\n    REQUIRE(log_to_str(\"Some message\", \"[%-8!l] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[info    ] Some message\\n\");\n}\n\nTEST_CASE(\"level_center_padded\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%=8l] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[  info  ] Some message\\n\");\n    REQUIRE(log_to_str(\"Some message\", \"[%=8!l] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[  info  ] Some message\\n\");\n}\n\nTEST_CASE(\"short level_left_padded\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%3L] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[  I] Some message\\n\");\n    REQUIRE(log_to_str(\"Some message\", \"[%3!L] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[  I] Some message\\n\");\n}\n\nTEST_CASE(\"short level_right_padded\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%-3L] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[I  ] Some message\\n\");\n    REQUIRE(log_to_str(\"Some message\", \"[%-3!L] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[I  ] Some message\\n\");\n}\n\nTEST_CASE(\"short level_center_padded\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%=3L] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[ I ] Some message\\n\");\n    REQUIRE(log_to_str(\"Some message\", \"[%=3!L] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[ I ] Some message\\n\");\n}\n\nTEST_CASE(\"left_padded_short\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%3n] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[pattern_tester] Some message\\n\");\n    REQUIRE(log_to_str(\"Some message\", \"[%3!n] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[pat] Some message\\n\");\n}\n\nTEST_CASE(\"right_padded_short\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%-3n] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[pattern_tester] Some message\\n\");\n    REQUIRE(log_to_str(\"Some message\", \"[%-3!n] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[pat] Some message\\n\");\n}\n\nTEST_CASE(\"center_padded_short\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%=3n] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[pattern_tester] Some message\\n\");\n    REQUIRE(log_to_str(\"Some message\", \"[%=3!n] %v\", spdlog::pattern_time_type::local, \"\\n\") == \"[pat] Some message\\n\");\n}\n\nTEST_CASE(\"left_padded_huge\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%-300n] %v\", spdlog::pattern_time_type::local, \"\\n\") ==\n            \"[pattern_tester                                                  ] Some message\\n\");\n\n    REQUIRE(log_to_str(\"Some message\", \"[%-300!n] %v\", spdlog::pattern_time_type::local, \"\\n\") ==\n            \"[pattern_tester                                                  ] Some message\\n\");\n}\n\nTEST_CASE(\"left_padded_max\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"Some message\", \"[%-64n] %v\", spdlog::pattern_time_type::local, \"\\n\") ==\n            \"[pattern_tester                                                  ] Some message\\n\");\n\n    REQUIRE(log_to_str(\"Some message\", \"[%-64!n] %v\", spdlog::pattern_time_type::local, \"\\n\") ==\n            \"[pattern_tester                                                  ] Some message\\n\");\n}\n\n\n\nTEST_CASE(\"paddinng_truncate\", \"[pattern_formatter]\")\n{\n    REQUIRE(log_to_str(\"123456\", \"%6!v\", spdlog::pattern_time_type::local, \"\\n\") == \"123456\\n\");\n    REQUIRE(log_to_str(\"123456\", \"%5!v\", spdlog::pattern_time_type::local, \"\\n\") == \"12345\\n\");\n    REQUIRE(log_to_str(\"123456\", \"%7!v\", spdlog::pattern_time_type::local, \"\\n\") == \" 123456\\n\");\n\n    REQUIRE(log_to_str(\"123456\", \"%-6!v\", spdlog::pattern_time_type::local, \"\\n\") == \"123456\\n\");\n    REQUIRE(log_to_str(\"123456\", \"%-5!v\", spdlog::pattern_time_type::local, \"\\n\") == \"12345\\n\");\n    REQUIRE(log_to_str(\"123456\", \"%-7!v\", spdlog::pattern_time_type::local, \"\\n\") == \"123456 \\n\");\n\n    REQUIRE(log_to_str(\"123456\", \"%=6!v\", spdlog::pattern_time_type::local, \"\\n\") == \"123456\\n\");\n    REQUIRE(log_to_str(\"123456\", \"%=5!v\", spdlog::pattern_time_type::local, \"\\n\") == \"12345\\n\");\n    REQUIRE(log_to_str(\"123456\", \"%=7!v\", spdlog::pattern_time_type::local, \"\\n\") == \"123456 \\n\");\n\n    REQUIRE(log_to_str(\"123456\", \"%0!v\", spdlog::pattern_time_type::local, \"\\n\") == \"\\n\");\n}\n\nTEST_CASE(\"padding_truncate_funcname\", \"[pattern_formatter]\")\n{\n    spdlog::sinks::test_sink_st test_sink;\n\n    const char *pattern = \"%v [%5!!]\";\n    auto formatter = std::unique_ptr<spdlog::formatter>(new spdlog::pattern_formatter(pattern));\n    test_sink.set_formatter(std::move(formatter));\n\n    spdlog::details::log_msg msg1{spdlog::source_loc{\"ignored\", 1, \"func\"}, \"test_logger\", spdlog::level::info, \"message\"};\n    test_sink.log(msg1);\n    REQUIRE(test_sink.lines()[0] == \"message [ func]\");\n\n    spdlog::details::log_msg msg2{spdlog::source_loc{\"ignored\", 1, \"function\"}, \"test_logger\", spdlog::level::info, \"message\"};\n    test_sink.log(msg2);\n    REQUIRE(test_sink.lines()[1] == \"message [funct]\");\n}\n\nTEST_CASE(\"padding_funcname\", \"[pattern_formatter]\")\n{\n    spdlog::sinks::test_sink_st test_sink;\n\n    const char *pattern = \"%v [%10!]\";\n    auto formatter = std::unique_ptr<spdlog::formatter>(new spdlog::pattern_formatter(pattern));\n    test_sink.set_formatter(std::move(formatter));\n\n    spdlog::details::log_msg msg1{spdlog::source_loc{\"ignored\", 1, \"func\"}, \"test_logger\", spdlog::level::info, \"message\"};\n    test_sink.log(msg1);\n    REQUIRE(test_sink.lines()[0] == \"message [      func]\");\n\n    spdlog::details::log_msg msg2{spdlog::source_loc{\"ignored\", 1, \"func567890123\"}, \"test_logger\", spdlog::level::info, \"message\"};\n    test_sink.log(msg2);\n    REQUIRE(test_sink.lines()[1] == \"message [func567890123]\");\n}\n\nTEST_CASE(\"clone-default-formatter\", \"[pattern_formatter]\")\n{\n    auto formatter_1 = std::make_shared<spdlog::pattern_formatter>();\n    auto formatter_2 = formatter_1->clone();\n    std::string logger_name = \"test\";\n    spdlog::details::log_msg msg(logger_name, spdlog::level::info, \"some message\");\n\n    memory_buf_t formatted_1;\n    memory_buf_t formatted_2;\n    formatter_1->format(msg, formatted_1);\n    formatter_2->format(msg, formatted_2);\n\n    REQUIRE(to_string_view(formatted_1) == to_string_view(formatted_2));\n}\n\nTEST_CASE(\"clone-default-formatter2\", \"[pattern_formatter]\")\n{\n    auto formatter_1 = std::make_shared<spdlog::pattern_formatter>(\"%+\");\n    auto formatter_2 = formatter_1->clone();\n    std::string logger_name = \"test\";\n    spdlog::details::log_msg msg(logger_name, spdlog::level::info, \"some message\");\n\n    memory_buf_t formatted_1;\n    memory_buf_t formatted_2;\n    formatter_1->format(msg, formatted_1);\n    formatter_2->format(msg, formatted_2);\n\n    REQUIRE(to_string_view(formatted_1) == to_string_view(formatted_2));\n}\n\nTEST_CASE(\"clone-formatter\", \"[pattern_formatter]\")\n{\n    auto formatter_1 = std::make_shared<spdlog::pattern_formatter>(\"%D %X [%] [%n] %v\");\n    auto formatter_2 = formatter_1->clone();\n    std::string logger_name = \"test\";\n    spdlog::details::log_msg msg(logger_name, spdlog::level::info, \"some message\");\n\n    memory_buf_t formatted_1;\n    memory_buf_t formatted_2;\n    formatter_1->format(msg, formatted_1);\n    formatter_2->format(msg, formatted_2);\n\n    REQUIRE(to_string_view(formatted_1) == to_string_view(formatted_2));\n}\n\nTEST_CASE(\"clone-formatter-2\", \"[pattern_formatter]\")\n{\n    using spdlog::pattern_time_type;\n    auto formatter_1 = std::make_shared<spdlog::pattern_formatter>(\"%D %X [%] [%n] %v\", pattern_time_type::utc, \"xxxxxx\\n\");\n    auto formatter_2 = formatter_1->clone();\n    std::string logger_name = \"test2\";\n    spdlog::details::log_msg msg(logger_name, spdlog::level::info, \"some message\");\n\n    memory_buf_t formatted_1;\n    memory_buf_t formatted_2;\n    formatter_1->format(msg, formatted_1);\n    formatter_2->format(msg, formatted_2);\n\n    REQUIRE(to_string_view(formatted_1) == to_string_view(formatted_2));\n}\n\nclass custom_test_flag : public spdlog::custom_flag_formatter\n{\npublic:\n    explicit custom_test_flag(std::string txt)\n        : some_txt{std::move(txt)}\n    {}\n\n    void format(const spdlog::details::log_msg &, const std::tm &tm, spdlog::memory_buf_t &dest) override\n    {\n        if (some_txt == \"throw_me\")\n        {\n            throw spdlog::spdlog_ex(\"custom_flag_exception_test\");\n        }\n        else if (some_txt == \"time\")\n        {\n            auto formatted = spdlog::fmt_lib::format(\"{:d}:{:02d}{:s}\", tm.tm_hour % 12, tm.tm_min, tm.tm_hour / 12 ? \"PM\" : \"AM\");\n            dest.append(formatted.data(), formatted.data() + formatted.size());\n            return;\n        }\n        some_txt = std::string(padinfo_.width_, ' ') + some_txt;\n        dest.append(some_txt.data(), some_txt.data() + some_txt.size());\n    }\n    spdlog::details::padding_info get_padding_info()\n    {\n        return padinfo_;\n    }\n\n    std::string some_txt;\n\n    std::unique_ptr<custom_flag_formatter> clone() const override\n    {\n        return spdlog::details::make_unique<custom_test_flag>(some_txt);\n    }\n};\n\nTEST_CASE(\"clone-custom_formatter\", \"[pattern_formatter]\")\n{\n    auto formatter_1 = std::make_shared<spdlog::pattern_formatter>();\n    formatter_1->add_flag<custom_test_flag>('t', \"custom_output\").set_pattern(\"[%n] [%t] %v\");\n    auto formatter_2 = formatter_1->clone();\n    std::string logger_name = \"logger-name\";\n    spdlog::details::log_msg msg(logger_name, spdlog::level::info, \"some message\");\n\n    memory_buf_t formatted_1;\n    memory_buf_t formatted_2;\n    formatter_1->format(msg, formatted_1);\n    formatter_2->format(msg, formatted_2);\n\n    auto expected = spdlog::fmt_lib::format(\"[logger-name] [custom_output] some message{}\", spdlog::details::os::default_eol);\n\n    REQUIRE(to_string_view(formatted_1) == expected);\n    REQUIRE(to_string_view(formatted_2) == expected);\n}\n\n\n\n\n\n#ifdef _WIN32\nstatic const char *const test_path = \"\\\\a\\\\b\\\\c/myfile.cpp\";\n#else\nstatic const char *const test_path = \"/a/b\n#endif\n\nTEST_CASE(\"short filename formatter-1\", \"[pattern_formatter]\")\n{\n    spdlog::pattern_formatter formatter(\"%s\", spdlog::pattern_time_type::local, \"\");\n    memory_buf_t formatted;\n    std::string logger_name = \"logger-name\";\n    spdlog::source_loc source_loc{test_path, 123, \"some_func()\"};\n    spdlog::details::log_msg msg(source_loc, \"logger-name\", spdlog::level::info, \"Hello\");\n    formatter.format(msg, formatted);\n\n    REQUIRE(to_string_view(formatted) == \"myfile.cpp\");\n}\n\nTEST_CASE(\"short filename formatter-2\", \"[pattern_formatter]\")\n{\n    spdlog::pattern_formatter formatter(\"%s:%#\", spdlog::pattern_time_type::local, \"\");\n    memory_buf_t formatted;\n    std::string logger_name = \"logger-name\";\n    spdlog::source_loc source_loc{\"myfile.cpp\", 123, \"some_func()\"};\n    spdlog::details::log_msg msg(source_loc, \"logger-name\", spdlog::level::info, \"Hello\");\n    formatter.format(msg, formatted);\n\n    REQUIRE(to_string_view(formatted) == \"myfile.cpp:123\");\n}\n\nTEST_CASE(\"short filename formatter-3\", \"[pattern_formatter]\")\n{\n    spdlog::pattern_formatter formatter(\"%s %v\", spdlog::pattern_time_type::local, \"\");\n    memory_buf_t formatted;\n    std::string logger_name = \"logger-name\";\n    spdlog::source_loc source_loc{\"\", 123, \"some_func()\"};\n    spdlog::details::log_msg msg(source_loc, \"logger-name\", spdlog::level::info, \"Hello\");\n    formatter.format(msg, formatted);\n\n    REQUIRE(to_string_view(formatted) == \" Hello\");\n}\n\nTEST_CASE(\"full filename formatter\", \"[pattern_formatter]\")\n{\n    spdlog::pattern_formatter formatter(\"%g\", spdlog::pattern_time_type::local, \"\");\n    memory_buf_t formatted;\n    std::string logger_name = \"logger-name\";\n    spdlog::source_loc source_loc{test_path, 123, \"some_func()\"};\n    spdlog::details::log_msg msg(source_loc, \"logger-name\", spdlog::level::info, \"Hello\");\n    formatter.format(msg, formatted);\n\n    REQUIRE(to_string_view(formatted) == test_path);\n}\n\nTEST_CASE(\"custom flags\", \"[pattern_formatter]\")\n{\n    auto formatter = std::make_shared<spdlog::pattern_formatter>();\n    formatter->add_flag<custom_test_flag>('t', \"custom1\").add_flag<custom_test_flag>('u', \"custom2\").set_pattern(\"[%n] [%t] [%u] %v\");\n\n    memory_buf_t formatted;\n\n    spdlog::details::log_msg msg(spdlog::source_loc{}, \"logger-name\", spdlog::level::info, \"some message\");\n    formatter->format(msg, formatted);\n    auto expected = spdlog::fmt_lib::format(\"[logger-name] [custom1] [custom2] some message{}\", spdlog::details::os::default_eol);\n\n    REQUIRE(to_string_view(formatted) == expected);\n}\n\nTEST_CASE(\"custom flags-padding\", \"[pattern_formatter]\")\n{\n    auto formatter = std::make_shared<spdlog::pattern_formatter>();\n    formatter->add_flag<custom_test_flag>('t', \"custom1\").add_flag<custom_test_flag>('u', \"custom2\").set_pattern(\"[%n] [%t] [%5u] %v\");\n\n    memory_buf_t formatted;\n\n    spdlog::details::log_msg msg(spdlog::source_loc{}, \"logger-name\", spdlog::level::info, \"some message\");\n    formatter->format(msg, formatted);\n    auto expected = spdlog::fmt_lib::format(\"[logger-name] [custom1] [     custom2] some message{}\", spdlog::details::os::default_eol);\n\n    REQUIRE(to_string_view(formatted) == expected);\n}\n\nTEST_CASE(\"custom flags-exception\", \"[pattern_formatter]\")\n{\n    auto formatter = std::make_shared<spdlog::pattern_formatter>();\n    formatter->add_flag<custom_test_flag>('t', \"throw_me\").add_flag<custom_test_flag>('u', \"custom2\").set_pattern(\"[%n] [%t] [%u] %v\");\n\n    memory_buf_t formatted;\n    spdlog::details::log_msg msg(spdlog::source_loc{}, \"logger-name\", spdlog::level::info, \"some message\");\n    CHECK_THROWS_AS(formatter->format(msg, formatted), spdlog::spdlog_ex);\n}\n\nTEST_CASE(\"override need_localtime\", \"[pattern_formatter]\")\n{\n    auto formatter = std::make_shared<spdlog::pattern_formatter>(spdlog::pattern_time_type::local, \"\\n\");\n    formatter->add_flag<custom_test_flag>('t', \"time\").set_pattern(\"%t> %v\");\n\n    {\n        memory_buf_t formatted;\n        spdlog::details::log_msg msg(spdlog::source_loc{}, \"logger-name\", spdlog::level::info, \"some message\");\n        formatter->format(msg, formatted);\n        REQUIRE(to_string_view(formatted) == \"0:00AM> some message\\n\");\n    }\n\n    {\n        formatter->need_localtime();\n\n        auto now_tm = spdlog::details::os::localtime();\n        std::stringstream oss;\n        oss << (now_tm.tm_hour % 12) << \":\" << std::setfill('0') << std::setw(2) << now_tm.tm_min << (now_tm.tm_hour / 12 ? \"PM\" : \"AM\")\n            << \"> some message\\n\";\n\n        memory_buf_t formatted;\n        spdlog::details::log_msg msg(spdlog::source_loc{}, \"logger-name\", spdlog::level::info, \"some message\");\n        formatter->format(msg, formatted);\n        REQUIRE(to_string_view(formatted) == oss.str());\n    }\n}\n\n'query-pdb/thirdparty/spdlog/include/spdlog/async.h'\n:\n\n\n#pragma once\n\n\n\n\n\n\n\n\n\n\n\n\n#include <spdlog/async_logger.h>\n#include <spdlog/details/registry.h>\n#include <spdlog/details/thread_pool.h>\n\n#include <memory>\n#include <mutex>\n#include <functional>\n\nnamespace spdlog {\n\nnamespace details {\nstatic const size_t default_async_q_size = 8192;\n}\n\n\n\n\ntemplate<async_overflow_policy OverflowPolicy = async_overflow_policy::block>\nstruct async_factory_impl\n{\n    template<typename Sink, typename... SinkArgs>\n    static std::shared_ptr<async_logger> create(std::string logger_name, SinkArgs &&... args)\n    {\n        auto &registry_inst = details::registry::instance();\n\n\n\n        auto &mutex = registry_inst.tp_mutex();\n        std::lock_guard<std::recursive_mutex> tp_lock(mutex);\n        auto tp = registry_inst.get_tp();\n        if (tp == nullptr)\n        {\n            tp = std::make_shared<details::thread_pool>(details::default_async_q_size, 1U);\n            registry_inst.set_tp(tp);\n        }\n\n        auto sink = std::make_shared<Sink>(std::forward<SinkArgs>(args)...);\n        auto new_logger = std::make_shared<async_logger>(std::move(logger_name), std::move(sink), std::move(tp), OverflowPolicy);\n        registry_inst.initialize_logger(new_logger);\n        return new_logger;\n    }\n};\n\nusing async_factory = async_factory_impl<async_overflow_policy::block>;\nusing async_factory_nonblock = async_factory_impl<async_overflow_policy::overrun_oldest>;\n\ntemplate<typename Sink, typename... SinkArgs>\ninline std::shared_ptr<spdlog::logger> create_async(std::string logger_name, SinkArgs &&... sink_args)\n{\n    return async_factory::create<Sink>(std::move(logger_name), std::forward<SinkArgs>(sink_args)...);\n}\n\ntemplate<typename Sink, typename... SinkArgs>\ninline std::shared_ptr<spdlog::logger> create_async_nb(std::string logger_name, SinkArgs &&... sink_args)\n{\n    return async_factory_nonblock::create<Sink>(std::move(logger_name), std::forward<SinkArgs>(sink_args)...);\n}\n\n\ninline void init_thread_pool(\n    size_t q_size, size_t thread_count, std::function<void()> on_thread_start, std::function<void()> on_thread_stop)\n{\n    auto tp = std::make_shared<details::thread_pool>(q_size, thread_count, on_thread_start, on_thread_stop);\n    details::registry::instance().set_tp(std::move(tp));\n}\n\ninline void init_thread_pool(size_t q_size, size_t thread_count, std::function<void()> on_thread_start)\n{\n    init_thread_pool(q_size, thread_count, on_thread_start, [] {});\n}\n\ninline void init_thread_pool(size_t q_size, size_t thread_count)\n{\n    init_thread_pool(\n        q_size, thread_count, [] {}, [] {});\n}\n\n\ninline std::shared_ptr<spdlog::details::thread_pool> thread_pool()\n{\n    return details::registry::instance().get_tp();\n}\n}\n\n'query-pdb/thirdparty/spdlog/tests/includes.h'\n:#pragma once\n\n#if defined(__GNUC__) && __GNUC__ == 12\n#    pragma GCC diagnostic push\n#    pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n#include \"catch.hpp\"\n#if defined(__GNUC__) && __GNUC__ == 12\n#    pragma GCC diagnostic pop\n#endif\n\n#include \"utils.h\"\n#include <chrono>\n#include <cstdio>\n#include <exception>\n#include <fstream>\n#include <iostream>\n#include <ostream>\n#include <sstream>\n#include <string>\n#include <iomanip>\n#include <stdlib.h>\n\n#define SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_DEBUG\n\n#include \"spdlog/spdlog.h\"\n#include \"spdlog/async.h\"\n#include \"spdlog/details/fmt_helper.h\"\n#include \"spdlog/sinks/basic_file_sink.h\"\n#include \"spdlog/sinks/daily_file_sink.h\"\n#include \"spdlog/sinks/null_sink.h\"\n#include \"spdlog/sinks/ostream_sink.h\"\n#include \"spdlog/sinks/rotating_file_sink.h\"\n#include \"spdlog/sinks/stdout_color_sinks.h\"\n#include \"spdlog/sinks/msvc_sink.h\"\n#include \"spdlog/pattern_formatter.h\"\n",
        "gt": [
            "'query-pdb/thirdparty/spdlog/include/spdlog/async_logger.h'",
            "'query-pdb/thirdparty/spdlog/include/spdlog/async.h'",
            "'query-pdb/thirdparty/spdlog/tests/includes.h'",
            "'query-pdb/thirdparty/spdlog/tests/test_pattern_formatter.cpp'"
        ]
    },
    {
        "files": [
            "'pyeos/contracts/eosiolib/privileged.hpp'",
            "'pyeos/contracts/eosio.system/eosio.system.cpp'",
            "'pyeos/contracts/eosio.system/voting.cpp'"
        ],
        "content": "'pyeos/contracts/eosiolib/privileged.hpp'\n:#pragma once\n\n#include \"types.h\"\n#include \"privileged.h\"\n#include \"serialize.hpp\"\n\nnamespace eosio {\n\n\n\n\n   struct blockchain_parameters {\n\n      uint64_t max_block_net_usage;\n\n      uint32_t target_block_net_usage_pct;\n\n      uint32_t max_transaction_net_usage;\n\n\n      uint32_t base_per_transaction_net_usage;\n\n      uint32_t net_usage_leeway;\n\n      uint32_t context_free_discount_net_usage_num;\n\n      uint32_t context_free_discount_net_usage_den;\n\n      uint32_t max_block_cpu_usage;\n\n      uint32_t target_block_cpu_usage_pct;\n\n      uint32_t max_transaction_cpu_usage;\n\n      uint32_t min_transaction_cpu_usage;\n\n\n\n      uint64_t context_free_discount_cpu_usage_num;\n\n\n      uint64_t context_free_discount_cpu_usage_den;\n\n\n      uint32_t max_transaction_lifetime;\n\n      uint32_t deferred_trx_expiration_window;\n\n      uint32_t max_transaction_delay;\n\n\n      uint32_t max_inline_action_size;\n\n\n      uint16_t max_inline_action_depth;\n\n\n      uint16_t max_authority_depth;\n\n\n      EOSLIB_SERIALIZE( blockchain_parameters,\n                        (max_block_net_usage)(target_block_net_usage_pct)\n                        (max_transaction_net_usage)(base_per_transaction_net_usage)(net_usage_leeway)\n                        (context_free_discount_net_usage_num)(context_free_discount_net_usage_den)\n\n                        (max_block_cpu_usage)(target_block_cpu_usage_pct)\n                        (max_transaction_cpu_usage)(min_transaction_cpu_usage)\n\n                        (max_transaction_lifetime)(deferred_trx_expiration_window)(max_transaction_delay)\n                        (max_inline_action_size)(max_inline_action_depth)(max_authority_depth)\n      )\n   };\n\n\n   void set_blockchain_parameters(const eosio::blockchain_parameters& params);\n\n\n   void get_blockchain_parameters(eosio::blockchain_parameters& params);\n\n\n\n\n\n\n   struct producer_key {\n\n\n      account_name     producer_name;\n\n\n      public_key       block_signing_key;\n\n      friend bool operator < ( const producer_key& a, const producer_key& b ) {\n         return a.producer_name < b.producer_name;\n      }\n\n      EOSLIB_SERIALIZE( producer_key, (producer_name)(block_signing_key) )\n   };\n}\n\n'pyeos/contracts/eosio.system/eosio.system.cpp'\n:#include \"eosio.system.hpp\"\n#include <eosiolib/dispatcher.hpp>\n\n#include \"producer_pay.cpp\"\n#include \"delegate_bandwidth.cpp\"\n#include \"voting.cpp\"\n#include \"exchange_state.cpp\"\n\n\nnamespace eosiosystem {\n\n   system_contract::system_contract( account_name s )\n   :native(s),\n    _voters(_self,_self),\n    _producers(_self,_self),\n    _global(_self,_self),\n    _rammarket(_self,_self),\n    _jitbid(_self,_self),\n    _boost(_self,_self)\n    {\n\n      _gstate = _global.exists() ? _global.get() : get_default_parameters();\n      if (!_jitbid.exists()) {\n         jit_bid bid;\n         bid.high_bidder = 0;\n         bid.high_bid = 0;\n         bid.last_bid_time = 0;\n         bid.start_bid_time = current_time();\n         bid.jit_remains = 100;\n         _jitbid.set(bid, _self);\n         _boost.emplace( _self, [&]( auto& b ) {\n               b.account = N(eosio);\n               b.expiration = (uint64_t)-1;\n         });\n         _boost.emplace( _self, [&]( auto& b ) {\n               b.account = N(eosio.token);\n               b.expiration = (uint64_t)-1;\n         });\n      }\n\n      auto itr = _rammarket.find(S(4,RAMCORE));\n\n      if( itr == _rammarket.end() ) {\n         auto system_token_supply   = eosio::token(N(eosio.token)).get_supply(eosio::symbol_type(system_token_symbol).name()).amount;\n         if( system_token_supply > 0 ) {\n            itr = _rammarket.emplace( _self, [&]( auto& m ) {\n               m.supply.amount = 100000000000000ll;\n               m.supply.symbol = S(4,RAMCORE);\n               m.base.balance.amount = int64_t(_gstate.free_ram());\n               m.base.balance.symbol = S(0,RAM);\n               m.quote.balance.amount = system_token_supply / 1000;\n               m.quote.balance.symbol = CORE_SYMBOL;\n            });\n         }\n      } else {\n\n      }\n   }\n\n   eosio_global_state system_contract::get_default_parameters() {\n      eosio_global_state dp;\n      get_blockchain_parameters(dp);\n      return dp;\n   }\n\n\n   system_contract::~system_contract() {\n\n      _global.set( _gstate, _self );\n\n   }\n\n   void system_contract::setram( uint64_t max_ram_size ) {\n      require_auth( _self );\n\n      eosio_assert( _gstate.max_ram_size < max_ram_size, \"ram may only be increased\" );\n      eosio_assert( max_ram_size < 1024ll*1024*1024*1024*1024, \"ram size is unrealistic\" );\n      eosio_assert( max_ram_size > _gstate.total_ram_bytes_reserved, \"attempt to set max below reserved\" );\n\n      auto delta = int64_t(max_ram_size) - int64_t(_gstate.max_ram_size);\n      auto itr = _rammarket.find(S(4,RAMCORE));\n\n\n      _rammarket.modify( itr, 0, [&]( auto& m ) {\n         m.base.balance.amount += delta;\n      });\n\n      _gstate.max_ram_size = max_ram_size;\n      _global.set( _gstate, _self );\n   }\n\n   void system_contract::setparams( const eosio::blockchain_parameters& params ) {\n      require_auth( N(eosio) );\n      (eosio::blockchain_parameters&)(_gstate) = params;\n      eosio_assert( 3 <= _gstate.max_authority_depth, \"max_authority_depth should be at least 3\" );\n      set_blockchain_parameters( params );\n   }\n\n   void system_contract::setpriv( account_name account, uint8_t ispriv ) {\n      require_auth( _self );\n      set_privileged( account, ispriv );\n   }\n\n   void system_contract::rmvproducer( account_name producer ) {\n      require_auth( _self );\n      auto prod = _producers.find( producer );\n      eosio_assert( prod != _producers.end(), \"producer not found\" );\n      _producers.modify( prod, 0, [&](auto& p) {\n            p.deactivate();\n         });\n   }\n\n   void system_contract::bidname( account_name bidder, account_name newname, asset bid ) {\n      require_auth( bidder );\n      eosio_assert( eosio::name_suffix(newname) == newname, \"you can only bid on top-level suffix\" );\n      eosio_assert( newname != 0, \"the empty name is not a valid account name to bid on\" );\n      eosio_assert( (newname & 0xFull) == 0, \"13 character names are not valid account names to bid on\" );\n      eosio_assert( (newname & 0x1F0ull) == 0, \"accounts with 12 character names and no dots can be created without bidding required\" );\n      eosio_assert( !is_account( newname ), \"account already exists\" );\n      eosio_assert( bid.symbol == asset().symbol, \"asset must be system token\" );\n      eosio_assert( bid.amount > 0, \"insufficient bid\" );\n\n      INLINE_ACTION_SENDER(eosio::token, transfer)( N(eosio.token), {bidder,N(active)},\n                                                    { bidder, N(eosio.names), bid, std::string(\"bid name \")+(name{newname}).to_string()  } );\n\n      name_bid_table bids(_self,_self);\n      print( name{bidder}, \" bid \", bid, \" on \", name{newname}, \"\\n\" );\n      auto current = bids.find( newname );\n      if( current == bids.end() ) {\n         bids.emplace( bidder, [&]( auto& b ) {\n            b.newname = newname;\n            b.high_bidder = bidder;\n            b.high_bid = bid.amount;\n            b.last_bid_time = current_time();\n         });\n      } else {\n         eosio_assert( current->high_bid > 0, \"this auction has already closed\" );\n         eosio_assert( bid.amount - current->high_bid > (current->high_bid / 10), \"must increase bid by 10%\" );\n         eosio_assert( current->high_bidder != bidder, \"account is already highest bidder\" );\n\n         INLINE_ACTION_SENDER(eosio::token, transfer)( N(eosio.token), {N(eosio.names),N(active)},\n                                                       { N(eosio.names), current->high_bidder, asset(current->high_bid),\n                                                       std::string(\"refund bid on name \")+(name{newname}).to_string()  } );\n\n         bids.modify( current, bidder, [&]( auto& b ) {\n            b.high_bidder = bidder;\n            b.high_bid = bid.amount;\n            b.last_bid_time = current_time();\n         });\n      }\n   }\n\n   void system_contract::bidjit( account_name bidder, asset bid ) {\n       require_auth( bidder );\n       eosio_assert( bid.symbol == asset().symbol, \"asset must be system token\" );\n       eosio_assert( bid.amount > 0, \"insufficient bid\" );\n\n       jit_bid current = _jitbid.get();\n\n\n       eosio_assert( bid.amount - current.high_bid > (current.high_bid / 10), \"must increase bid by 10%\" );\n       eosio_assert( current.high_bidder != bidder, \"account is already highest bidder\" );\n       eosio_assert( current.jit_remains > 0, \"no jit resources left!\" );\n\n\n       INLINE_ACTION_SENDER(eosio::token, transfer)( N(eosio.token), {bidder,N(active)},\n                                                     { bidder, N(eosio.jit), bid, std::string(\"bid jit \")+(name{bidder}).to_string()  } );\n       if (current.high_bidder) {\n          INLINE_ACTION_SENDER(eosio::token, transfer)( N(eosio.token), {N(eosio.jit),N(active)},\n                                                        { N(eosio.jit), current.high_bidder, asset(current.high_bid),\n                                                        std::string(\"refund bid to \")+(name{bidder}).to_string()  } );\n       }\n       current.high_bidder = bidder;\n       current.high_bid = bid.amount;\n       current.last_bid_time = current_time();\n       _jitbid.set(current, _self);\n    }\n\n   void system_contract::boost(account_name account) {\n      require_auth( N(eosio) );\n      eosio_assert(is_account(account), \"account does not exist\");\n       eosio_assert(_boost.find(account) == _boost.end(), \"account already accelerated\");\n      _boost.emplace( N(eosio), [&]( auto& p ) {\n            p.account = account;\n            p.expiration = uint64_t(-1);\n      });\n      jit_bid bid = _jitbid.get();\n      bid.jit_remains -= 1;\n      _jitbid.set(bid, 0);\n   }\n\n   void system_contract::cancelboost(account_name account) {\n      require_auth( N(eosio) );\n      eosio_assert(is_account(account), \"account does not exist\");\n      auto itr = _boost.find(account);\n      eosio_assert( itr != _boost.end(), \"account not in list\" );\n      _boost.erase(itr);\n      jit_bid bid = _jitbid.get();\n      bid.jit_remains += 1;\n      _jitbid.set(bid, 0);\n   }\n\n\n   void native::newaccount( account_name     creator,\n                            account_name     newact\n                             ) {\n\n      if( creator != _self ) {\n         auto tmp = newact >> 4;\n         bool has_dot = false;\n\n         for( uint32_t i = 0; i < 12; ++i ) {\n           has_dot |= !(tmp & 0x1f);\n           tmp >>= 5;\n         }\n         if( has_dot ) {\n            auto suffix = eosio::name_suffix(newact);\n            if( suffix == newact ) {\n               name_bid_table bids(_self,_self);\n               auto current = bids.find( newact );\n               eosio_assert( current != bids.end(), \"no active bid for name\" );\n               eosio_assert( current->high_bidder == creator, \"only highest bidder can claim\" );\n               eosio_assert( current->high_bid < 0, \"auction for name is not closed yet\" );\n               bids.erase( current );\n            } else {\n               eosio_assert( creator == suffix, \"only suffix may create this account\" );\n            }\n         }\n      }\n\n      user_resources_table  userres( _self, newact);\n\n      userres.emplace( newact, [&]( auto& res ) {\n        res.owner = newact;\n      });\n\n      set_resource_limits( newact, 0, 0, 0 );\n   }\n\n}\n\n\nEOSIO_ABI( eosiosystem::system_contract,\n\n     (newaccount)(updateauth)(deleteauth)(linkauth)(unlinkauth)(canceldelay)(onerror)\n\n     (setram)(setparams)(setpriv)(rmvproducer)(bidname)(boost)(cancelboost)(bidjit)\n\n     (buyrambytes)(buyram)(sellram)(delegatebw)(undelegatebw)(refund)\n\n     (regproducer)(unregprod)(voteproducer)(regproxy)\n\n     (onblock)(claimrewards)\n)\n\n'pyeos/contracts/eosio.system/voting.cpp'\n:\n#include \"eosio.system.hpp\"\n\n#include <eosiolib/eosio.hpp>\n#include <eosiolib/crypto.h>\n#include <eosiolib/print.hpp>\n#include <eosiolib/datastream.hpp>\n#include <eosiolib/serialize.hpp>\n#include <eosiolib/multi_index.hpp>\n#include <eosiolib/privileged.hpp>\n#include <eosiolib/singleton.hpp>\n#include <eosiolib/transaction.hpp>\n#include <eosio.token/eosio.token.hpp>\n\n#include <algorithm>\n#include <cmath>\n\nnamespace eosiosystem {\n   using eosio::indexed_by;\n   using eosio::const_mem_fun;\n   using eosio::bytes;\n   using eosio::print;\n   using eosio::singleton;\n   using eosio::transaction;\n\n\n   void system_contract::regproducer( const account_name producer, const eosio::public_key& producer_key, const std::string& url, uint16_t location ) {\n      eosio_assert( url.size() < 512, \"url too long\" );\n      eosio_assert( producer_key != eosio::public_key(), \"public key should not be the default value\" );\n      require_auth( producer );\n\n      auto prod = _producers.find( producer );\n\n      if ( prod != _producers.end() ) {\n         _producers.modify( prod, producer, [&]( producer_info& info ){\n               info.producer_key = producer_key;\n               info.is_active    = true;\n               info.url          = url;\n               info.location     = location;\n            });\n      } else {\n         _producers.emplace( producer, [&]( producer_info& info ){\n               info.owner         = producer;\n               info.total_votes   = 0;\n               info.producer_key  = producer_key;\n               info.is_active     = true;\n               info.url           = url;\n               info.location      = location;\n         });\n      }\n   }\n\n   void system_contract::unregprod( const account_name producer ) {\n      require_auth( producer );\n\n      const auto& prod = _producers.get( producer, \"producer not found\" );\n\n      _producers.modify( prod, 0, [&]( producer_info& info ){\n            info.deactivate();\n      });\n   }\n\n   void system_contract::update_elected_producers( block_timestamp block_time ) {\n      _gstate.last_producer_schedule_update = block_time;\n\n      auto idx = _producers.get_index<N(prototalvote)>();\n\n      std::vector< std::pair<eosio::producer_key,uint16_t> > top_producers;\n      top_producers.reserve(21);\n\n      for ( auto it = idx.cbegin(); it != idx.cend() && top_producers.size() < 21 && 0 < it->total_votes && it->active(); ++it ) {\n         top_producers.emplace_back( std::pair<eosio::producer_key,uint16_t>({{it->owner, it->producer_key}, it->location}) );\n      }\n\n      if ( top_producers.size() < _gstate.last_producer_schedule_size ) {\n         return;\n      }\n\n\n      std::sort( top_producers.begin(), top_producers.end() );\n\n      std::vector<eosio::producer_key> producers;\n\n      producers.reserve(top_producers.size());\n      for( const auto& item : top_producers )\n         producers.push_back(item.first);\n\n      bytes packed_schedule = pack(producers);\n\n      if( set_proposed_producers( packed_schedule.data(),  packed_schedule.size() ) >= 0 ) {\n         _gstate.last_producer_schedule_size = static_cast<decltype(_gstate.last_producer_schedule_size)>( top_producers.size() );\n      }\n   }\n\n   double stake2vote( int64_t staked ) {\n\n      double weight = int64_t( (now() - (block_timestamp::block_timestamp_epoch / 1000)) / (seconds_per_day * 7) )  / double( 52 );\n      return double(staked) * std::pow( 2, weight );\n   }\n\n   void system_contract::voteproducer( const account_name voter_name, const account_name proxy, const std::vector<account_name>& producers ) {\n      require_auth( voter_name );\n      update_votes( voter_name, proxy, producers, true );\n   }\n\n   void system_contract::update_votes( const account_name voter_name, const account_name proxy, const std::vector<account_name>& producers, bool voting ) {\n\n      if ( proxy ) {\n         eosio_assert( producers.size() == 0, \"cannot vote for producers and proxy at same time\" );\n         eosio_assert( voter_name != proxy, \"cannot proxy to self\" );\n         require_recipient( proxy );\n      } else {\n         eosio_assert( producers.size() <= 30, \"attempt to vote for too many producers\" );\n         for( size_t i = 1; i < producers.size(); ++i ) {\n            eosio_assert( producers[i-1] < producers[i], \"producer votes must be unique and sorted\" );\n         }\n      }\n\n      auto voter = _voters.find(voter_name);\n      eosio_assert( voter != _voters.end(), \"user must stake before they can vote\" );\n      eosio_assert( !proxy || !voter->is_proxy, \"account registered as a proxy is not allowed to use a proxy\" );\n\n\n      if( voter->last_vote_weight <= 0.0 ) {\n         _gstate.total_activated_stake += voter->staked;\n         if( _gstate.total_activated_stake >= min_activated_stake && _gstate.thresh_activated_stake_time == 0 ) {\n            _gstate.thresh_activated_stake_time = current_time();\n         }\n      }\n\n      auto new_vote_weight = stake2vote( voter->staked );\n      if( voter->is_proxy ) {\n         new_vote_weight += voter->proxied_vote_weight;\n      }\n\n      boost::container::flat_map<account_name, pair<double, bool > > producer_deltas;\n      if ( voter->last_vote_weight > 0 ) {\n         if( voter->proxy ) {\n            auto old_proxy = _voters.find( voter->proxy );\n            eosio_assert( old_proxy != _voters.end(), \"old proxy not found\" );\n            _voters.modify( old_proxy, 0, [&]( auto& vp ) {\n                  vp.proxied_vote_weight -= voter->last_vote_weight;\n               });\n            propagate_weight_change( *old_proxy );\n         } else {\n            for( const auto& p : voter->producers ) {\n               auto& d = producer_deltas[p];\n               d.first -= voter->last_vote_weight;\n               d.second = false;\n            }\n         }\n      }\n\n      if( proxy ) {\n         auto new_proxy = _voters.find( proxy );\n         eosio_assert( new_proxy != _voters.end(), \"invalid proxy specified\" );\n         eosio_assert( !voting || new_proxy->is_proxy, \"proxy not found\" );\n         if ( new_vote_weight >= 0 ) {\n            _voters.modify( new_proxy, 0, [&]( auto& vp ) {\n                  vp.proxied_vote_weight += new_vote_weight;\n               });\n            propagate_weight_change( *new_proxy );\n         }\n      } else {\n         if( new_vote_weight >= 0 ) {\n            for( const auto& p : producers ) {\n               auto& d = producer_deltas[p];\n               d.first += new_vote_weight;\n               d.second = true;\n            }\n         }\n      }\n\n      for( const auto& pd : producer_deltas ) {\n         auto pitr = _producers.find( pd.first );\n         if( pitr != _producers.end() ) {\n            eosio_assert( !voting || pitr->active() || !pd.second.second , \"producer is not currently registered\" );\n            _producers.modify( pitr, 0, [&]( auto& p ) {\n               p.total_votes += pd.second.first;\n               if ( p.total_votes < 0 ) {\n                  p.total_votes = 0;\n               }\n               _gstate.total_producer_vote_weight += pd.second.first;\n\n            });\n         } else {\n            eosio_assert( !pd.second.second , \"producer is not registered\" );\n         }\n      }\n\n      _voters.modify( voter, 0, [&]( auto& av ) {\n         av.last_vote_weight = new_vote_weight;\n         av.producers = producers;\n         av.proxy     = proxy;\n      });\n   }\n\n\n   void system_contract::regproxy( const account_name proxy, bool isproxy ) {\n      require_auth( proxy );\n\n      auto pitr = _voters.find(proxy);\n      if ( pitr != _voters.end() ) {\n         eosio_assert( isproxy != pitr->is_proxy, \"action has no effect\" );\n         eosio_assert( !isproxy || !pitr->proxy, \"account that uses a proxy is not allowed to become a proxy\" );\n         _voters.modify( pitr, 0, [&]( auto& p ) {\n               p.is_proxy = isproxy;\n            });\n         propagate_weight_change( *pitr );\n      } else {\n         _voters.emplace( proxy, [&]( auto& p ) {\n               p.owner  = proxy;\n               p.is_proxy = isproxy;\n            });\n      }\n   }\n\n   void system_contract::propagate_weight_change( const voter_info& voter ) {\n      eosio_assert( voter.proxy == 0 || !voter.is_proxy, \"account registered as a proxy is not allowed to use a proxy\" );\n      double new_weight = stake2vote( voter.staked );\n      if ( voter.is_proxy ) {\n         new_weight += voter.proxied_vote_weight;\n      }\n\n\n      if ( fabs( new_weight - voter.last_vote_weight ) > 1 )  {\n         if ( voter.proxy ) {\n            auto& proxy = _voters.get( voter.proxy, \"proxy not found\" );\n            _voters.modify( proxy, 0, [&]( auto& p ) {\n                  p.proxied_vote_weight += new_weight - voter.last_vote_weight;\n               }\n            );\n            propagate_weight_change( proxy );\n         } else {\n            auto delta = new_weight - voter.last_vote_weight;\n            for ( auto acnt : voter.producers ) {\n               auto& pitr = _producers.get( acnt, \"producer not found\" );\n               _producers.modify( pitr, 0, [&]( auto& p ) {\n                     p.total_votes += delta;\n                     _gstate.total_producer_vote_weight += delta;\n               });\n            }\n         }\n      }\n      _voters.modify( voter, 0, [&]( auto& v ) {\n            v.last_vote_weight = new_weight;\n         }\n      );\n   }\n\n}\n",
        "gt": [
            "'pyeos/contracts/eosiolib/privileged.hpp'",
            "'pyeos/contracts/eosio.system/voting.cpp'",
            "'pyeos/contracts/eosio.system/eosio.system.cpp'"
        ]
    },
    {
        "files": [
            "'miniselect/testing/test_common.h'",
            "'miniselect/include/miniselect/median_of_medians.h'",
            "'miniselect/fuzz/fuzz_sort.cpp'",
            "'miniselect/include/miniselect/private/median_common.h'"
        ],
        "content": "'miniselect/testing/test_common.h'\n:\n#pragma once\n\n#include <gtest/gtest.h>\n\n#include <algorithm>\n\n#include \"miniselect/floyd_rivest_select.h\"\n#include \"miniselect/heap_select.h\"\n#include \"miniselect/median_of_3_random.h\"\n#include \"miniselect/median_of_medians.h\"\n#include \"miniselect/median_of_ninthers.h\"\n#include \"miniselect/pdqselect.h\"\n\nnamespace miniselect {\nnamespace algorithms {\n\nstruct STD {\n  template <class Iter, class Compare>\n  static void Sort(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    std::partial_sort(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Sort(Iter begin, Iter mid, Iter end) {\n    std::partial_sort(begin, mid, end);\n  }\n\n  template <class Iter, class Compare>\n  static void Select(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    std::nth_element(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Select(Iter begin, Iter mid, Iter end) {\n    std::nth_element(begin, mid, end);\n  }\n};\n\nstruct PDQ {\n  template <class Iter, class Compare>\n  static void Sort(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    pdqpartial_sort(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Sort(Iter begin, Iter mid, Iter end) {\n    pdqpartial_sort(begin, mid, end);\n  }\n\n  template <class Iter, class Compare>\n  static void Select(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    pdqselect(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Select(Iter begin, Iter mid, Iter end) {\n    pdqselect(begin, mid, end);\n  }\n};\n\nstruct PDQBranchless {\n  template <class Iter, class Compare>\n  static void Sort(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    pdqpartial_sort_branchless(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Sort(Iter begin, Iter mid, Iter end) {\n    pdqpartial_sort_branchless(begin, mid, end);\n  }\n\n  template <class Iter, class Compare>\n  static void Select(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    pdqselect_branchless(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Select(Iter begin, Iter mid, Iter end) {\n    pdqselect_branchless(begin, mid, end);\n  }\n};\n\nstruct FloydRivest {\n  template <class Iter, class Compare>\n  static void Sort(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    floyd_rivest_partial_sort(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Sort(Iter begin, Iter mid, Iter end) {\n    floyd_rivest_partial_sort(begin, mid, end);\n  }\n\n  template <class Iter, class Compare>\n  static void Select(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    floyd_rivest_select(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Select(Iter begin, Iter mid, Iter end) {\n    floyd_rivest_select(begin, mid, end);\n  }\n};\n\nstruct MedianOfNinthers {\n  template <class Iter, class Compare>\n  static void Sort(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    median_of_ninthers_partial_sort(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Sort(Iter begin, Iter mid, Iter end) {\n    median_of_ninthers_partial_sort(begin, mid, end);\n  }\n\n  template <class Iter, class Compare>\n  static void Select(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    median_of_ninthers_select(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Select(Iter begin, Iter mid, Iter end) {\n    median_of_ninthers_select(begin, mid, end);\n  }\n};\n\nstruct MedianOfMedians {\n  template <class Iter, class Compare>\n  static void Sort(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    median_of_medians_partial_sort(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Sort(Iter begin, Iter mid, Iter end) {\n    median_of_medians_partial_sort(begin, mid, end);\n  }\n\n  template <class Iter, class Compare>\n  static void Select(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    median_of_medians_select(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Select(Iter begin, Iter mid, Iter end) {\n    median_of_medians_select(begin, mid, end);\n  }\n};\n\nstruct MedianOf3Random {\n  template <class Iter, class Compare>\n  static void Sort(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    median_of_3_random_partial_sort(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Sort(Iter begin, Iter mid, Iter end) {\n    median_of_3_random_partial_sort(begin, mid, end);\n  }\n\n  template <class Iter, class Compare>\n  static void Select(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    median_of_3_random_select(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Select(Iter begin, Iter mid, Iter end) {\n    median_of_3_random_select(begin, mid, end);\n  }\n};\n\nstruct Heap {\n  template <class Iter, class Compare>\n  static void Sort(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    heap_partial_sort(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Sort(Iter begin, Iter mid, Iter end) {\n    heap_partial_sort(begin, mid, end);\n  }\n\n  template <class Iter, class Compare>\n  static void Select(Iter begin, Iter mid, Iter end, Compare&& comp) {\n    heap_select(begin, mid, end, std::move(comp));\n  }\n\n  template <class Iter>\n  static void Select(Iter begin, Iter mid, Iter end) {\n    heap_select(begin, mid, end);\n  }\n};\n\nusing All =\n    ::testing::Types<STD, PDQ, PDQBranchless, FloydRivest, MedianOfNinthers,\n                     MedianOfMedians, MedianOf3Random, Heap>;\n\ntemplate <class Integral>\nstruct IntegralCharIterator {\n  using difference_type = Integral;\n  using value_type = char;\n  using pointer = char*;\n  using reference = char&;\n  using iterator_category = std::random_access_iterator_tag;\n\n  IntegralCharIterator() = default;\n  IntegralCharIterator(const IntegralCharIterator& other) : pos(other.pos) {}\n  IntegralCharIterator(IntegralCharIterator&& other) : pos(other.pos) {}\n  IntegralCharIterator& operator=(const IntegralCharIterator& other) {\n    pos = other.pos;\n    return *this;\n  }\n  IntegralCharIterator& operator=(IntegralCharIterator&& other) {\n    pos = other.pos;\n    return *this;\n  }\n  ~IntegralCharIterator() = default;\n  IntegralCharIterator(pointer p) : pos(p) {}\n\n  IntegralCharIterator& operator+=(difference_type other) {\n    pos += other;\n    return *this;\n  }\n\n  IntegralCharIterator& operator-=(difference_type other) {\n    pos -= other;\n    return *this;\n  }\n\n  value_type& operator[](difference_type other) {\n    return pos[static_cast<size_t>(other)];\n  }\n\n  value_type& operator[](difference_type other) const {\n    return pos[static_cast<size_t>(other)];\n  }\n\n  IntegralCharIterator& operator++() {\n    ++pos;\n    return *this;\n  }\n\n  IntegralCharIterator operator++(int) { return IntegralCharIterator(pos++); }\n\n  IntegralCharIterator& operator--() {\n    --pos;\n    return *this;\n  }\n\n  IntegralCharIterator operator--(int) { return IntegralCharIterator(pos--); }\n\n  value_type& operator*() { return *pos; }\n\n  value_type& operator*() const { return *pos; }\n\n  difference_type operator-(const IntegralCharIterator& other) const {\n    return pos - other.pos;\n  }\n\n  IntegralCharIterator operator-(difference_type other) const {\n    return IntegralCharIterator(pos - other);\n  }\n\n  IntegralCharIterator operator+(difference_type other) const {\n    return IntegralCharIterator(pos + other);\n  }\n\n  bool operator==(const IntegralCharIterator& other) const {\n    return pos == other.pos;\n  }\n\n  bool operator!=(const IntegralCharIterator& other) const {\n    return pos != other.pos;\n  }\n\n  bool operator<(const IntegralCharIterator& other) const {\n    return pos < other.pos;\n  }\n\n  bool operator>(const IntegralCharIterator& other) const {\n    return pos > other.pos;\n  }\n\n  bool operator<=(const IntegralCharIterator& other) const {\n    return pos <= other.pos;\n  }\n\n  bool operator>=(const IntegralCharIterator& other) const {\n    return pos >= other.pos;\n  }\n\n  char* pos = nullptr;\n};\n\ntemplate <class Integral>\ninline IntegralCharIterator<Integral> operator+(\n    typename IntegralCharIterator<Integral>::difference_type diff,\n    const IntegralCharIterator<Integral> iter) {\n  return iter + diff;\n}\n\n}\n}\n\n'miniselect/include/miniselect/median_of_medians.h'\n:\n#pragma once\n\n#include <algorithm>\n#include <cassert>\n#include <functional>\n#include <iterator>\n#include <utility>\n\n#include \"private/median_common.h\"\n\nnamespace miniselect {\nnamespace median_of_medians_detail {\n\ntemplate <class Iter, class Compare>\ninline Iter partition(Iter r, Iter end, Compare&& comp) {\n  using CompType = typename median_common_detail::CompareRefType<Compare>::type;\n  using DiffType = typename std::iterator_traits<Iter>::difference_type;\n  const DiffType len = end - r;\n  if (len < 5) {\n    return median_common_detail::pivot_partition(\n        r, static_cast<DiffType>(len / 2), len, comp);\n  }\n  DiffType j = 0;\n  DiffType end_range = len - 5;\n  for (DiffType i = 0; i <= end_range; i += 5, ++j) {\n    median_common_detail::partition5(\n        r, static_cast<DiffType>(i), static_cast<DiffType>(i + 1),\n        static_cast<DiffType>(i + 2), static_cast<DiffType>(i + 3),\n        static_cast<DiffType>(i + 4), comp);\n    std::swap(r[i], r[j]);\n  }\n  median_common_detail::quickselect<Iter, CompType, &partition>(\n      r, r + static_cast<DiffType>(j / 2), r + j, comp);\n  return median_common_detail::pivot_partition(r, static_cast<DiffType>(j / 2),\n                                               len, comp);\n}\n\n}\n\ntemplate <class Iter, class Compare>\ninline void median_of_medians_select(Iter begin, Iter mid, Iter end,\n                                     Compare comp) {\n  if (mid == end) return;\n  using CompType = typename median_common_detail::CompareRefType<Compare>::type;\n\n  median_common_detail::quickselect<\n      Iter, CompType, &median_of_medians_detail::partition<Iter, CompType>>(\n      begin, mid, end, comp);\n}\n\ntemplate <class Iter>\ninline void median_of_medians_select(Iter begin, Iter mid, Iter end) {\n  using T = typename std::iterator_traits<Iter>::value_type;\n  median_of_medians_select(begin, mid, end, std::less<T>());\n}\n\ntemplate <class Iter, class Compare>\ninline void median_of_medians_partial_sort(Iter begin, Iter mid, Iter end,\n                                           Compare comp) {\n  if (begin == mid) return;\n  using CompType = typename median_common_detail::CompareRefType<Compare>::type;\n  median_common_detail::quickselect<\n      Iter, CompType, &median_of_medians_detail::partition<Iter, CompType>>(\n      begin, mid - 1, end, comp);\n  std::sort<Iter, CompType>(begin, mid, comp);\n}\n\ntemplate <class Iter>\ninline void median_of_medians_partial_sort(Iter begin, Iter mid, Iter end) {\n  using T = typename std::iterator_traits<Iter>::value_type;\n  median_of_medians_partial_sort(begin, mid, end, std::less<T>());\n}\n\n}\n\n'miniselect/fuzz/fuzz_sort.cpp'\n:#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\n#include \"test_common.h\"\n\ntemplate <class U, class Iter, class... T>\nvoid ChooseImplementation(uint8_t byte, std::vector<U>& working,\n                          Iter partition_iter, const ::testing::Types<T...>&) {\n  static_assert(sizeof...(T) < 256);\n  int i = 0;\n  constexpr size_t size = sizeof...(T);\n  (\n      [&]() {\n        if (byte % size == i++) {\n          T::Sort(working.begin(), partition_iter, working.end());\n        }\n      }(),\n      ...);\n}\n\nextern \"C\" int LLVMFuzzerTestOneInput(const std::uint8_t* data,\n                                      std::size_t size) {\n  if (size <= 3) return 0;\n  uint8_t impl = data[0];\n  uint16_t partition_point = 0;\n  memcpy(&partition_point, data + 1, 2);\n  partition_point %= (size - 3);\n  std::vector<std::uint8_t> working(data + 3, data + size);\n  auto canonical = working;\n  const auto partition_iter = working.begin() + partition_point;\n  ChooseImplementation(impl, working, partition_iter,\n                       miniselect::algorithms::All{});\n\n  bool is_error = false;\n  if (partition_iter != working.end()) {\n    const auto& nth = *std::min_element(partition_iter, working.end());\n    if (!std::all_of(working.begin(), partition_iter,\n                     [&](const auto& v) { return v <= nth; })) {\n      is_error = true;\n    }\n    if (!std::all_of(partition_iter, working.end(),\n                     [&](const auto& v) { return v >= nth; })) {\n      is_error = true;\n    }\n  }\n  if (!std::is_sorted(working.begin(), partition_iter)) {\n    is_error = true;\n  }\n  if (is_error) {\n    std::cerr << \"FAILED!\\nCanonical: \";\n    for (const auto& s : canonical) {\n      std::cerr << static_cast<int>(s) << ' ';\n    }\n    std::cerr << std::endl;\n    std::cerr << \"Got: \";\n    for (const auto& s : working) {\n      std::cerr << static_cast<int>(s) << ' ';\n    }\n    std::cerr << std::endl;\n    std::cerr << \"partition_iter = \" << partition_iter - working.begin()\n              << std::endl;\n    std::abort();\n  }\n\n  return 0;\n}\n\n'miniselect/include/miniselect/private/median_common.h'\n:\n\n#pragma once\n\n#include <cassert>\n#include <iterator>\n#include <type_traits>\n#include <utility>\n\nnamespace miniselect {\nnamespace median_common_detail {\n\ntemplate <class Compare>\nstruct CompareRefType {\n\n\n  using type = typename std::add_lvalue_reference<Compare>::type;\n};\n\ntemplate <class Iter, class Compare,\n          class DiffType = typename std::iterator_traits<Iter>::difference_type>\ninline void median3(Iter r, DiffType a, DiffType b, DiffType c,\n                    Compare&& comp) {\n  if (comp(r[b], r[a]))\n  {\n    if (comp(r[b], r[c]))\n    {\n      if (comp(r[c], r[a]))\n        std::swap(r[b], r[c]);\n      else\n        std::swap(r[b], r[a]);\n    }\n  } else if (comp(r[c], r[b]))\n  {\n    if (comp(r[c], r[a]))\n      std::swap(r[b], r[a]);\n    else\n      std::swap(r[b], r[c]);\n  }\n}\n\n\ntemplate <class Iter, class Compare,\n          class DiffType = typename std::iterator_traits<Iter>::difference_type>\ninline void sort3(Iter r, DiffType a, DiffType b, DiffType c, Compare&& comp) {\n  typedef typename std::iterator_traits<Iter>::value_type T;\n  if (comp(r[b], r[a]))\n  {\n    if (comp(r[c], r[b]))\n    {\n      std::swap(r[a], r[c]);\n    } else\n    {\n      T t = std::move(r[a]);\n      r[a] = std::move(r[b]);\n      if (comp(r[c], t))\n      {\n        r[b] = std::move(r[c]);\n        r[c] = std::move(t);\n      } else\n      {\n        r[b] = std::move(t);\n      }\n    }\n  } else if (comp(r[c], r[b]))\n  {\n    T t = std::move(r[c]);\n    r[c] = std::move(r[b]);\n    if (comp(t, r[a]))\n    {\n      r[b] = std::move(r[a]);\n      r[a] = std::move(t);\n    } else\n    {\n      r[b] = std::move(t);\n    }\n  }\n\n  assert(!comp(r[b], r[a]) && !comp(r[c], r[b]));\n}\n\n\ntemplate <bool leanRight, class Iter, class Compare,\n          class DiffType = typename std::iterator_traits<Iter>::difference_type>\ninline void partition4(Iter r, DiffType a, DiffType b, DiffType c, DiffType d,\n                       Compare&& comp) {\n  assert(a != b && a != c && a != d && b != c && b != d && c != d);\n   if (leanRight) {\n\n    if (comp(r[c], r[a])) {\n      std::swap(r[a], r[c]);\n    }\n    if (comp(r[d], r[b])) {\n      std::swap(r[b], r[d]);\n    }\n    if (comp(r[d], r[c])) {\n      std::swap(r[c], r[d]);\n      std::swap(r[a], r[b]);\n    }\n    if (comp(r[c], r[b])) {\n      std::swap(r[b], r[c]);\n    }\n  } else {\n\n\n    if (comp(r[c], r[a])) {\n      std::swap(r[a], r[c]);\n    }\n    if (comp(r[c], r[b])) {\n      std::swap(r[b], r[c]);\n    }\n    if (comp(r[d], r[a])) {\n      std::swap(r[a], r[d]);\n    }\n    if (comp(r[d], r[b])) {\n      std::swap(r[b], r[d]);\n    } else {\n      if (comp(r[b], r[a])) {\n        std::swap(r[a], r[b]);\n      }\n    }\n  }\n}\n\n\ntemplate <class Iter, class Compare,\n          class DiffType = typename std::iterator_traits<Iter>::difference_type>\ninline void partition5(Iter r, DiffType a, DiffType b, DiffType c, DiffType d,\n                       DiffType e, Compare&& comp) {\n  assert(a != b && a != c && a != d && a != e && b != c && b != d && b != e &&\n         c != d && c != e && d != e);\n  if (comp(r[c], r[a])) {\n    std::swap(r[a], r[c]);\n  }\n  if (comp(r[d], r[b])) {\n    std::swap(r[b], r[d]);\n  }\n  if (comp(r[d], r[c])) {\n    std::swap(r[c], r[d]);\n    std::swap(r[a], r[b]);\n  }\n  if (comp(r[e], r[b])) {\n    std::swap(r[b], r[e]);\n  }\n  if (comp(r[e], r[c])) {\n    std::swap(r[c], r[e]);\n    if (comp(r[c], r[a])) {\n      std::swap(r[a], r[c]);\n    }\n  } else {\n    if (comp(r[c], r[b])) {\n      std::swap(r[b], r[c]);\n    }\n  }\n}\n\n\ntemplate <class Iter, class Compare,\n          class DiffType = typename std::iterator_traits<Iter>::difference_type>\ninline Iter pivot_partition(Iter r, DiffType k, DiffType length,\n                            Compare&& comp) {\n  assert(k < length);\n  std::swap(*r, r[k]);\n  DiffType lo = 1, hi = length - 1;\n  for (;; ++lo, --hi) {\n    for (;; ++lo) {\n      if (lo > hi) goto loop_done;\n      if (!comp(r[lo], *r)) break;\n    }\n\n    assert(lo <= hi);\n    for (; comp(*r, r[hi]); --hi) {\n    }\n    if (lo >= hi) break;\n\n    std::swap(r[lo], r[hi]);\n  }\nloop_done:\n  --lo;\n  std::swap(r[lo], *r);\n  return r + lo;\n}\n\n\ntemplate <class Iter, class Compare, Iter (*partition)(Iter, Iter, Compare)>\ninline void quickselect(Iter r, Iter mid, Iter end, Compare&& comp) {\n  if (r == end || mid >= end) return;\n  assert(r <= mid && mid < end);\n  for (;;) switch (end - r) {\n      case 1:\n        return;\n      case 2:\n        if (comp(r[1], *r)) std::swap(*r, r[1]);\n        return;\n      case 3:\n        sort3(r, 0, 1, 2, comp);\n        return;\n      case 4:\n        switch (mid - r) {\n          case 0:\n            goto select_min;\n          case 1:\n            partition4<false>(r, 0, 1, 2, 3, comp);\n            break;\n          case 2:\n            partition4<true>(r, 0, 1, 2, 3, comp);\n            break;\n          case 3:\n            goto select_max;\n          default:\n            assert(false);\n        }\n        return;\n      default:\n        assert(end - r > 4);\n        if (r == mid) {\n        select_min:\n          auto pivot = r;\n          for (++mid; mid < end; ++mid)\n            if (comp(*mid, *pivot)) pivot = mid;\n          std::swap(*r, *pivot);\n          return;\n        }\n        if (mid + 1 == end) {\n        select_max:\n          auto pivot = r;\n          for (mid = r + 1; mid < end; ++mid)\n            if (comp(*pivot, *mid)) pivot = mid;\n          std::swap(*pivot, *(end - 1));\n          return;\n        }\n        auto pivot = partition(r, end, comp);\n        if (pivot == mid) return;\n        if (mid < pivot) {\n          end = pivot;\n        } else {\n          r = pivot + 1;\n        }\n    }\n}\n\n\ntemplate <class Iter, class Compare,\n          class DiffType = typename std::iterator_traits<Iter>::difference_type>\ninline DiffType median_index(const Iter r, DiffType a, DiffType b, DiffType c,\n                             Compare&& comp) {\n  if (comp(r[c], r[a])) std::swap(a, c);\n  if (comp(r[c], r[b])) return c;\n  if (comp(r[b], r[a])) return a;\n  return b;\n}\n\n\ntemplate <bool leanRight, class Iter, class Compare,\n          class DiffType = typename std::iterator_traits<Iter>::difference_type>\ninline DiffType median_index(Iter r, DiffType a, DiffType b, DiffType c,\n                             DiffType d, Compare&& comp) {\n  if (comp(r[d], r[c])) std::swap(c, d);\n  if (leanRight) {\n    if (comp(r[c], r[a])) {\n      assert(comp(r[c], r[a]) && !comp(r[d], r[c]));\n      return median_index(r, a, b, d, comp);\n    }\n  } else {\n    if (!comp(r[d], r[a])) {\n      return median_index(r, a, b, c, comp);\n    }\n  }\n\n  if (!comp(r[c], r[b])) return c;\n  if (comp(r[d], r[b])) return d;\n  return b;\n}\n\n\ntemplate <class Iter, class Compare,\n          class DiffType = typename std::iterator_traits<Iter>::difference_type>\ninline void ninther(Iter r, DiffType _1, DiffType _2, DiffType _3, DiffType _4,\n                    DiffType _5, DiffType _6, DiffType _7, DiffType _8,\n                    DiffType _9, Compare&& comp) {\n  _2 = median_index(r, _1, _2, _3, comp);\n  _8 = median_index(r, _7, _8, _9, comp);\n  if (comp(r[_8], r[_2])) std::swap(_2, _8);\n  if (comp(r[_6], r[_4])) std::swap(_4, _6);\n\n\n  if (comp(r[_5], r[_4])) {\n\n  } else if (comp(r[_6], r[_5])) {\n\n    _4 = _6;\n  } else {\n\n    if (comp(r[_5], r[_2])) return std::swap(r[_5], r[_2]);\n    if (comp(r[_8], r[_5])) return std::swap(r[_5], r[_8]);\n\n    return;\n  }\n\n  if (comp(r[_4], r[_2]))\n    _4 = _2;\n  else if (comp(r[_8], r[_4]))\n    _4 = _8;\n  std::swap(r[_5], r[_4]);\n}\n\n\ntemplate <class Iter, class Compare,\n          class DiffType = typename std::iterator_traits<Iter>::difference_type>\ninline DiffType expand_partition_right(Iter r, DiffType hi, DiffType rite,\n                                       Compare&& comp) {\n  DiffType pivot = 0;\n  assert(pivot <= hi);\n  assert(hi <= rite);\n\n  for (; pivot < hi; --rite) {\n    if (rite == hi) goto done;\n    if (!comp(r[rite], r[0])) continue;\n    ++pivot;\n    std::swap(r[rite], r[pivot]);\n  }\n\n  for (; rite > pivot; --rite) {\n    if (!comp(r[rite], r[0])) continue;\n    while (rite > pivot) {\n      ++pivot;\n      if (comp(r[0], r[pivot])) {\n        std::swap(r[rite], r[pivot]);\n        break;\n      }\n    }\n  }\n\ndone:\n  std::swap(r[0], r[pivot]);\n  return pivot;\n}\n\n\ntemplate <class Iter, class Compare,\n          class DiffType = typename std::iterator_traits<Iter>::difference_type>\ninline DiffType expand_partition_left(Iter r, DiffType lo, DiffType pivot,\n                                      Compare&& comp) {\n  assert(lo > 0 && lo <= pivot);\n  DiffType left = 0;\n  const auto oldPivot = pivot;\n  for (; lo < pivot; ++left) {\n    if (left == lo) goto done;\n    if (!comp(r[oldPivot], r[left])) continue;\n    --pivot;\n    std::swap(r[left], r[pivot]);\n  }\n\n  for (;; ++left) {\n    if (left == pivot) break;\n    if (!comp(r[oldPivot], r[left])) continue;\n    for (;;) {\n      if (left == pivot) goto done;\n      --pivot;\n      if (comp(r[pivot], r[oldPivot])) {\n        std::swap(r[left], r[pivot]);\n        break;\n      }\n    }\n  }\n\ndone:\n  std::swap(r[oldPivot], r[pivot]);\n  return pivot;\n}\n\n\ntemplate <class Iter, class Compare,\n          class DiffType = typename std::iterator_traits<Iter>::difference_type>\ninline DiffType expand_partition(Iter r, DiffType lo, DiffType pivot,\n                                 DiffType hi, DiffType length, Compare&& comp) {\n  assert(lo <= pivot && pivot < hi && hi <= length);\n  --hi;\n  --length;\n  DiffType left = 0;\n  for (;; ++left, --length) {\n    for (;; ++left) {\n      if (left == lo)\n        return pivot + expand_partition_right(r + pivot, hi - pivot,\n                                              length - pivot, comp);\n      if (comp(r[pivot], r[left])) break;\n    }\n    for (;; --length) {\n      if (length == hi)\n        return left +\n               expand_partition_left(r + left, lo - left, pivot - left, comp);\n      if (!comp(r[pivot], r[length])) break;\n    }\n    std::swap(r[left], r[length]);\n  }\n}\n\n}\n}\n",
        "gt": [
            "'miniselect/include/miniselect/private/median_common.h'",
            "'miniselect/include/miniselect/median_of_medians.h'",
            "'miniselect/testing/test_common.h'",
            "'miniselect/fuzz/fuzz_sort.cpp'"
        ]
    },
    {
        "files": [
            "'krusader/app/BookMan/krbookmarkhandler.h'",
            "'krusader/app/BookMan/krbookmark.h'",
            "'krusader/app/krslots.cpp'"
        ],
        "content": "'krusader/app/BookMan/krbookmarkhandler.h'\n:\n\n#ifndef KRBOOKMARKHANDLER_H\n#define KRBOOKMARKHANDLER_H\n\n\n#include <QEvent>\n#include <QMap>\n#include <QObject>\n#include <QPointer>\n#include <QUrl>\n\n#include <QDomEntity>\n\n#include <QLineEdit>\n#include <QMenu>\n#include <QWidgetAction>\n\n#include \"krbookmark.h\"\n\nclass KActionCollection;\nclass KBookmarkManager;\nclass KBookmarkMenu;\nclass KrMainWindow;\n\nclass KrBookmarkHandler : public QObject\n{\n    Q_OBJECT\n    friend class KrAddBookmarkDlg;\n    enum Actions { BookmarkCurrent = 0, ManageBookmarks };\n\npublic:\n    explicit KrBookmarkHandler(KrMainWindow *mainWindow);\n    ~KrBookmarkHandler() override;\n    void populate(QMenu *menu);\n    void addBookmark(KrBookmark *bm, KrBookmark *parent = nullptr);\n    void bookmarkCurrent(QUrl url);\n\nprotected:\n    void deleteBookmark(KrBookmark *bm);\n    void importFromFile();\n    bool importFromFileBookmark(QDomElement &e, KrBookmark *parent, const QString &path, QString *errorMsg);\n    bool importFromFileFolder(QDomNode &first, KrBookmark *parent, const QString &path, QString *errorMsg);\n    void exportToFile();\n    void exportToFileFolder(QDomDocument &doc, QDomElement &parent, KrBookmark *folder);\n    void exportToFileBookmark(QDomDocument &doc, QDomElement &where, KrBookmark *bm);\n    void clearBookmarks(KrBookmark *root, bool removeBookmarks = true);\n    void buildMenu(KrBookmark *parent, QMenu *menu, int depth = 0);\n\n    bool eventFilter(QObject *obj, QEvent *ev) override;\n    void rightClicked(QMenu *menu, KrBookmark *bm);\n    void rightClickOnSpecialBookmark();\n\n    void removeReferences(KrBookmark *root, KrBookmark *bmToRemove);\n\nprotected slots:\n    void bookmarksChanged(const QString &);\n    void slotActivated(const QUrl &url);\n\nprivate:\n    KrMainWindow *_mainWindow;\n    KActionCollection *_collection, *_privateCollection;\n    KrBookmark *_root;\n\n    KBookmarkManager *manager;\n    KBookmarkMenu *bookmarksMenu;\n    bool _middleClick;\n\n    QPointer<QMenu> _mainBookmarkPopup;\n    QList<QAction *> _specialBookmarks;\n\n    QWidgetAction *_quickSearchAction;\n    QLineEdit *_quickSearchBar;\n    QMenu *_quickSearchMenu;\n    QHash<QAction *, QString> _quickSearchOriginalActionTitles;\n\n    void _setQuickSearchText(const QString &text);\n    QString _quickSearchText() const;\n    static void _highlightAction(QAction *action, bool isMatched = true);\n    void _resetActionTextAndHighlighting();\n};\n\nQ_DECLARE_METATYPE(KrBookmark *)\n\n#endif\n\n'krusader/app/BookMan/krbookmark.h'\n:\n\n#ifndef KRBOOKMARK_H\n#define KRBOOKMARK_H\n\n\n#include <QList>\n#include <QUrl>\n\n#include <QAction>\n\nclass KActionCollection;\nclass ListPanelActions;\n\nclass KrBookmark : public QAction\n{\n    Q_OBJECT\npublic:\n    KrBookmark(const QString &name, QUrl url, KActionCollection *parent, const QString &iconName = \"\", const QString &actionName = QString());\n    explicit KrBookmark(const QString &name, const QString &iconName = \"\");\n    ~KrBookmark() override;\n\n\n\n\n    void setIconName(const QString &iconName);\n\n    inline const QString &iconName() const\n    {\n        return _iconName;\n    }\n\n    inline const QUrl &url() const\n    {\n        return _url;\n    }\n    inline void setURL(const QUrl &url)\n    {\n        _url = url;\n    }\n    inline bool isFolder() const\n    {\n        return _folder;\n    }\n    inline bool isSeparator() const\n    {\n        return _separator;\n    }\n    QList<KrBookmark *> &children()\n    {\n        return _children;\n    }\n\n    static KrBookmark *getExistingBookmark(const QString &actionName, KActionCollection *collection);\n\n\n    static KrBookmark *trash(KActionCollection *collection);\n    static KrBookmark *virt(KActionCollection *collection);\n    static KrBookmark *lan(KActionCollection *collection);\n    static QAction *jumpBackAction(KActionCollection *collection, bool isSetter = false, ListPanelActions *sourceActions = nullptr);\n    static KrBookmark *separator();\n\nsignals:\n    void activated(const QUrl &url);\n\nprotected slots:\n    void activatedProxy();\n\nprivate:\n    QUrl _url;\n    QString _iconName;\n    bool _folder;\n    bool _separator;\n    bool _autoDelete;\n    QList<KrBookmark *> _children;\n};\n\n#endif\n\n'krusader/app/krslots.cpp'\n:\n\n#include \"krslots.h\"\n\n\n#include <QDir>\n#include <QEvent>\n#include <QList>\n#include <QPoint>\n#include <QStringList>\n#include <QTemporaryFile>\n\n#include <QKeyEvent>\n#include <QPixmapCache>\n\n#include <QApplication>\n\n#include <KIO/FileCopyJob>\n#include <KLocalizedString>\n#include <KMessageBox>\n#include <KSharedConfig>\n#include <KShell>\n#include <KToggleAction>\n#include <utility>\n\n#include \"defaults.h\"\n#include \"icon.h\"\n#include \"kractions.h\"\n#include \"krservices.h\"\n#include \"krtrashhandler.h\"\n#include \"krusader.h\"\n#include \"krusaderview.h\"\n#include \"panelmanager.h\"\n\n#include \"ActionMan/actionman.h\"\n#include \"BookMan/krbookmarkbutton.h\"\n#include \"BookMan/krbookmarkhandler.h\"\n#include \"Dialogs/krdialogs.h\"\n#include \"Dialogs/krspecialwidgets.h\"\n#include \"Dialogs/krspwidgets.h\"\n#include \"DiskUsage/diskusagegui.h\"\n#include \"FileSystem/fileitem.h\"\n#include \"FileSystem/filesystem.h\"\n#include \"FileSystem/krquery.h\"\n#include \"GUI/dirhistorybutton.h\"\n#include \"GUI/kcmdline.h\"\n#include \"GUI/kfnkeys.h\"\n#include \"GUI/krusaderstatus.h\"\n#include \"GUI/mediabutton.h\"\n#include \"GUI/terminaldock.h\"\n#include \"KViewer/krviewer.h\"\n#include \"Konfigurator/konfigurator.h\"\n#include \"Locate/locate.h\"\n#include \"MountMan/kmountman.h\"\n#include \"Panel/PanelView/krselectionmode.h\"\n#include \"Panel/PanelView/krview.h\"\n#include \"Panel/PanelView/krviewfactory.h\"\n#include \"Panel/PanelView/krviewitem.h\"\n#include \"Panel/listpanel.h\"\n#include \"Panel/panelfunc.h\"\n#include \"Panel/sidebar.h\"\n#include \"Search/krsearchdialog.h\"\n#include \"Search/krsearchmod.h\"\n#include \"Splitter/combiner.h\"\n#include \"Splitter/splitter.h\"\n#include \"Splitter/splittergui.h\"\n\n#ifdef SYNCHRONIZER_ENABLED\n#include \"Synchronizer/synchronizergui.h\"\n#endif\n\n#define ACTIVE_VIEW _mainWindow->activeView()\n\nstatic const QStringList kKioSupportCompareApps = {\"kdiff3\", \"kompare\"};\n\nKrSlots::KrSlots(QObject *parent)\n    : QObject(parent)\n    , _mainWindow(krApp)\n{\n}\n\nvoid KrSlots::sendFileByEmail(const QList<QUrl> &urls)\n{\n    if (urls.count() == 0) {\n        KMessageBox::error(nullptr, i18n(\"No selected files to send.\"));\n        return;\n    }\n\n    QString mailProg;\n    QStringList lst = KrServices::supportedTools();\n    if (lst.contains(\"MAIL\"))\n        mailProg = lst[lst.indexOf(\"MAIL\") + 1];\n    else {\n        KMessageBox::error(nullptr, i18n(\"Krusader cannot find a supported mail client. Please install one to your path. Hint: Krusader supports KMail.\"));\n        return;\n    }\n\n    QString subject, separator;\n    for (const QUrl &url : urls) {\n        subject += separator + url.fileName();\n        separator = ',';\n    }\n    subject = i18np(\"Sending file: %2\", \"Sending files: %2\", urls.count(), subject);\n\n    KProcess proc;\n\n    QString executable = QUrl::fromLocalFile(mailProg).fileName();\n    if (executable == QStringLiteral(\"kmail\")) {\n        proc << mailProg << \"--subject\" << subject;\n        for (const QUrl &url2 : urls)\n            proc << \"--attach\" << url2.toDisplayString();\n    } else if (executable == QStringLiteral(\"thunderbird\")) {\n        QString param = \"attachment=\\'\";\n        separator = \"\";\n        for (const QUrl &url2 : urls) {\n            param += separator + url2.toDisplayString();\n            separator = ',';\n        }\n        param += \"\\',subject=\\'\" + subject + \"\\'\";\n        proc << mailProg << \"--compose\" << param;\n    } else if (executable == QStringLiteral(\"evolution\")) {\n        QString param = \"mailto:?cc=&subject=\" + subject + \"&attach=\";\n        separator = \"\";\n        for (const QUrl &url2 : urls) {\n            param += separator + url2.toDisplayString();\n            separator = \"&attach=\";\n        }\n        proc << mailProg << param + \"\";\n    }\n\n    if (!proc.startDetached())\n        KMessageBox::error(nullptr, i18n(\"Error executing %1.\", mailProg));\n}\n\nvoid KrSlots::compareContent()\n{\n    const QStringList lstLeft = LEFT_PANEL->getSelectedNames();\n    const QStringList lstRight = RIGHT_PANEL->getSelectedNames();\n    const QStringList lstActive = ACTIVE_PANEL->gui->isLeft() ? lstLeft : lstRight;\n    QUrl name1, name2;\n\n    if (lstLeft.count() == 1 && lstRight.count() == 1) {\n\n        name1 = LEFT_PANEL->func->files()->getUrl(lstLeft[0]);\n        name2 = RIGHT_PANEL->func->files()->getUrl(lstRight[0]);\n    } else if (lstActive.count() == 2) {\n\n        name1 = ACTIVE_PANEL->func->files()->getUrl(lstActive[0]);\n        name2 = ACTIVE_PANEL->func->files()->getUrl(lstActive[1]);\n    } else if (ACTIVE_PANEL->otherPanel()->func->files()->getFileItem(ACTIVE_VIEW->getCurrentItem())) {\n\n        name1 = ACTIVE_PANEL->func->files()->getUrl(ACTIVE_VIEW->getCurrentItem());\n        name2 = ACTIVE_PANEL->otherPanel()->func->files()->getUrl(ACTIVE_VIEW->getCurrentItem());\n    } else {\n\n        KMessageBox::error(nullptr,\n                           \"<qt>\" + i18n(\"Do not know which files to compare.\") + \"<br/><br/>\"\n                               + i18n(\"To compare two files by content, you can either:<ul><li>Select one file in the left panel, and one in the right \"\n                                      \"panel.</li><li>Select exactly two files in the active panel.</li><li>Make sure there is a file in the other panel, with \"\n                                      \"the same name as the current file in the active panel.</li></ul>\")\n                               + \"</qt>\");\n\n        return;\n    }\n\n\n\n    compareContent(name1, name2);\n}\n\nbool downloadToTemp(const QUrl &url, QString &dest)\n{\n    QTemporaryFile tmpFile;\n    tmpFile.setAutoRemove(false);\n    if (tmpFile.open()) {\n        dest = tmpFile.fileName();\n        KIO::Job *job = KIO::file_copy(url, QUrl::fromLocalFile(dest), -1, KIO::Overwrite | KIO::HideProgressInfo);\n        if (!job->exec()) {\n            KMessageBox::error(krApp, i18n(\"Krusader is unable to download %1\", url.fileName()));\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n\nvoid KrSlots::compareContent(const QUrl &url1, const QUrl &url2)\n{\n    QString diffProg;\n    QStringList lst = KrServices::supportedTools();\n    if (lst.contains(\"DIFF\"))\n        diffProg = lst[lst.indexOf(\"DIFF\") + 1];\n    else {\n        KMessageBox::error(nullptr,\n                           i18n(\"Krusader cannot find any of the supported diff-frontends. Please install one to your path. Hint: Krusader supports Kompare, \"\n                                \"KDiff3 and Xxdiff.\"));\n        return;\n    }\n\n    QString tmp1;\n    QString tmp2;\n    if (kKioSupportCompareApps.contains(QUrl::fromLocalFile(diffProg).fileName())) {\n        tmp1 = url1.toDisplayString();\n        tmp2 = url2.toDisplayString();\n    } else {\n        if (!url1.isLocalFile()) {\n            if (!downloadToTemp(url1, tmp1)) {\n                return;\n            }\n        } else\n            tmp1 = url1.path();\n        if (!url2.isLocalFile()) {\n            if (!downloadToTemp(url2, tmp2)) {\n                if (tmp1 != url1.path()) {\n                    QFile::remove(tmp1);\n                }\n                return;\n            }\n        } else\n            tmp2 = url2.path();\n    }\n\n    KrProcess *p = new KrProcess(tmp1 != url1.path() ? tmp1 : QString(), tmp2 != url2.path() ? tmp2 : QString());\n    *p << diffProg << tmp1 << tmp2;\n    p->start();\n    if (!p->waitForStarted()) {\n        KMessageBox::error(nullptr, i18n(\"Error executing %1.\", diffProg));\n    }\n}\n\n\nvoid KrSlots::toggleFnkeys()\n{\n    if (MAIN_VIEW->fnKeys()->isVisible())\n        MAIN_VIEW->fnKeys()->hide();\n    else\n        MAIN_VIEW->fnKeys()->show();\n}\n\nvoid KrSlots::toggleCmdline()\n{\n    if (MAIN_VIEW->cmdLine()->isVisible())\n        MAIN_VIEW->cmdLine()->hide();\n    else\n        MAIN_VIEW->cmdLine()->show();\n}\n\nvoid KrSlots::updateStatusbarVisibility()\n{\n    krApp->statusBar()->setVisible(KrActions::actShowStatusBar->isChecked());\n}\n\nvoid KrSlots::toggleTerminal()\n{\n    MAIN_VIEW->setTerminalEmulator(KrActions::actToggleTerminal->isChecked());\n}\n\nvoid KrSlots::insertFileName(bool fullPath)\n{\n    QString filename = ACTIVE_VIEW->getCurrentItem();\n    if (filename.isEmpty()) {\n        return;\n    }\n\n    if (fullPath) {\n        const QString path = FileSystem::ensureTrailingSlash(ACTIVE_PANEL->virtualPath()).toDisplayString(QUrl::PreferLocalFile);\n        filename = path + filename;\n    }\n\n    filename = KrServices::quote(filename);\n\n    if (MAIN_VIEW->cmdLine()->isVisible() || !MAIN_VIEW->terminalDock()->isTerminalVisible()) {\n        QString current = MAIN_VIEW->cmdLine()->text();\n        if (current.length() != 0 && !current.endsWith(' '))\n            current += ' ';\n        MAIN_VIEW->cmdLine()->setText(current + filename);\n        MAIN_VIEW->cmdLine()->setFocus();\n    } else if (MAIN_VIEW->terminalDock()->isTerminalVisible()) {\n        filename = ' ' + filename + ' ';\n        MAIN_VIEW->terminalDock()->sendInput(filename, false);\n        MAIN_VIEW->terminalDock()->setFocus();\n    }\n}\n\nvoid KrSlots::refresh(const QUrl &u)\n{\n    ACTIVE_FUNC->openUrl(u);\n}\n\nvoid KrSlots::runKonfigurator(bool firstTime)\n{\n    auto *konfigurator = new Konfigurator(firstTime);\n    connect(konfigurator, &Konfigurator::configChanged, this, &KrSlots::configChanged);\n\n\n    konfigurator->exec();\n\n    delete konfigurator;\n}\n\nvoid KrSlots::configChanged(bool isGUIRestartNeeded)\n{\n    krConfig->sync();\n\n    if (isGUIRestartNeeded) {\n        krApp->setUpdatesEnabled(false);\n        KConfigGroup group(krConfig, \"Look&Feel\");\n        FileItem::loadUserDefinedFolderIcons(group.readEntry(\"Load User Defined Folder Icons\", _UserDefinedFolderIcons));\n\n        bool leftActive = ACTIVE_PANEL->gui->isLeft();\n        MAIN_VIEW->leftManager()->slotRecreatePanels();\n        MAIN_VIEW->rightManager()->slotRecreatePanels();\n        if (leftActive)\n            LEFT_PANEL->slotFocusOnMe();\n        else\n            RIGHT_PANEL->slotFocusOnMe();\n        MAIN_VIEW->fnKeys()->updateShortcuts();\n        KrSelectionMode::resetSelectionHandler();\n        krApp->setUpdatesEnabled(true);\n    }\n\n    krApp->setTray();\n\n\n    MAIN_VIEW->fnKeys()->updateShortcuts();\n\n    const bool showHidden = KConfigGroup(krConfig, \"Look&Feel\").readEntry(\"Show Hidden\", KrActions::actToggleHidden->isChecked());\n\n    if (showHidden != KrActions::actToggleHidden->isChecked()) {\n        KrActions::actToggleHidden->setChecked(showHidden);\n        MAIN_VIEW->leftManager()->reloadConfig();\n        MAIN_VIEW->rightManager()->reloadConfig();\n    }\n}\n\nvoid KrSlots::showHiddenFiles(bool show)\n{\n    KConfigGroup group(krConfig, \"Look&Feel\");\n    group.writeEntry(\"Show Hidden\", show);\n\n    MAIN_VIEW->leftManager()->reloadConfig();\n    MAIN_VIEW->rightManager()->reloadConfig();\n}\n\nvoid KrSlots::swapPanels()\n{\n    QUrl leftURL = LEFT_PANEL->virtualPath();\n    QUrl rightURL = RIGHT_PANEL->virtualPath();\n\n    LEFT_PANEL->func->openUrl(rightURL);\n    RIGHT_PANEL->func->openUrl(leftURL);\n}\n\nvoid KrSlots::toggleSwapSides()\n{\n    MAIN_VIEW->swapSides();\n}\n\nvoid KrSlots::search()\n{\n    if (KrSearchDialog::SearchDialog != nullptr) {\n        KConfigGroup group(krConfig, \"Search\");\n        if (group.readEntry(\"Window Maximized\", false))\n            KrSearchDialog::SearchDialog->showMaximized();\n        else\n            KrSearchDialog::SearchDialog->showNormal();\n\n        KrSearchDialog::SearchDialog->raise();\n        KrSearchDialog::SearchDialog->activateWindow();\n    } else\n        KrSearchDialog::SearchDialog = new KrSearchDialog();\n}\n\nvoid KrSlots::locate()\n{\n    if (!KrServices::cmdExist(\"locate\")) {\n        KMessageBox::error(krApp,\n                           i18n(\"Cannot find the 'locate' command. Please install the \"\n                                \"findutils-locate package of GNU, or set its dependencies in \"\n                                \"Konfigurator\"));\n        return;\n    }\n\n    if (LocateDlg::LocateDialog != nullptr) {\n        LocateDlg::LocateDialog->showNormal();\n        LocateDlg::LocateDialog->raise();\n        LocateDlg::LocateDialog->activateWindow();\n        LocateDlg::LocateDialog->reset();\n    } else\n        LocateDlg::LocateDialog = new LocateDlg(krApp);\n}\n\nvoid KrSlots::runTerminal(const QString &dir)\n{\n    KProcess proc;\n    proc.setWorkingDirectory(dir);\n    KConfigGroup group(krConfig, \"General\");\n    QString term = group.readEntry(\"Terminal\", _Terminal);\n    QStringList sepdArgs = KShell::splitArgs(term, KShell::TildeExpand);\n    if (sepdArgs.isEmpty()) {\n        KMessageBox::error(krMainWindow, i18nc(\"Arg is a string containing the bad quoting.\", \"Bad quoting in terminal command:\\n%1\", term));\n        return;\n    }\n    for (int i = 0; i < sepdArgs.size(); i++) {\n        if (sepdArgs[i] == \"%d\") {\n            sepdArgs[i] = dir;\n        }\n    }\n    proc << sepdArgs;\n    if (!proc.startDetached())\n        KMessageBox::error(krApp, i18n(\"Error executing %1.\", term));\n}\n\nvoid KrSlots::homeTerminal()\n{\n    runTerminal(QDir::homePath());\n}\n\nvoid KrSlots::multiRename()\n{\n    QStringList lst = KrServices::supportedTools();\n    qsizetype i = lst.indexOf(\"RENAME\");\n    if (i == -1) {\n        KMessageBox::error(\n            krApp,\n            i18n(\"Cannot find a batch rename tool.\\nYou can get KRename at %1\", QLatin1String(\"https:\n        return;\n    }\n    QString pathToRename = lst[i + 1];\n\n    const QStringList names = ACTIVE_PANEL->gui->getSelectedNames();\n    if (names.isEmpty()) {\n        return;\n    }\n\n    KProcess proc;\n    proc << pathToRename;\n\n    for (const QString &name : names) {\n        FileItem *file = ACTIVE_FUNC->files()->getFileItem(name);\n        if (!file)\n            continue;\n        const QUrl url = file->getUrl();\n\n        if (file->isDir() && url.scheme() == \"file\") {\n            proc << \"-r\" << url.path();\n        } else {\n            proc << url.toString();\n        }\n    }\n\n    if (!proc.startDetached())\n        KMessageBox::error(nullptr, i18n(\"Error executing '%1'.\", proc.program().join(\" \")));\n}\n\nvoid KrSlots::rootKrusader()\n{\n    if (KMessageBox::warningContinueCancel(krApp,\n                                           i18n(\"Improper operations in root mode can damage your operating system. \"\n                                                \"<p>Furthermore, running UI applications as root is insecure and can \"\n                                                \"allow attackers to gain root access.\"),\n                                           QString(),\n                                           KStandardGuiItem::cont(),\n                                           KStandardGuiItem::cancel(),\n                                           \"Confirm Root Mode\",\n                                           KMessageBox::Notify | KMessageBox::Dangerous)\n        != KMessageBox::Continue)\n        return;\n\n    if (!KrServices::isExecutable(KDESU_PATH)) {\n        KMessageBox::error(krApp,\n                           i18n(\"Cannot start root mode Krusader, %1 not found or not executable. \"\n                                \"Please verify that kde-cli-tools are installed.\",\n                                QString(KDESU_PATH)));\n        return;\n    }\n\n    KProcess proc;\n    proc << KDESU_PATH << \"-c\"\n         << QApplication::instance()->applicationFilePath() + \" --left=\" + KrServices::quote(LEFT_PANEL->virtualPath().toDisplayString(QUrl::PreferLocalFile))\n            + \" --right=\" + KrServices::quote(RIGHT_PANEL->virtualPath().toDisplayString(QUrl::PreferLocalFile));\n\n    if (!proc.startDetached())\n        KMessageBox::error(nullptr, i18n(\"Error executing %1.\", proc.program()[0]));\n}\n\nvoid KrSlots::slotSplit()\n{\n    const QStringList list = ACTIVE_PANEL->gui->getSelectedNames();\n    QString name;\n\n\n    if (list.count() == 1)\n        name = list[0];\n\n    if (name.isEmpty()) {\n\n        KMessageBox::error(nullptr, i18n(\"Do not know which file to split.\"));\n        return;\n    }\n\n    QUrl fileURL = ACTIVE_FUNC->files()->getUrl(name);\n    if (fileURL.isEmpty())\n        return;\n\n    if (ACTIVE_FUNC->files()->getFileItem(name)->isDir()) {\n        KMessageBox::error(krApp, i18n(\"You cannot split a folder.\"));\n        return;\n    }\n\n    const QUrl destDir = ACTIVE_PANEL->otherPanel()->virtualPath();\n\n    SplitterGUI splitterGUI(MAIN_VIEW, fileURL, destDir);\n\n    if (splitterGUI.exec() == QDialog::Accepted) {\n        bool splitToOtherPanel = splitterGUI.getDestinationDir().matches(ACTIVE_PANEL->otherPanel()->virtualPath(), QUrl::StripTrailingSlash);\n\n        Splitter split(MAIN_VIEW, fileURL, splitterGUI.getDestinationDir(), splitterGUI.overWriteFiles());\n        split.split(splitterGUI.getSplitSize());\n\n        if (splitToOtherPanel)\n            ACTIVE_PANEL->otherPanel()->func->refresh();\n    }\n}\n\nvoid KrSlots::slotCombine()\n{\n    const QStringList list = ACTIVE_PANEL->gui->getSelectedNames();\n    if (list.isEmpty()) {\n        KMessageBox::error(nullptr, i18n(\"Do not know which files to combine.\"));\n        return;\n    }\n\n    QUrl baseURL;\n    bool unixStyle = false;\n    bool windowsStyle = false;\n    QString commonName;\n    qsizetype commonLength = 0;\n\n\n    for (const auto &it : list) {\n        QUrl url = ACTIVE_FUNC->files()->getUrl(it);\n        if (url.isEmpty())\n            return;\n\n        if (ACTIVE_FUNC->files()->getFileItem(it)->isDir()) {\n            KMessageBox::error(krApp, i18n(\"You cannot combine a folder.\"));\n            return;\n        }\n\n        if (!unixStyle) {\n            QString name = url.fileName();\n            qsizetype extPos = name.lastIndexOf('.');\n            QString ext = name.mid(extPos + 1);\n            name.truncate(extPos);\n            url = url.adjusted(QUrl::RemoveFilename);\n            url.setPath(url.path() + name);\n\n            bool isExtInt;\n            ext.toInt(&isExtInt, 10);\n\n            if (extPos < 1 || ext.isEmpty() || (ext != \"crc\" && !isExtInt)) {\n                if (windowsStyle) {\n                    KMessageBox::error(nullptr, i18n(\"Not a split file: %1.\", url.toDisplayString(QUrl::PreferLocalFile)));\n                    return;\n                }\n                unixStyle = true;\n            } else {\n                if (ext != \"crc\")\n                    windowsStyle = true;\n\n                if (baseURL.isEmpty())\n                    baseURL = url;\n                else if (baseURL != url) {\n                    KMessageBox::error(nullptr, i18n(\"Select only one split file.\"));\n                    return;\n                }\n            }\n        }\n\n        if (unixStyle) {\n            bool error = true;\n\n            do {\n                const QString &shortName = it;\n                QChar lastChar = shortName.at(shortName.length() - 1);\n\n                if (lastChar.isLetter()) {\n                    char fillLetter = (lastChar.toUpper() == lastChar) ? 'A' : 'a';\n\n                    if (commonName.isNull()) {\n                        commonLength = shortName.length();\n                        commonName = shortName;\n\n                        while (commonName.length()) {\n                            QString shorter = commonName.left(commonName.length() - 1);\n                            QString testFile = shorter.leftJustified(commonLength, fillLetter);\n\n                            if (ACTIVE_FUNC->files()->getFileItem(testFile) == nullptr)\n                                break;\n                            else {\n                                commonName = shorter;\n                                baseURL = ACTIVE_PANEL->virtualPath().adjusted(QUrl::StripTrailingSlash);\n                                baseURL.setPath(baseURL.path() + '/' + (testFile));\n                            }\n                        }\n\n                        error = (commonName == shortName);\n                    } else if (commonLength == shortName.length() && shortName.startsWith(commonName))\n                        error = false;\n                }\n            } while (false);\n\n            if (error) {\n                KMessageBox::error(nullptr, i18n(\"Not a split file: %1.\", url.toDisplayString(QUrl::PreferLocalFile)));\n                return;\n            }\n        }\n    }\n\n\n    QUrl dest = KChooseDir::getDir(i18n(\"Combining %1.* to folder:\", baseURL.toDisplayString(QUrl::PreferLocalFile)),\n                                   ACTIVE_PANEL->otherPanel()->virtualPath(),\n                                   ACTIVE_PANEL->virtualPath());\n    if (dest.isEmpty())\n        return;\n\n    bool combineToOtherPanel = (dest.matches(ACTIVE_PANEL->otherPanel()->virtualPath(), QUrl::StripTrailingSlash));\n\n    Combiner combine(MAIN_VIEW, baseURL, dest, unixStyle);\n    combine.combine();\n\n    if (combineToOtherPanel)\n        ACTIVE_PANEL->otherPanel()->func->refresh();\n}\n\nvoid KrSlots::manageUseractions()\n{\n    ActionMan actionMan(MAIN_VIEW);\n}\n\n#ifdef SYNCHRONIZER_ENABLED\nvoid KrSlots::slotSynchronizeDirs(QStringList selected)\n{\n    SynchronizerGUI *synchronizerDialog = new SynchronizerGUI(MAIN_VIEW, LEFT_PANEL->virtualPath(), RIGHT_PANEL->virtualPath(), std::move(selected));\n    synchronizerDialog->show();\n}\n#endif\n\nvoid KrSlots::compareSetup()\n{\n    for (int i = 0; KrActions::compareArray[i] != nullptr; i++)\n        if ((*KrActions::compareArray[i])->isChecked()) {\n            KConfigGroup group(krConfig, \"Private\");\n            group.writeEntry(\"Compare Mode\", i);\n            break;\n        }\n}\n\n\nvoid KrSlots::execTypeSetup()\n{\n    for (int i = 0; KrActions::execTypeArray[i] != nullptr; i++)\n        if ((*KrActions::execTypeArray[i])->isChecked()) {\n            if (*KrActions::execTypeArray[i] == KrActions::actExecTerminalEmbedded) {\n\n                MAIN_VIEW->terminalDock()->initialise();\n            }\n            KConfigGroup grp(krConfig, \"Private\");\n            grp.writeEntry(\"Command Execution Mode\", i);\n            break;\n        }\n}\n\nvoid KrSlots::slotDiskUsage()\n{\n    DiskUsageGUI *diskUsageDialog = new DiskUsageGUI(ACTIVE_PANEL->virtualPath());\n    diskUsageDialog->askDirAndShow();\n}\n\nvoid KrSlots::applicationStateChanged()\n{\n    if (MAIN_VIEW == nullptr) {\n        return;\n    }\n    if (qApp->applicationState() == Qt::ApplicationActive || qApp->applicationState() == Qt::ApplicationInactive) {\n        LEFT_PANEL->panelVisible();\n        RIGHT_PANEL->panelVisible();\n    } else {\n        LEFT_PANEL->panelHidden();\n        RIGHT_PANEL->panelHidden();\n    }\n}\n\nvoid KrSlots::emptyTrash()\n{\n    KrTrashHandler::emptyTrash();\n}\n\n#define OPEN_ID 100001\n#define EMPTY_TRASH_ID 100002\n\nvoid KrSlots::trashPopupMenu()\n{\n    QMenu trashMenu(krApp);\n    QAction *act = trashMenu.addAction(Icon(\"document-open\"), i18n(\"Open trash bin\"));\n    act->setData(QVariant(OPEN_ID));\n    act = trashMenu.addAction(Icon(\"trash-empty\"), i18n(\"Empty trash bin\"));\n    act->setData(QVariant(EMPTY_TRASH_ID));\n\n    int result = -1;\n    QAction *res = trashMenu.exec(QCursor::pos());\n    if (res && res->data().canConvert<int>())\n        result = res->data().toInt();\n\n    if (result == OPEN_ID) {\n        ACTIVE_FUNC->openUrl(QUrl(QStringLiteral(\"trash:/\")));\n    } else if (result == EMPTY_TRASH_ID) {\n        KrTrashHandler::emptyTrash();\n    }\n}\n\nvoid KrSlots::addBookmark()\n{\n    krBookMan->bookmarkCurrent(ACTIVE_PANEL->virtualPath());\n}\n\nvoid KrSlots::cmdlinePopup()\n{\n    MAIN_VIEW->cmdLine()->popup();\n}\n",
        "gt": [
            "'krusader/app/BookMan/krbookmark.h'",
            "'krusader/app/BookMan/krbookmarkhandler.h'",
            "'krusader/app/krslots.cpp'"
        ]
    },
    {
        "files": [
            "'Implicit-SVSDF-Planner/src/plan_manager/src/plan_manager.cpp'",
            "'Implicit-SVSDF-Planner/src/map_manager/include/map_manager/PCSmap_manager.h'",
            "'Implicit-SVSDF-Planner/src/utils/include/utils/debug_publisher.hpp'",
            "'Implicit-SVSDF-Planner/src/plan_manager/include/plan_manager/plan_manager.hpp'"
        ],
        "content": "'Implicit-SVSDF-Planner/src/plan_manager/src/plan_manager.cpp'\n:#include <plan_manager/plan_manager.hpp>\n#include <utils/Visualization.hpp>\n#include <iomanip>\n#include <limits>\nusing namespace std;\nusing namespace ros;\nusing namespace Eigen;\n\n#define USE_MIASTAR 1\n\nint main(int argc, char **argv)\n{\n  ros::init(argc, argv, \"plan_manager\");\n  ros::NodeHandle nh_;\n  ros::NodeHandle nh_priv(\"~\");\n\n  debug_publisher::init(nh_);\n  ros::Duration(0.5).sleep();\n\n  debug_publisher::DBSendNew(\"plan_manager\", \"Program start\");\n  planner_manager.reset(new PlannerManager);\n  planner_manager->init(nh_, nh_priv);\n\n  debug_assistant.reset(new DebugAssistant);\n  debug_assistant->init(nh_, planner_manager);\n  debug_publisher::DBSendNew(\"plan_manager\", \"Program init done!\");\n\n  double test_rate = planner_manager->config.testRate;\n  if (test_rate > 0.0)\n  {\n    ros::Rate lr(test_rate);\n    while (ros::ok())\n    {\n      planner_manager->process();\n      ros::spinOnce();\n      lr.sleep();\n    }\n  }\n  else\n  {\n    ros::spin();\n  }\n  ros::spin();\n  return 0;\n}\n\nvoid PlannerManager::init(ros::NodeHandle &nh, ros::NodeHandle &nh_prev)\n{\n\n  debug_publisher::DBSendNew(\"plan_manager\", \"planner_manager init start\");\n  config.loadParameters(nh_prev);\n  Loadstartandend = config.loadStartEnd;\n  if (Loadstartandend)\n  {\n    LoadStartEnd();\n  }\n  bdx = config.kernel_size * config.occupancy_resolution;\n  bdy = config.kernel_size * config.occupancy_resolution;\n  bdz = config.kernel_size * config.occupancy_resolution;\n\n  pcsmap_manager.reset(new PCSmapManager(config));\n  pcsmap_manager->init(nh);\n  debug_publisher::DBSendNew(\"plan_manager\", \"pcsmap_manager init done\");\n\n  sv_manager.reset(new SweptVolumeManager(config));\n  sv_manager->init(nh, config);\n  debug_publisher::DBSendNew(\"plan_manager\", \"sv_manager init done\");\n\n  astar_searcher.reset(new AstarPathSearcher);\n  astar_searcher->init(nh);\n  astar_searcher->kernel_size = config.kernel_size;\n\n  debug_publisher::DBSendNew(\"plan_manager\", \"front_end init done\");\n\n  traj_parlength = 3.0;\n  minco_traj_optimizer.reset(new TrajOptimizer);\n  minco_traj_optimizer->setParam(nh, config);\n  minco_traj_optimizer->setEnvironment(sv_manager);\n\n  debug_publisher::DBSendNew(\"plan_manager\", \"back_end init done\");\n\n  ori_traj_generator.reset(new OriTraj);\n  ori_traj_generator->setParam(nh, config);\n\n  current_front_end = USE_MIASTAR;\n\n  visulizer.reset(new vis::Visualization(nh));\n  target_sub = nh.subscribe(\"/goal\", 1, &PlannerManager::targetRcvCallBack, this);\n  rcvmap_signal_sub = nh.subscribe(\"/rcvmap_signal\", 1, &PlannerManager::mapRcvCallBack, this);\n\n  setting_sub = nh.subscribe(\"/setting_receive\", 1, &PlannerManager::settingRcvCallBack, this);\n  rs = nh.subscribe(\"/reshow\", 1, &PlannerManager::reShowTraj, this);\n  debug_publisher::DBSendNew(\"plan_manager\", \"planner_manager init done\");\n}\n\nbool PlannerManager::generatePath(Vector3d start, Vector3d end)\n{\n\n  astar_searcher->AstarPathSearch(start, end);\n  if (astar_searcher->success_flag)\n  {\n    recent_path = astar_searcher->getPath();\n    visulizer->visR3Path(\"front_end_path\", recent_path);\n    Eigen::Matrix3d Rt;\n    Eigen::Vector3d trans;\n    for (size_t i = 0; i < recent_path.size(); i++)\n    {\n      trans = recent_path[i];\n      double yaw = trans(2);\n      trans(2) = 0.0;\n      Rt = Eigen::AngleAxisd(yaw, Eigen::Vector3d::UnitZ()).toRotationMatrix();\n      sv_manager->current_robot_shape->Transform(Rt, trans);\n      visulizer->visPolytope(sv_manager->current_robot_shape->mesh_var, \"front_end_pose\", \"front_end_pose_edge\", false, 2, i + 11452, Color::steelblue, 0.4);\n    }\n\n    recent_se3_path = astar_searcher->getastarSE3Path();\n    visulizer->visSE3Path(\"SE3path\", sv_manager->current_robot_shape->mesh, recent_se3_path);\n    ROS_WARN(\"[A*] search success.\");\n  }\n  else\n  {\n    ROS_WARN(\"[A*] search failed.\");\n  }\n  astar_searcher->reset();\n  return (astar_searcher->success_flag);\n}\n\nvoid PlannerManager::generateTraj(vector<Vector3d> path)\n{\n  int N;\n\n  int path_size = path.size();\n  double temp_traj_parlength = traj_parlength;\n  int index_gap = ceil(temp_traj_parlength / ((pcsmap_manager->occupancy_map)->grid_resolution));\n\n  while (index_gap >= path_size - 1)\n  {\n    temp_traj_parlength /= 1.5;\n    index_gap = ceil(temp_traj_parlength / ((pcsmap_manager->occupancy_map)->grid_resolution));\n  }\n\n  bool ret_opt;\n  Matrix3d initState = Matrix3d::Zero();\n  Matrix3d finalState = Matrix3d::Zero();\n  initState.col(0) = path.front();\n\n  finalState.col(0) = path.back();\n\n  vector<Vector3d> Q;\n  vector<Vector3d> acc_list;\n  Vector3d wp;\n  Vector3d tmp_pos{999, 999, 999};\n  Vector3d dir;\n  Matrix3d rotate;\n  vector<Matrix3d> rotatelist;\n  minco_traj_optimizer->pcsmap_manager->aabb_points.clear();\n  for (int ind = index_gap; ind < path_size - 1; ind += index_gap)\n  {\n    wp = path[ind];\n    rotate = recent_se3_path[ind].getRotMatrix();\n    dir = rotate * Eigen::Vector3d(0, 0, 1);\n    Q.push_back(wp);\n    rotatelist.push_back(rotate);\n    acc_list.push_back(dir);\n    minco_traj_optimizer->pcsmap_manager->getPointsInAABBOutOfLastOne(wp, tmp_pos, bdx / 3.0, bdy / 3.0, bdz / 3.0);\n    tmp_pos = wp;\n  }\n  minco_traj_optimizer->parallel_points.clear();\n  for (const auto &pair : minco_traj_optimizer->pcsmap_manager->aabb_points)\n  {\n    minco_traj_optimizer->parallel_points.push_back(pair.second);\n  }\n  minco_traj_optimizer->parallel_points_num = minco_traj_optimizer->pcsmap_manager->aabb_points.size();\n  cout << \"\\033[32m=========parallel_points_num:==========\\033[0m\" << minco_traj_optimizer->parallel_points_num << endl;\n  minco_traj_optimizer->lastTstar = vector<double>(minco_traj_optimizer->parallel_points_num, 0.0);\n\n  minco_traj_optimizer->renderAABBpoints();\n\n  N = Q.size() + 1;\n\n  Matrix3Xd inPts = MatrixXd::Zero(3, N);\n  for (int i = 0; i < N - 1; i++)\n  {\n    inPts.col(i) = Q[i];\n  }\n  VectorXd ts = config.inittime * VectorXd::Ones(N);\n  bool ret;\n  bool mid_ret;\n  ros::Time t1;\n  visulizer->visSE3Vec(\"path_vec\", Q, acc_list, 156468);\n  Eigen::VectorXd opt_x;\n  mid_ret = ori_traj_generator->getOriTraj(initState, finalState, Q, ts, acc_list, rotatelist, N, recent_traj, opt_x);\n\n  sv_manager->updateTraj(recent_traj);\n  clear();\n  std::cout << \"[planner manager] Ori trajectory generated successfully!\" << std::endl;\n  if (mid_ret)\n  {\n    ret = minco_traj_optimizer->optimize_traj_lmbm(initState, finalState, opt_x, N, recent_traj);\n    recent_ret = ret;\n  }\n  std::cout << \"==========mid_ret:\" << mid_ret << \" ret:=============== \" << ret << std::endl;\n  if (mid_ret && ret)\n  {\n    std::cout << \"[planner manager] Trajectory optimization is successful! \" << std::endl;\n    visulizer->visTraj(\"traj\", recent_traj, 1, true);\n    std::cout << \" tmax for traj: \" << recent_traj.getTotalDuration() << std::endl;\n    sv_manager->updateTraj(recent_traj);\n\n\n    auto lasttrans = recent_traj.getPos(recent_traj.getTotalDuration() - 1e-5);\n    double lastyaw = lasttrans(2);\n    sv_manager->lastRotate = Eigen::AngleAxisd(lastyaw, Eigen::Vector3d::UnitZ()).toRotationMatrix();\n    sv_manager->current_robot_shape->Transform(planner_manager->sv_manager->lastRotate, planner_manager->recent_traj.getPos(planner_manager->recent_traj.getTotalDuration()) + Eigen::Vector3d(0, 0, 5));\n    sv_manager->vis->visPolytope(planner_manager->sv_manager->current_robot_shape->mesh_var, \"Polymeshoriginal\", \"Polyedgeoriginal\", false, 1, 3, vis::blue, 1.0);\n    sv_manager->current_robot_shape->Transform(Eigen::Matrix3d::Identity(), planner_manager->recent_traj.getPos(0) + Eigen::Vector3d(0, 0, 5));\n    sv_manager->vis->visPolytope(planner_manager->sv_manager->current_robot_shape->mesh_var, \"Polymeshoriginal\", \"Polyedgeoriginal\", false, 1, 2, vis::blue, 1.0);\n\n    sv_manager->process(recent_traj);\n\n    sv_manager->setTrajStamp(ros::Time::now().toSec());\n  }\n  else\n  {\n    std::cout << \"[planner manager] Trajectory optimization is failed! \" << std::endl;\n  }\n}\n\nvoid PlannerManager::clear()\n{\n  planner_manager->sv_manager->swept_cal->sweptvolumeclear();\n}\n\nvoid PlannerManager::mapRcvCallBack(const std_msgs::Empty &msg)\n{\n  debug_publisher::DBSendNew(\"plan_manager\", \"Try to gene byte kernel\");\n  uint8_t *map_kernel = pcsmap_manager->generateMapKernel2D(config.kernel_size);\n  debug_publisher::DBSendNew(\"plan_manager\", \"gene byte kernel done!\");\n\n  int sizeX = pcsmap_manager->occupancy_map->X_size;\n  int sizeY = pcsmap_manager->occupancy_map->Y_size;\n  int sizeZ = pcsmap_manager->occupancy_map->Z_size;\n  sv_manager->setMapKernel(map_kernel, sizeX, sizeY, sizeZ);\n  debug_publisher::DBSendNew(\"plan_manager\", \"set byte kernel done!\");\n  astar_searcher->initGridMap(pcsmap_manager, sv_manager);\n\n  minco_traj_optimizer->setGridMap(pcsmap_manager);\n\n  cout << \"init map A* --\" << endl;\n}\n\nvoid PlannerManager::settingRcvCallBack(const std_msgs::Int8MultiArray &msg)\n{\n#define CLEAR_MAP 1\n#define SETTING_FRONT_END 2\n#define SETTING_SHAPE 3\n\n  if (msg.data.size() < 2)\n  {\n    return;\n  }\n  int head = msg.data[0];\n\n  if (head == CLEAR_MAP)\n  {\n    pcsmap_manager->clearMap();\n    std::cout << \"[planner manager] clear map!\" << std::endl;\n  }\n}\n\nvoid PlannerManager::targetRcvCallBack(const geometry_msgs::PoseStamped &msg)\n{\n  if (step_state == STEP_NOPOINT)\n  {\n    clear();\n    start_pos(0) = msg.pose.position.x;\n    start_pos(1) = msg.pose.position.y;\n    start_pos(2) = 0.0;\n    if (Loadstartandend)\n    {\n      cout << \"\\033[32m=========load start point========\\033[0m\" << endl;\n      start_pos = Start_record;\n\n      std::cout << std::setprecision(std::numeric_limits<double>::max_digits10);\n\n      std::cout << \"\\033[32m Loaded Start_record pose: \" << Start_record.x() << \", \" << Start_record.y() << \", \" << Start_record.z() << \"\\033[0m\" << std::endl;\n\n      std::cout << std::setprecision(std::numeric_limits<double>::digits10);\n\n      start_pos(2) = 0.0;\n    }\n    step_state = STEP_HAVE_START;\n    std::cout << \"[plan_manager] Get start position! \" << std::endl;\n    debug_publisher::DBSendNew(\"plan_manager\", \"Get start position!\");\n  }\n  else if (step_state == STEP_HAVE_START)\n  {\n    end_pos(0) = msg.pose.position.x;\n    end_pos(1) = msg.pose.position.y;\n    end_pos(2) = 0.0;\n    if (Loadstartandend)\n    {\n      cout << \"\\033[32m=========load End point========\\033[0m\" << endl;\n      end_pos = End_record;\n\n      std::cout << std::setprecision(std::numeric_limits<double>::max_digits10);\n\n      std::cout << \"\\033[32m Loaded End_record pose: \" << End_record.x() << \", \" << End_record.y() << \", \" << End_record.z() << \"\\033[0m\" << std::endl;\n\n      std::cout << std::setprecision(std::numeric_limits<double>::digits10);\n\n      end_pos(2) = 0.0;\n    }\n    step_state = STEP_HAVE_TARGET;\n    std::cout << \"[plan_manager] Get target position! \" << std::endl;\n    debug_publisher::DBSendNew(\"plan_manager\", \"Get target position!\");\n  }\n  else if (step_state == STEP_HAVE_TARGET)\n  {\n    start_pos(0) = msg.pose.position.x;\n    start_pos(1) = msg.pose.position.y;\n    start_pos(2) = 0.0;\n    if (Loadstartandend)\n    {\n      cout << \"\\033[32m=========load start point========\\033[0m\" << endl;\n      start_pos = Start_record;\n\n      std::cout << std::setprecision(std::numeric_limits<double>::max_digits10);\n\n      std::cout << \"\\033[32m Loaded start pose: \" << Start_record.x() << \", \" << Start_record.y() << \", \" << Start_record.z() << \"\\033[0m\" << std::endl;\n\n      std::cout << std::setprecision(std::numeric_limits<double>::digits10);\n\n      start_pos(2) = 0.0;\n    }\n    step_state = STEP_HAVE_START;\n    std::cout << \"[plan_manager] Get start position! \" << std::endl;\n    debug_publisher::DBSendNew(\"plan_manager\", \"Get target position!\");\n  }\n\n  if (step_state == STEP_HAVE_TARGET)\n  {\n    std::cout << \"[plan_manager] Try to generate path. \" << std::endl;\n    debug_publisher::DBSendNew(\"plan_manager\", \"Try to generate path.\");\n    if (generatePath(start_pos, end_pos))\n    {\n      std::cout << \"[plan_manager] Path generated successfully! \" << std::endl;\n      debug_publisher::DBSendNew(\"plan_manager\", \"Path generated successfully!\");\n      generateTraj(recent_path);\n    }\n  }\n}\n\nvoid PlannerManager::process()\n{\n  this->sv_manager->process(recent_traj);\n}\n\nvoid PlannerManager::LoadStartEnd()\n{\n  std::string fullPath = config.inputdata;\n  std::string prefix = \"shapes/\";\n  size_t startPos = fullPath.find(prefix);\n  std::string shapeString;\n  if (startPos != std::string::npos)\n  {\n    startPos += prefix.length();\n    size_t endPos = fullPath.find(\".obj\", startPos);\n\n    if (endPos != std::string::npos)\n    {\n      shapeString = fullPath.substr(startPos, endPos - startPos);\n      std::cout << \"ShapeString : \" << shapeString << std::endl;\n    }\n    else\n    {\n      std::cout << \"The string does not contain '.obj' after 'shapes/'\" << std::endl;\n    }\n  }\n  else\n  {\n    std::cout << \"The string does not contain 'shapes/'\" << std::endl;\n  }\n\n  cout << \"\\033[32m========load traj start and end points=======\\033[0m\" << endl;\n  std::string filename = ros::package::getPath(string(\"plan_manager\")) + \"/pcds/trajectory_\" + shapeString + \".txt\";\n  std::ifstream file(filename);\n  std::string line;\n\n  if (!file.is_open())\n  {\n    std::cerr << \"无法打开文件 \" << filename << std::endl;\n  }\n  std::string labelstart{\"Start: \"};\n\n  while (std::getline(file, line))\n  {\n    if (line.find(labelstart) != std::string::npos)\n    {\n      std::istringstream iss(line.substr(labelstart.length()));\n      iss >> Start_record.x() >> Start_record.y() >> Start_record.z();\n      std::cout << std::setprecision(std::numeric_limits<double>::max_digits10);\n      std::cout << \"\\033[32m Load start pose: \" << Start_record.x() << \", \" << Start_record.y() << \", \" << Start_record.z() << \"\\033[0m\" << std::endl;\n      std::cout << std::setprecision(std::numeric_limits<double>::digits10);\n      break;\n    }\n  }\n  std::string labelend(\"End: \");\n  while (std::getline(file, line))\n  {\n    if (line.find(labelend) != std::string::npos)\n    {\n      std::istringstream iss(line.substr(labelend.length()));\n      iss >> End_record.x() >> End_record.y() >> End_record.z();\n      std::cout << std::setprecision(std::numeric_limits<double>::max_digits10);\n      std::cout << \"\\033[32m Load End pose: \" << End_record.x() << \", \" << End_record.y() << \", \" << End_record.z() << \"\\033[0m\" << std::endl;\n      std::cout << std::setprecision(std::numeric_limits<double>::digits10);\n      break;\n    }\n  }\n  file.close();\n}\n\nvoid PlannerManager::reShowTraj(const std_msgs::Empty::Ptr msg)\n{\n  sv_manager->setTrajStamp(ros::Time::now().toSec());\n  sv_manager->process(recent_traj);\n}\n\nconst uint8_t bit_sel[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\nvoid DebugAssistant::debugMsgcallback(const std_msgs::Float64MultiArray::ConstPtr &msg)\n{\n  planner_manager->sv_manager->swept_cal->sweptvolumeclear();\n\n  if (msg->data.size() < 1)\n  {\n    return;\n  }\n\n  if (msg->data[0] == 21)\n  {\n    planner_manager->minco_traj_optimizer->exit = true;\n  }\n\n}\n\nvoid DebugAssistant::init(ros::NodeHandle &nh, PlannerManager::Ptr pm)\n{\n\n  debug_publisher::DBSendNew(\"plan_manager\", \"debug_assistant init start\");\n  debug_sub = nh.subscribe(\"/debug_cmd\", 10, &DebugAssistant::debugMsgcallback, this);\n  planner_manager = pm;\n  debug_publisher::DBSendNew(\"plan_manager\", \"debug_assistant init done\");\n}\n'Implicit-SVSDF-Planner/src/map_manager/include/map_manager/PCSmap_manager.h'\n:#ifndef PCSMAP_MANAGER_H\n#define PCSMAP_MANAGER_H\n\n#include <string.h>\n#include <ros/ros.h>\n#include <unordered_map>\n#include <ros/package.h>\n#include <std_msgs/Empty.h>\n#include <std_msgs/Int16.h>\n#include <nav_msgs/Odometry.h>\n#include <nav_msgs/OccupancyGrid.h>\n#include <sensor_msgs/PointCloud2.h>\n#include <utils/config.hpp>\n#include <utils/debug_publisher.hpp>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl/kdtree/kdtree_flann.h>\n#include <pcl/sample_consensus/ransac.h>\n#include <pcl_conversions/pcl_conversions.h>\n#include <pcl/segmentation/sac_segmentation.h>\n#include <pcl/sample_consensus/sac_model_plane.h>\n\n#include \"map_manager/GridMap3D.h\"\n\n\n\nclass PCSmapManager\n{\n    public:\n        PCSmapManager(const Config&conf);\n        ~PCSmapManager();\n        static constexpr uint8_t or_mask[8]={0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\n        void init(ros::NodeHandle& nh);\n\n        std::vector<Eigen::Vector3d> obs_forblender;\n\n        void rcvGlobalMapHandler(const sensor_msgs::PointCloud2& globalmap);\n        void rcvOdomHandler(const nav_msgs::Odometry odom);\n        void rcvRenderGrad(const std_msgs::Int16 msg);\n\n\n       inline uint8_t* generateMapKernel(const int& kernel_size)\n       {\n\n            int side_size = (kernel_size - 1)/2;\n            int x_size    = occupancy_map -> X_size + 2 * side_size;\n            int y_size    = occupancy_map -> Y_size + 2 * side_size;\n            int z_size    = occupancy_map -> Z_size + 2 * side_size;\n            int bytes_len_of_last_dim = (z_size + 7) / 8;\n            int size_yz   = y_size * bytes_len_of_last_dim;\n            int bytes_len = x_size * y_size * bytes_len_of_last_dim;\n            uint8_t *map_kernel = new uint8_t[bytes_len]();\n\n\n\n            for (int x = 0; x < occupancy_map -> X_size; x++)\n            {\n                for (int y = 0; y < occupancy_map -> Y_size; y++)\n                {\n                    for (int z = 0; z < occupancy_map -> Z_size; z++)\n                    {\n                        int flate_x  = x + side_size;\n                        int flate_y  = y + side_size;\n                        int flate_z  = z + side_size;\n\n                        int byte_idx = flate_x * size_yz + flate_y * bytes_len_of_last_dim + (flate_z + 0) / 8;\n                        int byte_offset = flate_z % 8;\n                        if ( occupancy_map -> isIndexOccupied(x,y,z) == true)\n                        {\n                            map_kernel[byte_idx] |= or_mask[byte_offset];\n                        }\n                    }\n                }\n            }\n            mk = map_kernel;\n            return map_kernel;\n       }\n\n\n       inline uint8_t* generateMapKernel2D(const int& kernel_size)\n       {\n\n            int side_size = (kernel_size - 1)/2;\n            int x_size    = occupancy_map -> X_size + 2 * side_size;\n            int y_size    = occupancy_map -> Y_size + 2 * side_size;\n            int bytes_len_of_last_dim = (y_size + 7) / 8;\n            int bytes_len = x_size * bytes_len_of_last_dim;\n            uint8_t *map_kernel = new uint8_t[bytes_len]();\n\n            for (int x = 0; x < occupancy_map -> X_size; x++)\n            {\n                for (int y = 0; y < occupancy_map -> Y_size; y++)\n                {\n                    int flate_x  = x + side_size;\n                    int flate_y  = y + side_size;\n\n                    int byte_idx    = flate_x  * bytes_len_of_last_dim + (flate_y + 0) / 8;\n                    int byte_offset = flate_y % 8;\n                    if ( occupancy_map -> isIndexOccupied(x,y,0) == true)\n                    {\n                        map_kernel[byte_idx] |= or_mask[byte_offset];\n                    }\n                }\n            }\n            mk = map_kernel;\n            return map_kernel;\n       }\n\n\n        inline void clearMap() {\n            if( recieved_globalmap == true ){\n                occupancy_map -> releaseMemory();\n                recieved_globalmap = false;\n            }\n        }\n\n        inline int unifiedID(const int& i, const int& j, const int& k) const\n        {\n            int unified_id = 0;\n            unified_id += k * (occupancy_map->X_size) * (occupancy_map->Y_size);\n            unified_id += j * (occupancy_map->X_size) ;\n            unified_id += i;\n            return unified_id;\n        }\n\n\n        inline void projInMap(Eigen::Vector3d& pt) const{\n            if( pt(0) < boundary_xyzmin(0) ){ pt(0) = boundary_xyzmin(0);}\n            if( pt(1) < boundary_xyzmin(1) ){ pt(1) = boundary_xyzmin(1);}\n            if( pt(2) < boundary_xyzmin(2) ){ pt(2) = boundary_xyzmin(2);}\n            if( pt(0) > boundary_xyzmax(0) ){ pt(0) = boundary_xyzmax(0);}\n            if( pt(1) > boundary_xyzmax(1) ){ pt(1) = boundary_xyzmax(1);}\n            if( pt(2) > boundary_xyzmax(2) ){ pt(2) = boundary_xyzmax(2);}\n        }\n\n        inline void getPointsInAABB2D(const Eigen::Vector3d &center, double halfbdx,double halfbdy, std::vector<Eigen::Vector2d>& ob_pts) const\n        {\n            Eigen::Vector3d corner1 = center - Eigen::Vector3d(halfbdx, halfbdy, 0);\n            Eigen::Vector3d corner2 = center + Eigen::Vector3d(halfbdx, halfbdy, 0);\n            corner1(2) = 0.0;\n            corner2(2) = 0.0;\n            projInMap(corner1);\n            projInMap(corner2);\n            const Eigen::Vector3i idcorner1 = occupancy_map -> getGridIndex( corner1 );\n            const Eigen::Vector3i idcorner2 = occupancy_map -> getGridIndex( corner2 );\n\n            for (int i = idcorner1(0); i <= idcorner2(0); i++)\n            {\n                for (int j = idcorner1(1); j <= idcorner2(1); j++)\n                {\n                    if( occupancy_map -> isIndexOccupied(i,j,0) )\n                    {\n                        ob_pts.emplace_back( occupancy_map->getGridCubeCenter(i,j,0).head(2) );\n                    }\n                }\n            }\n        }\n\n        inline void getPointsInAABB(const Eigen::Vector3d &center, double halfbdx,double halfbdy,double halfbdz, std::vector<Eigen::Vector3d>& ob_pts) const\n        {\n            Eigen::Vector3d corner1 = center - Eigen::Vector3d(halfbdx, halfbdy, halfbdz);\n            Eigen::Vector3d corner2 = center + Eigen::Vector3d(halfbdx, halfbdy, halfbdz);\n            projInMap(corner1);\n            projInMap(corner2);\n            const Eigen::Vector3i idcorner1 = occupancy_map -> getGridIndex( corner1 );\n            const Eigen::Vector3i idcorner2 = occupancy_map -> getGridIndex( corner2 );\n\n            for (int i = idcorner1(0); i <= idcorner2(0); i++)\n            {\n                for (int j = idcorner1(1); j <= idcorner2(1); j++)\n                {\n                    for (int k = idcorner1(2); k <= idcorner2(2); k++)\n                    {\n                        if( occupancy_map -> isIndexOccupied(i,j,k) )\n                        {\n                            ob_pts.emplace_back( occupancy_map->getGridCubeCenter(i,j,k) );\n                        }\n                    }\n                }\n            }\n        }\n\n        inline void getPointsInAABBOutOfLastOne(const Eigen::Vector3d &center, const Eigen::Vector3d &center_last, double halfbdx,double halfbdy,double halfbdz)\n        {\n            Eigen::Vector3d corner1 = center - Eigen::Vector3d(halfbdx, halfbdy, halfbdz);\n            Eigen::Vector3d corner2 = center + Eigen::Vector3d(halfbdx, halfbdy, halfbdz);\n            projInMap(corner1);\n            projInMap(corner2);\n            const Eigen::Vector3i idcorner1 = occupancy_map -> getGridIndex( corner1 );\n            const Eigen::Vector3i idcorner2 = occupancy_map -> getGridIndex( corner2 );\n\n            Eigen::Vector3d corner1_l = center_last - Eigen::Vector3d(halfbdx, halfbdy, halfbdz);\n            Eigen::Vector3d corner2_l = center_last + Eigen::Vector3d(halfbdx, halfbdy, halfbdz);\n            projInMap(corner1_l);\n            projInMap(corner2_l);\n            const Eigen::Vector3i idcorner1_l = occupancy_map -> getGridIndex( corner1_l );\n            const Eigen::Vector3i idcorner2_l = occupancy_map -> getGridIndex( corner2_l );\n\n\n            for (int i = idcorner1(0); i <= idcorner2(0); i++)\n            {\n                for (int j = idcorner1(1); j <= idcorner2(1); j++)\n                {\n                    for (int k = idcorner1(2); k <= idcorner2(2); k++)\n                    {\n                        if( i > idcorner2_l(0) || i < idcorner1_l(0) ||\n                            j > idcorner2_l(1) || j < idcorner1_l(1) ||\n                            k > idcorner2_l(2) || k < idcorner1_l(2) )\n                        {\n                            if( occupancy_map -> isIndexOccupied(i,j,k) )\n                            {\n                                aabb_points.emplace( unifiedID(i,j,k), occupancy_map -> getGridCubeCenter(i,j,k) );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n\n        Vector3d boundary_xyzmin;\n        Vector3d boundary_xyzmax;\n\n\n        double occupancy_resolution;\n\n\n\n        int sta_threshold;\n\n        bool recieved_globalmap;\n\n        bool debug_output;\n\n\n        GridMap3D::Ptr occupancy_map;\n\n        uint8_t *mk;\n\n        std::unordered_map<int, Eigen::Vector3d> aabb_points;\n\n\n    private:\n\n        pcl::PointCloud<pcl::PointXYZ>::Ptr global_pointcloud;\n        pcl::KdTreeFLANN<pcl::PointXYZ> global_kdtree;\n\n\n        ros::Subscriber globalmap_sub;\n        ros::Subscriber odometry_sub;\n        ros::Subscriber debug_grad_sub;\n\n        ros::Publisher  globalmap_vis_pub;\n        ros::Publisher  gridmap_vis_pub;\n        ros::Publisher  rcvmap_signal_pub;\n        ros::Publisher  debug_grad_pub;\n\n     public:\n         typedef shared_ptr<PCSmapManager> Ptr;\n};\n\n#endif\n'Implicit-SVSDF-Planner/src/utils/include/utils/debug_publisher.hpp'\n:#ifndef DEBUG_PUBLISHER_HPP\n#define DEBUG_PUBLISHER_HPP\n\n#include <ros/ros.h>\n#include <std_msgs/String.h>\n#include <std_msgs/Float64MultiArray.h>\n#include <string>\n\nnamespace debug_publisher\n{\n\nvoid DBSendNew(const std::string& title, const std::string& message);\nvoid DBSendOptiStep(const std::vector<double>& step);\nvoid DBSendLogCost(const std::vector<double>& log_cost);\n\nvoid init(ros::NodeHandle& nh);\n\n};\n#endif\n'Implicit-SVSDF-Planner/src/plan_manager/include/plan_manager/plan_manager.hpp'\n:#ifndef PLANNER_MANAGER_H\n#define PLANNER_MANAGER_H\n\n#include <planner_algorithm/front_end_Astar.hpp>\n#include <planner_algorithm/back_end_optimizer.hpp>\n#include <planner_algorithm/mid_end.hpp>\n#include <utils/se3_state.hpp>\n#include <map_manager/PCSmap_manager.h>\n#include <swept_volume/sw_manager.hpp>\n#include <std_msgs/Float64MultiArray.h>\n#include <std_msgs/Empty.h>\n#include <std_msgs/Int8MultiArray.h>\n#include <std_msgs/Float64MultiArray.h>\n#include <geometry_msgs/PoseWithCovarianceStamped.h>\n#include <utils/config.hpp>\n#include <utils/debug_publisher.hpp>\n\n\nusing namespace Eigen;\n\n\nclass PlannerManager\n{\n  public:\n    PlannerManager(){};\n    ~PlannerManager(){};\n\n    void clear();\n    double bdx;\n    double bdy;\n    double bdz;\n\n    void init( ros::NodeHandle& nh, ros::NodeHandle& nh_prev );\n    void mapRcvCallBack(const std_msgs::Empty& msg);\n    void iniPoseRcvCallBack(const geometry_msgs::PoseWithCovarianceStamped& msg);\n    void settingRcvCallBack(const std_msgs::Int8MultiArray& msg);\n    void targetRcvCallBack(const geometry_msgs::PoseStamped& msg);\n    void viscallback(const ros::TimerEvent & event);\n\n    void reShowTraj( const std_msgs::Empty::Ptr msg);\n\n    void LoadStartEnd();\n\n\n    double getMinSVSDF();\n    void autoBenchMark();\n\n\n    bool generatePath( Vector3d start, Vector3d end );\n\n\n    void generateTraj( vector<Vector3d> path );\n\n\n\n    void process();\n\n\n\n\n    double traj_parlength{1.0};\n\n\n    #define STEP_NOPOINT      0\n    #define STEP_HAVE_START   1\n    #define STEP_HAVE_TARGET  2\n\n    int step_state = STEP_NOPOINT;\n\n\n    nav_msgs::Odometry recent_odom;\n    bool has_odom;\n\n\n    int current_front_end;\n\n    Eigen::Vector3d Start_record;\n    Eigen::Vector3d End_record;\n    bool Loadstartandend{false};\n\n\n\n    vector<Vector3d> recent_path;\n    vector<SE3State> recent_se3_path;\n    vector<double> recent_se3_path_roll;\n    vector<double> recent_se3_path_pitch;\n    Vector3d start_pos;\n    Vector3d end_pos;\n    Trajectory<TRAJ_ORDER> recent_traj;\n    int recent_ret;\n\n\n    ros::Subscriber target_sub;\n    ros::Subscriber odom_sub;\n    ros::Subscriber rcvmap_signal_sub;\n    ros::Subscriber setting_sub;\n    ros::Subscriber rs;\n\n    ros::Publisher traj_pub;\n\n\n    Visualization::Ptr visulizer;\n\n\n    PCSmapManager::Ptr pcsmap_manager;\n\n\n    AstarPathSearcher::Ptr    astar_searcher;\n\n\n    OriTraj::Ptr ori_traj_generator;\n    TrajOptimizer::Ptr minco_traj_optimizer;\n    SweptVolumeManager::Ptr sv_manager;\n    Config config;\n\n\n\n  public:\n    typedef shared_ptr<PlannerManager> Ptr;\n};\n\n\nclass DebugAssistant\n{\n  public:\n    DebugAssistant(){};\n    ~DebugAssistant(){};\n\n    void init(ros::NodeHandle& nh, PlannerManager::Ptr pm);\n    void debugMsgcallback(const std_msgs::Float64MultiArray::ConstPtr& msg);\n\n  private:\n    ros::Subscriber debug_sub;\n    PlannerManager::Ptr planner_manager;\n  public:\n    typedef std::shared_ptr<DebugAssistant> Ptr;\n};\n\n\nPlannerManager::Ptr planner_manager;\nDebugAssistant::Ptr debug_assistant;\n\n#endif",
        "gt": [
            "'Implicit-SVSDF-Planner/src/utils/include/utils/debug_publisher.hpp'",
            "'Implicit-SVSDF-Planner/src/map_manager/include/map_manager/PCSmap_manager.h'",
            "'Implicit-SVSDF-Planner/src/plan_manager/include/plan_manager/plan_manager.hpp'",
            "'Implicit-SVSDF-Planner/src/plan_manager/src/plan_manager.cpp'"
        ]
    },
    {
        "files": [
            "'elaphureLink/thirdparty/asio/include/asio/execution/context.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/execution/context_as.hpp'",
            "'elaphureLink/elaphureLinkProxy/proxy.cpp'",
            "'elaphureLink/elaphureLinkProxy/SocketClient.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio.hpp'"
        ],
        "content": "'elaphureLink/thirdparty/asio/include/asio/execution/context.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_EXECUTION_CONTEXT2_HPP\n#define ASIO_EXECUTION_CONTEXT2_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include \"asio/detail/type_traits.hpp\"\n#include \"asio/execution/executor.hpp\"\n#include \"asio/execution/scheduler.hpp\"\n#include \"asio/execution/sender.hpp\"\n#include \"asio/is_applicable_property.hpp\"\n#include \"asio/traits/query_static_constexpr_member.hpp\"\n#include \"asio/traits/static_query.hpp\"\n\n#if defined(ASIO_HAS_STD_ANY)\n# include <any>\n#endif\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\n\n#if defined(GENERATING_DOCUMENTATION)\n\nnamespace execution {\n\n\n\nstruct context_t\n{\n\n  template <typename T>\n  static constexpr bool is_applicable_property_v =\n    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;\n\n\n  static constexpr bool is_requirable = false;\n\n\n  static constexpr bool is_preferable = false;\n\n\n  typedef std::any polymorphic_query_result_type;\n};\n\n\nconstexpr context_t context;\n\n}\n\n#else\n\nnamespace execution {\nnamespace detail {\n\ntemplate <int I = 0>\nstruct context_t\n{\n#if defined(ASIO_HAS_VARIABLE_TEMPLATES)\n  template <typename T>\n  ASIO_STATIC_CONSTEXPR(bool,\n    is_applicable_property_v = (\n      is_executor<T>::value\n        || conditional<\n            is_executor<T>::value,\n            false_type,\n            is_sender<T>\n          >::type::value\n        || conditional<\n            is_executor<T>::value,\n            false_type,\n            is_scheduler<T>\n          >::type::value));\n#endif\n\n  ASIO_STATIC_CONSTEXPR(bool, is_requirable = false);\n  ASIO_STATIC_CONSTEXPR(bool, is_preferable = false);\n\n#if defined(ASIO_HAS_STD_ANY)\n  typedef std::any polymorphic_query_result_type;\n#endif\n\n  ASIO_CONSTEXPR context_t()\n  {\n  }\n\n  template <typename T>\n  struct static_proxy\n  {\n#if defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)\n    struct type\n    {\n      template <typename P>\n      static constexpr auto query(ASIO_MOVE_ARG(P) p)\n        noexcept(\n          noexcept(\n            conditional<true, T, P>::type::query(ASIO_MOVE_CAST(P)(p))\n          )\n        )\n        -> decltype(\n          conditional<true, T, P>::type::query(ASIO_MOVE_CAST(P)(p))\n        )\n      {\n        return T::query(ASIO_MOVE_CAST(P)(p));\n      }\n    };\n#else\n    typedef T type;\n#endif\n  };\n\n  template <typename T>\n  struct query_static_constexpr_member :\n    traits::query_static_constexpr_member<\n      typename static_proxy<T>::type, context_t> {};\n\n#if defined(ASIO_HAS_DEDUCED_STATIC_QUERY_TRAIT) \\\n  && defined(ASIO_HAS_SFINAE_VARIABLE_TEMPLATES)\n  template <typename T>\n  static ASIO_CONSTEXPR\n  typename query_static_constexpr_member<T>::result_type\n  static_query()\n    ASIO_NOEXCEPT_IF((\n      query_static_constexpr_member<T>::is_noexcept))\n  {\n    return query_static_constexpr_member<T>::value();\n  }\n\n  template <typename E, typename T = decltype(context_t::static_query<E>())>\n  static ASIO_CONSTEXPR const T static_query_v\n    = context_t::static_query<E>();\n#endif\n\n\n#if !defined(ASIO_HAS_CONSTEXPR)\n  static const context_t instance;\n#endif\n};\n\n#if defined(ASIO_HAS_DEDUCED_STATIC_QUERY_TRAIT) \\\n  && defined(ASIO_HAS_SFINAE_VARIABLE_TEMPLATES)\ntemplate <int I> template <typename E, typename T>\nconst T context_t<I>::static_query_v;\n#endif\n\n\n#if !defined(ASIO_HAS_CONSTEXPR)\ntemplate <int I>\nconst context_t<I> context_t<I>::instance;\n#endif\n\n}\n\ntypedef detail::context_t<> context_t;\n\n#if defined(ASIO_HAS_CONSTEXPR) || defined(GENERATING_DOCUMENTATION)\nconstexpr context_t context;\n#else\nnamespace { static const context_t& context = context_t::instance; }\n#endif\n\n}\n\n#if !defined(ASIO_HAS_VARIABLE_TEMPLATES)\n\ntemplate <typename T>\nstruct is_applicable_property<T, execution::context_t>\n  : integral_constant<bool,\n      execution::is_executor<T>::value\n        || conditional<\n            execution::is_executor<T>::value,\n            false_type,\n            execution::is_sender<T>\n          >::type::value\n        || conditional<\n            execution::is_executor<T>::value,\n            false_type,\n            execution::is_scheduler<T>\n          >::type::value>\n{\n};\n\n#endif\n\nnamespace traits {\n\n#if !defined(ASIO_HAS_DEDUCED_STATIC_QUERY_TRAIT) \\\n  || !defined(ASIO_HAS_SFINAE_VARIABLE_TEMPLATES)\n\ntemplate <typename T>\nstruct static_query<T, execution::context_t,\n  typename enable_if<\n    execution::detail::context_t<0>::\n      query_static_constexpr_member<T>::is_valid\n  >::type>\n{\n  ASIO_STATIC_CONSTEXPR(bool, is_valid = true);\n  ASIO_STATIC_CONSTEXPR(bool, is_noexcept = true);\n\n  typedef typename execution::detail::context_t<0>::\n    query_static_constexpr_member<T>::result_type result_type;\n\n  static ASIO_CONSTEXPR result_type value()\n  {\n    return execution::detail::context_t<0>::\n      query_static_constexpr_member<T>::value();\n  }\n};\n\n#endif\n\n\n}\n\n#endif\n\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n\n'elaphureLink/thirdparty/asio/include/asio/execution/context_as.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_EXECUTION_CONTEXT_AS_HPP\n#define ASIO_EXECUTION_CONTEXT_AS_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/detail/config.hpp\"\n#include \"asio/detail/type_traits.hpp\"\n#include \"asio/execution/context.hpp\"\n#include \"asio/execution/executor.hpp\"\n#include \"asio/execution/scheduler.hpp\"\n#include \"asio/execution/sender.hpp\"\n#include \"asio/is_applicable_property.hpp\"\n#include \"asio/query.hpp\"\n#include \"asio/traits/query_static_constexpr_member.hpp\"\n#include \"asio/traits/static_query.hpp\"\n\n#include \"asio/detail/push_options.hpp\"\n\nnamespace asio {\n\n#if defined(GENERATING_DOCUMENTATION)\n\nnamespace execution {\n\n\n\ntemplate <typename U>\nstruct context_as_t\n{\n\n  template <typename T>\n  static constexpr bool is_applicable_property_v =\n    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;\n\n\n  static constexpr bool is_requirable = false;\n\n\n  static constexpr bool is_preferable = false;\n\n\n  typedef T polymorphic_query_result_type;\n};\n\n\ntemplate <typename U>\nconstexpr context_as_t context_as;\n\n}\n\n#else\n\nnamespace execution {\n\ntemplate <typename T>\nstruct context_as_t\n{\n#if defined(ASIO_HAS_VARIABLE_TEMPLATES)\n  template <typename U>\n  ASIO_STATIC_CONSTEXPR(bool,\n    is_applicable_property_v = (\n      is_executor<U>::value\n        || conditional<\n            is_executor<U>::value,\n            false_type,\n            is_sender<U>\n          >::type::value\n        || conditional<\n            is_executor<U>::value,\n            false_type,\n            is_scheduler<U>\n          >::type::value));\n#endif\n\n  ASIO_STATIC_CONSTEXPR(bool, is_requirable = false);\n  ASIO_STATIC_CONSTEXPR(bool, is_preferable = false);\n\n  typedef T polymorphic_query_result_type;\n\n  ASIO_CONSTEXPR context_as_t()\n  {\n  }\n\n  ASIO_CONSTEXPR context_as_t(context_t)\n  {\n  }\n\n#if defined(ASIO_HAS_DEDUCED_STATIC_QUERY_TRAIT) \\\n  && defined(ASIO_HAS_SFINAE_VARIABLE_TEMPLATES)\n  template <typename E>\n  static ASIO_CONSTEXPR\n  typename context_t::query_static_constexpr_member<E>::result_type\n  static_query()\n    ASIO_NOEXCEPT_IF((\n      context_t::query_static_constexpr_member<E>::is_noexcept))\n  {\n    return context_t::query_static_constexpr_member<E>::value();\n  }\n\n  template <typename E, typename U = decltype(context_as_t::static_query<E>())>\n  static ASIO_CONSTEXPR const U static_query_v\n    = context_as_t::static_query<E>();\n#endif\n\n\n  template <typename Executor, typename U>\n  friend ASIO_CONSTEXPR U query(\n      const Executor& ex, const context_as_t<U>&,\n      typename enable_if<\n        is_same<T, U>::value\n      >::type* = 0,\n      typename enable_if<\n        can_query<const Executor&, const context_t&>::value\n      >::type* = 0)\n#if !defined(__clang__)\n#if defined(ASIO_MSVC)\n    ASIO_NOEXCEPT_IF((\n      is_nothrow_query<const Executor&, const context_t&>::value))\n#else\n    ASIO_NOEXCEPT_IF((\n      is_nothrow_query<const Executor&, const context_t&>::value))\n#endif\n#endif\n  {\n    return asio::query(ex, context);\n  }\n};\n\n#if defined(ASIO_HAS_DEDUCED_STATIC_QUERY_TRAIT) \\\n  && defined(ASIO_HAS_SFINAE_VARIABLE_TEMPLATES)\ntemplate <typename T> template <typename E, typename U>\nconst U context_as_t<T>::static_query_v;\n#endif\n\n\n#if (defined(ASIO_HAS_VARIABLE_TEMPLATES) \\\n    && defined(ASIO_HAS_CONSTEXPR)) \\\n  || defined(GENERATING_DOCUMENTATION)\ntemplate <typename T>\nconstexpr context_as_t<T> context_as{};\n#endif\n\n\n\n}\n\n#if !defined(ASIO_HAS_VARIABLE_TEMPLATES)\n\ntemplate <typename T, typename U>\nstruct is_applicable_property<T, execution::context_as_t<U> >\n  : integral_constant<bool,\n      execution::is_executor<T>::value\n        || conditional<\n            execution::is_executor<T>::value,\n            false_type,\n            execution::is_sender<T>\n          >::type::value\n        || conditional<\n            execution::is_executor<T>::value,\n            false_type,\n            execution::is_scheduler<T>\n          >::type::value>\n{\n};\n\n#endif\n\nnamespace traits {\n\n#if !defined(ASIO_HAS_DEDUCED_STATIC_QUERY_TRAIT) \\\n  || !defined(ASIO_HAS_SFINAE_VARIABLE_TEMPLATES)\n\ntemplate <typename T, typename U>\nstruct static_query<T, execution::context_as_t<U>,\n  typename enable_if<\n    static_query<T, execution::context_t>::is_valid\n  >::type> : static_query<T, execution::context_t>\n{\n};\n\n#endif\n\n\n#if !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)\n\ntemplate <typename T, typename U>\nstruct query_free<T, execution::context_as_t<U>,\n    typename enable_if<\n      can_query<const T&, const execution::context_t&>::value\n    >::type>\n{\n  ASIO_STATIC_CONSTEXPR(bool, is_valid = true);\n  ASIO_STATIC_CONSTEXPR(bool, is_noexcept =\n    (is_nothrow_query<const T&, const execution::context_t&>::value));\n\n  typedef U result_type;\n};\n\n#endif\n\n}\n\n#endif\n\n}\n\n#include \"asio/detail/pop_options.hpp\"\n\n#endif\n\n'elaphureLink/elaphureLinkProxy/proxy.cpp'\n:﻿#include \"pch.h\"\n\n#include \"SocketClient.hpp\"\n\n\nclass ProxyManager\n{\n    public:\n    ProxyManager()\n        : on_connect_callback_(nullptr),\n          on_socket_disconnect_callback_(nullptr)\n    {\n    }\n\n    bool is_proxy_running()\n    {\n        if (client_.get()) {\n            return client_.get()->is_socket_running();\n        }\n\n        return false;\n    }\n\n    void set_on_proxy_connect_callback(onSocketConnectCallbackType callback)\n    {\n        on_connect_callback_ = callback;\n\n        if (client_.get()) {\n            client_.get()->set_connect_callback(callback);\n        }\n    }\n\n    void set_on_proxy_disconnect_callback(onSocketDisconnectCallbackType callback)\n    {\n        on_socket_disconnect_callback_ = callback;\n\n        if (client_.get()) {\n            client_.get()->set_disconnect_callback(callback);\n        }\n    }\n\n    int start_with_address(std::string address)\n    {\n        stop();\n        client_ = std::make_unique<SocketClient>();\n\n        if (on_connect_callback_) {\n            client_.get()->set_connect_callback(on_connect_callback_);\n        }\n        if (on_socket_disconnect_callback_) {\n            client_.get()->set_disconnect_callback(on_socket_disconnect_callback_);\n        }\n\n        int ret = client_.get()->init_socket(address, \"3240\");\n        if (ret != 0) {\n            return ret;\n        }\n\n        return client_.get()->start();\n    }\n\n    void stop()\n    {\n        if (client_.get()) {\n            client_.get()->kill();\n        }\n        client_.reset(nullptr);\n    }\n\n    private:\n    onSocketConnectCallbackType    on_connect_callback_;\n    onSocketDisconnectCallbackType on_socket_disconnect_callback_;\n    std::unique_ptr<SocketClient>  client_;\n};\n\nProxyManager k_manager;\n\n\nPROXY_DLL_FUNCTION int el_proxy_start_with_address(char *address)\n{\n    return k_manager.start_with_address(address);\n}\n\n\nPROXY_DLL_FUNCTION void el_proxy_stop()\n{\n    if (k_is_proxy_init) {\n        return k_manager.stop();\n    }\n}\n\n\nPROXY_DLL_FUNCTION void el_proxy_set_on_connect_callback(onSocketConnectCallbackType callback)\n{\n    return k_manager.set_on_proxy_connect_callback(callback);\n}\n\n\nPROXY_DLL_FUNCTION void el_proxy_set_on_disconnect_callback(onSocketDisconnectCallbackType callback)\n{\n    return k_manager.set_on_proxy_disconnect_callback(callback);\n}\n\n'elaphureLink/elaphureLinkProxy/SocketClient.hpp'\n:﻿#pragma once\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n\n#include <sdkddkver.h>\n#include \"thirdparty/asio/include/asio.hpp\"\n\n#include \"pch.h\"\n\nusing asio::ip::tcp;\n\nclass SocketClient\n{\n    public:\n    SocketClient()\n        : is_running_(false),\n          connect_callback_(nullptr),\n          disconnect_callback_(nullptr)\n    {\n    }\n\n    void do_something();\n\n    ~SocketClient()\n    {\n\n\n\n        if (main_thread_.joinable()) {\n            main_thread_.join();\n        }\n    }\n\n    int init_socket(std::string address, std::string port = \"3240\")\n    {\n        socket_.reset(nullptr);\n\n        io_context_ = std::make_unique<asio::io_context>();\n        tcp::resolver resolver(get_io_context());\n\n        socket_ = std::make_unique<asio::ip::tcp::socket>(get_io_context());\n\n        try {\n            endpoint_ = resolver.resolve(address, port);\n        } catch (std::exception &e) {\n            return -1;\n        }\n\n        return 0;\n    }\n\n\n    void kill()\n    {\n        is_running_ = false;\n        if (k_is_proxy_init) {\n            k_shared_memory_ptr->info_page.is_proxy_ready       = 0;\n            k_shared_memory_ptr->consumer_page.command_response = 0xFFFFFFFF;\n            SetEvent(k_producer_event);\n            SetEvent(k_consumer_event);\n        }\n\n        socket_.get()->close();\n        io_context_.get()->stop();\n\n        Sleep(100);\n    }\n\n    int start()\n    {\n        using namespace std::chrono_literals;\n\n        std::unique_lock<std::mutex> lk(running_status_mutex_);\n        if (is_running_) {\n            return 0;\n        }\n\n        is_running_post_done_ = false;\n        is_running_           = true;\n\n        do_connect(endpoint_);\n\n        main_thread_ = std::thread([&]() {\n            try {\n                get_io_context().run();\n            } catch (std::exception &e) {\n                set_running_status(false, e.what());\n            }\n\n        });\n\n        running_cv_.wait(lk, [this]() { return is_running_post_done_; });\n\n        return !is_running_;\n    }\n\n    void wait_main_thread()\n    {\n        main_thread_.join();\n    }\n\n\n\n\n\n    public:\n    asio::io_context &get_io_context()\n    {\n        return *(io_context_.get());\n    }\n\n    asio::ip::tcp::socket &get_socket()\n    {\n        return *(socket_.get());\n    }\n\n    bool is_socket_running()\n    {\n        return is_running_;\n    }\n\n    void set_running_status(bool status, const std::string msg)\n    {\n        is_running_ = status;\n        if (status) {\n            if (connect_callback_) {\n                connect_callback_(msg.c_str());\n            }\n        } else {\n            if (disconnect_callback_) {\n                disconnect_callback_(msg.c_str());\n            }\n        }\n    }\n\n    void set_connect_callback(onSocketConnectCallbackType callback)\n    {\n        connect_callback_ = callback;\n    }\n\n    void set_disconnect_callback(onSocketDisconnectCallbackType callback)\n    {\n        disconnect_callback_ = callback;\n    }\n\n    private:\n    void close()\n    {\n        is_running_ = false;\n        if (k_is_proxy_init) {\n            k_shared_memory_ptr->info_page.is_proxy_ready       = 0;\n            k_shared_memory_ptr->consumer_page.command_response = 0xFFFFFFFF;\n            SetEvent(k_producer_event);\n            SetEvent(k_consumer_event);\n        }\n\n        asio::post(get_io_context(),\n                   [this]() {\n                       get_socket().close();\n                   });\n    }\n\n    void do_connect(const tcp::resolver::results_type &endpoints)\n    {\n        asio::async_connect(get_socket(), endpoints,\n                            [&](std::error_code ec, tcp::endpoint) {\n\n                                if (!ec) {\n                                    asio::ip::tcp::no_delay option(true);\n                                    get_socket().set_option(option);\n\n                                    set_keep_alive();\n\n                                    do_handshake();\n                                } else {\n                                    notify_connection_status(false, ec.message());\n                                    close();\n                                }\n                            });\n    }\n    void set_keep_alive();\n\n\n    void do_handshake();\n\n\n    void get_device_info();\n    void do_data_process();\n\n    void notify_connection_status(bool status, const std::string msg)\n    {\n        is_running_post_done_ = true;\n        set_running_status(status, msg);\n        running_cv_.notify_all();\n    }\n\n\n    private:\n    bool                    is_running_;\n    bool                    is_running_post_done_;\n    std::mutex              running_status_mutex_;\n    std::condition_variable running_cv_;\n\n    std::unique_ptr<asio::io_context> io_context_;\n    std::unique_ptr<tcp::socket>      socket_;\n\n    tcp::resolver::results_type endpoint_;\n\n    std::thread main_thread_;\n\n    onSocketConnectCallbackType    connect_callback_;\n    onSocketDisconnectCallbackType disconnect_callback_;\n};\n\n'elaphureLink/thirdparty/asio/include/asio.hpp'\n:\n\n\n\n\n\n\n\n\n\n#ifndef ASIO_HPP\n#define ASIO_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include \"asio/associated_allocator.hpp\"\n#include \"asio/associated_executor.hpp\"\n#include \"asio/associated_cancellation_slot.hpp\"\n#include \"asio/associator.hpp\"\n#include \"asio/async_result.hpp\"\n#include \"asio/awaitable.hpp\"\n#include \"asio/basic_datagram_socket.hpp\"\n#include \"asio/basic_deadline_timer.hpp\"\n#include \"asio/basic_file.hpp\"\n#include \"asio/basic_io_object.hpp\"\n#include \"asio/basic_random_access_file.hpp\"\n#include \"asio/basic_raw_socket.hpp\"\n#include \"asio/basic_readable_pipe.hpp\"\n#include \"asio/basic_seq_packet_socket.hpp\"\n#include \"asio/basic_serial_port.hpp\"\n#include \"asio/basic_signal_set.hpp\"\n#include \"asio/basic_socket.hpp\"\n#include \"asio/basic_socket_acceptor.hpp\"\n#include \"asio/basic_socket_iostream.hpp\"\n#include \"asio/basic_socket_streambuf.hpp\"\n#include \"asio/basic_stream_file.hpp\"\n#include \"asio/basic_stream_socket.hpp\"\n#include \"asio/basic_streambuf.hpp\"\n#include \"asio/basic_waitable_timer.hpp\"\n#include \"asio/basic_writable_pipe.hpp\"\n#include \"asio/bind_allocator.hpp\"\n#include \"asio/bind_cancellation_slot.hpp\"\n#include \"asio/bind_executor.hpp\"\n#include \"asio/buffer.hpp\"\n#include \"asio/buffer_registration.hpp\"\n#include \"asio/buffered_read_stream_fwd.hpp\"\n#include \"asio/buffered_read_stream.hpp\"\n#include \"asio/buffered_stream_fwd.hpp\"\n#include \"asio/buffered_stream.hpp\"\n#include \"asio/buffered_write_stream_fwd.hpp\"\n#include \"asio/buffered_write_stream.hpp\"\n#include \"asio/buffers_iterator.hpp\"\n#include \"asio/cancellation_signal.hpp\"\n#include \"asio/cancellation_state.hpp\"\n#include \"asio/cancellation_type.hpp\"\n#include \"asio/co_spawn.hpp\"\n#include \"asio/completion_condition.hpp\"\n#include \"asio/compose.hpp\"\n#include \"asio/connect.hpp\"\n#include \"asio/connect_pipe.hpp\"\n#include \"asio/coroutine.hpp\"\n#include \"asio/deadline_timer.hpp\"\n#include \"asio/defer.hpp\"\n#include \"asio/detached.hpp\"\n#include \"asio/dispatch.hpp\"\n#include \"asio/error.hpp\"\n#include \"asio/error_code.hpp\"\n#include \"asio/execution.hpp\"\n#include \"asio/execution/allocator.hpp\"\n#include \"asio/execution/any_executor.hpp\"\n#include \"asio/execution/blocking.hpp\"\n#include \"asio/execution/blocking_adaptation.hpp\"\n#include \"asio/execution/bulk_execute.hpp\"\n#include \"asio/execution/bulk_guarantee.hpp\"\n#include \"asio/execution/connect.hpp\"\n#include \"asio/execution/context.hpp\"\n#include \"asio/execution/context_as.hpp\"\n#include \"asio/execution/execute.hpp\"\n#include \"asio/execution/executor.hpp\"\n#include \"asio/execution/invocable_archetype.hpp\"\n#include \"asio/execution/mapping.hpp\"\n#include \"asio/execution/occupancy.hpp\"\n#include \"asio/execution/operation_state.hpp\"\n#include \"asio/execution/outstanding_work.hpp\"\n#include \"asio/execution/prefer_only.hpp\"\n#include \"asio/execution/receiver.hpp\"\n#include \"asio/execution/receiver_invocation_error.hpp\"\n#include \"asio/execution/relationship.hpp\"\n#include \"asio/execution/schedule.hpp\"\n#include \"asio/execution/scheduler.hpp\"\n#include \"asio/execution/sender.hpp\"\n#include \"asio/execution/set_done.hpp\"\n#include \"asio/execution/set_error.hpp\"\n#include \"asio/execution/set_value.hpp\"\n#include \"asio/execution/start.hpp\"\n#include \"asio/execution_context.hpp\"\n#include \"asio/executor.hpp\"\n#include \"asio/executor_work_guard.hpp\"\n#include \"asio/file_base.hpp\"\n#include \"asio/generic/basic_endpoint.hpp\"\n#include \"asio/generic/datagram_protocol.hpp\"\n#include \"asio/generic/raw_protocol.hpp\"\n#include \"asio/generic/seq_packet_protocol.hpp\"\n#include \"asio/generic/stream_protocol.hpp\"\n#include \"asio/handler_alloc_hook.hpp\"\n#include \"asio/handler_continuation_hook.hpp\"\n#include \"asio/handler_invoke_hook.hpp\"\n#include \"asio/high_resolution_timer.hpp\"\n#include \"asio/io_context.hpp\"\n#include \"asio/io_context_strand.hpp\"\n#include \"asio/io_service.hpp\"\n#include \"asio/io_service_strand.hpp\"\n#include \"asio/ip/address.hpp\"\n#include \"asio/ip/address_v4.hpp\"\n#include \"asio/ip/address_v4_iterator.hpp\"\n#include \"asio/ip/address_v4_range.hpp\"\n#include \"asio/ip/address_v6.hpp\"\n#include \"asio/ip/address_v6_iterator.hpp\"\n#include \"asio/ip/address_v6_range.hpp\"\n#include \"asio/ip/network_v4.hpp\"\n#include \"asio/ip/network_v6.hpp\"\n#include \"asio/ip/bad_address_cast.hpp\"\n#include \"asio/ip/basic_endpoint.hpp\"\n#include \"asio/ip/basic_resolver.hpp\"\n#include \"asio/ip/basic_resolver_entry.hpp\"\n#include \"asio/ip/basic_resolver_iterator.hpp\"\n#include \"asio/ip/basic_resolver_query.hpp\"\n#include \"asio/ip/host_name.hpp\"\n#include \"asio/ip/icmp.hpp\"\n#include \"asio/ip/multicast.hpp\"\n#include \"asio/ip/resolver_base.hpp\"\n#include \"asio/ip/resolver_query_base.hpp\"\n#include \"asio/ip/tcp.hpp\"\n#include \"asio/ip/udp.hpp\"\n#include \"asio/ip/unicast.hpp\"\n#include \"asio/ip/v6_only.hpp\"\n#include \"asio/is_applicable_property.hpp\"\n#include \"asio/is_executor.hpp\"\n#include \"asio/is_read_buffered.hpp\"\n#include \"asio/is_write_buffered.hpp\"\n#include \"asio/local/basic_endpoint.hpp\"\n#include \"asio/local/connect_pair.hpp\"\n#include \"asio/local/datagram_protocol.hpp\"\n#include \"asio/local/stream_protocol.hpp\"\n#include \"asio/multiple_exceptions.hpp\"\n#include \"asio/packaged_task.hpp\"\n#include \"asio/placeholders.hpp\"\n#include \"asio/posix/basic_descriptor.hpp\"\n#include \"asio/posix/basic_stream_descriptor.hpp\"\n#include \"asio/posix/descriptor.hpp\"\n#include \"asio/posix/descriptor_base.hpp\"\n#include \"asio/posix/stream_descriptor.hpp\"\n#include \"asio/post.hpp\"\n#include \"asio/prefer.hpp\"\n#include \"asio/query.hpp\"\n#include \"asio/random_access_file.hpp\"\n#include \"asio/read.hpp\"\n#include \"asio/read_at.hpp\"\n#include \"asio/read_until.hpp\"\n#include \"asio/readable_pipe.hpp\"\n#include \"asio/recycling_allocator.hpp\"\n#include \"asio/redirect_error.hpp\"\n#include \"asio/registered_buffer.hpp\"\n#include \"asio/require.hpp\"\n#include \"asio/require_concept.hpp\"\n#include \"asio/serial_port.hpp\"\n#include \"asio/serial_port_base.hpp\"\n#include \"asio/signal_set.hpp\"\n#include \"asio/socket_base.hpp\"\n#include \"asio/static_thread_pool.hpp\"\n#include \"asio/steady_timer.hpp\"\n#include \"asio/strand.hpp\"\n#include \"asio/stream_file.hpp\"\n#include \"asio/streambuf.hpp\"\n#include \"asio/system_context.hpp\"\n#include \"asio/system_error.hpp\"\n#include \"asio/system_executor.hpp\"\n#include \"asio/system_timer.hpp\"\n#include \"asio/this_coro.hpp\"\n#include \"asio/thread.hpp\"\n#include \"asio/thread_pool.hpp\"\n#include \"asio/time_traits.hpp\"\n#include \"asio/use_awaitable.hpp\"\n#include \"asio/use_future.hpp\"\n#include \"asio/uses_executor.hpp\"\n#include \"asio/version.hpp\"\n#include \"asio/wait_traits.hpp\"\n#include \"asio/windows/basic_object_handle.hpp\"\n#include \"asio/windows/basic_overlapped_handle.hpp\"\n#include \"asio/windows/basic_random_access_handle.hpp\"\n#include \"asio/windows/basic_stream_handle.hpp\"\n#include \"asio/windows/object_handle.hpp\"\n#include \"asio/windows/overlapped_handle.hpp\"\n#include \"asio/windows/overlapped_ptr.hpp\"\n#include \"asio/windows/random_access_handle.hpp\"\n#include \"asio/windows/stream_handle.hpp\"\n#include \"asio/writable_pipe.hpp\"\n#include \"asio/write.hpp\"\n#include \"asio/write_at.hpp\"\n\n#endif\n",
        "gt": [
            "'elaphureLink/thirdparty/asio/include/asio/execution/context.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio/execution/context_as.hpp'",
            "'elaphureLink/thirdparty/asio/include/asio.hpp'",
            "'elaphureLink/elaphureLinkProxy/SocketClient.hpp'",
            "'elaphureLink/elaphureLinkProxy/proxy.cpp'"
        ]
    },
    {
        "files": [
            "'booster/cpp/ggml/src/ggml-sycl/common.hpp'",
            "'booster/cpp/ggml/include/ggml-sycl.h'",
            "'booster/cpp/ggml/src/ggml-sycl/norm.hpp'",
            "'booster/cpp/ggml/src/ggml-sycl/softmax.cpp'"
        ],
        "content": "'booster/cpp/ggml/src/ggml-sycl/common.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n#ifndef GGML_SYCL_COMMON_HPP\n#define GGML_SYCL_COMMON_HPP\n\n#include <fstream>\n#include <iostream>\n\n#include \"dpct/helper.hpp\"\n#include \"ggml-sycl.h\"\n#include \"presets.hpp\"\n\n#define GGML_COMMON_DECL_SYCL\n#define GGML_COMMON_IMPL_SYCL\n#include \"ggml-common.h\"\n\nvoid* ggml_sycl_host_malloc(size_t size);\nvoid ggml_sycl_host_free(void* ptr);\n\nstatic int g_ggml_sycl_debug = 0;\n#define GGML_SYCL_DEBUG(...)        \\\n  do {                              \\\n    if (g_ggml_sycl_debug)          \\\n      fprintf(stderr, __VA_ARGS__); \\\n  } while (0)\n\n#define CHECK_TRY_ERROR(expr)                                            \\\n  [&]() {                                                                \\\n    try {                                                                \\\n      expr;                                                              \\\n      return dpct::success;                                              \\\n    } catch (std::exception const& e) {                                  \\\n      std::cerr << e.what() << \"\\nException caught at file:\" << __FILE__ \\\n                << \", line:\" << __LINE__ << \", func:\" << __func__        \\\n                << std::endl;                                            \\\n      return dpct::default_error;                                        \\\n    }                                                                    \\\n  }()\n\n\n#define __SYCL_ARCH__ DPCT_COMPATIBILITY_TEMP\n#define VER_4VEC 610\n#define VER_GEN9 700\n#define VER_GEN12 1000000\n#define VER_GEN13 (VER_GEN12 + 1030)\n\n#define GGML_SYCL_MAX_NODES 8192\n\n\n\n#if !defined(GGML_SYCL_FORCE_MMQ)\n    #define SYCL_USE_XMX\n#endif\n\n\n#define MMQ_MAX_BATCH_SIZE 32\n\n#if defined(_MSC_VER)\n#pragma warning(disable : 4244 4267)\n#endif\n\n\n#ifndef GGML_SYCL_DMMV_X\n#define GGML_SYCL_DMMV_X 32\n#endif\n#ifndef GGML_SYCL_MMV_Y\n#define GGML_SYCL_MMV_Y 1\n#endif\n\ntypedef sycl::queue *queue_ptr;\n\nenum ggml_sycl_backend_gpu_mode {\n  SYCL_UNSET_GPU_MODE = -1,\n  SYCL_SINGLE_GPU_MODE = 0,\n  SYCL_MUL_GPU_MODE\n};\n\nstatic_assert(sizeof(sycl::half) == sizeof(ggml_fp16_t), \"wrong fp16 size\");\n\nstatic void crash() {\n  int* ptr = NULL;\n  *ptr = 0;\n}\n\n[[noreturn]] static void ggml_sycl_error(\n    const char* stmt,\n    const char* func,\n    const char* file,\n    const int line,\n    const char* msg) {\n  fprintf(stderr, \"SYCL error: %s: %s\\n\", stmt, msg);\n  fprintf(stderr, \"  in function %s at %s:%d\\n\", func, file, line);\n  GGML_ABORT(\"SYCL error\");\n}\n\n#define SYCL_CHECK(err)                     \\\n  do {                                      \\\n    auto err_ = (err);                      \\\n    if (err_ != 0)                          \\\n      ggml_sycl_error(                      \\\n          #err,                             \\\n          __func__,                         \\\n          __FILE__,                         \\\n          __LINE__,                         \\\n          \"Meet error in this line code!\"); \\\n  } while (0)\n\n#if DPCT_COMPAT_RT_VERSION >= 11100\n#define GGML_SYCL_ASSUME(x) __builtin_assume(x)\n#else\n#define GGML_SYCL_ASSUME(x)\n#endif\n\n#ifdef GGML_SYCL_F16\ntypedef sycl::half dfloat;\ntypedef sycl::half2 dfloat2;\n#else\ntypedef float dfloat;\ntypedef sycl::float2 dfloat2;\n#endif\n\n#define MMVQ_MAX_BATCH_SIZE  8\n\nstatic const int8_t kvalues_iq4nl[16]={-127, -104, -83, -65, -49, -35, -22, -10, 1, 13, 25, 38, 53, 69, 89, 113};\n\nstatic int g_all_sycl_device_count = -1;\nstatic bool g_ggml_backend_sycl_buffer_type_initialized = false;\n\nstatic ggml_sycl_backend_gpu_mode g_ggml_sycl_backend_gpu_mode =\n    SYCL_UNSET_GPU_MODE;\n\nstatic void* g_scratch_buffer = nullptr;\nstatic size_t g_scratch_size = 0;\nstatic size_t g_scratch_offset = 0;\n\n[[noreturn]] static inline void bad_arch(const sycl::stream& stream_ct1) {\n  stream_ct1 << \"ERROR: ggml-sycl was compiled without support for the \"\n                \"current GPU architecture.\\n\";\n\n  std::exit(1);\n\n  (void)bad_arch;\n}\n\nint get_current_device_id();\n\ninline dpct::err0 ggml_sycl_set_device(const int device) try {\n\n  int current_device_id;\n  SYCL_CHECK(CHECK_TRY_ERROR(current_device_id = get_current_device_id()));\n\n\n\n  if (device == current_device_id) {\n    return 0;\n  }\n\n  return CHECK_TRY_ERROR(dpct::select_device(device));\n} catch (sycl::exception const& exc) {\n  std::cerr << exc.what() << \"Exception caught at file:\" << __FILE__\n            << \", line:\" << __LINE__ << std::endl;\n  crash();\n  std::exit(1);\n}\n\n\n\nstruct ggml_sycl_device_info {\n    int device_count;\n\n    struct sycl_device_info {\n        int     cc;\n\n\n        bool    vmm;\n        size_t  total_vram;\n    };\n\n    sycl_device_info devices[GGML_SYCL_MAX_DEVICES] = {};\n\n    std::array<float, GGML_SYCL_MAX_DEVICES> default_tensor_split = {};\n\n    int max_work_group_sizes[GGML_SYCL_MAX_DEVICES] = {0};\n};\n\nconst ggml_sycl_device_info & ggml_sycl_info();\n\nstruct ggml_sycl_pool {\n    virtual ~ggml_sycl_pool() = default;\n\n    virtual void * alloc(size_t size, size_t * actual_size) = 0;\n    virtual void free(void * ptr, size_t size) = 0;\n};\n\ntemplate<typename T>\nstruct ggml_sycl_pool_alloc {\n    ggml_sycl_pool * pool = nullptr;\n    T * ptr = nullptr;\n    size_t actual_size = 0;\n\n    explicit ggml_sycl_pool_alloc(ggml_sycl_pool & pool) : pool(&pool) {\n    }\n\n    ggml_sycl_pool_alloc(ggml_sycl_pool & pool, size_t size) : pool(&pool) {\n        alloc(size);\n    }\n\n    ~ggml_sycl_pool_alloc() {\n        if (ptr != nullptr) {\n            pool->free(ptr, actual_size);\n        }\n    }\n\n\n    T * alloc(size_t size) {\n        GGML_ASSERT(pool != nullptr);\n        GGML_ASSERT(ptr == nullptr);\n        ptr = (T *) pool->alloc(size * sizeof(T), &this->actual_size);\n        return ptr;\n    }\n\n    T * alloc(ggml_sycl_pool & pool, size_t size) {\n        this->pool = &pool;\n        return alloc(size);\n    }\n\n    T * get() {\n        return ptr;\n    }\n\n    ggml_sycl_pool_alloc() = default;\n    ggml_sycl_pool_alloc(const ggml_sycl_pool_alloc &) = delete;\n    ggml_sycl_pool_alloc(ggml_sycl_pool_alloc &&) = delete;\n    ggml_sycl_pool_alloc& operator=(const ggml_sycl_pool_alloc &) = delete;\n    ggml_sycl_pool_alloc& operator=(ggml_sycl_pool_alloc &&) = delete;\n};\n\n\n\nstruct ggml_tensor_extra_gpu {\n  void* data_device[GGML_SYCL_MAX_DEVICES];\n\n  dpct::event_ptr events[GGML_SYCL_MAX_DEVICES]\n                        [GGML_SYCL_MAX_STREAMS];\n};\n\nstruct ggml_backend_sycl_context {\n    int device;\n    std::string name;\n\n    queue_ptr qptrs[GGML_SYCL_MAX_DEVICES][GGML_SYCL_MAX_STREAMS] = { { nullptr } };\n\n    explicit ggml_backend_sycl_context(int device) :\n        device(device),\n        name(GGML_SYCL_NAME + std::to_string(device)) {\n    }\n\n    queue_ptr stream(int device, int stream) {\n        if (qptrs[device][stream] == nullptr) {\n            qptrs[device][stream] = &(dpct::get_device(device).default_queue());\n        }\n        return qptrs[device][stream];\n    }\n\n    queue_ptr stream() {\n        return stream(device, 0);\n    }\n\n\n    std::unique_ptr<ggml_sycl_pool> pools[GGML_SYCL_MAX_DEVICES];\n\n    static std::unique_ptr<ggml_sycl_pool> new_pool_for_device(queue_ptr qptr, int device);\n\n    ggml_sycl_pool & pool(int device) {\n        if (pools[device] == nullptr) {\n            pools[device] = new_pool_for_device(stream(device,0), device);\n        }\n        return *pools[device];\n    }\n\n    ggml_sycl_pool & pool() {\n        return pool(device);\n    }\n};\n\n\n\nstatic __dpct_inline__ float warp_reduce_sum(float x,\n    const sycl::nd_item<3>& item_ct1) {\n#pragma unroll\n    for (int mask = WARP_SIZE / 2; mask > 0; mask >>= 1) {\n\n        x += dpct::permute_sub_group_by_xor(item_ct1.get_sub_group(), x, mask);\n    }\n    return x;\n}\n\nstatic __dpct_inline__ sycl::float2\nwarp_reduce_sum(sycl::float2 a, const sycl::nd_item<3>& item_ct1) {\n#pragma unroll\n    for (int mask = WARP_SIZE / 2; mask > 0; mask >>= 1) {\n        a.x() += dpct::permute_sub_group_by_xor(item_ct1.get_sub_group(), a.x(),\n            mask);\n        a.y() += dpct::permute_sub_group_by_xor(item_ct1.get_sub_group(), a.y(),\n            mask);\n    }\n    return a;\n}\n\nstatic __dpct_inline__ float warp_reduce_max(float x,\n    const sycl::nd_item<3>& item_ct1) {\n#pragma unroll\n    for (int mask = WARP_SIZE / 2; mask > 0; mask >>= 1) {\n\n        x = sycl::fmax(x, dpct::permute_sub_group_by_xor(\n            item_ct1.get_sub_group(), x, mask));\n    }\n    return x;\n}\n\n\ntemplate <typename Tp, int n>\ninline sycl::vec<Tp, n> vec_aligned_load(const Tp* aligned_ptr) {\n    return *reinterpret_cast<const sycl::vec<Tp, n>*>(aligned_ptr);\n}\n\n\ntemplate <typename Tp, int dim>\nstatic __dpct_inline__ Tp* get_pointer(sycl::local_accessor<Tp, dim> acc) {\n    return acc.template get_multi_ptr<sycl::access::decorated::no>().get();\n}\n\n#endif\n\n'booster/cpp/ggml/include/ggml-sycl.h'\n:\n\n\n\n\n\n#pragma once\n\n#include \"ggml.h\"\n#include \"ggml-backend.h\"\n\n#define GGML_SYCL_NAME \"SYCL\"\n#define GGML_SYCL_MAX_DEVICES 48\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n\nGGML_API ggml_backend_t ggml_backend_sycl_init(int device);\n\n\nGGML_API ggml_backend_buffer_type_t ggml_backend_sycl_buffer_type(int device);\n\n\nGGML_API GGML_CALL ggml_backend_buffer_type_t ggml_backend_sycl_split_buffer_type(const float * tensor_split);\n\n\nGGML_API ggml_backend_buffer_type_t ggml_backend_sycl_host_buffer_type(void);\n\nGGML_API void   ggml_backend_sycl_print_sycl_devices(void);\nGGML_API GGML_CALL void   ggml_sycl_get_gpu_list(int *id_list, int max_len);\nGGML_API GGML_CALL void   ggml_sycl_get_device_description(int device, char *description, size_t description_size);\nGGML_API GGML_CALL int   ggml_backend_sycl_get_device_count();\nGGML_API GGML_CALL void ggml_backend_sycl_get_device_memory(int device, size_t *free, size_t *total);\n\n\n\n\n#ifdef  __cplusplus\n}\n#endif\n\n'booster/cpp/ggml/src/ggml-sycl/norm.hpp'\n:\n\n\n\n\n\n\n\n\n\n\n\n#ifndef GGML_SYCL_NORM_HPP\n#define GGML_SYCL_NORM_HPP\n\n#include \"common.hpp\"\n\nvoid ggml_sycl_op_norm(ggml_backend_sycl_context& ctx, const ggml_tensor* src0, const ggml_tensor* src1,\n    ggml_tensor* dst, const float* src0_dd,\n    const float* src1_dd, float* dst_dd,\n    const queue_ptr& main_stream);\n\nvoid ggml_sycl_op_rms_norm(ggml_backend_sycl_context& ctx, const ggml_tensor* src0,\n    const ggml_tensor* src1, ggml_tensor* dst,\n    const float* src0_dd, const float* src1_dd,\n    float* dst_dd,\n    const queue_ptr& main_stream);\n\nvoid ggml_sycl_op_group_norm(ggml_backend_sycl_context& ctx, const ggml_tensor* src0,\n    const ggml_tensor* src1, ggml_tensor* dst,\n    const float* src0_dd, const float* src1_dd,\n    float* dst_dd,\n    const queue_ptr& main_stream);\n\n#endif\n\n'booster/cpp/ggml/src/ggml-sycl/softmax.cpp'\n:#include \"norm.hpp\"\n\ntemplate <bool vals_smem, int ncols_template, int block_size_template>\nstatic void soft_max_f32(const float * x, const float * mask, float * dst, const int ncols_par,\n                         const int nrows_y, const float scale, const float max_bias, const float m0,\n                         const float m1, uint32_t n_head_log2, const sycl::nd_item<3> &item_ct1, float *buf) {\n    const int ncols = ncols_template == 0 ? ncols_par : ncols_template;\n\n    const int tid = item_ct1.get_local_id(2);\n    const int rowx = item_ct1.get_group(2);\n    const int rowy = rowx % nrows_y;\n\n    const int block_size = block_size_template == 0 ? item_ct1.get_local_range(2) : block_size_template;\n\n    const int warp_id = item_ct1.get_local_id(2) / WARP_SIZE;\n    const int lane_id = item_ct1.get_local_id(2) % WARP_SIZE;\n    const int nthreads = block_size;\n    const int nwarps = nthreads / WARP_SIZE;\n    int nreduce = nwarps / WARP_SIZE;\n    float slope = 1.0f;\n\n\n    if (max_bias > 0.0f) {\n        const uint32_t h = rowx/nrows_y;\n\n        const float base = h < n_head_log2 ? m0 : m1;\n        const int   exp  = h < n_head_log2 ? h + 1 : 2*(h - n_head_log2) + 1;\n\n        slope = sycl::pow(base, float(exp));\n    }\n\n    float *vals = vals_smem ? buf + std::max(nwarps, WARP_SIZE) : dst + rowx * ncols;\n    float max_val = -INFINITY;\n\n    for (int col0 = 0; col0 < ncols; col0 += block_size) {\n        const int col = col0 + tid;\n\n        if (ncols_template == 0 && col >= ncols) {\n            break;\n        }\n\n        const int ix = rowx*ncols + col;\n        const int iy = rowy*ncols + col;\n\n        const float val = x[ix]*scale + (mask ? slope*mask[iy] : 0.0f);\n\n        vals[col] = val;\n        max_val = sycl::max(max_val, val);\n    }\n\n\n    max_val = warp_reduce_max(max_val, item_ct1);\n    if (block_size > WARP_SIZE) {\n        if (warp_id == 0) {\n            buf[lane_id] = -INFINITY;\n            for (size_t i = 1; i < nreduce; i += 1)\n                buf[lane_id + i * WARP_SIZE] = -INFINITY;\n        }\n        item_ct1.barrier(sycl::access::fence_space::local_space);\n\n        if (lane_id == 0) {\n            buf[warp_id] = max_val;\n        }\n        item_ct1.barrier(sycl::access::fence_space::local_space);\n        max_val = buf[lane_id];\n        for (size_t i = 1; i < nreduce; i += 1)\n        {\n            max_val = std::max(max_val, buf[lane_id + i * WARP_SIZE]);\n        }\n        max_val = warp_reduce_max(max_val, item_ct1);\n    }\n\n    float tmp = 0.f;\n#pragma unroll\n    for (int col0 = 0; col0 < ncols; col0 += block_size) {\n        const int col = col0 + tid;\n                if (ncols_template == 0 && col >= ncols) {\n            break;\n        }\n\n        const float val = sycl::native::exp(vals[col] - max_val);\n        tmp += val;\n        vals[col] = val;\n    }\n\n\n    tmp = warp_reduce_sum(tmp, item_ct1);\n    if (block_size > WARP_SIZE) {\n        item_ct1.barrier(sycl::access::fence_space::local_space);\n        if (warp_id == 0) {\n            buf[lane_id] = 0.f;\n            for (size_t i = 1; i < nreduce; i += 1)\n                buf[lane_id + i * WARP_SIZE] = 0.f;\n        }\n        item_ct1.barrier(sycl::access::fence_space::local_space);\n\n        if (lane_id == 0) {\n            buf[warp_id] = tmp;\n        }\n        item_ct1.barrier(sycl::access::fence_space::local_space);\n\n        tmp = buf[lane_id];\n        for (size_t i = 1; i < nreduce; i += 1)\n        {\n            tmp += buf[lane_id + i * WARP_SIZE];\n        }\n        tmp = warp_reduce_sum(tmp, item_ct1);\n    }\n\n    const float inv_sum = 1.f / tmp;\n\n#pragma unroll\n    for (int col0 = 0; col0 < ncols; col0 += block_size) {\n        const int col = col0 + tid;\n\n        if (ncols_template == 0 && col >= ncols) {\n            return;\n        }\n\n        const int idst = rowx*ncols + col;\n        dst[idst] = vals[col] * inv_sum;\n    }\n}\n\ntemplate <bool vals_smem, int ncols_template, int block_size_template>\nstatic void soft_max_f32_submitter(const float * x, const float * mask, float * dst, const int ncols_par,\n                                   const int nrows_y, const float scale, const float max_bias, const float m0,\n                                   const float m1, uint32_t n_head_log2, sycl::range<3> block_nums, sycl::range<3> block_dims,\n                                   const size_t n_local_scratch, queue_ptr stream) {\n    stream->submit([&](sycl::handler &cgh) {\n        sycl::local_accessor<float, 1> local_buf_acc(n_local_scratch, cgh);\n\n        cgh.parallel_for(\n            sycl::nd_range<3>(block_nums * block_dims, block_dims),\n            [=](sycl::nd_item<3> item_ct1) [[intel::reqd_sub_group_size(WARP_SIZE)]] {\n                soft_max_f32<vals_smem, ncols_template, block_size_template>(x, mask, dst, ncols_par,\n                                                                             nrows_y, scale, max_bias, m0,\n                                                                             m1, n_head_log2, item_ct1,\n                                                                             get_pointer(local_buf_acc));\n            });\n    });\n}\n\nstatic void soft_max_f32_sycl(const float * x, const float * mask,\n                              float * dst, const int ncols_x, const int nrows_x,\n                              const int nrows_y, const float scale, const float max_bias,\n                              queue_ptr stream, int device) {\n    int nth = WARP_SIZE;\n    int max_block_size = ggml_sycl_info().max_work_group_sizes[device];\n    while (nth < ncols_x && nth < max_block_size) nth *= 2;\n    if (nth>max_block_size) nth = max_block_size;\n\n    const sycl::range<3> block_dims(1, 1, nth);\n    const sycl::range<3> block_nums(1, 1, nrows_x);\n    const size_t n_val_tmp = nth / WARP_SIZE;\n    const size_t n_local_scratch = (GGML_PAD(ncols_x, WARP_SIZE) + n_val_tmp);\n\n    const uint32_t n_head_kv   = nrows_x/nrows_y;\n    const uint32_t n_head_log2 = 1u << (uint32_t) floorf(log2f((float) n_head_kv));\n\n    const float m0 = powf(2.0f, -(max_bias       ) / n_head_log2);\n    const float m1 = powf(2.0f, -(max_bias / 2.0f) / n_head_log2);\n\n    const size_t local_mem_size = stream->get_device().get_info<sycl::info::device::local_mem_size>();\n    if (n_local_scratch*sizeof(float) < local_mem_size) {\n        if (ncols_x > max_block_size) {\n            soft_max_f32_submitter<true, 0, 0>(x, mask, dst, ncols_x, nrows_y, scale,\n                                               max_bias, m0, m1, n_head_log2, block_nums,\n                                               block_dims, n_local_scratch, stream);\n            return;\n        }\n        switch (ncols_x) {\n            case 32:\n                soft_max_f32_submitter<true, 32, 32>(x, mask, dst, ncols_x, nrows_y, scale,\n                                                     max_bias, m0, m1, n_head_log2, block_nums,\n                                                     block_dims, n_local_scratch, stream);\n                break;\n            case 64:\n                soft_max_f32_submitter<true, 64, 64>(x, mask, dst, ncols_x, nrows_y, scale,\n                                                     max_bias, m0, m1, n_head_log2, block_nums,\n                                                     block_dims, n_local_scratch, stream);\n                break;\n            case 128:\n                soft_max_f32_submitter<true, 128, 128>(x, mask, dst, ncols_x, nrows_y, scale,\n                                                       max_bias, m0, m1, n_head_log2, block_nums,\n                                                       block_dims, n_local_scratch, stream);\n                break;\n            case 256:\n                soft_max_f32_submitter<true, 256, 256>(x, mask, dst, ncols_x, nrows_y, scale,\n                                                       max_bias, m0, m1, n_head_log2, block_nums,\n                                                       block_dims, n_local_scratch, stream);\n                break;\n            case 512:\n                soft_max_f32_submitter<true, 512, 512>(x, mask, dst, ncols_x, nrows_y, scale,\n                                                       max_bias, m0, m1, n_head_log2, block_nums,\n                                                       block_dims, n_local_scratch, stream);\n                break;\n            case 1024:\n                soft_max_f32_submitter<true, 1024, 1024>(x, mask, dst, ncols_x, nrows_y, scale,\n                                                         max_bias, m0, m1, n_head_log2, block_nums,\n                                                         block_dims, n_local_scratch, stream);\n                break;\n            case 2048:\n                soft_max_f32_submitter<true, 2048, 1024>(x, mask, dst, ncols_x, nrows_y, scale,\n                                                         max_bias, m0, m1, n_head_log2, block_nums,\n                                                         block_dims, n_local_scratch, stream);\n                break;\n            case 4096:\n                soft_max_f32_submitter<true, 4096, 1024>(x, mask, dst, ncols_x, nrows_y, scale,\n                                                         max_bias, m0, m1, n_head_log2, block_nums,\n                                                         block_dims, n_local_scratch, stream);\n                break;\n            default:\n                soft_max_f32_submitter<true, 0, 0>(x, mask, dst, ncols_x, nrows_y, scale,\n                                                   max_bias, m0, m1, n_head_log2, block_nums,\n                                                   block_dims, n_local_scratch, stream);\n                break;\n        }\n    } else {\n        soft_max_f32_submitter<false, 0, 0>(x, mask, dst, ncols_x, nrows_y, scale,\n                                            max_bias, m0, m1, n_head_log2, block_nums,\n                                            block_dims, WARP_SIZE, stream);\n    }\n}\n\nvoid ggml_sycl_op_soft_max(ggml_backend_sycl_context & ctx, const ggml_tensor *src0,\n                                  const ggml_tensor *src1, ggml_tensor *dst,\n                                  const float *src0_dd, const float *src1_dd,\n                                  float *dst_dd,\n                                  const queue_ptr &main_stream) {\n\n    GGML_ASSERT(src0->type == GGML_TYPE_F32);\n    GGML_ASSERT( dst->type == GGML_TYPE_F32);\n\n#pragma message(\"TODO: add ggml_sycl_op_soft_max() F16 src1 support\")\n#pragma message(\"ref:  https:\n    GGML_ASSERT(!src1 || src1->type == GGML_TYPE_F32);\n\n    const int64_t ne00 = src0->ne[0];\n    const int64_t nrows_x = ggml_nrows(src0);\n    const int64_t nrows_y = src0->ne[1];\n\n    float scale = 1.0f;\n    float max_bias = 0.0f;\n\n    memcpy(&scale, dst->op_params + 0, sizeof(float));\n    memcpy(&max_bias, dst->op_params + 1, sizeof(float));\n\n    soft_max_f32_sycl(src0_dd, src1 ? src1_dd : nullptr, dst_dd, ne00,\n        nrows_x, nrows_y, scale, max_bias, main_stream, ctx.device);\n}\n",
        "gt": [
            "'booster/cpp/ggml/include/ggml-sycl.h'",
            "'booster/cpp/ggml/src/ggml-sycl/common.hpp'",
            "'booster/cpp/ggml/src/ggml-sycl/norm.hpp'",
            "'booster/cpp/ggml/src/ggml-sycl/softmax.cpp'"
        ]
    },
    {
        "files": [
            "'PeaceMaker/PeaceMaker Kernel/ThreadFilter.h'",
            "'PeaceMaker/PeaceMaker Kernel/IOCTLCommunication.cpp'",
            "'PeaceMaker/PeaceMaker Kernel/IOCTLCommunication.h'"
        ],
        "content": "'PeaceMaker/PeaceMaker Kernel/ThreadFilter.h'\n:\n#pragma once\n#include \"common.h\"\n#include \"DetectionLogic.h\"\n#include \"ImageHistoryFilter.h\"\n#include \"StackWalker.h\"\n\ntypedef class ThreadFilter\n{\n\tstatic PDETECTION_LOGIC Detector;\n\tstatic STACK_WALKER Walker;\n\n\tstatic PVOID GetThreadStartAddress(\n\t\t_In_ HANDLE ThreadId\n\t\t);\n\n\tstatic VOID ThreadNotifyRoutine(\n\t\tHANDLE ProcessId,\n\t\tHANDLE ThreadId,\n\t\tBOOLEAN Create\n\t\t);\npublic:\n\tThreadFilter(\n\t\t_In_ PDETECTION_LOGIC DetectionLogic,\n\t\t_Inout_ NTSTATUS* InitializeStatus\n\t\t);\n\t~ThreadFilter(VOID);\n\n\n} THREAD_FILTER, *PTHREAD_FILTER;\n'PeaceMaker/PeaceMaker Kernel/IOCTLCommunication.cpp'\n:\n#include \"IOCTLCommunication.h\"\n\nPDRIVER_OBJECT IOCTLCommunication::DriverObject;\nPDETECTION_LOGIC IOCTLCommunication::Detector;\nPIMAGE_HISTORY_FILTER IOCTLCommunication::ImageProcessFilter;\nPFLT_FILTER IOCTLCommunication::FileFilterHandle;\nPFS_BLOCKING_FILTER IOCTLCommunication::FilesystemMonitor;\nPREGISTRY_BLOCKING_FILTER IOCTLCommunication::RegistryMonitor;\nPTHREAD_FILTER IOCTLCommunication::ThreadOperationFilter;\nPTAMPER_GUARD IOCTLCommunication::TamperGuardFilter;\n\n\nIOCTLCommunication::IOCTLCommunication (\n\t_In_ PDRIVER_OBJECT Driver,\n\t_In_ PUNICODE_STRING RegistryPath,\n\t_In_ PFLT_FILTER_UNLOAD_CALLBACK UnloadRoutine,\n\t_Inout_ NTSTATUS* InitializeStatus\n\t)\n{\n\tthis->DriverObject = Driver;\n\n\t*InitializeStatus = STATUS_SUCCESS;\n\n\n\n\n\tthis->Detector = new (NonPagedPool, DETECTION_LOGIC_TAG) DetectionLogic();\n\tif (this->Detector == NULL)\n\t{\n\t\tDBGPRINT(\"IOCTLCommunication!IOCTLCommunication: Failed to allocate space for detection logic.\");\n\t\t*InitializeStatus = STATUS_NO_MEMORY;\n\t\treturn;\n\t}\n\n\tthis->ImageProcessFilter = new (NonPagedPool, IMAGE_HISTORY_FILTER_TAG) ImageHistoryFilter(this->Detector, InitializeStatus);\n\tif (NT_SUCCESS(*InitializeStatus) == FALSE)\n\t{\n\t\tDBGPRINT(\"IOCTLCommunication!IOCTLCommunication: Failed to initialize image process history filter with status 0x%X.\", *InitializeStatus);\n\t\treturn;\n\t}\n\tif (this->ImageProcessFilter == NULL)\n\t{\n\t\tDBGPRINT(\"IOCTLCommunication!IOCTLCommunication: Failed to allocate space for image process history filter.\");\n\t\t*InitializeStatus = STATUS_NO_MEMORY;\n\t\treturn;\n\t}\n\n\tFilesystemMonitor = new (NonPagedPool, FILE_MONITOR_TAG) FSBlockingFilter(DriverObject, RegistryPath, UnloadRoutine, this->Detector, InitializeStatus, &FileFilterHandle);\n\tif (NT_SUCCESS(*InitializeStatus) == FALSE)\n\t{\n\t\tDBGPRINT(\"IOCTLCommunication!IOCTLCommunication: Failed to initialize the filesystem blocking filter with status 0x%X.\", *InitializeStatus);\n\t\treturn;\n\t}\n\n\tRegistryMonitor = new (NonPagedPool, REGISTRY_MONITOR_TAG) RegistryBlockingFilter(DriverObject, RegistryPath, this->Detector, InitializeStatus);\n\tif (NT_SUCCESS(*InitializeStatus) == FALSE)\n\t{\n\t\tDBGPRINT(\"IOCTLCommunication!IOCTLCommunication: Failed to initialize the registry blocking filter with status 0x%X.\", *InitializeStatus);\n\t\treturn;\n\t}\n\n\tthis->ThreadOperationFilter = new (NonPagedPool, THREAD_FILTER_TAG) ThreadFilter(this->Detector, InitializeStatus);\n\tif (NT_SUCCESS(*InitializeStatus) == FALSE)\n\t{\n\t\tDBGPRINT(\"IOCTLCommunication!IOCTLCommunication: Failed to initialize thread operation filters with status 0x%X.\", *InitializeStatus);\n\t\treturn;\n\t}\n\tif (this->ThreadOperationFilter == NULL)\n\t{\n\t\tDBGPRINT(\"IOCTLCommunication!IOCTLCommunication: Failed to allocate space for thread operation filters.\");\n\t\t*InitializeStatus = STATUS_NO_MEMORY;\n\t\treturn;\n\t}\n\n\tthis->TamperGuardFilter = new (NonPagedPool, TAMPER_GUARD_TAG) TamperGuard(InitializeStatus);\n\tif (NT_SUCCESS(*InitializeStatus) == FALSE)\n\t{\n\t\tDBGPRINT(\"IOCTLCommunication!IOCTLCommunication: Failed to initialize tamper guard with status 0x%X.\", *InitializeStatus);\n\t\treturn;\n\t}\n\n\tInitializeDriverIOCTL();\n}\n\n\nIOCTLCommunication::~IOCTLCommunication\t(\n\tVOID\n\t)\n{\n\tthis->Detector->~DetectionLogic();\n\tExFreePoolWithTag(this->Detector, DETECTION_LOGIC_TAG);\n\n\tthis->ImageProcessFilter->~ImageHistoryFilter();\n\tExFreePoolWithTag(this->ImageProcessFilter, IMAGE_HISTORY_FILTER_TAG);\n\n\tFltUnregisterFilter(FileFilterHandle);\n\n\tthis->FilesystemMonitor->~FSBlockingFilter();\n\tExFreePoolWithTag(this->FilesystemMonitor, FILE_MONITOR_TAG);\n\n\tthis->RegistryMonitor->~RegistryBlockingFilter();\n\tExFreePoolWithTag(this->RegistryMonitor, REGISTRY_MONITOR_TAG);\n\n\tthis->ThreadOperationFilter->~ThreadFilter();\n\tExFreePoolWithTag(this->ThreadOperationFilter, THREAD_FILTER_TAG);\n\n\tthis->TamperGuardFilter->~TamperGuard();\n\tExFreePoolWithTag(this->TamperGuardFilter, TAMPER_GUARD_TAG);\n\n\tUninitializeDriverIOCTL();\n}\n\n\nNTSTATUS\nIOCTLCommunication::IOCTLCreateClose (\n\t_In_ PDEVICE_OBJECT DeviceObject,\n\t_In_ PIRP Irp\n\t)\n{\n\tUNREFERENCED_PARAMETER(DeviceObject);\n\n\n\n\n\n\tIrp->IoStatus.Status = STATUS_SUCCESS;\n\tIrp->IoStatus.Information = 0;\n\n\tIoCompleteRequest(Irp, IO_NO_INCREMENT);\n\n\treturn STATUS_SUCCESS;\n}\n\n\nNTSTATUS\nIOCTLCommunication::IOCTLDeviceControl (\n\t_In_ PDEVICE_OBJECT DeviceObject,\n\t_In_ PIRP Irp\n\t)\n{\n\tNTSTATUS status;\n\tPIO_STACK_LOCATION irpStackLocation;\n\tULONG ioctlCode;\n\tULONG inputLength;\n\tULONG outputLength;\n\tULONG minimumLength;\n\tULONG writtenLength;\n\n\tPBASE_ALERT_INFO poppedAlert;\n\tPPROCESS_SUMMARY_REQUEST processSummaryRequest;\n\tPPROCESS_DETAILED_REQUEST processDetailedRequest;\n\tPSTRING_FILTER_REQUEST filterAddRequest;\n\tPLIST_FILTERS_REQUEST listFiltersRequest;\n\tPIMAGE_DETAILED_REQUEST imageDetailedRequest;\n\tPDELETE_FILTER_REQUEST deleteFilterRequest;\n\tPGLOBAL_SIZES globalSizes;\n\n\tWCHAR temporaryFilterBuffer[MAX_PATH];\n\n\tUNREFERENCED_PARAMETER(DeviceObject);\n\n\tstatus = STATUS_SUCCESS;\n\tirpStackLocation = IoGetCurrentIrpStackLocation(Irp);\n\n\n\n\n\tioctlCode = irpStackLocation->Parameters.DeviceIoControl.IoControlCode;\n\tinputLength = irpStackLocation->Parameters.DeviceIoControl.InputBufferLength;\n\toutputLength = irpStackLocation->Parameters.DeviceIoControl.OutputBufferLength;\n\twrittenLength = 0;\n\n\n\n\n\tIOCTLCommunication::TamperGuardFilter->UpdateProtectedProcess(PsGetCurrentProcessId());\n\n\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: ioctlCode = 0x%X, inputLength = 0x%X, outputLength = 0x%X\", ioctlCode, inputLength, outputLength);\n\n\n\n\n\tswitch (ioctlCode)\n\t{\n\tcase IOCTL_ALERTS_QUEUED:\n\t\tif (outputLength >= sizeof(BOOLEAN))\n\t\t{\n\n\n\n\t\t\t*RCAST<BOOLEAN*>(Irp->AssociatedIrp.SystemBuffer) = !IOCTLCommunication::Detector->GetAlertQueue()->IsQueueEmpty();\n\t\t\twrittenLength = sizeof(BOOLEAN);\n\t\t}\n\t\tbreak;\n\tcase IOCTL_POP_ALERT:\n\t\tif (outputLength < MAX_STACK_VIOLATION_ALERT_SIZE)\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_POP_ALERT but output buffer with size 0x%X smaller then minimum 0x%X.\", outputLength, MAX_STACK_VIOLATION_ALERT_SIZE);\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\n\n\n\t\tpoppedAlert = IOCTLCommunication::Detector->GetAlertQueue()->PopAlert();\n\t\tif (poppedAlert == NULL)\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_POP_ALERT but no alert to pop.\");\n\t\t\tstatus = STATUS_NOT_FOUND;\n\t\t\tgoto Exit;\n\t\t}\n\n\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Got alert 0x%llx for IOCTL_POP_ALERT with size 0x%llx.\\n\", poppedAlert, poppedAlert->AlertSize);\n\n\n\n\n\t\tmemcpy_s(Irp->AssociatedIrp.SystemBuffer, outputLength, poppedAlert, poppedAlert->AlertSize);\n\n\t\twrittenLength = poppedAlert->AlertSize;\n\n\n\n\n\t\tIOCTLCommunication::Detector->GetAlertQueue()->FreeAlert(poppedAlert);\n\t\tbreak;\n\tcase IOCTL_GET_PROCESSES:\n\t\tif (inputLength < sizeof(PROCESS_SUMMARY_REQUEST))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_GET_PROCESSES but input buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\n\n\n\n\t\tprocessSummaryRequest = RCAST<PPROCESS_SUMMARY_REQUEST>(Irp->AssociatedIrp.SystemBuffer);\n\t\tif (processSummaryRequest->ProcessHistorySize <= 0 || outputLength < MAX_PROCESS_SUMMARY_REQUEST_SIZE(processSummaryRequest))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_GET_PROCESSES but output buffer with size 0x%X smaller then minimum 0x%X.\", outputLength, MAX_PROCESS_SUMMARY_REQUEST_SIZE(processSummaryRequest));\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\n\n\n\n\t\tprocessSummaryRequest->ProcessHistorySize = IOCTLCommunication::ImageProcessFilter->GetProcessHistorySummary(processSummaryRequest->SkipCount, RCAST<PPROCESS_SUMMARY_ENTRY>(&processSummaryRequest->ProcessHistory[0]), processSummaryRequest->ProcessHistorySize);\n\t\twrittenLength = MAX_PROCESS_SUMMARY_REQUEST_SIZE(processSummaryRequest);\n\n\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: IOCTL_GET_PROCESSES found %i processes.\", processSummaryRequest->ProcessHistorySize);\n\t\tbreak;\n\tcase IOCTL_GET_PROCESS_DETAILED:\n\t\tif (inputLength < sizeof(PROCESS_DETAILED_REQUEST))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_GET_PROCESS_DETAILED but input buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\n\t\tprocessDetailedRequest = RCAST<PPROCESS_DETAILED_REQUEST>(Irp->AssociatedIrp.SystemBuffer);\n\n\t\tminimumLength = sizeof(PROCESS_DETAILED_REQUEST);\n\n\n\n\t\tif (outputLength < minimumLength)\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_GET_PROCESS_DETAILED but output buffer with size 0x%X smaller then minimum 0x%X.\", outputLength, minimumLength);\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\n\n\n\n\t\t__try\n\t\t{\n\t\t\tProbeForWrite(processDetailedRequest->ImageSummary, processDetailedRequest->ImageSummarySize * sizeof(IMAGE_SUMMARY), sizeof(ULONG));\n\t\t\tProbeForWrite(processDetailedRequest->StackHistory, processDetailedRequest->StackHistorySize * sizeof(STACK_RETURN_INFO), sizeof(ULONG));\n\t\t}\n\t\t__except (1)\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_GET_PROCESS_DETAILED but user buffers were invalid.\");\n\t\t\tstatus = STATUS_BAD_DATA;\n\t\t\tgoto Exit;\n\t\t}\n\n\n\n\n\t\tIOCTLCommunication::ImageProcessFilter->PopulateProcessDetailedRequest(processDetailedRequest);\n\t\twrittenLength = minimumLength;\n\t\tbreak;\n\tcase IOCTL_ADD_FILTER:\n\n\n\n\t\tif (inputLength < sizeof(STRING_FILTER_REQUEST))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_ADD_FILTER but input buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\t\tif (outputLength < sizeof(STRING_FILTER_REQUEST))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_ADD_FILTER but output buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\n\t\tfilterAddRequest = RCAST<PSTRING_FILTER_REQUEST>(Irp->AssociatedIrp.SystemBuffer);\n\n\n\n\n\t\tstatus = RtlStringCchCopyNW(temporaryFilterBuffer, MAX_PATH, filterAddRequest->Filter.MatchString, MAX_PATH);\n\t\tif (NT_SUCCESS(status) == FALSE)\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Failed to copy filter content to temporary buffer with status 0x%X.\", status);\n\t\t\tgoto Exit;\n\t\t}\n\n\n\n\n\t\tif (wcsnlen_s(temporaryFilterBuffer, MAX_PATH) == 0)\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Blocked empty filter.\");\n\t\t\tgoto Exit;\n\t\t}\n\n\n\n\n\t\tswitch (filterAddRequest->FilterType)\n\t\t{\n\t\tcase FilesystemFilter:\n\t\t\tfilterAddRequest->Filter.Id = FilesystemMonitor->GetStringFilters()->AddFilter(temporaryFilterBuffer, filterAddRequest->Filter.Flags);\n\t\t\tbreak;\n\t\tcase RegistryFilter:\n\t\t\tfilterAddRequest->Filter.Id = RegistryMonitor->GetStringFilters()->AddFilter(temporaryFilterBuffer, filterAddRequest->Filter.Flags);\n\t\t\tbreak;\n\t\t}\n\t\twrittenLength = sizeof(STRING_FILTER_REQUEST);\n\t\tbreak;\n\tcase IOCTL_LIST_FILTERS:\n\n\n\n\t\tif (inputLength < sizeof(LIST_FILTERS_REQUEST))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_LIST_FILTERS but input buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\t\tif (outputLength < sizeof(LIST_FILTERS_REQUEST))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_LIST_FILTERS but output buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\n\t\tlistFiltersRequest = RCAST<PLIST_FILTERS_REQUEST>(Irp->AssociatedIrp.SystemBuffer);\n\t\tswitch (listFiltersRequest->FilterType)\n\t\t{\n\t\tcase FilesystemFilter:\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Retrieving filesystem filters.\");\n\t\t\tlistFiltersRequest->CopiedFilters = FilesystemMonitor->GetStringFilters()->GetFilters(listFiltersRequest->SkipFilters, RCAST<PFILTER_INFO>(&listFiltersRequest->Filters), 10);\n\t\t\tbreak;\n\t\tcase RegistryFilter:\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Retrieving registry filters.\");\n\t\t\tlistFiltersRequest->CopiedFilters = RegistryMonitor->GetStringFilters()->GetFilters(listFiltersRequest->SkipFilters, RCAST<PFILTER_INFO>(&listFiltersRequest->Filters), 10);\n\t\t\tbreak;\n\t\t}\n\t\twrittenLength = sizeof(LIST_FILTERS_REQUEST);\n\t\tbreak;\n\tcase IOCTL_GET_PROCESS_SIZES:\n\n\n\n\t\tif (inputLength < sizeof(PROCESS_SIZES_REQUEST))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_GET_PROCESS_SIZES but input buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\t\tif (outputLength < sizeof(PROCESS_SIZES_REQUEST))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_GET_PROCESS_SIZES but output buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\n\t\tIOCTLCommunication::ImageProcessFilter->PopulateProcessSizes(RCAST<PPROCESS_SIZES_REQUEST>(Irp->AssociatedIrp.SystemBuffer));\n\t\twrittenLength = sizeof(PROCESS_SIZES_REQUEST);\n\t\tbreak;\n\tcase IOCTL_GET_IMAGE_DETAILED:\n\n\n\n\t\tif (inputLength < sizeof(IMAGE_DETAILED_REQUEST))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_GET_IMAGE_DETAILED but input buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\n\t\timageDetailedRequest = RCAST<PIMAGE_DETAILED_REQUEST>(Irp->AssociatedIrp.SystemBuffer);\n\t\tminimumLength = MAX_IMAGE_DETAILED_REQUEST_SIZE(imageDetailedRequest);\n\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: IOCTL_GET_IMAGE_DETAILED minimumLength = 0x%X.\", minimumLength);\n\n\t\tif (inputLength < minimumLength)\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_GET_IMAGE_DETAILED but input buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\t\tif (outputLength < minimumLength)\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_GET_IMAGE_DETAILED but output buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\t\tIOCTLCommunication::ImageProcessFilter->PopulateImageDetailedRequest(imageDetailedRequest);\n\t\twrittenLength = MAX_IMAGE_DETAILED_REQUEST_SIZE(imageDetailedRequest);\n\t\tbreak;\n\tcase IOCTL_GET_GLOBAL_SIZES:\n\n\n\n\t\tif (outputLength < sizeof(GLOBAL_SIZES))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_GET_GLOBAL_SIZES but output buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\n\t\tglobalSizes = RCAST<PGLOBAL_SIZES>(Irp->AssociatedIrp.SystemBuffer);\n\t\tglobalSizes->ProcessHistorySize = ImageHistoryFilter::ProcessHistorySize;\n\t\tglobalSizes->FilesystemFilterSize = FilesystemMonitor->GetStringFilters()->filtersCount;\n\t\tglobalSizes->RegistryFilterSize = RegistryMonitor->GetStringFilters()->filtersCount;\n\t\twrittenLength = sizeof(GLOBAL_SIZES);\n\t\tbreak;\n\tcase IOCTL_DELETE_FILTER:\n\n\n\n\t\tif (inputLength < sizeof(DELETE_FILTER_REQUEST))\n\t\t{\n\t\t\tDBGPRINT(\"IOCTLCommunication!IOCTLDeviceControl: Received IOCTL_DELETE_FILTER but input buffer is too small.\");\n\t\t\tstatus = STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tgoto Exit;\n\t\t}\n\n\t\tdeleteFilterRequest = RCAST<PDELETE_FILTER_REQUEST>(Irp->AssociatedIrp.SystemBuffer);\n\t\tswitch (deleteFilterRequest->FilterType)\n\t\t{\n\t\tcase FilesystemFilter:\n\t\t\tdeleteFilterRequest->Deleted = FilesystemMonitor->GetStringFilters()->RemoveFilter(deleteFilterRequest->FilterId);\n\t\t\tbreak;\n\t\tcase RegistryFilter:\n\t\t\tdeleteFilterRequest->Deleted = RegistryMonitor->GetStringFilters()->RemoveFilter(deleteFilterRequest->FilterId);\n\t\t\tbreak;\n\t\t}\n\t\twrittenLength = sizeof(DELETE_FILTER_REQUEST);\n\t\tbreak;\n\t}\n\nExit:\n\tIrp->IoStatus.Status = status;\n\tIrp->IoStatus.Information = writtenLength;\n\n\tIoCompleteRequest(Irp, IO_NO_INCREMENT);\n\n\treturn status;\n}\n\n\nNTSTATUS\nIOCTLCommunication::InitializeDriverIOCTL (\n\tVOID\n\t)\n{\n\tNTSTATUS status;\n\tUNICODE_STRING ioctlDeviceName;\n\tUNICODE_STRING ioctlDosDevicesName;\n\tPDEVICE_OBJECT ioctlDevice;\n\n\tRtlInitUnicodeString(&ioctlDeviceName, NT_DEVICE_NAME);\n\n\n\n\n\n\tstatus = IoCreateDevice(DriverObject, NULL, &ioctlDeviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, TRUE, &ioctlDevice);\n\tif (NT_SUCCESS(status) == FALSE)\n\t{\n\t\tDBGPRINT(\"IOCTLCommunication!InitializeDriverIOCTL: Failed to create kernel device object with error 0x%X.\", status);\n\t\tgoto Exit;\n\t}\n\n\n\n\n\tDriverObject->MajorFunction[IRP_MJ_CREATE] = IOCTLCreateClose;\n\tDriverObject->MajorFunction[IRP_MJ_CLOSE] = IOCTLCreateClose;\n\tDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IOCTLDeviceControl;\n\n\tRtlInitUnicodeString(&ioctlDosDevicesName, DOS_DEVICE_NAME);\n\n\tstatus = IoCreateSymbolicLink(&ioctlDosDevicesName, &ioctlDeviceName);\n\tif (NT_SUCCESS(status) == FALSE)\n\t{\n\t\tDBGPRINT(\"IOCTLCommunication!InitializeDriverIOCTL: Failed to create symbolic link to device with error 0x%X.\", status);\n\t\tIoDeleteDevice(ioctlDevice);\n\t\tgoto Exit;\n\t}\nExit:\n\treturn status;\n}\n\n\nVOID\nIOCTLCommunication::UninitializeDriverIOCTL (\n\tVOID\n\t)\n{\n\tPDEVICE_OBJECT deviceObject;\n\tUNICODE_STRING ioctlDosDevicesName;\n\n\tdeviceObject = DriverObject->DeviceObject;\n\n\n\n\n\tRtlInitUnicodeString(&ioctlDosDevicesName, DOS_DEVICE_NAME);\n\n\n\n\n\tIoDeleteSymbolicLink(&ioctlDosDevicesName);\n\tif (deviceObject != NULL)\n\t{\n\n\n\n\t\tIoDeleteDevice(deviceObject);\n\t}\n}\n'PeaceMaker/PeaceMaker Kernel/IOCTLCommunication.h'\n:\n#pragma once\n#include \"common.h\"\n#include \"DetectionLogic.h\"\n#include \"ImageHistoryFilter.h\"\n#include \"ThreadFilter.h\"\n#include \"FSFilter.h\"\n#include \"RegistryFilter.h\"\n#include \"TamperGuard.h\"\n\ntypedef class IOCTLCommunication\n{\n\tstatic PDRIVER_OBJECT DriverObject;\n\tstatic PDETECTION_LOGIC Detector;\n\tstatic PIMAGE_HISTORY_FILTER ImageProcessFilter;\n\tstatic PFLT_FILTER FileFilterHandle;\n\tstatic PFS_BLOCKING_FILTER FilesystemMonitor;\n\tstatic PREGISTRY_BLOCKING_FILTER RegistryMonitor;\n\tstatic PTHREAD_FILTER ThreadOperationFilter;\n\tstatic PTAMPER_GUARD TamperGuardFilter;\n\n\tNTSTATUS InitializeDriverIOCTL(VOID);\n\tVOID UninitializeDriverIOCTL(VOID);\n\n\tstatic NTSTATUS IOCTLCreateClose(\n\t\t_In_ PDEVICE_OBJECT DeviceObject,\n\t\t_In_ PIRP Irp\n\t\t);\n\tstatic NTSTATUS IOCTLDeviceControl(\n\t\t_In_ PDEVICE_OBJECT DeviceObject,\n\t\t_In_ PIRP Irp\n\t\t);\n\npublic:\n\tIOCTLCommunication(\n\t\t_In_ PDRIVER_OBJECT Driver,\n\t\t_In_ PUNICODE_STRING RegistryPath,\n\t\t_In_ PFLT_FILTER_UNLOAD_CALLBACK UnloadRoutine,\n\t\t_Inout_ NTSTATUS* InitializeStatus\n\t\t);\n\t~IOCTLCommunication(VOID);\n} IOCTL_COMMUNICATION, *PIOCTL_COMMUNICATION;\n\n#define DETECTION_LOGIC_TAG 'lDmP'\n#define IMAGE_HISTORY_FILTER_TAG 'fImP'\n#define FILE_MONITOR_TAG 'mFmP'\n#define REGISTRY_MONITOR_TAG 'mRmP'\n#define THREAD_FILTER_TAG 'fTmP'\n#define TAMPER_GUARD_TAG 'gTmP'",
        "gt": [
            "'PeaceMaker/PeaceMaker Kernel/ThreadFilter.h'",
            "'PeaceMaker/PeaceMaker Kernel/IOCTLCommunication.h'",
            "'PeaceMaker/PeaceMaker Kernel/IOCTLCommunication.cpp'"
        ]
    }
]